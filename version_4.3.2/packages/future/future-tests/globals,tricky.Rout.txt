
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:23:31.713] plan(): Setting new future strategy stack:
[13:23:31.714] List of future strategies:
[13:23:31.714] 1. sequential:
[13:23:31.714]    - args: function (..., envir = parent.frame())
[13:23:31.714]    - tweaked: FALSE
[13:23:31.714]    - call: future::plan("sequential")
[13:23:31.729] plan(): nbrOfWorkers() = 1
> library("listenv")
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Tricky use cases related to globals ...")
*** Tricky use cases related to globals ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   message("- Local variables with the same name as globals ...")
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     methods <- c("conservative", "ordered")
+     for (method in methods) {
+       options(future.globals.method = method)
+       message(sprintf("Method for identifying globals: '%s' ...", method))
+ 
+       a <- 3
+ 
+       yTruth <- local({
+         b <- a
+         a <- 2
+         a * b
+       })
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       }
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       a <- 3
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       } %lazy% TRUE
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         }
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         } %lazy% TRUE
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Assert that `a` is resolved and turned into a constant future
+       ## at the moment when future `b` is created.
+       ## Requires options(future.globals.resolve = TRUE).
+       a <- future(1)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+ 
+       ## BUG FIX: In future (<= 1.0.0) a global 'pkg' would be
+       ## overwritten by the name of the last package attached
+       ## by the future.
+       pkg <- "foo"
+       f <- sequential({ pkg })
+       v <- value(f)
+       message(sprintf("value(f) = %s", sQuote(v)))
+       stopifnot(pkg == "foo", v == "foo")
+       
+       message(sprintf("Method for identifying globals: '%s' ... DONE", method))
+     }
+ 
+     ## BUG FIX: In globals (<= 0.10.3) a global 'x' in LHS of an assignment
+     ## would be missed.
+     options(future.globals.method = "ordered")
+ 
+     ## A local
+     x <- 1
+     f <- future({ x <- 0; x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 1)
+     
+     ## A global
+     x <- 1
+     f <- future({ x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 2)
+ 
+     ## A global
+     x <- function() TRUE
+     f <- future({ x <- x(); x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == TRUE)
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- Local variables with the same name as globals ...
- plan('sequential') ...
[13:23:31.824] plan(): Setting new future strategy stack:
[13:23:31.824] List of future strategies:
[13:23:31.824] 1. sequential:
[13:23:31.824]    - args: function (..., envir = parent.frame())
[13:23:31.824]    - tweaked: FALSE
[13:23:31.824]    - call: plan(strategy)
[13:23:31.837] plan(): nbrOfWorkers() = 1
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:31.839] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:31.839] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:31.846] - globals found: [3] ‘{’, ‘<-’, ‘*’
[13:23:31.846] Searching for globals ... DONE
[13:23:31.846] Resolving globals: TRUE
[13:23:31.846] Resolving any globals that are futures ...
[13:23:31.846] - globals: [3] ‘{’, ‘<-’, ‘*’
[13:23:31.846] Resolving any globals that are futures ... DONE
[13:23:31.847] 
[13:23:31.847] 
[13:23:31.847] getGlobalsAndPackages() ... DONE
[13:23:31.848] run() for ‘Future’ ...
[13:23:31.848] - state: ‘created’
[13:23:31.848] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:31.849] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:31.849] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:31.849]   - Field: ‘label’
[13:23:31.849]   - Field: ‘local’
[13:23:31.849]   - Field: ‘owner’
[13:23:31.849]   - Field: ‘envir’
[13:23:31.849]   - Field: ‘packages’
[13:23:31.849]   - Field: ‘gc’
[13:23:31.849]   - Field: ‘conditions’
[13:23:31.850]   - Field: ‘expr’
[13:23:31.850]   - Field: ‘uuid’
[13:23:31.850]   - Field: ‘seed’
[13:23:31.850]   - Field: ‘version’
[13:23:31.850]   - Field: ‘result’
[13:23:31.850]   - Field: ‘asynchronous’
[13:23:31.850]   - Field: ‘calls’
[13:23:31.850]   - Field: ‘globals’
[13:23:31.850]   - Field: ‘stdout’
[13:23:31.850]   - Field: ‘earlySignal’
[13:23:31.850]   - Field: ‘lazy’
[13:23:31.851]   - Field: ‘state’
[13:23:31.851] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:31.851] - Launch lazy future ...
[13:23:31.852] Packages needed by the future expression (n = 0): <none>
[13:23:31.852] Packages needed by future strategies (n = 0): <none>
[13:23:31.853] {
[13:23:31.853]     {
[13:23:31.853]         {
[13:23:31.853]             ...future.startTime <- base::Sys.time()
[13:23:31.853]             {
[13:23:31.853]                 {
[13:23:31.853]                   {
[13:23:31.853]                     base::local({
[13:23:31.853]                       has_future <- base::requireNamespace("future", 
[13:23:31.853]                         quietly = TRUE)
[13:23:31.853]                       if (has_future) {
[13:23:31.853]                         ns <- base::getNamespace("future")
[13:23:31.853]                         version <- ns[[".package"]][["version"]]
[13:23:31.853]                         if (is.null(version)) 
[13:23:31.853]                           version <- utils::packageVersion("future")
[13:23:31.853]                       }
[13:23:31.853]                       else {
[13:23:31.853]                         version <- NULL
[13:23:31.853]                       }
[13:23:31.853]                       if (!has_future || version < "1.8.0") {
[13:23:31.853]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:31.853]                           "", base::R.version$version.string), 
[13:23:31.853]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:31.853]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:31.853]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:31.853]                             "release", "version")], collapse = " "), 
[13:23:31.853]                           hostname = base::Sys.info()[["nodename"]])
[13:23:31.853]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:31.853]                           info)
[13:23:31.853]                         info <- base::paste(info, collapse = "; ")
[13:23:31.853]                         if (!has_future) {
[13:23:31.853]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:31.853]                             info)
[13:23:31.853]                         }
[13:23:31.853]                         else {
[13:23:31.853]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:31.853]                             info, version)
[13:23:31.853]                         }
[13:23:31.853]                         base::stop(msg)
[13:23:31.853]                       }
[13:23:31.853]                     })
[13:23:31.853]                   }
[13:23:31.853]                   options(future.plan = NULL)
[13:23:31.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:31.853]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:31.853]                 }
[13:23:31.853]                 ...future.workdir <- getwd()
[13:23:31.853]             }
[13:23:31.853]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:31.853]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:31.853]         }
[13:23:31.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:31.853]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:31.853]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:31.853]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:31.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:31.853]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:31.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:31.853]             base::names(...future.oldOptions))
[13:23:31.853]     }
[13:23:31.853]     if (FALSE) {
[13:23:31.853]     }
[13:23:31.853]     else {
[13:23:31.853]         if (TRUE) {
[13:23:31.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:31.853]                 open = "w")
[13:23:31.853]         }
[13:23:31.853]         else {
[13:23:31.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:31.853]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:31.853]         }
[13:23:31.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:31.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:31.853]             base::sink(type = "output", split = FALSE)
[13:23:31.853]             base::close(...future.stdout)
[13:23:31.853]         }, add = TRUE)
[13:23:31.853]     }
[13:23:31.853]     ...future.frame <- base::sys.nframe()
[13:23:31.853]     ...future.conditions <- base::list()
[13:23:31.853]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:31.853]     if (FALSE) {
[13:23:31.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:31.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:31.853]     }
[13:23:31.853]     ...future.result <- base::tryCatch({
[13:23:31.853]         base::withCallingHandlers({
[13:23:31.853]             ...future.value <- base::withVisible(base::local({
[13:23:31.853]                 b <- a
[13:23:31.853]                 a <- 2
[13:23:31.853]                 a * b
[13:23:31.853]             }))
[13:23:31.853]             future::FutureResult(value = ...future.value$value, 
[13:23:31.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:31.853]                   ...future.rng), globalenv = if (FALSE) 
[13:23:31.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:31.853]                     ...future.globalenv.names))
[13:23:31.853]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:31.853]         }, condition = base::local({
[13:23:31.853]             c <- base::c
[13:23:31.853]             inherits <- base::inherits
[13:23:31.853]             invokeRestart <- base::invokeRestart
[13:23:31.853]             length <- base::length
[13:23:31.853]             list <- base::list
[13:23:31.853]             seq.int <- base::seq.int
[13:23:31.853]             signalCondition <- base::signalCondition
[13:23:31.853]             sys.calls <- base::sys.calls
[13:23:31.853]             `[[` <- base::`[[`
[13:23:31.853]             `+` <- base::`+`
[13:23:31.853]             `<<-` <- base::`<<-`
[13:23:31.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:31.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:31.853]                   3L)]
[13:23:31.853]             }
[13:23:31.853]             function(cond) {
[13:23:31.853]                 is_error <- inherits(cond, "error")
[13:23:31.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:31.853]                   NULL)
[13:23:31.853]                 if (is_error) {
[13:23:31.853]                   sessionInformation <- function() {
[13:23:31.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:31.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:31.853]                       search = base::search(), system = base::Sys.info())
[13:23:31.853]                   }
[13:23:31.853]                   ...future.conditions[[length(...future.conditions) + 
[13:23:31.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:31.853]                     cond$call), session = sessionInformation(), 
[13:23:31.853]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:31.853]                   signalCondition(cond)
[13:23:31.853]                 }
[13:23:31.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:31.853]                 "immediateCondition"))) {
[13:23:31.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:31.853]                   ...future.conditions[[length(...future.conditions) + 
[13:23:31.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:31.853]                   if (TRUE && !signal) {
[13:23:31.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:31.853]                     {
[13:23:31.853]                       inherits <- base::inherits
[13:23:31.853]                       invokeRestart <- base::invokeRestart
[13:23:31.853]                       is.null <- base::is.null
[13:23:31.853]                       muffled <- FALSE
[13:23:31.853]                       if (inherits(cond, "message")) {
[13:23:31.853]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:31.853]                         if (muffled) 
[13:23:31.853]                           invokeRestart("muffleMessage")
[13:23:31.853]                       }
[13:23:31.853]                       else if (inherits(cond, "warning")) {
[13:23:31.853]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:31.853]                         if (muffled) 
[13:23:31.853]                           invokeRestart("muffleWarning")
[13:23:31.853]                       }
[13:23:31.853]                       else if (inherits(cond, "condition")) {
[13:23:31.853]                         if (!is.null(pattern)) {
[13:23:31.853]                           computeRestarts <- base::computeRestarts
[13:23:31.853]                           grepl <- base::grepl
[13:23:31.853]                           restarts <- computeRestarts(cond)
[13:23:31.853]                           for (restart in restarts) {
[13:23:31.853]                             name <- restart$name
[13:23:31.853]                             if (is.null(name)) 
[13:23:31.853]                               next
[13:23:31.853]                             if (!grepl(pattern, name)) 
[13:23:31.853]                               next
[13:23:31.853]                             invokeRestart(restart)
[13:23:31.853]                             muffled <- TRUE
[13:23:31.853]                             break
[13:23:31.853]                           }
[13:23:31.853]                         }
[13:23:31.853]                       }
[13:23:31.853]                       invisible(muffled)
[13:23:31.853]                     }
[13:23:31.853]                     muffleCondition(cond, pattern = "^muffle")
[13:23:31.853]                   }
[13:23:31.853]                 }
[13:23:31.853]                 else {
[13:23:31.853]                   if (TRUE) {
[13:23:31.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:31.853]                     {
[13:23:31.853]                       inherits <- base::inherits
[13:23:31.853]                       invokeRestart <- base::invokeRestart
[13:23:31.853]                       is.null <- base::is.null
[13:23:31.853]                       muffled <- FALSE
[13:23:31.853]                       if (inherits(cond, "message")) {
[13:23:31.853]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:31.853]                         if (muffled) 
[13:23:31.853]                           invokeRestart("muffleMessage")
[13:23:31.853]                       }
[13:23:31.853]                       else if (inherits(cond, "warning")) {
[13:23:31.853]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:31.853]                         if (muffled) 
[13:23:31.853]                           invokeRestart("muffleWarning")
[13:23:31.853]                       }
[13:23:31.853]                       else if (inherits(cond, "condition")) {
[13:23:31.853]                         if (!is.null(pattern)) {
[13:23:31.853]                           computeRestarts <- base::computeRestarts
[13:23:31.853]                           grepl <- base::grepl
[13:23:31.853]                           restarts <- computeRestarts(cond)
[13:23:31.853]                           for (restart in restarts) {
[13:23:31.853]                             name <- restart$name
[13:23:31.853]                             if (is.null(name)) 
[13:23:31.853]                               next
[13:23:31.853]                             if (!grepl(pattern, name)) 
[13:23:31.853]                               next
[13:23:31.853]                             invokeRestart(restart)
[13:23:31.853]                             muffled <- TRUE
[13:23:31.853]                             break
[13:23:31.853]                           }
[13:23:31.853]                         }
[13:23:31.853]                       }
[13:23:31.853]                       invisible(muffled)
[13:23:31.853]                     }
[13:23:31.853]                     muffleCondition(cond, pattern = "^muffle")
[13:23:31.853]                   }
[13:23:31.853]                 }
[13:23:31.853]             }
[13:23:31.853]         }))
[13:23:31.853]     }, error = function(ex) {
[13:23:31.853]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:31.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:31.853]                 ...future.rng), started = ...future.startTime, 
[13:23:31.853]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:31.853]             version = "1.8"), class = "FutureResult")
[13:23:31.853]     }, finally = {
[13:23:31.853]         if (!identical(...future.workdir, getwd())) 
[13:23:31.853]             setwd(...future.workdir)
[13:23:31.853]         {
[13:23:31.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:31.853]                 ...future.oldOptions$nwarnings <- NULL
[13:23:31.853]             }
[13:23:31.853]             base::options(...future.oldOptions)
[13:23:31.853]             if (.Platform$OS.type == "windows") {
[13:23:31.853]                 old_names <- names(...future.oldEnvVars)
[13:23:31.853]                 envs <- base::Sys.getenv()
[13:23:31.853]                 names <- names(envs)
[13:23:31.853]                 common <- intersect(names, old_names)
[13:23:31.853]                 added <- setdiff(names, old_names)
[13:23:31.853]                 removed <- setdiff(old_names, names)
[13:23:31.853]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:31.853]                   envs[common]]
[13:23:31.853]                 NAMES <- toupper(changed)
[13:23:31.853]                 args <- list()
[13:23:31.853]                 for (kk in seq_along(NAMES)) {
[13:23:31.853]                   name <- changed[[kk]]
[13:23:31.853]                   NAME <- NAMES[[kk]]
[13:23:31.853]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:31.853]                     next
[13:23:31.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:31.853]                 }
[13:23:31.853]                 NAMES <- toupper(added)
[13:23:31.853]                 for (kk in seq_along(NAMES)) {
[13:23:31.853]                   name <- added[[kk]]
[13:23:31.853]                   NAME <- NAMES[[kk]]
[13:23:31.853]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:31.853]                     next
[13:23:31.853]                   args[[name]] <- ""
[13:23:31.853]                 }
[13:23:31.853]                 NAMES <- toupper(removed)
[13:23:31.853]                 for (kk in seq_along(NAMES)) {
[13:23:31.853]                   name <- removed[[kk]]
[13:23:31.853]                   NAME <- NAMES[[kk]]
[13:23:31.853]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:31.853]                     next
[13:23:31.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:31.853]                 }
[13:23:31.853]                 if (length(args) > 0) 
[13:23:31.853]                   base::do.call(base::Sys.setenv, args = args)
[13:23:31.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:31.853]             }
[13:23:31.853]             else {
[13:23:31.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:31.853]             }
[13:23:31.853]             {
[13:23:31.853]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:31.853]                   0L) {
[13:23:31.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:31.853]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:31.853]                   base::options(opts)
[13:23:31.853]                 }
[13:23:31.853]                 {
[13:23:31.853]                   {
[13:23:31.853]                     NULL
[13:23:31.853]                     RNGkind("Mersenne-Twister")
[13:23:31.853]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:31.853]                       inherits = FALSE)
[13:23:31.853]                   }
[13:23:31.853]                   options(future.plan = NULL)
[13:23:31.853]                   if (is.na(NA_character_)) 
[13:23:31.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:31.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:31.853]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:31.853]                   {
[13:23:31.853]                     future <- SequentialFuture(..., envir = envir)
[13:23:31.853]                     if (!future$lazy) 
[13:23:31.853]                       future <- run(future)
[13:23:31.853]                     invisible(future)
[13:23:31.853]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:31.853]                 }
[13:23:31.853]             }
[13:23:31.853]         }
[13:23:31.853]     })
[13:23:31.853]     if (TRUE) {
[13:23:31.853]         base::sink(type = "output", split = FALSE)
[13:23:31.853]         if (TRUE) {
[13:23:31.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:31.853]         }
[13:23:31.853]         else {
[13:23:31.853]             ...future.result["stdout"] <- base::list(NULL)
[13:23:31.853]         }
[13:23:31.853]         base::close(...future.stdout)
[13:23:31.853]         ...future.stdout <- NULL
[13:23:31.853]     }
[13:23:31.853]     ...future.result$conditions <- ...future.conditions
[13:23:31.853]     ...future.result$finished <- base::Sys.time()
[13:23:31.853]     ...future.result
[13:23:31.853] }
[13:23:31.855] plan(): Setting new future strategy stack:
[13:23:31.855] List of future strategies:
[13:23:31.855] 1. sequential:
[13:23:31.855]    - args: function (..., envir = parent.frame())
[13:23:31.855]    - tweaked: FALSE
[13:23:31.855]    - call: NULL
[13:23:31.855] plan(): nbrOfWorkers() = 1
[13:23:31.856] plan(): Setting new future strategy stack:
[13:23:31.856] List of future strategies:
[13:23:31.856] 1. sequential:
[13:23:31.856]    - args: function (..., envir = parent.frame())
[13:23:31.856]    - tweaked: FALSE
[13:23:31.856]    - call: plan(strategy)
[13:23:31.857] plan(): nbrOfWorkers() = 1
[13:23:31.857] SequentialFuture started (and completed)
[13:23:31.858] - Launch lazy future ... done
[13:23:31.858] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:31.859] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:31.859] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:31.860] - globals found: [3] ‘{’, ‘<-’, ‘*’
[13:23:31.860] Searching for globals ... DONE
[13:23:31.860] Resolving globals: TRUE
[13:23:31.860] Resolving any globals that are futures ...
[13:23:31.861] - globals: [3] ‘{’, ‘<-’, ‘*’
[13:23:31.861] Resolving any globals that are futures ... DONE
[13:23:31.861] 
[13:23:31.861] 
[13:23:31.861] getGlobalsAndPackages() ... DONE
[13:23:31.864] run() for ‘Future’ ...
[13:23:31.864] - state: ‘created’
[13:23:31.864] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:31.865] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:31.865] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:31.865]   - Field: ‘label’
[13:23:31.865]   - Field: ‘local’
[13:23:31.865]   - Field: ‘owner’
[13:23:31.865]   - Field: ‘envir’
[13:23:31.865]   - Field: ‘packages’
[13:23:31.865]   - Field: ‘gc’
[13:23:31.865]   - Field: ‘conditions’
[13:23:31.866]   - Field: ‘expr’
[13:23:31.866]   - Field: ‘uuid’
[13:23:31.866]   - Field: ‘seed’
[13:23:31.866]   - Field: ‘version’
[13:23:31.866]   - Field: ‘result’
[13:23:31.866]   - Field: ‘asynchronous’
[13:23:31.866]   - Field: ‘calls’
[13:23:31.866]   - Field: ‘globals’
[13:23:31.866]   - Field: ‘stdout’
[13:23:31.866]   - Field: ‘earlySignal’
[13:23:31.866]   - Field: ‘lazy’
[13:23:31.867]   - Field: ‘state’
[13:23:31.867] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:31.867] - Launch lazy future ...
[13:23:31.867] Packages needed by the future expression (n = 0): <none>
[13:23:31.867] Packages needed by future strategies (n = 0): <none>
[13:23:31.867] {
[13:23:31.867]     {
[13:23:31.867]         {
[13:23:31.867]             ...future.startTime <- base::Sys.time()
[13:23:31.867]             {
[13:23:31.867]                 {
[13:23:31.867]                   {
[13:23:31.867]                     base::local({
[13:23:31.867]                       has_future <- base::requireNamespace("future", 
[13:23:31.867]                         quietly = TRUE)
[13:23:31.867]                       if (has_future) {
[13:23:31.867]                         ns <- base::getNamespace("future")
[13:23:31.867]                         version <- ns[[".package"]][["version"]]
[13:23:31.867]                         if (is.null(version)) 
[13:23:31.867]                           version <- utils::packageVersion("future")
[13:23:31.867]                       }
[13:23:31.867]                       else {
[13:23:31.867]                         version <- NULL
[13:23:31.867]                       }
[13:23:31.867]                       if (!has_future || version < "1.8.0") {
[13:23:31.867]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:31.867]                           "", base::R.version$version.string), 
[13:23:31.867]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:31.867]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:31.867]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:31.867]                             "release", "version")], collapse = " "), 
[13:23:31.867]                           hostname = base::Sys.info()[["nodename"]])
[13:23:31.867]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:31.867]                           info)
[13:23:31.867]                         info <- base::paste(info, collapse = "; ")
[13:23:31.867]                         if (!has_future) {
[13:23:31.867]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:31.867]                             info)
[13:23:31.867]                         }
[13:23:31.867]                         else {
[13:23:31.867]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:31.867]                             info, version)
[13:23:31.867]                         }
[13:23:31.867]                         base::stop(msg)
[13:23:31.867]                       }
[13:23:31.867]                     })
[13:23:31.867]                   }
[13:23:31.867]                   options(future.plan = NULL)
[13:23:31.867]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:31.867]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:31.867]                 }
[13:23:31.867]                 ...future.workdir <- getwd()
[13:23:31.867]             }
[13:23:31.867]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:31.867]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:31.867]         }
[13:23:31.867]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:31.867]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:31.867]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:31.867]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:31.867]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:31.867]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:31.867]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:31.867]             base::names(...future.oldOptions))
[13:23:31.867]     }
[13:23:31.867]     if (FALSE) {
[13:23:31.867]     }
[13:23:31.867]     else {
[13:23:31.867]         if (TRUE) {
[13:23:31.867]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:31.867]                 open = "w")
[13:23:31.867]         }
[13:23:31.867]         else {
[13:23:31.867]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:31.867]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:31.867]         }
[13:23:31.867]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:31.867]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:31.867]             base::sink(type = "output", split = FALSE)
[13:23:31.867]             base::close(...future.stdout)
[13:23:31.867]         }, add = TRUE)
[13:23:31.867]     }
[13:23:31.867]     ...future.frame <- base::sys.nframe()
[13:23:31.867]     ...future.conditions <- base::list()
[13:23:31.867]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:31.867]     if (FALSE) {
[13:23:31.867]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:31.867]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:31.867]     }
[13:23:31.867]     ...future.result <- base::tryCatch({
[13:23:31.867]         base::withCallingHandlers({
[13:23:31.867]             ...future.value <- base::withVisible(base::local({
[13:23:31.867]                 b <- a
[13:23:31.867]                 a <- 2
[13:23:31.867]                 a * b
[13:23:31.867]             }))
[13:23:31.867]             future::FutureResult(value = ...future.value$value, 
[13:23:31.867]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:31.867]                   ...future.rng), globalenv = if (FALSE) 
[13:23:31.867]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:31.867]                     ...future.globalenv.names))
[13:23:31.867]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:31.867]         }, condition = base::local({
[13:23:31.867]             c <- base::c
[13:23:31.867]             inherits <- base::inherits
[13:23:31.867]             invokeRestart <- base::invokeRestart
[13:23:31.867]             length <- base::length
[13:23:31.867]             list <- base::list
[13:23:31.867]             seq.int <- base::seq.int
[13:23:31.867]             signalCondition <- base::signalCondition
[13:23:31.867]             sys.calls <- base::sys.calls
[13:23:31.867]             `[[` <- base::`[[`
[13:23:31.867]             `+` <- base::`+`
[13:23:31.867]             `<<-` <- base::`<<-`
[13:23:31.867]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:31.867]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:31.867]                   3L)]
[13:23:31.867]             }
[13:23:31.867]             function(cond) {
[13:23:31.867]                 is_error <- inherits(cond, "error")
[13:23:31.867]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:31.867]                   NULL)
[13:23:31.867]                 if (is_error) {
[13:23:31.867]                   sessionInformation <- function() {
[13:23:31.867]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:31.867]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:31.867]                       search = base::search(), system = base::Sys.info())
[13:23:31.867]                   }
[13:23:31.867]                   ...future.conditions[[length(...future.conditions) + 
[13:23:31.867]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:31.867]                     cond$call), session = sessionInformation(), 
[13:23:31.867]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:31.867]                   signalCondition(cond)
[13:23:31.867]                 }
[13:23:31.867]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:31.867]                 "immediateCondition"))) {
[13:23:31.867]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:31.867]                   ...future.conditions[[length(...future.conditions) + 
[13:23:31.867]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:31.867]                   if (TRUE && !signal) {
[13:23:31.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:31.867]                     {
[13:23:31.867]                       inherits <- base::inherits
[13:23:31.867]                       invokeRestart <- base::invokeRestart
[13:23:31.867]                       is.null <- base::is.null
[13:23:31.867]                       muffled <- FALSE
[13:23:31.867]                       if (inherits(cond, "message")) {
[13:23:31.867]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:31.867]                         if (muffled) 
[13:23:31.867]                           invokeRestart("muffleMessage")
[13:23:31.867]                       }
[13:23:31.867]                       else if (inherits(cond, "warning")) {
[13:23:31.867]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:31.867]                         if (muffled) 
[13:23:31.867]                           invokeRestart("muffleWarning")
[13:23:31.867]                       }
[13:23:31.867]                       else if (inherits(cond, "condition")) {
[13:23:31.867]                         if (!is.null(pattern)) {
[13:23:31.867]                           computeRestarts <- base::computeRestarts
[13:23:31.867]                           grepl <- base::grepl
[13:23:31.867]                           restarts <- computeRestarts(cond)
[13:23:31.867]                           for (restart in restarts) {
[13:23:31.867]                             name <- restart$name
[13:23:31.867]                             if (is.null(name)) 
[13:23:31.867]                               next
[13:23:31.867]                             if (!grepl(pattern, name)) 
[13:23:31.867]                               next
[13:23:31.867]                             invokeRestart(restart)
[13:23:31.867]                             muffled <- TRUE
[13:23:31.867]                             break
[13:23:31.867]                           }
[13:23:31.867]                         }
[13:23:31.867]                       }
[13:23:31.867]                       invisible(muffled)
[13:23:31.867]                     }
[13:23:31.867]                     muffleCondition(cond, pattern = "^muffle")
[13:23:31.867]                   }
[13:23:31.867]                 }
[13:23:31.867]                 else {
[13:23:31.867]                   if (TRUE) {
[13:23:31.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:31.867]                     {
[13:23:31.867]                       inherits <- base::inherits
[13:23:31.867]                       invokeRestart <- base::invokeRestart
[13:23:31.867]                       is.null <- base::is.null
[13:23:31.867]                       muffled <- FALSE
[13:23:31.867]                       if (inherits(cond, "message")) {
[13:23:31.867]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:31.867]                         if (muffled) 
[13:23:31.867]                           invokeRestart("muffleMessage")
[13:23:31.867]                       }
[13:23:31.867]                       else if (inherits(cond, "warning")) {
[13:23:31.867]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:31.867]                         if (muffled) 
[13:23:31.867]                           invokeRestart("muffleWarning")
[13:23:31.867]                       }
[13:23:31.867]                       else if (inherits(cond, "condition")) {
[13:23:31.867]                         if (!is.null(pattern)) {
[13:23:31.867]                           computeRestarts <- base::computeRestarts
[13:23:31.867]                           grepl <- base::grepl
[13:23:31.867]                           restarts <- computeRestarts(cond)
[13:23:31.867]                           for (restart in restarts) {
[13:23:31.867]                             name <- restart$name
[13:23:31.867]                             if (is.null(name)) 
[13:23:31.867]                               next
[13:23:31.867]                             if (!grepl(pattern, name)) 
[13:23:31.867]                               next
[13:23:31.867]                             invokeRestart(restart)
[13:23:31.867]                             muffled <- TRUE
[13:23:31.867]                             break
[13:23:31.867]                           }
[13:23:31.867]                         }
[13:23:31.867]                       }
[13:23:31.867]                       invisible(muffled)
[13:23:31.867]                     }
[13:23:31.867]                     muffleCondition(cond, pattern = "^muffle")
[13:23:31.867]                   }
[13:23:31.867]                 }
[13:23:31.867]             }
[13:23:31.867]         }))
[13:23:31.867]     }, error = function(ex) {
[13:23:31.867]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:31.867]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:31.867]                 ...future.rng), started = ...future.startTime, 
[13:23:31.867]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:31.867]             version = "1.8"), class = "FutureResult")
[13:23:31.867]     }, finally = {
[13:23:31.867]         if (!identical(...future.workdir, getwd())) 
[13:23:31.867]             setwd(...future.workdir)
[13:23:31.867]         {
[13:23:31.867]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:31.867]                 ...future.oldOptions$nwarnings <- NULL
[13:23:31.867]             }
[13:23:31.867]             base::options(...future.oldOptions)
[13:23:31.867]             if (.Platform$OS.type == "windows") {
[13:23:31.867]                 old_names <- names(...future.oldEnvVars)
[13:23:31.867]                 envs <- base::Sys.getenv()
[13:23:31.867]                 names <- names(envs)
[13:23:31.867]                 common <- intersect(names, old_names)
[13:23:31.867]                 added <- setdiff(names, old_names)
[13:23:31.867]                 removed <- setdiff(old_names, names)
[13:23:31.867]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:31.867]                   envs[common]]
[13:23:31.867]                 NAMES <- toupper(changed)
[13:23:31.867]                 args <- list()
[13:23:31.867]                 for (kk in seq_along(NAMES)) {
[13:23:31.867]                   name <- changed[[kk]]
[13:23:31.867]                   NAME <- NAMES[[kk]]
[13:23:31.867]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:31.867]                     next
[13:23:31.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:31.867]                 }
[13:23:31.867]                 NAMES <- toupper(added)
[13:23:31.867]                 for (kk in seq_along(NAMES)) {
[13:23:31.867]                   name <- added[[kk]]
[13:23:31.867]                   NAME <- NAMES[[kk]]
[13:23:31.867]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:31.867]                     next
[13:23:31.867]                   args[[name]] <- ""
[13:23:31.867]                 }
[13:23:31.867]                 NAMES <- toupper(removed)
[13:23:31.867]                 for (kk in seq_along(NAMES)) {
[13:23:31.867]                   name <- removed[[kk]]
[13:23:31.867]                   NAME <- NAMES[[kk]]
[13:23:31.867]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:31.867]                     next
[13:23:31.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:31.867]                 }
[13:23:31.867]                 if (length(args) > 0) 
[13:23:31.867]                   base::do.call(base::Sys.setenv, args = args)
[13:23:31.867]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:31.867]             }
[13:23:31.867]             else {
[13:23:31.867]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:31.867]             }
[13:23:31.867]             {
[13:23:31.867]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:31.867]                   0L) {
[13:23:31.867]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:31.867]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:31.867]                   base::options(opts)
[13:23:31.867]                 }
[13:23:31.867]                 {
[13:23:31.867]                   {
[13:23:31.867]                     NULL
[13:23:31.867]                     RNGkind("Mersenne-Twister")
[13:23:31.867]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:31.867]                       inherits = FALSE)
[13:23:31.867]                   }
[13:23:31.867]                   options(future.plan = NULL)
[13:23:31.867]                   if (is.na(NA_character_)) 
[13:23:31.867]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:31.867]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:31.867]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:31.867]                   {
[13:23:31.867]                     future <- SequentialFuture(..., envir = envir)
[13:23:31.867]                     if (!future$lazy) 
[13:23:31.867]                       future <- run(future)
[13:23:31.867]                     invisible(future)
[13:23:31.867]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:31.867]                 }
[13:23:31.867]             }
[13:23:31.867]         }
[13:23:31.867]     })
[13:23:31.867]     if (TRUE) {
[13:23:31.867]         base::sink(type = "output", split = FALSE)
[13:23:31.867]         if (TRUE) {
[13:23:31.867]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:31.867]         }
[13:23:31.867]         else {
[13:23:31.867]             ...future.result["stdout"] <- base::list(NULL)
[13:23:31.867]         }
[13:23:31.867]         base::close(...future.stdout)
[13:23:31.867]         ...future.stdout <- NULL
[13:23:31.867]     }
[13:23:31.867]     ...future.result$conditions <- ...future.conditions
[13:23:31.867]     ...future.result$finished <- base::Sys.time()
[13:23:31.867]     ...future.result
[13:23:31.867] }
[13:23:31.869] plan(): Setting new future strategy stack:
[13:23:31.869] List of future strategies:
[13:23:31.869] 1. sequential:
[13:23:31.869]    - args: function (..., envir = parent.frame())
[13:23:31.869]    - tweaked: FALSE
[13:23:31.869]    - call: NULL
[13:23:31.870] plan(): nbrOfWorkers() = 1
[13:23:31.871] plan(): Setting new future strategy stack:
[13:23:31.871] List of future strategies:
[13:23:31.871] 1. sequential:
[13:23:31.871]    - args: function (..., envir = parent.frame())
[13:23:31.871]    - tweaked: FALSE
[13:23:31.871]    - call: plan(strategy)
[13:23:31.871] plan(): nbrOfWorkers() = 1
[13:23:31.872] SequentialFuture started (and completed)
[13:23:31.872] signalConditions() ...
[13:23:31.872]  - include = ‘immediateCondition’
[13:23:31.872]  - exclude = 
[13:23:31.872]  - resignal = FALSE
[13:23:31.872]  - Number of conditions: 1
[13:23:31.872] signalConditions() ... done
[13:23:31.872] - Launch lazy future ... done
[13:23:31.872] run() for ‘SequentialFuture’ ... done
[13:23:31.873] signalConditions() ...
[13:23:31.873]  - include = ‘immediateCondition’
[13:23:31.873]  - exclude = 
[13:23:31.873]  - resignal = FALSE
[13:23:31.873]  - Number of conditions: 1
[13:23:31.873] signalConditions() ... done
[13:23:31.873] Future state: ‘finished’
[13:23:31.873] signalConditions() ...
[13:23:31.873]  - include = ‘condition’
[13:23:31.873]  - exclude = ‘immediateCondition’
[13:23:31.873]  - resignal = TRUE
[13:23:31.874]  - Number of conditions: 1
[13:23:31.874]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:23:31.874] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "47b98e4ec3a9" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:23:31"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:31.891] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:31.891] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:31.892] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:31.893] Searching for globals ... DONE
[13:23:31.893] Resolving globals: TRUE
[13:23:31.893] Resolving any globals that are futures ...
[13:23:31.893] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:31.893] Resolving any globals that are futures ... DONE
[13:23:31.893] Resolving futures part of globals (recursively) ...
[13:23:31.896] resolve() on list ...
[13:23:31.896]  recursive: 99
[13:23:31.897]  length: 1
[13:23:31.897]  elements: ‘ii’
[13:23:31.897]  length: 0 (resolved future 1)
[13:23:31.897] resolve() on list ... DONE
[13:23:31.897] - globals: [1] ‘ii’
[13:23:31.897] Resolving futures part of globals (recursively) ... DONE
[13:23:31.898] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:31.898] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:31.898] - globals: [1] ‘ii’
[13:23:31.898] 
[13:23:31.898] getGlobalsAndPackages() ... DONE
[13:23:31.899] run() for ‘Future’ ...
[13:23:31.899] - state: ‘created’
[13:23:31.899] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:31.899] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:31.899] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:31.900]   - Field: ‘label’
[13:23:31.900]   - Field: ‘local’
[13:23:31.900]   - Field: ‘owner’
[13:23:31.900]   - Field: ‘envir’
[13:23:31.900]   - Field: ‘packages’
[13:23:31.900]   - Field: ‘gc’
[13:23:31.900]   - Field: ‘conditions’
[13:23:31.900]   - Field: ‘expr’
[13:23:31.900]   - Field: ‘uuid’
[13:23:31.900]   - Field: ‘seed’
[13:23:31.901]   - Field: ‘version’
[13:23:31.901]   - Field: ‘result’
[13:23:31.901]   - Field: ‘asynchronous’
[13:23:31.901]   - Field: ‘calls’
[13:23:31.901]   - Field: ‘globals’
[13:23:31.901]   - Field: ‘stdout’
[13:23:31.901]   - Field: ‘earlySignal’
[13:23:31.901]   - Field: ‘lazy’
[13:23:31.901]   - Field: ‘state’
[13:23:31.901] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:31.901] - Launch lazy future ...
[13:23:31.902] Packages needed by the future expression (n = 0): <none>
[13:23:31.902] Packages needed by future strategies (n = 0): <none>
[13:23:31.902] {
[13:23:31.902]     {
[13:23:31.902]         {
[13:23:31.902]             ...future.startTime <- base::Sys.time()
[13:23:31.902]             {
[13:23:31.902]                 {
[13:23:31.902]                   {
[13:23:31.902]                     base::local({
[13:23:31.902]                       has_future <- base::requireNamespace("future", 
[13:23:31.902]                         quietly = TRUE)
[13:23:31.902]                       if (has_future) {
[13:23:31.902]                         ns <- base::getNamespace("future")
[13:23:31.902]                         version <- ns[[".package"]][["version"]]
[13:23:31.902]                         if (is.null(version)) 
[13:23:31.902]                           version <- utils::packageVersion("future")
[13:23:31.902]                       }
[13:23:31.902]                       else {
[13:23:31.902]                         version <- NULL
[13:23:31.902]                       }
[13:23:31.902]                       if (!has_future || version < "1.8.0") {
[13:23:31.902]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:31.902]                           "", base::R.version$version.string), 
[13:23:31.902]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:31.902]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:31.902]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:31.902]                             "release", "version")], collapse = " "), 
[13:23:31.902]                           hostname = base::Sys.info()[["nodename"]])
[13:23:31.902]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:31.902]                           info)
[13:23:31.902]                         info <- base::paste(info, collapse = "; ")
[13:23:31.902]                         if (!has_future) {
[13:23:31.902]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:31.902]                             info)
[13:23:31.902]                         }
[13:23:31.902]                         else {
[13:23:31.902]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:31.902]                             info, version)
[13:23:31.902]                         }
[13:23:31.902]                         base::stop(msg)
[13:23:31.902]                       }
[13:23:31.902]                     })
[13:23:31.902]                   }
[13:23:31.902]                   options(future.plan = NULL)
[13:23:31.902]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:31.902]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:31.902]                 }
[13:23:31.902]                 ...future.workdir <- getwd()
[13:23:31.902]             }
[13:23:31.902]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:31.902]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:31.902]         }
[13:23:31.902]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:31.902]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:31.902]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:31.902]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:31.902]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:31.902]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:31.902]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:31.902]             base::names(...future.oldOptions))
[13:23:31.902]     }
[13:23:31.902]     if (FALSE) {
[13:23:31.902]     }
[13:23:31.902]     else {
[13:23:31.902]         if (TRUE) {
[13:23:31.902]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:31.902]                 open = "w")
[13:23:31.902]         }
[13:23:31.902]         else {
[13:23:31.902]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:31.902]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:31.902]         }
[13:23:31.902]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:31.902]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:31.902]             base::sink(type = "output", split = FALSE)
[13:23:31.902]             base::close(...future.stdout)
[13:23:31.902]         }, add = TRUE)
[13:23:31.902]     }
[13:23:31.902]     ...future.frame <- base::sys.nframe()
[13:23:31.902]     ...future.conditions <- base::list()
[13:23:31.902]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:31.902]     if (FALSE) {
[13:23:31.902]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:31.902]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:31.902]     }
[13:23:31.902]     ...future.result <- base::tryCatch({
[13:23:31.902]         base::withCallingHandlers({
[13:23:31.902]             ...future.value <- base::withVisible(base::local({
[13:23:31.902]                 b <- a * ii
[13:23:31.902]                 a <- 0
[13:23:31.902]                 b
[13:23:31.902]             }))
[13:23:31.902]             future::FutureResult(value = ...future.value$value, 
[13:23:31.902]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:31.902]                   ...future.rng), globalenv = if (FALSE) 
[13:23:31.902]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:31.902]                     ...future.globalenv.names))
[13:23:31.902]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:31.902]         }, condition = base::local({
[13:23:31.902]             c <- base::c
[13:23:31.902]             inherits <- base::inherits
[13:23:31.902]             invokeRestart <- base::invokeRestart
[13:23:31.902]             length <- base::length
[13:23:31.902]             list <- base::list
[13:23:31.902]             seq.int <- base::seq.int
[13:23:31.902]             signalCondition <- base::signalCondition
[13:23:31.902]             sys.calls <- base::sys.calls
[13:23:31.902]             `[[` <- base::`[[`
[13:23:31.902]             `+` <- base::`+`
[13:23:31.902]             `<<-` <- base::`<<-`
[13:23:31.902]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:31.902]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:31.902]                   3L)]
[13:23:31.902]             }
[13:23:31.902]             function(cond) {
[13:23:31.902]                 is_error <- inherits(cond, "error")
[13:23:31.902]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:31.902]                   NULL)
[13:23:31.902]                 if (is_error) {
[13:23:31.902]                   sessionInformation <- function() {
[13:23:31.902]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:31.902]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:31.902]                       search = base::search(), system = base::Sys.info())
[13:23:31.902]                   }
[13:23:31.902]                   ...future.conditions[[length(...future.conditions) + 
[13:23:31.902]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:31.902]                     cond$call), session = sessionInformation(), 
[13:23:31.902]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:31.902]                   signalCondition(cond)
[13:23:31.902]                 }
[13:23:31.902]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:31.902]                 "immediateCondition"))) {
[13:23:31.902]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:31.902]                   ...future.conditions[[length(...future.conditions) + 
[13:23:31.902]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:31.902]                   if (TRUE && !signal) {
[13:23:31.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:31.902]                     {
[13:23:31.902]                       inherits <- base::inherits
[13:23:31.902]                       invokeRestart <- base::invokeRestart
[13:23:31.902]                       is.null <- base::is.null
[13:23:31.902]                       muffled <- FALSE
[13:23:31.902]                       if (inherits(cond, "message")) {
[13:23:31.902]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:31.902]                         if (muffled) 
[13:23:31.902]                           invokeRestart("muffleMessage")
[13:23:31.902]                       }
[13:23:31.902]                       else if (inherits(cond, "warning")) {
[13:23:31.902]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:31.902]                         if (muffled) 
[13:23:31.902]                           invokeRestart("muffleWarning")
[13:23:31.902]                       }
[13:23:31.902]                       else if (inherits(cond, "condition")) {
[13:23:31.902]                         if (!is.null(pattern)) {
[13:23:31.902]                           computeRestarts <- base::computeRestarts
[13:23:31.902]                           grepl <- base::grepl
[13:23:31.902]                           restarts <- computeRestarts(cond)
[13:23:31.902]                           for (restart in restarts) {
[13:23:31.902]                             name <- restart$name
[13:23:31.902]                             if (is.null(name)) 
[13:23:31.902]                               next
[13:23:31.902]                             if (!grepl(pattern, name)) 
[13:23:31.902]                               next
[13:23:31.902]                             invokeRestart(restart)
[13:23:31.902]                             muffled <- TRUE
[13:23:31.902]                             break
[13:23:31.902]                           }
[13:23:31.902]                         }
[13:23:31.902]                       }
[13:23:31.902]                       invisible(muffled)
[13:23:31.902]                     }
[13:23:31.902]                     muffleCondition(cond, pattern = "^muffle")
[13:23:31.902]                   }
[13:23:31.902]                 }
[13:23:31.902]                 else {
[13:23:31.902]                   if (TRUE) {
[13:23:31.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:31.902]                     {
[13:23:31.902]                       inherits <- base::inherits
[13:23:31.902]                       invokeRestart <- base::invokeRestart
[13:23:31.902]                       is.null <- base::is.null
[13:23:31.902]                       muffled <- FALSE
[13:23:31.902]                       if (inherits(cond, "message")) {
[13:23:31.902]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:31.902]                         if (muffled) 
[13:23:31.902]                           invokeRestart("muffleMessage")
[13:23:31.902]                       }
[13:23:31.902]                       else if (inherits(cond, "warning")) {
[13:23:31.902]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:31.902]                         if (muffled) 
[13:23:31.902]                           invokeRestart("muffleWarning")
[13:23:31.902]                       }
[13:23:31.902]                       else if (inherits(cond, "condition")) {
[13:23:31.902]                         if (!is.null(pattern)) {
[13:23:31.902]                           computeRestarts <- base::computeRestarts
[13:23:31.902]                           grepl <- base::grepl
[13:23:31.902]                           restarts <- computeRestarts(cond)
[13:23:31.902]                           for (restart in restarts) {
[13:23:31.902]                             name <- restart$name
[13:23:31.902]                             if (is.null(name)) 
[13:23:31.902]                               next
[13:23:31.902]                             if (!grepl(pattern, name)) 
[13:23:31.902]                               next
[13:23:31.902]                             invokeRestart(restart)
[13:23:31.902]                             muffled <- TRUE
[13:23:31.902]                             break
[13:23:31.902]                           }
[13:23:31.902]                         }
[13:23:31.902]                       }
[13:23:31.902]                       invisible(muffled)
[13:23:31.902]                     }
[13:23:31.902]                     muffleCondition(cond, pattern = "^muffle")
[13:23:31.902]                   }
[13:23:31.902]                 }
[13:23:31.902]             }
[13:23:31.902]         }))
[13:23:31.902]     }, error = function(ex) {
[13:23:31.902]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:31.902]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:31.902]                 ...future.rng), started = ...future.startTime, 
[13:23:31.902]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:31.902]             version = "1.8"), class = "FutureResult")
[13:23:31.902]     }, finally = {
[13:23:31.902]         if (!identical(...future.workdir, getwd())) 
[13:23:31.902]             setwd(...future.workdir)
[13:23:31.902]         {
[13:23:31.902]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:31.902]                 ...future.oldOptions$nwarnings <- NULL
[13:23:31.902]             }
[13:23:31.902]             base::options(...future.oldOptions)
[13:23:31.902]             if (.Platform$OS.type == "windows") {
[13:23:31.902]                 old_names <- names(...future.oldEnvVars)
[13:23:31.902]                 envs <- base::Sys.getenv()
[13:23:31.902]                 names <- names(envs)
[13:23:31.902]                 common <- intersect(names, old_names)
[13:23:31.902]                 added <- setdiff(names, old_names)
[13:23:31.902]                 removed <- setdiff(old_names, names)
[13:23:31.902]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:31.902]                   envs[common]]
[13:23:31.902]                 NAMES <- toupper(changed)
[13:23:31.902]                 args <- list()
[13:23:31.902]                 for (kk in seq_along(NAMES)) {
[13:23:31.902]                   name <- changed[[kk]]
[13:23:31.902]                   NAME <- NAMES[[kk]]
[13:23:31.902]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:31.902]                     next
[13:23:31.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:31.902]                 }
[13:23:31.902]                 NAMES <- toupper(added)
[13:23:31.902]                 for (kk in seq_along(NAMES)) {
[13:23:31.902]                   name <- added[[kk]]
[13:23:31.902]                   NAME <- NAMES[[kk]]
[13:23:31.902]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:31.902]                     next
[13:23:31.902]                   args[[name]] <- ""
[13:23:31.902]                 }
[13:23:31.902]                 NAMES <- toupper(removed)
[13:23:31.902]                 for (kk in seq_along(NAMES)) {
[13:23:31.902]                   name <- removed[[kk]]
[13:23:31.902]                   NAME <- NAMES[[kk]]
[13:23:31.902]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:31.902]                     next
[13:23:31.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:31.902]                 }
[13:23:31.902]                 if (length(args) > 0) 
[13:23:31.902]                   base::do.call(base::Sys.setenv, args = args)
[13:23:31.902]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:31.902]             }
[13:23:31.902]             else {
[13:23:31.902]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:31.902]             }
[13:23:31.902]             {
[13:23:31.902]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:31.902]                   0L) {
[13:23:31.902]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:31.902]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:31.902]                   base::options(opts)
[13:23:31.902]                 }
[13:23:31.902]                 {
[13:23:31.902]                   {
[13:23:31.902]                     NULL
[13:23:31.902]                     RNGkind("Mersenne-Twister")
[13:23:31.902]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:31.902]                       inherits = FALSE)
[13:23:31.902]                   }
[13:23:31.902]                   options(future.plan = NULL)
[13:23:31.902]                   if (is.na(NA_character_)) 
[13:23:31.902]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:31.902]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:31.902]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:31.902]                   {
[13:23:31.902]                     future <- SequentialFuture(..., envir = envir)
[13:23:31.902]                     if (!future$lazy) 
[13:23:31.902]                       future <- run(future)
[13:23:31.902]                     invisible(future)
[13:23:31.902]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:31.902]                 }
[13:23:31.902]             }
[13:23:31.902]         }
[13:23:31.902]     })
[13:23:31.902]     if (TRUE) {
[13:23:31.902]         base::sink(type = "output", split = FALSE)
[13:23:31.902]         if (TRUE) {
[13:23:31.902]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:31.902]         }
[13:23:31.902]         else {
[13:23:31.902]             ...future.result["stdout"] <- base::list(NULL)
[13:23:31.902]         }
[13:23:31.902]         base::close(...future.stdout)
[13:23:31.902]         ...future.stdout <- NULL
[13:23:31.902]     }
[13:23:31.902]     ...future.result$conditions <- ...future.conditions
[13:23:31.902]     ...future.result$finished <- base::Sys.time()
[13:23:31.902]     ...future.result
[13:23:31.902] }
[13:23:31.904] assign_globals() ...
[13:23:31.904] List of 1
[13:23:31.904]  $ ii: int 1
[13:23:31.904]  - attr(*, "where")=List of 1
[13:23:31.904]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:31.904]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:31.904]  - attr(*, "resolved")= logi TRUE
[13:23:31.904]  - attr(*, "total_size")= num 56
[13:23:31.904]  - attr(*, "already-done")= logi TRUE
[13:23:31.907] - copied ‘ii’ to environment
[13:23:31.907] assign_globals() ... done
[13:23:31.907] plan(): Setting new future strategy stack:
[13:23:31.907] List of future strategies:
[13:23:31.907] 1. sequential:
[13:23:31.907]    - args: function (..., envir = parent.frame())
[13:23:31.907]    - tweaked: FALSE
[13:23:31.907]    - call: NULL
[13:23:31.908] plan(): nbrOfWorkers() = 1
[13:23:31.908] plan(): Setting new future strategy stack:
[13:23:31.909] List of future strategies:
[13:23:31.909] 1. sequential:
[13:23:31.909]    - args: function (..., envir = parent.frame())
[13:23:31.909]    - tweaked: FALSE
[13:23:31.909]    - call: plan(strategy)
[13:23:31.909] plan(): nbrOfWorkers() = 1
[13:23:31.909] SequentialFuture started (and completed)
[13:23:31.909] - Launch lazy future ... done
[13:23:31.909] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:31.910] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:31.910] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:31.911] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:31.912] Searching for globals ... DONE
[13:23:31.912] Resolving globals: TRUE
[13:23:31.912] Resolving any globals that are futures ...
[13:23:31.912] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:31.912] Resolving any globals that are futures ... DONE
[13:23:31.912] Resolving futures part of globals (recursively) ...
[13:23:31.913] resolve() on list ...
[13:23:31.913]  recursive: 99
[13:23:31.913]  length: 1
[13:23:31.913]  elements: ‘ii’
[13:23:31.913]  length: 0 (resolved future 1)
[13:23:31.913] resolve() on list ... DONE
[13:23:31.913] - globals: [1] ‘ii’
[13:23:31.913] Resolving futures part of globals (recursively) ... DONE
[13:23:31.913] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:31.914] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:31.914] - globals: [1] ‘ii’
[13:23:31.914] 
[13:23:31.914] getGlobalsAndPackages() ... DONE
[13:23:31.914] run() for ‘Future’ ...
[13:23:31.914] - state: ‘created’
[13:23:31.915] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:31.915] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:31.915] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:31.915]   - Field: ‘label’
[13:23:31.915]   - Field: ‘local’
[13:23:31.915]   - Field: ‘owner’
[13:23:31.915]   - Field: ‘envir’
[13:23:31.915]   - Field: ‘packages’
[13:23:31.916]   - Field: ‘gc’
[13:23:31.916]   - Field: ‘conditions’
[13:23:31.916]   - Field: ‘expr’
[13:23:31.916]   - Field: ‘uuid’
[13:23:31.916]   - Field: ‘seed’
[13:23:31.916]   - Field: ‘version’
[13:23:31.916]   - Field: ‘result’
[13:23:31.916]   - Field: ‘asynchronous’
[13:23:31.916]   - Field: ‘calls’
[13:23:31.916]   - Field: ‘globals’
[13:23:31.917]   - Field: ‘stdout’
[13:23:31.917]   - Field: ‘earlySignal’
[13:23:31.917]   - Field: ‘lazy’
[13:23:31.917]   - Field: ‘state’
[13:23:31.917] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:31.917] - Launch lazy future ...
[13:23:31.917] Packages needed by the future expression (n = 0): <none>
[13:23:31.917] Packages needed by future strategies (n = 0): <none>
[13:23:31.918] {
[13:23:31.918]     {
[13:23:31.918]         {
[13:23:31.918]             ...future.startTime <- base::Sys.time()
[13:23:31.918]             {
[13:23:31.918]                 {
[13:23:31.918]                   {
[13:23:31.918]                     base::local({
[13:23:31.918]                       has_future <- base::requireNamespace("future", 
[13:23:31.918]                         quietly = TRUE)
[13:23:31.918]                       if (has_future) {
[13:23:31.918]                         ns <- base::getNamespace("future")
[13:23:31.918]                         version <- ns[[".package"]][["version"]]
[13:23:31.918]                         if (is.null(version)) 
[13:23:31.918]                           version <- utils::packageVersion("future")
[13:23:31.918]                       }
[13:23:31.918]                       else {
[13:23:31.918]                         version <- NULL
[13:23:31.918]                       }
[13:23:31.918]                       if (!has_future || version < "1.8.0") {
[13:23:31.918]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:31.918]                           "", base::R.version$version.string), 
[13:23:31.918]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:31.918]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:31.918]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:31.918]                             "release", "version")], collapse = " "), 
[13:23:31.918]                           hostname = base::Sys.info()[["nodename"]])
[13:23:31.918]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:31.918]                           info)
[13:23:31.918]                         info <- base::paste(info, collapse = "; ")
[13:23:31.918]                         if (!has_future) {
[13:23:31.918]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:31.918]                             info)
[13:23:31.918]                         }
[13:23:31.918]                         else {
[13:23:31.918]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:31.918]                             info, version)
[13:23:31.918]                         }
[13:23:31.918]                         base::stop(msg)
[13:23:31.918]                       }
[13:23:31.918]                     })
[13:23:31.918]                   }
[13:23:31.918]                   options(future.plan = NULL)
[13:23:31.918]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:31.918]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:31.918]                 }
[13:23:31.918]                 ...future.workdir <- getwd()
[13:23:31.918]             }
[13:23:31.918]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:31.918]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:31.918]         }
[13:23:31.918]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:31.918]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:31.918]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:31.918]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:31.918]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:31.918]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:31.918]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:31.918]             base::names(...future.oldOptions))
[13:23:31.918]     }
[13:23:31.918]     if (FALSE) {
[13:23:31.918]     }
[13:23:31.918]     else {
[13:23:31.918]         if (TRUE) {
[13:23:31.918]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:31.918]                 open = "w")
[13:23:31.918]         }
[13:23:31.918]         else {
[13:23:31.918]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:31.918]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:31.918]         }
[13:23:31.918]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:31.918]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:31.918]             base::sink(type = "output", split = FALSE)
[13:23:31.918]             base::close(...future.stdout)
[13:23:31.918]         }, add = TRUE)
[13:23:31.918]     }
[13:23:31.918]     ...future.frame <- base::sys.nframe()
[13:23:31.918]     ...future.conditions <- base::list()
[13:23:31.918]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:31.918]     if (FALSE) {
[13:23:31.918]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:31.918]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:31.918]     }
[13:23:31.918]     ...future.result <- base::tryCatch({
[13:23:31.918]         base::withCallingHandlers({
[13:23:31.918]             ...future.value <- base::withVisible(base::local({
[13:23:31.918]                 b <- a * ii
[13:23:31.918]                 a <- 0
[13:23:31.918]                 b
[13:23:31.918]             }))
[13:23:31.918]             future::FutureResult(value = ...future.value$value, 
[13:23:31.918]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:31.918]                   ...future.rng), globalenv = if (FALSE) 
[13:23:31.918]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:31.918]                     ...future.globalenv.names))
[13:23:31.918]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:31.918]         }, condition = base::local({
[13:23:31.918]             c <- base::c
[13:23:31.918]             inherits <- base::inherits
[13:23:31.918]             invokeRestart <- base::invokeRestart
[13:23:31.918]             length <- base::length
[13:23:31.918]             list <- base::list
[13:23:31.918]             seq.int <- base::seq.int
[13:23:31.918]             signalCondition <- base::signalCondition
[13:23:31.918]             sys.calls <- base::sys.calls
[13:23:31.918]             `[[` <- base::`[[`
[13:23:31.918]             `+` <- base::`+`
[13:23:31.918]             `<<-` <- base::`<<-`
[13:23:31.918]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:31.918]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:31.918]                   3L)]
[13:23:31.918]             }
[13:23:31.918]             function(cond) {
[13:23:31.918]                 is_error <- inherits(cond, "error")
[13:23:31.918]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:31.918]                   NULL)
[13:23:31.918]                 if (is_error) {
[13:23:31.918]                   sessionInformation <- function() {
[13:23:31.918]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:31.918]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:31.918]                       search = base::search(), system = base::Sys.info())
[13:23:31.918]                   }
[13:23:31.918]                   ...future.conditions[[length(...future.conditions) + 
[13:23:31.918]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:31.918]                     cond$call), session = sessionInformation(), 
[13:23:31.918]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:31.918]                   signalCondition(cond)
[13:23:31.918]                 }
[13:23:31.918]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:31.918]                 "immediateCondition"))) {
[13:23:31.918]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:31.918]                   ...future.conditions[[length(...future.conditions) + 
[13:23:31.918]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:31.918]                   if (TRUE && !signal) {
[13:23:31.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:31.918]                     {
[13:23:31.918]                       inherits <- base::inherits
[13:23:31.918]                       invokeRestart <- base::invokeRestart
[13:23:31.918]                       is.null <- base::is.null
[13:23:31.918]                       muffled <- FALSE
[13:23:31.918]                       if (inherits(cond, "message")) {
[13:23:31.918]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:31.918]                         if (muffled) 
[13:23:31.918]                           invokeRestart("muffleMessage")
[13:23:31.918]                       }
[13:23:31.918]                       else if (inherits(cond, "warning")) {
[13:23:31.918]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:31.918]                         if (muffled) 
[13:23:31.918]                           invokeRestart("muffleWarning")
[13:23:31.918]                       }
[13:23:31.918]                       else if (inherits(cond, "condition")) {
[13:23:31.918]                         if (!is.null(pattern)) {
[13:23:31.918]                           computeRestarts <- base::computeRestarts
[13:23:31.918]                           grepl <- base::grepl
[13:23:31.918]                           restarts <- computeRestarts(cond)
[13:23:31.918]                           for (restart in restarts) {
[13:23:31.918]                             name <- restart$name
[13:23:31.918]                             if (is.null(name)) 
[13:23:31.918]                               next
[13:23:31.918]                             if (!grepl(pattern, name)) 
[13:23:31.918]                               next
[13:23:31.918]                             invokeRestart(restart)
[13:23:31.918]                             muffled <- TRUE
[13:23:31.918]                             break
[13:23:31.918]                           }
[13:23:31.918]                         }
[13:23:31.918]                       }
[13:23:31.918]                       invisible(muffled)
[13:23:31.918]                     }
[13:23:31.918]                     muffleCondition(cond, pattern = "^muffle")
[13:23:31.918]                   }
[13:23:31.918]                 }
[13:23:31.918]                 else {
[13:23:31.918]                   if (TRUE) {
[13:23:31.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:31.918]                     {
[13:23:31.918]                       inherits <- base::inherits
[13:23:31.918]                       invokeRestart <- base::invokeRestart
[13:23:31.918]                       is.null <- base::is.null
[13:23:31.918]                       muffled <- FALSE
[13:23:31.918]                       if (inherits(cond, "message")) {
[13:23:31.918]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:31.918]                         if (muffled) 
[13:23:31.918]                           invokeRestart("muffleMessage")
[13:23:31.918]                       }
[13:23:31.918]                       else if (inherits(cond, "warning")) {
[13:23:31.918]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:31.918]                         if (muffled) 
[13:23:31.918]                           invokeRestart("muffleWarning")
[13:23:31.918]                       }
[13:23:31.918]                       else if (inherits(cond, "condition")) {
[13:23:31.918]                         if (!is.null(pattern)) {
[13:23:31.918]                           computeRestarts <- base::computeRestarts
[13:23:31.918]                           grepl <- base::grepl
[13:23:31.918]                           restarts <- computeRestarts(cond)
[13:23:31.918]                           for (restart in restarts) {
[13:23:31.918]                             name <- restart$name
[13:23:31.918]                             if (is.null(name)) 
[13:23:31.918]                               next
[13:23:31.918]                             if (!grepl(pattern, name)) 
[13:23:31.918]                               next
[13:23:31.918]                             invokeRestart(restart)
[13:23:31.918]                             muffled <- TRUE
[13:23:31.918]                             break
[13:23:31.918]                           }
[13:23:31.918]                         }
[13:23:31.918]                       }
[13:23:31.918]                       invisible(muffled)
[13:23:31.918]                     }
[13:23:31.918]                     muffleCondition(cond, pattern = "^muffle")
[13:23:31.918]                   }
[13:23:31.918]                 }
[13:23:31.918]             }
[13:23:31.918]         }))
[13:23:31.918]     }, error = function(ex) {
[13:23:31.918]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:31.918]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:31.918]                 ...future.rng), started = ...future.startTime, 
[13:23:31.918]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:31.918]             version = "1.8"), class = "FutureResult")
[13:23:31.918]     }, finally = {
[13:23:31.918]         if (!identical(...future.workdir, getwd())) 
[13:23:31.918]             setwd(...future.workdir)
[13:23:31.918]         {
[13:23:31.918]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:31.918]                 ...future.oldOptions$nwarnings <- NULL
[13:23:31.918]             }
[13:23:31.918]             base::options(...future.oldOptions)
[13:23:31.918]             if (.Platform$OS.type == "windows") {
[13:23:31.918]                 old_names <- names(...future.oldEnvVars)
[13:23:31.918]                 envs <- base::Sys.getenv()
[13:23:31.918]                 names <- names(envs)
[13:23:31.918]                 common <- intersect(names, old_names)
[13:23:31.918]                 added <- setdiff(names, old_names)
[13:23:31.918]                 removed <- setdiff(old_names, names)
[13:23:31.918]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:31.918]                   envs[common]]
[13:23:31.918]                 NAMES <- toupper(changed)
[13:23:31.918]                 args <- list()
[13:23:31.918]                 for (kk in seq_along(NAMES)) {
[13:23:31.918]                   name <- changed[[kk]]
[13:23:31.918]                   NAME <- NAMES[[kk]]
[13:23:31.918]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:31.918]                     next
[13:23:31.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:31.918]                 }
[13:23:31.918]                 NAMES <- toupper(added)
[13:23:31.918]                 for (kk in seq_along(NAMES)) {
[13:23:31.918]                   name <- added[[kk]]
[13:23:31.918]                   NAME <- NAMES[[kk]]
[13:23:31.918]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:31.918]                     next
[13:23:31.918]                   args[[name]] <- ""
[13:23:31.918]                 }
[13:23:31.918]                 NAMES <- toupper(removed)
[13:23:31.918]                 for (kk in seq_along(NAMES)) {
[13:23:31.918]                   name <- removed[[kk]]
[13:23:31.918]                   NAME <- NAMES[[kk]]
[13:23:31.918]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:31.918]                     next
[13:23:31.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:31.918]                 }
[13:23:31.918]                 if (length(args) > 0) 
[13:23:31.918]                   base::do.call(base::Sys.setenv, args = args)
[13:23:31.918]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:31.918]             }
[13:23:31.918]             else {
[13:23:31.918]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:31.918]             }
[13:23:31.918]             {
[13:23:31.918]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:31.918]                   0L) {
[13:23:31.918]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:31.918]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:31.918]                   base::options(opts)
[13:23:31.918]                 }
[13:23:31.918]                 {
[13:23:31.918]                   {
[13:23:31.918]                     NULL
[13:23:31.918]                     RNGkind("Mersenne-Twister")
[13:23:31.918]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:31.918]                       inherits = FALSE)
[13:23:31.918]                   }
[13:23:31.918]                   options(future.plan = NULL)
[13:23:31.918]                   if (is.na(NA_character_)) 
[13:23:31.918]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:31.918]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:31.918]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:31.918]                   {
[13:23:31.918]                     future <- SequentialFuture(..., envir = envir)
[13:23:31.918]                     if (!future$lazy) 
[13:23:31.918]                       future <- run(future)
[13:23:31.918]                     invisible(future)
[13:23:31.918]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:31.918]                 }
[13:23:31.918]             }
[13:23:31.918]         }
[13:23:31.918]     })
[13:23:31.918]     if (TRUE) {
[13:23:31.918]         base::sink(type = "output", split = FALSE)
[13:23:31.918]         if (TRUE) {
[13:23:31.918]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:31.918]         }
[13:23:31.918]         else {
[13:23:31.918]             ...future.result["stdout"] <- base::list(NULL)
[13:23:31.918]         }
[13:23:31.918]         base::close(...future.stdout)
[13:23:31.918]         ...future.stdout <- NULL
[13:23:31.918]     }
[13:23:31.918]     ...future.result$conditions <- ...future.conditions
[13:23:31.918]     ...future.result$finished <- base::Sys.time()
[13:23:31.918]     ...future.result
[13:23:31.918] }
[13:23:31.919] assign_globals() ...
[13:23:31.920] List of 1
[13:23:31.920]  $ ii: int 2
[13:23:31.920]  - attr(*, "where")=List of 1
[13:23:31.920]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:31.920]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:31.920]  - attr(*, "resolved")= logi TRUE
[13:23:31.920]  - attr(*, "total_size")= num 56
[13:23:31.920]  - attr(*, "already-done")= logi TRUE
[13:23:31.922] - copied ‘ii’ to environment
[13:23:31.922] assign_globals() ... done
[13:23:31.922] plan(): Setting new future strategy stack:
[13:23:31.923] List of future strategies:
[13:23:31.923] 1. sequential:
[13:23:31.923]    - args: function (..., envir = parent.frame())
[13:23:31.923]    - tweaked: FALSE
[13:23:31.923]    - call: NULL
[13:23:31.923] plan(): nbrOfWorkers() = 1
[13:23:31.924] plan(): Setting new future strategy stack:
[13:23:31.924] List of future strategies:
[13:23:31.924] 1. sequential:
[13:23:31.924]    - args: function (..., envir = parent.frame())
[13:23:31.924]    - tweaked: FALSE
[13:23:31.924]    - call: plan(strategy)
[13:23:31.924] plan(): nbrOfWorkers() = 1
[13:23:31.924] SequentialFuture started (and completed)
[13:23:31.925] - Launch lazy future ... done
[13:23:31.925] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:31.925] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:31.925] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:31.929] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:31.929] Searching for globals ... DONE
[13:23:31.929] Resolving globals: TRUE
[13:23:31.929] Resolving any globals that are futures ...
[13:23:31.929] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:31.929] Resolving any globals that are futures ... DONE
[13:23:31.929] Resolving futures part of globals (recursively) ...
[13:23:31.930] resolve() on list ...
[13:23:31.930]  recursive: 99
[13:23:31.930]  length: 1
[13:23:31.930]  elements: ‘ii’
[13:23:31.930]  length: 0 (resolved future 1)
[13:23:31.930] resolve() on list ... DONE
[13:23:31.930] - globals: [1] ‘ii’
[13:23:31.930] Resolving futures part of globals (recursively) ... DONE
[13:23:31.931] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:31.931] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:31.931] - globals: [1] ‘ii’
[13:23:31.931] 
[13:23:31.931] getGlobalsAndPackages() ... DONE
[13:23:31.931] run() for ‘Future’ ...
[13:23:31.932] - state: ‘created’
[13:23:31.932] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:31.932] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:31.932] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:31.932]   - Field: ‘label’
[13:23:31.932]   - Field: ‘local’
[13:23:31.932]   - Field: ‘owner’
[13:23:31.933]   - Field: ‘envir’
[13:23:31.933]   - Field: ‘packages’
[13:23:31.933]   - Field: ‘gc’
[13:23:31.933]   - Field: ‘conditions’
[13:23:31.933]   - Field: ‘expr’
[13:23:31.933]   - Field: ‘uuid’
[13:23:31.933]   - Field: ‘seed’
[13:23:31.933]   - Field: ‘version’
[13:23:31.933]   - Field: ‘result’
[13:23:31.933]   - Field: ‘asynchronous’
[13:23:31.934]   - Field: ‘calls’
[13:23:31.934]   - Field: ‘globals’
[13:23:31.934]   - Field: ‘stdout’
[13:23:31.934]   - Field: ‘earlySignal’
[13:23:31.934]   - Field: ‘lazy’
[13:23:31.934]   - Field: ‘state’
[13:23:31.934] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:31.934] - Launch lazy future ...
[13:23:31.934] Packages needed by the future expression (n = 0): <none>
[13:23:31.935] Packages needed by future strategies (n = 0): <none>
[13:23:31.935] {
[13:23:31.935]     {
[13:23:31.935]         {
[13:23:31.935]             ...future.startTime <- base::Sys.time()
[13:23:31.935]             {
[13:23:31.935]                 {
[13:23:31.935]                   {
[13:23:31.935]                     base::local({
[13:23:31.935]                       has_future <- base::requireNamespace("future", 
[13:23:31.935]                         quietly = TRUE)
[13:23:31.935]                       if (has_future) {
[13:23:31.935]                         ns <- base::getNamespace("future")
[13:23:31.935]                         version <- ns[[".package"]][["version"]]
[13:23:31.935]                         if (is.null(version)) 
[13:23:31.935]                           version <- utils::packageVersion("future")
[13:23:31.935]                       }
[13:23:31.935]                       else {
[13:23:31.935]                         version <- NULL
[13:23:31.935]                       }
[13:23:31.935]                       if (!has_future || version < "1.8.0") {
[13:23:31.935]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:31.935]                           "", base::R.version$version.string), 
[13:23:31.935]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:31.935]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:31.935]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:31.935]                             "release", "version")], collapse = " "), 
[13:23:31.935]                           hostname = base::Sys.info()[["nodename"]])
[13:23:31.935]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:31.935]                           info)
[13:23:31.935]                         info <- base::paste(info, collapse = "; ")
[13:23:31.935]                         if (!has_future) {
[13:23:31.935]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:31.935]                             info)
[13:23:31.935]                         }
[13:23:31.935]                         else {
[13:23:31.935]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:31.935]                             info, version)
[13:23:31.935]                         }
[13:23:31.935]                         base::stop(msg)
[13:23:31.935]                       }
[13:23:31.935]                     })
[13:23:31.935]                   }
[13:23:31.935]                   options(future.plan = NULL)
[13:23:31.935]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:31.935]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:31.935]                 }
[13:23:31.935]                 ...future.workdir <- getwd()
[13:23:31.935]             }
[13:23:31.935]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:31.935]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:31.935]         }
[13:23:31.935]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:31.935]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:31.935]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:31.935]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:31.935]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:31.935]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:31.935]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:31.935]             base::names(...future.oldOptions))
[13:23:31.935]     }
[13:23:31.935]     if (FALSE) {
[13:23:31.935]     }
[13:23:31.935]     else {
[13:23:31.935]         if (TRUE) {
[13:23:31.935]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:31.935]                 open = "w")
[13:23:31.935]         }
[13:23:31.935]         else {
[13:23:31.935]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:31.935]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:31.935]         }
[13:23:31.935]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:31.935]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:31.935]             base::sink(type = "output", split = FALSE)
[13:23:31.935]             base::close(...future.stdout)
[13:23:31.935]         }, add = TRUE)
[13:23:31.935]     }
[13:23:31.935]     ...future.frame <- base::sys.nframe()
[13:23:31.935]     ...future.conditions <- base::list()
[13:23:31.935]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:31.935]     if (FALSE) {
[13:23:31.935]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:31.935]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:31.935]     }
[13:23:31.935]     ...future.result <- base::tryCatch({
[13:23:31.935]         base::withCallingHandlers({
[13:23:31.935]             ...future.value <- base::withVisible(base::local({
[13:23:31.935]                 b <- a * ii
[13:23:31.935]                 a <- 0
[13:23:31.935]                 b
[13:23:31.935]             }))
[13:23:31.935]             future::FutureResult(value = ...future.value$value, 
[13:23:31.935]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:31.935]                   ...future.rng), globalenv = if (FALSE) 
[13:23:31.935]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:31.935]                     ...future.globalenv.names))
[13:23:31.935]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:31.935]         }, condition = base::local({
[13:23:31.935]             c <- base::c
[13:23:31.935]             inherits <- base::inherits
[13:23:31.935]             invokeRestart <- base::invokeRestart
[13:23:31.935]             length <- base::length
[13:23:31.935]             list <- base::list
[13:23:31.935]             seq.int <- base::seq.int
[13:23:31.935]             signalCondition <- base::signalCondition
[13:23:31.935]             sys.calls <- base::sys.calls
[13:23:31.935]             `[[` <- base::`[[`
[13:23:31.935]             `+` <- base::`+`
[13:23:31.935]             `<<-` <- base::`<<-`
[13:23:31.935]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:31.935]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:31.935]                   3L)]
[13:23:31.935]             }
[13:23:31.935]             function(cond) {
[13:23:31.935]                 is_error <- inherits(cond, "error")
[13:23:31.935]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:31.935]                   NULL)
[13:23:31.935]                 if (is_error) {
[13:23:31.935]                   sessionInformation <- function() {
[13:23:31.935]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:31.935]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:31.935]                       search = base::search(), system = base::Sys.info())
[13:23:31.935]                   }
[13:23:31.935]                   ...future.conditions[[length(...future.conditions) + 
[13:23:31.935]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:31.935]                     cond$call), session = sessionInformation(), 
[13:23:31.935]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:31.935]                   signalCondition(cond)
[13:23:31.935]                 }
[13:23:31.935]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:31.935]                 "immediateCondition"))) {
[13:23:31.935]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:31.935]                   ...future.conditions[[length(...future.conditions) + 
[13:23:31.935]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:31.935]                   if (TRUE && !signal) {
[13:23:31.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:31.935]                     {
[13:23:31.935]                       inherits <- base::inherits
[13:23:31.935]                       invokeRestart <- base::invokeRestart
[13:23:31.935]                       is.null <- base::is.null
[13:23:31.935]                       muffled <- FALSE
[13:23:31.935]                       if (inherits(cond, "message")) {
[13:23:31.935]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:31.935]                         if (muffled) 
[13:23:31.935]                           invokeRestart("muffleMessage")
[13:23:31.935]                       }
[13:23:31.935]                       else if (inherits(cond, "warning")) {
[13:23:31.935]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:31.935]                         if (muffled) 
[13:23:31.935]                           invokeRestart("muffleWarning")
[13:23:31.935]                       }
[13:23:31.935]                       else if (inherits(cond, "condition")) {
[13:23:31.935]                         if (!is.null(pattern)) {
[13:23:31.935]                           computeRestarts <- base::computeRestarts
[13:23:31.935]                           grepl <- base::grepl
[13:23:31.935]                           restarts <- computeRestarts(cond)
[13:23:31.935]                           for (restart in restarts) {
[13:23:31.935]                             name <- restart$name
[13:23:31.935]                             if (is.null(name)) 
[13:23:31.935]                               next
[13:23:31.935]                             if (!grepl(pattern, name)) 
[13:23:31.935]                               next
[13:23:31.935]                             invokeRestart(restart)
[13:23:31.935]                             muffled <- TRUE
[13:23:31.935]                             break
[13:23:31.935]                           }
[13:23:31.935]                         }
[13:23:31.935]                       }
[13:23:31.935]                       invisible(muffled)
[13:23:31.935]                     }
[13:23:31.935]                     muffleCondition(cond, pattern = "^muffle")
[13:23:31.935]                   }
[13:23:31.935]                 }
[13:23:31.935]                 else {
[13:23:31.935]                   if (TRUE) {
[13:23:31.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:31.935]                     {
[13:23:31.935]                       inherits <- base::inherits
[13:23:31.935]                       invokeRestart <- base::invokeRestart
[13:23:31.935]                       is.null <- base::is.null
[13:23:31.935]                       muffled <- FALSE
[13:23:31.935]                       if (inherits(cond, "message")) {
[13:23:31.935]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:31.935]                         if (muffled) 
[13:23:31.935]                           invokeRestart("muffleMessage")
[13:23:31.935]                       }
[13:23:31.935]                       else if (inherits(cond, "warning")) {
[13:23:31.935]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:31.935]                         if (muffled) 
[13:23:31.935]                           invokeRestart("muffleWarning")
[13:23:31.935]                       }
[13:23:31.935]                       else if (inherits(cond, "condition")) {
[13:23:31.935]                         if (!is.null(pattern)) {
[13:23:31.935]                           computeRestarts <- base::computeRestarts
[13:23:31.935]                           grepl <- base::grepl
[13:23:31.935]                           restarts <- computeRestarts(cond)
[13:23:31.935]                           for (restart in restarts) {
[13:23:31.935]                             name <- restart$name
[13:23:31.935]                             if (is.null(name)) 
[13:23:31.935]                               next
[13:23:31.935]                             if (!grepl(pattern, name)) 
[13:23:31.935]                               next
[13:23:31.935]                             invokeRestart(restart)
[13:23:31.935]                             muffled <- TRUE
[13:23:31.935]                             break
[13:23:31.935]                           }
[13:23:31.935]                         }
[13:23:31.935]                       }
[13:23:31.935]                       invisible(muffled)
[13:23:31.935]                     }
[13:23:31.935]                     muffleCondition(cond, pattern = "^muffle")
[13:23:31.935]                   }
[13:23:31.935]                 }
[13:23:31.935]             }
[13:23:31.935]         }))
[13:23:31.935]     }, error = function(ex) {
[13:23:31.935]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:31.935]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:31.935]                 ...future.rng), started = ...future.startTime, 
[13:23:31.935]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:31.935]             version = "1.8"), class = "FutureResult")
[13:23:31.935]     }, finally = {
[13:23:31.935]         if (!identical(...future.workdir, getwd())) 
[13:23:31.935]             setwd(...future.workdir)
[13:23:31.935]         {
[13:23:31.935]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:31.935]                 ...future.oldOptions$nwarnings <- NULL
[13:23:31.935]             }
[13:23:31.935]             base::options(...future.oldOptions)
[13:23:31.935]             if (.Platform$OS.type == "windows") {
[13:23:31.935]                 old_names <- names(...future.oldEnvVars)
[13:23:31.935]                 envs <- base::Sys.getenv()
[13:23:31.935]                 names <- names(envs)
[13:23:31.935]                 common <- intersect(names, old_names)
[13:23:31.935]                 added <- setdiff(names, old_names)
[13:23:31.935]                 removed <- setdiff(old_names, names)
[13:23:31.935]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:31.935]                   envs[common]]
[13:23:31.935]                 NAMES <- toupper(changed)
[13:23:31.935]                 args <- list()
[13:23:31.935]                 for (kk in seq_along(NAMES)) {
[13:23:31.935]                   name <- changed[[kk]]
[13:23:31.935]                   NAME <- NAMES[[kk]]
[13:23:31.935]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:31.935]                     next
[13:23:31.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:31.935]                 }
[13:23:31.935]                 NAMES <- toupper(added)
[13:23:31.935]                 for (kk in seq_along(NAMES)) {
[13:23:31.935]                   name <- added[[kk]]
[13:23:31.935]                   NAME <- NAMES[[kk]]
[13:23:31.935]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:31.935]                     next
[13:23:31.935]                   args[[name]] <- ""
[13:23:31.935]                 }
[13:23:31.935]                 NAMES <- toupper(removed)
[13:23:31.935]                 for (kk in seq_along(NAMES)) {
[13:23:31.935]                   name <- removed[[kk]]
[13:23:31.935]                   NAME <- NAMES[[kk]]
[13:23:31.935]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:31.935]                     next
[13:23:31.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:31.935]                 }
[13:23:31.935]                 if (length(args) > 0) 
[13:23:31.935]                   base::do.call(base::Sys.setenv, args = args)
[13:23:31.935]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:31.935]             }
[13:23:31.935]             else {
[13:23:31.935]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:31.935]             }
[13:23:31.935]             {
[13:23:31.935]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:31.935]                   0L) {
[13:23:31.935]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:31.935]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:31.935]                   base::options(opts)
[13:23:31.935]                 }
[13:23:31.935]                 {
[13:23:31.935]                   {
[13:23:31.935]                     NULL
[13:23:31.935]                     RNGkind("Mersenne-Twister")
[13:23:31.935]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:31.935]                       inherits = FALSE)
[13:23:31.935]                   }
[13:23:31.935]                   options(future.plan = NULL)
[13:23:31.935]                   if (is.na(NA_character_)) 
[13:23:31.935]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:31.935]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:31.935]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:31.935]                   {
[13:23:31.935]                     future <- SequentialFuture(..., envir = envir)
[13:23:31.935]                     if (!future$lazy) 
[13:23:31.935]                       future <- run(future)
[13:23:31.935]                     invisible(future)
[13:23:31.935]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:31.935]                 }
[13:23:31.935]             }
[13:23:31.935]         }
[13:23:31.935]     })
[13:23:31.935]     if (TRUE) {
[13:23:31.935]         base::sink(type = "output", split = FALSE)
[13:23:31.935]         if (TRUE) {
[13:23:31.935]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:31.935]         }
[13:23:31.935]         else {
[13:23:31.935]             ...future.result["stdout"] <- base::list(NULL)
[13:23:31.935]         }
[13:23:31.935]         base::close(...future.stdout)
[13:23:31.935]         ...future.stdout <- NULL
[13:23:31.935]     }
[13:23:31.935]     ...future.result$conditions <- ...future.conditions
[13:23:31.935]     ...future.result$finished <- base::Sys.time()
[13:23:31.935]     ...future.result
[13:23:31.935] }
[13:23:31.937] assign_globals() ...
[13:23:31.937] List of 1
[13:23:31.937]  $ ii: int 3
[13:23:31.937]  - attr(*, "where")=List of 1
[13:23:31.937]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:31.937]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:31.937]  - attr(*, "resolved")= logi TRUE
[13:23:31.937]  - attr(*, "total_size")= num 56
[13:23:31.937]  - attr(*, "already-done")= logi TRUE
[13:23:31.939] - copied ‘ii’ to environment
[13:23:31.939] assign_globals() ... done
[13:23:31.940] plan(): Setting new future strategy stack:
[13:23:31.940] List of future strategies:
[13:23:31.940] 1. sequential:
[13:23:31.940]    - args: function (..., envir = parent.frame())
[13:23:31.940]    - tweaked: FALSE
[13:23:31.940]    - call: NULL
[13:23:31.940] plan(): nbrOfWorkers() = 1
[13:23:31.941] plan(): Setting new future strategy stack:
[13:23:31.941] List of future strategies:
[13:23:31.941] 1. sequential:
[13:23:31.941]    - args: function (..., envir = parent.frame())
[13:23:31.941]    - tweaked: FALSE
[13:23:31.941]    - call: plan(strategy)
[13:23:31.941] plan(): nbrOfWorkers() = 1
[13:23:31.942] SequentialFuture started (and completed)
[13:23:31.942] - Launch lazy future ... done
[13:23:31.942] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:31.943] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:31.943] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:31.944] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:31.945] Searching for globals ... DONE
[13:23:31.945] Resolving globals: TRUE
[13:23:31.945] Resolving any globals that are futures ...
[13:23:31.945] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:31.945] Resolving any globals that are futures ... DONE
[13:23:31.945] Resolving futures part of globals (recursively) ...
[13:23:31.946] resolve() on list ...
[13:23:31.946]  recursive: 99
[13:23:31.946]  length: 1
[13:23:31.946]  elements: ‘ii’
[13:23:31.946]  length: 0 (resolved future 1)
[13:23:31.946] resolve() on list ... DONE
[13:23:31.946] - globals: [1] ‘ii’
[13:23:31.946] Resolving futures part of globals (recursively) ... DONE
[13:23:31.946] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:31.947] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:31.947] - globals: [1] ‘ii’
[13:23:31.947] 
[13:23:31.947] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:31.948] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:31.948] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:31.949] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:31.949] Searching for globals ... DONE
[13:23:31.949] Resolving globals: TRUE
[13:23:31.950] Resolving any globals that are futures ...
[13:23:31.950] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:31.950] Resolving any globals that are futures ... DONE
[13:23:31.950] Resolving futures part of globals (recursively) ...
[13:23:31.950] resolve() on list ...
[13:23:31.950]  recursive: 99
[13:23:31.950]  length: 1
[13:23:31.951]  elements: ‘ii’
[13:23:31.951]  length: 0 (resolved future 1)
[13:23:31.951] resolve() on list ... DONE
[13:23:31.951] - globals: [1] ‘ii’
[13:23:31.951] Resolving futures part of globals (recursively) ... DONE
[13:23:31.951] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:31.951] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:31.952] - globals: [1] ‘ii’
[13:23:31.952] 
[13:23:31.952] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:31.952] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:31.953] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:31.956] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:31.956] Searching for globals ... DONE
[13:23:31.956] Resolving globals: TRUE
[13:23:31.956] Resolving any globals that are futures ...
[13:23:31.956] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:31.956] Resolving any globals that are futures ... DONE
[13:23:31.957] Resolving futures part of globals (recursively) ...
[13:23:31.957] resolve() on list ...
[13:23:31.957]  recursive: 99
[13:23:31.957]  length: 1
[13:23:31.957]  elements: ‘ii’
[13:23:31.957]  length: 0 (resolved future 1)
[13:23:31.957] resolve() on list ... DONE
[13:23:31.957] - globals: [1] ‘ii’
[13:23:31.957] Resolving futures part of globals (recursively) ... DONE
[13:23:31.958] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:31.958] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:31.958] - globals: [1] ‘ii’
[13:23:31.958] 
[13:23:31.958] getGlobalsAndPackages() ... DONE
[13:23:31.959] run() for ‘Future’ ...
[13:23:31.959] - state: ‘created’
[13:23:31.959] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:31.959] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:31.959] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:31.959]   - Field: ‘label’
[13:23:31.959]   - Field: ‘local’
[13:23:31.960]   - Field: ‘owner’
[13:23:31.960]   - Field: ‘envir’
[13:23:31.960]   - Field: ‘packages’
[13:23:31.960]   - Field: ‘gc’
[13:23:31.960]   - Field: ‘conditions’
[13:23:31.960]   - Field: ‘expr’
[13:23:31.960]   - Field: ‘uuid’
[13:23:31.960]   - Field: ‘seed’
[13:23:31.960]   - Field: ‘version’
[13:23:31.960]   - Field: ‘result’
[13:23:31.961]   - Field: ‘asynchronous’
[13:23:31.961]   - Field: ‘calls’
[13:23:31.961]   - Field: ‘globals’
[13:23:31.961]   - Field: ‘stdout’
[13:23:31.961]   - Field: ‘earlySignal’
[13:23:31.961]   - Field: ‘lazy’
[13:23:31.961]   - Field: ‘state’
[13:23:31.961] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:31.961] - Launch lazy future ...
[13:23:31.962] Packages needed by the future expression (n = 0): <none>
[13:23:31.962] Packages needed by future strategies (n = 0): <none>
[13:23:31.962] {
[13:23:31.962]     {
[13:23:31.962]         {
[13:23:31.962]             ...future.startTime <- base::Sys.time()
[13:23:31.962]             {
[13:23:31.962]                 {
[13:23:31.962]                   {
[13:23:31.962]                     base::local({
[13:23:31.962]                       has_future <- base::requireNamespace("future", 
[13:23:31.962]                         quietly = TRUE)
[13:23:31.962]                       if (has_future) {
[13:23:31.962]                         ns <- base::getNamespace("future")
[13:23:31.962]                         version <- ns[[".package"]][["version"]]
[13:23:31.962]                         if (is.null(version)) 
[13:23:31.962]                           version <- utils::packageVersion("future")
[13:23:31.962]                       }
[13:23:31.962]                       else {
[13:23:31.962]                         version <- NULL
[13:23:31.962]                       }
[13:23:31.962]                       if (!has_future || version < "1.8.0") {
[13:23:31.962]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:31.962]                           "", base::R.version$version.string), 
[13:23:31.962]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:31.962]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:31.962]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:31.962]                             "release", "version")], collapse = " "), 
[13:23:31.962]                           hostname = base::Sys.info()[["nodename"]])
[13:23:31.962]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:31.962]                           info)
[13:23:31.962]                         info <- base::paste(info, collapse = "; ")
[13:23:31.962]                         if (!has_future) {
[13:23:31.962]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:31.962]                             info)
[13:23:31.962]                         }
[13:23:31.962]                         else {
[13:23:31.962]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:31.962]                             info, version)
[13:23:31.962]                         }
[13:23:31.962]                         base::stop(msg)
[13:23:31.962]                       }
[13:23:31.962]                     })
[13:23:31.962]                   }
[13:23:31.962]                   options(future.plan = NULL)
[13:23:31.962]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:31.962]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:31.962]                 }
[13:23:31.962]                 ...future.workdir <- getwd()
[13:23:31.962]             }
[13:23:31.962]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:31.962]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:31.962]         }
[13:23:31.962]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:31.962]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:31.962]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:31.962]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:31.962]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:31.962]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:31.962]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:31.962]             base::names(...future.oldOptions))
[13:23:31.962]     }
[13:23:31.962]     if (FALSE) {
[13:23:31.962]     }
[13:23:31.962]     else {
[13:23:31.962]         if (TRUE) {
[13:23:31.962]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:31.962]                 open = "w")
[13:23:31.962]         }
[13:23:31.962]         else {
[13:23:31.962]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:31.962]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:31.962]         }
[13:23:31.962]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:31.962]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:31.962]             base::sink(type = "output", split = FALSE)
[13:23:31.962]             base::close(...future.stdout)
[13:23:31.962]         }, add = TRUE)
[13:23:31.962]     }
[13:23:31.962]     ...future.frame <- base::sys.nframe()
[13:23:31.962]     ...future.conditions <- base::list()
[13:23:31.962]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:31.962]     if (FALSE) {
[13:23:31.962]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:31.962]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:31.962]     }
[13:23:31.962]     ...future.result <- base::tryCatch({
[13:23:31.962]         base::withCallingHandlers({
[13:23:31.962]             ...future.value <- base::withVisible(base::local({
[13:23:31.962]                 b <- a * ii
[13:23:31.962]                 a <- 0
[13:23:31.962]                 b
[13:23:31.962]             }))
[13:23:31.962]             future::FutureResult(value = ...future.value$value, 
[13:23:31.962]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:31.962]                   ...future.rng), globalenv = if (FALSE) 
[13:23:31.962]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:31.962]                     ...future.globalenv.names))
[13:23:31.962]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:31.962]         }, condition = base::local({
[13:23:31.962]             c <- base::c
[13:23:31.962]             inherits <- base::inherits
[13:23:31.962]             invokeRestart <- base::invokeRestart
[13:23:31.962]             length <- base::length
[13:23:31.962]             list <- base::list
[13:23:31.962]             seq.int <- base::seq.int
[13:23:31.962]             signalCondition <- base::signalCondition
[13:23:31.962]             sys.calls <- base::sys.calls
[13:23:31.962]             `[[` <- base::`[[`
[13:23:31.962]             `+` <- base::`+`
[13:23:31.962]             `<<-` <- base::`<<-`
[13:23:31.962]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:31.962]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:31.962]                   3L)]
[13:23:31.962]             }
[13:23:31.962]             function(cond) {
[13:23:31.962]                 is_error <- inherits(cond, "error")
[13:23:31.962]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:31.962]                   NULL)
[13:23:31.962]                 if (is_error) {
[13:23:31.962]                   sessionInformation <- function() {
[13:23:31.962]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:31.962]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:31.962]                       search = base::search(), system = base::Sys.info())
[13:23:31.962]                   }
[13:23:31.962]                   ...future.conditions[[length(...future.conditions) + 
[13:23:31.962]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:31.962]                     cond$call), session = sessionInformation(), 
[13:23:31.962]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:31.962]                   signalCondition(cond)
[13:23:31.962]                 }
[13:23:31.962]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:31.962]                 "immediateCondition"))) {
[13:23:31.962]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:31.962]                   ...future.conditions[[length(...future.conditions) + 
[13:23:31.962]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:31.962]                   if (TRUE && !signal) {
[13:23:31.962]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:31.962]                     {
[13:23:31.962]                       inherits <- base::inherits
[13:23:31.962]                       invokeRestart <- base::invokeRestart
[13:23:31.962]                       is.null <- base::is.null
[13:23:31.962]                       muffled <- FALSE
[13:23:31.962]                       if (inherits(cond, "message")) {
[13:23:31.962]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:31.962]                         if (muffled) 
[13:23:31.962]                           invokeRestart("muffleMessage")
[13:23:31.962]                       }
[13:23:31.962]                       else if (inherits(cond, "warning")) {
[13:23:31.962]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:31.962]                         if (muffled) 
[13:23:31.962]                           invokeRestart("muffleWarning")
[13:23:31.962]                       }
[13:23:31.962]                       else if (inherits(cond, "condition")) {
[13:23:31.962]                         if (!is.null(pattern)) {
[13:23:31.962]                           computeRestarts <- base::computeRestarts
[13:23:31.962]                           grepl <- base::grepl
[13:23:31.962]                           restarts <- computeRestarts(cond)
[13:23:31.962]                           for (restart in restarts) {
[13:23:31.962]                             name <- restart$name
[13:23:31.962]                             if (is.null(name)) 
[13:23:31.962]                               next
[13:23:31.962]                             if (!grepl(pattern, name)) 
[13:23:31.962]                               next
[13:23:31.962]                             invokeRestart(restart)
[13:23:31.962]                             muffled <- TRUE
[13:23:31.962]                             break
[13:23:31.962]                           }
[13:23:31.962]                         }
[13:23:31.962]                       }
[13:23:31.962]                       invisible(muffled)
[13:23:31.962]                     }
[13:23:31.962]                     muffleCondition(cond, pattern = "^muffle")
[13:23:31.962]                   }
[13:23:31.962]                 }
[13:23:31.962]                 else {
[13:23:31.962]                   if (TRUE) {
[13:23:31.962]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:31.962]                     {
[13:23:31.962]                       inherits <- base::inherits
[13:23:31.962]                       invokeRestart <- base::invokeRestart
[13:23:31.962]                       is.null <- base::is.null
[13:23:31.962]                       muffled <- FALSE
[13:23:31.962]                       if (inherits(cond, "message")) {
[13:23:31.962]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:31.962]                         if (muffled) 
[13:23:31.962]                           invokeRestart("muffleMessage")
[13:23:31.962]                       }
[13:23:31.962]                       else if (inherits(cond, "warning")) {
[13:23:31.962]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:31.962]                         if (muffled) 
[13:23:31.962]                           invokeRestart("muffleWarning")
[13:23:31.962]                       }
[13:23:31.962]                       else if (inherits(cond, "condition")) {
[13:23:31.962]                         if (!is.null(pattern)) {
[13:23:31.962]                           computeRestarts <- base::computeRestarts
[13:23:31.962]                           grepl <- base::grepl
[13:23:31.962]                           restarts <- computeRestarts(cond)
[13:23:31.962]                           for (restart in restarts) {
[13:23:31.962]                             name <- restart$name
[13:23:31.962]                             if (is.null(name)) 
[13:23:31.962]                               next
[13:23:31.962]                             if (!grepl(pattern, name)) 
[13:23:31.962]                               next
[13:23:31.962]                             invokeRestart(restart)
[13:23:31.962]                             muffled <- TRUE
[13:23:31.962]                             break
[13:23:31.962]                           }
[13:23:31.962]                         }
[13:23:31.962]                       }
[13:23:31.962]                       invisible(muffled)
[13:23:31.962]                     }
[13:23:31.962]                     muffleCondition(cond, pattern = "^muffle")
[13:23:31.962]                   }
[13:23:31.962]                 }
[13:23:31.962]             }
[13:23:31.962]         }))
[13:23:31.962]     }, error = function(ex) {
[13:23:31.962]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:31.962]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:31.962]                 ...future.rng), started = ...future.startTime, 
[13:23:31.962]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:31.962]             version = "1.8"), class = "FutureResult")
[13:23:31.962]     }, finally = {
[13:23:31.962]         if (!identical(...future.workdir, getwd())) 
[13:23:31.962]             setwd(...future.workdir)
[13:23:31.962]         {
[13:23:31.962]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:31.962]                 ...future.oldOptions$nwarnings <- NULL
[13:23:31.962]             }
[13:23:31.962]             base::options(...future.oldOptions)
[13:23:31.962]             if (.Platform$OS.type == "windows") {
[13:23:31.962]                 old_names <- names(...future.oldEnvVars)
[13:23:31.962]                 envs <- base::Sys.getenv()
[13:23:31.962]                 names <- names(envs)
[13:23:31.962]                 common <- intersect(names, old_names)
[13:23:31.962]                 added <- setdiff(names, old_names)
[13:23:31.962]                 removed <- setdiff(old_names, names)
[13:23:31.962]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:31.962]                   envs[common]]
[13:23:31.962]                 NAMES <- toupper(changed)
[13:23:31.962]                 args <- list()
[13:23:31.962]                 for (kk in seq_along(NAMES)) {
[13:23:31.962]                   name <- changed[[kk]]
[13:23:31.962]                   NAME <- NAMES[[kk]]
[13:23:31.962]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:31.962]                     next
[13:23:31.962]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:31.962]                 }
[13:23:31.962]                 NAMES <- toupper(added)
[13:23:31.962]                 for (kk in seq_along(NAMES)) {
[13:23:31.962]                   name <- added[[kk]]
[13:23:31.962]                   NAME <- NAMES[[kk]]
[13:23:31.962]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:31.962]                     next
[13:23:31.962]                   args[[name]] <- ""
[13:23:31.962]                 }
[13:23:31.962]                 NAMES <- toupper(removed)
[13:23:31.962]                 for (kk in seq_along(NAMES)) {
[13:23:31.962]                   name <- removed[[kk]]
[13:23:31.962]                   NAME <- NAMES[[kk]]
[13:23:31.962]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:31.962]                     next
[13:23:31.962]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:31.962]                 }
[13:23:31.962]                 if (length(args) > 0) 
[13:23:31.962]                   base::do.call(base::Sys.setenv, args = args)
[13:23:31.962]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:31.962]             }
[13:23:31.962]             else {
[13:23:31.962]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:31.962]             }
[13:23:31.962]             {
[13:23:31.962]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:31.962]                   0L) {
[13:23:31.962]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:31.962]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:31.962]                   base::options(opts)
[13:23:31.962]                 }
[13:23:31.962]                 {
[13:23:31.962]                   {
[13:23:31.962]                     NULL
[13:23:31.962]                     RNGkind("Mersenne-Twister")
[13:23:31.962]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:31.962]                       inherits = FALSE)
[13:23:31.962]                   }
[13:23:31.962]                   options(future.plan = NULL)
[13:23:31.962]                   if (is.na(NA_character_)) 
[13:23:31.962]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:31.962]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:31.962]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:31.962]                   {
[13:23:31.962]                     future <- SequentialFuture(..., envir = envir)
[13:23:31.962]                     if (!future$lazy) 
[13:23:31.962]                       future <- run(future)
[13:23:31.962]                     invisible(future)
[13:23:31.962]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:31.962]                 }
[13:23:31.962]             }
[13:23:31.962]         }
[13:23:31.962]     })
[13:23:31.962]     if (TRUE) {
[13:23:31.962]         base::sink(type = "output", split = FALSE)
[13:23:31.962]         if (TRUE) {
[13:23:31.962]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:31.962]         }
[13:23:31.962]         else {
[13:23:31.962]             ...future.result["stdout"] <- base::list(NULL)
[13:23:31.962]         }
[13:23:31.962]         base::close(...future.stdout)
[13:23:31.962]         ...future.stdout <- NULL
[13:23:31.962]     }
[13:23:31.962]     ...future.result$conditions <- ...future.conditions
[13:23:31.962]     ...future.result$finished <- base::Sys.time()
[13:23:31.962]     ...future.result
[13:23:31.962] }
[13:23:31.964] assign_globals() ...
[13:23:31.964] List of 1
[13:23:31.964]  $ ii: int 1
[13:23:31.964]  - attr(*, "where")=List of 1
[13:23:31.964]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:31.964]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:31.964]  - attr(*, "resolved")= logi TRUE
[13:23:31.964]  - attr(*, "total_size")= num 56
[13:23:31.964]  - attr(*, "already-done")= logi TRUE
[13:23:31.967] - copied ‘ii’ to environment
[13:23:31.967] assign_globals() ... done
[13:23:31.967] plan(): Setting new future strategy stack:
[13:23:31.967] List of future strategies:
[13:23:31.967] 1. sequential:
[13:23:31.967]    - args: function (..., envir = parent.frame())
[13:23:31.967]    - tweaked: FALSE
[13:23:31.967]    - call: NULL
[13:23:31.967] plan(): nbrOfWorkers() = 1
[13:23:31.968] plan(): Setting new future strategy stack:
[13:23:31.969] List of future strategies:
[13:23:31.969] 1. sequential:
[13:23:31.969]    - args: function (..., envir = parent.frame())
[13:23:31.969]    - tweaked: FALSE
[13:23:31.969]    - call: plan(strategy)
[13:23:31.969] plan(): nbrOfWorkers() = 1
[13:23:31.969] SequentialFuture started (and completed)
[13:23:31.969] signalConditions() ...
[13:23:31.969]  - include = ‘immediateCondition’
[13:23:31.969]  - exclude = 
[13:23:31.969]  - resignal = FALSE
[13:23:31.970]  - Number of conditions: 1
[13:23:31.970] signalConditions() ... done
[13:23:31.970] - Launch lazy future ... done
[13:23:31.970] run() for ‘SequentialFuture’ ... done
[13:23:31.970] signalConditions() ...
[13:23:31.970]  - include = ‘immediateCondition’
[13:23:31.970]  - exclude = 
[13:23:31.970]  - resignal = FALSE
[13:23:31.970]  - Number of conditions: 1
[13:23:31.970] signalConditions() ... done
[13:23:31.971] Future state: ‘finished’
[13:23:31.971] signalConditions() ...
[13:23:31.971]  - include = ‘condition’
[13:23:31.971]  - exclude = ‘immediateCondition’
[13:23:31.971]  - resignal = TRUE
[13:23:31.971]  - Number of conditions: 1
[13:23:31.971]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:23:31.971] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a * ii ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a * ii ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "47b98e4ec3a9" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:23:31"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:31.987] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:31.988] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:31.988] 
[13:23:31.988] Searching for globals ... DONE
[13:23:31.988] - globals: [0] <none>
[13:23:31.988] getGlobalsAndPackages() ... DONE
[13:23:31.989] run() for ‘Future’ ...
[13:23:31.989] - state: ‘created’
[13:23:31.989] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:31.989] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:31.989] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:31.989]   - Field: ‘label’
[13:23:31.990]   - Field: ‘local’
[13:23:31.990]   - Field: ‘owner’
[13:23:31.990]   - Field: ‘envir’
[13:23:31.990]   - Field: ‘packages’
[13:23:31.990]   - Field: ‘gc’
[13:23:31.990]   - Field: ‘conditions’
[13:23:31.990]   - Field: ‘expr’
[13:23:31.990]   - Field: ‘uuid’
[13:23:31.990]   - Field: ‘seed’
[13:23:31.990]   - Field: ‘version’
[13:23:31.990]   - Field: ‘result’
[13:23:31.991]   - Field: ‘asynchronous’
[13:23:31.991]   - Field: ‘calls’
[13:23:31.991]   - Field: ‘globals’
[13:23:31.991]   - Field: ‘stdout’
[13:23:31.991]   - Field: ‘earlySignal’
[13:23:31.991]   - Field: ‘lazy’
[13:23:31.991]   - Field: ‘state’
[13:23:31.991] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:31.991] - Launch lazy future ...
[13:23:31.991] Packages needed by the future expression (n = 0): <none>
[13:23:31.992] Packages needed by future strategies (n = 0): <none>
[13:23:31.992] {
[13:23:31.992]     {
[13:23:31.992]         {
[13:23:31.992]             ...future.startTime <- base::Sys.time()
[13:23:31.992]             {
[13:23:31.992]                 {
[13:23:31.992]                   {
[13:23:31.992]                     base::local({
[13:23:31.992]                       has_future <- base::requireNamespace("future", 
[13:23:31.992]                         quietly = TRUE)
[13:23:31.992]                       if (has_future) {
[13:23:31.992]                         ns <- base::getNamespace("future")
[13:23:31.992]                         version <- ns[[".package"]][["version"]]
[13:23:31.992]                         if (is.null(version)) 
[13:23:31.992]                           version <- utils::packageVersion("future")
[13:23:31.992]                       }
[13:23:31.992]                       else {
[13:23:31.992]                         version <- NULL
[13:23:31.992]                       }
[13:23:31.992]                       if (!has_future || version < "1.8.0") {
[13:23:31.992]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:31.992]                           "", base::R.version$version.string), 
[13:23:31.992]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:31.992]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:31.992]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:31.992]                             "release", "version")], collapse = " "), 
[13:23:31.992]                           hostname = base::Sys.info()[["nodename"]])
[13:23:31.992]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:31.992]                           info)
[13:23:31.992]                         info <- base::paste(info, collapse = "; ")
[13:23:31.992]                         if (!has_future) {
[13:23:31.992]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:31.992]                             info)
[13:23:31.992]                         }
[13:23:31.992]                         else {
[13:23:31.992]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:31.992]                             info, version)
[13:23:31.992]                         }
[13:23:31.992]                         base::stop(msg)
[13:23:31.992]                       }
[13:23:31.992]                     })
[13:23:31.992]                   }
[13:23:31.992]                   options(future.plan = NULL)
[13:23:31.992]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:31.992]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:31.992]                 }
[13:23:31.992]                 ...future.workdir <- getwd()
[13:23:31.992]             }
[13:23:31.992]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:31.992]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:31.992]         }
[13:23:31.992]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:31.992]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:31.992]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:31.992]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:31.992]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:31.992]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:31.992]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:31.992]             base::names(...future.oldOptions))
[13:23:31.992]     }
[13:23:31.992]     if (FALSE) {
[13:23:31.992]     }
[13:23:31.992]     else {
[13:23:31.992]         if (TRUE) {
[13:23:31.992]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:31.992]                 open = "w")
[13:23:31.992]         }
[13:23:31.992]         else {
[13:23:31.992]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:31.992]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:31.992]         }
[13:23:31.992]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:31.992]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:31.992]             base::sink(type = "output", split = FALSE)
[13:23:31.992]             base::close(...future.stdout)
[13:23:31.992]         }, add = TRUE)
[13:23:31.992]     }
[13:23:31.992]     ...future.frame <- base::sys.nframe()
[13:23:31.992]     ...future.conditions <- base::list()
[13:23:31.992]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:31.992]     if (FALSE) {
[13:23:31.992]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:31.992]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:31.992]     }
[13:23:31.992]     ...future.result <- base::tryCatch({
[13:23:31.992]         base::withCallingHandlers({
[13:23:31.992]             ...future.value <- base::withVisible(base::local(1))
[13:23:31.992]             future::FutureResult(value = ...future.value$value, 
[13:23:31.992]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:31.992]                   ...future.rng), globalenv = if (FALSE) 
[13:23:31.992]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:31.992]                     ...future.globalenv.names))
[13:23:31.992]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:31.992]         }, condition = base::local({
[13:23:31.992]             c <- base::c
[13:23:31.992]             inherits <- base::inherits
[13:23:31.992]             invokeRestart <- base::invokeRestart
[13:23:31.992]             length <- base::length
[13:23:31.992]             list <- base::list
[13:23:31.992]             seq.int <- base::seq.int
[13:23:31.992]             signalCondition <- base::signalCondition
[13:23:31.992]             sys.calls <- base::sys.calls
[13:23:31.992]             `[[` <- base::`[[`
[13:23:31.992]             `+` <- base::`+`
[13:23:31.992]             `<<-` <- base::`<<-`
[13:23:31.992]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:31.992]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:31.992]                   3L)]
[13:23:31.992]             }
[13:23:31.992]             function(cond) {
[13:23:31.992]                 is_error <- inherits(cond, "error")
[13:23:31.992]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:31.992]                   NULL)
[13:23:31.992]                 if (is_error) {
[13:23:31.992]                   sessionInformation <- function() {
[13:23:31.992]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:31.992]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:31.992]                       search = base::search(), system = base::Sys.info())
[13:23:31.992]                   }
[13:23:31.992]                   ...future.conditions[[length(...future.conditions) + 
[13:23:31.992]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:31.992]                     cond$call), session = sessionInformation(), 
[13:23:31.992]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:31.992]                   signalCondition(cond)
[13:23:31.992]                 }
[13:23:31.992]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:31.992]                 "immediateCondition"))) {
[13:23:31.992]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:31.992]                   ...future.conditions[[length(...future.conditions) + 
[13:23:31.992]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:31.992]                   if (TRUE && !signal) {
[13:23:31.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:31.992]                     {
[13:23:31.992]                       inherits <- base::inherits
[13:23:31.992]                       invokeRestart <- base::invokeRestart
[13:23:31.992]                       is.null <- base::is.null
[13:23:31.992]                       muffled <- FALSE
[13:23:31.992]                       if (inherits(cond, "message")) {
[13:23:31.992]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:31.992]                         if (muffled) 
[13:23:31.992]                           invokeRestart("muffleMessage")
[13:23:31.992]                       }
[13:23:31.992]                       else if (inherits(cond, "warning")) {
[13:23:31.992]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:31.992]                         if (muffled) 
[13:23:31.992]                           invokeRestart("muffleWarning")
[13:23:31.992]                       }
[13:23:31.992]                       else if (inherits(cond, "condition")) {
[13:23:31.992]                         if (!is.null(pattern)) {
[13:23:31.992]                           computeRestarts <- base::computeRestarts
[13:23:31.992]                           grepl <- base::grepl
[13:23:31.992]                           restarts <- computeRestarts(cond)
[13:23:31.992]                           for (restart in restarts) {
[13:23:31.992]                             name <- restart$name
[13:23:31.992]                             if (is.null(name)) 
[13:23:31.992]                               next
[13:23:31.992]                             if (!grepl(pattern, name)) 
[13:23:31.992]                               next
[13:23:31.992]                             invokeRestart(restart)
[13:23:31.992]                             muffled <- TRUE
[13:23:31.992]                             break
[13:23:31.992]                           }
[13:23:31.992]                         }
[13:23:31.992]                       }
[13:23:31.992]                       invisible(muffled)
[13:23:31.992]                     }
[13:23:31.992]                     muffleCondition(cond, pattern = "^muffle")
[13:23:31.992]                   }
[13:23:31.992]                 }
[13:23:31.992]                 else {
[13:23:31.992]                   if (TRUE) {
[13:23:31.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:31.992]                     {
[13:23:31.992]                       inherits <- base::inherits
[13:23:31.992]                       invokeRestart <- base::invokeRestart
[13:23:31.992]                       is.null <- base::is.null
[13:23:31.992]                       muffled <- FALSE
[13:23:31.992]                       if (inherits(cond, "message")) {
[13:23:31.992]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:31.992]                         if (muffled) 
[13:23:31.992]                           invokeRestart("muffleMessage")
[13:23:31.992]                       }
[13:23:31.992]                       else if (inherits(cond, "warning")) {
[13:23:31.992]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:31.992]                         if (muffled) 
[13:23:31.992]                           invokeRestart("muffleWarning")
[13:23:31.992]                       }
[13:23:31.992]                       else if (inherits(cond, "condition")) {
[13:23:31.992]                         if (!is.null(pattern)) {
[13:23:31.992]                           computeRestarts <- base::computeRestarts
[13:23:31.992]                           grepl <- base::grepl
[13:23:31.992]                           restarts <- computeRestarts(cond)
[13:23:31.992]                           for (restart in restarts) {
[13:23:31.992]                             name <- restart$name
[13:23:31.992]                             if (is.null(name)) 
[13:23:31.992]                               next
[13:23:31.992]                             if (!grepl(pattern, name)) 
[13:23:31.992]                               next
[13:23:31.992]                             invokeRestart(restart)
[13:23:31.992]                             muffled <- TRUE
[13:23:31.992]                             break
[13:23:31.992]                           }
[13:23:31.992]                         }
[13:23:31.992]                       }
[13:23:31.992]                       invisible(muffled)
[13:23:31.992]                     }
[13:23:31.992]                     muffleCondition(cond, pattern = "^muffle")
[13:23:31.992]                   }
[13:23:31.992]                 }
[13:23:31.992]             }
[13:23:31.992]         }))
[13:23:31.992]     }, error = function(ex) {
[13:23:31.992]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:31.992]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:31.992]                 ...future.rng), started = ...future.startTime, 
[13:23:31.992]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:31.992]             version = "1.8"), class = "FutureResult")
[13:23:31.992]     }, finally = {
[13:23:31.992]         if (!identical(...future.workdir, getwd())) 
[13:23:31.992]             setwd(...future.workdir)
[13:23:31.992]         {
[13:23:31.992]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:31.992]                 ...future.oldOptions$nwarnings <- NULL
[13:23:31.992]             }
[13:23:31.992]             base::options(...future.oldOptions)
[13:23:31.992]             if (.Platform$OS.type == "windows") {
[13:23:31.992]                 old_names <- names(...future.oldEnvVars)
[13:23:31.992]                 envs <- base::Sys.getenv()
[13:23:31.992]                 names <- names(envs)
[13:23:31.992]                 common <- intersect(names, old_names)
[13:23:31.992]                 added <- setdiff(names, old_names)
[13:23:31.992]                 removed <- setdiff(old_names, names)
[13:23:31.992]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:31.992]                   envs[common]]
[13:23:31.992]                 NAMES <- toupper(changed)
[13:23:31.992]                 args <- list()
[13:23:31.992]                 for (kk in seq_along(NAMES)) {
[13:23:31.992]                   name <- changed[[kk]]
[13:23:31.992]                   NAME <- NAMES[[kk]]
[13:23:31.992]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:31.992]                     next
[13:23:31.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:31.992]                 }
[13:23:31.992]                 NAMES <- toupper(added)
[13:23:31.992]                 for (kk in seq_along(NAMES)) {
[13:23:31.992]                   name <- added[[kk]]
[13:23:31.992]                   NAME <- NAMES[[kk]]
[13:23:31.992]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:31.992]                     next
[13:23:31.992]                   args[[name]] <- ""
[13:23:31.992]                 }
[13:23:31.992]                 NAMES <- toupper(removed)
[13:23:31.992]                 for (kk in seq_along(NAMES)) {
[13:23:31.992]                   name <- removed[[kk]]
[13:23:31.992]                   NAME <- NAMES[[kk]]
[13:23:31.992]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:31.992]                     next
[13:23:31.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:31.992]                 }
[13:23:31.992]                 if (length(args) > 0) 
[13:23:31.992]                   base::do.call(base::Sys.setenv, args = args)
[13:23:31.992]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:31.992]             }
[13:23:31.992]             else {
[13:23:31.992]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:31.992]             }
[13:23:31.992]             {
[13:23:31.992]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:31.992]                   0L) {
[13:23:31.992]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:31.992]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:31.992]                   base::options(opts)
[13:23:31.992]                 }
[13:23:31.992]                 {
[13:23:31.992]                   {
[13:23:31.992]                     NULL
[13:23:31.992]                     RNGkind("Mersenne-Twister")
[13:23:31.992]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:31.992]                       inherits = FALSE)
[13:23:31.992]                   }
[13:23:31.992]                   options(future.plan = NULL)
[13:23:31.992]                   if (is.na(NA_character_)) 
[13:23:31.992]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:31.992]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:31.992]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:31.992]                   {
[13:23:31.992]                     future <- SequentialFuture(..., envir = envir)
[13:23:31.992]                     if (!future$lazy) 
[13:23:31.992]                       future <- run(future)
[13:23:31.992]                     invisible(future)
[13:23:31.992]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:31.992]                 }
[13:23:31.992]             }
[13:23:31.992]         }
[13:23:31.992]     })
[13:23:31.992]     if (TRUE) {
[13:23:31.992]         base::sink(type = "output", split = FALSE)
[13:23:31.992]         if (TRUE) {
[13:23:31.992]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:31.992]         }
[13:23:31.992]         else {
[13:23:31.992]             ...future.result["stdout"] <- base::list(NULL)
[13:23:31.992]         }
[13:23:31.992]         base::close(...future.stdout)
[13:23:31.992]         ...future.stdout <- NULL
[13:23:31.992]     }
[13:23:31.992]     ...future.result$conditions <- ...future.conditions
[13:23:31.992]     ...future.result$finished <- base::Sys.time()
[13:23:31.992]     ...future.result
[13:23:31.992] }
[13:23:31.994] plan(): Setting new future strategy stack:
[13:23:31.994] List of future strategies:
[13:23:31.994] 1. sequential:
[13:23:31.994]    - args: function (..., envir = parent.frame())
[13:23:31.994]    - tweaked: FALSE
[13:23:31.994]    - call: NULL
[13:23:31.994] plan(): nbrOfWorkers() = 1
[13:23:31.995] plan(): Setting new future strategy stack:
[13:23:31.995] List of future strategies:
[13:23:31.995] 1. sequential:
[13:23:31.995]    - args: function (..., envir = parent.frame())
[13:23:31.995]    - tweaked: FALSE
[13:23:31.995]    - call: plan(strategy)
[13:23:31.996] plan(): nbrOfWorkers() = 1
[13:23:31.996] SequentialFuture started (and completed)
[13:23:31.996] - Launch lazy future ... done
[13:23:31.996] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:31.996] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:31.997] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:31.997] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:31.998] Searching for globals ... DONE
[13:23:31.998] Resolving globals: TRUE
[13:23:31.998] Resolving any globals that are futures ...
[13:23:31.998] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:31.998] Resolving any globals that are futures ... DONE
[13:23:31.998] Resolving futures part of globals (recursively) ...
[13:23:31.999] resolve() on list ...
[13:23:31.999]  recursive: 99
[13:23:31.999]  length: 1
[13:23:31.999]  elements: ‘a’
[13:23:31.999] resolved() for ‘SequentialFuture’ ...
[13:23:31.999] - state: ‘finished’
[13:23:31.999] - run: TRUE
[13:23:31.999] - result: ‘FutureResult’
[13:23:32.000] resolved() for ‘SequentialFuture’ ... done
[13:23:32.000] Future #1
[13:23:32.000] resolved() for ‘SequentialFuture’ ...
[13:23:32.000] - state: ‘finished’
[13:23:32.000] - run: TRUE
[13:23:32.000] - result: ‘FutureResult’
[13:23:32.000] resolved() for ‘SequentialFuture’ ... done
[13:23:32.000] A SequentialFuture was resolved
[13:23:32.001]  length: 0 (resolved future 1)
[13:23:32.001] resolve() on list ... DONE
[13:23:32.001] - globals: [1] ‘a’
[13:23:32.001] Resolving futures part of globals (recursively) ... DONE
[13:23:32.002] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[13:23:32.002] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[13:23:32.002] - globals: [1] ‘a’
[13:23:32.002] - packages: [1] ‘future’
[13:23:32.002] getGlobalsAndPackages() ... DONE
[13:23:32.003] run() for ‘Future’ ...
[13:23:32.003] - state: ‘created’
[13:23:32.003] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.003] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.003] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.003]   - Field: ‘label’
[13:23:32.003]   - Field: ‘local’
[13:23:32.004]   - Field: ‘owner’
[13:23:32.004]   - Field: ‘envir’
[13:23:32.004]   - Field: ‘packages’
[13:23:32.004]   - Field: ‘gc’
[13:23:32.004]   - Field: ‘conditions’
[13:23:32.004]   - Field: ‘expr’
[13:23:32.004]   - Field: ‘uuid’
[13:23:32.004]   - Field: ‘seed’
[13:23:32.004]   - Field: ‘version’
[13:23:32.004]   - Field: ‘result’
[13:23:32.005]   - Field: ‘asynchronous’
[13:23:32.005]   - Field: ‘calls’
[13:23:32.005]   - Field: ‘globals’
[13:23:32.005]   - Field: ‘stdout’
[13:23:32.005]   - Field: ‘earlySignal’
[13:23:32.005]   - Field: ‘lazy’
[13:23:32.005]   - Field: ‘state’
[13:23:32.005] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.005] - Launch lazy future ...
[13:23:32.005] Packages needed by the future expression (n = 1): ‘future’
[13:23:32.006] Packages needed by future strategies (n = 0): <none>
[13:23:32.006] {
[13:23:32.006]     {
[13:23:32.006]         {
[13:23:32.006]             ...future.startTime <- base::Sys.time()
[13:23:32.006]             {
[13:23:32.006]                 {
[13:23:32.006]                   {
[13:23:32.006]                     {
[13:23:32.006]                       base::local({
[13:23:32.006]                         has_future <- base::requireNamespace("future", 
[13:23:32.006]                           quietly = TRUE)
[13:23:32.006]                         if (has_future) {
[13:23:32.006]                           ns <- base::getNamespace("future")
[13:23:32.006]                           version <- ns[[".package"]][["version"]]
[13:23:32.006]                           if (is.null(version)) 
[13:23:32.006]                             version <- utils::packageVersion("future")
[13:23:32.006]                         }
[13:23:32.006]                         else {
[13:23:32.006]                           version <- NULL
[13:23:32.006]                         }
[13:23:32.006]                         if (!has_future || version < "1.8.0") {
[13:23:32.006]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.006]                             "", base::R.version$version.string), 
[13:23:32.006]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:32.006]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.006]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.006]                               "release", "version")], collapse = " "), 
[13:23:32.006]                             hostname = base::Sys.info()[["nodename"]])
[13:23:32.006]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.006]                             info)
[13:23:32.006]                           info <- base::paste(info, collapse = "; ")
[13:23:32.006]                           if (!has_future) {
[13:23:32.006]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.006]                               info)
[13:23:32.006]                           }
[13:23:32.006]                           else {
[13:23:32.006]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.006]                               info, version)
[13:23:32.006]                           }
[13:23:32.006]                           base::stop(msg)
[13:23:32.006]                         }
[13:23:32.006]                       })
[13:23:32.006]                     }
[13:23:32.006]                     base::local({
[13:23:32.006]                       for (pkg in "future") {
[13:23:32.006]                         base::loadNamespace(pkg)
[13:23:32.006]                         base::library(pkg, character.only = TRUE)
[13:23:32.006]                       }
[13:23:32.006]                     })
[13:23:32.006]                   }
[13:23:32.006]                   options(future.plan = NULL)
[13:23:32.006]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.006]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.006]                 }
[13:23:32.006]                 ...future.workdir <- getwd()
[13:23:32.006]             }
[13:23:32.006]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.006]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.006]         }
[13:23:32.006]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.006]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:32.006]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.006]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.006]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.006]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.006]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.006]             base::names(...future.oldOptions))
[13:23:32.006]     }
[13:23:32.006]     if (FALSE) {
[13:23:32.006]     }
[13:23:32.006]     else {
[13:23:32.006]         if (TRUE) {
[13:23:32.006]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.006]                 open = "w")
[13:23:32.006]         }
[13:23:32.006]         else {
[13:23:32.006]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.006]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.006]         }
[13:23:32.006]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.006]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.006]             base::sink(type = "output", split = FALSE)
[13:23:32.006]             base::close(...future.stdout)
[13:23:32.006]         }, add = TRUE)
[13:23:32.006]     }
[13:23:32.006]     ...future.frame <- base::sys.nframe()
[13:23:32.006]     ...future.conditions <- base::list()
[13:23:32.006]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.006]     if (FALSE) {
[13:23:32.006]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.006]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.006]     }
[13:23:32.006]     ...future.result <- base::tryCatch({
[13:23:32.006]         base::withCallingHandlers({
[13:23:32.006]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:23:32.006]                 1))
[13:23:32.006]             future::FutureResult(value = ...future.value$value, 
[13:23:32.006]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.006]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.006]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.006]                     ...future.globalenv.names))
[13:23:32.006]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.006]         }, condition = base::local({
[13:23:32.006]             c <- base::c
[13:23:32.006]             inherits <- base::inherits
[13:23:32.006]             invokeRestart <- base::invokeRestart
[13:23:32.006]             length <- base::length
[13:23:32.006]             list <- base::list
[13:23:32.006]             seq.int <- base::seq.int
[13:23:32.006]             signalCondition <- base::signalCondition
[13:23:32.006]             sys.calls <- base::sys.calls
[13:23:32.006]             `[[` <- base::`[[`
[13:23:32.006]             `+` <- base::`+`
[13:23:32.006]             `<<-` <- base::`<<-`
[13:23:32.006]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.006]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.006]                   3L)]
[13:23:32.006]             }
[13:23:32.006]             function(cond) {
[13:23:32.006]                 is_error <- inherits(cond, "error")
[13:23:32.006]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.006]                   NULL)
[13:23:32.006]                 if (is_error) {
[13:23:32.006]                   sessionInformation <- function() {
[13:23:32.006]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.006]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.006]                       search = base::search(), system = base::Sys.info())
[13:23:32.006]                   }
[13:23:32.006]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.006]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.006]                     cond$call), session = sessionInformation(), 
[13:23:32.006]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.006]                   signalCondition(cond)
[13:23:32.006]                 }
[13:23:32.006]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.006]                 "immediateCondition"))) {
[13:23:32.006]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.006]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.006]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.006]                   if (TRUE && !signal) {
[13:23:32.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.006]                     {
[13:23:32.006]                       inherits <- base::inherits
[13:23:32.006]                       invokeRestart <- base::invokeRestart
[13:23:32.006]                       is.null <- base::is.null
[13:23:32.006]                       muffled <- FALSE
[13:23:32.006]                       if (inherits(cond, "message")) {
[13:23:32.006]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.006]                         if (muffled) 
[13:23:32.006]                           invokeRestart("muffleMessage")
[13:23:32.006]                       }
[13:23:32.006]                       else if (inherits(cond, "warning")) {
[13:23:32.006]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.006]                         if (muffled) 
[13:23:32.006]                           invokeRestart("muffleWarning")
[13:23:32.006]                       }
[13:23:32.006]                       else if (inherits(cond, "condition")) {
[13:23:32.006]                         if (!is.null(pattern)) {
[13:23:32.006]                           computeRestarts <- base::computeRestarts
[13:23:32.006]                           grepl <- base::grepl
[13:23:32.006]                           restarts <- computeRestarts(cond)
[13:23:32.006]                           for (restart in restarts) {
[13:23:32.006]                             name <- restart$name
[13:23:32.006]                             if (is.null(name)) 
[13:23:32.006]                               next
[13:23:32.006]                             if (!grepl(pattern, name)) 
[13:23:32.006]                               next
[13:23:32.006]                             invokeRestart(restart)
[13:23:32.006]                             muffled <- TRUE
[13:23:32.006]                             break
[13:23:32.006]                           }
[13:23:32.006]                         }
[13:23:32.006]                       }
[13:23:32.006]                       invisible(muffled)
[13:23:32.006]                     }
[13:23:32.006]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.006]                   }
[13:23:32.006]                 }
[13:23:32.006]                 else {
[13:23:32.006]                   if (TRUE) {
[13:23:32.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.006]                     {
[13:23:32.006]                       inherits <- base::inherits
[13:23:32.006]                       invokeRestart <- base::invokeRestart
[13:23:32.006]                       is.null <- base::is.null
[13:23:32.006]                       muffled <- FALSE
[13:23:32.006]                       if (inherits(cond, "message")) {
[13:23:32.006]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.006]                         if (muffled) 
[13:23:32.006]                           invokeRestart("muffleMessage")
[13:23:32.006]                       }
[13:23:32.006]                       else if (inherits(cond, "warning")) {
[13:23:32.006]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.006]                         if (muffled) 
[13:23:32.006]                           invokeRestart("muffleWarning")
[13:23:32.006]                       }
[13:23:32.006]                       else if (inherits(cond, "condition")) {
[13:23:32.006]                         if (!is.null(pattern)) {
[13:23:32.006]                           computeRestarts <- base::computeRestarts
[13:23:32.006]                           grepl <- base::grepl
[13:23:32.006]                           restarts <- computeRestarts(cond)
[13:23:32.006]                           for (restart in restarts) {
[13:23:32.006]                             name <- restart$name
[13:23:32.006]                             if (is.null(name)) 
[13:23:32.006]                               next
[13:23:32.006]                             if (!grepl(pattern, name)) 
[13:23:32.006]                               next
[13:23:32.006]                             invokeRestart(restart)
[13:23:32.006]                             muffled <- TRUE
[13:23:32.006]                             break
[13:23:32.006]                           }
[13:23:32.006]                         }
[13:23:32.006]                       }
[13:23:32.006]                       invisible(muffled)
[13:23:32.006]                     }
[13:23:32.006]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.006]                   }
[13:23:32.006]                 }
[13:23:32.006]             }
[13:23:32.006]         }))
[13:23:32.006]     }, error = function(ex) {
[13:23:32.006]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.006]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.006]                 ...future.rng), started = ...future.startTime, 
[13:23:32.006]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.006]             version = "1.8"), class = "FutureResult")
[13:23:32.006]     }, finally = {
[13:23:32.006]         if (!identical(...future.workdir, getwd())) 
[13:23:32.006]             setwd(...future.workdir)
[13:23:32.006]         {
[13:23:32.006]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.006]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.006]             }
[13:23:32.006]             base::options(...future.oldOptions)
[13:23:32.006]             if (.Platform$OS.type == "windows") {
[13:23:32.006]                 old_names <- names(...future.oldEnvVars)
[13:23:32.006]                 envs <- base::Sys.getenv()
[13:23:32.006]                 names <- names(envs)
[13:23:32.006]                 common <- intersect(names, old_names)
[13:23:32.006]                 added <- setdiff(names, old_names)
[13:23:32.006]                 removed <- setdiff(old_names, names)
[13:23:32.006]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.006]                   envs[common]]
[13:23:32.006]                 NAMES <- toupper(changed)
[13:23:32.006]                 args <- list()
[13:23:32.006]                 for (kk in seq_along(NAMES)) {
[13:23:32.006]                   name <- changed[[kk]]
[13:23:32.006]                   NAME <- NAMES[[kk]]
[13:23:32.006]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.006]                     next
[13:23:32.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.006]                 }
[13:23:32.006]                 NAMES <- toupper(added)
[13:23:32.006]                 for (kk in seq_along(NAMES)) {
[13:23:32.006]                   name <- added[[kk]]
[13:23:32.006]                   NAME <- NAMES[[kk]]
[13:23:32.006]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.006]                     next
[13:23:32.006]                   args[[name]] <- ""
[13:23:32.006]                 }
[13:23:32.006]                 NAMES <- toupper(removed)
[13:23:32.006]                 for (kk in seq_along(NAMES)) {
[13:23:32.006]                   name <- removed[[kk]]
[13:23:32.006]                   NAME <- NAMES[[kk]]
[13:23:32.006]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.006]                     next
[13:23:32.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.006]                 }
[13:23:32.006]                 if (length(args) > 0) 
[13:23:32.006]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.006]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.006]             }
[13:23:32.006]             else {
[13:23:32.006]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.006]             }
[13:23:32.006]             {
[13:23:32.006]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.006]                   0L) {
[13:23:32.006]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.006]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.006]                   base::options(opts)
[13:23:32.006]                 }
[13:23:32.006]                 {
[13:23:32.006]                   {
[13:23:32.006]                     NULL
[13:23:32.006]                     RNGkind("Mersenne-Twister")
[13:23:32.006]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.006]                       inherits = FALSE)
[13:23:32.006]                   }
[13:23:32.006]                   options(future.plan = NULL)
[13:23:32.006]                   if (is.na(NA_character_)) 
[13:23:32.006]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.006]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.006]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.006]                   {
[13:23:32.006]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.006]                     if (!future$lazy) 
[13:23:32.006]                       future <- run(future)
[13:23:32.006]                     invisible(future)
[13:23:32.006]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.006]                 }
[13:23:32.006]             }
[13:23:32.006]         }
[13:23:32.006]     })
[13:23:32.006]     if (TRUE) {
[13:23:32.006]         base::sink(type = "output", split = FALSE)
[13:23:32.006]         if (TRUE) {
[13:23:32.006]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.006]         }
[13:23:32.006]         else {
[13:23:32.006]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.006]         }
[13:23:32.006]         base::close(...future.stdout)
[13:23:32.006]         ...future.stdout <- NULL
[13:23:32.006]     }
[13:23:32.006]     ...future.result$conditions <- ...future.conditions
[13:23:32.006]     ...future.result$finished <- base::Sys.time()
[13:23:32.006]     ...future.result
[13:23:32.006] }
[13:23:32.008] assign_globals() ...
[13:23:32.008] List of 1
[13:23:32.008]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5589be78cea0> 
[13:23:32.008]  - attr(*, "where")=List of 1
[13:23:32.008]   ..$ a:<environment: R_EmptyEnv> 
[13:23:32.008]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.008]  - attr(*, "resolved")= logi TRUE
[13:23:32.008]  - attr(*, "total_size")= num 10424
[13:23:32.008]  - attr(*, "already-done")= logi TRUE
[13:23:32.011] - copied ‘a’ to environment
[13:23:32.011] assign_globals() ... done
[13:23:32.013] plan(): Setting new future strategy stack:
[13:23:32.013] List of future strategies:
[13:23:32.013] 1. sequential:
[13:23:32.013]    - args: function (..., envir = parent.frame())
[13:23:32.013]    - tweaked: FALSE
[13:23:32.013]    - call: NULL
[13:23:32.014] plan(): nbrOfWorkers() = 1
[13:23:32.014] plan(): Setting new future strategy stack:
[13:23:32.015] List of future strategies:
[13:23:32.015] 1. sequential:
[13:23:32.015]    - args: function (..., envir = parent.frame())
[13:23:32.015]    - tweaked: FALSE
[13:23:32.015]    - call: plan(strategy)
[13:23:32.015] plan(): nbrOfWorkers() = 1
[13:23:32.015] SequentialFuture started (and completed)
[13:23:32.015] - Launch lazy future ... done
[13:23:32.015] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.016] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.016] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:32.017] 
[13:23:32.017] Searching for globals ... DONE
[13:23:32.017] - globals: [0] <none>
[13:23:32.017] getGlobalsAndPackages() ... DONE
[13:23:32.017] run() for ‘Future’ ...
[13:23:32.017] - state: ‘created’
[13:23:32.017] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.018] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.018] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.018]   - Field: ‘label’
[13:23:32.018]   - Field: ‘local’
[13:23:32.018]   - Field: ‘owner’
[13:23:32.018]   - Field: ‘envir’
[13:23:32.018]   - Field: ‘packages’
[13:23:32.018]   - Field: ‘gc’
[13:23:32.018]   - Field: ‘conditions’
[13:23:32.019]   - Field: ‘expr’
[13:23:32.019]   - Field: ‘uuid’
[13:23:32.019]   - Field: ‘seed’
[13:23:32.019]   - Field: ‘version’
[13:23:32.019]   - Field: ‘result’
[13:23:32.019]   - Field: ‘asynchronous’
[13:23:32.019]   - Field: ‘calls’
[13:23:32.019]   - Field: ‘globals’
[13:23:32.019]   - Field: ‘stdout’
[13:23:32.019]   - Field: ‘earlySignal’
[13:23:32.020]   - Field: ‘lazy’
[13:23:32.020]   - Field: ‘state’
[13:23:32.020] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.020] - Launch lazy future ...
[13:23:32.020] Packages needed by the future expression (n = 0): <none>
[13:23:32.020] Packages needed by future strategies (n = 0): <none>
[13:23:32.021] {
[13:23:32.021]     {
[13:23:32.021]         {
[13:23:32.021]             ...future.startTime <- base::Sys.time()
[13:23:32.021]             {
[13:23:32.021]                 {
[13:23:32.021]                   {
[13:23:32.021]                     base::local({
[13:23:32.021]                       has_future <- base::requireNamespace("future", 
[13:23:32.021]                         quietly = TRUE)
[13:23:32.021]                       if (has_future) {
[13:23:32.021]                         ns <- base::getNamespace("future")
[13:23:32.021]                         version <- ns[[".package"]][["version"]]
[13:23:32.021]                         if (is.null(version)) 
[13:23:32.021]                           version <- utils::packageVersion("future")
[13:23:32.021]                       }
[13:23:32.021]                       else {
[13:23:32.021]                         version <- NULL
[13:23:32.021]                       }
[13:23:32.021]                       if (!has_future || version < "1.8.0") {
[13:23:32.021]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.021]                           "", base::R.version$version.string), 
[13:23:32.021]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:32.021]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.021]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.021]                             "release", "version")], collapse = " "), 
[13:23:32.021]                           hostname = base::Sys.info()[["nodename"]])
[13:23:32.021]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.021]                           info)
[13:23:32.021]                         info <- base::paste(info, collapse = "; ")
[13:23:32.021]                         if (!has_future) {
[13:23:32.021]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.021]                             info)
[13:23:32.021]                         }
[13:23:32.021]                         else {
[13:23:32.021]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.021]                             info, version)
[13:23:32.021]                         }
[13:23:32.021]                         base::stop(msg)
[13:23:32.021]                       }
[13:23:32.021]                     })
[13:23:32.021]                   }
[13:23:32.021]                   options(future.plan = NULL)
[13:23:32.021]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.021]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.021]                 }
[13:23:32.021]                 ...future.workdir <- getwd()
[13:23:32.021]             }
[13:23:32.021]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.021]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.021]         }
[13:23:32.021]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.021]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:32.021]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.021]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.021]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.021]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.021]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.021]             base::names(...future.oldOptions))
[13:23:32.021]     }
[13:23:32.021]     if (FALSE) {
[13:23:32.021]     }
[13:23:32.021]     else {
[13:23:32.021]         if (TRUE) {
[13:23:32.021]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.021]                 open = "w")
[13:23:32.021]         }
[13:23:32.021]         else {
[13:23:32.021]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.021]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.021]         }
[13:23:32.021]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.021]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.021]             base::sink(type = "output", split = FALSE)
[13:23:32.021]             base::close(...future.stdout)
[13:23:32.021]         }, add = TRUE)
[13:23:32.021]     }
[13:23:32.021]     ...future.frame <- base::sys.nframe()
[13:23:32.021]     ...future.conditions <- base::list()
[13:23:32.021]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.021]     if (FALSE) {
[13:23:32.021]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.021]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.021]     }
[13:23:32.021]     ...future.result <- base::tryCatch({
[13:23:32.021]         base::withCallingHandlers({
[13:23:32.021]             ...future.value <- base::withVisible(base::local(1))
[13:23:32.021]             future::FutureResult(value = ...future.value$value, 
[13:23:32.021]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.021]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.021]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.021]                     ...future.globalenv.names))
[13:23:32.021]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.021]         }, condition = base::local({
[13:23:32.021]             c <- base::c
[13:23:32.021]             inherits <- base::inherits
[13:23:32.021]             invokeRestart <- base::invokeRestart
[13:23:32.021]             length <- base::length
[13:23:32.021]             list <- base::list
[13:23:32.021]             seq.int <- base::seq.int
[13:23:32.021]             signalCondition <- base::signalCondition
[13:23:32.021]             sys.calls <- base::sys.calls
[13:23:32.021]             `[[` <- base::`[[`
[13:23:32.021]             `+` <- base::`+`
[13:23:32.021]             `<<-` <- base::`<<-`
[13:23:32.021]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.021]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.021]                   3L)]
[13:23:32.021]             }
[13:23:32.021]             function(cond) {
[13:23:32.021]                 is_error <- inherits(cond, "error")
[13:23:32.021]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.021]                   NULL)
[13:23:32.021]                 if (is_error) {
[13:23:32.021]                   sessionInformation <- function() {
[13:23:32.021]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.021]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.021]                       search = base::search(), system = base::Sys.info())
[13:23:32.021]                   }
[13:23:32.021]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.021]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.021]                     cond$call), session = sessionInformation(), 
[13:23:32.021]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.021]                   signalCondition(cond)
[13:23:32.021]                 }
[13:23:32.021]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.021]                 "immediateCondition"))) {
[13:23:32.021]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.021]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.021]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.021]                   if (TRUE && !signal) {
[13:23:32.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.021]                     {
[13:23:32.021]                       inherits <- base::inherits
[13:23:32.021]                       invokeRestart <- base::invokeRestart
[13:23:32.021]                       is.null <- base::is.null
[13:23:32.021]                       muffled <- FALSE
[13:23:32.021]                       if (inherits(cond, "message")) {
[13:23:32.021]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.021]                         if (muffled) 
[13:23:32.021]                           invokeRestart("muffleMessage")
[13:23:32.021]                       }
[13:23:32.021]                       else if (inherits(cond, "warning")) {
[13:23:32.021]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.021]                         if (muffled) 
[13:23:32.021]                           invokeRestart("muffleWarning")
[13:23:32.021]                       }
[13:23:32.021]                       else if (inherits(cond, "condition")) {
[13:23:32.021]                         if (!is.null(pattern)) {
[13:23:32.021]                           computeRestarts <- base::computeRestarts
[13:23:32.021]                           grepl <- base::grepl
[13:23:32.021]                           restarts <- computeRestarts(cond)
[13:23:32.021]                           for (restart in restarts) {
[13:23:32.021]                             name <- restart$name
[13:23:32.021]                             if (is.null(name)) 
[13:23:32.021]                               next
[13:23:32.021]                             if (!grepl(pattern, name)) 
[13:23:32.021]                               next
[13:23:32.021]                             invokeRestart(restart)
[13:23:32.021]                             muffled <- TRUE
[13:23:32.021]                             break
[13:23:32.021]                           }
[13:23:32.021]                         }
[13:23:32.021]                       }
[13:23:32.021]                       invisible(muffled)
[13:23:32.021]                     }
[13:23:32.021]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.021]                   }
[13:23:32.021]                 }
[13:23:32.021]                 else {
[13:23:32.021]                   if (TRUE) {
[13:23:32.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.021]                     {
[13:23:32.021]                       inherits <- base::inherits
[13:23:32.021]                       invokeRestart <- base::invokeRestart
[13:23:32.021]                       is.null <- base::is.null
[13:23:32.021]                       muffled <- FALSE
[13:23:32.021]                       if (inherits(cond, "message")) {
[13:23:32.021]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.021]                         if (muffled) 
[13:23:32.021]                           invokeRestart("muffleMessage")
[13:23:32.021]                       }
[13:23:32.021]                       else if (inherits(cond, "warning")) {
[13:23:32.021]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.021]                         if (muffled) 
[13:23:32.021]                           invokeRestart("muffleWarning")
[13:23:32.021]                       }
[13:23:32.021]                       else if (inherits(cond, "condition")) {
[13:23:32.021]                         if (!is.null(pattern)) {
[13:23:32.021]                           computeRestarts <- base::computeRestarts
[13:23:32.021]                           grepl <- base::grepl
[13:23:32.021]                           restarts <- computeRestarts(cond)
[13:23:32.021]                           for (restart in restarts) {
[13:23:32.021]                             name <- restart$name
[13:23:32.021]                             if (is.null(name)) 
[13:23:32.021]                               next
[13:23:32.021]                             if (!grepl(pattern, name)) 
[13:23:32.021]                               next
[13:23:32.021]                             invokeRestart(restart)
[13:23:32.021]                             muffled <- TRUE
[13:23:32.021]                             break
[13:23:32.021]                           }
[13:23:32.021]                         }
[13:23:32.021]                       }
[13:23:32.021]                       invisible(muffled)
[13:23:32.021]                     }
[13:23:32.021]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.021]                   }
[13:23:32.021]                 }
[13:23:32.021]             }
[13:23:32.021]         }))
[13:23:32.021]     }, error = function(ex) {
[13:23:32.021]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.021]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.021]                 ...future.rng), started = ...future.startTime, 
[13:23:32.021]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.021]             version = "1.8"), class = "FutureResult")
[13:23:32.021]     }, finally = {
[13:23:32.021]         if (!identical(...future.workdir, getwd())) 
[13:23:32.021]             setwd(...future.workdir)
[13:23:32.021]         {
[13:23:32.021]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.021]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.021]             }
[13:23:32.021]             base::options(...future.oldOptions)
[13:23:32.021]             if (.Platform$OS.type == "windows") {
[13:23:32.021]                 old_names <- names(...future.oldEnvVars)
[13:23:32.021]                 envs <- base::Sys.getenv()
[13:23:32.021]                 names <- names(envs)
[13:23:32.021]                 common <- intersect(names, old_names)
[13:23:32.021]                 added <- setdiff(names, old_names)
[13:23:32.021]                 removed <- setdiff(old_names, names)
[13:23:32.021]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.021]                   envs[common]]
[13:23:32.021]                 NAMES <- toupper(changed)
[13:23:32.021]                 args <- list()
[13:23:32.021]                 for (kk in seq_along(NAMES)) {
[13:23:32.021]                   name <- changed[[kk]]
[13:23:32.021]                   NAME <- NAMES[[kk]]
[13:23:32.021]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.021]                     next
[13:23:32.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.021]                 }
[13:23:32.021]                 NAMES <- toupper(added)
[13:23:32.021]                 for (kk in seq_along(NAMES)) {
[13:23:32.021]                   name <- added[[kk]]
[13:23:32.021]                   NAME <- NAMES[[kk]]
[13:23:32.021]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.021]                     next
[13:23:32.021]                   args[[name]] <- ""
[13:23:32.021]                 }
[13:23:32.021]                 NAMES <- toupper(removed)
[13:23:32.021]                 for (kk in seq_along(NAMES)) {
[13:23:32.021]                   name <- removed[[kk]]
[13:23:32.021]                   NAME <- NAMES[[kk]]
[13:23:32.021]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.021]                     next
[13:23:32.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.021]                 }
[13:23:32.021]                 if (length(args) > 0) 
[13:23:32.021]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.021]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.021]             }
[13:23:32.021]             else {
[13:23:32.021]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.021]             }
[13:23:32.021]             {
[13:23:32.021]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.021]                   0L) {
[13:23:32.021]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.021]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.021]                   base::options(opts)
[13:23:32.021]                 }
[13:23:32.021]                 {
[13:23:32.021]                   {
[13:23:32.021]                     NULL
[13:23:32.021]                     RNGkind("Mersenne-Twister")
[13:23:32.021]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.021]                       inherits = FALSE)
[13:23:32.021]                   }
[13:23:32.021]                   options(future.plan = NULL)
[13:23:32.021]                   if (is.na(NA_character_)) 
[13:23:32.021]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.021]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.021]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.021]                   {
[13:23:32.021]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.021]                     if (!future$lazy) 
[13:23:32.021]                       future <- run(future)
[13:23:32.021]                     invisible(future)
[13:23:32.021]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.021]                 }
[13:23:32.021]             }
[13:23:32.021]         }
[13:23:32.021]     })
[13:23:32.021]     if (TRUE) {
[13:23:32.021]         base::sink(type = "output", split = FALSE)
[13:23:32.021]         if (TRUE) {
[13:23:32.021]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.021]         }
[13:23:32.021]         else {
[13:23:32.021]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.021]         }
[13:23:32.021]         base::close(...future.stdout)
[13:23:32.021]         ...future.stdout <- NULL
[13:23:32.021]     }
[13:23:32.021]     ...future.result$conditions <- ...future.conditions
[13:23:32.021]     ...future.result$finished <- base::Sys.time()
[13:23:32.021]     ...future.result
[13:23:32.021] }
[13:23:32.022] plan(): Setting new future strategy stack:
[13:23:32.022] List of future strategies:
[13:23:32.022] 1. sequential:
[13:23:32.022]    - args: function (..., envir = parent.frame())
[13:23:32.022]    - tweaked: FALSE
[13:23:32.022]    - call: NULL
[13:23:32.023] plan(): nbrOfWorkers() = 1
[13:23:32.024] plan(): Setting new future strategy stack:
[13:23:32.024] List of future strategies:
[13:23:32.024] 1. sequential:
[13:23:32.024]    - args: function (..., envir = parent.frame())
[13:23:32.024]    - tweaked: FALSE
[13:23:32.024]    - call: plan(strategy)
[13:23:32.024] plan(): nbrOfWorkers() = 1
[13:23:32.024] SequentialFuture started (and completed)
[13:23:32.024] - Launch lazy future ... done
[13:23:32.025] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.025] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.025] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:32.026] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:32.026] Searching for globals ... DONE
[13:23:32.026] Resolving globals: TRUE
[13:23:32.026] Resolving any globals that are futures ...
[13:23:32.026] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:32.027] Resolving any globals that are futures ... DONE
[13:23:32.027] Resolving futures part of globals (recursively) ...
[13:23:32.027] resolve() on list ...
[13:23:32.027]  recursive: 99
[13:23:32.027]  length: 1
[13:23:32.027]  elements: ‘a’
[13:23:32.028] resolved() for ‘SequentialFuture’ ...
[13:23:32.028] - state: ‘finished’
[13:23:32.028] - run: TRUE
[13:23:32.028] - result: ‘FutureResult’
[13:23:32.028] resolved() for ‘SequentialFuture’ ... done
[13:23:32.028] Future #1
[13:23:32.028] resolved() for ‘SequentialFuture’ ...
[13:23:32.028] - state: ‘finished’
[13:23:32.028] - run: TRUE
[13:23:32.029] - result: ‘FutureResult’
[13:23:32.029] resolved() for ‘SequentialFuture’ ... done
[13:23:32.029] A SequentialFuture was resolved
[13:23:32.029]  length: 0 (resolved future 1)
[13:23:32.029] resolve() on list ... DONE
[13:23:32.029] - globals: [1] ‘a’
[13:23:32.029] Resolving futures part of globals (recursively) ... DONE
[13:23:32.030] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[13:23:32.030] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[13:23:32.030] - globals: [1] ‘a’
[13:23:32.031] - packages: [1] ‘future’
[13:23:32.031] getGlobalsAndPackages() ... DONE
[13:23:32.031] run() for ‘Future’ ...
[13:23:32.031] - state: ‘created’
[13:23:32.031] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.032] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.032] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.032]   - Field: ‘label’
[13:23:32.032]   - Field: ‘local’
[13:23:32.032]   - Field: ‘owner’
[13:23:32.032]   - Field: ‘envir’
[13:23:32.032]   - Field: ‘packages’
[13:23:32.032]   - Field: ‘gc’
[13:23:32.032]   - Field: ‘conditions’
[13:23:32.032]   - Field: ‘expr’
[13:23:32.033]   - Field: ‘uuid’
[13:23:32.033]   - Field: ‘seed’
[13:23:32.033]   - Field: ‘version’
[13:23:32.033]   - Field: ‘result’
[13:23:32.033]   - Field: ‘asynchronous’
[13:23:32.033]   - Field: ‘calls’
[13:23:32.033]   - Field: ‘globals’
[13:23:32.033]   - Field: ‘stdout’
[13:23:32.033]   - Field: ‘earlySignal’
[13:23:32.033]   - Field: ‘lazy’
[13:23:32.034]   - Field: ‘state’
[13:23:32.034] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.034] - Launch lazy future ...
[13:23:32.034] Packages needed by the future expression (n = 1): ‘future’
[13:23:32.034] Packages needed by future strategies (n = 0): <none>
[13:23:32.035] {
[13:23:32.035]     {
[13:23:32.035]         {
[13:23:32.035]             ...future.startTime <- base::Sys.time()
[13:23:32.035]             {
[13:23:32.035]                 {
[13:23:32.035]                   {
[13:23:32.035]                     {
[13:23:32.035]                       base::local({
[13:23:32.035]                         has_future <- base::requireNamespace("future", 
[13:23:32.035]                           quietly = TRUE)
[13:23:32.035]                         if (has_future) {
[13:23:32.035]                           ns <- base::getNamespace("future")
[13:23:32.035]                           version <- ns[[".package"]][["version"]]
[13:23:32.035]                           if (is.null(version)) 
[13:23:32.035]                             version <- utils::packageVersion("future")
[13:23:32.035]                         }
[13:23:32.035]                         else {
[13:23:32.035]                           version <- NULL
[13:23:32.035]                         }
[13:23:32.035]                         if (!has_future || version < "1.8.0") {
[13:23:32.035]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.035]                             "", base::R.version$version.string), 
[13:23:32.035]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:32.035]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.035]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.035]                               "release", "version")], collapse = " "), 
[13:23:32.035]                             hostname = base::Sys.info()[["nodename"]])
[13:23:32.035]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.035]                             info)
[13:23:32.035]                           info <- base::paste(info, collapse = "; ")
[13:23:32.035]                           if (!has_future) {
[13:23:32.035]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.035]                               info)
[13:23:32.035]                           }
[13:23:32.035]                           else {
[13:23:32.035]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.035]                               info, version)
[13:23:32.035]                           }
[13:23:32.035]                           base::stop(msg)
[13:23:32.035]                         }
[13:23:32.035]                       })
[13:23:32.035]                     }
[13:23:32.035]                     base::local({
[13:23:32.035]                       for (pkg in "future") {
[13:23:32.035]                         base::loadNamespace(pkg)
[13:23:32.035]                         base::library(pkg, character.only = TRUE)
[13:23:32.035]                       }
[13:23:32.035]                     })
[13:23:32.035]                   }
[13:23:32.035]                   options(future.plan = NULL)
[13:23:32.035]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.035]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.035]                 }
[13:23:32.035]                 ...future.workdir <- getwd()
[13:23:32.035]             }
[13:23:32.035]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.035]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.035]         }
[13:23:32.035]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.035]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:32.035]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.035]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.035]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.035]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.035]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.035]             base::names(...future.oldOptions))
[13:23:32.035]     }
[13:23:32.035]     if (FALSE) {
[13:23:32.035]     }
[13:23:32.035]     else {
[13:23:32.035]         if (TRUE) {
[13:23:32.035]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.035]                 open = "w")
[13:23:32.035]         }
[13:23:32.035]         else {
[13:23:32.035]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.035]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.035]         }
[13:23:32.035]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.035]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.035]             base::sink(type = "output", split = FALSE)
[13:23:32.035]             base::close(...future.stdout)
[13:23:32.035]         }, add = TRUE)
[13:23:32.035]     }
[13:23:32.035]     ...future.frame <- base::sys.nframe()
[13:23:32.035]     ...future.conditions <- base::list()
[13:23:32.035]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.035]     if (FALSE) {
[13:23:32.035]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.035]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.035]     }
[13:23:32.035]     ...future.result <- base::tryCatch({
[13:23:32.035]         base::withCallingHandlers({
[13:23:32.035]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:23:32.035]                 1))
[13:23:32.035]             future::FutureResult(value = ...future.value$value, 
[13:23:32.035]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.035]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.035]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.035]                     ...future.globalenv.names))
[13:23:32.035]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.035]         }, condition = base::local({
[13:23:32.035]             c <- base::c
[13:23:32.035]             inherits <- base::inherits
[13:23:32.035]             invokeRestart <- base::invokeRestart
[13:23:32.035]             length <- base::length
[13:23:32.035]             list <- base::list
[13:23:32.035]             seq.int <- base::seq.int
[13:23:32.035]             signalCondition <- base::signalCondition
[13:23:32.035]             sys.calls <- base::sys.calls
[13:23:32.035]             `[[` <- base::`[[`
[13:23:32.035]             `+` <- base::`+`
[13:23:32.035]             `<<-` <- base::`<<-`
[13:23:32.035]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.035]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.035]                   3L)]
[13:23:32.035]             }
[13:23:32.035]             function(cond) {
[13:23:32.035]                 is_error <- inherits(cond, "error")
[13:23:32.035]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.035]                   NULL)
[13:23:32.035]                 if (is_error) {
[13:23:32.035]                   sessionInformation <- function() {
[13:23:32.035]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.035]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.035]                       search = base::search(), system = base::Sys.info())
[13:23:32.035]                   }
[13:23:32.035]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.035]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.035]                     cond$call), session = sessionInformation(), 
[13:23:32.035]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.035]                   signalCondition(cond)
[13:23:32.035]                 }
[13:23:32.035]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.035]                 "immediateCondition"))) {
[13:23:32.035]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.035]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.035]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.035]                   if (TRUE && !signal) {
[13:23:32.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.035]                     {
[13:23:32.035]                       inherits <- base::inherits
[13:23:32.035]                       invokeRestart <- base::invokeRestart
[13:23:32.035]                       is.null <- base::is.null
[13:23:32.035]                       muffled <- FALSE
[13:23:32.035]                       if (inherits(cond, "message")) {
[13:23:32.035]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.035]                         if (muffled) 
[13:23:32.035]                           invokeRestart("muffleMessage")
[13:23:32.035]                       }
[13:23:32.035]                       else if (inherits(cond, "warning")) {
[13:23:32.035]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.035]                         if (muffled) 
[13:23:32.035]                           invokeRestart("muffleWarning")
[13:23:32.035]                       }
[13:23:32.035]                       else if (inherits(cond, "condition")) {
[13:23:32.035]                         if (!is.null(pattern)) {
[13:23:32.035]                           computeRestarts <- base::computeRestarts
[13:23:32.035]                           grepl <- base::grepl
[13:23:32.035]                           restarts <- computeRestarts(cond)
[13:23:32.035]                           for (restart in restarts) {
[13:23:32.035]                             name <- restart$name
[13:23:32.035]                             if (is.null(name)) 
[13:23:32.035]                               next
[13:23:32.035]                             if (!grepl(pattern, name)) 
[13:23:32.035]                               next
[13:23:32.035]                             invokeRestart(restart)
[13:23:32.035]                             muffled <- TRUE
[13:23:32.035]                             break
[13:23:32.035]                           }
[13:23:32.035]                         }
[13:23:32.035]                       }
[13:23:32.035]                       invisible(muffled)
[13:23:32.035]                     }
[13:23:32.035]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.035]                   }
[13:23:32.035]                 }
[13:23:32.035]                 else {
[13:23:32.035]                   if (TRUE) {
[13:23:32.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.035]                     {
[13:23:32.035]                       inherits <- base::inherits
[13:23:32.035]                       invokeRestart <- base::invokeRestart
[13:23:32.035]                       is.null <- base::is.null
[13:23:32.035]                       muffled <- FALSE
[13:23:32.035]                       if (inherits(cond, "message")) {
[13:23:32.035]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.035]                         if (muffled) 
[13:23:32.035]                           invokeRestart("muffleMessage")
[13:23:32.035]                       }
[13:23:32.035]                       else if (inherits(cond, "warning")) {
[13:23:32.035]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.035]                         if (muffled) 
[13:23:32.035]                           invokeRestart("muffleWarning")
[13:23:32.035]                       }
[13:23:32.035]                       else if (inherits(cond, "condition")) {
[13:23:32.035]                         if (!is.null(pattern)) {
[13:23:32.035]                           computeRestarts <- base::computeRestarts
[13:23:32.035]                           grepl <- base::grepl
[13:23:32.035]                           restarts <- computeRestarts(cond)
[13:23:32.035]                           for (restart in restarts) {
[13:23:32.035]                             name <- restart$name
[13:23:32.035]                             if (is.null(name)) 
[13:23:32.035]                               next
[13:23:32.035]                             if (!grepl(pattern, name)) 
[13:23:32.035]                               next
[13:23:32.035]                             invokeRestart(restart)
[13:23:32.035]                             muffled <- TRUE
[13:23:32.035]                             break
[13:23:32.035]                           }
[13:23:32.035]                         }
[13:23:32.035]                       }
[13:23:32.035]                       invisible(muffled)
[13:23:32.035]                     }
[13:23:32.035]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.035]                   }
[13:23:32.035]                 }
[13:23:32.035]             }
[13:23:32.035]         }))
[13:23:32.035]     }, error = function(ex) {
[13:23:32.035]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.035]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.035]                 ...future.rng), started = ...future.startTime, 
[13:23:32.035]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.035]             version = "1.8"), class = "FutureResult")
[13:23:32.035]     }, finally = {
[13:23:32.035]         if (!identical(...future.workdir, getwd())) 
[13:23:32.035]             setwd(...future.workdir)
[13:23:32.035]         {
[13:23:32.035]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.035]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.035]             }
[13:23:32.035]             base::options(...future.oldOptions)
[13:23:32.035]             if (.Platform$OS.type == "windows") {
[13:23:32.035]                 old_names <- names(...future.oldEnvVars)
[13:23:32.035]                 envs <- base::Sys.getenv()
[13:23:32.035]                 names <- names(envs)
[13:23:32.035]                 common <- intersect(names, old_names)
[13:23:32.035]                 added <- setdiff(names, old_names)
[13:23:32.035]                 removed <- setdiff(old_names, names)
[13:23:32.035]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.035]                   envs[common]]
[13:23:32.035]                 NAMES <- toupper(changed)
[13:23:32.035]                 args <- list()
[13:23:32.035]                 for (kk in seq_along(NAMES)) {
[13:23:32.035]                   name <- changed[[kk]]
[13:23:32.035]                   NAME <- NAMES[[kk]]
[13:23:32.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.035]                     next
[13:23:32.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.035]                 }
[13:23:32.035]                 NAMES <- toupper(added)
[13:23:32.035]                 for (kk in seq_along(NAMES)) {
[13:23:32.035]                   name <- added[[kk]]
[13:23:32.035]                   NAME <- NAMES[[kk]]
[13:23:32.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.035]                     next
[13:23:32.035]                   args[[name]] <- ""
[13:23:32.035]                 }
[13:23:32.035]                 NAMES <- toupper(removed)
[13:23:32.035]                 for (kk in seq_along(NAMES)) {
[13:23:32.035]                   name <- removed[[kk]]
[13:23:32.035]                   NAME <- NAMES[[kk]]
[13:23:32.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.035]                     next
[13:23:32.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.035]                 }
[13:23:32.035]                 if (length(args) > 0) 
[13:23:32.035]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.035]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.035]             }
[13:23:32.035]             else {
[13:23:32.035]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.035]             }
[13:23:32.035]             {
[13:23:32.035]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.035]                   0L) {
[13:23:32.035]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.035]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.035]                   base::options(opts)
[13:23:32.035]                 }
[13:23:32.035]                 {
[13:23:32.035]                   {
[13:23:32.035]                     NULL
[13:23:32.035]                     RNGkind("Mersenne-Twister")
[13:23:32.035]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.035]                       inherits = FALSE)
[13:23:32.035]                   }
[13:23:32.035]                   options(future.plan = NULL)
[13:23:32.035]                   if (is.na(NA_character_)) 
[13:23:32.035]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.035]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.035]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.035]                   {
[13:23:32.035]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.035]                     if (!future$lazy) 
[13:23:32.035]                       future <- run(future)
[13:23:32.035]                     invisible(future)
[13:23:32.035]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.035]                 }
[13:23:32.035]             }
[13:23:32.035]         }
[13:23:32.035]     })
[13:23:32.035]     if (TRUE) {
[13:23:32.035]         base::sink(type = "output", split = FALSE)
[13:23:32.035]         if (TRUE) {
[13:23:32.035]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.035]         }
[13:23:32.035]         else {
[13:23:32.035]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.035]         }
[13:23:32.035]         base::close(...future.stdout)
[13:23:32.035]         ...future.stdout <- NULL
[13:23:32.035]     }
[13:23:32.035]     ...future.result$conditions <- ...future.conditions
[13:23:32.035]     ...future.result$finished <- base::Sys.time()
[13:23:32.035]     ...future.result
[13:23:32.035] }
[13:23:32.036] assign_globals() ...
[13:23:32.036] List of 1
[13:23:32.036]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5589bd5a0378> 
[13:23:32.036]  - attr(*, "where")=List of 1
[13:23:32.036]   ..$ a:<environment: R_EmptyEnv> 
[13:23:32.036]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.036]  - attr(*, "resolved")= logi TRUE
[13:23:32.036]  - attr(*, "total_size")= num 10424
[13:23:32.036]  - attr(*, "already-done")= logi TRUE
[13:23:32.039] - copied ‘a’ to environment
[13:23:32.039] assign_globals() ... done
[13:23:32.040] plan(): Setting new future strategy stack:
[13:23:32.040] List of future strategies:
[13:23:32.040] 1. sequential:
[13:23:32.040]    - args: function (..., envir = parent.frame())
[13:23:32.040]    - tweaked: FALSE
[13:23:32.040]    - call: NULL
[13:23:32.040] plan(): nbrOfWorkers() = 1
[13:23:32.041] plan(): Setting new future strategy stack:
[13:23:32.041] List of future strategies:
[13:23:32.041] 1. sequential:
[13:23:32.041]    - args: function (..., envir = parent.frame())
[13:23:32.041]    - tweaked: FALSE
[13:23:32.041]    - call: plan(strategy)
[13:23:32.042] plan(): nbrOfWorkers() = 1
[13:23:32.042] SequentialFuture started (and completed)
[13:23:32.044] - Launch lazy future ... done
[13:23:32.044] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.045] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.045] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:32.045] 
[13:23:32.045] Searching for globals ... DONE
[13:23:32.046] - globals: [0] <none>
[13:23:32.046] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.046] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.046] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:32.047] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:32.047] Searching for globals ... DONE
[13:23:32.047] Resolving globals: TRUE
[13:23:32.047] Resolving any globals that are futures ...
[13:23:32.048] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:32.048] Resolving any globals that are futures ... DONE
[13:23:32.048] Resolving futures part of globals (recursively) ...
[13:23:32.048] resolve() on list ...
[13:23:32.048]  recursive: 99
[13:23:32.048]  length: 1
[13:23:32.049]  elements: ‘a’
[13:23:32.049] run() for ‘Future’ ...
[13:23:32.049] - state: ‘created’
[13:23:32.049] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.049] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.049] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.049]   - Field: ‘label’
[13:23:32.050]   - Field: ‘local’
[13:23:32.050]   - Field: ‘owner’
[13:23:32.050]   - Field: ‘envir’
[13:23:32.050]   - Field: ‘packages’
[13:23:32.050]   - Field: ‘gc’
[13:23:32.050]   - Field: ‘conditions’
[13:23:32.050]   - Field: ‘expr’
[13:23:32.050]   - Field: ‘uuid’
[13:23:32.050]   - Field: ‘seed’
[13:23:32.050]   - Field: ‘version’
[13:23:32.050]   - Field: ‘result’
[13:23:32.051]   - Field: ‘asynchronous’
[13:23:32.051]   - Field: ‘calls’
[13:23:32.051]   - Field: ‘globals’
[13:23:32.051]   - Field: ‘stdout’
[13:23:32.051]   - Field: ‘earlySignal’
[13:23:32.051]   - Field: ‘lazy’
[13:23:32.051]   - Field: ‘state’
[13:23:32.051] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.051] - Launch lazy future ...
[13:23:32.052] Packages needed by the future expression (n = 0): <none>
[13:23:32.052] Packages needed by future strategies (n = 0): <none>
[13:23:32.052] {
[13:23:32.052]     {
[13:23:32.052]         {
[13:23:32.052]             ...future.startTime <- base::Sys.time()
[13:23:32.052]             {
[13:23:32.052]                 {
[13:23:32.052]                   {
[13:23:32.052]                     base::local({
[13:23:32.052]                       has_future <- base::requireNamespace("future", 
[13:23:32.052]                         quietly = TRUE)
[13:23:32.052]                       if (has_future) {
[13:23:32.052]                         ns <- base::getNamespace("future")
[13:23:32.052]                         version <- ns[[".package"]][["version"]]
[13:23:32.052]                         if (is.null(version)) 
[13:23:32.052]                           version <- utils::packageVersion("future")
[13:23:32.052]                       }
[13:23:32.052]                       else {
[13:23:32.052]                         version <- NULL
[13:23:32.052]                       }
[13:23:32.052]                       if (!has_future || version < "1.8.0") {
[13:23:32.052]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.052]                           "", base::R.version$version.string), 
[13:23:32.052]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:32.052]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.052]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.052]                             "release", "version")], collapse = " "), 
[13:23:32.052]                           hostname = base::Sys.info()[["nodename"]])
[13:23:32.052]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.052]                           info)
[13:23:32.052]                         info <- base::paste(info, collapse = "; ")
[13:23:32.052]                         if (!has_future) {
[13:23:32.052]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.052]                             info)
[13:23:32.052]                         }
[13:23:32.052]                         else {
[13:23:32.052]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.052]                             info, version)
[13:23:32.052]                         }
[13:23:32.052]                         base::stop(msg)
[13:23:32.052]                       }
[13:23:32.052]                     })
[13:23:32.052]                   }
[13:23:32.052]                   options(future.plan = NULL)
[13:23:32.052]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.052]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.052]                 }
[13:23:32.052]                 ...future.workdir <- getwd()
[13:23:32.052]             }
[13:23:32.052]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.052]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.052]         }
[13:23:32.052]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.052]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:32.052]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.052]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.052]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.052]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.052]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.052]             base::names(...future.oldOptions))
[13:23:32.052]     }
[13:23:32.052]     if (FALSE) {
[13:23:32.052]     }
[13:23:32.052]     else {
[13:23:32.052]         if (TRUE) {
[13:23:32.052]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.052]                 open = "w")
[13:23:32.052]         }
[13:23:32.052]         else {
[13:23:32.052]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.052]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.052]         }
[13:23:32.052]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.052]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.052]             base::sink(type = "output", split = FALSE)
[13:23:32.052]             base::close(...future.stdout)
[13:23:32.052]         }, add = TRUE)
[13:23:32.052]     }
[13:23:32.052]     ...future.frame <- base::sys.nframe()
[13:23:32.052]     ...future.conditions <- base::list()
[13:23:32.052]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.052]     if (FALSE) {
[13:23:32.052]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.052]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.052]     }
[13:23:32.052]     ...future.result <- base::tryCatch({
[13:23:32.052]         base::withCallingHandlers({
[13:23:32.052]             ...future.value <- base::withVisible(base::local(1))
[13:23:32.052]             future::FutureResult(value = ...future.value$value, 
[13:23:32.052]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.052]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.052]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.052]                     ...future.globalenv.names))
[13:23:32.052]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.052]         }, condition = base::local({
[13:23:32.052]             c <- base::c
[13:23:32.052]             inherits <- base::inherits
[13:23:32.052]             invokeRestart <- base::invokeRestart
[13:23:32.052]             length <- base::length
[13:23:32.052]             list <- base::list
[13:23:32.052]             seq.int <- base::seq.int
[13:23:32.052]             signalCondition <- base::signalCondition
[13:23:32.052]             sys.calls <- base::sys.calls
[13:23:32.052]             `[[` <- base::`[[`
[13:23:32.052]             `+` <- base::`+`
[13:23:32.052]             `<<-` <- base::`<<-`
[13:23:32.052]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.052]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.052]                   3L)]
[13:23:32.052]             }
[13:23:32.052]             function(cond) {
[13:23:32.052]                 is_error <- inherits(cond, "error")
[13:23:32.052]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.052]                   NULL)
[13:23:32.052]                 if (is_error) {
[13:23:32.052]                   sessionInformation <- function() {
[13:23:32.052]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.052]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.052]                       search = base::search(), system = base::Sys.info())
[13:23:32.052]                   }
[13:23:32.052]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.052]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.052]                     cond$call), session = sessionInformation(), 
[13:23:32.052]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.052]                   signalCondition(cond)
[13:23:32.052]                 }
[13:23:32.052]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.052]                 "immediateCondition"))) {
[13:23:32.052]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.052]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.052]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.052]                   if (TRUE && !signal) {
[13:23:32.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.052]                     {
[13:23:32.052]                       inherits <- base::inherits
[13:23:32.052]                       invokeRestart <- base::invokeRestart
[13:23:32.052]                       is.null <- base::is.null
[13:23:32.052]                       muffled <- FALSE
[13:23:32.052]                       if (inherits(cond, "message")) {
[13:23:32.052]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.052]                         if (muffled) 
[13:23:32.052]                           invokeRestart("muffleMessage")
[13:23:32.052]                       }
[13:23:32.052]                       else if (inherits(cond, "warning")) {
[13:23:32.052]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.052]                         if (muffled) 
[13:23:32.052]                           invokeRestart("muffleWarning")
[13:23:32.052]                       }
[13:23:32.052]                       else if (inherits(cond, "condition")) {
[13:23:32.052]                         if (!is.null(pattern)) {
[13:23:32.052]                           computeRestarts <- base::computeRestarts
[13:23:32.052]                           grepl <- base::grepl
[13:23:32.052]                           restarts <- computeRestarts(cond)
[13:23:32.052]                           for (restart in restarts) {
[13:23:32.052]                             name <- restart$name
[13:23:32.052]                             if (is.null(name)) 
[13:23:32.052]                               next
[13:23:32.052]                             if (!grepl(pattern, name)) 
[13:23:32.052]                               next
[13:23:32.052]                             invokeRestart(restart)
[13:23:32.052]                             muffled <- TRUE
[13:23:32.052]                             break
[13:23:32.052]                           }
[13:23:32.052]                         }
[13:23:32.052]                       }
[13:23:32.052]                       invisible(muffled)
[13:23:32.052]                     }
[13:23:32.052]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.052]                   }
[13:23:32.052]                 }
[13:23:32.052]                 else {
[13:23:32.052]                   if (TRUE) {
[13:23:32.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.052]                     {
[13:23:32.052]                       inherits <- base::inherits
[13:23:32.052]                       invokeRestart <- base::invokeRestart
[13:23:32.052]                       is.null <- base::is.null
[13:23:32.052]                       muffled <- FALSE
[13:23:32.052]                       if (inherits(cond, "message")) {
[13:23:32.052]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.052]                         if (muffled) 
[13:23:32.052]                           invokeRestart("muffleMessage")
[13:23:32.052]                       }
[13:23:32.052]                       else if (inherits(cond, "warning")) {
[13:23:32.052]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.052]                         if (muffled) 
[13:23:32.052]                           invokeRestart("muffleWarning")
[13:23:32.052]                       }
[13:23:32.052]                       else if (inherits(cond, "condition")) {
[13:23:32.052]                         if (!is.null(pattern)) {
[13:23:32.052]                           computeRestarts <- base::computeRestarts
[13:23:32.052]                           grepl <- base::grepl
[13:23:32.052]                           restarts <- computeRestarts(cond)
[13:23:32.052]                           for (restart in restarts) {
[13:23:32.052]                             name <- restart$name
[13:23:32.052]                             if (is.null(name)) 
[13:23:32.052]                               next
[13:23:32.052]                             if (!grepl(pattern, name)) 
[13:23:32.052]                               next
[13:23:32.052]                             invokeRestart(restart)
[13:23:32.052]                             muffled <- TRUE
[13:23:32.052]                             break
[13:23:32.052]                           }
[13:23:32.052]                         }
[13:23:32.052]                       }
[13:23:32.052]                       invisible(muffled)
[13:23:32.052]                     }
[13:23:32.052]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.052]                   }
[13:23:32.052]                 }
[13:23:32.052]             }
[13:23:32.052]         }))
[13:23:32.052]     }, error = function(ex) {
[13:23:32.052]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.052]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.052]                 ...future.rng), started = ...future.startTime, 
[13:23:32.052]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.052]             version = "1.8"), class = "FutureResult")
[13:23:32.052]     }, finally = {
[13:23:32.052]         if (!identical(...future.workdir, getwd())) 
[13:23:32.052]             setwd(...future.workdir)
[13:23:32.052]         {
[13:23:32.052]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.052]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.052]             }
[13:23:32.052]             base::options(...future.oldOptions)
[13:23:32.052]             if (.Platform$OS.type == "windows") {
[13:23:32.052]                 old_names <- names(...future.oldEnvVars)
[13:23:32.052]                 envs <- base::Sys.getenv()
[13:23:32.052]                 names <- names(envs)
[13:23:32.052]                 common <- intersect(names, old_names)
[13:23:32.052]                 added <- setdiff(names, old_names)
[13:23:32.052]                 removed <- setdiff(old_names, names)
[13:23:32.052]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.052]                   envs[common]]
[13:23:32.052]                 NAMES <- toupper(changed)
[13:23:32.052]                 args <- list()
[13:23:32.052]                 for (kk in seq_along(NAMES)) {
[13:23:32.052]                   name <- changed[[kk]]
[13:23:32.052]                   NAME <- NAMES[[kk]]
[13:23:32.052]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.052]                     next
[13:23:32.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.052]                 }
[13:23:32.052]                 NAMES <- toupper(added)
[13:23:32.052]                 for (kk in seq_along(NAMES)) {
[13:23:32.052]                   name <- added[[kk]]
[13:23:32.052]                   NAME <- NAMES[[kk]]
[13:23:32.052]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.052]                     next
[13:23:32.052]                   args[[name]] <- ""
[13:23:32.052]                 }
[13:23:32.052]                 NAMES <- toupper(removed)
[13:23:32.052]                 for (kk in seq_along(NAMES)) {
[13:23:32.052]                   name <- removed[[kk]]
[13:23:32.052]                   NAME <- NAMES[[kk]]
[13:23:32.052]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.052]                     next
[13:23:32.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.052]                 }
[13:23:32.052]                 if (length(args) > 0) 
[13:23:32.052]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.052]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.052]             }
[13:23:32.052]             else {
[13:23:32.052]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.052]             }
[13:23:32.052]             {
[13:23:32.052]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.052]                   0L) {
[13:23:32.052]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.052]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.052]                   base::options(opts)
[13:23:32.052]                 }
[13:23:32.052]                 {
[13:23:32.052]                   {
[13:23:32.052]                     NULL
[13:23:32.052]                     RNGkind("Mersenne-Twister")
[13:23:32.052]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.052]                       inherits = FALSE)
[13:23:32.052]                   }
[13:23:32.052]                   options(future.plan = NULL)
[13:23:32.052]                   if (is.na(NA_character_)) 
[13:23:32.052]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.052]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.052]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.052]                   {
[13:23:32.052]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.052]                     if (!future$lazy) 
[13:23:32.052]                       future <- run(future)
[13:23:32.052]                     invisible(future)
[13:23:32.052]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.052]                 }
[13:23:32.052]             }
[13:23:32.052]         }
[13:23:32.052]     })
[13:23:32.052]     if (TRUE) {
[13:23:32.052]         base::sink(type = "output", split = FALSE)
[13:23:32.052]         if (TRUE) {
[13:23:32.052]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.052]         }
[13:23:32.052]         else {
[13:23:32.052]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.052]         }
[13:23:32.052]         base::close(...future.stdout)
[13:23:32.052]         ...future.stdout <- NULL
[13:23:32.052]     }
[13:23:32.052]     ...future.result$conditions <- ...future.conditions
[13:23:32.052]     ...future.result$finished <- base::Sys.time()
[13:23:32.052]     ...future.result
[13:23:32.052] }
[13:23:32.054] plan(): Setting new future strategy stack:
[13:23:32.054] List of future strategies:
[13:23:32.054] 1. sequential:
[13:23:32.054]    - args: function (..., envir = parent.frame())
[13:23:32.054]    - tweaked: FALSE
[13:23:32.054]    - call: NULL
[13:23:32.055] plan(): nbrOfWorkers() = 1
[13:23:32.055] plan(): Setting new future strategy stack:
[13:23:32.055] List of future strategies:
[13:23:32.055] 1. sequential:
[13:23:32.055]    - args: function (..., envir = parent.frame())
[13:23:32.055]    - tweaked: FALSE
[13:23:32.055]    - call: plan(strategy)
[13:23:32.056] plan(): nbrOfWorkers() = 1
[13:23:32.056] SequentialFuture started (and completed)
[13:23:32.056] - Launch lazy future ... done
[13:23:32.056] run() for ‘SequentialFuture’ ... done
[13:23:32.056] resolved() for ‘SequentialFuture’ ...
[13:23:32.056] - state: ‘finished’
[13:23:32.057] - run: TRUE
[13:23:32.057] - result: ‘FutureResult’
[13:23:32.057] resolved() for ‘SequentialFuture’ ... done
[13:23:32.057] Future #1
[13:23:32.057] resolved() for ‘SequentialFuture’ ...
[13:23:32.057] - state: ‘finished’
[13:23:32.057] - run: TRUE
[13:23:32.057] - result: ‘FutureResult’
[13:23:32.057] resolved() for ‘SequentialFuture’ ... done
[13:23:32.057] A SequentialFuture was resolved
[13:23:32.058]  length: 0 (resolved future 1)
[13:23:32.058] resolve() on list ... DONE
[13:23:32.058] - globals: [1] ‘a’
[13:23:32.058] Resolving futures part of globals (recursively) ... DONE
[13:23:32.059] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[13:23:32.059] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[13:23:32.059] - globals: [1] ‘a’
[13:23:32.059] - packages: [1] ‘future’
[13:23:32.059] getGlobalsAndPackages() ... DONE
[13:23:32.060] run() for ‘Future’ ...
[13:23:32.060] - state: ‘created’
[13:23:32.060] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.060] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.060] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.060]   - Field: ‘label’
[13:23:32.061]   - Field: ‘local’
[13:23:32.061]   - Field: ‘owner’
[13:23:32.061]   - Field: ‘envir’
[13:23:32.061]   - Field: ‘packages’
[13:23:32.061]   - Field: ‘gc’
[13:23:32.061]   - Field: ‘conditions’
[13:23:32.061]   - Field: ‘expr’
[13:23:32.061]   - Field: ‘uuid’
[13:23:32.061]   - Field: ‘seed’
[13:23:32.061]   - Field: ‘version’
[13:23:32.062]   - Field: ‘result’
[13:23:32.062]   - Field: ‘asynchronous’
[13:23:32.062]   - Field: ‘calls’
[13:23:32.062]   - Field: ‘globals’
[13:23:32.062]   - Field: ‘stdout’
[13:23:32.062]   - Field: ‘earlySignal’
[13:23:32.062]   - Field: ‘lazy’
[13:23:32.062]   - Field: ‘state’
[13:23:32.062] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.062] - Launch lazy future ...
[13:23:32.063] Packages needed by the future expression (n = 1): ‘future’
[13:23:32.063] Packages needed by future strategies (n = 0): <none>
[13:23:32.063] {
[13:23:32.063]     {
[13:23:32.063]         {
[13:23:32.063]             ...future.startTime <- base::Sys.time()
[13:23:32.063]             {
[13:23:32.063]                 {
[13:23:32.063]                   {
[13:23:32.063]                     {
[13:23:32.063]                       base::local({
[13:23:32.063]                         has_future <- base::requireNamespace("future", 
[13:23:32.063]                           quietly = TRUE)
[13:23:32.063]                         if (has_future) {
[13:23:32.063]                           ns <- base::getNamespace("future")
[13:23:32.063]                           version <- ns[[".package"]][["version"]]
[13:23:32.063]                           if (is.null(version)) 
[13:23:32.063]                             version <- utils::packageVersion("future")
[13:23:32.063]                         }
[13:23:32.063]                         else {
[13:23:32.063]                           version <- NULL
[13:23:32.063]                         }
[13:23:32.063]                         if (!has_future || version < "1.8.0") {
[13:23:32.063]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.063]                             "", base::R.version$version.string), 
[13:23:32.063]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:32.063]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.063]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.063]                               "release", "version")], collapse = " "), 
[13:23:32.063]                             hostname = base::Sys.info()[["nodename"]])
[13:23:32.063]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.063]                             info)
[13:23:32.063]                           info <- base::paste(info, collapse = "; ")
[13:23:32.063]                           if (!has_future) {
[13:23:32.063]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.063]                               info)
[13:23:32.063]                           }
[13:23:32.063]                           else {
[13:23:32.063]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.063]                               info, version)
[13:23:32.063]                           }
[13:23:32.063]                           base::stop(msg)
[13:23:32.063]                         }
[13:23:32.063]                       })
[13:23:32.063]                     }
[13:23:32.063]                     base::local({
[13:23:32.063]                       for (pkg in "future") {
[13:23:32.063]                         base::loadNamespace(pkg)
[13:23:32.063]                         base::library(pkg, character.only = TRUE)
[13:23:32.063]                       }
[13:23:32.063]                     })
[13:23:32.063]                   }
[13:23:32.063]                   options(future.plan = NULL)
[13:23:32.063]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.063]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.063]                 }
[13:23:32.063]                 ...future.workdir <- getwd()
[13:23:32.063]             }
[13:23:32.063]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.063]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.063]         }
[13:23:32.063]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.063]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:32.063]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.063]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.063]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.063]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.063]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.063]             base::names(...future.oldOptions))
[13:23:32.063]     }
[13:23:32.063]     if (FALSE) {
[13:23:32.063]     }
[13:23:32.063]     else {
[13:23:32.063]         if (TRUE) {
[13:23:32.063]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.063]                 open = "w")
[13:23:32.063]         }
[13:23:32.063]         else {
[13:23:32.063]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.063]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.063]         }
[13:23:32.063]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.063]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.063]             base::sink(type = "output", split = FALSE)
[13:23:32.063]             base::close(...future.stdout)
[13:23:32.063]         }, add = TRUE)
[13:23:32.063]     }
[13:23:32.063]     ...future.frame <- base::sys.nframe()
[13:23:32.063]     ...future.conditions <- base::list()
[13:23:32.063]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.063]     if (FALSE) {
[13:23:32.063]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.063]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.063]     }
[13:23:32.063]     ...future.result <- base::tryCatch({
[13:23:32.063]         base::withCallingHandlers({
[13:23:32.063]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:23:32.063]                 1))
[13:23:32.063]             future::FutureResult(value = ...future.value$value, 
[13:23:32.063]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.063]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.063]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.063]                     ...future.globalenv.names))
[13:23:32.063]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.063]         }, condition = base::local({
[13:23:32.063]             c <- base::c
[13:23:32.063]             inherits <- base::inherits
[13:23:32.063]             invokeRestart <- base::invokeRestart
[13:23:32.063]             length <- base::length
[13:23:32.063]             list <- base::list
[13:23:32.063]             seq.int <- base::seq.int
[13:23:32.063]             signalCondition <- base::signalCondition
[13:23:32.063]             sys.calls <- base::sys.calls
[13:23:32.063]             `[[` <- base::`[[`
[13:23:32.063]             `+` <- base::`+`
[13:23:32.063]             `<<-` <- base::`<<-`
[13:23:32.063]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.063]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.063]                   3L)]
[13:23:32.063]             }
[13:23:32.063]             function(cond) {
[13:23:32.063]                 is_error <- inherits(cond, "error")
[13:23:32.063]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.063]                   NULL)
[13:23:32.063]                 if (is_error) {
[13:23:32.063]                   sessionInformation <- function() {
[13:23:32.063]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.063]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.063]                       search = base::search(), system = base::Sys.info())
[13:23:32.063]                   }
[13:23:32.063]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.063]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.063]                     cond$call), session = sessionInformation(), 
[13:23:32.063]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.063]                   signalCondition(cond)
[13:23:32.063]                 }
[13:23:32.063]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.063]                 "immediateCondition"))) {
[13:23:32.063]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.063]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.063]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.063]                   if (TRUE && !signal) {
[13:23:32.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.063]                     {
[13:23:32.063]                       inherits <- base::inherits
[13:23:32.063]                       invokeRestart <- base::invokeRestart
[13:23:32.063]                       is.null <- base::is.null
[13:23:32.063]                       muffled <- FALSE
[13:23:32.063]                       if (inherits(cond, "message")) {
[13:23:32.063]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.063]                         if (muffled) 
[13:23:32.063]                           invokeRestart("muffleMessage")
[13:23:32.063]                       }
[13:23:32.063]                       else if (inherits(cond, "warning")) {
[13:23:32.063]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.063]                         if (muffled) 
[13:23:32.063]                           invokeRestart("muffleWarning")
[13:23:32.063]                       }
[13:23:32.063]                       else if (inherits(cond, "condition")) {
[13:23:32.063]                         if (!is.null(pattern)) {
[13:23:32.063]                           computeRestarts <- base::computeRestarts
[13:23:32.063]                           grepl <- base::grepl
[13:23:32.063]                           restarts <- computeRestarts(cond)
[13:23:32.063]                           for (restart in restarts) {
[13:23:32.063]                             name <- restart$name
[13:23:32.063]                             if (is.null(name)) 
[13:23:32.063]                               next
[13:23:32.063]                             if (!grepl(pattern, name)) 
[13:23:32.063]                               next
[13:23:32.063]                             invokeRestart(restart)
[13:23:32.063]                             muffled <- TRUE
[13:23:32.063]                             break
[13:23:32.063]                           }
[13:23:32.063]                         }
[13:23:32.063]                       }
[13:23:32.063]                       invisible(muffled)
[13:23:32.063]                     }
[13:23:32.063]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.063]                   }
[13:23:32.063]                 }
[13:23:32.063]                 else {
[13:23:32.063]                   if (TRUE) {
[13:23:32.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.063]                     {
[13:23:32.063]                       inherits <- base::inherits
[13:23:32.063]                       invokeRestart <- base::invokeRestart
[13:23:32.063]                       is.null <- base::is.null
[13:23:32.063]                       muffled <- FALSE
[13:23:32.063]                       if (inherits(cond, "message")) {
[13:23:32.063]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.063]                         if (muffled) 
[13:23:32.063]                           invokeRestart("muffleMessage")
[13:23:32.063]                       }
[13:23:32.063]                       else if (inherits(cond, "warning")) {
[13:23:32.063]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.063]                         if (muffled) 
[13:23:32.063]                           invokeRestart("muffleWarning")
[13:23:32.063]                       }
[13:23:32.063]                       else if (inherits(cond, "condition")) {
[13:23:32.063]                         if (!is.null(pattern)) {
[13:23:32.063]                           computeRestarts <- base::computeRestarts
[13:23:32.063]                           grepl <- base::grepl
[13:23:32.063]                           restarts <- computeRestarts(cond)
[13:23:32.063]                           for (restart in restarts) {
[13:23:32.063]                             name <- restart$name
[13:23:32.063]                             if (is.null(name)) 
[13:23:32.063]                               next
[13:23:32.063]                             if (!grepl(pattern, name)) 
[13:23:32.063]                               next
[13:23:32.063]                             invokeRestart(restart)
[13:23:32.063]                             muffled <- TRUE
[13:23:32.063]                             break
[13:23:32.063]                           }
[13:23:32.063]                         }
[13:23:32.063]                       }
[13:23:32.063]                       invisible(muffled)
[13:23:32.063]                     }
[13:23:32.063]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.063]                   }
[13:23:32.063]                 }
[13:23:32.063]             }
[13:23:32.063]         }))
[13:23:32.063]     }, error = function(ex) {
[13:23:32.063]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.063]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.063]                 ...future.rng), started = ...future.startTime, 
[13:23:32.063]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.063]             version = "1.8"), class = "FutureResult")
[13:23:32.063]     }, finally = {
[13:23:32.063]         if (!identical(...future.workdir, getwd())) 
[13:23:32.063]             setwd(...future.workdir)
[13:23:32.063]         {
[13:23:32.063]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.063]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.063]             }
[13:23:32.063]             base::options(...future.oldOptions)
[13:23:32.063]             if (.Platform$OS.type == "windows") {
[13:23:32.063]                 old_names <- names(...future.oldEnvVars)
[13:23:32.063]                 envs <- base::Sys.getenv()
[13:23:32.063]                 names <- names(envs)
[13:23:32.063]                 common <- intersect(names, old_names)
[13:23:32.063]                 added <- setdiff(names, old_names)
[13:23:32.063]                 removed <- setdiff(old_names, names)
[13:23:32.063]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.063]                   envs[common]]
[13:23:32.063]                 NAMES <- toupper(changed)
[13:23:32.063]                 args <- list()
[13:23:32.063]                 for (kk in seq_along(NAMES)) {
[13:23:32.063]                   name <- changed[[kk]]
[13:23:32.063]                   NAME <- NAMES[[kk]]
[13:23:32.063]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.063]                     next
[13:23:32.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.063]                 }
[13:23:32.063]                 NAMES <- toupper(added)
[13:23:32.063]                 for (kk in seq_along(NAMES)) {
[13:23:32.063]                   name <- added[[kk]]
[13:23:32.063]                   NAME <- NAMES[[kk]]
[13:23:32.063]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.063]                     next
[13:23:32.063]                   args[[name]] <- ""
[13:23:32.063]                 }
[13:23:32.063]                 NAMES <- toupper(removed)
[13:23:32.063]                 for (kk in seq_along(NAMES)) {
[13:23:32.063]                   name <- removed[[kk]]
[13:23:32.063]                   NAME <- NAMES[[kk]]
[13:23:32.063]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.063]                     next
[13:23:32.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.063]                 }
[13:23:32.063]                 if (length(args) > 0) 
[13:23:32.063]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.063]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.063]             }
[13:23:32.063]             else {
[13:23:32.063]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.063]             }
[13:23:32.063]             {
[13:23:32.063]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.063]                   0L) {
[13:23:32.063]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.063]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.063]                   base::options(opts)
[13:23:32.063]                 }
[13:23:32.063]                 {
[13:23:32.063]                   {
[13:23:32.063]                     NULL
[13:23:32.063]                     RNGkind("Mersenne-Twister")
[13:23:32.063]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.063]                       inherits = FALSE)
[13:23:32.063]                   }
[13:23:32.063]                   options(future.plan = NULL)
[13:23:32.063]                   if (is.na(NA_character_)) 
[13:23:32.063]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.063]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.063]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.063]                   {
[13:23:32.063]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.063]                     if (!future$lazy) 
[13:23:32.063]                       future <- run(future)
[13:23:32.063]                     invisible(future)
[13:23:32.063]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.063]                 }
[13:23:32.063]             }
[13:23:32.063]         }
[13:23:32.063]     })
[13:23:32.063]     if (TRUE) {
[13:23:32.063]         base::sink(type = "output", split = FALSE)
[13:23:32.063]         if (TRUE) {
[13:23:32.063]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.063]         }
[13:23:32.063]         else {
[13:23:32.063]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.063]         }
[13:23:32.063]         base::close(...future.stdout)
[13:23:32.063]         ...future.stdout <- NULL
[13:23:32.063]     }
[13:23:32.063]     ...future.result$conditions <- ...future.conditions
[13:23:32.063]     ...future.result$finished <- base::Sys.time()
[13:23:32.063]     ...future.result
[13:23:32.063] }
[13:23:32.065] assign_globals() ...
[13:23:32.065] List of 1
[13:23:32.065]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5589bdb43c10> 
[13:23:32.065]  - attr(*, "where")=List of 1
[13:23:32.065]   ..$ a:<environment: R_EmptyEnv> 
[13:23:32.065]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.065]  - attr(*, "resolved")= logi TRUE
[13:23:32.065]  - attr(*, "total_size")= num 10592
[13:23:32.065]  - attr(*, "already-done")= logi TRUE
[13:23:32.068] - copied ‘a’ to environment
[13:23:32.068] assign_globals() ... done
[13:23:32.068] plan(): Setting new future strategy stack:
[13:23:32.068] List of future strategies:
[13:23:32.068] 1. sequential:
[13:23:32.068]    - args: function (..., envir = parent.frame())
[13:23:32.068]    - tweaked: FALSE
[13:23:32.068]    - call: NULL
[13:23:32.069] plan(): nbrOfWorkers() = 1
[13:23:32.070] plan(): Setting new future strategy stack:
[13:23:32.070] List of future strategies:
[13:23:32.070] 1. sequential:
[13:23:32.070]    - args: function (..., envir = parent.frame())
[13:23:32.070]    - tweaked: FALSE
[13:23:32.070]    - call: plan(strategy)
[13:23:32.070] plan(): nbrOfWorkers() = 1
[13:23:32.070] SequentialFuture started (and completed)
[13:23:32.070] - Launch lazy future ... done
[13:23:32.070] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.071] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.071] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:32.072] 
[13:23:32.072] Searching for globals ... DONE
[13:23:32.072] - globals: [0] <none>
[13:23:32.072] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.074] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.075] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:32.076] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:32.076] Searching for globals ... DONE
[13:23:32.076] Resolving globals: TRUE
[13:23:32.076] Resolving any globals that are futures ...
[13:23:32.076] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:32.076] Resolving any globals that are futures ... DONE
[13:23:32.077] Resolving futures part of globals (recursively) ...
[13:23:32.077] resolve() on list ...
[13:23:32.077]  recursive: 99
[13:23:32.077]  length: 1
[13:23:32.077]  elements: ‘a’
[13:23:32.077] run() for ‘Future’ ...
[13:23:32.077] - state: ‘created’
[13:23:32.077] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.078] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.078] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.078]   - Field: ‘label’
[13:23:32.078]   - Field: ‘local’
[13:23:32.078]   - Field: ‘owner’
[13:23:32.078]   - Field: ‘envir’
[13:23:32.078]   - Field: ‘packages’
[13:23:32.078]   - Field: ‘gc’
[13:23:32.079]   - Field: ‘conditions’
[13:23:32.079]   - Field: ‘expr’
[13:23:32.079]   - Field: ‘uuid’
[13:23:32.079]   - Field: ‘seed’
[13:23:32.079]   - Field: ‘version’
[13:23:32.079]   - Field: ‘result’
[13:23:32.079]   - Field: ‘asynchronous’
[13:23:32.079]   - Field: ‘calls’
[13:23:32.079]   - Field: ‘globals’
[13:23:32.079]   - Field: ‘stdout’
[13:23:32.080]   - Field: ‘earlySignal’
[13:23:32.080]   - Field: ‘lazy’
[13:23:32.080]   - Field: ‘state’
[13:23:32.080] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.080] - Launch lazy future ...
[13:23:32.080] Packages needed by the future expression (n = 0): <none>
[13:23:32.080] Packages needed by future strategies (n = 0): <none>
[13:23:32.081] {
[13:23:32.081]     {
[13:23:32.081]         {
[13:23:32.081]             ...future.startTime <- base::Sys.time()
[13:23:32.081]             {
[13:23:32.081]                 {
[13:23:32.081]                   {
[13:23:32.081]                     base::local({
[13:23:32.081]                       has_future <- base::requireNamespace("future", 
[13:23:32.081]                         quietly = TRUE)
[13:23:32.081]                       if (has_future) {
[13:23:32.081]                         ns <- base::getNamespace("future")
[13:23:32.081]                         version <- ns[[".package"]][["version"]]
[13:23:32.081]                         if (is.null(version)) 
[13:23:32.081]                           version <- utils::packageVersion("future")
[13:23:32.081]                       }
[13:23:32.081]                       else {
[13:23:32.081]                         version <- NULL
[13:23:32.081]                       }
[13:23:32.081]                       if (!has_future || version < "1.8.0") {
[13:23:32.081]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.081]                           "", base::R.version$version.string), 
[13:23:32.081]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:32.081]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.081]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.081]                             "release", "version")], collapse = " "), 
[13:23:32.081]                           hostname = base::Sys.info()[["nodename"]])
[13:23:32.081]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.081]                           info)
[13:23:32.081]                         info <- base::paste(info, collapse = "; ")
[13:23:32.081]                         if (!has_future) {
[13:23:32.081]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.081]                             info)
[13:23:32.081]                         }
[13:23:32.081]                         else {
[13:23:32.081]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.081]                             info, version)
[13:23:32.081]                         }
[13:23:32.081]                         base::stop(msg)
[13:23:32.081]                       }
[13:23:32.081]                     })
[13:23:32.081]                   }
[13:23:32.081]                   options(future.plan = NULL)
[13:23:32.081]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.081]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.081]                 }
[13:23:32.081]                 ...future.workdir <- getwd()
[13:23:32.081]             }
[13:23:32.081]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.081]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.081]         }
[13:23:32.081]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.081]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:32.081]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.081]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.081]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.081]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.081]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.081]             base::names(...future.oldOptions))
[13:23:32.081]     }
[13:23:32.081]     if (FALSE) {
[13:23:32.081]     }
[13:23:32.081]     else {
[13:23:32.081]         if (TRUE) {
[13:23:32.081]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.081]                 open = "w")
[13:23:32.081]         }
[13:23:32.081]         else {
[13:23:32.081]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.081]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.081]         }
[13:23:32.081]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.081]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.081]             base::sink(type = "output", split = FALSE)
[13:23:32.081]             base::close(...future.stdout)
[13:23:32.081]         }, add = TRUE)
[13:23:32.081]     }
[13:23:32.081]     ...future.frame <- base::sys.nframe()
[13:23:32.081]     ...future.conditions <- base::list()
[13:23:32.081]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.081]     if (FALSE) {
[13:23:32.081]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.081]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.081]     }
[13:23:32.081]     ...future.result <- base::tryCatch({
[13:23:32.081]         base::withCallingHandlers({
[13:23:32.081]             ...future.value <- base::withVisible(base::local(1))
[13:23:32.081]             future::FutureResult(value = ...future.value$value, 
[13:23:32.081]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.081]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.081]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.081]                     ...future.globalenv.names))
[13:23:32.081]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.081]         }, condition = base::local({
[13:23:32.081]             c <- base::c
[13:23:32.081]             inherits <- base::inherits
[13:23:32.081]             invokeRestart <- base::invokeRestart
[13:23:32.081]             length <- base::length
[13:23:32.081]             list <- base::list
[13:23:32.081]             seq.int <- base::seq.int
[13:23:32.081]             signalCondition <- base::signalCondition
[13:23:32.081]             sys.calls <- base::sys.calls
[13:23:32.081]             `[[` <- base::`[[`
[13:23:32.081]             `+` <- base::`+`
[13:23:32.081]             `<<-` <- base::`<<-`
[13:23:32.081]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.081]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.081]                   3L)]
[13:23:32.081]             }
[13:23:32.081]             function(cond) {
[13:23:32.081]                 is_error <- inherits(cond, "error")
[13:23:32.081]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.081]                   NULL)
[13:23:32.081]                 if (is_error) {
[13:23:32.081]                   sessionInformation <- function() {
[13:23:32.081]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.081]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.081]                       search = base::search(), system = base::Sys.info())
[13:23:32.081]                   }
[13:23:32.081]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.081]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.081]                     cond$call), session = sessionInformation(), 
[13:23:32.081]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.081]                   signalCondition(cond)
[13:23:32.081]                 }
[13:23:32.081]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.081]                 "immediateCondition"))) {
[13:23:32.081]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.081]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.081]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.081]                   if (TRUE && !signal) {
[13:23:32.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.081]                     {
[13:23:32.081]                       inherits <- base::inherits
[13:23:32.081]                       invokeRestart <- base::invokeRestart
[13:23:32.081]                       is.null <- base::is.null
[13:23:32.081]                       muffled <- FALSE
[13:23:32.081]                       if (inherits(cond, "message")) {
[13:23:32.081]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.081]                         if (muffled) 
[13:23:32.081]                           invokeRestart("muffleMessage")
[13:23:32.081]                       }
[13:23:32.081]                       else if (inherits(cond, "warning")) {
[13:23:32.081]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.081]                         if (muffled) 
[13:23:32.081]                           invokeRestart("muffleWarning")
[13:23:32.081]                       }
[13:23:32.081]                       else if (inherits(cond, "condition")) {
[13:23:32.081]                         if (!is.null(pattern)) {
[13:23:32.081]                           computeRestarts <- base::computeRestarts
[13:23:32.081]                           grepl <- base::grepl
[13:23:32.081]                           restarts <- computeRestarts(cond)
[13:23:32.081]                           for (restart in restarts) {
[13:23:32.081]                             name <- restart$name
[13:23:32.081]                             if (is.null(name)) 
[13:23:32.081]                               next
[13:23:32.081]                             if (!grepl(pattern, name)) 
[13:23:32.081]                               next
[13:23:32.081]                             invokeRestart(restart)
[13:23:32.081]                             muffled <- TRUE
[13:23:32.081]                             break
[13:23:32.081]                           }
[13:23:32.081]                         }
[13:23:32.081]                       }
[13:23:32.081]                       invisible(muffled)
[13:23:32.081]                     }
[13:23:32.081]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.081]                   }
[13:23:32.081]                 }
[13:23:32.081]                 else {
[13:23:32.081]                   if (TRUE) {
[13:23:32.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.081]                     {
[13:23:32.081]                       inherits <- base::inherits
[13:23:32.081]                       invokeRestart <- base::invokeRestart
[13:23:32.081]                       is.null <- base::is.null
[13:23:32.081]                       muffled <- FALSE
[13:23:32.081]                       if (inherits(cond, "message")) {
[13:23:32.081]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.081]                         if (muffled) 
[13:23:32.081]                           invokeRestart("muffleMessage")
[13:23:32.081]                       }
[13:23:32.081]                       else if (inherits(cond, "warning")) {
[13:23:32.081]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.081]                         if (muffled) 
[13:23:32.081]                           invokeRestart("muffleWarning")
[13:23:32.081]                       }
[13:23:32.081]                       else if (inherits(cond, "condition")) {
[13:23:32.081]                         if (!is.null(pattern)) {
[13:23:32.081]                           computeRestarts <- base::computeRestarts
[13:23:32.081]                           grepl <- base::grepl
[13:23:32.081]                           restarts <- computeRestarts(cond)
[13:23:32.081]                           for (restart in restarts) {
[13:23:32.081]                             name <- restart$name
[13:23:32.081]                             if (is.null(name)) 
[13:23:32.081]                               next
[13:23:32.081]                             if (!grepl(pattern, name)) 
[13:23:32.081]                               next
[13:23:32.081]                             invokeRestart(restart)
[13:23:32.081]                             muffled <- TRUE
[13:23:32.081]                             break
[13:23:32.081]                           }
[13:23:32.081]                         }
[13:23:32.081]                       }
[13:23:32.081]                       invisible(muffled)
[13:23:32.081]                     }
[13:23:32.081]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.081]                   }
[13:23:32.081]                 }
[13:23:32.081]             }
[13:23:32.081]         }))
[13:23:32.081]     }, error = function(ex) {
[13:23:32.081]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.081]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.081]                 ...future.rng), started = ...future.startTime, 
[13:23:32.081]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.081]             version = "1.8"), class = "FutureResult")
[13:23:32.081]     }, finally = {
[13:23:32.081]         if (!identical(...future.workdir, getwd())) 
[13:23:32.081]             setwd(...future.workdir)
[13:23:32.081]         {
[13:23:32.081]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.081]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.081]             }
[13:23:32.081]             base::options(...future.oldOptions)
[13:23:32.081]             if (.Platform$OS.type == "windows") {
[13:23:32.081]                 old_names <- names(...future.oldEnvVars)
[13:23:32.081]                 envs <- base::Sys.getenv()
[13:23:32.081]                 names <- names(envs)
[13:23:32.081]                 common <- intersect(names, old_names)
[13:23:32.081]                 added <- setdiff(names, old_names)
[13:23:32.081]                 removed <- setdiff(old_names, names)
[13:23:32.081]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.081]                   envs[common]]
[13:23:32.081]                 NAMES <- toupper(changed)
[13:23:32.081]                 args <- list()
[13:23:32.081]                 for (kk in seq_along(NAMES)) {
[13:23:32.081]                   name <- changed[[kk]]
[13:23:32.081]                   NAME <- NAMES[[kk]]
[13:23:32.081]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.081]                     next
[13:23:32.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.081]                 }
[13:23:32.081]                 NAMES <- toupper(added)
[13:23:32.081]                 for (kk in seq_along(NAMES)) {
[13:23:32.081]                   name <- added[[kk]]
[13:23:32.081]                   NAME <- NAMES[[kk]]
[13:23:32.081]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.081]                     next
[13:23:32.081]                   args[[name]] <- ""
[13:23:32.081]                 }
[13:23:32.081]                 NAMES <- toupper(removed)
[13:23:32.081]                 for (kk in seq_along(NAMES)) {
[13:23:32.081]                   name <- removed[[kk]]
[13:23:32.081]                   NAME <- NAMES[[kk]]
[13:23:32.081]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.081]                     next
[13:23:32.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.081]                 }
[13:23:32.081]                 if (length(args) > 0) 
[13:23:32.081]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.081]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.081]             }
[13:23:32.081]             else {
[13:23:32.081]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.081]             }
[13:23:32.081]             {
[13:23:32.081]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.081]                   0L) {
[13:23:32.081]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.081]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.081]                   base::options(opts)
[13:23:32.081]                 }
[13:23:32.081]                 {
[13:23:32.081]                   {
[13:23:32.081]                     NULL
[13:23:32.081]                     RNGkind("Mersenne-Twister")
[13:23:32.081]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.081]                       inherits = FALSE)
[13:23:32.081]                   }
[13:23:32.081]                   options(future.plan = NULL)
[13:23:32.081]                   if (is.na(NA_character_)) 
[13:23:32.081]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.081]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.081]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.081]                   {
[13:23:32.081]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.081]                     if (!future$lazy) 
[13:23:32.081]                       future <- run(future)
[13:23:32.081]                     invisible(future)
[13:23:32.081]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.081]                 }
[13:23:32.081]             }
[13:23:32.081]         }
[13:23:32.081]     })
[13:23:32.081]     if (TRUE) {
[13:23:32.081]         base::sink(type = "output", split = FALSE)
[13:23:32.081]         if (TRUE) {
[13:23:32.081]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.081]         }
[13:23:32.081]         else {
[13:23:32.081]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.081]         }
[13:23:32.081]         base::close(...future.stdout)
[13:23:32.081]         ...future.stdout <- NULL
[13:23:32.081]     }
[13:23:32.081]     ...future.result$conditions <- ...future.conditions
[13:23:32.081]     ...future.result$finished <- base::Sys.time()
[13:23:32.081]     ...future.result
[13:23:32.081] }
[13:23:32.083] plan(): Setting new future strategy stack:
[13:23:32.083] List of future strategies:
[13:23:32.083] 1. sequential:
[13:23:32.083]    - args: function (..., envir = parent.frame())
[13:23:32.083]    - tweaked: FALSE
[13:23:32.083]    - call: NULL
[13:23:32.083] plan(): nbrOfWorkers() = 1
[13:23:32.084] plan(): Setting new future strategy stack:
[13:23:32.084] List of future strategies:
[13:23:32.084] 1. sequential:
[13:23:32.084]    - args: function (..., envir = parent.frame())
[13:23:32.084]    - tweaked: FALSE
[13:23:32.084]    - call: plan(strategy)
[13:23:32.085] plan(): nbrOfWorkers() = 1
[13:23:32.085] SequentialFuture started (and completed)
[13:23:32.085] - Launch lazy future ... done
[13:23:32.085] run() for ‘SequentialFuture’ ... done
[13:23:32.085] resolved() for ‘SequentialFuture’ ...
[13:23:32.085] - state: ‘finished’
[13:23:32.085] - run: TRUE
[13:23:32.085] - result: ‘FutureResult’
[13:23:32.085] resolved() for ‘SequentialFuture’ ... done
[13:23:32.086] Future #1
[13:23:32.086] resolved() for ‘SequentialFuture’ ...
[13:23:32.086] - state: ‘finished’
[13:23:32.086] - run: TRUE
[13:23:32.086] - result: ‘FutureResult’
[13:23:32.086] resolved() for ‘SequentialFuture’ ... done
[13:23:32.086] A SequentialFuture was resolved
[13:23:32.086]  length: 0 (resolved future 1)
[13:23:32.086] resolve() on list ... DONE
[13:23:32.087] - globals: [1] ‘a’
[13:23:32.087] Resolving futures part of globals (recursively) ... DONE
[13:23:32.087] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[13:23:32.088] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[13:23:32.088] - globals: [1] ‘a’
[13:23:32.088] - packages: [1] ‘future’
[13:23:32.088] getGlobalsAndPackages() ... DONE
[13:23:32.089] run() for ‘Future’ ...
[13:23:32.089] - state: ‘created’
[13:23:32.089] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.089] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.089] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.089]   - Field: ‘label’
[13:23:32.090]   - Field: ‘local’
[13:23:32.090]   - Field: ‘owner’
[13:23:32.090]   - Field: ‘envir’
[13:23:32.090]   - Field: ‘packages’
[13:23:32.090]   - Field: ‘gc’
[13:23:32.090]   - Field: ‘conditions’
[13:23:32.090]   - Field: ‘expr’
[13:23:32.090]   - Field: ‘uuid’
[13:23:32.090]   - Field: ‘seed’
[13:23:32.090]   - Field: ‘version’
[13:23:32.090]   - Field: ‘result’
[13:23:32.091]   - Field: ‘asynchronous’
[13:23:32.091]   - Field: ‘calls’
[13:23:32.091]   - Field: ‘globals’
[13:23:32.091]   - Field: ‘stdout’
[13:23:32.091]   - Field: ‘earlySignal’
[13:23:32.091]   - Field: ‘lazy’
[13:23:32.091]   - Field: ‘state’
[13:23:32.091] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.091] - Launch lazy future ...
[13:23:32.092] Packages needed by the future expression (n = 1): ‘future’
[13:23:32.092] Packages needed by future strategies (n = 0): <none>
[13:23:32.092] {
[13:23:32.092]     {
[13:23:32.092]         {
[13:23:32.092]             ...future.startTime <- base::Sys.time()
[13:23:32.092]             {
[13:23:32.092]                 {
[13:23:32.092]                   {
[13:23:32.092]                     {
[13:23:32.092]                       base::local({
[13:23:32.092]                         has_future <- base::requireNamespace("future", 
[13:23:32.092]                           quietly = TRUE)
[13:23:32.092]                         if (has_future) {
[13:23:32.092]                           ns <- base::getNamespace("future")
[13:23:32.092]                           version <- ns[[".package"]][["version"]]
[13:23:32.092]                           if (is.null(version)) 
[13:23:32.092]                             version <- utils::packageVersion("future")
[13:23:32.092]                         }
[13:23:32.092]                         else {
[13:23:32.092]                           version <- NULL
[13:23:32.092]                         }
[13:23:32.092]                         if (!has_future || version < "1.8.0") {
[13:23:32.092]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.092]                             "", base::R.version$version.string), 
[13:23:32.092]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:32.092]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.092]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.092]                               "release", "version")], collapse = " "), 
[13:23:32.092]                             hostname = base::Sys.info()[["nodename"]])
[13:23:32.092]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.092]                             info)
[13:23:32.092]                           info <- base::paste(info, collapse = "; ")
[13:23:32.092]                           if (!has_future) {
[13:23:32.092]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.092]                               info)
[13:23:32.092]                           }
[13:23:32.092]                           else {
[13:23:32.092]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.092]                               info, version)
[13:23:32.092]                           }
[13:23:32.092]                           base::stop(msg)
[13:23:32.092]                         }
[13:23:32.092]                       })
[13:23:32.092]                     }
[13:23:32.092]                     base::local({
[13:23:32.092]                       for (pkg in "future") {
[13:23:32.092]                         base::loadNamespace(pkg)
[13:23:32.092]                         base::library(pkg, character.only = TRUE)
[13:23:32.092]                       }
[13:23:32.092]                     })
[13:23:32.092]                   }
[13:23:32.092]                   options(future.plan = NULL)
[13:23:32.092]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.092]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.092]                 }
[13:23:32.092]                 ...future.workdir <- getwd()
[13:23:32.092]             }
[13:23:32.092]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.092]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.092]         }
[13:23:32.092]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.092]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:32.092]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.092]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.092]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.092]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.092]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.092]             base::names(...future.oldOptions))
[13:23:32.092]     }
[13:23:32.092]     if (FALSE) {
[13:23:32.092]     }
[13:23:32.092]     else {
[13:23:32.092]         if (TRUE) {
[13:23:32.092]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.092]                 open = "w")
[13:23:32.092]         }
[13:23:32.092]         else {
[13:23:32.092]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.092]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.092]         }
[13:23:32.092]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.092]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.092]             base::sink(type = "output", split = FALSE)
[13:23:32.092]             base::close(...future.stdout)
[13:23:32.092]         }, add = TRUE)
[13:23:32.092]     }
[13:23:32.092]     ...future.frame <- base::sys.nframe()
[13:23:32.092]     ...future.conditions <- base::list()
[13:23:32.092]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.092]     if (FALSE) {
[13:23:32.092]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.092]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.092]     }
[13:23:32.092]     ...future.result <- base::tryCatch({
[13:23:32.092]         base::withCallingHandlers({
[13:23:32.092]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:23:32.092]                 1))
[13:23:32.092]             future::FutureResult(value = ...future.value$value, 
[13:23:32.092]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.092]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.092]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.092]                     ...future.globalenv.names))
[13:23:32.092]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.092]         }, condition = base::local({
[13:23:32.092]             c <- base::c
[13:23:32.092]             inherits <- base::inherits
[13:23:32.092]             invokeRestart <- base::invokeRestart
[13:23:32.092]             length <- base::length
[13:23:32.092]             list <- base::list
[13:23:32.092]             seq.int <- base::seq.int
[13:23:32.092]             signalCondition <- base::signalCondition
[13:23:32.092]             sys.calls <- base::sys.calls
[13:23:32.092]             `[[` <- base::`[[`
[13:23:32.092]             `+` <- base::`+`
[13:23:32.092]             `<<-` <- base::`<<-`
[13:23:32.092]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.092]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.092]                   3L)]
[13:23:32.092]             }
[13:23:32.092]             function(cond) {
[13:23:32.092]                 is_error <- inherits(cond, "error")
[13:23:32.092]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.092]                   NULL)
[13:23:32.092]                 if (is_error) {
[13:23:32.092]                   sessionInformation <- function() {
[13:23:32.092]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.092]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.092]                       search = base::search(), system = base::Sys.info())
[13:23:32.092]                   }
[13:23:32.092]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.092]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.092]                     cond$call), session = sessionInformation(), 
[13:23:32.092]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.092]                   signalCondition(cond)
[13:23:32.092]                 }
[13:23:32.092]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.092]                 "immediateCondition"))) {
[13:23:32.092]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.092]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.092]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.092]                   if (TRUE && !signal) {
[13:23:32.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.092]                     {
[13:23:32.092]                       inherits <- base::inherits
[13:23:32.092]                       invokeRestart <- base::invokeRestart
[13:23:32.092]                       is.null <- base::is.null
[13:23:32.092]                       muffled <- FALSE
[13:23:32.092]                       if (inherits(cond, "message")) {
[13:23:32.092]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.092]                         if (muffled) 
[13:23:32.092]                           invokeRestart("muffleMessage")
[13:23:32.092]                       }
[13:23:32.092]                       else if (inherits(cond, "warning")) {
[13:23:32.092]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.092]                         if (muffled) 
[13:23:32.092]                           invokeRestart("muffleWarning")
[13:23:32.092]                       }
[13:23:32.092]                       else if (inherits(cond, "condition")) {
[13:23:32.092]                         if (!is.null(pattern)) {
[13:23:32.092]                           computeRestarts <- base::computeRestarts
[13:23:32.092]                           grepl <- base::grepl
[13:23:32.092]                           restarts <- computeRestarts(cond)
[13:23:32.092]                           for (restart in restarts) {
[13:23:32.092]                             name <- restart$name
[13:23:32.092]                             if (is.null(name)) 
[13:23:32.092]                               next
[13:23:32.092]                             if (!grepl(pattern, name)) 
[13:23:32.092]                               next
[13:23:32.092]                             invokeRestart(restart)
[13:23:32.092]                             muffled <- TRUE
[13:23:32.092]                             break
[13:23:32.092]                           }
[13:23:32.092]                         }
[13:23:32.092]                       }
[13:23:32.092]                       invisible(muffled)
[13:23:32.092]                     }
[13:23:32.092]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.092]                   }
[13:23:32.092]                 }
[13:23:32.092]                 else {
[13:23:32.092]                   if (TRUE) {
[13:23:32.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.092]                     {
[13:23:32.092]                       inherits <- base::inherits
[13:23:32.092]                       invokeRestart <- base::invokeRestart
[13:23:32.092]                       is.null <- base::is.null
[13:23:32.092]                       muffled <- FALSE
[13:23:32.092]                       if (inherits(cond, "message")) {
[13:23:32.092]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.092]                         if (muffled) 
[13:23:32.092]                           invokeRestart("muffleMessage")
[13:23:32.092]                       }
[13:23:32.092]                       else if (inherits(cond, "warning")) {
[13:23:32.092]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.092]                         if (muffled) 
[13:23:32.092]                           invokeRestart("muffleWarning")
[13:23:32.092]                       }
[13:23:32.092]                       else if (inherits(cond, "condition")) {
[13:23:32.092]                         if (!is.null(pattern)) {
[13:23:32.092]                           computeRestarts <- base::computeRestarts
[13:23:32.092]                           grepl <- base::grepl
[13:23:32.092]                           restarts <- computeRestarts(cond)
[13:23:32.092]                           for (restart in restarts) {
[13:23:32.092]                             name <- restart$name
[13:23:32.092]                             if (is.null(name)) 
[13:23:32.092]                               next
[13:23:32.092]                             if (!grepl(pattern, name)) 
[13:23:32.092]                               next
[13:23:32.092]                             invokeRestart(restart)
[13:23:32.092]                             muffled <- TRUE
[13:23:32.092]                             break
[13:23:32.092]                           }
[13:23:32.092]                         }
[13:23:32.092]                       }
[13:23:32.092]                       invisible(muffled)
[13:23:32.092]                     }
[13:23:32.092]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.092]                   }
[13:23:32.092]                 }
[13:23:32.092]             }
[13:23:32.092]         }))
[13:23:32.092]     }, error = function(ex) {
[13:23:32.092]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.092]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.092]                 ...future.rng), started = ...future.startTime, 
[13:23:32.092]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.092]             version = "1.8"), class = "FutureResult")
[13:23:32.092]     }, finally = {
[13:23:32.092]         if (!identical(...future.workdir, getwd())) 
[13:23:32.092]             setwd(...future.workdir)
[13:23:32.092]         {
[13:23:32.092]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.092]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.092]             }
[13:23:32.092]             base::options(...future.oldOptions)
[13:23:32.092]             if (.Platform$OS.type == "windows") {
[13:23:32.092]                 old_names <- names(...future.oldEnvVars)
[13:23:32.092]                 envs <- base::Sys.getenv()
[13:23:32.092]                 names <- names(envs)
[13:23:32.092]                 common <- intersect(names, old_names)
[13:23:32.092]                 added <- setdiff(names, old_names)
[13:23:32.092]                 removed <- setdiff(old_names, names)
[13:23:32.092]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.092]                   envs[common]]
[13:23:32.092]                 NAMES <- toupper(changed)
[13:23:32.092]                 args <- list()
[13:23:32.092]                 for (kk in seq_along(NAMES)) {
[13:23:32.092]                   name <- changed[[kk]]
[13:23:32.092]                   NAME <- NAMES[[kk]]
[13:23:32.092]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.092]                     next
[13:23:32.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.092]                 }
[13:23:32.092]                 NAMES <- toupper(added)
[13:23:32.092]                 for (kk in seq_along(NAMES)) {
[13:23:32.092]                   name <- added[[kk]]
[13:23:32.092]                   NAME <- NAMES[[kk]]
[13:23:32.092]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.092]                     next
[13:23:32.092]                   args[[name]] <- ""
[13:23:32.092]                 }
[13:23:32.092]                 NAMES <- toupper(removed)
[13:23:32.092]                 for (kk in seq_along(NAMES)) {
[13:23:32.092]                   name <- removed[[kk]]
[13:23:32.092]                   NAME <- NAMES[[kk]]
[13:23:32.092]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.092]                     next
[13:23:32.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.092]                 }
[13:23:32.092]                 if (length(args) > 0) 
[13:23:32.092]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.092]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.092]             }
[13:23:32.092]             else {
[13:23:32.092]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.092]             }
[13:23:32.092]             {
[13:23:32.092]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.092]                   0L) {
[13:23:32.092]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.092]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.092]                   base::options(opts)
[13:23:32.092]                 }
[13:23:32.092]                 {
[13:23:32.092]                   {
[13:23:32.092]                     NULL
[13:23:32.092]                     RNGkind("Mersenne-Twister")
[13:23:32.092]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.092]                       inherits = FALSE)
[13:23:32.092]                   }
[13:23:32.092]                   options(future.plan = NULL)
[13:23:32.092]                   if (is.na(NA_character_)) 
[13:23:32.092]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.092]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.092]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.092]                   {
[13:23:32.092]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.092]                     if (!future$lazy) 
[13:23:32.092]                       future <- run(future)
[13:23:32.092]                     invisible(future)
[13:23:32.092]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.092]                 }
[13:23:32.092]             }
[13:23:32.092]         }
[13:23:32.092]     })
[13:23:32.092]     if (TRUE) {
[13:23:32.092]         base::sink(type = "output", split = FALSE)
[13:23:32.092]         if (TRUE) {
[13:23:32.092]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.092]         }
[13:23:32.092]         else {
[13:23:32.092]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.092]         }
[13:23:32.092]         base::close(...future.stdout)
[13:23:32.092]         ...future.stdout <- NULL
[13:23:32.092]     }
[13:23:32.092]     ...future.result$conditions <- ...future.conditions
[13:23:32.092]     ...future.result$finished <- base::Sys.time()
[13:23:32.092]     ...future.result
[13:23:32.092] }
[13:23:32.094] assign_globals() ...
[13:23:32.094] List of 1
[13:23:32.094]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5589be833aa8> 
[13:23:32.094]  - attr(*, "where")=List of 1
[13:23:32.094]   ..$ a:<environment: R_EmptyEnv> 
[13:23:32.094]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.094]  - attr(*, "resolved")= logi TRUE
[13:23:32.094]  - attr(*, "total_size")= num 10592
[13:23:32.094]  - attr(*, "already-done")= logi TRUE
[13:23:32.097] - copied ‘a’ to environment
[13:23:32.097] assign_globals() ... done
[13:23:32.097] plan(): Setting new future strategy stack:
[13:23:32.097] List of future strategies:
[13:23:32.097] 1. sequential:
[13:23:32.097]    - args: function (..., envir = parent.frame())
[13:23:32.097]    - tweaked: FALSE
[13:23:32.097]    - call: NULL
[13:23:32.098] plan(): nbrOfWorkers() = 1
[13:23:32.099] plan(): Setting new future strategy stack:
[13:23:32.099] List of future strategies:
[13:23:32.099] 1. sequential:
[13:23:32.099]    - args: function (..., envir = parent.frame())
[13:23:32.099]    - tweaked: FALSE
[13:23:32.099]    - call: plan(strategy)
[13:23:32.099] plan(): nbrOfWorkers() = 1
[13:23:32.099] SequentialFuture started (and completed)
[13:23:32.100] - Launch lazy future ... done
[13:23:32.100] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.100] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.100] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:32.101] - globals found: [2] ‘{’, ‘pkg’
[13:23:32.101] Searching for globals ... DONE
[13:23:32.101] Resolving globals: TRUE
[13:23:32.102] Resolving any globals that are futures ...
[13:23:32.102] - globals: [2] ‘{’, ‘pkg’
[13:23:32.102] Resolving any globals that are futures ... DONE
[13:23:32.102] Resolving futures part of globals (recursively) ...
[13:23:32.102] resolve() on list ...
[13:23:32.102]  recursive: 99
[13:23:32.102]  length: 1
[13:23:32.103]  elements: ‘pkg’
[13:23:32.105]  length: 0 (resolved future 1)
[13:23:32.105] resolve() on list ... DONE
[13:23:32.105] - globals: [1] ‘pkg’
[13:23:32.105] Resolving futures part of globals (recursively) ... DONE
[13:23:32.105] The total size of the 1 globals is 112 bytes (112 bytes)
[13:23:32.106] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[13:23:32.106] - globals: [1] ‘pkg’
[13:23:32.106] 
[13:23:32.106] getGlobalsAndPackages() ... DONE
[13:23:32.107] Packages needed by the future expression (n = 0): <none>
[13:23:32.107] Packages needed by future strategies (n = 0): <none>
[13:23:32.107] {
[13:23:32.107]     {
[13:23:32.107]         {
[13:23:32.107]             ...future.startTime <- base::Sys.time()
[13:23:32.107]             {
[13:23:32.107]                 {
[13:23:32.107]                   {
[13:23:32.107]                     base::local({
[13:23:32.107]                       has_future <- base::requireNamespace("future", 
[13:23:32.107]                         quietly = TRUE)
[13:23:32.107]                       if (has_future) {
[13:23:32.107]                         ns <- base::getNamespace("future")
[13:23:32.107]                         version <- ns[[".package"]][["version"]]
[13:23:32.107]                         if (is.null(version)) 
[13:23:32.107]                           version <- utils::packageVersion("future")
[13:23:32.107]                       }
[13:23:32.107]                       else {
[13:23:32.107]                         version <- NULL
[13:23:32.107]                       }
[13:23:32.107]                       if (!has_future || version < "1.8.0") {
[13:23:32.107]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.107]                           "", base::R.version$version.string), 
[13:23:32.107]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:32.107]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.107]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.107]                             "release", "version")], collapse = " "), 
[13:23:32.107]                           hostname = base::Sys.info()[["nodename"]])
[13:23:32.107]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.107]                           info)
[13:23:32.107]                         info <- base::paste(info, collapse = "; ")
[13:23:32.107]                         if (!has_future) {
[13:23:32.107]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.107]                             info)
[13:23:32.107]                         }
[13:23:32.107]                         else {
[13:23:32.107]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.107]                             info, version)
[13:23:32.107]                         }
[13:23:32.107]                         base::stop(msg)
[13:23:32.107]                       }
[13:23:32.107]                     })
[13:23:32.107]                   }
[13:23:32.107]                   options(future.plan = NULL)
[13:23:32.107]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.107]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.107]                 }
[13:23:32.107]                 ...future.workdir <- getwd()
[13:23:32.107]             }
[13:23:32.107]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.107]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.107]         }
[13:23:32.107]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.107]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:32.107]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.107]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.107]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.107]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.107]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.107]             base::names(...future.oldOptions))
[13:23:32.107]     }
[13:23:32.107]     if (FALSE) {
[13:23:32.107]     }
[13:23:32.107]     else {
[13:23:32.107]         if (TRUE) {
[13:23:32.107]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.107]                 open = "w")
[13:23:32.107]         }
[13:23:32.107]         else {
[13:23:32.107]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.107]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.107]         }
[13:23:32.107]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.107]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.107]             base::sink(type = "output", split = FALSE)
[13:23:32.107]             base::close(...future.stdout)
[13:23:32.107]         }, add = TRUE)
[13:23:32.107]     }
[13:23:32.107]     ...future.frame <- base::sys.nframe()
[13:23:32.107]     ...future.conditions <- base::list()
[13:23:32.107]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.107]     if (FALSE) {
[13:23:32.107]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.107]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.107]     }
[13:23:32.107]     ...future.result <- base::tryCatch({
[13:23:32.107]         base::withCallingHandlers({
[13:23:32.107]             ...future.value <- base::withVisible(base::local({
[13:23:32.107]                 pkg
[13:23:32.107]             }))
[13:23:32.107]             future::FutureResult(value = ...future.value$value, 
[13:23:32.107]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.107]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.107]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.107]                     ...future.globalenv.names))
[13:23:32.107]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.107]         }, condition = base::local({
[13:23:32.107]             c <- base::c
[13:23:32.107]             inherits <- base::inherits
[13:23:32.107]             invokeRestart <- base::invokeRestart
[13:23:32.107]             length <- base::length
[13:23:32.107]             list <- base::list
[13:23:32.107]             seq.int <- base::seq.int
[13:23:32.107]             signalCondition <- base::signalCondition
[13:23:32.107]             sys.calls <- base::sys.calls
[13:23:32.107]             `[[` <- base::`[[`
[13:23:32.107]             `+` <- base::`+`
[13:23:32.107]             `<<-` <- base::`<<-`
[13:23:32.107]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.107]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.107]                   3L)]
[13:23:32.107]             }
[13:23:32.107]             function(cond) {
[13:23:32.107]                 is_error <- inherits(cond, "error")
[13:23:32.107]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.107]                   NULL)
[13:23:32.107]                 if (is_error) {
[13:23:32.107]                   sessionInformation <- function() {
[13:23:32.107]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.107]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.107]                       search = base::search(), system = base::Sys.info())
[13:23:32.107]                   }
[13:23:32.107]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.107]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.107]                     cond$call), session = sessionInformation(), 
[13:23:32.107]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.107]                   signalCondition(cond)
[13:23:32.107]                 }
[13:23:32.107]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.107]                 "immediateCondition"))) {
[13:23:32.107]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.107]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.107]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.107]                   if (TRUE && !signal) {
[13:23:32.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.107]                     {
[13:23:32.107]                       inherits <- base::inherits
[13:23:32.107]                       invokeRestart <- base::invokeRestart
[13:23:32.107]                       is.null <- base::is.null
[13:23:32.107]                       muffled <- FALSE
[13:23:32.107]                       if (inherits(cond, "message")) {
[13:23:32.107]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.107]                         if (muffled) 
[13:23:32.107]                           invokeRestart("muffleMessage")
[13:23:32.107]                       }
[13:23:32.107]                       else if (inherits(cond, "warning")) {
[13:23:32.107]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.107]                         if (muffled) 
[13:23:32.107]                           invokeRestart("muffleWarning")
[13:23:32.107]                       }
[13:23:32.107]                       else if (inherits(cond, "condition")) {
[13:23:32.107]                         if (!is.null(pattern)) {
[13:23:32.107]                           computeRestarts <- base::computeRestarts
[13:23:32.107]                           grepl <- base::grepl
[13:23:32.107]                           restarts <- computeRestarts(cond)
[13:23:32.107]                           for (restart in restarts) {
[13:23:32.107]                             name <- restart$name
[13:23:32.107]                             if (is.null(name)) 
[13:23:32.107]                               next
[13:23:32.107]                             if (!grepl(pattern, name)) 
[13:23:32.107]                               next
[13:23:32.107]                             invokeRestart(restart)
[13:23:32.107]                             muffled <- TRUE
[13:23:32.107]                             break
[13:23:32.107]                           }
[13:23:32.107]                         }
[13:23:32.107]                       }
[13:23:32.107]                       invisible(muffled)
[13:23:32.107]                     }
[13:23:32.107]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.107]                   }
[13:23:32.107]                 }
[13:23:32.107]                 else {
[13:23:32.107]                   if (TRUE) {
[13:23:32.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.107]                     {
[13:23:32.107]                       inherits <- base::inherits
[13:23:32.107]                       invokeRestart <- base::invokeRestart
[13:23:32.107]                       is.null <- base::is.null
[13:23:32.107]                       muffled <- FALSE
[13:23:32.107]                       if (inherits(cond, "message")) {
[13:23:32.107]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.107]                         if (muffled) 
[13:23:32.107]                           invokeRestart("muffleMessage")
[13:23:32.107]                       }
[13:23:32.107]                       else if (inherits(cond, "warning")) {
[13:23:32.107]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.107]                         if (muffled) 
[13:23:32.107]                           invokeRestart("muffleWarning")
[13:23:32.107]                       }
[13:23:32.107]                       else if (inherits(cond, "condition")) {
[13:23:32.107]                         if (!is.null(pattern)) {
[13:23:32.107]                           computeRestarts <- base::computeRestarts
[13:23:32.107]                           grepl <- base::grepl
[13:23:32.107]                           restarts <- computeRestarts(cond)
[13:23:32.107]                           for (restart in restarts) {
[13:23:32.107]                             name <- restart$name
[13:23:32.107]                             if (is.null(name)) 
[13:23:32.107]                               next
[13:23:32.107]                             if (!grepl(pattern, name)) 
[13:23:32.107]                               next
[13:23:32.107]                             invokeRestart(restart)
[13:23:32.107]                             muffled <- TRUE
[13:23:32.107]                             break
[13:23:32.107]                           }
[13:23:32.107]                         }
[13:23:32.107]                       }
[13:23:32.107]                       invisible(muffled)
[13:23:32.107]                     }
[13:23:32.107]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.107]                   }
[13:23:32.107]                 }
[13:23:32.107]             }
[13:23:32.107]         }))
[13:23:32.107]     }, error = function(ex) {
[13:23:32.107]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.107]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.107]                 ...future.rng), started = ...future.startTime, 
[13:23:32.107]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.107]             version = "1.8"), class = "FutureResult")
[13:23:32.107]     }, finally = {
[13:23:32.107]         if (!identical(...future.workdir, getwd())) 
[13:23:32.107]             setwd(...future.workdir)
[13:23:32.107]         {
[13:23:32.107]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.107]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.107]             }
[13:23:32.107]             base::options(...future.oldOptions)
[13:23:32.107]             if (.Platform$OS.type == "windows") {
[13:23:32.107]                 old_names <- names(...future.oldEnvVars)
[13:23:32.107]                 envs <- base::Sys.getenv()
[13:23:32.107]                 names <- names(envs)
[13:23:32.107]                 common <- intersect(names, old_names)
[13:23:32.107]                 added <- setdiff(names, old_names)
[13:23:32.107]                 removed <- setdiff(old_names, names)
[13:23:32.107]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.107]                   envs[common]]
[13:23:32.107]                 NAMES <- toupper(changed)
[13:23:32.107]                 args <- list()
[13:23:32.107]                 for (kk in seq_along(NAMES)) {
[13:23:32.107]                   name <- changed[[kk]]
[13:23:32.107]                   NAME <- NAMES[[kk]]
[13:23:32.107]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.107]                     next
[13:23:32.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.107]                 }
[13:23:32.107]                 NAMES <- toupper(added)
[13:23:32.107]                 for (kk in seq_along(NAMES)) {
[13:23:32.107]                   name <- added[[kk]]
[13:23:32.107]                   NAME <- NAMES[[kk]]
[13:23:32.107]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.107]                     next
[13:23:32.107]                   args[[name]] <- ""
[13:23:32.107]                 }
[13:23:32.107]                 NAMES <- toupper(removed)
[13:23:32.107]                 for (kk in seq_along(NAMES)) {
[13:23:32.107]                   name <- removed[[kk]]
[13:23:32.107]                   NAME <- NAMES[[kk]]
[13:23:32.107]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.107]                     next
[13:23:32.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.107]                 }
[13:23:32.107]                 if (length(args) > 0) 
[13:23:32.107]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.107]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.107]             }
[13:23:32.107]             else {
[13:23:32.107]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.107]             }
[13:23:32.107]             {
[13:23:32.107]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.107]                   0L) {
[13:23:32.107]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.107]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.107]                   base::options(opts)
[13:23:32.107]                 }
[13:23:32.107]                 {
[13:23:32.107]                   {
[13:23:32.107]                     NULL
[13:23:32.107]                     RNGkind("Mersenne-Twister")
[13:23:32.107]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.107]                       inherits = FALSE)
[13:23:32.107]                   }
[13:23:32.107]                   options(future.plan = NULL)
[13:23:32.107]                   if (is.na(NA_character_)) 
[13:23:32.107]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.107]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.107]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.107]                   {
[13:23:32.107]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.107]                     if (!future$lazy) 
[13:23:32.107]                       future <- run(future)
[13:23:32.107]                     invisible(future)
[13:23:32.107]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.107]                 }
[13:23:32.107]             }
[13:23:32.107]         }
[13:23:32.107]     })
[13:23:32.107]     if (TRUE) {
[13:23:32.107]         base::sink(type = "output", split = FALSE)
[13:23:32.107]         if (TRUE) {
[13:23:32.107]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.107]         }
[13:23:32.107]         else {
[13:23:32.107]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.107]         }
[13:23:32.107]         base::close(...future.stdout)
[13:23:32.107]         ...future.stdout <- NULL
[13:23:32.107]     }
[13:23:32.107]     ...future.result$conditions <- ...future.conditions
[13:23:32.107]     ...future.result$finished <- base::Sys.time()
[13:23:32.107]     ...future.result
[13:23:32.107] }
[13:23:32.109] assign_globals() ...
[13:23:32.109] List of 1
[13:23:32.109]  $ pkg: chr "foo"
[13:23:32.109]  - attr(*, "where")=List of 1
[13:23:32.109]   ..$ pkg:<environment: R_EmptyEnv> 
[13:23:32.109]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.109]  - attr(*, "resolved")= logi TRUE
[13:23:32.109]  - attr(*, "total_size")= num 112
[13:23:32.111] - copied ‘pkg’ to environment
[13:23:32.111] assign_globals() ... done
[13:23:32.112] plan(): Setting new future strategy stack:
[13:23:32.112] List of future strategies:
[13:23:32.112] 1. sequential:
[13:23:32.112]    - args: function (..., envir = parent.frame())
[13:23:32.112]    - tweaked: FALSE
[13:23:32.112]    - call: NULL
[13:23:32.112] plan(): nbrOfWorkers() = 1
[13:23:32.113] plan(): Setting new future strategy stack:
[13:23:32.113] List of future strategies:
[13:23:32.113] 1. sequential:
[13:23:32.113]    - args: function (..., envir = parent.frame())
[13:23:32.113]    - tweaked: FALSE
[13:23:32.113]    - call: plan(strategy)
[13:23:32.114] plan(): nbrOfWorkers() = 1
[13:23:32.114] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.115] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.115] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:32.117] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:23:32.117] Searching for globals ... DONE
[13:23:32.117] Resolving globals: TRUE
[13:23:32.118] Resolving any globals that are futures ...
[13:23:32.118] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:23:32.118] Resolving any globals that are futures ... DONE
[13:23:32.118] Resolving futures part of globals (recursively) ...
[13:23:32.118] resolve() on list ...
[13:23:32.118]  recursive: 99
[13:23:32.119]  length: 1
[13:23:32.119]  elements: ‘a’
[13:23:32.119]  length: 0 (resolved future 1)
[13:23:32.119] resolve() on list ... DONE
[13:23:32.119] - globals: [1] ‘a’
[13:23:32.119] Resolving futures part of globals (recursively) ... DONE
[13:23:32.119] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:32.120] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:23:32.120] - globals: [1] ‘a’
[13:23:32.120] 
[13:23:32.120] getGlobalsAndPackages() ... DONE
[13:23:32.120] run() for ‘Future’ ...
[13:23:32.120] - state: ‘created’
[13:23:32.121] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.121] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.121] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.121]   - Field: ‘label’
[13:23:32.121]   - Field: ‘local’
[13:23:32.121]   - Field: ‘owner’
[13:23:32.121]   - Field: ‘envir’
[13:23:32.122]   - Field: ‘packages’
[13:23:32.122]   - Field: ‘gc’
[13:23:32.122]   - Field: ‘conditions’
[13:23:32.122]   - Field: ‘expr’
[13:23:32.122]   - Field: ‘uuid’
[13:23:32.122]   - Field: ‘seed’
[13:23:32.122]   - Field: ‘version’
[13:23:32.122]   - Field: ‘result’
[13:23:32.122]   - Field: ‘asynchronous’
[13:23:32.122]   - Field: ‘calls’
[13:23:32.122]   - Field: ‘globals’
[13:23:32.123]   - Field: ‘stdout’
[13:23:32.123]   - Field: ‘earlySignal’
[13:23:32.123]   - Field: ‘lazy’
[13:23:32.123]   - Field: ‘state’
[13:23:32.123] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.123] - Launch lazy future ...
[13:23:32.123] Packages needed by the future expression (n = 0): <none>
[13:23:32.123] Packages needed by future strategies (n = 0): <none>
[13:23:32.124] {
[13:23:32.124]     {
[13:23:32.124]         {
[13:23:32.124]             ...future.startTime <- base::Sys.time()
[13:23:32.124]             {
[13:23:32.124]                 {
[13:23:32.124]                   {
[13:23:32.124]                     base::local({
[13:23:32.124]                       has_future <- base::requireNamespace("future", 
[13:23:32.124]                         quietly = TRUE)
[13:23:32.124]                       if (has_future) {
[13:23:32.124]                         ns <- base::getNamespace("future")
[13:23:32.124]                         version <- ns[[".package"]][["version"]]
[13:23:32.124]                         if (is.null(version)) 
[13:23:32.124]                           version <- utils::packageVersion("future")
[13:23:32.124]                       }
[13:23:32.124]                       else {
[13:23:32.124]                         version <- NULL
[13:23:32.124]                       }
[13:23:32.124]                       if (!has_future || version < "1.8.0") {
[13:23:32.124]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.124]                           "", base::R.version$version.string), 
[13:23:32.124]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:32.124]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.124]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.124]                             "release", "version")], collapse = " "), 
[13:23:32.124]                           hostname = base::Sys.info()[["nodename"]])
[13:23:32.124]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.124]                           info)
[13:23:32.124]                         info <- base::paste(info, collapse = "; ")
[13:23:32.124]                         if (!has_future) {
[13:23:32.124]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.124]                             info)
[13:23:32.124]                         }
[13:23:32.124]                         else {
[13:23:32.124]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.124]                             info, version)
[13:23:32.124]                         }
[13:23:32.124]                         base::stop(msg)
[13:23:32.124]                       }
[13:23:32.124]                     })
[13:23:32.124]                   }
[13:23:32.124]                   options(future.plan = NULL)
[13:23:32.124]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.124]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.124]                 }
[13:23:32.124]                 ...future.workdir <- getwd()
[13:23:32.124]             }
[13:23:32.124]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.124]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.124]         }
[13:23:32.124]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.124]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:32.124]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.124]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.124]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.124]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.124]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.124]             base::names(...future.oldOptions))
[13:23:32.124]     }
[13:23:32.124]     if (FALSE) {
[13:23:32.124]     }
[13:23:32.124]     else {
[13:23:32.124]         if (TRUE) {
[13:23:32.124]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.124]                 open = "w")
[13:23:32.124]         }
[13:23:32.124]         else {
[13:23:32.124]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.124]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.124]         }
[13:23:32.124]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.124]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.124]             base::sink(type = "output", split = FALSE)
[13:23:32.124]             base::close(...future.stdout)
[13:23:32.124]         }, add = TRUE)
[13:23:32.124]     }
[13:23:32.124]     ...future.frame <- base::sys.nframe()
[13:23:32.124]     ...future.conditions <- base::list()
[13:23:32.124]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.124]     if (FALSE) {
[13:23:32.124]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.124]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.124]     }
[13:23:32.124]     ...future.result <- base::tryCatch({
[13:23:32.124]         base::withCallingHandlers({
[13:23:32.124]             ...future.value <- base::withVisible(base::local({
[13:23:32.124]                 b <- a
[13:23:32.124]                 a <- 2
[13:23:32.124]                 a * b
[13:23:32.124]             }))
[13:23:32.124]             future::FutureResult(value = ...future.value$value, 
[13:23:32.124]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.124]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.124]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.124]                     ...future.globalenv.names))
[13:23:32.124]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.124]         }, condition = base::local({
[13:23:32.124]             c <- base::c
[13:23:32.124]             inherits <- base::inherits
[13:23:32.124]             invokeRestart <- base::invokeRestart
[13:23:32.124]             length <- base::length
[13:23:32.124]             list <- base::list
[13:23:32.124]             seq.int <- base::seq.int
[13:23:32.124]             signalCondition <- base::signalCondition
[13:23:32.124]             sys.calls <- base::sys.calls
[13:23:32.124]             `[[` <- base::`[[`
[13:23:32.124]             `+` <- base::`+`
[13:23:32.124]             `<<-` <- base::`<<-`
[13:23:32.124]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.124]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.124]                   3L)]
[13:23:32.124]             }
[13:23:32.124]             function(cond) {
[13:23:32.124]                 is_error <- inherits(cond, "error")
[13:23:32.124]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.124]                   NULL)
[13:23:32.124]                 if (is_error) {
[13:23:32.124]                   sessionInformation <- function() {
[13:23:32.124]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.124]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.124]                       search = base::search(), system = base::Sys.info())
[13:23:32.124]                   }
[13:23:32.124]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.124]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.124]                     cond$call), session = sessionInformation(), 
[13:23:32.124]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.124]                   signalCondition(cond)
[13:23:32.124]                 }
[13:23:32.124]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.124]                 "immediateCondition"))) {
[13:23:32.124]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.124]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.124]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.124]                   if (TRUE && !signal) {
[13:23:32.124]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.124]                     {
[13:23:32.124]                       inherits <- base::inherits
[13:23:32.124]                       invokeRestart <- base::invokeRestart
[13:23:32.124]                       is.null <- base::is.null
[13:23:32.124]                       muffled <- FALSE
[13:23:32.124]                       if (inherits(cond, "message")) {
[13:23:32.124]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.124]                         if (muffled) 
[13:23:32.124]                           invokeRestart("muffleMessage")
[13:23:32.124]                       }
[13:23:32.124]                       else if (inherits(cond, "warning")) {
[13:23:32.124]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.124]                         if (muffled) 
[13:23:32.124]                           invokeRestart("muffleWarning")
[13:23:32.124]                       }
[13:23:32.124]                       else if (inherits(cond, "condition")) {
[13:23:32.124]                         if (!is.null(pattern)) {
[13:23:32.124]                           computeRestarts <- base::computeRestarts
[13:23:32.124]                           grepl <- base::grepl
[13:23:32.124]                           restarts <- computeRestarts(cond)
[13:23:32.124]                           for (restart in restarts) {
[13:23:32.124]                             name <- restart$name
[13:23:32.124]                             if (is.null(name)) 
[13:23:32.124]                               next
[13:23:32.124]                             if (!grepl(pattern, name)) 
[13:23:32.124]                               next
[13:23:32.124]                             invokeRestart(restart)
[13:23:32.124]                             muffled <- TRUE
[13:23:32.124]                             break
[13:23:32.124]                           }
[13:23:32.124]                         }
[13:23:32.124]                       }
[13:23:32.124]                       invisible(muffled)
[13:23:32.124]                     }
[13:23:32.124]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.124]                   }
[13:23:32.124]                 }
[13:23:32.124]                 else {
[13:23:32.124]                   if (TRUE) {
[13:23:32.124]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.124]                     {
[13:23:32.124]                       inherits <- base::inherits
[13:23:32.124]                       invokeRestart <- base::invokeRestart
[13:23:32.124]                       is.null <- base::is.null
[13:23:32.124]                       muffled <- FALSE
[13:23:32.124]                       if (inherits(cond, "message")) {
[13:23:32.124]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.124]                         if (muffled) 
[13:23:32.124]                           invokeRestart("muffleMessage")
[13:23:32.124]                       }
[13:23:32.124]                       else if (inherits(cond, "warning")) {
[13:23:32.124]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.124]                         if (muffled) 
[13:23:32.124]                           invokeRestart("muffleWarning")
[13:23:32.124]                       }
[13:23:32.124]                       else if (inherits(cond, "condition")) {
[13:23:32.124]                         if (!is.null(pattern)) {
[13:23:32.124]                           computeRestarts <- base::computeRestarts
[13:23:32.124]                           grepl <- base::grepl
[13:23:32.124]                           restarts <- computeRestarts(cond)
[13:23:32.124]                           for (restart in restarts) {
[13:23:32.124]                             name <- restart$name
[13:23:32.124]                             if (is.null(name)) 
[13:23:32.124]                               next
[13:23:32.124]                             if (!grepl(pattern, name)) 
[13:23:32.124]                               next
[13:23:32.124]                             invokeRestart(restart)
[13:23:32.124]                             muffled <- TRUE
[13:23:32.124]                             break
[13:23:32.124]                           }
[13:23:32.124]                         }
[13:23:32.124]                       }
[13:23:32.124]                       invisible(muffled)
[13:23:32.124]                     }
[13:23:32.124]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.124]                   }
[13:23:32.124]                 }
[13:23:32.124]             }
[13:23:32.124]         }))
[13:23:32.124]     }, error = function(ex) {
[13:23:32.124]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.124]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.124]                 ...future.rng), started = ...future.startTime, 
[13:23:32.124]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.124]             version = "1.8"), class = "FutureResult")
[13:23:32.124]     }, finally = {
[13:23:32.124]         if (!identical(...future.workdir, getwd())) 
[13:23:32.124]             setwd(...future.workdir)
[13:23:32.124]         {
[13:23:32.124]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.124]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.124]             }
[13:23:32.124]             base::options(...future.oldOptions)
[13:23:32.124]             if (.Platform$OS.type == "windows") {
[13:23:32.124]                 old_names <- names(...future.oldEnvVars)
[13:23:32.124]                 envs <- base::Sys.getenv()
[13:23:32.124]                 names <- names(envs)
[13:23:32.124]                 common <- intersect(names, old_names)
[13:23:32.124]                 added <- setdiff(names, old_names)
[13:23:32.124]                 removed <- setdiff(old_names, names)
[13:23:32.124]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.124]                   envs[common]]
[13:23:32.124]                 NAMES <- toupper(changed)
[13:23:32.124]                 args <- list()
[13:23:32.124]                 for (kk in seq_along(NAMES)) {
[13:23:32.124]                   name <- changed[[kk]]
[13:23:32.124]                   NAME <- NAMES[[kk]]
[13:23:32.124]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.124]                     next
[13:23:32.124]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.124]                 }
[13:23:32.124]                 NAMES <- toupper(added)
[13:23:32.124]                 for (kk in seq_along(NAMES)) {
[13:23:32.124]                   name <- added[[kk]]
[13:23:32.124]                   NAME <- NAMES[[kk]]
[13:23:32.124]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.124]                     next
[13:23:32.124]                   args[[name]] <- ""
[13:23:32.124]                 }
[13:23:32.124]                 NAMES <- toupper(removed)
[13:23:32.124]                 for (kk in seq_along(NAMES)) {
[13:23:32.124]                   name <- removed[[kk]]
[13:23:32.124]                   NAME <- NAMES[[kk]]
[13:23:32.124]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.124]                     next
[13:23:32.124]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.124]                 }
[13:23:32.124]                 if (length(args) > 0) 
[13:23:32.124]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.124]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.124]             }
[13:23:32.124]             else {
[13:23:32.124]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.124]             }
[13:23:32.124]             {
[13:23:32.124]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.124]                   0L) {
[13:23:32.124]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.124]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.124]                   base::options(opts)
[13:23:32.124]                 }
[13:23:32.124]                 {
[13:23:32.124]                   {
[13:23:32.124]                     NULL
[13:23:32.124]                     RNGkind("Mersenne-Twister")
[13:23:32.124]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.124]                       inherits = FALSE)
[13:23:32.124]                   }
[13:23:32.124]                   options(future.plan = NULL)
[13:23:32.124]                   if (is.na(NA_character_)) 
[13:23:32.124]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.124]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.124]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.124]                   {
[13:23:32.124]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.124]                     if (!future$lazy) 
[13:23:32.124]                       future <- run(future)
[13:23:32.124]                     invisible(future)
[13:23:32.124]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.124]                 }
[13:23:32.124]             }
[13:23:32.124]         }
[13:23:32.124]     })
[13:23:32.124]     if (TRUE) {
[13:23:32.124]         base::sink(type = "output", split = FALSE)
[13:23:32.124]         if (TRUE) {
[13:23:32.124]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.124]         }
[13:23:32.124]         else {
[13:23:32.124]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.124]         }
[13:23:32.124]         base::close(...future.stdout)
[13:23:32.124]         ...future.stdout <- NULL
[13:23:32.124]     }
[13:23:32.124]     ...future.result$conditions <- ...future.conditions
[13:23:32.124]     ...future.result$finished <- base::Sys.time()
[13:23:32.124]     ...future.result
[13:23:32.124] }
[13:23:32.126] assign_globals() ...
[13:23:32.126] List of 1
[13:23:32.126]  $ a: num 3
[13:23:32.126]  - attr(*, "where")=List of 1
[13:23:32.126]   ..$ a:<environment: R_EmptyEnv> 
[13:23:32.126]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.126]  - attr(*, "resolved")= logi TRUE
[13:23:32.126]  - attr(*, "total_size")= num 56
[13:23:32.126]  - attr(*, "already-done")= logi TRUE
[13:23:32.129] - copied ‘a’ to environment
[13:23:32.129] assign_globals() ... done
[13:23:32.129] plan(): Setting new future strategy stack:
[13:23:32.129] List of future strategies:
[13:23:32.129] 1. sequential:
[13:23:32.129]    - args: function (..., envir = parent.frame())
[13:23:32.129]    - tweaked: FALSE
[13:23:32.129]    - call: NULL
[13:23:32.129] plan(): nbrOfWorkers() = 1
[13:23:32.130] plan(): Setting new future strategy stack:
[13:23:32.130] List of future strategies:
[13:23:32.130] 1. sequential:
[13:23:32.130]    - args: function (..., envir = parent.frame())
[13:23:32.130]    - tweaked: FALSE
[13:23:32.130]    - call: plan(strategy)
[13:23:32.131] plan(): nbrOfWorkers() = 1
[13:23:32.131] SequentialFuture started (and completed)
[13:23:32.131] - Launch lazy future ... done
[13:23:32.131] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.132] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.132] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:32.136] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:23:32.137] Searching for globals ... DONE
[13:23:32.137] Resolving globals: TRUE
[13:23:32.137] Resolving any globals that are futures ...
[13:23:32.137] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:23:32.137] Resolving any globals that are futures ... DONE
[13:23:32.137] Resolving futures part of globals (recursively) ...
[13:23:32.138] resolve() on list ...
[13:23:32.138]  recursive: 99
[13:23:32.138]  length: 1
[13:23:32.138]  elements: ‘a’
[13:23:32.138]  length: 0 (resolved future 1)
[13:23:32.138] resolve() on list ... DONE
[13:23:32.138] - globals: [1] ‘a’
[13:23:32.138] Resolving futures part of globals (recursively) ... DONE
[13:23:32.139] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:32.139] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:23:32.139] - globals: [1] ‘a’
[13:23:32.139] 
[13:23:32.139] getGlobalsAndPackages() ... DONE
[13:23:32.140] run() for ‘Future’ ...
[13:23:32.140] - state: ‘created’
[13:23:32.140] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.140] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.140] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.141]   - Field: ‘label’
[13:23:32.141]   - Field: ‘local’
[13:23:32.141]   - Field: ‘owner’
[13:23:32.141]   - Field: ‘envir’
[13:23:32.141]   - Field: ‘packages’
[13:23:32.141]   - Field: ‘gc’
[13:23:32.141]   - Field: ‘conditions’
[13:23:32.141]   - Field: ‘expr’
[13:23:32.141]   - Field: ‘uuid’
[13:23:32.141]   - Field: ‘seed’
[13:23:32.142]   - Field: ‘version’
[13:23:32.142]   - Field: ‘result’
[13:23:32.142]   - Field: ‘asynchronous’
[13:23:32.142]   - Field: ‘calls’
[13:23:32.142]   - Field: ‘globals’
[13:23:32.142]   - Field: ‘stdout’
[13:23:32.142]   - Field: ‘earlySignal’
[13:23:32.142]   - Field: ‘lazy’
[13:23:32.142]   - Field: ‘state’
[13:23:32.143] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.143] - Launch lazy future ...
[13:23:32.143] Packages needed by the future expression (n = 0): <none>
[13:23:32.143] Packages needed by future strategies (n = 0): <none>
[13:23:32.143] {
[13:23:32.143]     {
[13:23:32.143]         {
[13:23:32.143]             ...future.startTime <- base::Sys.time()
[13:23:32.143]             {
[13:23:32.143]                 {
[13:23:32.143]                   {
[13:23:32.143]                     base::local({
[13:23:32.143]                       has_future <- base::requireNamespace("future", 
[13:23:32.143]                         quietly = TRUE)
[13:23:32.143]                       if (has_future) {
[13:23:32.143]                         ns <- base::getNamespace("future")
[13:23:32.143]                         version <- ns[[".package"]][["version"]]
[13:23:32.143]                         if (is.null(version)) 
[13:23:32.143]                           version <- utils::packageVersion("future")
[13:23:32.143]                       }
[13:23:32.143]                       else {
[13:23:32.143]                         version <- NULL
[13:23:32.143]                       }
[13:23:32.143]                       if (!has_future || version < "1.8.0") {
[13:23:32.143]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.143]                           "", base::R.version$version.string), 
[13:23:32.143]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:32.143]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.143]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.143]                             "release", "version")], collapse = " "), 
[13:23:32.143]                           hostname = base::Sys.info()[["nodename"]])
[13:23:32.143]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.143]                           info)
[13:23:32.143]                         info <- base::paste(info, collapse = "; ")
[13:23:32.143]                         if (!has_future) {
[13:23:32.143]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.143]                             info)
[13:23:32.143]                         }
[13:23:32.143]                         else {
[13:23:32.143]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.143]                             info, version)
[13:23:32.143]                         }
[13:23:32.143]                         base::stop(msg)
[13:23:32.143]                       }
[13:23:32.143]                     })
[13:23:32.143]                   }
[13:23:32.143]                   options(future.plan = NULL)
[13:23:32.143]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.143]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.143]                 }
[13:23:32.143]                 ...future.workdir <- getwd()
[13:23:32.143]             }
[13:23:32.143]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.143]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.143]         }
[13:23:32.143]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.143]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:32.143]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.143]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.143]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.143]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.143]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.143]             base::names(...future.oldOptions))
[13:23:32.143]     }
[13:23:32.143]     if (FALSE) {
[13:23:32.143]     }
[13:23:32.143]     else {
[13:23:32.143]         if (TRUE) {
[13:23:32.143]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.143]                 open = "w")
[13:23:32.143]         }
[13:23:32.143]         else {
[13:23:32.143]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.143]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.143]         }
[13:23:32.143]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.143]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.143]             base::sink(type = "output", split = FALSE)
[13:23:32.143]             base::close(...future.stdout)
[13:23:32.143]         }, add = TRUE)
[13:23:32.143]     }
[13:23:32.143]     ...future.frame <- base::sys.nframe()
[13:23:32.143]     ...future.conditions <- base::list()
[13:23:32.143]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.143]     if (FALSE) {
[13:23:32.143]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.143]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.143]     }
[13:23:32.143]     ...future.result <- base::tryCatch({
[13:23:32.143]         base::withCallingHandlers({
[13:23:32.143]             ...future.value <- base::withVisible(base::local({
[13:23:32.143]                 b <- a
[13:23:32.143]                 a <- 2
[13:23:32.143]                 a * b
[13:23:32.143]             }))
[13:23:32.143]             future::FutureResult(value = ...future.value$value, 
[13:23:32.143]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.143]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.143]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.143]                     ...future.globalenv.names))
[13:23:32.143]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.143]         }, condition = base::local({
[13:23:32.143]             c <- base::c
[13:23:32.143]             inherits <- base::inherits
[13:23:32.143]             invokeRestart <- base::invokeRestart
[13:23:32.143]             length <- base::length
[13:23:32.143]             list <- base::list
[13:23:32.143]             seq.int <- base::seq.int
[13:23:32.143]             signalCondition <- base::signalCondition
[13:23:32.143]             sys.calls <- base::sys.calls
[13:23:32.143]             `[[` <- base::`[[`
[13:23:32.143]             `+` <- base::`+`
[13:23:32.143]             `<<-` <- base::`<<-`
[13:23:32.143]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.143]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.143]                   3L)]
[13:23:32.143]             }
[13:23:32.143]             function(cond) {
[13:23:32.143]                 is_error <- inherits(cond, "error")
[13:23:32.143]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.143]                   NULL)
[13:23:32.143]                 if (is_error) {
[13:23:32.143]                   sessionInformation <- function() {
[13:23:32.143]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.143]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.143]                       search = base::search(), system = base::Sys.info())
[13:23:32.143]                   }
[13:23:32.143]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.143]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.143]                     cond$call), session = sessionInformation(), 
[13:23:32.143]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.143]                   signalCondition(cond)
[13:23:32.143]                 }
[13:23:32.143]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.143]                 "immediateCondition"))) {
[13:23:32.143]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.143]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.143]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.143]                   if (TRUE && !signal) {
[13:23:32.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.143]                     {
[13:23:32.143]                       inherits <- base::inherits
[13:23:32.143]                       invokeRestart <- base::invokeRestart
[13:23:32.143]                       is.null <- base::is.null
[13:23:32.143]                       muffled <- FALSE
[13:23:32.143]                       if (inherits(cond, "message")) {
[13:23:32.143]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.143]                         if (muffled) 
[13:23:32.143]                           invokeRestart("muffleMessage")
[13:23:32.143]                       }
[13:23:32.143]                       else if (inherits(cond, "warning")) {
[13:23:32.143]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.143]                         if (muffled) 
[13:23:32.143]                           invokeRestart("muffleWarning")
[13:23:32.143]                       }
[13:23:32.143]                       else if (inherits(cond, "condition")) {
[13:23:32.143]                         if (!is.null(pattern)) {
[13:23:32.143]                           computeRestarts <- base::computeRestarts
[13:23:32.143]                           grepl <- base::grepl
[13:23:32.143]                           restarts <- computeRestarts(cond)
[13:23:32.143]                           for (restart in restarts) {
[13:23:32.143]                             name <- restart$name
[13:23:32.143]                             if (is.null(name)) 
[13:23:32.143]                               next
[13:23:32.143]                             if (!grepl(pattern, name)) 
[13:23:32.143]                               next
[13:23:32.143]                             invokeRestart(restart)
[13:23:32.143]                             muffled <- TRUE
[13:23:32.143]                             break
[13:23:32.143]                           }
[13:23:32.143]                         }
[13:23:32.143]                       }
[13:23:32.143]                       invisible(muffled)
[13:23:32.143]                     }
[13:23:32.143]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.143]                   }
[13:23:32.143]                 }
[13:23:32.143]                 else {
[13:23:32.143]                   if (TRUE) {
[13:23:32.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.143]                     {
[13:23:32.143]                       inherits <- base::inherits
[13:23:32.143]                       invokeRestart <- base::invokeRestart
[13:23:32.143]                       is.null <- base::is.null
[13:23:32.143]                       muffled <- FALSE
[13:23:32.143]                       if (inherits(cond, "message")) {
[13:23:32.143]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.143]                         if (muffled) 
[13:23:32.143]                           invokeRestart("muffleMessage")
[13:23:32.143]                       }
[13:23:32.143]                       else if (inherits(cond, "warning")) {
[13:23:32.143]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.143]                         if (muffled) 
[13:23:32.143]                           invokeRestart("muffleWarning")
[13:23:32.143]                       }
[13:23:32.143]                       else if (inherits(cond, "condition")) {
[13:23:32.143]                         if (!is.null(pattern)) {
[13:23:32.143]                           computeRestarts <- base::computeRestarts
[13:23:32.143]                           grepl <- base::grepl
[13:23:32.143]                           restarts <- computeRestarts(cond)
[13:23:32.143]                           for (restart in restarts) {
[13:23:32.143]                             name <- restart$name
[13:23:32.143]                             if (is.null(name)) 
[13:23:32.143]                               next
[13:23:32.143]                             if (!grepl(pattern, name)) 
[13:23:32.143]                               next
[13:23:32.143]                             invokeRestart(restart)
[13:23:32.143]                             muffled <- TRUE
[13:23:32.143]                             break
[13:23:32.143]                           }
[13:23:32.143]                         }
[13:23:32.143]                       }
[13:23:32.143]                       invisible(muffled)
[13:23:32.143]                     }
[13:23:32.143]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.143]                   }
[13:23:32.143]                 }
[13:23:32.143]             }
[13:23:32.143]         }))
[13:23:32.143]     }, error = function(ex) {
[13:23:32.143]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.143]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.143]                 ...future.rng), started = ...future.startTime, 
[13:23:32.143]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.143]             version = "1.8"), class = "FutureResult")
[13:23:32.143]     }, finally = {
[13:23:32.143]         if (!identical(...future.workdir, getwd())) 
[13:23:32.143]             setwd(...future.workdir)
[13:23:32.143]         {
[13:23:32.143]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.143]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.143]             }
[13:23:32.143]             base::options(...future.oldOptions)
[13:23:32.143]             if (.Platform$OS.type == "windows") {
[13:23:32.143]                 old_names <- names(...future.oldEnvVars)
[13:23:32.143]                 envs <- base::Sys.getenv()
[13:23:32.143]                 names <- names(envs)
[13:23:32.143]                 common <- intersect(names, old_names)
[13:23:32.143]                 added <- setdiff(names, old_names)
[13:23:32.143]                 removed <- setdiff(old_names, names)
[13:23:32.143]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.143]                   envs[common]]
[13:23:32.143]                 NAMES <- toupper(changed)
[13:23:32.143]                 args <- list()
[13:23:32.143]                 for (kk in seq_along(NAMES)) {
[13:23:32.143]                   name <- changed[[kk]]
[13:23:32.143]                   NAME <- NAMES[[kk]]
[13:23:32.143]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.143]                     next
[13:23:32.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.143]                 }
[13:23:32.143]                 NAMES <- toupper(added)
[13:23:32.143]                 for (kk in seq_along(NAMES)) {
[13:23:32.143]                   name <- added[[kk]]
[13:23:32.143]                   NAME <- NAMES[[kk]]
[13:23:32.143]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.143]                     next
[13:23:32.143]                   args[[name]] <- ""
[13:23:32.143]                 }
[13:23:32.143]                 NAMES <- toupper(removed)
[13:23:32.143]                 for (kk in seq_along(NAMES)) {
[13:23:32.143]                   name <- removed[[kk]]
[13:23:32.143]                   NAME <- NAMES[[kk]]
[13:23:32.143]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.143]                     next
[13:23:32.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.143]                 }
[13:23:32.143]                 if (length(args) > 0) 
[13:23:32.143]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.143]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.143]             }
[13:23:32.143]             else {
[13:23:32.143]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.143]             }
[13:23:32.143]             {
[13:23:32.143]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.143]                   0L) {
[13:23:32.143]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.143]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.143]                   base::options(opts)
[13:23:32.143]                 }
[13:23:32.143]                 {
[13:23:32.143]                   {
[13:23:32.143]                     NULL
[13:23:32.143]                     RNGkind("Mersenne-Twister")
[13:23:32.143]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.143]                       inherits = FALSE)
[13:23:32.143]                   }
[13:23:32.143]                   options(future.plan = NULL)
[13:23:32.143]                   if (is.na(NA_character_)) 
[13:23:32.143]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.143]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.143]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.143]                   {
[13:23:32.143]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.143]                     if (!future$lazy) 
[13:23:32.143]                       future <- run(future)
[13:23:32.143]                     invisible(future)
[13:23:32.143]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.143]                 }
[13:23:32.143]             }
[13:23:32.143]         }
[13:23:32.143]     })
[13:23:32.143]     if (TRUE) {
[13:23:32.143]         base::sink(type = "output", split = FALSE)
[13:23:32.143]         if (TRUE) {
[13:23:32.143]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.143]         }
[13:23:32.143]         else {
[13:23:32.143]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.143]         }
[13:23:32.143]         base::close(...future.stdout)
[13:23:32.143]         ...future.stdout <- NULL
[13:23:32.143]     }
[13:23:32.143]     ...future.result$conditions <- ...future.conditions
[13:23:32.143]     ...future.result$finished <- base::Sys.time()
[13:23:32.143]     ...future.result
[13:23:32.143] }
[13:23:32.145] assign_globals() ...
[13:23:32.145] List of 1
[13:23:32.145]  $ a: num 3
[13:23:32.145]  - attr(*, "where")=List of 1
[13:23:32.145]   ..$ a:<environment: R_EmptyEnv> 
[13:23:32.145]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.145]  - attr(*, "resolved")= logi TRUE
[13:23:32.145]  - attr(*, "total_size")= num 56
[13:23:32.145]  - attr(*, "already-done")= logi TRUE
[13:23:32.148] - copied ‘a’ to environment
[13:23:32.148] assign_globals() ... done
[13:23:32.149] plan(): Setting new future strategy stack:
[13:23:32.149] List of future strategies:
[13:23:32.149] 1. sequential:
[13:23:32.149]    - args: function (..., envir = parent.frame())
[13:23:32.149]    - tweaked: FALSE
[13:23:32.149]    - call: NULL
[13:23:32.149] plan(): nbrOfWorkers() = 1
[13:23:32.150] plan(): Setting new future strategy stack:
[13:23:32.150] List of future strategies:
[13:23:32.150] 1. sequential:
[13:23:32.150]    - args: function (..., envir = parent.frame())
[13:23:32.150]    - tweaked: FALSE
[13:23:32.150]    - call: plan(strategy)
[13:23:32.150] plan(): nbrOfWorkers() = 1
[13:23:32.151] SequentialFuture started (and completed)
[13:23:32.151] - Launch lazy future ... done
[13:23:32.151] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.152] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.152] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:32.154] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:32.154] Searching for globals ... DONE
[13:23:32.154] Resolving globals: TRUE
[13:23:32.154] Resolving any globals that are futures ...
[13:23:32.154] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:32.154] Resolving any globals that are futures ... DONE
[13:23:32.155] Resolving futures part of globals (recursively) ...
[13:23:32.155] resolve() on list ...
[13:23:32.155]  recursive: 99
[13:23:32.155]  length: 2
[13:23:32.155]  elements: ‘a’, ‘ii’
[13:23:32.155]  length: 1 (resolved future 1)
[13:23:32.156]  length: 0 (resolved future 2)
[13:23:32.156] resolve() on list ... DONE
[13:23:32.156] - globals: [2] ‘a’, ‘ii’
[13:23:32.156] Resolving futures part of globals (recursively) ... DONE
[13:23:32.156] The total size of the 2 globals is 112 bytes (112 bytes)
[13:23:32.156] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:23:32.157] - globals: [2] ‘a’, ‘ii’
[13:23:32.157] 
[13:23:32.157] getGlobalsAndPackages() ... DONE
[13:23:32.157] run() for ‘Future’ ...
[13:23:32.157] - state: ‘created’
[13:23:32.157] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.158] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.158] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.158]   - Field: ‘label’
[13:23:32.158]   - Field: ‘local’
[13:23:32.158]   - Field: ‘owner’
[13:23:32.158]   - Field: ‘envir’
[13:23:32.158]   - Field: ‘packages’
[13:23:32.158]   - Field: ‘gc’
[13:23:32.158]   - Field: ‘conditions’
[13:23:32.159]   - Field: ‘expr’
[13:23:32.159]   - Field: ‘uuid’
[13:23:32.159]   - Field: ‘seed’
[13:23:32.159]   - Field: ‘version’
[13:23:32.159]   - Field: ‘result’
[13:23:32.159]   - Field: ‘asynchronous’
[13:23:32.159]   - Field: ‘calls’
[13:23:32.159]   - Field: ‘globals’
[13:23:32.159]   - Field: ‘stdout’
[13:23:32.159]   - Field: ‘earlySignal’
[13:23:32.159]   - Field: ‘lazy’
[13:23:32.160]   - Field: ‘state’
[13:23:32.160] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.160] - Launch lazy future ...
[13:23:32.160] Packages needed by the future expression (n = 0): <none>
[13:23:32.160] Packages needed by future strategies (n = 0): <none>
[13:23:32.161] {
[13:23:32.161]     {
[13:23:32.161]         {
[13:23:32.161]             ...future.startTime <- base::Sys.time()
[13:23:32.161]             {
[13:23:32.161]                 {
[13:23:32.161]                   {
[13:23:32.161]                     base::local({
[13:23:32.161]                       has_future <- base::requireNamespace("future", 
[13:23:32.161]                         quietly = TRUE)
[13:23:32.161]                       if (has_future) {
[13:23:32.161]                         ns <- base::getNamespace("future")
[13:23:32.161]                         version <- ns[[".package"]][["version"]]
[13:23:32.161]                         if (is.null(version)) 
[13:23:32.161]                           version <- utils::packageVersion("future")
[13:23:32.161]                       }
[13:23:32.161]                       else {
[13:23:32.161]                         version <- NULL
[13:23:32.161]                       }
[13:23:32.161]                       if (!has_future || version < "1.8.0") {
[13:23:32.161]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.161]                           "", base::R.version$version.string), 
[13:23:32.161]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:32.161]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.161]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.161]                             "release", "version")], collapse = " "), 
[13:23:32.161]                           hostname = base::Sys.info()[["nodename"]])
[13:23:32.161]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.161]                           info)
[13:23:32.161]                         info <- base::paste(info, collapse = "; ")
[13:23:32.161]                         if (!has_future) {
[13:23:32.161]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.161]                             info)
[13:23:32.161]                         }
[13:23:32.161]                         else {
[13:23:32.161]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.161]                             info, version)
[13:23:32.161]                         }
[13:23:32.161]                         base::stop(msg)
[13:23:32.161]                       }
[13:23:32.161]                     })
[13:23:32.161]                   }
[13:23:32.161]                   options(future.plan = NULL)
[13:23:32.161]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.161]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.161]                 }
[13:23:32.161]                 ...future.workdir <- getwd()
[13:23:32.161]             }
[13:23:32.161]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.161]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.161]         }
[13:23:32.161]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.161]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:32.161]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.161]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.161]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.161]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.161]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.161]             base::names(...future.oldOptions))
[13:23:32.161]     }
[13:23:32.161]     if (FALSE) {
[13:23:32.161]     }
[13:23:32.161]     else {
[13:23:32.161]         if (TRUE) {
[13:23:32.161]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.161]                 open = "w")
[13:23:32.161]         }
[13:23:32.161]         else {
[13:23:32.161]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.161]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.161]         }
[13:23:32.161]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.161]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.161]             base::sink(type = "output", split = FALSE)
[13:23:32.161]             base::close(...future.stdout)
[13:23:32.161]         }, add = TRUE)
[13:23:32.161]     }
[13:23:32.161]     ...future.frame <- base::sys.nframe()
[13:23:32.161]     ...future.conditions <- base::list()
[13:23:32.161]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.161]     if (FALSE) {
[13:23:32.161]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.161]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.161]     }
[13:23:32.161]     ...future.result <- base::tryCatch({
[13:23:32.161]         base::withCallingHandlers({
[13:23:32.161]             ...future.value <- base::withVisible(base::local({
[13:23:32.161]                 b <- a * ii
[13:23:32.161]                 a <- 0
[13:23:32.161]                 b
[13:23:32.161]             }))
[13:23:32.161]             future::FutureResult(value = ...future.value$value, 
[13:23:32.161]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.161]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.161]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.161]                     ...future.globalenv.names))
[13:23:32.161]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.161]         }, condition = base::local({
[13:23:32.161]             c <- base::c
[13:23:32.161]             inherits <- base::inherits
[13:23:32.161]             invokeRestart <- base::invokeRestart
[13:23:32.161]             length <- base::length
[13:23:32.161]             list <- base::list
[13:23:32.161]             seq.int <- base::seq.int
[13:23:32.161]             signalCondition <- base::signalCondition
[13:23:32.161]             sys.calls <- base::sys.calls
[13:23:32.161]             `[[` <- base::`[[`
[13:23:32.161]             `+` <- base::`+`
[13:23:32.161]             `<<-` <- base::`<<-`
[13:23:32.161]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.161]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.161]                   3L)]
[13:23:32.161]             }
[13:23:32.161]             function(cond) {
[13:23:32.161]                 is_error <- inherits(cond, "error")
[13:23:32.161]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.161]                   NULL)
[13:23:32.161]                 if (is_error) {
[13:23:32.161]                   sessionInformation <- function() {
[13:23:32.161]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.161]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.161]                       search = base::search(), system = base::Sys.info())
[13:23:32.161]                   }
[13:23:32.161]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.161]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.161]                     cond$call), session = sessionInformation(), 
[13:23:32.161]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.161]                   signalCondition(cond)
[13:23:32.161]                 }
[13:23:32.161]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.161]                 "immediateCondition"))) {
[13:23:32.161]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.161]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.161]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.161]                   if (TRUE && !signal) {
[13:23:32.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.161]                     {
[13:23:32.161]                       inherits <- base::inherits
[13:23:32.161]                       invokeRestart <- base::invokeRestart
[13:23:32.161]                       is.null <- base::is.null
[13:23:32.161]                       muffled <- FALSE
[13:23:32.161]                       if (inherits(cond, "message")) {
[13:23:32.161]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.161]                         if (muffled) 
[13:23:32.161]                           invokeRestart("muffleMessage")
[13:23:32.161]                       }
[13:23:32.161]                       else if (inherits(cond, "warning")) {
[13:23:32.161]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.161]                         if (muffled) 
[13:23:32.161]                           invokeRestart("muffleWarning")
[13:23:32.161]                       }
[13:23:32.161]                       else if (inherits(cond, "condition")) {
[13:23:32.161]                         if (!is.null(pattern)) {
[13:23:32.161]                           computeRestarts <- base::computeRestarts
[13:23:32.161]                           grepl <- base::grepl
[13:23:32.161]                           restarts <- computeRestarts(cond)
[13:23:32.161]                           for (restart in restarts) {
[13:23:32.161]                             name <- restart$name
[13:23:32.161]                             if (is.null(name)) 
[13:23:32.161]                               next
[13:23:32.161]                             if (!grepl(pattern, name)) 
[13:23:32.161]                               next
[13:23:32.161]                             invokeRestart(restart)
[13:23:32.161]                             muffled <- TRUE
[13:23:32.161]                             break
[13:23:32.161]                           }
[13:23:32.161]                         }
[13:23:32.161]                       }
[13:23:32.161]                       invisible(muffled)
[13:23:32.161]                     }
[13:23:32.161]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.161]                   }
[13:23:32.161]                 }
[13:23:32.161]                 else {
[13:23:32.161]                   if (TRUE) {
[13:23:32.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.161]                     {
[13:23:32.161]                       inherits <- base::inherits
[13:23:32.161]                       invokeRestart <- base::invokeRestart
[13:23:32.161]                       is.null <- base::is.null
[13:23:32.161]                       muffled <- FALSE
[13:23:32.161]                       if (inherits(cond, "message")) {
[13:23:32.161]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.161]                         if (muffled) 
[13:23:32.161]                           invokeRestart("muffleMessage")
[13:23:32.161]                       }
[13:23:32.161]                       else if (inherits(cond, "warning")) {
[13:23:32.161]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.161]                         if (muffled) 
[13:23:32.161]                           invokeRestart("muffleWarning")
[13:23:32.161]                       }
[13:23:32.161]                       else if (inherits(cond, "condition")) {
[13:23:32.161]                         if (!is.null(pattern)) {
[13:23:32.161]                           computeRestarts <- base::computeRestarts
[13:23:32.161]                           grepl <- base::grepl
[13:23:32.161]                           restarts <- computeRestarts(cond)
[13:23:32.161]                           for (restart in restarts) {
[13:23:32.161]                             name <- restart$name
[13:23:32.161]                             if (is.null(name)) 
[13:23:32.161]                               next
[13:23:32.161]                             if (!grepl(pattern, name)) 
[13:23:32.161]                               next
[13:23:32.161]                             invokeRestart(restart)
[13:23:32.161]                             muffled <- TRUE
[13:23:32.161]                             break
[13:23:32.161]                           }
[13:23:32.161]                         }
[13:23:32.161]                       }
[13:23:32.161]                       invisible(muffled)
[13:23:32.161]                     }
[13:23:32.161]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.161]                   }
[13:23:32.161]                 }
[13:23:32.161]             }
[13:23:32.161]         }))
[13:23:32.161]     }, error = function(ex) {
[13:23:32.161]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.161]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.161]                 ...future.rng), started = ...future.startTime, 
[13:23:32.161]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.161]             version = "1.8"), class = "FutureResult")
[13:23:32.161]     }, finally = {
[13:23:32.161]         if (!identical(...future.workdir, getwd())) 
[13:23:32.161]             setwd(...future.workdir)
[13:23:32.161]         {
[13:23:32.161]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.161]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.161]             }
[13:23:32.161]             base::options(...future.oldOptions)
[13:23:32.161]             if (.Platform$OS.type == "windows") {
[13:23:32.161]                 old_names <- names(...future.oldEnvVars)
[13:23:32.161]                 envs <- base::Sys.getenv()
[13:23:32.161]                 names <- names(envs)
[13:23:32.161]                 common <- intersect(names, old_names)
[13:23:32.161]                 added <- setdiff(names, old_names)
[13:23:32.161]                 removed <- setdiff(old_names, names)
[13:23:32.161]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.161]                   envs[common]]
[13:23:32.161]                 NAMES <- toupper(changed)
[13:23:32.161]                 args <- list()
[13:23:32.161]                 for (kk in seq_along(NAMES)) {
[13:23:32.161]                   name <- changed[[kk]]
[13:23:32.161]                   NAME <- NAMES[[kk]]
[13:23:32.161]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.161]                     next
[13:23:32.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.161]                 }
[13:23:32.161]                 NAMES <- toupper(added)
[13:23:32.161]                 for (kk in seq_along(NAMES)) {
[13:23:32.161]                   name <- added[[kk]]
[13:23:32.161]                   NAME <- NAMES[[kk]]
[13:23:32.161]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.161]                     next
[13:23:32.161]                   args[[name]] <- ""
[13:23:32.161]                 }
[13:23:32.161]                 NAMES <- toupper(removed)
[13:23:32.161]                 for (kk in seq_along(NAMES)) {
[13:23:32.161]                   name <- removed[[kk]]
[13:23:32.161]                   NAME <- NAMES[[kk]]
[13:23:32.161]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.161]                     next
[13:23:32.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.161]                 }
[13:23:32.161]                 if (length(args) > 0) 
[13:23:32.161]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.161]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.161]             }
[13:23:32.161]             else {
[13:23:32.161]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.161]             }
[13:23:32.161]             {
[13:23:32.161]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.161]                   0L) {
[13:23:32.161]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.161]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.161]                   base::options(opts)
[13:23:32.161]                 }
[13:23:32.161]                 {
[13:23:32.161]                   {
[13:23:32.161]                     NULL
[13:23:32.161]                     RNGkind("Mersenne-Twister")
[13:23:32.161]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.161]                       inherits = FALSE)
[13:23:32.161]                   }
[13:23:32.161]                   options(future.plan = NULL)
[13:23:32.161]                   if (is.na(NA_character_)) 
[13:23:32.161]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.161]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.161]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.161]                   {
[13:23:32.161]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.161]                     if (!future$lazy) 
[13:23:32.161]                       future <- run(future)
[13:23:32.161]                     invisible(future)
[13:23:32.161]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.161]                 }
[13:23:32.161]             }
[13:23:32.161]         }
[13:23:32.161]     })
[13:23:32.161]     if (TRUE) {
[13:23:32.161]         base::sink(type = "output", split = FALSE)
[13:23:32.161]         if (TRUE) {
[13:23:32.161]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.161]         }
[13:23:32.161]         else {
[13:23:32.161]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.161]         }
[13:23:32.161]         base::close(...future.stdout)
[13:23:32.161]         ...future.stdout <- NULL
[13:23:32.161]     }
[13:23:32.161]     ...future.result$conditions <- ...future.conditions
[13:23:32.161]     ...future.result$finished <- base::Sys.time()
[13:23:32.161]     ...future.result
[13:23:32.161] }
[13:23:32.162] assign_globals() ...
[13:23:32.162] List of 2
[13:23:32.162]  $ a : num 1
[13:23:32.162]  $ ii: int 1
[13:23:32.162]  - attr(*, "where")=List of 2
[13:23:32.162]   ..$ a :<environment: R_EmptyEnv> 
[13:23:32.162]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:32.162]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.162]  - attr(*, "resolved")= logi TRUE
[13:23:32.162]  - attr(*, "total_size")= num 112
[13:23:32.162]  - attr(*, "already-done")= logi TRUE
[13:23:32.168] - copied ‘a’ to environment
[13:23:32.168] - copied ‘ii’ to environment
[13:23:32.168] assign_globals() ... done
[13:23:32.169] plan(): Setting new future strategy stack:
[13:23:32.169] List of future strategies:
[13:23:32.169] 1. sequential:
[13:23:32.169]    - args: function (..., envir = parent.frame())
[13:23:32.169]    - tweaked: FALSE
[13:23:32.169]    - call: NULL
[13:23:32.169] plan(): nbrOfWorkers() = 1
[13:23:32.170] plan(): Setting new future strategy stack:
[13:23:32.170] List of future strategies:
[13:23:32.170] 1. sequential:
[13:23:32.170]    - args: function (..., envir = parent.frame())
[13:23:32.170]    - tweaked: FALSE
[13:23:32.170]    - call: plan(strategy)
[13:23:32.171] plan(): nbrOfWorkers() = 1
[13:23:32.171] SequentialFuture started (and completed)
[13:23:32.171] - Launch lazy future ... done
[13:23:32.171] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.171] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.172] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:32.174] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:32.174] Searching for globals ... DONE
[13:23:32.174] Resolving globals: TRUE
[13:23:32.174] Resolving any globals that are futures ...
[13:23:32.174] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:32.174] Resolving any globals that are futures ... DONE
[13:23:32.175] Resolving futures part of globals (recursively) ...
[13:23:32.175] resolve() on list ...
[13:23:32.175]  recursive: 99
[13:23:32.175]  length: 2
[13:23:32.175]  elements: ‘a’, ‘ii’
[13:23:32.175]  length: 1 (resolved future 1)
[13:23:32.175]  length: 0 (resolved future 2)
[13:23:32.176] resolve() on list ... DONE
[13:23:32.176] - globals: [2] ‘a’, ‘ii’
[13:23:32.176] Resolving futures part of globals (recursively) ... DONE
[13:23:32.176] The total size of the 2 globals is 112 bytes (112 bytes)
[13:23:32.176] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:23:32.176] - globals: [2] ‘a’, ‘ii’
[13:23:32.177] 
[13:23:32.177] getGlobalsAndPackages() ... DONE
[13:23:32.177] run() for ‘Future’ ...
[13:23:32.177] - state: ‘created’
[13:23:32.177] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.178] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.178] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.178]   - Field: ‘label’
[13:23:32.178]   - Field: ‘local’
[13:23:32.178]   - Field: ‘owner’
[13:23:32.178]   - Field: ‘envir’
[13:23:32.178]   - Field: ‘packages’
[13:23:32.178]   - Field: ‘gc’
[13:23:32.178]   - Field: ‘conditions’
[13:23:32.178]   - Field: ‘expr’
[13:23:32.179]   - Field: ‘uuid’
[13:23:32.179]   - Field: ‘seed’
[13:23:32.179]   - Field: ‘version’
[13:23:32.179]   - Field: ‘result’
[13:23:32.179]   - Field: ‘asynchronous’
[13:23:32.179]   - Field: ‘calls’
[13:23:32.179]   - Field: ‘globals’
[13:23:32.179]   - Field: ‘stdout’
[13:23:32.179]   - Field: ‘earlySignal’
[13:23:32.179]   - Field: ‘lazy’
[13:23:32.180]   - Field: ‘state’
[13:23:32.180] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.180] - Launch lazy future ...
[13:23:32.180] Packages needed by the future expression (n = 0): <none>
[13:23:32.180] Packages needed by future strategies (n = 0): <none>
[13:23:32.181] {
[13:23:32.181]     {
[13:23:32.181]         {
[13:23:32.181]             ...future.startTime <- base::Sys.time()
[13:23:32.181]             {
[13:23:32.181]                 {
[13:23:32.181]                   {
[13:23:32.181]                     base::local({
[13:23:32.181]                       has_future <- base::requireNamespace("future", 
[13:23:32.181]                         quietly = TRUE)
[13:23:32.181]                       if (has_future) {
[13:23:32.181]                         ns <- base::getNamespace("future")
[13:23:32.181]                         version <- ns[[".package"]][["version"]]
[13:23:32.181]                         if (is.null(version)) 
[13:23:32.181]                           version <- utils::packageVersion("future")
[13:23:32.181]                       }
[13:23:32.181]                       else {
[13:23:32.181]                         version <- NULL
[13:23:32.181]                       }
[13:23:32.181]                       if (!has_future || version < "1.8.0") {
[13:23:32.181]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.181]                           "", base::R.version$version.string), 
[13:23:32.181]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:32.181]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.181]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.181]                             "release", "version")], collapse = " "), 
[13:23:32.181]                           hostname = base::Sys.info()[["nodename"]])
[13:23:32.181]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.181]                           info)
[13:23:32.181]                         info <- base::paste(info, collapse = "; ")
[13:23:32.181]                         if (!has_future) {
[13:23:32.181]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.181]                             info)
[13:23:32.181]                         }
[13:23:32.181]                         else {
[13:23:32.181]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.181]                             info, version)
[13:23:32.181]                         }
[13:23:32.181]                         base::stop(msg)
[13:23:32.181]                       }
[13:23:32.181]                     })
[13:23:32.181]                   }
[13:23:32.181]                   options(future.plan = NULL)
[13:23:32.181]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.181]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.181]                 }
[13:23:32.181]                 ...future.workdir <- getwd()
[13:23:32.181]             }
[13:23:32.181]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.181]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.181]         }
[13:23:32.181]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.181]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:32.181]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.181]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.181]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.181]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.181]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.181]             base::names(...future.oldOptions))
[13:23:32.181]     }
[13:23:32.181]     if (FALSE) {
[13:23:32.181]     }
[13:23:32.181]     else {
[13:23:32.181]         if (TRUE) {
[13:23:32.181]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.181]                 open = "w")
[13:23:32.181]         }
[13:23:32.181]         else {
[13:23:32.181]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.181]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.181]         }
[13:23:32.181]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.181]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.181]             base::sink(type = "output", split = FALSE)
[13:23:32.181]             base::close(...future.stdout)
[13:23:32.181]         }, add = TRUE)
[13:23:32.181]     }
[13:23:32.181]     ...future.frame <- base::sys.nframe()
[13:23:32.181]     ...future.conditions <- base::list()
[13:23:32.181]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.181]     if (FALSE) {
[13:23:32.181]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.181]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.181]     }
[13:23:32.181]     ...future.result <- base::tryCatch({
[13:23:32.181]         base::withCallingHandlers({
[13:23:32.181]             ...future.value <- base::withVisible(base::local({
[13:23:32.181]                 b <- a * ii
[13:23:32.181]                 a <- 0
[13:23:32.181]                 b
[13:23:32.181]             }))
[13:23:32.181]             future::FutureResult(value = ...future.value$value, 
[13:23:32.181]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.181]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.181]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.181]                     ...future.globalenv.names))
[13:23:32.181]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.181]         }, condition = base::local({
[13:23:32.181]             c <- base::c
[13:23:32.181]             inherits <- base::inherits
[13:23:32.181]             invokeRestart <- base::invokeRestart
[13:23:32.181]             length <- base::length
[13:23:32.181]             list <- base::list
[13:23:32.181]             seq.int <- base::seq.int
[13:23:32.181]             signalCondition <- base::signalCondition
[13:23:32.181]             sys.calls <- base::sys.calls
[13:23:32.181]             `[[` <- base::`[[`
[13:23:32.181]             `+` <- base::`+`
[13:23:32.181]             `<<-` <- base::`<<-`
[13:23:32.181]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.181]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.181]                   3L)]
[13:23:32.181]             }
[13:23:32.181]             function(cond) {
[13:23:32.181]                 is_error <- inherits(cond, "error")
[13:23:32.181]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.181]                   NULL)
[13:23:32.181]                 if (is_error) {
[13:23:32.181]                   sessionInformation <- function() {
[13:23:32.181]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.181]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.181]                       search = base::search(), system = base::Sys.info())
[13:23:32.181]                   }
[13:23:32.181]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.181]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.181]                     cond$call), session = sessionInformation(), 
[13:23:32.181]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.181]                   signalCondition(cond)
[13:23:32.181]                 }
[13:23:32.181]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.181]                 "immediateCondition"))) {
[13:23:32.181]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.181]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.181]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.181]                   if (TRUE && !signal) {
[13:23:32.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.181]                     {
[13:23:32.181]                       inherits <- base::inherits
[13:23:32.181]                       invokeRestart <- base::invokeRestart
[13:23:32.181]                       is.null <- base::is.null
[13:23:32.181]                       muffled <- FALSE
[13:23:32.181]                       if (inherits(cond, "message")) {
[13:23:32.181]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.181]                         if (muffled) 
[13:23:32.181]                           invokeRestart("muffleMessage")
[13:23:32.181]                       }
[13:23:32.181]                       else if (inherits(cond, "warning")) {
[13:23:32.181]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.181]                         if (muffled) 
[13:23:32.181]                           invokeRestart("muffleWarning")
[13:23:32.181]                       }
[13:23:32.181]                       else if (inherits(cond, "condition")) {
[13:23:32.181]                         if (!is.null(pattern)) {
[13:23:32.181]                           computeRestarts <- base::computeRestarts
[13:23:32.181]                           grepl <- base::grepl
[13:23:32.181]                           restarts <- computeRestarts(cond)
[13:23:32.181]                           for (restart in restarts) {
[13:23:32.181]                             name <- restart$name
[13:23:32.181]                             if (is.null(name)) 
[13:23:32.181]                               next
[13:23:32.181]                             if (!grepl(pattern, name)) 
[13:23:32.181]                               next
[13:23:32.181]                             invokeRestart(restart)
[13:23:32.181]                             muffled <- TRUE
[13:23:32.181]                             break
[13:23:32.181]                           }
[13:23:32.181]                         }
[13:23:32.181]                       }
[13:23:32.181]                       invisible(muffled)
[13:23:32.181]                     }
[13:23:32.181]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.181]                   }
[13:23:32.181]                 }
[13:23:32.181]                 else {
[13:23:32.181]                   if (TRUE) {
[13:23:32.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.181]                     {
[13:23:32.181]                       inherits <- base::inherits
[13:23:32.181]                       invokeRestart <- base::invokeRestart
[13:23:32.181]                       is.null <- base::is.null
[13:23:32.181]                       muffled <- FALSE
[13:23:32.181]                       if (inherits(cond, "message")) {
[13:23:32.181]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.181]                         if (muffled) 
[13:23:32.181]                           invokeRestart("muffleMessage")
[13:23:32.181]                       }
[13:23:32.181]                       else if (inherits(cond, "warning")) {
[13:23:32.181]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.181]                         if (muffled) 
[13:23:32.181]                           invokeRestart("muffleWarning")
[13:23:32.181]                       }
[13:23:32.181]                       else if (inherits(cond, "condition")) {
[13:23:32.181]                         if (!is.null(pattern)) {
[13:23:32.181]                           computeRestarts <- base::computeRestarts
[13:23:32.181]                           grepl <- base::grepl
[13:23:32.181]                           restarts <- computeRestarts(cond)
[13:23:32.181]                           for (restart in restarts) {
[13:23:32.181]                             name <- restart$name
[13:23:32.181]                             if (is.null(name)) 
[13:23:32.181]                               next
[13:23:32.181]                             if (!grepl(pattern, name)) 
[13:23:32.181]                               next
[13:23:32.181]                             invokeRestart(restart)
[13:23:32.181]                             muffled <- TRUE
[13:23:32.181]                             break
[13:23:32.181]                           }
[13:23:32.181]                         }
[13:23:32.181]                       }
[13:23:32.181]                       invisible(muffled)
[13:23:32.181]                     }
[13:23:32.181]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.181]                   }
[13:23:32.181]                 }
[13:23:32.181]             }
[13:23:32.181]         }))
[13:23:32.181]     }, error = function(ex) {
[13:23:32.181]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.181]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.181]                 ...future.rng), started = ...future.startTime, 
[13:23:32.181]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.181]             version = "1.8"), class = "FutureResult")
[13:23:32.181]     }, finally = {
[13:23:32.181]         if (!identical(...future.workdir, getwd())) 
[13:23:32.181]             setwd(...future.workdir)
[13:23:32.181]         {
[13:23:32.181]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.181]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.181]             }
[13:23:32.181]             base::options(...future.oldOptions)
[13:23:32.181]             if (.Platform$OS.type == "windows") {
[13:23:32.181]                 old_names <- names(...future.oldEnvVars)
[13:23:32.181]                 envs <- base::Sys.getenv()
[13:23:32.181]                 names <- names(envs)
[13:23:32.181]                 common <- intersect(names, old_names)
[13:23:32.181]                 added <- setdiff(names, old_names)
[13:23:32.181]                 removed <- setdiff(old_names, names)
[13:23:32.181]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.181]                   envs[common]]
[13:23:32.181]                 NAMES <- toupper(changed)
[13:23:32.181]                 args <- list()
[13:23:32.181]                 for (kk in seq_along(NAMES)) {
[13:23:32.181]                   name <- changed[[kk]]
[13:23:32.181]                   NAME <- NAMES[[kk]]
[13:23:32.181]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.181]                     next
[13:23:32.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.181]                 }
[13:23:32.181]                 NAMES <- toupper(added)
[13:23:32.181]                 for (kk in seq_along(NAMES)) {
[13:23:32.181]                   name <- added[[kk]]
[13:23:32.181]                   NAME <- NAMES[[kk]]
[13:23:32.181]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.181]                     next
[13:23:32.181]                   args[[name]] <- ""
[13:23:32.181]                 }
[13:23:32.181]                 NAMES <- toupper(removed)
[13:23:32.181]                 for (kk in seq_along(NAMES)) {
[13:23:32.181]                   name <- removed[[kk]]
[13:23:32.181]                   NAME <- NAMES[[kk]]
[13:23:32.181]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.181]                     next
[13:23:32.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.181]                 }
[13:23:32.181]                 if (length(args) > 0) 
[13:23:32.181]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.181]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.181]             }
[13:23:32.181]             else {
[13:23:32.181]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.181]             }
[13:23:32.181]             {
[13:23:32.181]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.181]                   0L) {
[13:23:32.181]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.181]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.181]                   base::options(opts)
[13:23:32.181]                 }
[13:23:32.181]                 {
[13:23:32.181]                   {
[13:23:32.181]                     NULL
[13:23:32.181]                     RNGkind("Mersenne-Twister")
[13:23:32.181]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.181]                       inherits = FALSE)
[13:23:32.181]                   }
[13:23:32.181]                   options(future.plan = NULL)
[13:23:32.181]                   if (is.na(NA_character_)) 
[13:23:32.181]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.181]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.181]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.181]                   {
[13:23:32.181]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.181]                     if (!future$lazy) 
[13:23:32.181]                       future <- run(future)
[13:23:32.181]                     invisible(future)
[13:23:32.181]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.181]                 }
[13:23:32.181]             }
[13:23:32.181]         }
[13:23:32.181]     })
[13:23:32.181]     if (TRUE) {
[13:23:32.181]         base::sink(type = "output", split = FALSE)
[13:23:32.181]         if (TRUE) {
[13:23:32.181]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.181]         }
[13:23:32.181]         else {
[13:23:32.181]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.181]         }
[13:23:32.181]         base::close(...future.stdout)
[13:23:32.181]         ...future.stdout <- NULL
[13:23:32.181]     }
[13:23:32.181]     ...future.result$conditions <- ...future.conditions
[13:23:32.181]     ...future.result$finished <- base::Sys.time()
[13:23:32.181]     ...future.result
[13:23:32.181] }
[13:23:32.182] assign_globals() ...
[13:23:32.182] List of 2
[13:23:32.182]  $ a : num 1
[13:23:32.182]  $ ii: int 2
[13:23:32.182]  - attr(*, "where")=List of 2
[13:23:32.182]   ..$ a :<environment: R_EmptyEnv> 
[13:23:32.182]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:32.182]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.182]  - attr(*, "resolved")= logi TRUE
[13:23:32.182]  - attr(*, "total_size")= num 112
[13:23:32.182]  - attr(*, "already-done")= logi TRUE
[13:23:32.186] - copied ‘a’ to environment
[13:23:32.186] - copied ‘ii’ to environment
[13:23:32.186] assign_globals() ... done
[13:23:32.186] plan(): Setting new future strategy stack:
[13:23:32.186] List of future strategies:
[13:23:32.186] 1. sequential:
[13:23:32.186]    - args: function (..., envir = parent.frame())
[13:23:32.186]    - tweaked: FALSE
[13:23:32.186]    - call: NULL
[13:23:32.187] plan(): nbrOfWorkers() = 1
[13:23:32.188] plan(): Setting new future strategy stack:
[13:23:32.188] List of future strategies:
[13:23:32.188] 1. sequential:
[13:23:32.188]    - args: function (..., envir = parent.frame())
[13:23:32.188]    - tweaked: FALSE
[13:23:32.188]    - call: plan(strategy)
[13:23:32.188] plan(): nbrOfWorkers() = 1
[13:23:32.188] SequentialFuture started (and completed)
[13:23:32.189] - Launch lazy future ... done
[13:23:32.189] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.189] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.189] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:32.194] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:32.194] Searching for globals ... DONE
[13:23:32.194] Resolving globals: TRUE
[13:23:32.194] Resolving any globals that are futures ...
[13:23:32.194] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:32.194] Resolving any globals that are futures ... DONE
[13:23:32.195] Resolving futures part of globals (recursively) ...
[13:23:32.195] resolve() on list ...
[13:23:32.195]  recursive: 99
[13:23:32.195]  length: 2
[13:23:32.195]  elements: ‘a’, ‘ii’
[13:23:32.195]  length: 1 (resolved future 1)
[13:23:32.195]  length: 0 (resolved future 2)
[13:23:32.195] resolve() on list ... DONE
[13:23:32.196] - globals: [2] ‘a’, ‘ii’
[13:23:32.196] Resolving futures part of globals (recursively) ... DONE
[13:23:32.196] The total size of the 2 globals is 112 bytes (112 bytes)
[13:23:32.196] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:23:32.196] - globals: [2] ‘a’, ‘ii’
[13:23:32.197] 
[13:23:32.197] getGlobalsAndPackages() ... DONE
[13:23:32.197] run() for ‘Future’ ...
[13:23:32.197] - state: ‘created’
[13:23:32.197] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.197] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.198] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.198]   - Field: ‘label’
[13:23:32.198]   - Field: ‘local’
[13:23:32.198]   - Field: ‘owner’
[13:23:32.198]   - Field: ‘envir’
[13:23:32.198]   - Field: ‘packages’
[13:23:32.198]   - Field: ‘gc’
[13:23:32.198]   - Field: ‘conditions’
[13:23:32.198]   - Field: ‘expr’
[13:23:32.198]   - Field: ‘uuid’
[13:23:32.199]   - Field: ‘seed’
[13:23:32.199]   - Field: ‘version’
[13:23:32.199]   - Field: ‘result’
[13:23:32.199]   - Field: ‘asynchronous’
[13:23:32.199]   - Field: ‘calls’
[13:23:32.199]   - Field: ‘globals’
[13:23:32.199]   - Field: ‘stdout’
[13:23:32.199]   - Field: ‘earlySignal’
[13:23:32.199]   - Field: ‘lazy’
[13:23:32.199]   - Field: ‘state’
[13:23:32.199] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.200] - Launch lazy future ...
[13:23:32.200] Packages needed by the future expression (n = 0): <none>
[13:23:32.200] Packages needed by future strategies (n = 0): <none>
[13:23:32.200] {
[13:23:32.200]     {
[13:23:32.200]         {
[13:23:32.200]             ...future.startTime <- base::Sys.time()
[13:23:32.200]             {
[13:23:32.200]                 {
[13:23:32.200]                   {
[13:23:32.200]                     base::local({
[13:23:32.200]                       has_future <- base::requireNamespace("future", 
[13:23:32.200]                         quietly = TRUE)
[13:23:32.200]                       if (has_future) {
[13:23:32.200]                         ns <- base::getNamespace("future")
[13:23:32.200]                         version <- ns[[".package"]][["version"]]
[13:23:32.200]                         if (is.null(version)) 
[13:23:32.200]                           version <- utils::packageVersion("future")
[13:23:32.200]                       }
[13:23:32.200]                       else {
[13:23:32.200]                         version <- NULL
[13:23:32.200]                       }
[13:23:32.200]                       if (!has_future || version < "1.8.0") {
[13:23:32.200]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.200]                           "", base::R.version$version.string), 
[13:23:32.200]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:32.200]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.200]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.200]                             "release", "version")], collapse = " "), 
[13:23:32.200]                           hostname = base::Sys.info()[["nodename"]])
[13:23:32.200]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.200]                           info)
[13:23:32.200]                         info <- base::paste(info, collapse = "; ")
[13:23:32.200]                         if (!has_future) {
[13:23:32.200]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.200]                             info)
[13:23:32.200]                         }
[13:23:32.200]                         else {
[13:23:32.200]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.200]                             info, version)
[13:23:32.200]                         }
[13:23:32.200]                         base::stop(msg)
[13:23:32.200]                       }
[13:23:32.200]                     })
[13:23:32.200]                   }
[13:23:32.200]                   options(future.plan = NULL)
[13:23:32.200]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.200]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.200]                 }
[13:23:32.200]                 ...future.workdir <- getwd()
[13:23:32.200]             }
[13:23:32.200]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.200]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.200]         }
[13:23:32.200]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.200]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:32.200]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.200]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.200]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.200]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.200]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.200]             base::names(...future.oldOptions))
[13:23:32.200]     }
[13:23:32.200]     if (FALSE) {
[13:23:32.200]     }
[13:23:32.200]     else {
[13:23:32.200]         if (TRUE) {
[13:23:32.200]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.200]                 open = "w")
[13:23:32.200]         }
[13:23:32.200]         else {
[13:23:32.200]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.200]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.200]         }
[13:23:32.200]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.200]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.200]             base::sink(type = "output", split = FALSE)
[13:23:32.200]             base::close(...future.stdout)
[13:23:32.200]         }, add = TRUE)
[13:23:32.200]     }
[13:23:32.200]     ...future.frame <- base::sys.nframe()
[13:23:32.200]     ...future.conditions <- base::list()
[13:23:32.200]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.200]     if (FALSE) {
[13:23:32.200]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.200]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.200]     }
[13:23:32.200]     ...future.result <- base::tryCatch({
[13:23:32.200]         base::withCallingHandlers({
[13:23:32.200]             ...future.value <- base::withVisible(base::local({
[13:23:32.200]                 b <- a * ii
[13:23:32.200]                 a <- 0
[13:23:32.200]                 b
[13:23:32.200]             }))
[13:23:32.200]             future::FutureResult(value = ...future.value$value, 
[13:23:32.200]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.200]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.200]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.200]                     ...future.globalenv.names))
[13:23:32.200]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.200]         }, condition = base::local({
[13:23:32.200]             c <- base::c
[13:23:32.200]             inherits <- base::inherits
[13:23:32.200]             invokeRestart <- base::invokeRestart
[13:23:32.200]             length <- base::length
[13:23:32.200]             list <- base::list
[13:23:32.200]             seq.int <- base::seq.int
[13:23:32.200]             signalCondition <- base::signalCondition
[13:23:32.200]             sys.calls <- base::sys.calls
[13:23:32.200]             `[[` <- base::`[[`
[13:23:32.200]             `+` <- base::`+`
[13:23:32.200]             `<<-` <- base::`<<-`
[13:23:32.200]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.200]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.200]                   3L)]
[13:23:32.200]             }
[13:23:32.200]             function(cond) {
[13:23:32.200]                 is_error <- inherits(cond, "error")
[13:23:32.200]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.200]                   NULL)
[13:23:32.200]                 if (is_error) {
[13:23:32.200]                   sessionInformation <- function() {
[13:23:32.200]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.200]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.200]                       search = base::search(), system = base::Sys.info())
[13:23:32.200]                   }
[13:23:32.200]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.200]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.200]                     cond$call), session = sessionInformation(), 
[13:23:32.200]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.200]                   signalCondition(cond)
[13:23:32.200]                 }
[13:23:32.200]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.200]                 "immediateCondition"))) {
[13:23:32.200]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.200]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.200]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.200]                   if (TRUE && !signal) {
[13:23:32.200]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.200]                     {
[13:23:32.200]                       inherits <- base::inherits
[13:23:32.200]                       invokeRestart <- base::invokeRestart
[13:23:32.200]                       is.null <- base::is.null
[13:23:32.200]                       muffled <- FALSE
[13:23:32.200]                       if (inherits(cond, "message")) {
[13:23:32.200]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.200]                         if (muffled) 
[13:23:32.200]                           invokeRestart("muffleMessage")
[13:23:32.200]                       }
[13:23:32.200]                       else if (inherits(cond, "warning")) {
[13:23:32.200]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.200]                         if (muffled) 
[13:23:32.200]                           invokeRestart("muffleWarning")
[13:23:32.200]                       }
[13:23:32.200]                       else if (inherits(cond, "condition")) {
[13:23:32.200]                         if (!is.null(pattern)) {
[13:23:32.200]                           computeRestarts <- base::computeRestarts
[13:23:32.200]                           grepl <- base::grepl
[13:23:32.200]                           restarts <- computeRestarts(cond)
[13:23:32.200]                           for (restart in restarts) {
[13:23:32.200]                             name <- restart$name
[13:23:32.200]                             if (is.null(name)) 
[13:23:32.200]                               next
[13:23:32.200]                             if (!grepl(pattern, name)) 
[13:23:32.200]                               next
[13:23:32.200]                             invokeRestart(restart)
[13:23:32.200]                             muffled <- TRUE
[13:23:32.200]                             break
[13:23:32.200]                           }
[13:23:32.200]                         }
[13:23:32.200]                       }
[13:23:32.200]                       invisible(muffled)
[13:23:32.200]                     }
[13:23:32.200]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.200]                   }
[13:23:32.200]                 }
[13:23:32.200]                 else {
[13:23:32.200]                   if (TRUE) {
[13:23:32.200]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.200]                     {
[13:23:32.200]                       inherits <- base::inherits
[13:23:32.200]                       invokeRestart <- base::invokeRestart
[13:23:32.200]                       is.null <- base::is.null
[13:23:32.200]                       muffled <- FALSE
[13:23:32.200]                       if (inherits(cond, "message")) {
[13:23:32.200]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.200]                         if (muffled) 
[13:23:32.200]                           invokeRestart("muffleMessage")
[13:23:32.200]                       }
[13:23:32.200]                       else if (inherits(cond, "warning")) {
[13:23:32.200]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.200]                         if (muffled) 
[13:23:32.200]                           invokeRestart("muffleWarning")
[13:23:32.200]                       }
[13:23:32.200]                       else if (inherits(cond, "condition")) {
[13:23:32.200]                         if (!is.null(pattern)) {
[13:23:32.200]                           computeRestarts <- base::computeRestarts
[13:23:32.200]                           grepl <- base::grepl
[13:23:32.200]                           restarts <- computeRestarts(cond)
[13:23:32.200]                           for (restart in restarts) {
[13:23:32.200]                             name <- restart$name
[13:23:32.200]                             if (is.null(name)) 
[13:23:32.200]                               next
[13:23:32.200]                             if (!grepl(pattern, name)) 
[13:23:32.200]                               next
[13:23:32.200]                             invokeRestart(restart)
[13:23:32.200]                             muffled <- TRUE
[13:23:32.200]                             break
[13:23:32.200]                           }
[13:23:32.200]                         }
[13:23:32.200]                       }
[13:23:32.200]                       invisible(muffled)
[13:23:32.200]                     }
[13:23:32.200]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.200]                   }
[13:23:32.200]                 }
[13:23:32.200]             }
[13:23:32.200]         }))
[13:23:32.200]     }, error = function(ex) {
[13:23:32.200]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.200]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.200]                 ...future.rng), started = ...future.startTime, 
[13:23:32.200]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.200]             version = "1.8"), class = "FutureResult")
[13:23:32.200]     }, finally = {
[13:23:32.200]         if (!identical(...future.workdir, getwd())) 
[13:23:32.200]             setwd(...future.workdir)
[13:23:32.200]         {
[13:23:32.200]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.200]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.200]             }
[13:23:32.200]             base::options(...future.oldOptions)
[13:23:32.200]             if (.Platform$OS.type == "windows") {
[13:23:32.200]                 old_names <- names(...future.oldEnvVars)
[13:23:32.200]                 envs <- base::Sys.getenv()
[13:23:32.200]                 names <- names(envs)
[13:23:32.200]                 common <- intersect(names, old_names)
[13:23:32.200]                 added <- setdiff(names, old_names)
[13:23:32.200]                 removed <- setdiff(old_names, names)
[13:23:32.200]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.200]                   envs[common]]
[13:23:32.200]                 NAMES <- toupper(changed)
[13:23:32.200]                 args <- list()
[13:23:32.200]                 for (kk in seq_along(NAMES)) {
[13:23:32.200]                   name <- changed[[kk]]
[13:23:32.200]                   NAME <- NAMES[[kk]]
[13:23:32.200]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.200]                     next
[13:23:32.200]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.200]                 }
[13:23:32.200]                 NAMES <- toupper(added)
[13:23:32.200]                 for (kk in seq_along(NAMES)) {
[13:23:32.200]                   name <- added[[kk]]
[13:23:32.200]                   NAME <- NAMES[[kk]]
[13:23:32.200]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.200]                     next
[13:23:32.200]                   args[[name]] <- ""
[13:23:32.200]                 }
[13:23:32.200]                 NAMES <- toupper(removed)
[13:23:32.200]                 for (kk in seq_along(NAMES)) {
[13:23:32.200]                   name <- removed[[kk]]
[13:23:32.200]                   NAME <- NAMES[[kk]]
[13:23:32.200]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.200]                     next
[13:23:32.200]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.200]                 }
[13:23:32.200]                 if (length(args) > 0) 
[13:23:32.200]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.200]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.200]             }
[13:23:32.200]             else {
[13:23:32.200]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.200]             }
[13:23:32.200]             {
[13:23:32.200]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.200]                   0L) {
[13:23:32.200]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.200]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.200]                   base::options(opts)
[13:23:32.200]                 }
[13:23:32.200]                 {
[13:23:32.200]                   {
[13:23:32.200]                     NULL
[13:23:32.200]                     RNGkind("Mersenne-Twister")
[13:23:32.200]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.200]                       inherits = FALSE)
[13:23:32.200]                   }
[13:23:32.200]                   options(future.plan = NULL)
[13:23:32.200]                   if (is.na(NA_character_)) 
[13:23:32.200]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.200]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.200]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.200]                   {
[13:23:32.200]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.200]                     if (!future$lazy) 
[13:23:32.200]                       future <- run(future)
[13:23:32.200]                     invisible(future)
[13:23:32.200]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.200]                 }
[13:23:32.200]             }
[13:23:32.200]         }
[13:23:32.200]     })
[13:23:32.200]     if (TRUE) {
[13:23:32.200]         base::sink(type = "output", split = FALSE)
[13:23:32.200]         if (TRUE) {
[13:23:32.200]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.200]         }
[13:23:32.200]         else {
[13:23:32.200]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.200]         }
[13:23:32.200]         base::close(...future.stdout)
[13:23:32.200]         ...future.stdout <- NULL
[13:23:32.200]     }
[13:23:32.200]     ...future.result$conditions <- ...future.conditions
[13:23:32.200]     ...future.result$finished <- base::Sys.time()
[13:23:32.200]     ...future.result
[13:23:32.200] }
[13:23:32.202] assign_globals() ...
[13:23:32.202] List of 2
[13:23:32.202]  $ a : num 1
[13:23:32.202]  $ ii: int 3
[13:23:32.202]  - attr(*, "where")=List of 2
[13:23:32.202]   ..$ a :<environment: R_EmptyEnv> 
[13:23:32.202]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:32.202]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.202]  - attr(*, "resolved")= logi TRUE
[13:23:32.202]  - attr(*, "total_size")= num 112
[13:23:32.202]  - attr(*, "already-done")= logi TRUE
[13:23:32.205] - copied ‘a’ to environment
[13:23:32.206] - copied ‘ii’ to environment
[13:23:32.206] assign_globals() ... done
[13:23:32.206] plan(): Setting new future strategy stack:
[13:23:32.206] List of future strategies:
[13:23:32.206] 1. sequential:
[13:23:32.206]    - args: function (..., envir = parent.frame())
[13:23:32.206]    - tweaked: FALSE
[13:23:32.206]    - call: NULL
[13:23:32.206] plan(): nbrOfWorkers() = 1
[13:23:32.207] plan(): Setting new future strategy stack:
[13:23:32.207] List of future strategies:
[13:23:32.207] 1. sequential:
[13:23:32.207]    - args: function (..., envir = parent.frame())
[13:23:32.207]    - tweaked: FALSE
[13:23:32.207]    - call: plan(strategy)
[13:23:32.208] plan(): nbrOfWorkers() = 1
[13:23:32.208] SequentialFuture started (and completed)
[13:23:32.208] - Launch lazy future ... done
[13:23:32.208] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.209] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.209] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:32.211] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:32.211] Searching for globals ... DONE
[13:23:32.211] Resolving globals: TRUE
[13:23:32.212] Resolving any globals that are futures ...
[13:23:32.212] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:32.212] Resolving any globals that are futures ... DONE
[13:23:32.212] Resolving futures part of globals (recursively) ...
[13:23:32.212] resolve() on list ...
[13:23:32.213]  recursive: 99
[13:23:32.213]  length: 2
[13:23:32.213]  elements: ‘a’, ‘ii’
[13:23:32.213]  length: 1 (resolved future 1)
[13:23:32.213]  length: 0 (resolved future 2)
[13:23:32.213] resolve() on list ... DONE
[13:23:32.213] - globals: [2] ‘a’, ‘ii’
[13:23:32.213] Resolving futures part of globals (recursively) ... DONE
[13:23:32.213] The total size of the 2 globals is 112 bytes (112 bytes)
[13:23:32.214] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:23:32.214] - globals: [2] ‘a’, ‘ii’
[13:23:32.214] 
[13:23:32.214] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.215] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.215] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:32.217] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:32.217] Searching for globals ... DONE
[13:23:32.217] Resolving globals: TRUE
[13:23:32.217] Resolving any globals that are futures ...
[13:23:32.217] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:32.220] Resolving any globals that are futures ... DONE
[13:23:32.220] Resolving futures part of globals (recursively) ...
[13:23:32.220] resolve() on list ...
[13:23:32.220]  recursive: 99
[13:23:32.221]  length: 2
[13:23:32.221]  elements: ‘a’, ‘ii’
[13:23:32.221]  length: 1 (resolved future 1)
[13:23:32.221]  length: 0 (resolved future 2)
[13:23:32.221] resolve() on list ... DONE
[13:23:32.221] - globals: [2] ‘a’, ‘ii’
[13:23:32.221] Resolving futures part of globals (recursively) ... DONE
[13:23:32.221] The total size of the 2 globals is 112 bytes (112 bytes)
[13:23:32.222] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:23:32.222] - globals: [2] ‘a’, ‘ii’
[13:23:32.222] 
[13:23:32.222] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.223] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.223] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:32.225] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:32.225] Searching for globals ... DONE
[13:23:32.225] Resolving globals: TRUE
[13:23:32.225] Resolving any globals that are futures ...
[13:23:32.225] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:32.225] Resolving any globals that are futures ... DONE
[13:23:32.226] Resolving futures part of globals (recursively) ...
[13:23:32.226] resolve() on list ...
[13:23:32.226]  recursive: 99
[13:23:32.226]  length: 2
[13:23:32.226]  elements: ‘a’, ‘ii’
[13:23:32.226]  length: 1 (resolved future 1)
[13:23:32.227]  length: 0 (resolved future 2)
[13:23:32.227] resolve() on list ... DONE
[13:23:32.227] - globals: [2] ‘a’, ‘ii’
[13:23:32.227] Resolving futures part of globals (recursively) ... DONE
[13:23:32.227] The total size of the 2 globals is 112 bytes (112 bytes)
[13:23:32.227] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:23:32.227] - globals: [2] ‘a’, ‘ii’
[13:23:32.228] 
[13:23:32.228] getGlobalsAndPackages() ... DONE
[13:23:32.228] run() for ‘Future’ ...
[13:23:32.228] - state: ‘created’
[13:23:32.228] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.229] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.229] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.229]   - Field: ‘label’
[13:23:32.229]   - Field: ‘local’
[13:23:32.229]   - Field: ‘owner’
[13:23:32.229]   - Field: ‘envir’
[13:23:32.229]   - Field: ‘packages’
[13:23:32.229]   - Field: ‘gc’
[13:23:32.229]   - Field: ‘conditions’
[13:23:32.230]   - Field: ‘expr’
[13:23:32.230]   - Field: ‘uuid’
[13:23:32.230]   - Field: ‘seed’
[13:23:32.230]   - Field: ‘version’
[13:23:32.230]   - Field: ‘result’
[13:23:32.230]   - Field: ‘asynchronous’
[13:23:32.230]   - Field: ‘calls’
[13:23:32.230]   - Field: ‘globals’
[13:23:32.230]   - Field: ‘stdout’
[13:23:32.230]   - Field: ‘earlySignal’
[13:23:32.230]   - Field: ‘lazy’
[13:23:32.231]   - Field: ‘state’
[13:23:32.231] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.231] - Launch lazy future ...
[13:23:32.231] Packages needed by the future expression (n = 0): <none>
[13:23:32.231] Packages needed by future strategies (n = 0): <none>
[13:23:32.232] {
[13:23:32.232]     {
[13:23:32.232]         {
[13:23:32.232]             ...future.startTime <- base::Sys.time()
[13:23:32.232]             {
[13:23:32.232]                 {
[13:23:32.232]                   {
[13:23:32.232]                     base::local({
[13:23:32.232]                       has_future <- base::requireNamespace("future", 
[13:23:32.232]                         quietly = TRUE)
[13:23:32.232]                       if (has_future) {
[13:23:32.232]                         ns <- base::getNamespace("future")
[13:23:32.232]                         version <- ns[[".package"]][["version"]]
[13:23:32.232]                         if (is.null(version)) 
[13:23:32.232]                           version <- utils::packageVersion("future")
[13:23:32.232]                       }
[13:23:32.232]                       else {
[13:23:32.232]                         version <- NULL
[13:23:32.232]                       }
[13:23:32.232]                       if (!has_future || version < "1.8.0") {
[13:23:32.232]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.232]                           "", base::R.version$version.string), 
[13:23:32.232]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:32.232]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.232]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.232]                             "release", "version")], collapse = " "), 
[13:23:32.232]                           hostname = base::Sys.info()[["nodename"]])
[13:23:32.232]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.232]                           info)
[13:23:32.232]                         info <- base::paste(info, collapse = "; ")
[13:23:32.232]                         if (!has_future) {
[13:23:32.232]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.232]                             info)
[13:23:32.232]                         }
[13:23:32.232]                         else {
[13:23:32.232]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.232]                             info, version)
[13:23:32.232]                         }
[13:23:32.232]                         base::stop(msg)
[13:23:32.232]                       }
[13:23:32.232]                     })
[13:23:32.232]                   }
[13:23:32.232]                   options(future.plan = NULL)
[13:23:32.232]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.232]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.232]                 }
[13:23:32.232]                 ...future.workdir <- getwd()
[13:23:32.232]             }
[13:23:32.232]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.232]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.232]         }
[13:23:32.232]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.232]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:32.232]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.232]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.232]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.232]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.232]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.232]             base::names(...future.oldOptions))
[13:23:32.232]     }
[13:23:32.232]     if (FALSE) {
[13:23:32.232]     }
[13:23:32.232]     else {
[13:23:32.232]         if (TRUE) {
[13:23:32.232]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.232]                 open = "w")
[13:23:32.232]         }
[13:23:32.232]         else {
[13:23:32.232]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.232]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.232]         }
[13:23:32.232]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.232]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.232]             base::sink(type = "output", split = FALSE)
[13:23:32.232]             base::close(...future.stdout)
[13:23:32.232]         }, add = TRUE)
[13:23:32.232]     }
[13:23:32.232]     ...future.frame <- base::sys.nframe()
[13:23:32.232]     ...future.conditions <- base::list()
[13:23:32.232]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.232]     if (FALSE) {
[13:23:32.232]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.232]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.232]     }
[13:23:32.232]     ...future.result <- base::tryCatch({
[13:23:32.232]         base::withCallingHandlers({
[13:23:32.232]             ...future.value <- base::withVisible(base::local({
[13:23:32.232]                 b <- a * ii
[13:23:32.232]                 a <- 0
[13:23:32.232]                 b
[13:23:32.232]             }))
[13:23:32.232]             future::FutureResult(value = ...future.value$value, 
[13:23:32.232]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.232]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.232]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.232]                     ...future.globalenv.names))
[13:23:32.232]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.232]         }, condition = base::local({
[13:23:32.232]             c <- base::c
[13:23:32.232]             inherits <- base::inherits
[13:23:32.232]             invokeRestart <- base::invokeRestart
[13:23:32.232]             length <- base::length
[13:23:32.232]             list <- base::list
[13:23:32.232]             seq.int <- base::seq.int
[13:23:32.232]             signalCondition <- base::signalCondition
[13:23:32.232]             sys.calls <- base::sys.calls
[13:23:32.232]             `[[` <- base::`[[`
[13:23:32.232]             `+` <- base::`+`
[13:23:32.232]             `<<-` <- base::`<<-`
[13:23:32.232]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.232]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.232]                   3L)]
[13:23:32.232]             }
[13:23:32.232]             function(cond) {
[13:23:32.232]                 is_error <- inherits(cond, "error")
[13:23:32.232]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.232]                   NULL)
[13:23:32.232]                 if (is_error) {
[13:23:32.232]                   sessionInformation <- function() {
[13:23:32.232]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.232]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.232]                       search = base::search(), system = base::Sys.info())
[13:23:32.232]                   }
[13:23:32.232]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.232]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.232]                     cond$call), session = sessionInformation(), 
[13:23:32.232]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.232]                   signalCondition(cond)
[13:23:32.232]                 }
[13:23:32.232]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.232]                 "immediateCondition"))) {
[13:23:32.232]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.232]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.232]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.232]                   if (TRUE && !signal) {
[13:23:32.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.232]                     {
[13:23:32.232]                       inherits <- base::inherits
[13:23:32.232]                       invokeRestart <- base::invokeRestart
[13:23:32.232]                       is.null <- base::is.null
[13:23:32.232]                       muffled <- FALSE
[13:23:32.232]                       if (inherits(cond, "message")) {
[13:23:32.232]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.232]                         if (muffled) 
[13:23:32.232]                           invokeRestart("muffleMessage")
[13:23:32.232]                       }
[13:23:32.232]                       else if (inherits(cond, "warning")) {
[13:23:32.232]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.232]                         if (muffled) 
[13:23:32.232]                           invokeRestart("muffleWarning")
[13:23:32.232]                       }
[13:23:32.232]                       else if (inherits(cond, "condition")) {
[13:23:32.232]                         if (!is.null(pattern)) {
[13:23:32.232]                           computeRestarts <- base::computeRestarts
[13:23:32.232]                           grepl <- base::grepl
[13:23:32.232]                           restarts <- computeRestarts(cond)
[13:23:32.232]                           for (restart in restarts) {
[13:23:32.232]                             name <- restart$name
[13:23:32.232]                             if (is.null(name)) 
[13:23:32.232]                               next
[13:23:32.232]                             if (!grepl(pattern, name)) 
[13:23:32.232]                               next
[13:23:32.232]                             invokeRestart(restart)
[13:23:32.232]                             muffled <- TRUE
[13:23:32.232]                             break
[13:23:32.232]                           }
[13:23:32.232]                         }
[13:23:32.232]                       }
[13:23:32.232]                       invisible(muffled)
[13:23:32.232]                     }
[13:23:32.232]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.232]                   }
[13:23:32.232]                 }
[13:23:32.232]                 else {
[13:23:32.232]                   if (TRUE) {
[13:23:32.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.232]                     {
[13:23:32.232]                       inherits <- base::inherits
[13:23:32.232]                       invokeRestart <- base::invokeRestart
[13:23:32.232]                       is.null <- base::is.null
[13:23:32.232]                       muffled <- FALSE
[13:23:32.232]                       if (inherits(cond, "message")) {
[13:23:32.232]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.232]                         if (muffled) 
[13:23:32.232]                           invokeRestart("muffleMessage")
[13:23:32.232]                       }
[13:23:32.232]                       else if (inherits(cond, "warning")) {
[13:23:32.232]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.232]                         if (muffled) 
[13:23:32.232]                           invokeRestart("muffleWarning")
[13:23:32.232]                       }
[13:23:32.232]                       else if (inherits(cond, "condition")) {
[13:23:32.232]                         if (!is.null(pattern)) {
[13:23:32.232]                           computeRestarts <- base::computeRestarts
[13:23:32.232]                           grepl <- base::grepl
[13:23:32.232]                           restarts <- computeRestarts(cond)
[13:23:32.232]                           for (restart in restarts) {
[13:23:32.232]                             name <- restart$name
[13:23:32.232]                             if (is.null(name)) 
[13:23:32.232]                               next
[13:23:32.232]                             if (!grepl(pattern, name)) 
[13:23:32.232]                               next
[13:23:32.232]                             invokeRestart(restart)
[13:23:32.232]                             muffled <- TRUE
[13:23:32.232]                             break
[13:23:32.232]                           }
[13:23:32.232]                         }
[13:23:32.232]                       }
[13:23:32.232]                       invisible(muffled)
[13:23:32.232]                     }
[13:23:32.232]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.232]                   }
[13:23:32.232]                 }
[13:23:32.232]             }
[13:23:32.232]         }))
[13:23:32.232]     }, error = function(ex) {
[13:23:32.232]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.232]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.232]                 ...future.rng), started = ...future.startTime, 
[13:23:32.232]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.232]             version = "1.8"), class = "FutureResult")
[13:23:32.232]     }, finally = {
[13:23:32.232]         if (!identical(...future.workdir, getwd())) 
[13:23:32.232]             setwd(...future.workdir)
[13:23:32.232]         {
[13:23:32.232]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.232]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.232]             }
[13:23:32.232]             base::options(...future.oldOptions)
[13:23:32.232]             if (.Platform$OS.type == "windows") {
[13:23:32.232]                 old_names <- names(...future.oldEnvVars)
[13:23:32.232]                 envs <- base::Sys.getenv()
[13:23:32.232]                 names <- names(envs)
[13:23:32.232]                 common <- intersect(names, old_names)
[13:23:32.232]                 added <- setdiff(names, old_names)
[13:23:32.232]                 removed <- setdiff(old_names, names)
[13:23:32.232]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.232]                   envs[common]]
[13:23:32.232]                 NAMES <- toupper(changed)
[13:23:32.232]                 args <- list()
[13:23:32.232]                 for (kk in seq_along(NAMES)) {
[13:23:32.232]                   name <- changed[[kk]]
[13:23:32.232]                   NAME <- NAMES[[kk]]
[13:23:32.232]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.232]                     next
[13:23:32.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.232]                 }
[13:23:32.232]                 NAMES <- toupper(added)
[13:23:32.232]                 for (kk in seq_along(NAMES)) {
[13:23:32.232]                   name <- added[[kk]]
[13:23:32.232]                   NAME <- NAMES[[kk]]
[13:23:32.232]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.232]                     next
[13:23:32.232]                   args[[name]] <- ""
[13:23:32.232]                 }
[13:23:32.232]                 NAMES <- toupper(removed)
[13:23:32.232]                 for (kk in seq_along(NAMES)) {
[13:23:32.232]                   name <- removed[[kk]]
[13:23:32.232]                   NAME <- NAMES[[kk]]
[13:23:32.232]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.232]                     next
[13:23:32.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.232]                 }
[13:23:32.232]                 if (length(args) > 0) 
[13:23:32.232]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.232]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.232]             }
[13:23:32.232]             else {
[13:23:32.232]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.232]             }
[13:23:32.232]             {
[13:23:32.232]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.232]                   0L) {
[13:23:32.232]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.232]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.232]                   base::options(opts)
[13:23:32.232]                 }
[13:23:32.232]                 {
[13:23:32.232]                   {
[13:23:32.232]                     NULL
[13:23:32.232]                     RNGkind("Mersenne-Twister")
[13:23:32.232]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.232]                       inherits = FALSE)
[13:23:32.232]                   }
[13:23:32.232]                   options(future.plan = NULL)
[13:23:32.232]                   if (is.na(NA_character_)) 
[13:23:32.232]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.232]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.232]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.232]                   {
[13:23:32.232]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.232]                     if (!future$lazy) 
[13:23:32.232]                       future <- run(future)
[13:23:32.232]                     invisible(future)
[13:23:32.232]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.232]                 }
[13:23:32.232]             }
[13:23:32.232]         }
[13:23:32.232]     })
[13:23:32.232]     if (TRUE) {
[13:23:32.232]         base::sink(type = "output", split = FALSE)
[13:23:32.232]         if (TRUE) {
[13:23:32.232]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.232]         }
[13:23:32.232]         else {
[13:23:32.232]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.232]         }
[13:23:32.232]         base::close(...future.stdout)
[13:23:32.232]         ...future.stdout <- NULL
[13:23:32.232]     }
[13:23:32.232]     ...future.result$conditions <- ...future.conditions
[13:23:32.232]     ...future.result$finished <- base::Sys.time()
[13:23:32.232]     ...future.result
[13:23:32.232] }
[13:23:32.233] assign_globals() ...
[13:23:32.233] List of 2
[13:23:32.233]  $ a : num 1
[13:23:32.233]  $ ii: int 1
[13:23:32.233]  - attr(*, "where")=List of 2
[13:23:32.233]   ..$ a :<environment: R_EmptyEnv> 
[13:23:32.233]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:32.233]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.233]  - attr(*, "resolved")= logi TRUE
[13:23:32.233]  - attr(*, "total_size")= num 112
[13:23:32.233]  - attr(*, "already-done")= logi TRUE
[13:23:32.237] - copied ‘a’ to environment
[13:23:32.237] - copied ‘ii’ to environment
[13:23:32.237] assign_globals() ... done
[13:23:32.237] plan(): Setting new future strategy stack:
[13:23:32.237] List of future strategies:
[13:23:32.237] 1. sequential:
[13:23:32.237]    - args: function (..., envir = parent.frame())
[13:23:32.237]    - tweaked: FALSE
[13:23:32.237]    - call: NULL
[13:23:32.238] plan(): nbrOfWorkers() = 1
[13:23:32.238] plan(): Setting new future strategy stack:
[13:23:32.239] List of future strategies:
[13:23:32.239] 1. sequential:
[13:23:32.239]    - args: function (..., envir = parent.frame())
[13:23:32.239]    - tweaked: FALSE
[13:23:32.239]    - call: plan(strategy)
[13:23:32.239] plan(): nbrOfWorkers() = 1
[13:23:32.239] SequentialFuture started (and completed)
[13:23:32.239] - Launch lazy future ... done
[13:23:32.239] run() for ‘SequentialFuture’ ... done
[13:23:32.239] run() for ‘Future’ ...
[13:23:32.240] - state: ‘created’
[13:23:32.240] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.240] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.240] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.240]   - Field: ‘label’
[13:23:32.240]   - Field: ‘local’
[13:23:32.240]   - Field: ‘owner’
[13:23:32.241]   - Field: ‘envir’
[13:23:32.241]   - Field: ‘packages’
[13:23:32.241]   - Field: ‘gc’
[13:23:32.241]   - Field: ‘conditions’
[13:23:32.241]   - Field: ‘expr’
[13:23:32.241]   - Field: ‘uuid’
[13:23:32.241]   - Field: ‘seed’
[13:23:32.241]   - Field: ‘version’
[13:23:32.241]   - Field: ‘result’
[13:23:32.241]   - Field: ‘asynchronous’
[13:23:32.241]   - Field: ‘calls’
[13:23:32.242]   - Field: ‘globals’
[13:23:32.242]   - Field: ‘stdout’
[13:23:32.242]   - Field: ‘earlySignal’
[13:23:32.242]   - Field: ‘lazy’
[13:23:32.242]   - Field: ‘state’
[13:23:32.242] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.242] - Launch lazy future ...
[13:23:32.242] Packages needed by the future expression (n = 0): <none>
[13:23:32.242] Packages needed by future strategies (n = 0): <none>
[13:23:32.243] {
[13:23:32.243]     {
[13:23:32.243]         {
[13:23:32.243]             ...future.startTime <- base::Sys.time()
[13:23:32.243]             {
[13:23:32.243]                 {
[13:23:32.243]                   {
[13:23:32.243]                     base::local({
[13:23:32.243]                       has_future <- base::requireNamespace("future", 
[13:23:32.243]                         quietly = TRUE)
[13:23:32.243]                       if (has_future) {
[13:23:32.243]                         ns <- base::getNamespace("future")
[13:23:32.243]                         version <- ns[[".package"]][["version"]]
[13:23:32.243]                         if (is.null(version)) 
[13:23:32.243]                           version <- utils::packageVersion("future")
[13:23:32.243]                       }
[13:23:32.243]                       else {
[13:23:32.243]                         version <- NULL
[13:23:32.243]                       }
[13:23:32.243]                       if (!has_future || version < "1.8.0") {
[13:23:32.243]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.243]                           "", base::R.version$version.string), 
[13:23:32.243]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:32.243]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.243]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.243]                             "release", "version")], collapse = " "), 
[13:23:32.243]                           hostname = base::Sys.info()[["nodename"]])
[13:23:32.243]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.243]                           info)
[13:23:32.243]                         info <- base::paste(info, collapse = "; ")
[13:23:32.243]                         if (!has_future) {
[13:23:32.243]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.243]                             info)
[13:23:32.243]                         }
[13:23:32.243]                         else {
[13:23:32.243]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.243]                             info, version)
[13:23:32.243]                         }
[13:23:32.243]                         base::stop(msg)
[13:23:32.243]                       }
[13:23:32.243]                     })
[13:23:32.243]                   }
[13:23:32.243]                   options(future.plan = NULL)
[13:23:32.243]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.243]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.243]                 }
[13:23:32.243]                 ...future.workdir <- getwd()
[13:23:32.243]             }
[13:23:32.243]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.243]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.243]         }
[13:23:32.243]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.243]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:32.243]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.243]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.243]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.243]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.243]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.243]             base::names(...future.oldOptions))
[13:23:32.243]     }
[13:23:32.243]     if (FALSE) {
[13:23:32.243]     }
[13:23:32.243]     else {
[13:23:32.243]         if (TRUE) {
[13:23:32.243]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.243]                 open = "w")
[13:23:32.243]         }
[13:23:32.243]         else {
[13:23:32.243]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.243]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.243]         }
[13:23:32.243]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.243]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.243]             base::sink(type = "output", split = FALSE)
[13:23:32.243]             base::close(...future.stdout)
[13:23:32.243]         }, add = TRUE)
[13:23:32.243]     }
[13:23:32.243]     ...future.frame <- base::sys.nframe()
[13:23:32.243]     ...future.conditions <- base::list()
[13:23:32.243]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.243]     if (FALSE) {
[13:23:32.243]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.243]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.243]     }
[13:23:32.243]     ...future.result <- base::tryCatch({
[13:23:32.243]         base::withCallingHandlers({
[13:23:32.243]             ...future.value <- base::withVisible(base::local({
[13:23:32.243]                 b <- a * ii
[13:23:32.243]                 a <- 0
[13:23:32.243]                 b
[13:23:32.243]             }))
[13:23:32.243]             future::FutureResult(value = ...future.value$value, 
[13:23:32.243]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.243]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.243]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.243]                     ...future.globalenv.names))
[13:23:32.243]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.243]         }, condition = base::local({
[13:23:32.243]             c <- base::c
[13:23:32.243]             inherits <- base::inherits
[13:23:32.243]             invokeRestart <- base::invokeRestart
[13:23:32.243]             length <- base::length
[13:23:32.243]             list <- base::list
[13:23:32.243]             seq.int <- base::seq.int
[13:23:32.243]             signalCondition <- base::signalCondition
[13:23:32.243]             sys.calls <- base::sys.calls
[13:23:32.243]             `[[` <- base::`[[`
[13:23:32.243]             `+` <- base::`+`
[13:23:32.243]             `<<-` <- base::`<<-`
[13:23:32.243]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.243]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.243]                   3L)]
[13:23:32.243]             }
[13:23:32.243]             function(cond) {
[13:23:32.243]                 is_error <- inherits(cond, "error")
[13:23:32.243]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.243]                   NULL)
[13:23:32.243]                 if (is_error) {
[13:23:32.243]                   sessionInformation <- function() {
[13:23:32.243]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.243]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.243]                       search = base::search(), system = base::Sys.info())
[13:23:32.243]                   }
[13:23:32.243]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.243]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.243]                     cond$call), session = sessionInformation(), 
[13:23:32.243]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.243]                   signalCondition(cond)
[13:23:32.243]                 }
[13:23:32.243]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.243]                 "immediateCondition"))) {
[13:23:32.243]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.243]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.243]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.243]                   if (TRUE && !signal) {
[13:23:32.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.243]                     {
[13:23:32.243]                       inherits <- base::inherits
[13:23:32.243]                       invokeRestart <- base::invokeRestart
[13:23:32.243]                       is.null <- base::is.null
[13:23:32.243]                       muffled <- FALSE
[13:23:32.243]                       if (inherits(cond, "message")) {
[13:23:32.243]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.243]                         if (muffled) 
[13:23:32.243]                           invokeRestart("muffleMessage")
[13:23:32.243]                       }
[13:23:32.243]                       else if (inherits(cond, "warning")) {
[13:23:32.243]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.243]                         if (muffled) 
[13:23:32.243]                           invokeRestart("muffleWarning")
[13:23:32.243]                       }
[13:23:32.243]                       else if (inherits(cond, "condition")) {
[13:23:32.243]                         if (!is.null(pattern)) {
[13:23:32.243]                           computeRestarts <- base::computeRestarts
[13:23:32.243]                           grepl <- base::grepl
[13:23:32.243]                           restarts <- computeRestarts(cond)
[13:23:32.243]                           for (restart in restarts) {
[13:23:32.243]                             name <- restart$name
[13:23:32.243]                             if (is.null(name)) 
[13:23:32.243]                               next
[13:23:32.243]                             if (!grepl(pattern, name)) 
[13:23:32.243]                               next
[13:23:32.243]                             invokeRestart(restart)
[13:23:32.243]                             muffled <- TRUE
[13:23:32.243]                             break
[13:23:32.243]                           }
[13:23:32.243]                         }
[13:23:32.243]                       }
[13:23:32.243]                       invisible(muffled)
[13:23:32.243]                     }
[13:23:32.243]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.243]                   }
[13:23:32.243]                 }
[13:23:32.243]                 else {
[13:23:32.243]                   if (TRUE) {
[13:23:32.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.243]                     {
[13:23:32.243]                       inherits <- base::inherits
[13:23:32.243]                       invokeRestart <- base::invokeRestart
[13:23:32.243]                       is.null <- base::is.null
[13:23:32.243]                       muffled <- FALSE
[13:23:32.243]                       if (inherits(cond, "message")) {
[13:23:32.243]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.243]                         if (muffled) 
[13:23:32.243]                           invokeRestart("muffleMessage")
[13:23:32.243]                       }
[13:23:32.243]                       else if (inherits(cond, "warning")) {
[13:23:32.243]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.243]                         if (muffled) 
[13:23:32.243]                           invokeRestart("muffleWarning")
[13:23:32.243]                       }
[13:23:32.243]                       else if (inherits(cond, "condition")) {
[13:23:32.243]                         if (!is.null(pattern)) {
[13:23:32.243]                           computeRestarts <- base::computeRestarts
[13:23:32.243]                           grepl <- base::grepl
[13:23:32.243]                           restarts <- computeRestarts(cond)
[13:23:32.243]                           for (restart in restarts) {
[13:23:32.243]                             name <- restart$name
[13:23:32.243]                             if (is.null(name)) 
[13:23:32.243]                               next
[13:23:32.243]                             if (!grepl(pattern, name)) 
[13:23:32.243]                               next
[13:23:32.243]                             invokeRestart(restart)
[13:23:32.243]                             muffled <- TRUE
[13:23:32.243]                             break
[13:23:32.243]                           }
[13:23:32.243]                         }
[13:23:32.243]                       }
[13:23:32.243]                       invisible(muffled)
[13:23:32.243]                     }
[13:23:32.243]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.243]                   }
[13:23:32.243]                 }
[13:23:32.243]             }
[13:23:32.243]         }))
[13:23:32.243]     }, error = function(ex) {
[13:23:32.243]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.243]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.243]                 ...future.rng), started = ...future.startTime, 
[13:23:32.243]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.243]             version = "1.8"), class = "FutureResult")
[13:23:32.243]     }, finally = {
[13:23:32.243]         if (!identical(...future.workdir, getwd())) 
[13:23:32.243]             setwd(...future.workdir)
[13:23:32.243]         {
[13:23:32.243]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.243]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.243]             }
[13:23:32.243]             base::options(...future.oldOptions)
[13:23:32.243]             if (.Platform$OS.type == "windows") {
[13:23:32.243]                 old_names <- names(...future.oldEnvVars)
[13:23:32.243]                 envs <- base::Sys.getenv()
[13:23:32.243]                 names <- names(envs)
[13:23:32.243]                 common <- intersect(names, old_names)
[13:23:32.243]                 added <- setdiff(names, old_names)
[13:23:32.243]                 removed <- setdiff(old_names, names)
[13:23:32.243]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.243]                   envs[common]]
[13:23:32.243]                 NAMES <- toupper(changed)
[13:23:32.243]                 args <- list()
[13:23:32.243]                 for (kk in seq_along(NAMES)) {
[13:23:32.243]                   name <- changed[[kk]]
[13:23:32.243]                   NAME <- NAMES[[kk]]
[13:23:32.243]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.243]                     next
[13:23:32.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.243]                 }
[13:23:32.243]                 NAMES <- toupper(added)
[13:23:32.243]                 for (kk in seq_along(NAMES)) {
[13:23:32.243]                   name <- added[[kk]]
[13:23:32.243]                   NAME <- NAMES[[kk]]
[13:23:32.243]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.243]                     next
[13:23:32.243]                   args[[name]] <- ""
[13:23:32.243]                 }
[13:23:32.243]                 NAMES <- toupper(removed)
[13:23:32.243]                 for (kk in seq_along(NAMES)) {
[13:23:32.243]                   name <- removed[[kk]]
[13:23:32.243]                   NAME <- NAMES[[kk]]
[13:23:32.243]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.243]                     next
[13:23:32.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.243]                 }
[13:23:32.243]                 if (length(args) > 0) 
[13:23:32.243]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.243]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.243]             }
[13:23:32.243]             else {
[13:23:32.243]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.243]             }
[13:23:32.243]             {
[13:23:32.243]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.243]                   0L) {
[13:23:32.243]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.243]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.243]                   base::options(opts)
[13:23:32.243]                 }
[13:23:32.243]                 {
[13:23:32.243]                   {
[13:23:32.243]                     NULL
[13:23:32.243]                     RNGkind("Mersenne-Twister")
[13:23:32.243]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.243]                       inherits = FALSE)
[13:23:32.243]                   }
[13:23:32.243]                   options(future.plan = NULL)
[13:23:32.243]                   if (is.na(NA_character_)) 
[13:23:32.243]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.243]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.243]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.243]                   {
[13:23:32.243]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.243]                     if (!future$lazy) 
[13:23:32.243]                       future <- run(future)
[13:23:32.243]                     invisible(future)
[13:23:32.243]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.243]                 }
[13:23:32.243]             }
[13:23:32.243]         }
[13:23:32.243]     })
[13:23:32.243]     if (TRUE) {
[13:23:32.243]         base::sink(type = "output", split = FALSE)
[13:23:32.243]         if (TRUE) {
[13:23:32.243]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.243]         }
[13:23:32.243]         else {
[13:23:32.243]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.243]         }
[13:23:32.243]         base::close(...future.stdout)
[13:23:32.243]         ...future.stdout <- NULL
[13:23:32.243]     }
[13:23:32.243]     ...future.result$conditions <- ...future.conditions
[13:23:32.243]     ...future.result$finished <- base::Sys.time()
[13:23:32.243]     ...future.result
[13:23:32.243] }
[13:23:32.245] assign_globals() ...
[13:23:32.245] List of 2
[13:23:32.245]  $ a : num 1
[13:23:32.245]  $ ii: int 2
[13:23:32.245]  - attr(*, "where")=List of 2
[13:23:32.245]   ..$ a :<environment: R_EmptyEnv> 
[13:23:32.245]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:32.245]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.245]  - attr(*, "resolved")= logi TRUE
[13:23:32.245]  - attr(*, "total_size")= num 112
[13:23:32.245]  - attr(*, "already-done")= logi TRUE
[13:23:32.250] - copied ‘a’ to environment
[13:23:32.250] - copied ‘ii’ to environment
[13:23:32.251] assign_globals() ... done
[13:23:32.251] plan(): Setting new future strategy stack:
[13:23:32.251] List of future strategies:
[13:23:32.251] 1. sequential:
[13:23:32.251]    - args: function (..., envir = parent.frame())
[13:23:32.251]    - tweaked: FALSE
[13:23:32.251]    - call: NULL
[13:23:32.251] plan(): nbrOfWorkers() = 1
[13:23:32.252] plan(): Setting new future strategy stack:
[13:23:32.252] List of future strategies:
[13:23:32.252] 1. sequential:
[13:23:32.252]    - args: function (..., envir = parent.frame())
[13:23:32.252]    - tweaked: FALSE
[13:23:32.252]    - call: plan(strategy)
[13:23:32.253] plan(): nbrOfWorkers() = 1
[13:23:32.253] SequentialFuture started (and completed)
[13:23:32.253] - Launch lazy future ... done
[13:23:32.253] run() for ‘SequentialFuture’ ... done
[13:23:32.253] run() for ‘Future’ ...
[13:23:32.253] - state: ‘created’
[13:23:32.254] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.254] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.254] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.254]   - Field: ‘label’
[13:23:32.254]   - Field: ‘local’
[13:23:32.254]   - Field: ‘owner’
[13:23:32.254]   - Field: ‘envir’
[13:23:32.254]   - Field: ‘packages’
[13:23:32.255]   - Field: ‘gc’
[13:23:32.255]   - Field: ‘conditions’
[13:23:32.255]   - Field: ‘expr’
[13:23:32.255]   - Field: ‘uuid’
[13:23:32.255]   - Field: ‘seed’
[13:23:32.255]   - Field: ‘version’
[13:23:32.255]   - Field: ‘result’
[13:23:32.255]   - Field: ‘asynchronous’
[13:23:32.255]   - Field: ‘calls’
[13:23:32.255]   - Field: ‘globals’
[13:23:32.256]   - Field: ‘stdout’
[13:23:32.256]   - Field: ‘earlySignal’
[13:23:32.256]   - Field: ‘lazy’
[13:23:32.256]   - Field: ‘state’
[13:23:32.256] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.256] - Launch lazy future ...
[13:23:32.256] Packages needed by the future expression (n = 0): <none>
[13:23:32.256] Packages needed by future strategies (n = 0): <none>
[13:23:32.257] {
[13:23:32.257]     {
[13:23:32.257]         {
[13:23:32.257]             ...future.startTime <- base::Sys.time()
[13:23:32.257]             {
[13:23:32.257]                 {
[13:23:32.257]                   {
[13:23:32.257]                     base::local({
[13:23:32.257]                       has_future <- base::requireNamespace("future", 
[13:23:32.257]                         quietly = TRUE)
[13:23:32.257]                       if (has_future) {
[13:23:32.257]                         ns <- base::getNamespace("future")
[13:23:32.257]                         version <- ns[[".package"]][["version"]]
[13:23:32.257]                         if (is.null(version)) 
[13:23:32.257]                           version <- utils::packageVersion("future")
[13:23:32.257]                       }
[13:23:32.257]                       else {
[13:23:32.257]                         version <- NULL
[13:23:32.257]                       }
[13:23:32.257]                       if (!has_future || version < "1.8.0") {
[13:23:32.257]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.257]                           "", base::R.version$version.string), 
[13:23:32.257]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:32.257]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.257]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.257]                             "release", "version")], collapse = " "), 
[13:23:32.257]                           hostname = base::Sys.info()[["nodename"]])
[13:23:32.257]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.257]                           info)
[13:23:32.257]                         info <- base::paste(info, collapse = "; ")
[13:23:32.257]                         if (!has_future) {
[13:23:32.257]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.257]                             info)
[13:23:32.257]                         }
[13:23:32.257]                         else {
[13:23:32.257]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.257]                             info, version)
[13:23:32.257]                         }
[13:23:32.257]                         base::stop(msg)
[13:23:32.257]                       }
[13:23:32.257]                     })
[13:23:32.257]                   }
[13:23:32.257]                   options(future.plan = NULL)
[13:23:32.257]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.257]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.257]                 }
[13:23:32.257]                 ...future.workdir <- getwd()
[13:23:32.257]             }
[13:23:32.257]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.257]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.257]         }
[13:23:32.257]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.257]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:32.257]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.257]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.257]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.257]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.257]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.257]             base::names(...future.oldOptions))
[13:23:32.257]     }
[13:23:32.257]     if (FALSE) {
[13:23:32.257]     }
[13:23:32.257]     else {
[13:23:32.257]         if (TRUE) {
[13:23:32.257]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.257]                 open = "w")
[13:23:32.257]         }
[13:23:32.257]         else {
[13:23:32.257]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.257]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.257]         }
[13:23:32.257]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.257]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.257]             base::sink(type = "output", split = FALSE)
[13:23:32.257]             base::close(...future.stdout)
[13:23:32.257]         }, add = TRUE)
[13:23:32.257]     }
[13:23:32.257]     ...future.frame <- base::sys.nframe()
[13:23:32.257]     ...future.conditions <- base::list()
[13:23:32.257]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.257]     if (FALSE) {
[13:23:32.257]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.257]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.257]     }
[13:23:32.257]     ...future.result <- base::tryCatch({
[13:23:32.257]         base::withCallingHandlers({
[13:23:32.257]             ...future.value <- base::withVisible(base::local({
[13:23:32.257]                 b <- a * ii
[13:23:32.257]                 a <- 0
[13:23:32.257]                 b
[13:23:32.257]             }))
[13:23:32.257]             future::FutureResult(value = ...future.value$value, 
[13:23:32.257]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.257]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.257]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.257]                     ...future.globalenv.names))
[13:23:32.257]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.257]         }, condition = base::local({
[13:23:32.257]             c <- base::c
[13:23:32.257]             inherits <- base::inherits
[13:23:32.257]             invokeRestart <- base::invokeRestart
[13:23:32.257]             length <- base::length
[13:23:32.257]             list <- base::list
[13:23:32.257]             seq.int <- base::seq.int
[13:23:32.257]             signalCondition <- base::signalCondition
[13:23:32.257]             sys.calls <- base::sys.calls
[13:23:32.257]             `[[` <- base::`[[`
[13:23:32.257]             `+` <- base::`+`
[13:23:32.257]             `<<-` <- base::`<<-`
[13:23:32.257]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.257]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.257]                   3L)]
[13:23:32.257]             }
[13:23:32.257]             function(cond) {
[13:23:32.257]                 is_error <- inherits(cond, "error")
[13:23:32.257]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.257]                   NULL)
[13:23:32.257]                 if (is_error) {
[13:23:32.257]                   sessionInformation <- function() {
[13:23:32.257]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.257]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.257]                       search = base::search(), system = base::Sys.info())
[13:23:32.257]                   }
[13:23:32.257]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.257]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.257]                     cond$call), session = sessionInformation(), 
[13:23:32.257]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.257]                   signalCondition(cond)
[13:23:32.257]                 }
[13:23:32.257]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.257]                 "immediateCondition"))) {
[13:23:32.257]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.257]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.257]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.257]                   if (TRUE && !signal) {
[13:23:32.257]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.257]                     {
[13:23:32.257]                       inherits <- base::inherits
[13:23:32.257]                       invokeRestart <- base::invokeRestart
[13:23:32.257]                       is.null <- base::is.null
[13:23:32.257]                       muffled <- FALSE
[13:23:32.257]                       if (inherits(cond, "message")) {
[13:23:32.257]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.257]                         if (muffled) 
[13:23:32.257]                           invokeRestart("muffleMessage")
[13:23:32.257]                       }
[13:23:32.257]                       else if (inherits(cond, "warning")) {
[13:23:32.257]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.257]                         if (muffled) 
[13:23:32.257]                           invokeRestart("muffleWarning")
[13:23:32.257]                       }
[13:23:32.257]                       else if (inherits(cond, "condition")) {
[13:23:32.257]                         if (!is.null(pattern)) {
[13:23:32.257]                           computeRestarts <- base::computeRestarts
[13:23:32.257]                           grepl <- base::grepl
[13:23:32.257]                           restarts <- computeRestarts(cond)
[13:23:32.257]                           for (restart in restarts) {
[13:23:32.257]                             name <- restart$name
[13:23:32.257]                             if (is.null(name)) 
[13:23:32.257]                               next
[13:23:32.257]                             if (!grepl(pattern, name)) 
[13:23:32.257]                               next
[13:23:32.257]                             invokeRestart(restart)
[13:23:32.257]                             muffled <- TRUE
[13:23:32.257]                             break
[13:23:32.257]                           }
[13:23:32.257]                         }
[13:23:32.257]                       }
[13:23:32.257]                       invisible(muffled)
[13:23:32.257]                     }
[13:23:32.257]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.257]                   }
[13:23:32.257]                 }
[13:23:32.257]                 else {
[13:23:32.257]                   if (TRUE) {
[13:23:32.257]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.257]                     {
[13:23:32.257]                       inherits <- base::inherits
[13:23:32.257]                       invokeRestart <- base::invokeRestart
[13:23:32.257]                       is.null <- base::is.null
[13:23:32.257]                       muffled <- FALSE
[13:23:32.257]                       if (inherits(cond, "message")) {
[13:23:32.257]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.257]                         if (muffled) 
[13:23:32.257]                           invokeRestart("muffleMessage")
[13:23:32.257]                       }
[13:23:32.257]                       else if (inherits(cond, "warning")) {
[13:23:32.257]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.257]                         if (muffled) 
[13:23:32.257]                           invokeRestart("muffleWarning")
[13:23:32.257]                       }
[13:23:32.257]                       else if (inherits(cond, "condition")) {
[13:23:32.257]                         if (!is.null(pattern)) {
[13:23:32.257]                           computeRestarts <- base::computeRestarts
[13:23:32.257]                           grepl <- base::grepl
[13:23:32.257]                           restarts <- computeRestarts(cond)
[13:23:32.257]                           for (restart in restarts) {
[13:23:32.257]                             name <- restart$name
[13:23:32.257]                             if (is.null(name)) 
[13:23:32.257]                               next
[13:23:32.257]                             if (!grepl(pattern, name)) 
[13:23:32.257]                               next
[13:23:32.257]                             invokeRestart(restart)
[13:23:32.257]                             muffled <- TRUE
[13:23:32.257]                             break
[13:23:32.257]                           }
[13:23:32.257]                         }
[13:23:32.257]                       }
[13:23:32.257]                       invisible(muffled)
[13:23:32.257]                     }
[13:23:32.257]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.257]                   }
[13:23:32.257]                 }
[13:23:32.257]             }
[13:23:32.257]         }))
[13:23:32.257]     }, error = function(ex) {
[13:23:32.257]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.257]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.257]                 ...future.rng), started = ...future.startTime, 
[13:23:32.257]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.257]             version = "1.8"), class = "FutureResult")
[13:23:32.257]     }, finally = {
[13:23:32.257]         if (!identical(...future.workdir, getwd())) 
[13:23:32.257]             setwd(...future.workdir)
[13:23:32.257]         {
[13:23:32.257]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.257]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.257]             }
[13:23:32.257]             base::options(...future.oldOptions)
[13:23:32.257]             if (.Platform$OS.type == "windows") {
[13:23:32.257]                 old_names <- names(...future.oldEnvVars)
[13:23:32.257]                 envs <- base::Sys.getenv()
[13:23:32.257]                 names <- names(envs)
[13:23:32.257]                 common <- intersect(names, old_names)
[13:23:32.257]                 added <- setdiff(names, old_names)
[13:23:32.257]                 removed <- setdiff(old_names, names)
[13:23:32.257]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.257]                   envs[common]]
[13:23:32.257]                 NAMES <- toupper(changed)
[13:23:32.257]                 args <- list()
[13:23:32.257]                 for (kk in seq_along(NAMES)) {
[13:23:32.257]                   name <- changed[[kk]]
[13:23:32.257]                   NAME <- NAMES[[kk]]
[13:23:32.257]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.257]                     next
[13:23:32.257]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.257]                 }
[13:23:32.257]                 NAMES <- toupper(added)
[13:23:32.257]                 for (kk in seq_along(NAMES)) {
[13:23:32.257]                   name <- added[[kk]]
[13:23:32.257]                   NAME <- NAMES[[kk]]
[13:23:32.257]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.257]                     next
[13:23:32.257]                   args[[name]] <- ""
[13:23:32.257]                 }
[13:23:32.257]                 NAMES <- toupper(removed)
[13:23:32.257]                 for (kk in seq_along(NAMES)) {
[13:23:32.257]                   name <- removed[[kk]]
[13:23:32.257]                   NAME <- NAMES[[kk]]
[13:23:32.257]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.257]                     next
[13:23:32.257]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.257]                 }
[13:23:32.257]                 if (length(args) > 0) 
[13:23:32.257]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.257]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.257]             }
[13:23:32.257]             else {
[13:23:32.257]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.257]             }
[13:23:32.257]             {
[13:23:32.257]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.257]                   0L) {
[13:23:32.257]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.257]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.257]                   base::options(opts)
[13:23:32.257]                 }
[13:23:32.257]                 {
[13:23:32.257]                   {
[13:23:32.257]                     NULL
[13:23:32.257]                     RNGkind("Mersenne-Twister")
[13:23:32.257]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.257]                       inherits = FALSE)
[13:23:32.257]                   }
[13:23:32.257]                   options(future.plan = NULL)
[13:23:32.257]                   if (is.na(NA_character_)) 
[13:23:32.257]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.257]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.257]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.257]                   {
[13:23:32.257]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.257]                     if (!future$lazy) 
[13:23:32.257]                       future <- run(future)
[13:23:32.257]                     invisible(future)
[13:23:32.257]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.257]                 }
[13:23:32.257]             }
[13:23:32.257]         }
[13:23:32.257]     })
[13:23:32.257]     if (TRUE) {
[13:23:32.257]         base::sink(type = "output", split = FALSE)
[13:23:32.257]         if (TRUE) {
[13:23:32.257]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.257]         }
[13:23:32.257]         else {
[13:23:32.257]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.257]         }
[13:23:32.257]         base::close(...future.stdout)
[13:23:32.257]         ...future.stdout <- NULL
[13:23:32.257]     }
[13:23:32.257]     ...future.result$conditions <- ...future.conditions
[13:23:32.257]     ...future.result$finished <- base::Sys.time()
[13:23:32.257]     ...future.result
[13:23:32.257] }
[13:23:32.258] assign_globals() ...
[13:23:32.259] List of 2
[13:23:32.259]  $ a : num 1
[13:23:32.259]  $ ii: int 3
[13:23:32.259]  - attr(*, "where")=List of 2
[13:23:32.259]   ..$ a :<environment: R_EmptyEnv> 
[13:23:32.259]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:32.259]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.259]  - attr(*, "resolved")= logi TRUE
[13:23:32.259]  - attr(*, "total_size")= num 112
[13:23:32.259]  - attr(*, "already-done")= logi TRUE
[13:23:32.262] - copied ‘a’ to environment
[13:23:32.262] - copied ‘ii’ to environment
[13:23:32.262] assign_globals() ... done
[13:23:32.262] plan(): Setting new future strategy stack:
[13:23:32.262] List of future strategies:
[13:23:32.262] 1. sequential:
[13:23:32.262]    - args: function (..., envir = parent.frame())
[13:23:32.262]    - tweaked: FALSE
[13:23:32.262]    - call: NULL
[13:23:32.263] plan(): nbrOfWorkers() = 1
[13:23:32.264] plan(): Setting new future strategy stack:
[13:23:32.264] List of future strategies:
[13:23:32.264] 1. sequential:
[13:23:32.264]    - args: function (..., envir = parent.frame())
[13:23:32.264]    - tweaked: FALSE
[13:23:32.264]    - call: plan(strategy)
[13:23:32.264] plan(): nbrOfWorkers() = 1
[13:23:32.264] SequentialFuture started (and completed)
[13:23:32.264] - Launch lazy future ... done
[13:23:32.265] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.265] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.265] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:32.266] 
[13:23:32.266] Searching for globals ... DONE
[13:23:32.266] - globals: [0] <none>
[13:23:32.266] getGlobalsAndPackages() ... DONE
[13:23:32.266] run() for ‘Future’ ...
[13:23:32.266] - state: ‘created’
[13:23:32.266] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.267] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.267] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.267]   - Field: ‘label’
[13:23:32.267]   - Field: ‘local’
[13:23:32.267]   - Field: ‘owner’
[13:23:32.267]   - Field: ‘envir’
[13:23:32.267]   - Field: ‘packages’
[13:23:32.267]   - Field: ‘gc’
[13:23:32.267]   - Field: ‘conditions’
[13:23:32.267]   - Field: ‘expr’
[13:23:32.268]   - Field: ‘uuid’
[13:23:32.268]   - Field: ‘seed’
[13:23:32.268]   - Field: ‘version’
[13:23:32.268]   - Field: ‘result’
[13:23:32.268]   - Field: ‘asynchronous’
[13:23:32.268]   - Field: ‘calls’
[13:23:32.268]   - Field: ‘globals’
[13:23:32.268]   - Field: ‘stdout’
[13:23:32.268]   - Field: ‘earlySignal’
[13:23:32.268]   - Field: ‘lazy’
[13:23:32.269]   - Field: ‘state’
[13:23:32.269] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.269] - Launch lazy future ...
[13:23:32.269] Packages needed by the future expression (n = 0): <none>
[13:23:32.269] Packages needed by future strategies (n = 0): <none>
[13:23:32.269] {
[13:23:32.269]     {
[13:23:32.269]         {
[13:23:32.269]             ...future.startTime <- base::Sys.time()
[13:23:32.269]             {
[13:23:32.269]                 {
[13:23:32.269]                   {
[13:23:32.269]                     base::local({
[13:23:32.269]                       has_future <- base::requireNamespace("future", 
[13:23:32.269]                         quietly = TRUE)
[13:23:32.269]                       if (has_future) {
[13:23:32.269]                         ns <- base::getNamespace("future")
[13:23:32.269]                         version <- ns[[".package"]][["version"]]
[13:23:32.269]                         if (is.null(version)) 
[13:23:32.269]                           version <- utils::packageVersion("future")
[13:23:32.269]                       }
[13:23:32.269]                       else {
[13:23:32.269]                         version <- NULL
[13:23:32.269]                       }
[13:23:32.269]                       if (!has_future || version < "1.8.0") {
[13:23:32.269]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.269]                           "", base::R.version$version.string), 
[13:23:32.269]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:32.269]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.269]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.269]                             "release", "version")], collapse = " "), 
[13:23:32.269]                           hostname = base::Sys.info()[["nodename"]])
[13:23:32.269]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.269]                           info)
[13:23:32.269]                         info <- base::paste(info, collapse = "; ")
[13:23:32.269]                         if (!has_future) {
[13:23:32.269]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.269]                             info)
[13:23:32.269]                         }
[13:23:32.269]                         else {
[13:23:32.269]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.269]                             info, version)
[13:23:32.269]                         }
[13:23:32.269]                         base::stop(msg)
[13:23:32.269]                       }
[13:23:32.269]                     })
[13:23:32.269]                   }
[13:23:32.269]                   options(future.plan = NULL)
[13:23:32.269]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.269]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.269]                 }
[13:23:32.269]                 ...future.workdir <- getwd()
[13:23:32.269]             }
[13:23:32.269]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.269]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.269]         }
[13:23:32.269]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.269]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:32.269]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.269]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.269]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.269]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.269]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.269]             base::names(...future.oldOptions))
[13:23:32.269]     }
[13:23:32.269]     if (FALSE) {
[13:23:32.269]     }
[13:23:32.269]     else {
[13:23:32.269]         if (TRUE) {
[13:23:32.269]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.269]                 open = "w")
[13:23:32.269]         }
[13:23:32.269]         else {
[13:23:32.269]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.269]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.269]         }
[13:23:32.269]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.269]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.269]             base::sink(type = "output", split = FALSE)
[13:23:32.269]             base::close(...future.stdout)
[13:23:32.269]         }, add = TRUE)
[13:23:32.269]     }
[13:23:32.269]     ...future.frame <- base::sys.nframe()
[13:23:32.269]     ...future.conditions <- base::list()
[13:23:32.269]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.269]     if (FALSE) {
[13:23:32.269]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.269]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.269]     }
[13:23:32.269]     ...future.result <- base::tryCatch({
[13:23:32.269]         base::withCallingHandlers({
[13:23:32.269]             ...future.value <- base::withVisible(base::local(1))
[13:23:32.269]             future::FutureResult(value = ...future.value$value, 
[13:23:32.269]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.269]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.269]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.269]                     ...future.globalenv.names))
[13:23:32.269]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.269]         }, condition = base::local({
[13:23:32.269]             c <- base::c
[13:23:32.269]             inherits <- base::inherits
[13:23:32.269]             invokeRestart <- base::invokeRestart
[13:23:32.269]             length <- base::length
[13:23:32.269]             list <- base::list
[13:23:32.269]             seq.int <- base::seq.int
[13:23:32.269]             signalCondition <- base::signalCondition
[13:23:32.269]             sys.calls <- base::sys.calls
[13:23:32.269]             `[[` <- base::`[[`
[13:23:32.269]             `+` <- base::`+`
[13:23:32.269]             `<<-` <- base::`<<-`
[13:23:32.269]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.269]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.269]                   3L)]
[13:23:32.269]             }
[13:23:32.269]             function(cond) {
[13:23:32.269]                 is_error <- inherits(cond, "error")
[13:23:32.269]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.269]                   NULL)
[13:23:32.269]                 if (is_error) {
[13:23:32.269]                   sessionInformation <- function() {
[13:23:32.269]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.269]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.269]                       search = base::search(), system = base::Sys.info())
[13:23:32.269]                   }
[13:23:32.269]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.269]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.269]                     cond$call), session = sessionInformation(), 
[13:23:32.269]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.269]                   signalCondition(cond)
[13:23:32.269]                 }
[13:23:32.269]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.269]                 "immediateCondition"))) {
[13:23:32.269]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.269]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.269]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.269]                   if (TRUE && !signal) {
[13:23:32.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.269]                     {
[13:23:32.269]                       inherits <- base::inherits
[13:23:32.269]                       invokeRestart <- base::invokeRestart
[13:23:32.269]                       is.null <- base::is.null
[13:23:32.269]                       muffled <- FALSE
[13:23:32.269]                       if (inherits(cond, "message")) {
[13:23:32.269]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.269]                         if (muffled) 
[13:23:32.269]                           invokeRestart("muffleMessage")
[13:23:32.269]                       }
[13:23:32.269]                       else if (inherits(cond, "warning")) {
[13:23:32.269]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.269]                         if (muffled) 
[13:23:32.269]                           invokeRestart("muffleWarning")
[13:23:32.269]                       }
[13:23:32.269]                       else if (inherits(cond, "condition")) {
[13:23:32.269]                         if (!is.null(pattern)) {
[13:23:32.269]                           computeRestarts <- base::computeRestarts
[13:23:32.269]                           grepl <- base::grepl
[13:23:32.269]                           restarts <- computeRestarts(cond)
[13:23:32.269]                           for (restart in restarts) {
[13:23:32.269]                             name <- restart$name
[13:23:32.269]                             if (is.null(name)) 
[13:23:32.269]                               next
[13:23:32.269]                             if (!grepl(pattern, name)) 
[13:23:32.269]                               next
[13:23:32.269]                             invokeRestart(restart)
[13:23:32.269]                             muffled <- TRUE
[13:23:32.269]                             break
[13:23:32.269]                           }
[13:23:32.269]                         }
[13:23:32.269]                       }
[13:23:32.269]                       invisible(muffled)
[13:23:32.269]                     }
[13:23:32.269]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.269]                   }
[13:23:32.269]                 }
[13:23:32.269]                 else {
[13:23:32.269]                   if (TRUE) {
[13:23:32.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.269]                     {
[13:23:32.269]                       inherits <- base::inherits
[13:23:32.269]                       invokeRestart <- base::invokeRestart
[13:23:32.269]                       is.null <- base::is.null
[13:23:32.269]                       muffled <- FALSE
[13:23:32.269]                       if (inherits(cond, "message")) {
[13:23:32.269]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.269]                         if (muffled) 
[13:23:32.269]                           invokeRestart("muffleMessage")
[13:23:32.269]                       }
[13:23:32.269]                       else if (inherits(cond, "warning")) {
[13:23:32.269]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.269]                         if (muffled) 
[13:23:32.269]                           invokeRestart("muffleWarning")
[13:23:32.269]                       }
[13:23:32.269]                       else if (inherits(cond, "condition")) {
[13:23:32.269]                         if (!is.null(pattern)) {
[13:23:32.269]                           computeRestarts <- base::computeRestarts
[13:23:32.269]                           grepl <- base::grepl
[13:23:32.269]                           restarts <- computeRestarts(cond)
[13:23:32.269]                           for (restart in restarts) {
[13:23:32.269]                             name <- restart$name
[13:23:32.269]                             if (is.null(name)) 
[13:23:32.269]                               next
[13:23:32.269]                             if (!grepl(pattern, name)) 
[13:23:32.269]                               next
[13:23:32.269]                             invokeRestart(restart)
[13:23:32.269]                             muffled <- TRUE
[13:23:32.269]                             break
[13:23:32.269]                           }
[13:23:32.269]                         }
[13:23:32.269]                       }
[13:23:32.269]                       invisible(muffled)
[13:23:32.269]                     }
[13:23:32.269]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.269]                   }
[13:23:32.269]                 }
[13:23:32.269]             }
[13:23:32.269]         }))
[13:23:32.269]     }, error = function(ex) {
[13:23:32.269]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.269]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.269]                 ...future.rng), started = ...future.startTime, 
[13:23:32.269]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.269]             version = "1.8"), class = "FutureResult")
[13:23:32.269]     }, finally = {
[13:23:32.269]         if (!identical(...future.workdir, getwd())) 
[13:23:32.269]             setwd(...future.workdir)
[13:23:32.269]         {
[13:23:32.269]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.269]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.269]             }
[13:23:32.269]             base::options(...future.oldOptions)
[13:23:32.269]             if (.Platform$OS.type == "windows") {
[13:23:32.269]                 old_names <- names(...future.oldEnvVars)
[13:23:32.269]                 envs <- base::Sys.getenv()
[13:23:32.269]                 names <- names(envs)
[13:23:32.269]                 common <- intersect(names, old_names)
[13:23:32.269]                 added <- setdiff(names, old_names)
[13:23:32.269]                 removed <- setdiff(old_names, names)
[13:23:32.269]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.269]                   envs[common]]
[13:23:32.269]                 NAMES <- toupper(changed)
[13:23:32.269]                 args <- list()
[13:23:32.269]                 for (kk in seq_along(NAMES)) {
[13:23:32.269]                   name <- changed[[kk]]
[13:23:32.269]                   NAME <- NAMES[[kk]]
[13:23:32.269]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.269]                     next
[13:23:32.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.269]                 }
[13:23:32.269]                 NAMES <- toupper(added)
[13:23:32.269]                 for (kk in seq_along(NAMES)) {
[13:23:32.269]                   name <- added[[kk]]
[13:23:32.269]                   NAME <- NAMES[[kk]]
[13:23:32.269]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.269]                     next
[13:23:32.269]                   args[[name]] <- ""
[13:23:32.269]                 }
[13:23:32.269]                 NAMES <- toupper(removed)
[13:23:32.269]                 for (kk in seq_along(NAMES)) {
[13:23:32.269]                   name <- removed[[kk]]
[13:23:32.269]                   NAME <- NAMES[[kk]]
[13:23:32.269]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.269]                     next
[13:23:32.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.269]                 }
[13:23:32.269]                 if (length(args) > 0) 
[13:23:32.269]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.269]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.269]             }
[13:23:32.269]             else {
[13:23:32.269]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.269]             }
[13:23:32.269]             {
[13:23:32.269]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.269]                   0L) {
[13:23:32.269]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.269]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.269]                   base::options(opts)
[13:23:32.269]                 }
[13:23:32.269]                 {
[13:23:32.269]                   {
[13:23:32.269]                     NULL
[13:23:32.269]                     RNGkind("Mersenne-Twister")
[13:23:32.269]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.269]                       inherits = FALSE)
[13:23:32.269]                   }
[13:23:32.269]                   options(future.plan = NULL)
[13:23:32.269]                   if (is.na(NA_character_)) 
[13:23:32.269]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.269]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.269]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.269]                   {
[13:23:32.269]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.269]                     if (!future$lazy) 
[13:23:32.269]                       future <- run(future)
[13:23:32.269]                     invisible(future)
[13:23:32.269]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.269]                 }
[13:23:32.269]             }
[13:23:32.269]         }
[13:23:32.269]     })
[13:23:32.269]     if (TRUE) {
[13:23:32.269]         base::sink(type = "output", split = FALSE)
[13:23:32.269]         if (TRUE) {
[13:23:32.269]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.269]         }
[13:23:32.269]         else {
[13:23:32.269]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.269]         }
[13:23:32.269]         base::close(...future.stdout)
[13:23:32.269]         ...future.stdout <- NULL
[13:23:32.269]     }
[13:23:32.269]     ...future.result$conditions <- ...future.conditions
[13:23:32.269]     ...future.result$finished <- base::Sys.time()
[13:23:32.269]     ...future.result
[13:23:32.269] }
[13:23:32.271] plan(): Setting new future strategy stack:
[13:23:32.271] List of future strategies:
[13:23:32.271] 1. sequential:
[13:23:32.271]    - args: function (..., envir = parent.frame())
[13:23:32.271]    - tweaked: FALSE
[13:23:32.271]    - call: NULL
[13:23:32.272] plan(): nbrOfWorkers() = 1
[13:23:32.273] plan(): Setting new future strategy stack:
[13:23:32.273] List of future strategies:
[13:23:32.273] 1. sequential:
[13:23:32.273]    - args: function (..., envir = parent.frame())
[13:23:32.273]    - tweaked: FALSE
[13:23:32.273]    - call: plan(strategy)
[13:23:32.273] plan(): nbrOfWorkers() = 1
[13:23:32.273] SequentialFuture started (and completed)
[13:23:32.273] - Launch lazy future ... done
[13:23:32.274] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.274] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.274] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:32.277] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:32.277] Searching for globals ... DONE
[13:23:32.277] Resolving globals: TRUE
[13:23:32.278] Resolving any globals that are futures ...
[13:23:32.278] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:32.278] Resolving any globals that are futures ... DONE
[13:23:32.278] Resolving futures part of globals (recursively) ...
[13:23:32.278] resolve() on list ...
[13:23:32.278]  recursive: 99
[13:23:32.279]  length: 1
[13:23:32.279]  elements: ‘a’
[13:23:32.279] resolved() for ‘SequentialFuture’ ...
[13:23:32.279] - state: ‘finished’
[13:23:32.279] - run: TRUE
[13:23:32.279] - result: ‘FutureResult’
[13:23:32.279] resolved() for ‘SequentialFuture’ ... done
[13:23:32.279] Future #1
[13:23:32.279] resolved() for ‘SequentialFuture’ ...
[13:23:32.280] - state: ‘finished’
[13:23:32.280] - run: TRUE
[13:23:32.280] - result: ‘FutureResult’
[13:23:32.280] resolved() for ‘SequentialFuture’ ... done
[13:23:32.280] A SequentialFuture was resolved
[13:23:32.280]  length: 0 (resolved future 1)
[13:23:32.280] resolve() on list ... DONE
[13:23:32.280] - globals: [1] ‘a’
[13:23:32.280] Resolving futures part of globals (recursively) ... DONE
[13:23:32.282] The total size of the 1 globals is 1.54 MiB (1615912 bytes)
[13:23:32.283] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.54 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.54 MiB of class ‘environment’)
[13:23:32.283] - globals: [1] ‘a’
[13:23:32.283] - packages: [1] ‘future’
[13:23:32.283] getGlobalsAndPackages() ... DONE
[13:23:32.283] run() for ‘Future’ ...
[13:23:32.283] - state: ‘created’
[13:23:32.284] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.284] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.284] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.284]   - Field: ‘label’
[13:23:32.284]   - Field: ‘local’
[13:23:32.284]   - Field: ‘owner’
[13:23:32.284]   - Field: ‘envir’
[13:23:32.285]   - Field: ‘packages’
[13:23:32.285]   - Field: ‘gc’
[13:23:32.285]   - Field: ‘conditions’
[13:23:32.285]   - Field: ‘expr’
[13:23:32.285]   - Field: ‘uuid’
[13:23:32.285]   - Field: ‘seed’
[13:23:32.285]   - Field: ‘version’
[13:23:32.285]   - Field: ‘result’
[13:23:32.285]   - Field: ‘asynchronous’
[13:23:32.285]   - Field: ‘calls’
[13:23:32.285]   - Field: ‘globals’
[13:23:32.286]   - Field: ‘stdout’
[13:23:32.286]   - Field: ‘earlySignal’
[13:23:32.286]   - Field: ‘lazy’
[13:23:32.286]   - Field: ‘state’
[13:23:32.286] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.286] - Launch lazy future ...
[13:23:32.286] Packages needed by the future expression (n = 1): ‘future’
[13:23:32.286] Packages needed by future strategies (n = 0): <none>
[13:23:32.287] {
[13:23:32.287]     {
[13:23:32.287]         {
[13:23:32.287]             ...future.startTime <- base::Sys.time()
[13:23:32.287]             {
[13:23:32.287]                 {
[13:23:32.287]                   {
[13:23:32.287]                     {
[13:23:32.287]                       base::local({
[13:23:32.287]                         has_future <- base::requireNamespace("future", 
[13:23:32.287]                           quietly = TRUE)
[13:23:32.287]                         if (has_future) {
[13:23:32.287]                           ns <- base::getNamespace("future")
[13:23:32.287]                           version <- ns[[".package"]][["version"]]
[13:23:32.287]                           if (is.null(version)) 
[13:23:32.287]                             version <- utils::packageVersion("future")
[13:23:32.287]                         }
[13:23:32.287]                         else {
[13:23:32.287]                           version <- NULL
[13:23:32.287]                         }
[13:23:32.287]                         if (!has_future || version < "1.8.0") {
[13:23:32.287]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.287]                             "", base::R.version$version.string), 
[13:23:32.287]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:32.287]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.287]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.287]                               "release", "version")], collapse = " "), 
[13:23:32.287]                             hostname = base::Sys.info()[["nodename"]])
[13:23:32.287]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.287]                             info)
[13:23:32.287]                           info <- base::paste(info, collapse = "; ")
[13:23:32.287]                           if (!has_future) {
[13:23:32.287]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.287]                               info)
[13:23:32.287]                           }
[13:23:32.287]                           else {
[13:23:32.287]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.287]                               info, version)
[13:23:32.287]                           }
[13:23:32.287]                           base::stop(msg)
[13:23:32.287]                         }
[13:23:32.287]                       })
[13:23:32.287]                     }
[13:23:32.287]                     base::local({
[13:23:32.287]                       for (pkg in "future") {
[13:23:32.287]                         base::loadNamespace(pkg)
[13:23:32.287]                         base::library(pkg, character.only = TRUE)
[13:23:32.287]                       }
[13:23:32.287]                     })
[13:23:32.287]                   }
[13:23:32.287]                   options(future.plan = NULL)
[13:23:32.287]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.287]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.287]                 }
[13:23:32.287]                 ...future.workdir <- getwd()
[13:23:32.287]             }
[13:23:32.287]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.287]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.287]         }
[13:23:32.287]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.287]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:32.287]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.287]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.287]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.287]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.287]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.287]             base::names(...future.oldOptions))
[13:23:32.287]     }
[13:23:32.287]     if (FALSE) {
[13:23:32.287]     }
[13:23:32.287]     else {
[13:23:32.287]         if (TRUE) {
[13:23:32.287]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.287]                 open = "w")
[13:23:32.287]         }
[13:23:32.287]         else {
[13:23:32.287]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.287]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.287]         }
[13:23:32.287]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.287]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.287]             base::sink(type = "output", split = FALSE)
[13:23:32.287]             base::close(...future.stdout)
[13:23:32.287]         }, add = TRUE)
[13:23:32.287]     }
[13:23:32.287]     ...future.frame <- base::sys.nframe()
[13:23:32.287]     ...future.conditions <- base::list()
[13:23:32.287]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.287]     if (FALSE) {
[13:23:32.287]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.287]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.287]     }
[13:23:32.287]     ...future.result <- base::tryCatch({
[13:23:32.287]         base::withCallingHandlers({
[13:23:32.287]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:23:32.287]                 1))
[13:23:32.287]             future::FutureResult(value = ...future.value$value, 
[13:23:32.287]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.287]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.287]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.287]                     ...future.globalenv.names))
[13:23:32.287]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.287]         }, condition = base::local({
[13:23:32.287]             c <- base::c
[13:23:32.287]             inherits <- base::inherits
[13:23:32.287]             invokeRestart <- base::invokeRestart
[13:23:32.287]             length <- base::length
[13:23:32.287]             list <- base::list
[13:23:32.287]             seq.int <- base::seq.int
[13:23:32.287]             signalCondition <- base::signalCondition
[13:23:32.287]             sys.calls <- base::sys.calls
[13:23:32.287]             `[[` <- base::`[[`
[13:23:32.287]             `+` <- base::`+`
[13:23:32.287]             `<<-` <- base::`<<-`
[13:23:32.287]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.287]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.287]                   3L)]
[13:23:32.287]             }
[13:23:32.287]             function(cond) {
[13:23:32.287]                 is_error <- inherits(cond, "error")
[13:23:32.287]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.287]                   NULL)
[13:23:32.287]                 if (is_error) {
[13:23:32.287]                   sessionInformation <- function() {
[13:23:32.287]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.287]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.287]                       search = base::search(), system = base::Sys.info())
[13:23:32.287]                   }
[13:23:32.287]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.287]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.287]                     cond$call), session = sessionInformation(), 
[13:23:32.287]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.287]                   signalCondition(cond)
[13:23:32.287]                 }
[13:23:32.287]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.287]                 "immediateCondition"))) {
[13:23:32.287]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.287]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.287]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.287]                   if (TRUE && !signal) {
[13:23:32.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.287]                     {
[13:23:32.287]                       inherits <- base::inherits
[13:23:32.287]                       invokeRestart <- base::invokeRestart
[13:23:32.287]                       is.null <- base::is.null
[13:23:32.287]                       muffled <- FALSE
[13:23:32.287]                       if (inherits(cond, "message")) {
[13:23:32.287]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.287]                         if (muffled) 
[13:23:32.287]                           invokeRestart("muffleMessage")
[13:23:32.287]                       }
[13:23:32.287]                       else if (inherits(cond, "warning")) {
[13:23:32.287]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.287]                         if (muffled) 
[13:23:32.287]                           invokeRestart("muffleWarning")
[13:23:32.287]                       }
[13:23:32.287]                       else if (inherits(cond, "condition")) {
[13:23:32.287]                         if (!is.null(pattern)) {
[13:23:32.287]                           computeRestarts <- base::computeRestarts
[13:23:32.287]                           grepl <- base::grepl
[13:23:32.287]                           restarts <- computeRestarts(cond)
[13:23:32.287]                           for (restart in restarts) {
[13:23:32.287]                             name <- restart$name
[13:23:32.287]                             if (is.null(name)) 
[13:23:32.287]                               next
[13:23:32.287]                             if (!grepl(pattern, name)) 
[13:23:32.287]                               next
[13:23:32.287]                             invokeRestart(restart)
[13:23:32.287]                             muffled <- TRUE
[13:23:32.287]                             break
[13:23:32.287]                           }
[13:23:32.287]                         }
[13:23:32.287]                       }
[13:23:32.287]                       invisible(muffled)
[13:23:32.287]                     }
[13:23:32.287]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.287]                   }
[13:23:32.287]                 }
[13:23:32.287]                 else {
[13:23:32.287]                   if (TRUE) {
[13:23:32.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.287]                     {
[13:23:32.287]                       inherits <- base::inherits
[13:23:32.287]                       invokeRestart <- base::invokeRestart
[13:23:32.287]                       is.null <- base::is.null
[13:23:32.287]                       muffled <- FALSE
[13:23:32.287]                       if (inherits(cond, "message")) {
[13:23:32.287]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.287]                         if (muffled) 
[13:23:32.287]                           invokeRestart("muffleMessage")
[13:23:32.287]                       }
[13:23:32.287]                       else if (inherits(cond, "warning")) {
[13:23:32.287]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.287]                         if (muffled) 
[13:23:32.287]                           invokeRestart("muffleWarning")
[13:23:32.287]                       }
[13:23:32.287]                       else if (inherits(cond, "condition")) {
[13:23:32.287]                         if (!is.null(pattern)) {
[13:23:32.287]                           computeRestarts <- base::computeRestarts
[13:23:32.287]                           grepl <- base::grepl
[13:23:32.287]                           restarts <- computeRestarts(cond)
[13:23:32.287]                           for (restart in restarts) {
[13:23:32.287]                             name <- restart$name
[13:23:32.287]                             if (is.null(name)) 
[13:23:32.287]                               next
[13:23:32.287]                             if (!grepl(pattern, name)) 
[13:23:32.287]                               next
[13:23:32.287]                             invokeRestart(restart)
[13:23:32.287]                             muffled <- TRUE
[13:23:32.287]                             break
[13:23:32.287]                           }
[13:23:32.287]                         }
[13:23:32.287]                       }
[13:23:32.287]                       invisible(muffled)
[13:23:32.287]                     }
[13:23:32.287]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.287]                   }
[13:23:32.287]                 }
[13:23:32.287]             }
[13:23:32.287]         }))
[13:23:32.287]     }, error = function(ex) {
[13:23:32.287]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.287]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.287]                 ...future.rng), started = ...future.startTime, 
[13:23:32.287]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.287]             version = "1.8"), class = "FutureResult")
[13:23:32.287]     }, finally = {
[13:23:32.287]         if (!identical(...future.workdir, getwd())) 
[13:23:32.287]             setwd(...future.workdir)
[13:23:32.287]         {
[13:23:32.287]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.287]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.287]             }
[13:23:32.287]             base::options(...future.oldOptions)
[13:23:32.287]             if (.Platform$OS.type == "windows") {
[13:23:32.287]                 old_names <- names(...future.oldEnvVars)
[13:23:32.287]                 envs <- base::Sys.getenv()
[13:23:32.287]                 names <- names(envs)
[13:23:32.287]                 common <- intersect(names, old_names)
[13:23:32.287]                 added <- setdiff(names, old_names)
[13:23:32.287]                 removed <- setdiff(old_names, names)
[13:23:32.287]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.287]                   envs[common]]
[13:23:32.287]                 NAMES <- toupper(changed)
[13:23:32.287]                 args <- list()
[13:23:32.287]                 for (kk in seq_along(NAMES)) {
[13:23:32.287]                   name <- changed[[kk]]
[13:23:32.287]                   NAME <- NAMES[[kk]]
[13:23:32.287]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.287]                     next
[13:23:32.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.287]                 }
[13:23:32.287]                 NAMES <- toupper(added)
[13:23:32.287]                 for (kk in seq_along(NAMES)) {
[13:23:32.287]                   name <- added[[kk]]
[13:23:32.287]                   NAME <- NAMES[[kk]]
[13:23:32.287]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.287]                     next
[13:23:32.287]                   args[[name]] <- ""
[13:23:32.287]                 }
[13:23:32.287]                 NAMES <- toupper(removed)
[13:23:32.287]                 for (kk in seq_along(NAMES)) {
[13:23:32.287]                   name <- removed[[kk]]
[13:23:32.287]                   NAME <- NAMES[[kk]]
[13:23:32.287]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.287]                     next
[13:23:32.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.287]                 }
[13:23:32.287]                 if (length(args) > 0) 
[13:23:32.287]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.287]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.287]             }
[13:23:32.287]             else {
[13:23:32.287]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.287]             }
[13:23:32.287]             {
[13:23:32.287]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.287]                   0L) {
[13:23:32.287]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.287]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.287]                   base::options(opts)
[13:23:32.287]                 }
[13:23:32.287]                 {
[13:23:32.287]                   {
[13:23:32.287]                     NULL
[13:23:32.287]                     RNGkind("Mersenne-Twister")
[13:23:32.287]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.287]                       inherits = FALSE)
[13:23:32.287]                   }
[13:23:32.287]                   options(future.plan = NULL)
[13:23:32.287]                   if (is.na(NA_character_)) 
[13:23:32.287]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.287]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.287]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.287]                   {
[13:23:32.287]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.287]                     if (!future$lazy) 
[13:23:32.287]                       future <- run(future)
[13:23:32.287]                     invisible(future)
[13:23:32.287]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.287]                 }
[13:23:32.287]             }
[13:23:32.287]         }
[13:23:32.287]     })
[13:23:32.287]     if (TRUE) {
[13:23:32.287]         base::sink(type = "output", split = FALSE)
[13:23:32.287]         if (TRUE) {
[13:23:32.287]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.287]         }
[13:23:32.287]         else {
[13:23:32.287]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.287]         }
[13:23:32.287]         base::close(...future.stdout)
[13:23:32.287]         ...future.stdout <- NULL
[13:23:32.287]     }
[13:23:32.287]     ...future.result$conditions <- ...future.conditions
[13:23:32.287]     ...future.result$finished <- base::Sys.time()
[13:23:32.287]     ...future.result
[13:23:32.287] }
[13:23:32.289] assign_globals() ...
[13:23:32.289] List of 1
[13:23:32.289]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5589bf32c998> 
[13:23:32.289]  - attr(*, "where")=List of 1
[13:23:32.289]   ..$ a:<environment: R_EmptyEnv> 
[13:23:32.289]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.289]  - attr(*, "resolved")= logi TRUE
[13:23:32.289]  - attr(*, "total_size")= num 1615912
[13:23:32.289]  - attr(*, "already-done")= logi TRUE
[13:23:32.291] - copied ‘a’ to environment
[13:23:32.292] assign_globals() ... done
[13:23:32.292] plan(): Setting new future strategy stack:
[13:23:32.292] List of future strategies:
[13:23:32.292] 1. sequential:
[13:23:32.292]    - args: function (..., envir = parent.frame())
[13:23:32.292]    - tweaked: FALSE
[13:23:32.292]    - call: NULL
[13:23:32.292] plan(): nbrOfWorkers() = 1
[13:23:32.293] plan(): Setting new future strategy stack:
[13:23:32.293] List of future strategies:
[13:23:32.293] 1. sequential:
[13:23:32.293]    - args: function (..., envir = parent.frame())
[13:23:32.293]    - tweaked: FALSE
[13:23:32.293]    - call: plan(strategy)
[13:23:32.294] plan(): nbrOfWorkers() = 1
[13:23:32.294] SequentialFuture started (and completed)
[13:23:32.294] - Launch lazy future ... done
[13:23:32.294] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.295] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.295] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:32.295] 
[13:23:32.295] Searching for globals ... DONE
[13:23:32.295] - globals: [0] <none>
[13:23:32.296] getGlobalsAndPackages() ... DONE
[13:23:32.296] run() for ‘Future’ ...
[13:23:32.296] - state: ‘created’
[13:23:32.296] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.296] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.296] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.297]   - Field: ‘label’
[13:23:32.297]   - Field: ‘local’
[13:23:32.297]   - Field: ‘owner’
[13:23:32.297]   - Field: ‘envir’
[13:23:32.297]   - Field: ‘packages’
[13:23:32.297]   - Field: ‘gc’
[13:23:32.297]   - Field: ‘conditions’
[13:23:32.297]   - Field: ‘expr’
[13:23:32.297]   - Field: ‘uuid’
[13:23:32.297]   - Field: ‘seed’
[13:23:32.297]   - Field: ‘version’
[13:23:32.298]   - Field: ‘result’
[13:23:32.298]   - Field: ‘asynchronous’
[13:23:32.298]   - Field: ‘calls’
[13:23:32.298]   - Field: ‘globals’
[13:23:32.298]   - Field: ‘stdout’
[13:23:32.298]   - Field: ‘earlySignal’
[13:23:32.298]   - Field: ‘lazy’
[13:23:32.298]   - Field: ‘state’
[13:23:32.298] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.298] - Launch lazy future ...
[13:23:32.299] Packages needed by the future expression (n = 0): <none>
[13:23:32.299] Packages needed by future strategies (n = 0): <none>
[13:23:32.299] {
[13:23:32.299]     {
[13:23:32.299]         {
[13:23:32.299]             ...future.startTime <- base::Sys.time()
[13:23:32.299]             {
[13:23:32.299]                 {
[13:23:32.299]                   {
[13:23:32.299]                     base::local({
[13:23:32.299]                       has_future <- base::requireNamespace("future", 
[13:23:32.299]                         quietly = TRUE)
[13:23:32.299]                       if (has_future) {
[13:23:32.299]                         ns <- base::getNamespace("future")
[13:23:32.299]                         version <- ns[[".package"]][["version"]]
[13:23:32.299]                         if (is.null(version)) 
[13:23:32.299]                           version <- utils::packageVersion("future")
[13:23:32.299]                       }
[13:23:32.299]                       else {
[13:23:32.299]                         version <- NULL
[13:23:32.299]                       }
[13:23:32.299]                       if (!has_future || version < "1.8.0") {
[13:23:32.299]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.299]                           "", base::R.version$version.string), 
[13:23:32.299]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:32.299]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.299]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.299]                             "release", "version")], collapse = " "), 
[13:23:32.299]                           hostname = base::Sys.info()[["nodename"]])
[13:23:32.299]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.299]                           info)
[13:23:32.299]                         info <- base::paste(info, collapse = "; ")
[13:23:32.299]                         if (!has_future) {
[13:23:32.299]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.299]                             info)
[13:23:32.299]                         }
[13:23:32.299]                         else {
[13:23:32.299]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.299]                             info, version)
[13:23:32.299]                         }
[13:23:32.299]                         base::stop(msg)
[13:23:32.299]                       }
[13:23:32.299]                     })
[13:23:32.299]                   }
[13:23:32.299]                   options(future.plan = NULL)
[13:23:32.299]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.299]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.299]                 }
[13:23:32.299]                 ...future.workdir <- getwd()
[13:23:32.299]             }
[13:23:32.299]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.299]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.299]         }
[13:23:32.299]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.299]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:32.299]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.299]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.299]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.299]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.299]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.299]             base::names(...future.oldOptions))
[13:23:32.299]     }
[13:23:32.299]     if (FALSE) {
[13:23:32.299]     }
[13:23:32.299]     else {
[13:23:32.299]         if (TRUE) {
[13:23:32.299]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.299]                 open = "w")
[13:23:32.299]         }
[13:23:32.299]         else {
[13:23:32.299]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.299]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.299]         }
[13:23:32.299]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.299]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.299]             base::sink(type = "output", split = FALSE)
[13:23:32.299]             base::close(...future.stdout)
[13:23:32.299]         }, add = TRUE)
[13:23:32.299]     }
[13:23:32.299]     ...future.frame <- base::sys.nframe()
[13:23:32.299]     ...future.conditions <- base::list()
[13:23:32.299]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.299]     if (FALSE) {
[13:23:32.299]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.299]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.299]     }
[13:23:32.299]     ...future.result <- base::tryCatch({
[13:23:32.299]         base::withCallingHandlers({
[13:23:32.299]             ...future.value <- base::withVisible(base::local(1))
[13:23:32.299]             future::FutureResult(value = ...future.value$value, 
[13:23:32.299]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.299]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.299]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.299]                     ...future.globalenv.names))
[13:23:32.299]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.299]         }, condition = base::local({
[13:23:32.299]             c <- base::c
[13:23:32.299]             inherits <- base::inherits
[13:23:32.299]             invokeRestart <- base::invokeRestart
[13:23:32.299]             length <- base::length
[13:23:32.299]             list <- base::list
[13:23:32.299]             seq.int <- base::seq.int
[13:23:32.299]             signalCondition <- base::signalCondition
[13:23:32.299]             sys.calls <- base::sys.calls
[13:23:32.299]             `[[` <- base::`[[`
[13:23:32.299]             `+` <- base::`+`
[13:23:32.299]             `<<-` <- base::`<<-`
[13:23:32.299]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.299]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.299]                   3L)]
[13:23:32.299]             }
[13:23:32.299]             function(cond) {
[13:23:32.299]                 is_error <- inherits(cond, "error")
[13:23:32.299]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.299]                   NULL)
[13:23:32.299]                 if (is_error) {
[13:23:32.299]                   sessionInformation <- function() {
[13:23:32.299]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.299]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.299]                       search = base::search(), system = base::Sys.info())
[13:23:32.299]                   }
[13:23:32.299]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.299]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.299]                     cond$call), session = sessionInformation(), 
[13:23:32.299]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.299]                   signalCondition(cond)
[13:23:32.299]                 }
[13:23:32.299]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.299]                 "immediateCondition"))) {
[13:23:32.299]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.299]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.299]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.299]                   if (TRUE && !signal) {
[13:23:32.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.299]                     {
[13:23:32.299]                       inherits <- base::inherits
[13:23:32.299]                       invokeRestart <- base::invokeRestart
[13:23:32.299]                       is.null <- base::is.null
[13:23:32.299]                       muffled <- FALSE
[13:23:32.299]                       if (inherits(cond, "message")) {
[13:23:32.299]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.299]                         if (muffled) 
[13:23:32.299]                           invokeRestart("muffleMessage")
[13:23:32.299]                       }
[13:23:32.299]                       else if (inherits(cond, "warning")) {
[13:23:32.299]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.299]                         if (muffled) 
[13:23:32.299]                           invokeRestart("muffleWarning")
[13:23:32.299]                       }
[13:23:32.299]                       else if (inherits(cond, "condition")) {
[13:23:32.299]                         if (!is.null(pattern)) {
[13:23:32.299]                           computeRestarts <- base::computeRestarts
[13:23:32.299]                           grepl <- base::grepl
[13:23:32.299]                           restarts <- computeRestarts(cond)
[13:23:32.299]                           for (restart in restarts) {
[13:23:32.299]                             name <- restart$name
[13:23:32.299]                             if (is.null(name)) 
[13:23:32.299]                               next
[13:23:32.299]                             if (!grepl(pattern, name)) 
[13:23:32.299]                               next
[13:23:32.299]                             invokeRestart(restart)
[13:23:32.299]                             muffled <- TRUE
[13:23:32.299]                             break
[13:23:32.299]                           }
[13:23:32.299]                         }
[13:23:32.299]                       }
[13:23:32.299]                       invisible(muffled)
[13:23:32.299]                     }
[13:23:32.299]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.299]                   }
[13:23:32.299]                 }
[13:23:32.299]                 else {
[13:23:32.299]                   if (TRUE) {
[13:23:32.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.299]                     {
[13:23:32.299]                       inherits <- base::inherits
[13:23:32.299]                       invokeRestart <- base::invokeRestart
[13:23:32.299]                       is.null <- base::is.null
[13:23:32.299]                       muffled <- FALSE
[13:23:32.299]                       if (inherits(cond, "message")) {
[13:23:32.299]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.299]                         if (muffled) 
[13:23:32.299]                           invokeRestart("muffleMessage")
[13:23:32.299]                       }
[13:23:32.299]                       else if (inherits(cond, "warning")) {
[13:23:32.299]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.299]                         if (muffled) 
[13:23:32.299]                           invokeRestart("muffleWarning")
[13:23:32.299]                       }
[13:23:32.299]                       else if (inherits(cond, "condition")) {
[13:23:32.299]                         if (!is.null(pattern)) {
[13:23:32.299]                           computeRestarts <- base::computeRestarts
[13:23:32.299]                           grepl <- base::grepl
[13:23:32.299]                           restarts <- computeRestarts(cond)
[13:23:32.299]                           for (restart in restarts) {
[13:23:32.299]                             name <- restart$name
[13:23:32.299]                             if (is.null(name)) 
[13:23:32.299]                               next
[13:23:32.299]                             if (!grepl(pattern, name)) 
[13:23:32.299]                               next
[13:23:32.299]                             invokeRestart(restart)
[13:23:32.299]                             muffled <- TRUE
[13:23:32.299]                             break
[13:23:32.299]                           }
[13:23:32.299]                         }
[13:23:32.299]                       }
[13:23:32.299]                       invisible(muffled)
[13:23:32.299]                     }
[13:23:32.299]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.299]                   }
[13:23:32.299]                 }
[13:23:32.299]             }
[13:23:32.299]         }))
[13:23:32.299]     }, error = function(ex) {
[13:23:32.299]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.299]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.299]                 ...future.rng), started = ...future.startTime, 
[13:23:32.299]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.299]             version = "1.8"), class = "FutureResult")
[13:23:32.299]     }, finally = {
[13:23:32.299]         if (!identical(...future.workdir, getwd())) 
[13:23:32.299]             setwd(...future.workdir)
[13:23:32.299]         {
[13:23:32.299]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.299]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.299]             }
[13:23:32.299]             base::options(...future.oldOptions)
[13:23:32.299]             if (.Platform$OS.type == "windows") {
[13:23:32.299]                 old_names <- names(...future.oldEnvVars)
[13:23:32.299]                 envs <- base::Sys.getenv()
[13:23:32.299]                 names <- names(envs)
[13:23:32.299]                 common <- intersect(names, old_names)
[13:23:32.299]                 added <- setdiff(names, old_names)
[13:23:32.299]                 removed <- setdiff(old_names, names)
[13:23:32.299]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.299]                   envs[common]]
[13:23:32.299]                 NAMES <- toupper(changed)
[13:23:32.299]                 args <- list()
[13:23:32.299]                 for (kk in seq_along(NAMES)) {
[13:23:32.299]                   name <- changed[[kk]]
[13:23:32.299]                   NAME <- NAMES[[kk]]
[13:23:32.299]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.299]                     next
[13:23:32.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.299]                 }
[13:23:32.299]                 NAMES <- toupper(added)
[13:23:32.299]                 for (kk in seq_along(NAMES)) {
[13:23:32.299]                   name <- added[[kk]]
[13:23:32.299]                   NAME <- NAMES[[kk]]
[13:23:32.299]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.299]                     next
[13:23:32.299]                   args[[name]] <- ""
[13:23:32.299]                 }
[13:23:32.299]                 NAMES <- toupper(removed)
[13:23:32.299]                 for (kk in seq_along(NAMES)) {
[13:23:32.299]                   name <- removed[[kk]]
[13:23:32.299]                   NAME <- NAMES[[kk]]
[13:23:32.299]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.299]                     next
[13:23:32.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.299]                 }
[13:23:32.299]                 if (length(args) > 0) 
[13:23:32.299]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.299]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.299]             }
[13:23:32.299]             else {
[13:23:32.299]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.299]             }
[13:23:32.299]             {
[13:23:32.299]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.299]                   0L) {
[13:23:32.299]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.299]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.299]                   base::options(opts)
[13:23:32.299]                 }
[13:23:32.299]                 {
[13:23:32.299]                   {
[13:23:32.299]                     NULL
[13:23:32.299]                     RNGkind("Mersenne-Twister")
[13:23:32.299]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.299]                       inherits = FALSE)
[13:23:32.299]                   }
[13:23:32.299]                   options(future.plan = NULL)
[13:23:32.299]                   if (is.na(NA_character_)) 
[13:23:32.299]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.299]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.299]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.299]                   {
[13:23:32.299]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.299]                     if (!future$lazy) 
[13:23:32.299]                       future <- run(future)
[13:23:32.299]                     invisible(future)
[13:23:32.299]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.299]                 }
[13:23:32.299]             }
[13:23:32.299]         }
[13:23:32.299]     })
[13:23:32.299]     if (TRUE) {
[13:23:32.299]         base::sink(type = "output", split = FALSE)
[13:23:32.299]         if (TRUE) {
[13:23:32.299]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.299]         }
[13:23:32.299]         else {
[13:23:32.299]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.299]         }
[13:23:32.299]         base::close(...future.stdout)
[13:23:32.299]         ...future.stdout <- NULL
[13:23:32.299]     }
[13:23:32.299]     ...future.result$conditions <- ...future.conditions
[13:23:32.299]     ...future.result$finished <- base::Sys.time()
[13:23:32.299]     ...future.result
[13:23:32.299] }
[13:23:32.301] plan(): Setting new future strategy stack:
[13:23:32.301] List of future strategies:
[13:23:32.301] 1. sequential:
[13:23:32.301]    - args: function (..., envir = parent.frame())
[13:23:32.301]    - tweaked: FALSE
[13:23:32.301]    - call: NULL
[13:23:32.302] plan(): nbrOfWorkers() = 1
[13:23:32.333] plan(): Setting new future strategy stack:
[13:23:32.333] List of future strategies:
[13:23:32.333] 1. sequential:
[13:23:32.333]    - args: function (..., envir = parent.frame())
[13:23:32.333]    - tweaked: FALSE
[13:23:32.333]    - call: plan(strategy)
[13:23:32.334] plan(): nbrOfWorkers() = 1
[13:23:32.334] SequentialFuture started (and completed)
[13:23:32.334] - Launch lazy future ... done
[13:23:32.335] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.335] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.335] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:32.336] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:32.336] Searching for globals ... DONE
[13:23:32.336] Resolving globals: TRUE
[13:23:32.337] Resolving any globals that are futures ...
[13:23:32.337] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:32.337] Resolving any globals that are futures ... DONE
[13:23:32.337] Resolving futures part of globals (recursively) ...
[13:23:32.337] resolve() on list ...
[13:23:32.338]  recursive: 99
[13:23:32.338]  length: 1
[13:23:32.338]  elements: ‘a’
[13:23:32.338] resolved() for ‘SequentialFuture’ ...
[13:23:32.338] - state: ‘finished’
[13:23:32.338] - run: TRUE
[13:23:32.338] - result: ‘FutureResult’
[13:23:32.338] resolved() for ‘SequentialFuture’ ... done
[13:23:32.338] Future #1
[13:23:32.339] resolved() for ‘SequentialFuture’ ...
[13:23:32.339] - state: ‘finished’
[13:23:32.339] - run: TRUE
[13:23:32.339] - result: ‘FutureResult’
[13:23:32.339] resolved() for ‘SequentialFuture’ ... done
[13:23:32.339] A SequentialFuture was resolved
[13:23:32.339]  length: 0 (resolved future 1)
[13:23:32.339] resolve() on list ... DONE
[13:23:32.339] - globals: [1] ‘a’
[13:23:32.339] Resolving futures part of globals (recursively) ... DONE
[13:23:32.341] The total size of the 1 globals is 1.54 MiB (1615912 bytes)
[13:23:32.342] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.54 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.54 MiB of class ‘environment’)
[13:23:32.342] - globals: [1] ‘a’
[13:23:32.342] - packages: [1] ‘future’
[13:23:32.342] getGlobalsAndPackages() ... DONE
[13:23:32.343] run() for ‘Future’ ...
[13:23:32.343] - state: ‘created’
[13:23:32.343] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.343] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.343] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.343]   - Field: ‘label’
[13:23:32.343]   - Field: ‘local’
[13:23:32.344]   - Field: ‘owner’
[13:23:32.344]   - Field: ‘envir’
[13:23:32.344]   - Field: ‘packages’
[13:23:32.344]   - Field: ‘gc’
[13:23:32.344]   - Field: ‘conditions’
[13:23:32.344]   - Field: ‘expr’
[13:23:32.344]   - Field: ‘uuid’
[13:23:32.344]   - Field: ‘seed’
[13:23:32.344]   - Field: ‘version’
[13:23:32.344]   - Field: ‘result’
[13:23:32.345]   - Field: ‘asynchronous’
[13:23:32.345]   - Field: ‘calls’
[13:23:32.345]   - Field: ‘globals’
[13:23:32.345]   - Field: ‘stdout’
[13:23:32.345]   - Field: ‘earlySignal’
[13:23:32.345]   - Field: ‘lazy’
[13:23:32.345]   - Field: ‘state’
[13:23:32.345] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.345] - Launch lazy future ...
[13:23:32.346] Packages needed by the future expression (n = 1): ‘future’
[13:23:32.346] Packages needed by future strategies (n = 0): <none>
[13:23:32.346] {
[13:23:32.346]     {
[13:23:32.346]         {
[13:23:32.346]             ...future.startTime <- base::Sys.time()
[13:23:32.346]             {
[13:23:32.346]                 {
[13:23:32.346]                   {
[13:23:32.346]                     {
[13:23:32.346]                       base::local({
[13:23:32.346]                         has_future <- base::requireNamespace("future", 
[13:23:32.346]                           quietly = TRUE)
[13:23:32.346]                         if (has_future) {
[13:23:32.346]                           ns <- base::getNamespace("future")
[13:23:32.346]                           version <- ns[[".package"]][["version"]]
[13:23:32.346]                           if (is.null(version)) 
[13:23:32.346]                             version <- utils::packageVersion("future")
[13:23:32.346]                         }
[13:23:32.346]                         else {
[13:23:32.346]                           version <- NULL
[13:23:32.346]                         }
[13:23:32.346]                         if (!has_future || version < "1.8.0") {
[13:23:32.346]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.346]                             "", base::R.version$version.string), 
[13:23:32.346]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:32.346]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.346]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.346]                               "release", "version")], collapse = " "), 
[13:23:32.346]                             hostname = base::Sys.info()[["nodename"]])
[13:23:32.346]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.346]                             info)
[13:23:32.346]                           info <- base::paste(info, collapse = "; ")
[13:23:32.346]                           if (!has_future) {
[13:23:32.346]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.346]                               info)
[13:23:32.346]                           }
[13:23:32.346]                           else {
[13:23:32.346]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.346]                               info, version)
[13:23:32.346]                           }
[13:23:32.346]                           base::stop(msg)
[13:23:32.346]                         }
[13:23:32.346]                       })
[13:23:32.346]                     }
[13:23:32.346]                     base::local({
[13:23:32.346]                       for (pkg in "future") {
[13:23:32.346]                         base::loadNamespace(pkg)
[13:23:32.346]                         base::library(pkg, character.only = TRUE)
[13:23:32.346]                       }
[13:23:32.346]                     })
[13:23:32.346]                   }
[13:23:32.346]                   options(future.plan = NULL)
[13:23:32.346]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.346]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.346]                 }
[13:23:32.346]                 ...future.workdir <- getwd()
[13:23:32.346]             }
[13:23:32.346]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.346]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.346]         }
[13:23:32.346]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.346]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:32.346]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.346]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.346]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.346]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.346]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.346]             base::names(...future.oldOptions))
[13:23:32.346]     }
[13:23:32.346]     if (FALSE) {
[13:23:32.346]     }
[13:23:32.346]     else {
[13:23:32.346]         if (TRUE) {
[13:23:32.346]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.346]                 open = "w")
[13:23:32.346]         }
[13:23:32.346]         else {
[13:23:32.346]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.346]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.346]         }
[13:23:32.346]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.346]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.346]             base::sink(type = "output", split = FALSE)
[13:23:32.346]             base::close(...future.stdout)
[13:23:32.346]         }, add = TRUE)
[13:23:32.346]     }
[13:23:32.346]     ...future.frame <- base::sys.nframe()
[13:23:32.346]     ...future.conditions <- base::list()
[13:23:32.346]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.346]     if (FALSE) {
[13:23:32.346]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.346]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.346]     }
[13:23:32.346]     ...future.result <- base::tryCatch({
[13:23:32.346]         base::withCallingHandlers({
[13:23:32.346]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:23:32.346]                 1))
[13:23:32.346]             future::FutureResult(value = ...future.value$value, 
[13:23:32.346]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.346]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.346]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.346]                     ...future.globalenv.names))
[13:23:32.346]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.346]         }, condition = base::local({
[13:23:32.346]             c <- base::c
[13:23:32.346]             inherits <- base::inherits
[13:23:32.346]             invokeRestart <- base::invokeRestart
[13:23:32.346]             length <- base::length
[13:23:32.346]             list <- base::list
[13:23:32.346]             seq.int <- base::seq.int
[13:23:32.346]             signalCondition <- base::signalCondition
[13:23:32.346]             sys.calls <- base::sys.calls
[13:23:32.346]             `[[` <- base::`[[`
[13:23:32.346]             `+` <- base::`+`
[13:23:32.346]             `<<-` <- base::`<<-`
[13:23:32.346]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.346]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.346]                   3L)]
[13:23:32.346]             }
[13:23:32.346]             function(cond) {
[13:23:32.346]                 is_error <- inherits(cond, "error")
[13:23:32.346]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.346]                   NULL)
[13:23:32.346]                 if (is_error) {
[13:23:32.346]                   sessionInformation <- function() {
[13:23:32.346]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.346]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.346]                       search = base::search(), system = base::Sys.info())
[13:23:32.346]                   }
[13:23:32.346]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.346]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.346]                     cond$call), session = sessionInformation(), 
[13:23:32.346]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.346]                   signalCondition(cond)
[13:23:32.346]                 }
[13:23:32.346]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.346]                 "immediateCondition"))) {
[13:23:32.346]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.346]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.346]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.346]                   if (TRUE && !signal) {
[13:23:32.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.346]                     {
[13:23:32.346]                       inherits <- base::inherits
[13:23:32.346]                       invokeRestart <- base::invokeRestart
[13:23:32.346]                       is.null <- base::is.null
[13:23:32.346]                       muffled <- FALSE
[13:23:32.346]                       if (inherits(cond, "message")) {
[13:23:32.346]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.346]                         if (muffled) 
[13:23:32.346]                           invokeRestart("muffleMessage")
[13:23:32.346]                       }
[13:23:32.346]                       else if (inherits(cond, "warning")) {
[13:23:32.346]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.346]                         if (muffled) 
[13:23:32.346]                           invokeRestart("muffleWarning")
[13:23:32.346]                       }
[13:23:32.346]                       else if (inherits(cond, "condition")) {
[13:23:32.346]                         if (!is.null(pattern)) {
[13:23:32.346]                           computeRestarts <- base::computeRestarts
[13:23:32.346]                           grepl <- base::grepl
[13:23:32.346]                           restarts <- computeRestarts(cond)
[13:23:32.346]                           for (restart in restarts) {
[13:23:32.346]                             name <- restart$name
[13:23:32.346]                             if (is.null(name)) 
[13:23:32.346]                               next
[13:23:32.346]                             if (!grepl(pattern, name)) 
[13:23:32.346]                               next
[13:23:32.346]                             invokeRestart(restart)
[13:23:32.346]                             muffled <- TRUE
[13:23:32.346]                             break
[13:23:32.346]                           }
[13:23:32.346]                         }
[13:23:32.346]                       }
[13:23:32.346]                       invisible(muffled)
[13:23:32.346]                     }
[13:23:32.346]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.346]                   }
[13:23:32.346]                 }
[13:23:32.346]                 else {
[13:23:32.346]                   if (TRUE) {
[13:23:32.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.346]                     {
[13:23:32.346]                       inherits <- base::inherits
[13:23:32.346]                       invokeRestart <- base::invokeRestart
[13:23:32.346]                       is.null <- base::is.null
[13:23:32.346]                       muffled <- FALSE
[13:23:32.346]                       if (inherits(cond, "message")) {
[13:23:32.346]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.346]                         if (muffled) 
[13:23:32.346]                           invokeRestart("muffleMessage")
[13:23:32.346]                       }
[13:23:32.346]                       else if (inherits(cond, "warning")) {
[13:23:32.346]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.346]                         if (muffled) 
[13:23:32.346]                           invokeRestart("muffleWarning")
[13:23:32.346]                       }
[13:23:32.346]                       else if (inherits(cond, "condition")) {
[13:23:32.346]                         if (!is.null(pattern)) {
[13:23:32.346]                           computeRestarts <- base::computeRestarts
[13:23:32.346]                           grepl <- base::grepl
[13:23:32.346]                           restarts <- computeRestarts(cond)
[13:23:32.346]                           for (restart in restarts) {
[13:23:32.346]                             name <- restart$name
[13:23:32.346]                             if (is.null(name)) 
[13:23:32.346]                               next
[13:23:32.346]                             if (!grepl(pattern, name)) 
[13:23:32.346]                               next
[13:23:32.346]                             invokeRestart(restart)
[13:23:32.346]                             muffled <- TRUE
[13:23:32.346]                             break
[13:23:32.346]                           }
[13:23:32.346]                         }
[13:23:32.346]                       }
[13:23:32.346]                       invisible(muffled)
[13:23:32.346]                     }
[13:23:32.346]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.346]                   }
[13:23:32.346]                 }
[13:23:32.346]             }
[13:23:32.346]         }))
[13:23:32.346]     }, error = function(ex) {
[13:23:32.346]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.346]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.346]                 ...future.rng), started = ...future.startTime, 
[13:23:32.346]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.346]             version = "1.8"), class = "FutureResult")
[13:23:32.346]     }, finally = {
[13:23:32.346]         if (!identical(...future.workdir, getwd())) 
[13:23:32.346]             setwd(...future.workdir)
[13:23:32.346]         {
[13:23:32.346]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.346]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.346]             }
[13:23:32.346]             base::options(...future.oldOptions)
[13:23:32.346]             if (.Platform$OS.type == "windows") {
[13:23:32.346]                 old_names <- names(...future.oldEnvVars)
[13:23:32.346]                 envs <- base::Sys.getenv()
[13:23:32.346]                 names <- names(envs)
[13:23:32.346]                 common <- intersect(names, old_names)
[13:23:32.346]                 added <- setdiff(names, old_names)
[13:23:32.346]                 removed <- setdiff(old_names, names)
[13:23:32.346]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.346]                   envs[common]]
[13:23:32.346]                 NAMES <- toupper(changed)
[13:23:32.346]                 args <- list()
[13:23:32.346]                 for (kk in seq_along(NAMES)) {
[13:23:32.346]                   name <- changed[[kk]]
[13:23:32.346]                   NAME <- NAMES[[kk]]
[13:23:32.346]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.346]                     next
[13:23:32.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.346]                 }
[13:23:32.346]                 NAMES <- toupper(added)
[13:23:32.346]                 for (kk in seq_along(NAMES)) {
[13:23:32.346]                   name <- added[[kk]]
[13:23:32.346]                   NAME <- NAMES[[kk]]
[13:23:32.346]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.346]                     next
[13:23:32.346]                   args[[name]] <- ""
[13:23:32.346]                 }
[13:23:32.346]                 NAMES <- toupper(removed)
[13:23:32.346]                 for (kk in seq_along(NAMES)) {
[13:23:32.346]                   name <- removed[[kk]]
[13:23:32.346]                   NAME <- NAMES[[kk]]
[13:23:32.346]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.346]                     next
[13:23:32.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.346]                 }
[13:23:32.346]                 if (length(args) > 0) 
[13:23:32.346]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.346]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.346]             }
[13:23:32.346]             else {
[13:23:32.346]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.346]             }
[13:23:32.346]             {
[13:23:32.346]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.346]                   0L) {
[13:23:32.346]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.346]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.346]                   base::options(opts)
[13:23:32.346]                 }
[13:23:32.346]                 {
[13:23:32.346]                   {
[13:23:32.346]                     NULL
[13:23:32.346]                     RNGkind("Mersenne-Twister")
[13:23:32.346]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.346]                       inherits = FALSE)
[13:23:32.346]                   }
[13:23:32.346]                   options(future.plan = NULL)
[13:23:32.346]                   if (is.na(NA_character_)) 
[13:23:32.346]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.346]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.346]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.346]                   {
[13:23:32.346]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.346]                     if (!future$lazy) 
[13:23:32.346]                       future <- run(future)
[13:23:32.346]                     invisible(future)
[13:23:32.346]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.346]                 }
[13:23:32.346]             }
[13:23:32.346]         }
[13:23:32.346]     })
[13:23:32.346]     if (TRUE) {
[13:23:32.346]         base::sink(type = "output", split = FALSE)
[13:23:32.346]         if (TRUE) {
[13:23:32.346]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.346]         }
[13:23:32.346]         else {
[13:23:32.346]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.346]         }
[13:23:32.346]         base::close(...future.stdout)
[13:23:32.346]         ...future.stdout <- NULL
[13:23:32.346]     }
[13:23:32.346]     ...future.result$conditions <- ...future.conditions
[13:23:32.346]     ...future.result$finished <- base::Sys.time()
[13:23:32.346]     ...future.result
[13:23:32.346] }
[13:23:32.348] assign_globals() ...
[13:23:32.348] List of 1
[13:23:32.348]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5589bf39bc38> 
[13:23:32.348]  - attr(*, "where")=List of 1
[13:23:32.348]   ..$ a:<environment: R_EmptyEnv> 
[13:23:32.348]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.348]  - attr(*, "resolved")= logi TRUE
[13:23:32.348]  - attr(*, "total_size")= num 1615912
[13:23:32.348]  - attr(*, "already-done")= logi TRUE
[13:23:32.351] - copied ‘a’ to environment
[13:23:32.351] assign_globals() ... done
[13:23:32.351] plan(): Setting new future strategy stack:
[13:23:32.351] List of future strategies:
[13:23:32.351] 1. sequential:
[13:23:32.351]    - args: function (..., envir = parent.frame())
[13:23:32.351]    - tweaked: FALSE
[13:23:32.351]    - call: NULL
[13:23:32.352] plan(): nbrOfWorkers() = 1
[13:23:32.353] plan(): Setting new future strategy stack:
[13:23:32.353] List of future strategies:
[13:23:32.353] 1. sequential:
[13:23:32.353]    - args: function (..., envir = parent.frame())
[13:23:32.353]    - tweaked: FALSE
[13:23:32.353]    - call: plan(strategy)
[13:23:32.353] plan(): nbrOfWorkers() = 1
[13:23:32.353] SequentialFuture started (and completed)
[13:23:32.354] - Launch lazy future ... done
[13:23:32.354] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.354] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.354] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:32.355] 
[13:23:32.355] Searching for globals ... DONE
[13:23:32.355] - globals: [0] <none>
[13:23:32.355] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.355] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.356] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:32.356] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:32.357] Searching for globals ... DONE
[13:23:32.357] Resolving globals: TRUE
[13:23:32.357] Resolving any globals that are futures ...
[13:23:32.357] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:32.357] Resolving any globals that are futures ... DONE
[13:23:32.357] Resolving futures part of globals (recursively) ...
[13:23:32.357] resolve() on list ...
[13:23:32.358]  recursive: 99
[13:23:32.358]  length: 1
[13:23:32.358]  elements: ‘a’
[13:23:32.358] run() for ‘Future’ ...
[13:23:32.358] - state: ‘created’
[13:23:32.358] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.358] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.359] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.359]   - Field: ‘label’
[13:23:32.359]   - Field: ‘local’
[13:23:32.359]   - Field: ‘owner’
[13:23:32.359]   - Field: ‘envir’
[13:23:32.359]   - Field: ‘packages’
[13:23:32.359]   - Field: ‘gc’
[13:23:32.359]   - Field: ‘conditions’
[13:23:32.359]   - Field: ‘expr’
[13:23:32.359]   - Field: ‘uuid’
[13:23:32.360]   - Field: ‘seed’
[13:23:32.360]   - Field: ‘version’
[13:23:32.360]   - Field: ‘result’
[13:23:32.360]   - Field: ‘asynchronous’
[13:23:32.360]   - Field: ‘calls’
[13:23:32.360]   - Field: ‘globals’
[13:23:32.360]   - Field: ‘stdout’
[13:23:32.360]   - Field: ‘earlySignal’
[13:23:32.360]   - Field: ‘lazy’
[13:23:32.360]   - Field: ‘state’
[13:23:32.361] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.361] - Launch lazy future ...
[13:23:32.361] Packages needed by the future expression (n = 0): <none>
[13:23:32.361] Packages needed by future strategies (n = 0): <none>
[13:23:32.361] {
[13:23:32.361]     {
[13:23:32.361]         {
[13:23:32.361]             ...future.startTime <- base::Sys.time()
[13:23:32.361]             {
[13:23:32.361]                 {
[13:23:32.361]                   {
[13:23:32.361]                     base::local({
[13:23:32.361]                       has_future <- base::requireNamespace("future", 
[13:23:32.361]                         quietly = TRUE)
[13:23:32.361]                       if (has_future) {
[13:23:32.361]                         ns <- base::getNamespace("future")
[13:23:32.361]                         version <- ns[[".package"]][["version"]]
[13:23:32.361]                         if (is.null(version)) 
[13:23:32.361]                           version <- utils::packageVersion("future")
[13:23:32.361]                       }
[13:23:32.361]                       else {
[13:23:32.361]                         version <- NULL
[13:23:32.361]                       }
[13:23:32.361]                       if (!has_future || version < "1.8.0") {
[13:23:32.361]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.361]                           "", base::R.version$version.string), 
[13:23:32.361]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:32.361]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.361]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.361]                             "release", "version")], collapse = " "), 
[13:23:32.361]                           hostname = base::Sys.info()[["nodename"]])
[13:23:32.361]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.361]                           info)
[13:23:32.361]                         info <- base::paste(info, collapse = "; ")
[13:23:32.361]                         if (!has_future) {
[13:23:32.361]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.361]                             info)
[13:23:32.361]                         }
[13:23:32.361]                         else {
[13:23:32.361]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.361]                             info, version)
[13:23:32.361]                         }
[13:23:32.361]                         base::stop(msg)
[13:23:32.361]                       }
[13:23:32.361]                     })
[13:23:32.361]                   }
[13:23:32.361]                   options(future.plan = NULL)
[13:23:32.361]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.361]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.361]                 }
[13:23:32.361]                 ...future.workdir <- getwd()
[13:23:32.361]             }
[13:23:32.361]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.361]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.361]         }
[13:23:32.361]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.361]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:32.361]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.361]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.361]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.361]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.361]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.361]             base::names(...future.oldOptions))
[13:23:32.361]     }
[13:23:32.361]     if (FALSE) {
[13:23:32.361]     }
[13:23:32.361]     else {
[13:23:32.361]         if (TRUE) {
[13:23:32.361]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.361]                 open = "w")
[13:23:32.361]         }
[13:23:32.361]         else {
[13:23:32.361]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.361]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.361]         }
[13:23:32.361]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.361]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.361]             base::sink(type = "output", split = FALSE)
[13:23:32.361]             base::close(...future.stdout)
[13:23:32.361]         }, add = TRUE)
[13:23:32.361]     }
[13:23:32.361]     ...future.frame <- base::sys.nframe()
[13:23:32.361]     ...future.conditions <- base::list()
[13:23:32.361]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.361]     if (FALSE) {
[13:23:32.361]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.361]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.361]     }
[13:23:32.361]     ...future.result <- base::tryCatch({
[13:23:32.361]         base::withCallingHandlers({
[13:23:32.361]             ...future.value <- base::withVisible(base::local(1))
[13:23:32.361]             future::FutureResult(value = ...future.value$value, 
[13:23:32.361]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.361]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.361]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.361]                     ...future.globalenv.names))
[13:23:32.361]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.361]         }, condition = base::local({
[13:23:32.361]             c <- base::c
[13:23:32.361]             inherits <- base::inherits
[13:23:32.361]             invokeRestart <- base::invokeRestart
[13:23:32.361]             length <- base::length
[13:23:32.361]             list <- base::list
[13:23:32.361]             seq.int <- base::seq.int
[13:23:32.361]             signalCondition <- base::signalCondition
[13:23:32.361]             sys.calls <- base::sys.calls
[13:23:32.361]             `[[` <- base::`[[`
[13:23:32.361]             `+` <- base::`+`
[13:23:32.361]             `<<-` <- base::`<<-`
[13:23:32.361]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.361]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.361]                   3L)]
[13:23:32.361]             }
[13:23:32.361]             function(cond) {
[13:23:32.361]                 is_error <- inherits(cond, "error")
[13:23:32.361]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.361]                   NULL)
[13:23:32.361]                 if (is_error) {
[13:23:32.361]                   sessionInformation <- function() {
[13:23:32.361]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.361]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.361]                       search = base::search(), system = base::Sys.info())
[13:23:32.361]                   }
[13:23:32.361]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.361]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.361]                     cond$call), session = sessionInformation(), 
[13:23:32.361]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.361]                   signalCondition(cond)
[13:23:32.361]                 }
[13:23:32.361]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.361]                 "immediateCondition"))) {
[13:23:32.361]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.361]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.361]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.361]                   if (TRUE && !signal) {
[13:23:32.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.361]                     {
[13:23:32.361]                       inherits <- base::inherits
[13:23:32.361]                       invokeRestart <- base::invokeRestart
[13:23:32.361]                       is.null <- base::is.null
[13:23:32.361]                       muffled <- FALSE
[13:23:32.361]                       if (inherits(cond, "message")) {
[13:23:32.361]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.361]                         if (muffled) 
[13:23:32.361]                           invokeRestart("muffleMessage")
[13:23:32.361]                       }
[13:23:32.361]                       else if (inherits(cond, "warning")) {
[13:23:32.361]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.361]                         if (muffled) 
[13:23:32.361]                           invokeRestart("muffleWarning")
[13:23:32.361]                       }
[13:23:32.361]                       else if (inherits(cond, "condition")) {
[13:23:32.361]                         if (!is.null(pattern)) {
[13:23:32.361]                           computeRestarts <- base::computeRestarts
[13:23:32.361]                           grepl <- base::grepl
[13:23:32.361]                           restarts <- computeRestarts(cond)
[13:23:32.361]                           for (restart in restarts) {
[13:23:32.361]                             name <- restart$name
[13:23:32.361]                             if (is.null(name)) 
[13:23:32.361]                               next
[13:23:32.361]                             if (!grepl(pattern, name)) 
[13:23:32.361]                               next
[13:23:32.361]                             invokeRestart(restart)
[13:23:32.361]                             muffled <- TRUE
[13:23:32.361]                             break
[13:23:32.361]                           }
[13:23:32.361]                         }
[13:23:32.361]                       }
[13:23:32.361]                       invisible(muffled)
[13:23:32.361]                     }
[13:23:32.361]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.361]                   }
[13:23:32.361]                 }
[13:23:32.361]                 else {
[13:23:32.361]                   if (TRUE) {
[13:23:32.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.361]                     {
[13:23:32.361]                       inherits <- base::inherits
[13:23:32.361]                       invokeRestart <- base::invokeRestart
[13:23:32.361]                       is.null <- base::is.null
[13:23:32.361]                       muffled <- FALSE
[13:23:32.361]                       if (inherits(cond, "message")) {
[13:23:32.361]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.361]                         if (muffled) 
[13:23:32.361]                           invokeRestart("muffleMessage")
[13:23:32.361]                       }
[13:23:32.361]                       else if (inherits(cond, "warning")) {
[13:23:32.361]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.361]                         if (muffled) 
[13:23:32.361]                           invokeRestart("muffleWarning")
[13:23:32.361]                       }
[13:23:32.361]                       else if (inherits(cond, "condition")) {
[13:23:32.361]                         if (!is.null(pattern)) {
[13:23:32.361]                           computeRestarts <- base::computeRestarts
[13:23:32.361]                           grepl <- base::grepl
[13:23:32.361]                           restarts <- computeRestarts(cond)
[13:23:32.361]                           for (restart in restarts) {
[13:23:32.361]                             name <- restart$name
[13:23:32.361]                             if (is.null(name)) 
[13:23:32.361]                               next
[13:23:32.361]                             if (!grepl(pattern, name)) 
[13:23:32.361]                               next
[13:23:32.361]                             invokeRestart(restart)
[13:23:32.361]                             muffled <- TRUE
[13:23:32.361]                             break
[13:23:32.361]                           }
[13:23:32.361]                         }
[13:23:32.361]                       }
[13:23:32.361]                       invisible(muffled)
[13:23:32.361]                     }
[13:23:32.361]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.361]                   }
[13:23:32.361]                 }
[13:23:32.361]             }
[13:23:32.361]         }))
[13:23:32.361]     }, error = function(ex) {
[13:23:32.361]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.361]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.361]                 ...future.rng), started = ...future.startTime, 
[13:23:32.361]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.361]             version = "1.8"), class = "FutureResult")
[13:23:32.361]     }, finally = {
[13:23:32.361]         if (!identical(...future.workdir, getwd())) 
[13:23:32.361]             setwd(...future.workdir)
[13:23:32.361]         {
[13:23:32.361]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.361]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.361]             }
[13:23:32.361]             base::options(...future.oldOptions)
[13:23:32.361]             if (.Platform$OS.type == "windows") {
[13:23:32.361]                 old_names <- names(...future.oldEnvVars)
[13:23:32.361]                 envs <- base::Sys.getenv()
[13:23:32.361]                 names <- names(envs)
[13:23:32.361]                 common <- intersect(names, old_names)
[13:23:32.361]                 added <- setdiff(names, old_names)
[13:23:32.361]                 removed <- setdiff(old_names, names)
[13:23:32.361]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.361]                   envs[common]]
[13:23:32.361]                 NAMES <- toupper(changed)
[13:23:32.361]                 args <- list()
[13:23:32.361]                 for (kk in seq_along(NAMES)) {
[13:23:32.361]                   name <- changed[[kk]]
[13:23:32.361]                   NAME <- NAMES[[kk]]
[13:23:32.361]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.361]                     next
[13:23:32.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.361]                 }
[13:23:32.361]                 NAMES <- toupper(added)
[13:23:32.361]                 for (kk in seq_along(NAMES)) {
[13:23:32.361]                   name <- added[[kk]]
[13:23:32.361]                   NAME <- NAMES[[kk]]
[13:23:32.361]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.361]                     next
[13:23:32.361]                   args[[name]] <- ""
[13:23:32.361]                 }
[13:23:32.361]                 NAMES <- toupper(removed)
[13:23:32.361]                 for (kk in seq_along(NAMES)) {
[13:23:32.361]                   name <- removed[[kk]]
[13:23:32.361]                   NAME <- NAMES[[kk]]
[13:23:32.361]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.361]                     next
[13:23:32.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.361]                 }
[13:23:32.361]                 if (length(args) > 0) 
[13:23:32.361]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.361]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.361]             }
[13:23:32.361]             else {
[13:23:32.361]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.361]             }
[13:23:32.361]             {
[13:23:32.361]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.361]                   0L) {
[13:23:32.361]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.361]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.361]                   base::options(opts)
[13:23:32.361]                 }
[13:23:32.361]                 {
[13:23:32.361]                   {
[13:23:32.361]                     NULL
[13:23:32.361]                     RNGkind("Mersenne-Twister")
[13:23:32.361]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.361]                       inherits = FALSE)
[13:23:32.361]                   }
[13:23:32.361]                   options(future.plan = NULL)
[13:23:32.361]                   if (is.na(NA_character_)) 
[13:23:32.361]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.361]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.361]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.361]                   {
[13:23:32.361]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.361]                     if (!future$lazy) 
[13:23:32.361]                       future <- run(future)
[13:23:32.361]                     invisible(future)
[13:23:32.361]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.361]                 }
[13:23:32.361]             }
[13:23:32.361]         }
[13:23:32.361]     })
[13:23:32.361]     if (TRUE) {
[13:23:32.361]         base::sink(type = "output", split = FALSE)
[13:23:32.361]         if (TRUE) {
[13:23:32.361]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.361]         }
[13:23:32.361]         else {
[13:23:32.361]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.361]         }
[13:23:32.361]         base::close(...future.stdout)
[13:23:32.361]         ...future.stdout <- NULL
[13:23:32.361]     }
[13:23:32.361]     ...future.result$conditions <- ...future.conditions
[13:23:32.361]     ...future.result$finished <- base::Sys.time()
[13:23:32.361]     ...future.result
[13:23:32.361] }
[13:23:32.363] plan(): Setting new future strategy stack:
[13:23:32.364] List of future strategies:
[13:23:32.364] 1. sequential:
[13:23:32.364]    - args: function (..., envir = parent.frame())
[13:23:32.364]    - tweaked: FALSE
[13:23:32.364]    - call: NULL
[13:23:32.364] plan(): nbrOfWorkers() = 1
[13:23:32.367] plan(): Setting new future strategy stack:
[13:23:32.367] List of future strategies:
[13:23:32.367] 1. sequential:
[13:23:32.367]    - args: function (..., envir = parent.frame())
[13:23:32.367]    - tweaked: FALSE
[13:23:32.367]    - call: plan(strategy)
[13:23:32.367] plan(): nbrOfWorkers() = 1
[13:23:32.368] SequentialFuture started (and completed)
[13:23:32.368] - Launch lazy future ... done
[13:23:32.368] run() for ‘SequentialFuture’ ... done
[13:23:32.368] resolved() for ‘SequentialFuture’ ...
[13:23:32.368] - state: ‘finished’
[13:23:32.368] - run: TRUE
[13:23:32.369] - result: ‘FutureResult’
[13:23:32.369] resolved() for ‘SequentialFuture’ ... done
[13:23:32.369] Future #1
[13:23:32.369] resolved() for ‘SequentialFuture’ ...
[13:23:32.369] - state: ‘finished’
[13:23:32.369] - run: TRUE
[13:23:32.369] - result: ‘FutureResult’
[13:23:32.369] resolved() for ‘SequentialFuture’ ... done
[13:23:32.370] A SequentialFuture was resolved
[13:23:32.370]  length: 0 (resolved future 1)
[13:23:32.370] resolve() on list ... DONE
[13:23:32.370] - globals: [1] ‘a’
[13:23:32.370] Resolving futures part of globals (recursively) ... DONE
[13:23:32.372] The total size of the 1 globals is 1.54 MiB (1616080 bytes)
[13:23:32.372] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.54 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.54 MiB of class ‘environment’)
[13:23:32.373] - globals: [1] ‘a’
[13:23:32.373] - packages: [1] ‘future’
[13:23:32.373] getGlobalsAndPackages() ... DONE
[13:23:32.373] run() for ‘Future’ ...
[13:23:32.373] - state: ‘created’
[13:23:32.373] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.374] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.374] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.374]   - Field: ‘label’
[13:23:32.374]   - Field: ‘local’
[13:23:32.374]   - Field: ‘owner’
[13:23:32.374]   - Field: ‘envir’
[13:23:32.374]   - Field: ‘packages’
[13:23:32.374]   - Field: ‘gc’
[13:23:32.375]   - Field: ‘conditions’
[13:23:32.375]   - Field: ‘expr’
[13:23:32.375]   - Field: ‘uuid’
[13:23:32.375]   - Field: ‘seed’
[13:23:32.375]   - Field: ‘version’
[13:23:32.375]   - Field: ‘result’
[13:23:32.375]   - Field: ‘asynchronous’
[13:23:32.375]   - Field: ‘calls’
[13:23:32.375]   - Field: ‘globals’
[13:23:32.375]   - Field: ‘stdout’
[13:23:32.375]   - Field: ‘earlySignal’
[13:23:32.376]   - Field: ‘lazy’
[13:23:32.376]   - Field: ‘state’
[13:23:32.376] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.376] - Launch lazy future ...
[13:23:32.376] Packages needed by the future expression (n = 1): ‘future’
[13:23:32.376] Packages needed by future strategies (n = 0): <none>
[13:23:32.377] {
[13:23:32.377]     {
[13:23:32.377]         {
[13:23:32.377]             ...future.startTime <- base::Sys.time()
[13:23:32.377]             {
[13:23:32.377]                 {
[13:23:32.377]                   {
[13:23:32.377]                     {
[13:23:32.377]                       base::local({
[13:23:32.377]                         has_future <- base::requireNamespace("future", 
[13:23:32.377]                           quietly = TRUE)
[13:23:32.377]                         if (has_future) {
[13:23:32.377]                           ns <- base::getNamespace("future")
[13:23:32.377]                           version <- ns[[".package"]][["version"]]
[13:23:32.377]                           if (is.null(version)) 
[13:23:32.377]                             version <- utils::packageVersion("future")
[13:23:32.377]                         }
[13:23:32.377]                         else {
[13:23:32.377]                           version <- NULL
[13:23:32.377]                         }
[13:23:32.377]                         if (!has_future || version < "1.8.0") {
[13:23:32.377]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.377]                             "", base::R.version$version.string), 
[13:23:32.377]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:32.377]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.377]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.377]                               "release", "version")], collapse = " "), 
[13:23:32.377]                             hostname = base::Sys.info()[["nodename"]])
[13:23:32.377]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.377]                             info)
[13:23:32.377]                           info <- base::paste(info, collapse = "; ")
[13:23:32.377]                           if (!has_future) {
[13:23:32.377]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.377]                               info)
[13:23:32.377]                           }
[13:23:32.377]                           else {
[13:23:32.377]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.377]                               info, version)
[13:23:32.377]                           }
[13:23:32.377]                           base::stop(msg)
[13:23:32.377]                         }
[13:23:32.377]                       })
[13:23:32.377]                     }
[13:23:32.377]                     base::local({
[13:23:32.377]                       for (pkg in "future") {
[13:23:32.377]                         base::loadNamespace(pkg)
[13:23:32.377]                         base::library(pkg, character.only = TRUE)
[13:23:32.377]                       }
[13:23:32.377]                     })
[13:23:32.377]                   }
[13:23:32.377]                   options(future.plan = NULL)
[13:23:32.377]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.377]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.377]                 }
[13:23:32.377]                 ...future.workdir <- getwd()
[13:23:32.377]             }
[13:23:32.377]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.377]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.377]         }
[13:23:32.377]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.377]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:32.377]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.377]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.377]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.377]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.377]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.377]             base::names(...future.oldOptions))
[13:23:32.377]     }
[13:23:32.377]     if (FALSE) {
[13:23:32.377]     }
[13:23:32.377]     else {
[13:23:32.377]         if (TRUE) {
[13:23:32.377]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.377]                 open = "w")
[13:23:32.377]         }
[13:23:32.377]         else {
[13:23:32.377]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.377]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.377]         }
[13:23:32.377]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.377]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.377]             base::sink(type = "output", split = FALSE)
[13:23:32.377]             base::close(...future.stdout)
[13:23:32.377]         }, add = TRUE)
[13:23:32.377]     }
[13:23:32.377]     ...future.frame <- base::sys.nframe()
[13:23:32.377]     ...future.conditions <- base::list()
[13:23:32.377]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.377]     if (FALSE) {
[13:23:32.377]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.377]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.377]     }
[13:23:32.377]     ...future.result <- base::tryCatch({
[13:23:32.377]         base::withCallingHandlers({
[13:23:32.377]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:23:32.377]                 1))
[13:23:32.377]             future::FutureResult(value = ...future.value$value, 
[13:23:32.377]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.377]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.377]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.377]                     ...future.globalenv.names))
[13:23:32.377]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.377]         }, condition = base::local({
[13:23:32.377]             c <- base::c
[13:23:32.377]             inherits <- base::inherits
[13:23:32.377]             invokeRestart <- base::invokeRestart
[13:23:32.377]             length <- base::length
[13:23:32.377]             list <- base::list
[13:23:32.377]             seq.int <- base::seq.int
[13:23:32.377]             signalCondition <- base::signalCondition
[13:23:32.377]             sys.calls <- base::sys.calls
[13:23:32.377]             `[[` <- base::`[[`
[13:23:32.377]             `+` <- base::`+`
[13:23:32.377]             `<<-` <- base::`<<-`
[13:23:32.377]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.377]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.377]                   3L)]
[13:23:32.377]             }
[13:23:32.377]             function(cond) {
[13:23:32.377]                 is_error <- inherits(cond, "error")
[13:23:32.377]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.377]                   NULL)
[13:23:32.377]                 if (is_error) {
[13:23:32.377]                   sessionInformation <- function() {
[13:23:32.377]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.377]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.377]                       search = base::search(), system = base::Sys.info())
[13:23:32.377]                   }
[13:23:32.377]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.377]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.377]                     cond$call), session = sessionInformation(), 
[13:23:32.377]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.377]                   signalCondition(cond)
[13:23:32.377]                 }
[13:23:32.377]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.377]                 "immediateCondition"))) {
[13:23:32.377]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.377]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.377]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.377]                   if (TRUE && !signal) {
[13:23:32.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.377]                     {
[13:23:32.377]                       inherits <- base::inherits
[13:23:32.377]                       invokeRestart <- base::invokeRestart
[13:23:32.377]                       is.null <- base::is.null
[13:23:32.377]                       muffled <- FALSE
[13:23:32.377]                       if (inherits(cond, "message")) {
[13:23:32.377]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.377]                         if (muffled) 
[13:23:32.377]                           invokeRestart("muffleMessage")
[13:23:32.377]                       }
[13:23:32.377]                       else if (inherits(cond, "warning")) {
[13:23:32.377]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.377]                         if (muffled) 
[13:23:32.377]                           invokeRestart("muffleWarning")
[13:23:32.377]                       }
[13:23:32.377]                       else if (inherits(cond, "condition")) {
[13:23:32.377]                         if (!is.null(pattern)) {
[13:23:32.377]                           computeRestarts <- base::computeRestarts
[13:23:32.377]                           grepl <- base::grepl
[13:23:32.377]                           restarts <- computeRestarts(cond)
[13:23:32.377]                           for (restart in restarts) {
[13:23:32.377]                             name <- restart$name
[13:23:32.377]                             if (is.null(name)) 
[13:23:32.377]                               next
[13:23:32.377]                             if (!grepl(pattern, name)) 
[13:23:32.377]                               next
[13:23:32.377]                             invokeRestart(restart)
[13:23:32.377]                             muffled <- TRUE
[13:23:32.377]                             break
[13:23:32.377]                           }
[13:23:32.377]                         }
[13:23:32.377]                       }
[13:23:32.377]                       invisible(muffled)
[13:23:32.377]                     }
[13:23:32.377]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.377]                   }
[13:23:32.377]                 }
[13:23:32.377]                 else {
[13:23:32.377]                   if (TRUE) {
[13:23:32.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.377]                     {
[13:23:32.377]                       inherits <- base::inherits
[13:23:32.377]                       invokeRestart <- base::invokeRestart
[13:23:32.377]                       is.null <- base::is.null
[13:23:32.377]                       muffled <- FALSE
[13:23:32.377]                       if (inherits(cond, "message")) {
[13:23:32.377]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.377]                         if (muffled) 
[13:23:32.377]                           invokeRestart("muffleMessage")
[13:23:32.377]                       }
[13:23:32.377]                       else if (inherits(cond, "warning")) {
[13:23:32.377]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.377]                         if (muffled) 
[13:23:32.377]                           invokeRestart("muffleWarning")
[13:23:32.377]                       }
[13:23:32.377]                       else if (inherits(cond, "condition")) {
[13:23:32.377]                         if (!is.null(pattern)) {
[13:23:32.377]                           computeRestarts <- base::computeRestarts
[13:23:32.377]                           grepl <- base::grepl
[13:23:32.377]                           restarts <- computeRestarts(cond)
[13:23:32.377]                           for (restart in restarts) {
[13:23:32.377]                             name <- restart$name
[13:23:32.377]                             if (is.null(name)) 
[13:23:32.377]                               next
[13:23:32.377]                             if (!grepl(pattern, name)) 
[13:23:32.377]                               next
[13:23:32.377]                             invokeRestart(restart)
[13:23:32.377]                             muffled <- TRUE
[13:23:32.377]                             break
[13:23:32.377]                           }
[13:23:32.377]                         }
[13:23:32.377]                       }
[13:23:32.377]                       invisible(muffled)
[13:23:32.377]                     }
[13:23:32.377]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.377]                   }
[13:23:32.377]                 }
[13:23:32.377]             }
[13:23:32.377]         }))
[13:23:32.377]     }, error = function(ex) {
[13:23:32.377]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.377]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.377]                 ...future.rng), started = ...future.startTime, 
[13:23:32.377]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.377]             version = "1.8"), class = "FutureResult")
[13:23:32.377]     }, finally = {
[13:23:32.377]         if (!identical(...future.workdir, getwd())) 
[13:23:32.377]             setwd(...future.workdir)
[13:23:32.377]         {
[13:23:32.377]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.377]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.377]             }
[13:23:32.377]             base::options(...future.oldOptions)
[13:23:32.377]             if (.Platform$OS.type == "windows") {
[13:23:32.377]                 old_names <- names(...future.oldEnvVars)
[13:23:32.377]                 envs <- base::Sys.getenv()
[13:23:32.377]                 names <- names(envs)
[13:23:32.377]                 common <- intersect(names, old_names)
[13:23:32.377]                 added <- setdiff(names, old_names)
[13:23:32.377]                 removed <- setdiff(old_names, names)
[13:23:32.377]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.377]                   envs[common]]
[13:23:32.377]                 NAMES <- toupper(changed)
[13:23:32.377]                 args <- list()
[13:23:32.377]                 for (kk in seq_along(NAMES)) {
[13:23:32.377]                   name <- changed[[kk]]
[13:23:32.377]                   NAME <- NAMES[[kk]]
[13:23:32.377]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.377]                     next
[13:23:32.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.377]                 }
[13:23:32.377]                 NAMES <- toupper(added)
[13:23:32.377]                 for (kk in seq_along(NAMES)) {
[13:23:32.377]                   name <- added[[kk]]
[13:23:32.377]                   NAME <- NAMES[[kk]]
[13:23:32.377]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.377]                     next
[13:23:32.377]                   args[[name]] <- ""
[13:23:32.377]                 }
[13:23:32.377]                 NAMES <- toupper(removed)
[13:23:32.377]                 for (kk in seq_along(NAMES)) {
[13:23:32.377]                   name <- removed[[kk]]
[13:23:32.377]                   NAME <- NAMES[[kk]]
[13:23:32.377]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.377]                     next
[13:23:32.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.377]                 }
[13:23:32.377]                 if (length(args) > 0) 
[13:23:32.377]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.377]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.377]             }
[13:23:32.377]             else {
[13:23:32.377]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.377]             }
[13:23:32.377]             {
[13:23:32.377]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.377]                   0L) {
[13:23:32.377]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.377]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.377]                   base::options(opts)
[13:23:32.377]                 }
[13:23:32.377]                 {
[13:23:32.377]                   {
[13:23:32.377]                     NULL
[13:23:32.377]                     RNGkind("Mersenne-Twister")
[13:23:32.377]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.377]                       inherits = FALSE)
[13:23:32.377]                   }
[13:23:32.377]                   options(future.plan = NULL)
[13:23:32.377]                   if (is.na(NA_character_)) 
[13:23:32.377]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.377]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.377]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.377]                   {
[13:23:32.377]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.377]                     if (!future$lazy) 
[13:23:32.377]                       future <- run(future)
[13:23:32.377]                     invisible(future)
[13:23:32.377]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.377]                 }
[13:23:32.377]             }
[13:23:32.377]         }
[13:23:32.377]     })
[13:23:32.377]     if (TRUE) {
[13:23:32.377]         base::sink(type = "output", split = FALSE)
[13:23:32.377]         if (TRUE) {
[13:23:32.377]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.377]         }
[13:23:32.377]         else {
[13:23:32.377]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.377]         }
[13:23:32.377]         base::close(...future.stdout)
[13:23:32.377]         ...future.stdout <- NULL
[13:23:32.377]     }
[13:23:32.377]     ...future.result$conditions <- ...future.conditions
[13:23:32.377]     ...future.result$finished <- base::Sys.time()
[13:23:32.377]     ...future.result
[13:23:32.377] }
[13:23:32.379] assign_globals() ...
[13:23:32.379] List of 1
[13:23:32.379]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5589bf348340> 
[13:23:32.379]  - attr(*, "where")=List of 1
[13:23:32.379]   ..$ a:<environment: R_EmptyEnv> 
[13:23:32.379]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.379]  - attr(*, "resolved")= logi TRUE
[13:23:32.379]  - attr(*, "total_size")= num 1616080
[13:23:32.379]  - attr(*, "already-done")= logi TRUE
[13:23:32.381] - copied ‘a’ to environment
[13:23:32.382] assign_globals() ... done
[13:23:32.382] plan(): Setting new future strategy stack:
[13:23:32.382] List of future strategies:
[13:23:32.382] 1. sequential:
[13:23:32.382]    - args: function (..., envir = parent.frame())
[13:23:32.382]    - tweaked: FALSE
[13:23:32.382]    - call: NULL
[13:23:32.383] plan(): nbrOfWorkers() = 1
[13:23:32.383] plan(): Setting new future strategy stack:
[13:23:32.384] List of future strategies:
[13:23:32.384] 1. sequential:
[13:23:32.384]    - args: function (..., envir = parent.frame())
[13:23:32.384]    - tweaked: FALSE
[13:23:32.384]    - call: plan(strategy)
[13:23:32.384] plan(): nbrOfWorkers() = 1
[13:23:32.384] SequentialFuture started (and completed)
[13:23:32.384] - Launch lazy future ... done
[13:23:32.384] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.385] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.385] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:32.385] 
[13:23:32.386] Searching for globals ... DONE
[13:23:32.386] - globals: [0] <none>
[13:23:32.386] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.386] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.386] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:32.387] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:32.387] Searching for globals ... DONE
[13:23:32.387] Resolving globals: TRUE
[13:23:32.387] Resolving any globals that are futures ...
[13:23:32.388] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:32.388] Resolving any globals that are futures ... DONE
[13:23:32.388] Resolving futures part of globals (recursively) ...
[13:23:32.388] resolve() on list ...
[13:23:32.388]  recursive: 99
[13:23:32.388]  length: 1
[13:23:32.388]  elements: ‘a’
[13:23:32.389] run() for ‘Future’ ...
[13:23:32.389] - state: ‘created’
[13:23:32.389] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.389] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.389] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.389]   - Field: ‘label’
[13:23:32.389]   - Field: ‘local’
[13:23:32.390]   - Field: ‘owner’
[13:23:32.390]   - Field: ‘envir’
[13:23:32.390]   - Field: ‘packages’
[13:23:32.390]   - Field: ‘gc’
[13:23:32.390]   - Field: ‘conditions’
[13:23:32.390]   - Field: ‘expr’
[13:23:32.390]   - Field: ‘uuid’
[13:23:32.390]   - Field: ‘seed’
[13:23:32.390]   - Field: ‘version’
[13:23:32.390]   - Field: ‘result’
[13:23:32.391]   - Field: ‘asynchronous’
[13:23:32.391]   - Field: ‘calls’
[13:23:32.391]   - Field: ‘globals’
[13:23:32.391]   - Field: ‘stdout’
[13:23:32.391]   - Field: ‘earlySignal’
[13:23:32.391]   - Field: ‘lazy’
[13:23:32.391]   - Field: ‘state’
[13:23:32.391] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.391] - Launch lazy future ...
[13:23:32.391] Packages needed by the future expression (n = 0): <none>
[13:23:32.392] Packages needed by future strategies (n = 0): <none>
[13:23:32.392] {
[13:23:32.392]     {
[13:23:32.392]         {
[13:23:32.392]             ...future.startTime <- base::Sys.time()
[13:23:32.392]             {
[13:23:32.392]                 {
[13:23:32.392]                   {
[13:23:32.392]                     base::local({
[13:23:32.392]                       has_future <- base::requireNamespace("future", 
[13:23:32.392]                         quietly = TRUE)
[13:23:32.392]                       if (has_future) {
[13:23:32.392]                         ns <- base::getNamespace("future")
[13:23:32.392]                         version <- ns[[".package"]][["version"]]
[13:23:32.392]                         if (is.null(version)) 
[13:23:32.392]                           version <- utils::packageVersion("future")
[13:23:32.392]                       }
[13:23:32.392]                       else {
[13:23:32.392]                         version <- NULL
[13:23:32.392]                       }
[13:23:32.392]                       if (!has_future || version < "1.8.0") {
[13:23:32.392]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.392]                           "", base::R.version$version.string), 
[13:23:32.392]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:32.392]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.392]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.392]                             "release", "version")], collapse = " "), 
[13:23:32.392]                           hostname = base::Sys.info()[["nodename"]])
[13:23:32.392]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.392]                           info)
[13:23:32.392]                         info <- base::paste(info, collapse = "; ")
[13:23:32.392]                         if (!has_future) {
[13:23:32.392]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.392]                             info)
[13:23:32.392]                         }
[13:23:32.392]                         else {
[13:23:32.392]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.392]                             info, version)
[13:23:32.392]                         }
[13:23:32.392]                         base::stop(msg)
[13:23:32.392]                       }
[13:23:32.392]                     })
[13:23:32.392]                   }
[13:23:32.392]                   options(future.plan = NULL)
[13:23:32.392]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.392]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.392]                 }
[13:23:32.392]                 ...future.workdir <- getwd()
[13:23:32.392]             }
[13:23:32.392]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.392]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.392]         }
[13:23:32.392]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.392]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:32.392]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.392]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.392]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.392]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.392]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.392]             base::names(...future.oldOptions))
[13:23:32.392]     }
[13:23:32.392]     if (FALSE) {
[13:23:32.392]     }
[13:23:32.392]     else {
[13:23:32.392]         if (TRUE) {
[13:23:32.392]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.392]                 open = "w")
[13:23:32.392]         }
[13:23:32.392]         else {
[13:23:32.392]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.392]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.392]         }
[13:23:32.392]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.392]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.392]             base::sink(type = "output", split = FALSE)
[13:23:32.392]             base::close(...future.stdout)
[13:23:32.392]         }, add = TRUE)
[13:23:32.392]     }
[13:23:32.392]     ...future.frame <- base::sys.nframe()
[13:23:32.392]     ...future.conditions <- base::list()
[13:23:32.392]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.392]     if (FALSE) {
[13:23:32.392]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.392]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.392]     }
[13:23:32.392]     ...future.result <- base::tryCatch({
[13:23:32.392]         base::withCallingHandlers({
[13:23:32.392]             ...future.value <- base::withVisible(base::local(1))
[13:23:32.392]             future::FutureResult(value = ...future.value$value, 
[13:23:32.392]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.392]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.392]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.392]                     ...future.globalenv.names))
[13:23:32.392]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.392]         }, condition = base::local({
[13:23:32.392]             c <- base::c
[13:23:32.392]             inherits <- base::inherits
[13:23:32.392]             invokeRestart <- base::invokeRestart
[13:23:32.392]             length <- base::length
[13:23:32.392]             list <- base::list
[13:23:32.392]             seq.int <- base::seq.int
[13:23:32.392]             signalCondition <- base::signalCondition
[13:23:32.392]             sys.calls <- base::sys.calls
[13:23:32.392]             `[[` <- base::`[[`
[13:23:32.392]             `+` <- base::`+`
[13:23:32.392]             `<<-` <- base::`<<-`
[13:23:32.392]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.392]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.392]                   3L)]
[13:23:32.392]             }
[13:23:32.392]             function(cond) {
[13:23:32.392]                 is_error <- inherits(cond, "error")
[13:23:32.392]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.392]                   NULL)
[13:23:32.392]                 if (is_error) {
[13:23:32.392]                   sessionInformation <- function() {
[13:23:32.392]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.392]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.392]                       search = base::search(), system = base::Sys.info())
[13:23:32.392]                   }
[13:23:32.392]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.392]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.392]                     cond$call), session = sessionInformation(), 
[13:23:32.392]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.392]                   signalCondition(cond)
[13:23:32.392]                 }
[13:23:32.392]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.392]                 "immediateCondition"))) {
[13:23:32.392]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.392]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.392]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.392]                   if (TRUE && !signal) {
[13:23:32.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.392]                     {
[13:23:32.392]                       inherits <- base::inherits
[13:23:32.392]                       invokeRestart <- base::invokeRestart
[13:23:32.392]                       is.null <- base::is.null
[13:23:32.392]                       muffled <- FALSE
[13:23:32.392]                       if (inherits(cond, "message")) {
[13:23:32.392]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.392]                         if (muffled) 
[13:23:32.392]                           invokeRestart("muffleMessage")
[13:23:32.392]                       }
[13:23:32.392]                       else if (inherits(cond, "warning")) {
[13:23:32.392]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.392]                         if (muffled) 
[13:23:32.392]                           invokeRestart("muffleWarning")
[13:23:32.392]                       }
[13:23:32.392]                       else if (inherits(cond, "condition")) {
[13:23:32.392]                         if (!is.null(pattern)) {
[13:23:32.392]                           computeRestarts <- base::computeRestarts
[13:23:32.392]                           grepl <- base::grepl
[13:23:32.392]                           restarts <- computeRestarts(cond)
[13:23:32.392]                           for (restart in restarts) {
[13:23:32.392]                             name <- restart$name
[13:23:32.392]                             if (is.null(name)) 
[13:23:32.392]                               next
[13:23:32.392]                             if (!grepl(pattern, name)) 
[13:23:32.392]                               next
[13:23:32.392]                             invokeRestart(restart)
[13:23:32.392]                             muffled <- TRUE
[13:23:32.392]                             break
[13:23:32.392]                           }
[13:23:32.392]                         }
[13:23:32.392]                       }
[13:23:32.392]                       invisible(muffled)
[13:23:32.392]                     }
[13:23:32.392]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.392]                   }
[13:23:32.392]                 }
[13:23:32.392]                 else {
[13:23:32.392]                   if (TRUE) {
[13:23:32.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.392]                     {
[13:23:32.392]                       inherits <- base::inherits
[13:23:32.392]                       invokeRestart <- base::invokeRestart
[13:23:32.392]                       is.null <- base::is.null
[13:23:32.392]                       muffled <- FALSE
[13:23:32.392]                       if (inherits(cond, "message")) {
[13:23:32.392]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.392]                         if (muffled) 
[13:23:32.392]                           invokeRestart("muffleMessage")
[13:23:32.392]                       }
[13:23:32.392]                       else if (inherits(cond, "warning")) {
[13:23:32.392]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.392]                         if (muffled) 
[13:23:32.392]                           invokeRestart("muffleWarning")
[13:23:32.392]                       }
[13:23:32.392]                       else if (inherits(cond, "condition")) {
[13:23:32.392]                         if (!is.null(pattern)) {
[13:23:32.392]                           computeRestarts <- base::computeRestarts
[13:23:32.392]                           grepl <- base::grepl
[13:23:32.392]                           restarts <- computeRestarts(cond)
[13:23:32.392]                           for (restart in restarts) {
[13:23:32.392]                             name <- restart$name
[13:23:32.392]                             if (is.null(name)) 
[13:23:32.392]                               next
[13:23:32.392]                             if (!grepl(pattern, name)) 
[13:23:32.392]                               next
[13:23:32.392]                             invokeRestart(restart)
[13:23:32.392]                             muffled <- TRUE
[13:23:32.392]                             break
[13:23:32.392]                           }
[13:23:32.392]                         }
[13:23:32.392]                       }
[13:23:32.392]                       invisible(muffled)
[13:23:32.392]                     }
[13:23:32.392]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.392]                   }
[13:23:32.392]                 }
[13:23:32.392]             }
[13:23:32.392]         }))
[13:23:32.392]     }, error = function(ex) {
[13:23:32.392]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.392]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.392]                 ...future.rng), started = ...future.startTime, 
[13:23:32.392]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.392]             version = "1.8"), class = "FutureResult")
[13:23:32.392]     }, finally = {
[13:23:32.392]         if (!identical(...future.workdir, getwd())) 
[13:23:32.392]             setwd(...future.workdir)
[13:23:32.392]         {
[13:23:32.392]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.392]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.392]             }
[13:23:32.392]             base::options(...future.oldOptions)
[13:23:32.392]             if (.Platform$OS.type == "windows") {
[13:23:32.392]                 old_names <- names(...future.oldEnvVars)
[13:23:32.392]                 envs <- base::Sys.getenv()
[13:23:32.392]                 names <- names(envs)
[13:23:32.392]                 common <- intersect(names, old_names)
[13:23:32.392]                 added <- setdiff(names, old_names)
[13:23:32.392]                 removed <- setdiff(old_names, names)
[13:23:32.392]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.392]                   envs[common]]
[13:23:32.392]                 NAMES <- toupper(changed)
[13:23:32.392]                 args <- list()
[13:23:32.392]                 for (kk in seq_along(NAMES)) {
[13:23:32.392]                   name <- changed[[kk]]
[13:23:32.392]                   NAME <- NAMES[[kk]]
[13:23:32.392]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.392]                     next
[13:23:32.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.392]                 }
[13:23:32.392]                 NAMES <- toupper(added)
[13:23:32.392]                 for (kk in seq_along(NAMES)) {
[13:23:32.392]                   name <- added[[kk]]
[13:23:32.392]                   NAME <- NAMES[[kk]]
[13:23:32.392]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.392]                     next
[13:23:32.392]                   args[[name]] <- ""
[13:23:32.392]                 }
[13:23:32.392]                 NAMES <- toupper(removed)
[13:23:32.392]                 for (kk in seq_along(NAMES)) {
[13:23:32.392]                   name <- removed[[kk]]
[13:23:32.392]                   NAME <- NAMES[[kk]]
[13:23:32.392]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.392]                     next
[13:23:32.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.392]                 }
[13:23:32.392]                 if (length(args) > 0) 
[13:23:32.392]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.392]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.392]             }
[13:23:32.392]             else {
[13:23:32.392]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.392]             }
[13:23:32.392]             {
[13:23:32.392]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.392]                   0L) {
[13:23:32.392]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.392]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.392]                   base::options(opts)
[13:23:32.392]                 }
[13:23:32.392]                 {
[13:23:32.392]                   {
[13:23:32.392]                     NULL
[13:23:32.392]                     RNGkind("Mersenne-Twister")
[13:23:32.392]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.392]                       inherits = FALSE)
[13:23:32.392]                   }
[13:23:32.392]                   options(future.plan = NULL)
[13:23:32.392]                   if (is.na(NA_character_)) 
[13:23:32.392]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.392]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.392]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.392]                   {
[13:23:32.392]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.392]                     if (!future$lazy) 
[13:23:32.392]                       future <- run(future)
[13:23:32.392]                     invisible(future)
[13:23:32.392]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.392]                 }
[13:23:32.392]             }
[13:23:32.392]         }
[13:23:32.392]     })
[13:23:32.392]     if (TRUE) {
[13:23:32.392]         base::sink(type = "output", split = FALSE)
[13:23:32.392]         if (TRUE) {
[13:23:32.392]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.392]         }
[13:23:32.392]         else {
[13:23:32.392]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.392]         }
[13:23:32.392]         base::close(...future.stdout)
[13:23:32.392]         ...future.stdout <- NULL
[13:23:32.392]     }
[13:23:32.392]     ...future.result$conditions <- ...future.conditions
[13:23:32.392]     ...future.result$finished <- base::Sys.time()
[13:23:32.392]     ...future.result
[13:23:32.392] }
[13:23:32.394] plan(): Setting new future strategy stack:
[13:23:32.394] List of future strategies:
[13:23:32.394] 1. sequential:
[13:23:32.394]    - args: function (..., envir = parent.frame())
[13:23:32.394]    - tweaked: FALSE
[13:23:32.394]    - call: NULL
[13:23:32.394] plan(): nbrOfWorkers() = 1
[13:23:32.395] plan(): Setting new future strategy stack:
[13:23:32.395] List of future strategies:
[13:23:32.395] 1. sequential:
[13:23:32.395]    - args: function (..., envir = parent.frame())
[13:23:32.395]    - tweaked: FALSE
[13:23:32.395]    - call: plan(strategy)
[13:23:32.396] plan(): nbrOfWorkers() = 1
[13:23:32.396] SequentialFuture started (and completed)
[13:23:32.396] - Launch lazy future ... done
[13:23:32.396] run() for ‘SequentialFuture’ ... done
[13:23:32.396] resolved() for ‘SequentialFuture’ ...
[13:23:32.397] - state: ‘finished’
[13:23:32.397] - run: TRUE
[13:23:32.397] - result: ‘FutureResult’
[13:23:32.397] resolved() for ‘SequentialFuture’ ... done
[13:23:32.397] Future #1
[13:23:32.399] resolved() for ‘SequentialFuture’ ...
[13:23:32.399] - state: ‘finished’
[13:23:32.399] - run: TRUE
[13:23:32.399] - result: ‘FutureResult’
[13:23:32.399] resolved() for ‘SequentialFuture’ ... done
[13:23:32.400] A SequentialFuture was resolved
[13:23:32.400]  length: 0 (resolved future 1)
[13:23:32.400] resolve() on list ... DONE
[13:23:32.400] - globals: [1] ‘a’
[13:23:32.400] Resolving futures part of globals (recursively) ... DONE
[13:23:32.403] The total size of the 1 globals is 1.54 MiB (1616080 bytes)
[13:23:32.403] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.54 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.54 MiB of class ‘environment’)
[13:23:32.403] - globals: [1] ‘a’
[13:23:32.403] - packages: [1] ‘future’
[13:23:32.403] getGlobalsAndPackages() ... DONE
[13:23:32.404] run() for ‘Future’ ...
[13:23:32.404] - state: ‘created’
[13:23:32.404] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.404] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.404] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.404]   - Field: ‘label’
[13:23:32.404]   - Field: ‘local’
[13:23:32.405]   - Field: ‘owner’
[13:23:32.405]   - Field: ‘envir’
[13:23:32.405]   - Field: ‘packages’
[13:23:32.405]   - Field: ‘gc’
[13:23:32.405]   - Field: ‘conditions’
[13:23:32.405]   - Field: ‘expr’
[13:23:32.405]   - Field: ‘uuid’
[13:23:32.405]   - Field: ‘seed’
[13:23:32.405]   - Field: ‘version’
[13:23:32.405]   - Field: ‘result’
[13:23:32.406]   - Field: ‘asynchronous’
[13:23:32.406]   - Field: ‘calls’
[13:23:32.406]   - Field: ‘globals’
[13:23:32.406]   - Field: ‘stdout’
[13:23:32.406]   - Field: ‘earlySignal’
[13:23:32.406]   - Field: ‘lazy’
[13:23:32.406]   - Field: ‘state’
[13:23:32.406] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.406] - Launch lazy future ...
[13:23:32.407] Packages needed by the future expression (n = 1): ‘future’
[13:23:32.407] Packages needed by future strategies (n = 0): <none>
[13:23:32.407] {
[13:23:32.407]     {
[13:23:32.407]         {
[13:23:32.407]             ...future.startTime <- base::Sys.time()
[13:23:32.407]             {
[13:23:32.407]                 {
[13:23:32.407]                   {
[13:23:32.407]                     {
[13:23:32.407]                       base::local({
[13:23:32.407]                         has_future <- base::requireNamespace("future", 
[13:23:32.407]                           quietly = TRUE)
[13:23:32.407]                         if (has_future) {
[13:23:32.407]                           ns <- base::getNamespace("future")
[13:23:32.407]                           version <- ns[[".package"]][["version"]]
[13:23:32.407]                           if (is.null(version)) 
[13:23:32.407]                             version <- utils::packageVersion("future")
[13:23:32.407]                         }
[13:23:32.407]                         else {
[13:23:32.407]                           version <- NULL
[13:23:32.407]                         }
[13:23:32.407]                         if (!has_future || version < "1.8.0") {
[13:23:32.407]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.407]                             "", base::R.version$version.string), 
[13:23:32.407]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:32.407]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.407]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.407]                               "release", "version")], collapse = " "), 
[13:23:32.407]                             hostname = base::Sys.info()[["nodename"]])
[13:23:32.407]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.407]                             info)
[13:23:32.407]                           info <- base::paste(info, collapse = "; ")
[13:23:32.407]                           if (!has_future) {
[13:23:32.407]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.407]                               info)
[13:23:32.407]                           }
[13:23:32.407]                           else {
[13:23:32.407]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.407]                               info, version)
[13:23:32.407]                           }
[13:23:32.407]                           base::stop(msg)
[13:23:32.407]                         }
[13:23:32.407]                       })
[13:23:32.407]                     }
[13:23:32.407]                     base::local({
[13:23:32.407]                       for (pkg in "future") {
[13:23:32.407]                         base::loadNamespace(pkg)
[13:23:32.407]                         base::library(pkg, character.only = TRUE)
[13:23:32.407]                       }
[13:23:32.407]                     })
[13:23:32.407]                   }
[13:23:32.407]                   options(future.plan = NULL)
[13:23:32.407]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.407]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.407]                 }
[13:23:32.407]                 ...future.workdir <- getwd()
[13:23:32.407]             }
[13:23:32.407]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.407]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.407]         }
[13:23:32.407]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.407]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:32.407]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.407]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.407]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.407]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.407]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.407]             base::names(...future.oldOptions))
[13:23:32.407]     }
[13:23:32.407]     if (FALSE) {
[13:23:32.407]     }
[13:23:32.407]     else {
[13:23:32.407]         if (TRUE) {
[13:23:32.407]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.407]                 open = "w")
[13:23:32.407]         }
[13:23:32.407]         else {
[13:23:32.407]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.407]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.407]         }
[13:23:32.407]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.407]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.407]             base::sink(type = "output", split = FALSE)
[13:23:32.407]             base::close(...future.stdout)
[13:23:32.407]         }, add = TRUE)
[13:23:32.407]     }
[13:23:32.407]     ...future.frame <- base::sys.nframe()
[13:23:32.407]     ...future.conditions <- base::list()
[13:23:32.407]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.407]     if (FALSE) {
[13:23:32.407]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.407]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.407]     }
[13:23:32.407]     ...future.result <- base::tryCatch({
[13:23:32.407]         base::withCallingHandlers({
[13:23:32.407]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:23:32.407]                 1))
[13:23:32.407]             future::FutureResult(value = ...future.value$value, 
[13:23:32.407]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.407]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.407]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.407]                     ...future.globalenv.names))
[13:23:32.407]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.407]         }, condition = base::local({
[13:23:32.407]             c <- base::c
[13:23:32.407]             inherits <- base::inherits
[13:23:32.407]             invokeRestart <- base::invokeRestart
[13:23:32.407]             length <- base::length
[13:23:32.407]             list <- base::list
[13:23:32.407]             seq.int <- base::seq.int
[13:23:32.407]             signalCondition <- base::signalCondition
[13:23:32.407]             sys.calls <- base::sys.calls
[13:23:32.407]             `[[` <- base::`[[`
[13:23:32.407]             `+` <- base::`+`
[13:23:32.407]             `<<-` <- base::`<<-`
[13:23:32.407]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.407]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.407]                   3L)]
[13:23:32.407]             }
[13:23:32.407]             function(cond) {
[13:23:32.407]                 is_error <- inherits(cond, "error")
[13:23:32.407]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.407]                   NULL)
[13:23:32.407]                 if (is_error) {
[13:23:32.407]                   sessionInformation <- function() {
[13:23:32.407]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.407]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.407]                       search = base::search(), system = base::Sys.info())
[13:23:32.407]                   }
[13:23:32.407]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.407]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.407]                     cond$call), session = sessionInformation(), 
[13:23:32.407]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.407]                   signalCondition(cond)
[13:23:32.407]                 }
[13:23:32.407]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.407]                 "immediateCondition"))) {
[13:23:32.407]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.407]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.407]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.407]                   if (TRUE && !signal) {
[13:23:32.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.407]                     {
[13:23:32.407]                       inherits <- base::inherits
[13:23:32.407]                       invokeRestart <- base::invokeRestart
[13:23:32.407]                       is.null <- base::is.null
[13:23:32.407]                       muffled <- FALSE
[13:23:32.407]                       if (inherits(cond, "message")) {
[13:23:32.407]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.407]                         if (muffled) 
[13:23:32.407]                           invokeRestart("muffleMessage")
[13:23:32.407]                       }
[13:23:32.407]                       else if (inherits(cond, "warning")) {
[13:23:32.407]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.407]                         if (muffled) 
[13:23:32.407]                           invokeRestart("muffleWarning")
[13:23:32.407]                       }
[13:23:32.407]                       else if (inherits(cond, "condition")) {
[13:23:32.407]                         if (!is.null(pattern)) {
[13:23:32.407]                           computeRestarts <- base::computeRestarts
[13:23:32.407]                           grepl <- base::grepl
[13:23:32.407]                           restarts <- computeRestarts(cond)
[13:23:32.407]                           for (restart in restarts) {
[13:23:32.407]                             name <- restart$name
[13:23:32.407]                             if (is.null(name)) 
[13:23:32.407]                               next
[13:23:32.407]                             if (!grepl(pattern, name)) 
[13:23:32.407]                               next
[13:23:32.407]                             invokeRestart(restart)
[13:23:32.407]                             muffled <- TRUE
[13:23:32.407]                             break
[13:23:32.407]                           }
[13:23:32.407]                         }
[13:23:32.407]                       }
[13:23:32.407]                       invisible(muffled)
[13:23:32.407]                     }
[13:23:32.407]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.407]                   }
[13:23:32.407]                 }
[13:23:32.407]                 else {
[13:23:32.407]                   if (TRUE) {
[13:23:32.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.407]                     {
[13:23:32.407]                       inherits <- base::inherits
[13:23:32.407]                       invokeRestart <- base::invokeRestart
[13:23:32.407]                       is.null <- base::is.null
[13:23:32.407]                       muffled <- FALSE
[13:23:32.407]                       if (inherits(cond, "message")) {
[13:23:32.407]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.407]                         if (muffled) 
[13:23:32.407]                           invokeRestart("muffleMessage")
[13:23:32.407]                       }
[13:23:32.407]                       else if (inherits(cond, "warning")) {
[13:23:32.407]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.407]                         if (muffled) 
[13:23:32.407]                           invokeRestart("muffleWarning")
[13:23:32.407]                       }
[13:23:32.407]                       else if (inherits(cond, "condition")) {
[13:23:32.407]                         if (!is.null(pattern)) {
[13:23:32.407]                           computeRestarts <- base::computeRestarts
[13:23:32.407]                           grepl <- base::grepl
[13:23:32.407]                           restarts <- computeRestarts(cond)
[13:23:32.407]                           for (restart in restarts) {
[13:23:32.407]                             name <- restart$name
[13:23:32.407]                             if (is.null(name)) 
[13:23:32.407]                               next
[13:23:32.407]                             if (!grepl(pattern, name)) 
[13:23:32.407]                               next
[13:23:32.407]                             invokeRestart(restart)
[13:23:32.407]                             muffled <- TRUE
[13:23:32.407]                             break
[13:23:32.407]                           }
[13:23:32.407]                         }
[13:23:32.407]                       }
[13:23:32.407]                       invisible(muffled)
[13:23:32.407]                     }
[13:23:32.407]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.407]                   }
[13:23:32.407]                 }
[13:23:32.407]             }
[13:23:32.407]         }))
[13:23:32.407]     }, error = function(ex) {
[13:23:32.407]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.407]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.407]                 ...future.rng), started = ...future.startTime, 
[13:23:32.407]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.407]             version = "1.8"), class = "FutureResult")
[13:23:32.407]     }, finally = {
[13:23:32.407]         if (!identical(...future.workdir, getwd())) 
[13:23:32.407]             setwd(...future.workdir)
[13:23:32.407]         {
[13:23:32.407]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.407]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.407]             }
[13:23:32.407]             base::options(...future.oldOptions)
[13:23:32.407]             if (.Platform$OS.type == "windows") {
[13:23:32.407]                 old_names <- names(...future.oldEnvVars)
[13:23:32.407]                 envs <- base::Sys.getenv()
[13:23:32.407]                 names <- names(envs)
[13:23:32.407]                 common <- intersect(names, old_names)
[13:23:32.407]                 added <- setdiff(names, old_names)
[13:23:32.407]                 removed <- setdiff(old_names, names)
[13:23:32.407]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.407]                   envs[common]]
[13:23:32.407]                 NAMES <- toupper(changed)
[13:23:32.407]                 args <- list()
[13:23:32.407]                 for (kk in seq_along(NAMES)) {
[13:23:32.407]                   name <- changed[[kk]]
[13:23:32.407]                   NAME <- NAMES[[kk]]
[13:23:32.407]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.407]                     next
[13:23:32.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.407]                 }
[13:23:32.407]                 NAMES <- toupper(added)
[13:23:32.407]                 for (kk in seq_along(NAMES)) {
[13:23:32.407]                   name <- added[[kk]]
[13:23:32.407]                   NAME <- NAMES[[kk]]
[13:23:32.407]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.407]                     next
[13:23:32.407]                   args[[name]] <- ""
[13:23:32.407]                 }
[13:23:32.407]                 NAMES <- toupper(removed)
[13:23:32.407]                 for (kk in seq_along(NAMES)) {
[13:23:32.407]                   name <- removed[[kk]]
[13:23:32.407]                   NAME <- NAMES[[kk]]
[13:23:32.407]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.407]                     next
[13:23:32.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.407]                 }
[13:23:32.407]                 if (length(args) > 0) 
[13:23:32.407]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.407]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.407]             }
[13:23:32.407]             else {
[13:23:32.407]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.407]             }
[13:23:32.407]             {
[13:23:32.407]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.407]                   0L) {
[13:23:32.407]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.407]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.407]                   base::options(opts)
[13:23:32.407]                 }
[13:23:32.407]                 {
[13:23:32.407]                   {
[13:23:32.407]                     NULL
[13:23:32.407]                     RNGkind("Mersenne-Twister")
[13:23:32.407]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.407]                       inherits = FALSE)
[13:23:32.407]                   }
[13:23:32.407]                   options(future.plan = NULL)
[13:23:32.407]                   if (is.na(NA_character_)) 
[13:23:32.407]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.407]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.407]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.407]                   {
[13:23:32.407]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.407]                     if (!future$lazy) 
[13:23:32.407]                       future <- run(future)
[13:23:32.407]                     invisible(future)
[13:23:32.407]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.407]                 }
[13:23:32.407]             }
[13:23:32.407]         }
[13:23:32.407]     })
[13:23:32.407]     if (TRUE) {
[13:23:32.407]         base::sink(type = "output", split = FALSE)
[13:23:32.407]         if (TRUE) {
[13:23:32.407]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.407]         }
[13:23:32.407]         else {
[13:23:32.407]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.407]         }
[13:23:32.407]         base::close(...future.stdout)
[13:23:32.407]         ...future.stdout <- NULL
[13:23:32.407]     }
[13:23:32.407]     ...future.result$conditions <- ...future.conditions
[13:23:32.407]     ...future.result$finished <- base::Sys.time()
[13:23:32.407]     ...future.result
[13:23:32.407] }
[13:23:32.409] assign_globals() ...
[13:23:32.409] List of 1
[13:23:32.409]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5589bf15be98> 
[13:23:32.409]  - attr(*, "where")=List of 1
[13:23:32.409]   ..$ a:<environment: R_EmptyEnv> 
[13:23:32.409]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.409]  - attr(*, "resolved")= logi TRUE
[13:23:32.409]  - attr(*, "total_size")= num 1616080
[13:23:32.409]  - attr(*, "already-done")= logi TRUE
[13:23:32.412] - copied ‘a’ to environment
[13:23:32.412] assign_globals() ... done
[13:23:32.412] plan(): Setting new future strategy stack:
[13:23:32.412] List of future strategies:
[13:23:32.412] 1. sequential:
[13:23:32.412]    - args: function (..., envir = parent.frame())
[13:23:32.412]    - tweaked: FALSE
[13:23:32.412]    - call: NULL
[13:23:32.413] plan(): nbrOfWorkers() = 1
[13:23:32.414] plan(): Setting new future strategy stack:
[13:23:32.414] List of future strategies:
[13:23:32.414] 1. sequential:
[13:23:32.414]    - args: function (..., envir = parent.frame())
[13:23:32.414]    - tweaked: FALSE
[13:23:32.414]    - call: plan(strategy)
[13:23:32.414] plan(): nbrOfWorkers() = 1
[13:23:32.414] SequentialFuture started (and completed)
[13:23:32.414] - Launch lazy future ... done
[13:23:32.415] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.415] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.415] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:32.416] - globals found: [2] ‘{’, ‘pkg’
[13:23:32.416] Searching for globals ... DONE
[13:23:32.416] Resolving globals: TRUE
[13:23:32.416] Resolving any globals that are futures ...
[13:23:32.417] - globals: [2] ‘{’, ‘pkg’
[13:23:32.417] Resolving any globals that are futures ... DONE
[13:23:32.417] Resolving futures part of globals (recursively) ...
[13:23:32.417] resolve() on list ...
[13:23:32.417]  recursive: 99
[13:23:32.417]  length: 1
[13:23:32.418]  elements: ‘pkg’
[13:23:32.418]  length: 0 (resolved future 1)
[13:23:32.418] resolve() on list ... DONE
[13:23:32.418] - globals: [1] ‘pkg’
[13:23:32.418] Resolving futures part of globals (recursively) ... DONE
[13:23:32.418] The total size of the 1 globals is 112 bytes (112 bytes)
[13:23:32.418] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[13:23:32.419] - globals: [1] ‘pkg’
[13:23:32.419] 
[13:23:32.419] getGlobalsAndPackages() ... DONE
[13:23:32.419] Packages needed by the future expression (n = 0): <none>
[13:23:32.419] Packages needed by future strategies (n = 0): <none>
[13:23:32.420] {
[13:23:32.420]     {
[13:23:32.420]         {
[13:23:32.420]             ...future.startTime <- base::Sys.time()
[13:23:32.420]             {
[13:23:32.420]                 {
[13:23:32.420]                   {
[13:23:32.420]                     base::local({
[13:23:32.420]                       has_future <- base::requireNamespace("future", 
[13:23:32.420]                         quietly = TRUE)
[13:23:32.420]                       if (has_future) {
[13:23:32.420]                         ns <- base::getNamespace("future")
[13:23:32.420]                         version <- ns[[".package"]][["version"]]
[13:23:32.420]                         if (is.null(version)) 
[13:23:32.420]                           version <- utils::packageVersion("future")
[13:23:32.420]                       }
[13:23:32.420]                       else {
[13:23:32.420]                         version <- NULL
[13:23:32.420]                       }
[13:23:32.420]                       if (!has_future || version < "1.8.0") {
[13:23:32.420]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.420]                           "", base::R.version$version.string), 
[13:23:32.420]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:32.420]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.420]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.420]                             "release", "version")], collapse = " "), 
[13:23:32.420]                           hostname = base::Sys.info()[["nodename"]])
[13:23:32.420]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.420]                           info)
[13:23:32.420]                         info <- base::paste(info, collapse = "; ")
[13:23:32.420]                         if (!has_future) {
[13:23:32.420]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.420]                             info)
[13:23:32.420]                         }
[13:23:32.420]                         else {
[13:23:32.420]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.420]                             info, version)
[13:23:32.420]                         }
[13:23:32.420]                         base::stop(msg)
[13:23:32.420]                       }
[13:23:32.420]                     })
[13:23:32.420]                   }
[13:23:32.420]                   options(future.plan = NULL)
[13:23:32.420]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.420]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.420]                 }
[13:23:32.420]                 ...future.workdir <- getwd()
[13:23:32.420]             }
[13:23:32.420]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.420]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.420]         }
[13:23:32.420]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.420]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:32.420]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.420]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.420]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.420]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.420]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.420]             base::names(...future.oldOptions))
[13:23:32.420]     }
[13:23:32.420]     if (FALSE) {
[13:23:32.420]     }
[13:23:32.420]     else {
[13:23:32.420]         if (TRUE) {
[13:23:32.420]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.420]                 open = "w")
[13:23:32.420]         }
[13:23:32.420]         else {
[13:23:32.420]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.420]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.420]         }
[13:23:32.420]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.420]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.420]             base::sink(type = "output", split = FALSE)
[13:23:32.420]             base::close(...future.stdout)
[13:23:32.420]         }, add = TRUE)
[13:23:32.420]     }
[13:23:32.420]     ...future.frame <- base::sys.nframe()
[13:23:32.420]     ...future.conditions <- base::list()
[13:23:32.420]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.420]     if (FALSE) {
[13:23:32.420]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.420]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.420]     }
[13:23:32.420]     ...future.result <- base::tryCatch({
[13:23:32.420]         base::withCallingHandlers({
[13:23:32.420]             ...future.value <- base::withVisible(base::local({
[13:23:32.420]                 pkg
[13:23:32.420]             }))
[13:23:32.420]             future::FutureResult(value = ...future.value$value, 
[13:23:32.420]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.420]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.420]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.420]                     ...future.globalenv.names))
[13:23:32.420]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.420]         }, condition = base::local({
[13:23:32.420]             c <- base::c
[13:23:32.420]             inherits <- base::inherits
[13:23:32.420]             invokeRestart <- base::invokeRestart
[13:23:32.420]             length <- base::length
[13:23:32.420]             list <- base::list
[13:23:32.420]             seq.int <- base::seq.int
[13:23:32.420]             signalCondition <- base::signalCondition
[13:23:32.420]             sys.calls <- base::sys.calls
[13:23:32.420]             `[[` <- base::`[[`
[13:23:32.420]             `+` <- base::`+`
[13:23:32.420]             `<<-` <- base::`<<-`
[13:23:32.420]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.420]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.420]                   3L)]
[13:23:32.420]             }
[13:23:32.420]             function(cond) {
[13:23:32.420]                 is_error <- inherits(cond, "error")
[13:23:32.420]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.420]                   NULL)
[13:23:32.420]                 if (is_error) {
[13:23:32.420]                   sessionInformation <- function() {
[13:23:32.420]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.420]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.420]                       search = base::search(), system = base::Sys.info())
[13:23:32.420]                   }
[13:23:32.420]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.420]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.420]                     cond$call), session = sessionInformation(), 
[13:23:32.420]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.420]                   signalCondition(cond)
[13:23:32.420]                 }
[13:23:32.420]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.420]                 "immediateCondition"))) {
[13:23:32.420]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.420]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.420]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.420]                   if (TRUE && !signal) {
[13:23:32.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.420]                     {
[13:23:32.420]                       inherits <- base::inherits
[13:23:32.420]                       invokeRestart <- base::invokeRestart
[13:23:32.420]                       is.null <- base::is.null
[13:23:32.420]                       muffled <- FALSE
[13:23:32.420]                       if (inherits(cond, "message")) {
[13:23:32.420]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.420]                         if (muffled) 
[13:23:32.420]                           invokeRestart("muffleMessage")
[13:23:32.420]                       }
[13:23:32.420]                       else if (inherits(cond, "warning")) {
[13:23:32.420]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.420]                         if (muffled) 
[13:23:32.420]                           invokeRestart("muffleWarning")
[13:23:32.420]                       }
[13:23:32.420]                       else if (inherits(cond, "condition")) {
[13:23:32.420]                         if (!is.null(pattern)) {
[13:23:32.420]                           computeRestarts <- base::computeRestarts
[13:23:32.420]                           grepl <- base::grepl
[13:23:32.420]                           restarts <- computeRestarts(cond)
[13:23:32.420]                           for (restart in restarts) {
[13:23:32.420]                             name <- restart$name
[13:23:32.420]                             if (is.null(name)) 
[13:23:32.420]                               next
[13:23:32.420]                             if (!grepl(pattern, name)) 
[13:23:32.420]                               next
[13:23:32.420]                             invokeRestart(restart)
[13:23:32.420]                             muffled <- TRUE
[13:23:32.420]                             break
[13:23:32.420]                           }
[13:23:32.420]                         }
[13:23:32.420]                       }
[13:23:32.420]                       invisible(muffled)
[13:23:32.420]                     }
[13:23:32.420]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.420]                   }
[13:23:32.420]                 }
[13:23:32.420]                 else {
[13:23:32.420]                   if (TRUE) {
[13:23:32.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.420]                     {
[13:23:32.420]                       inherits <- base::inherits
[13:23:32.420]                       invokeRestart <- base::invokeRestart
[13:23:32.420]                       is.null <- base::is.null
[13:23:32.420]                       muffled <- FALSE
[13:23:32.420]                       if (inherits(cond, "message")) {
[13:23:32.420]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.420]                         if (muffled) 
[13:23:32.420]                           invokeRestart("muffleMessage")
[13:23:32.420]                       }
[13:23:32.420]                       else if (inherits(cond, "warning")) {
[13:23:32.420]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.420]                         if (muffled) 
[13:23:32.420]                           invokeRestart("muffleWarning")
[13:23:32.420]                       }
[13:23:32.420]                       else if (inherits(cond, "condition")) {
[13:23:32.420]                         if (!is.null(pattern)) {
[13:23:32.420]                           computeRestarts <- base::computeRestarts
[13:23:32.420]                           grepl <- base::grepl
[13:23:32.420]                           restarts <- computeRestarts(cond)
[13:23:32.420]                           for (restart in restarts) {
[13:23:32.420]                             name <- restart$name
[13:23:32.420]                             if (is.null(name)) 
[13:23:32.420]                               next
[13:23:32.420]                             if (!grepl(pattern, name)) 
[13:23:32.420]                               next
[13:23:32.420]                             invokeRestart(restart)
[13:23:32.420]                             muffled <- TRUE
[13:23:32.420]                             break
[13:23:32.420]                           }
[13:23:32.420]                         }
[13:23:32.420]                       }
[13:23:32.420]                       invisible(muffled)
[13:23:32.420]                     }
[13:23:32.420]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.420]                   }
[13:23:32.420]                 }
[13:23:32.420]             }
[13:23:32.420]         }))
[13:23:32.420]     }, error = function(ex) {
[13:23:32.420]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.420]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.420]                 ...future.rng), started = ...future.startTime, 
[13:23:32.420]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.420]             version = "1.8"), class = "FutureResult")
[13:23:32.420]     }, finally = {
[13:23:32.420]         if (!identical(...future.workdir, getwd())) 
[13:23:32.420]             setwd(...future.workdir)
[13:23:32.420]         {
[13:23:32.420]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.420]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.420]             }
[13:23:32.420]             base::options(...future.oldOptions)
[13:23:32.420]             if (.Platform$OS.type == "windows") {
[13:23:32.420]                 old_names <- names(...future.oldEnvVars)
[13:23:32.420]                 envs <- base::Sys.getenv()
[13:23:32.420]                 names <- names(envs)
[13:23:32.420]                 common <- intersect(names, old_names)
[13:23:32.420]                 added <- setdiff(names, old_names)
[13:23:32.420]                 removed <- setdiff(old_names, names)
[13:23:32.420]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.420]                   envs[common]]
[13:23:32.420]                 NAMES <- toupper(changed)
[13:23:32.420]                 args <- list()
[13:23:32.420]                 for (kk in seq_along(NAMES)) {
[13:23:32.420]                   name <- changed[[kk]]
[13:23:32.420]                   NAME <- NAMES[[kk]]
[13:23:32.420]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.420]                     next
[13:23:32.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.420]                 }
[13:23:32.420]                 NAMES <- toupper(added)
[13:23:32.420]                 for (kk in seq_along(NAMES)) {
[13:23:32.420]                   name <- added[[kk]]
[13:23:32.420]                   NAME <- NAMES[[kk]]
[13:23:32.420]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.420]                     next
[13:23:32.420]                   args[[name]] <- ""
[13:23:32.420]                 }
[13:23:32.420]                 NAMES <- toupper(removed)
[13:23:32.420]                 for (kk in seq_along(NAMES)) {
[13:23:32.420]                   name <- removed[[kk]]
[13:23:32.420]                   NAME <- NAMES[[kk]]
[13:23:32.420]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.420]                     next
[13:23:32.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.420]                 }
[13:23:32.420]                 if (length(args) > 0) 
[13:23:32.420]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.420]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.420]             }
[13:23:32.420]             else {
[13:23:32.420]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.420]             }
[13:23:32.420]             {
[13:23:32.420]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.420]                   0L) {
[13:23:32.420]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.420]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.420]                   base::options(opts)
[13:23:32.420]                 }
[13:23:32.420]                 {
[13:23:32.420]                   {
[13:23:32.420]                     NULL
[13:23:32.420]                     RNGkind("Mersenne-Twister")
[13:23:32.420]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.420]                       inherits = FALSE)
[13:23:32.420]                   }
[13:23:32.420]                   options(future.plan = NULL)
[13:23:32.420]                   if (is.na(NA_character_)) 
[13:23:32.420]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.420]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.420]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.420]                   {
[13:23:32.420]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.420]                     if (!future$lazy) 
[13:23:32.420]                       future <- run(future)
[13:23:32.420]                     invisible(future)
[13:23:32.420]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.420]                 }
[13:23:32.420]             }
[13:23:32.420]         }
[13:23:32.420]     })
[13:23:32.420]     if (TRUE) {
[13:23:32.420]         base::sink(type = "output", split = FALSE)
[13:23:32.420]         if (TRUE) {
[13:23:32.420]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.420]         }
[13:23:32.420]         else {
[13:23:32.420]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.420]         }
[13:23:32.420]         base::close(...future.stdout)
[13:23:32.420]         ...future.stdout <- NULL
[13:23:32.420]     }
[13:23:32.420]     ...future.result$conditions <- ...future.conditions
[13:23:32.420]     ...future.result$finished <- base::Sys.time()
[13:23:32.420]     ...future.result
[13:23:32.420] }
[13:23:32.421] assign_globals() ...
[13:23:32.421] List of 1
[13:23:32.421]  $ pkg: chr "foo"
[13:23:32.421]  - attr(*, "where")=List of 1
[13:23:32.421]   ..$ pkg:<environment: R_EmptyEnv> 
[13:23:32.421]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.421]  - attr(*, "resolved")= logi TRUE
[13:23:32.421]  - attr(*, "total_size")= num 112
[13:23:32.424] - copied ‘pkg’ to environment
[13:23:32.424] assign_globals() ... done
[13:23:32.424] plan(): Setting new future strategy stack:
[13:23:32.424] List of future strategies:
[13:23:32.424] 1. sequential:
[13:23:32.424]    - args: function (..., envir = parent.frame())
[13:23:32.424]    - tweaked: FALSE
[13:23:32.424]    - call: NULL
[13:23:32.425] plan(): nbrOfWorkers() = 1
[13:23:32.426] plan(): Setting new future strategy stack:
[13:23:32.426] List of future strategies:
[13:23:32.426] 1. sequential:
[13:23:32.426]    - args: function (..., envir = parent.frame())
[13:23:32.426]    - tweaked: FALSE
[13:23:32.426]    - call: plan(strategy)
[13:23:32.426] plan(): nbrOfWorkers() = 1
[13:23:32.426] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.427] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.427] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:32.429] - globals found: [3] ‘{’, ‘<-’, ‘+’
[13:23:32.429] Searching for globals ... DONE
[13:23:32.431] Resolving globals: TRUE
[13:23:32.431] Resolving any globals that are futures ...
[13:23:32.431] - globals: [3] ‘{’, ‘<-’, ‘+’
[13:23:32.431] Resolving any globals that are futures ... DONE
[13:23:32.432] 
[13:23:32.432] 
[13:23:32.432] getGlobalsAndPackages() ... DONE
[13:23:32.433] run() for ‘Future’ ...
[13:23:32.433] - state: ‘created’
[13:23:32.433] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.433] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.433] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.434]   - Field: ‘label’
[13:23:32.434]   - Field: ‘local’
[13:23:32.434]   - Field: ‘owner’
[13:23:32.434]   - Field: ‘envir’
[13:23:32.434]   - Field: ‘packages’
[13:23:32.434]   - Field: ‘gc’
[13:23:32.434]   - Field: ‘conditions’
[13:23:32.434]   - Field: ‘expr’
[13:23:32.434]   - Field: ‘uuid’
[13:23:32.435]   - Field: ‘seed’
[13:23:32.435]   - Field: ‘version’
[13:23:32.435]   - Field: ‘result’
[13:23:32.435]   - Field: ‘asynchronous’
[13:23:32.435]   - Field: ‘calls’
[13:23:32.435]   - Field: ‘globals’
[13:23:32.435]   - Field: ‘stdout’
[13:23:32.435]   - Field: ‘earlySignal’
[13:23:32.435]   - Field: ‘lazy’
[13:23:32.435]   - Field: ‘state’
[13:23:32.436] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.436] - Launch lazy future ...
[13:23:32.436] Packages needed by the future expression (n = 0): <none>
[13:23:32.436] Packages needed by future strategies (n = 0): <none>
[13:23:32.437] {
[13:23:32.437]     {
[13:23:32.437]         {
[13:23:32.437]             ...future.startTime <- base::Sys.time()
[13:23:32.437]             {
[13:23:32.437]                 {
[13:23:32.437]                   {
[13:23:32.437]                     base::local({
[13:23:32.437]                       has_future <- base::requireNamespace("future", 
[13:23:32.437]                         quietly = TRUE)
[13:23:32.437]                       if (has_future) {
[13:23:32.437]                         ns <- base::getNamespace("future")
[13:23:32.437]                         version <- ns[[".package"]][["version"]]
[13:23:32.437]                         if (is.null(version)) 
[13:23:32.437]                           version <- utils::packageVersion("future")
[13:23:32.437]                       }
[13:23:32.437]                       else {
[13:23:32.437]                         version <- NULL
[13:23:32.437]                       }
[13:23:32.437]                       if (!has_future || version < "1.8.0") {
[13:23:32.437]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.437]                           "", base::R.version$version.string), 
[13:23:32.437]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:32.437]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.437]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.437]                             "release", "version")], collapse = " "), 
[13:23:32.437]                           hostname = base::Sys.info()[["nodename"]])
[13:23:32.437]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.437]                           info)
[13:23:32.437]                         info <- base::paste(info, collapse = "; ")
[13:23:32.437]                         if (!has_future) {
[13:23:32.437]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.437]                             info)
[13:23:32.437]                         }
[13:23:32.437]                         else {
[13:23:32.437]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.437]                             info, version)
[13:23:32.437]                         }
[13:23:32.437]                         base::stop(msg)
[13:23:32.437]                       }
[13:23:32.437]                     })
[13:23:32.437]                   }
[13:23:32.437]                   options(future.plan = NULL)
[13:23:32.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.437]                 }
[13:23:32.437]                 ...future.workdir <- getwd()
[13:23:32.437]             }
[13:23:32.437]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.437]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.437]         }
[13:23:32.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.437]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:32.437]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.437]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.437]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.437]             base::names(...future.oldOptions))
[13:23:32.437]     }
[13:23:32.437]     if (FALSE) {
[13:23:32.437]     }
[13:23:32.437]     else {
[13:23:32.437]         if (TRUE) {
[13:23:32.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.437]                 open = "w")
[13:23:32.437]         }
[13:23:32.437]         else {
[13:23:32.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.437]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.437]         }
[13:23:32.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.437]             base::sink(type = "output", split = FALSE)
[13:23:32.437]             base::close(...future.stdout)
[13:23:32.437]         }, add = TRUE)
[13:23:32.437]     }
[13:23:32.437]     ...future.frame <- base::sys.nframe()
[13:23:32.437]     ...future.conditions <- base::list()
[13:23:32.437]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.437]     if (FALSE) {
[13:23:32.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.437]     }
[13:23:32.437]     ...future.result <- base::tryCatch({
[13:23:32.437]         base::withCallingHandlers({
[13:23:32.437]             ...future.value <- base::withVisible(base::local({
[13:23:32.437]                 x <- 0
[13:23:32.437]                 x <- x + 1
[13:23:32.437]                 x
[13:23:32.437]             }))
[13:23:32.437]             future::FutureResult(value = ...future.value$value, 
[13:23:32.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.437]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.437]                     ...future.globalenv.names))
[13:23:32.437]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.437]         }, condition = base::local({
[13:23:32.437]             c <- base::c
[13:23:32.437]             inherits <- base::inherits
[13:23:32.437]             invokeRestart <- base::invokeRestart
[13:23:32.437]             length <- base::length
[13:23:32.437]             list <- base::list
[13:23:32.437]             seq.int <- base::seq.int
[13:23:32.437]             signalCondition <- base::signalCondition
[13:23:32.437]             sys.calls <- base::sys.calls
[13:23:32.437]             `[[` <- base::`[[`
[13:23:32.437]             `+` <- base::`+`
[13:23:32.437]             `<<-` <- base::`<<-`
[13:23:32.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.437]                   3L)]
[13:23:32.437]             }
[13:23:32.437]             function(cond) {
[13:23:32.437]                 is_error <- inherits(cond, "error")
[13:23:32.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.437]                   NULL)
[13:23:32.437]                 if (is_error) {
[13:23:32.437]                   sessionInformation <- function() {
[13:23:32.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.437]                       search = base::search(), system = base::Sys.info())
[13:23:32.437]                   }
[13:23:32.437]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.437]                     cond$call), session = sessionInformation(), 
[13:23:32.437]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.437]                   signalCondition(cond)
[13:23:32.437]                 }
[13:23:32.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.437]                 "immediateCondition"))) {
[13:23:32.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.437]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.437]                   if (TRUE && !signal) {
[13:23:32.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.437]                     {
[13:23:32.437]                       inherits <- base::inherits
[13:23:32.437]                       invokeRestart <- base::invokeRestart
[13:23:32.437]                       is.null <- base::is.null
[13:23:32.437]                       muffled <- FALSE
[13:23:32.437]                       if (inherits(cond, "message")) {
[13:23:32.437]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.437]                         if (muffled) 
[13:23:32.437]                           invokeRestart("muffleMessage")
[13:23:32.437]                       }
[13:23:32.437]                       else if (inherits(cond, "warning")) {
[13:23:32.437]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.437]                         if (muffled) 
[13:23:32.437]                           invokeRestart("muffleWarning")
[13:23:32.437]                       }
[13:23:32.437]                       else if (inherits(cond, "condition")) {
[13:23:32.437]                         if (!is.null(pattern)) {
[13:23:32.437]                           computeRestarts <- base::computeRestarts
[13:23:32.437]                           grepl <- base::grepl
[13:23:32.437]                           restarts <- computeRestarts(cond)
[13:23:32.437]                           for (restart in restarts) {
[13:23:32.437]                             name <- restart$name
[13:23:32.437]                             if (is.null(name)) 
[13:23:32.437]                               next
[13:23:32.437]                             if (!grepl(pattern, name)) 
[13:23:32.437]                               next
[13:23:32.437]                             invokeRestart(restart)
[13:23:32.437]                             muffled <- TRUE
[13:23:32.437]                             break
[13:23:32.437]                           }
[13:23:32.437]                         }
[13:23:32.437]                       }
[13:23:32.437]                       invisible(muffled)
[13:23:32.437]                     }
[13:23:32.437]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.437]                   }
[13:23:32.437]                 }
[13:23:32.437]                 else {
[13:23:32.437]                   if (TRUE) {
[13:23:32.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.437]                     {
[13:23:32.437]                       inherits <- base::inherits
[13:23:32.437]                       invokeRestart <- base::invokeRestart
[13:23:32.437]                       is.null <- base::is.null
[13:23:32.437]                       muffled <- FALSE
[13:23:32.437]                       if (inherits(cond, "message")) {
[13:23:32.437]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.437]                         if (muffled) 
[13:23:32.437]                           invokeRestart("muffleMessage")
[13:23:32.437]                       }
[13:23:32.437]                       else if (inherits(cond, "warning")) {
[13:23:32.437]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.437]                         if (muffled) 
[13:23:32.437]                           invokeRestart("muffleWarning")
[13:23:32.437]                       }
[13:23:32.437]                       else if (inherits(cond, "condition")) {
[13:23:32.437]                         if (!is.null(pattern)) {
[13:23:32.437]                           computeRestarts <- base::computeRestarts
[13:23:32.437]                           grepl <- base::grepl
[13:23:32.437]                           restarts <- computeRestarts(cond)
[13:23:32.437]                           for (restart in restarts) {
[13:23:32.437]                             name <- restart$name
[13:23:32.437]                             if (is.null(name)) 
[13:23:32.437]                               next
[13:23:32.437]                             if (!grepl(pattern, name)) 
[13:23:32.437]                               next
[13:23:32.437]                             invokeRestart(restart)
[13:23:32.437]                             muffled <- TRUE
[13:23:32.437]                             break
[13:23:32.437]                           }
[13:23:32.437]                         }
[13:23:32.437]                       }
[13:23:32.437]                       invisible(muffled)
[13:23:32.437]                     }
[13:23:32.437]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.437]                   }
[13:23:32.437]                 }
[13:23:32.437]             }
[13:23:32.437]         }))
[13:23:32.437]     }, error = function(ex) {
[13:23:32.437]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.437]                 ...future.rng), started = ...future.startTime, 
[13:23:32.437]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.437]             version = "1.8"), class = "FutureResult")
[13:23:32.437]     }, finally = {
[13:23:32.437]         if (!identical(...future.workdir, getwd())) 
[13:23:32.437]             setwd(...future.workdir)
[13:23:32.437]         {
[13:23:32.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.437]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.437]             }
[13:23:32.437]             base::options(...future.oldOptions)
[13:23:32.437]             if (.Platform$OS.type == "windows") {
[13:23:32.437]                 old_names <- names(...future.oldEnvVars)
[13:23:32.437]                 envs <- base::Sys.getenv()
[13:23:32.437]                 names <- names(envs)
[13:23:32.437]                 common <- intersect(names, old_names)
[13:23:32.437]                 added <- setdiff(names, old_names)
[13:23:32.437]                 removed <- setdiff(old_names, names)
[13:23:32.437]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.437]                   envs[common]]
[13:23:32.437]                 NAMES <- toupper(changed)
[13:23:32.437]                 args <- list()
[13:23:32.437]                 for (kk in seq_along(NAMES)) {
[13:23:32.437]                   name <- changed[[kk]]
[13:23:32.437]                   NAME <- NAMES[[kk]]
[13:23:32.437]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.437]                     next
[13:23:32.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.437]                 }
[13:23:32.437]                 NAMES <- toupper(added)
[13:23:32.437]                 for (kk in seq_along(NAMES)) {
[13:23:32.437]                   name <- added[[kk]]
[13:23:32.437]                   NAME <- NAMES[[kk]]
[13:23:32.437]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.437]                     next
[13:23:32.437]                   args[[name]] <- ""
[13:23:32.437]                 }
[13:23:32.437]                 NAMES <- toupper(removed)
[13:23:32.437]                 for (kk in seq_along(NAMES)) {
[13:23:32.437]                   name <- removed[[kk]]
[13:23:32.437]                   NAME <- NAMES[[kk]]
[13:23:32.437]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.437]                     next
[13:23:32.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.437]                 }
[13:23:32.437]                 if (length(args) > 0) 
[13:23:32.437]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.437]             }
[13:23:32.437]             else {
[13:23:32.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.437]             }
[13:23:32.437]             {
[13:23:32.437]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.437]                   0L) {
[13:23:32.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.437]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.437]                   base::options(opts)
[13:23:32.437]                 }
[13:23:32.437]                 {
[13:23:32.437]                   {
[13:23:32.437]                     NULL
[13:23:32.437]                     RNGkind("Mersenne-Twister")
[13:23:32.437]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.437]                       inherits = FALSE)
[13:23:32.437]                   }
[13:23:32.437]                   options(future.plan = NULL)
[13:23:32.437]                   if (is.na(NA_character_)) 
[13:23:32.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.437]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.437]                   {
[13:23:32.437]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.437]                     if (!future$lazy) 
[13:23:32.437]                       future <- run(future)
[13:23:32.437]                     invisible(future)
[13:23:32.437]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.437]                 }
[13:23:32.437]             }
[13:23:32.437]         }
[13:23:32.437]     })
[13:23:32.437]     if (TRUE) {
[13:23:32.437]         base::sink(type = "output", split = FALSE)
[13:23:32.437]         if (TRUE) {
[13:23:32.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.437]         }
[13:23:32.437]         else {
[13:23:32.437]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.437]         }
[13:23:32.437]         base::close(...future.stdout)
[13:23:32.437]         ...future.stdout <- NULL
[13:23:32.437]     }
[13:23:32.437]     ...future.result$conditions <- ...future.conditions
[13:23:32.437]     ...future.result$finished <- base::Sys.time()
[13:23:32.437]     ...future.result
[13:23:32.437] }
[13:23:32.438] plan(): Setting new future strategy stack:
[13:23:32.439] List of future strategies:
[13:23:32.439] 1. sequential:
[13:23:32.439]    - args: function (..., envir = parent.frame())
[13:23:32.439]    - tweaked: FALSE
[13:23:32.439]    - call: NULL
[13:23:32.439] plan(): nbrOfWorkers() = 1
[13:23:32.440] plan(): Setting new future strategy stack:
[13:23:32.440] List of future strategies:
[13:23:32.440] 1. sequential:
[13:23:32.440]    - args: function (..., envir = parent.frame())
[13:23:32.440]    - tweaked: FALSE
[13:23:32.440]    - call: plan(strategy)
[13:23:32.440] plan(): nbrOfWorkers() = 1
[13:23:32.441] SequentialFuture started (and completed)
[13:23:32.441] - Launch lazy future ... done
[13:23:32.441] run() for ‘SequentialFuture’ ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.441] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.441] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:32.443] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[13:23:32.443] Searching for globals ... DONE
[13:23:32.443] Resolving globals: TRUE
[13:23:32.443] Resolving any globals that are futures ...
[13:23:32.443] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[13:23:32.444] Resolving any globals that are futures ... DONE
[13:23:32.444] Resolving futures part of globals (recursively) ...
[13:23:32.444] resolve() on list ...
[13:23:32.444]  recursive: 99
[13:23:32.444]  length: 1
[13:23:32.444]  elements: ‘x’
[13:23:32.445]  length: 0 (resolved future 1)
[13:23:32.445] resolve() on list ... DONE
[13:23:32.445] - globals: [1] ‘x’
[13:23:32.445] Resolving futures part of globals (recursively) ... DONE
[13:23:32.445] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:32.445] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[13:23:32.446] - globals: [1] ‘x’
[13:23:32.446] 
[13:23:32.446] getGlobalsAndPackages() ... DONE
[13:23:32.446] run() for ‘Future’ ...
[13:23:32.446] - state: ‘created’
[13:23:32.446] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.447] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.447] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.447]   - Field: ‘label’
[13:23:32.447]   - Field: ‘local’
[13:23:32.447]   - Field: ‘owner’
[13:23:32.447]   - Field: ‘envir’
[13:23:32.447]   - Field: ‘packages’
[13:23:32.447]   - Field: ‘gc’
[13:23:32.447]   - Field: ‘conditions’
[13:23:32.447]   - Field: ‘expr’
[13:23:32.448]   - Field: ‘uuid’
[13:23:32.448]   - Field: ‘seed’
[13:23:32.448]   - Field: ‘version’
[13:23:32.448]   - Field: ‘result’
[13:23:32.448]   - Field: ‘asynchronous’
[13:23:32.448]   - Field: ‘calls’
[13:23:32.448]   - Field: ‘globals’
[13:23:32.448]   - Field: ‘stdout’
[13:23:32.448]   - Field: ‘earlySignal’
[13:23:32.448]   - Field: ‘lazy’
[13:23:32.449]   - Field: ‘state’
[13:23:32.449] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.449] - Launch lazy future ...
[13:23:32.449] Packages needed by the future expression (n = 0): <none>
[13:23:32.449] Packages needed by future strategies (n = 0): <none>
[13:23:32.449] {
[13:23:32.449]     {
[13:23:32.449]         {
[13:23:32.449]             ...future.startTime <- base::Sys.time()
[13:23:32.449]             {
[13:23:32.449]                 {
[13:23:32.449]                   {
[13:23:32.449]                     base::local({
[13:23:32.449]                       has_future <- base::requireNamespace("future", 
[13:23:32.449]                         quietly = TRUE)
[13:23:32.449]                       if (has_future) {
[13:23:32.449]                         ns <- base::getNamespace("future")
[13:23:32.449]                         version <- ns[[".package"]][["version"]]
[13:23:32.449]                         if (is.null(version)) 
[13:23:32.449]                           version <- utils::packageVersion("future")
[13:23:32.449]                       }
[13:23:32.449]                       else {
[13:23:32.449]                         version <- NULL
[13:23:32.449]                       }
[13:23:32.449]                       if (!has_future || version < "1.8.0") {
[13:23:32.449]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.449]                           "", base::R.version$version.string), 
[13:23:32.449]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:32.449]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.449]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.449]                             "release", "version")], collapse = " "), 
[13:23:32.449]                           hostname = base::Sys.info()[["nodename"]])
[13:23:32.449]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.449]                           info)
[13:23:32.449]                         info <- base::paste(info, collapse = "; ")
[13:23:32.449]                         if (!has_future) {
[13:23:32.449]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.449]                             info)
[13:23:32.449]                         }
[13:23:32.449]                         else {
[13:23:32.449]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.449]                             info, version)
[13:23:32.449]                         }
[13:23:32.449]                         base::stop(msg)
[13:23:32.449]                       }
[13:23:32.449]                     })
[13:23:32.449]                   }
[13:23:32.449]                   options(future.plan = NULL)
[13:23:32.449]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.449]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.449]                 }
[13:23:32.449]                 ...future.workdir <- getwd()
[13:23:32.449]             }
[13:23:32.449]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.449]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.449]         }
[13:23:32.449]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.449]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:32.449]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.449]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.449]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.449]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.449]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.449]             base::names(...future.oldOptions))
[13:23:32.449]     }
[13:23:32.449]     if (FALSE) {
[13:23:32.449]     }
[13:23:32.449]     else {
[13:23:32.449]         if (TRUE) {
[13:23:32.449]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.449]                 open = "w")
[13:23:32.449]         }
[13:23:32.449]         else {
[13:23:32.449]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.449]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.449]         }
[13:23:32.449]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.449]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.449]             base::sink(type = "output", split = FALSE)
[13:23:32.449]             base::close(...future.stdout)
[13:23:32.449]         }, add = TRUE)
[13:23:32.449]     }
[13:23:32.449]     ...future.frame <- base::sys.nframe()
[13:23:32.449]     ...future.conditions <- base::list()
[13:23:32.449]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.449]     if (FALSE) {
[13:23:32.449]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.449]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.449]     }
[13:23:32.449]     ...future.result <- base::tryCatch({
[13:23:32.449]         base::withCallingHandlers({
[13:23:32.449]             ...future.value <- base::withVisible(base::local({
[13:23:32.449]                 x <- x + 1
[13:23:32.449]                 x
[13:23:32.449]             }))
[13:23:32.449]             future::FutureResult(value = ...future.value$value, 
[13:23:32.449]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.449]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.449]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.449]                     ...future.globalenv.names))
[13:23:32.449]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.449]         }, condition = base::local({
[13:23:32.449]             c <- base::c
[13:23:32.449]             inherits <- base::inherits
[13:23:32.449]             invokeRestart <- base::invokeRestart
[13:23:32.449]             length <- base::length
[13:23:32.449]             list <- base::list
[13:23:32.449]             seq.int <- base::seq.int
[13:23:32.449]             signalCondition <- base::signalCondition
[13:23:32.449]             sys.calls <- base::sys.calls
[13:23:32.449]             `[[` <- base::`[[`
[13:23:32.449]             `+` <- base::`+`
[13:23:32.449]             `<<-` <- base::`<<-`
[13:23:32.449]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.449]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.449]                   3L)]
[13:23:32.449]             }
[13:23:32.449]             function(cond) {
[13:23:32.449]                 is_error <- inherits(cond, "error")
[13:23:32.449]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.449]                   NULL)
[13:23:32.449]                 if (is_error) {
[13:23:32.449]                   sessionInformation <- function() {
[13:23:32.449]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.449]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.449]                       search = base::search(), system = base::Sys.info())
[13:23:32.449]                   }
[13:23:32.449]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.449]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.449]                     cond$call), session = sessionInformation(), 
[13:23:32.449]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.449]                   signalCondition(cond)
[13:23:32.449]                 }
[13:23:32.449]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.449]                 "immediateCondition"))) {
[13:23:32.449]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.449]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.449]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.449]                   if (TRUE && !signal) {
[13:23:32.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.449]                     {
[13:23:32.449]                       inherits <- base::inherits
[13:23:32.449]                       invokeRestart <- base::invokeRestart
[13:23:32.449]                       is.null <- base::is.null
[13:23:32.449]                       muffled <- FALSE
[13:23:32.449]                       if (inherits(cond, "message")) {
[13:23:32.449]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.449]                         if (muffled) 
[13:23:32.449]                           invokeRestart("muffleMessage")
[13:23:32.449]                       }
[13:23:32.449]                       else if (inherits(cond, "warning")) {
[13:23:32.449]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.449]                         if (muffled) 
[13:23:32.449]                           invokeRestart("muffleWarning")
[13:23:32.449]                       }
[13:23:32.449]                       else if (inherits(cond, "condition")) {
[13:23:32.449]                         if (!is.null(pattern)) {
[13:23:32.449]                           computeRestarts <- base::computeRestarts
[13:23:32.449]                           grepl <- base::grepl
[13:23:32.449]                           restarts <- computeRestarts(cond)
[13:23:32.449]                           for (restart in restarts) {
[13:23:32.449]                             name <- restart$name
[13:23:32.449]                             if (is.null(name)) 
[13:23:32.449]                               next
[13:23:32.449]                             if (!grepl(pattern, name)) 
[13:23:32.449]                               next
[13:23:32.449]                             invokeRestart(restart)
[13:23:32.449]                             muffled <- TRUE
[13:23:32.449]                             break
[13:23:32.449]                           }
[13:23:32.449]                         }
[13:23:32.449]                       }
[13:23:32.449]                       invisible(muffled)
[13:23:32.449]                     }
[13:23:32.449]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.449]                   }
[13:23:32.449]                 }
[13:23:32.449]                 else {
[13:23:32.449]                   if (TRUE) {
[13:23:32.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.449]                     {
[13:23:32.449]                       inherits <- base::inherits
[13:23:32.449]                       invokeRestart <- base::invokeRestart
[13:23:32.449]                       is.null <- base::is.null
[13:23:32.449]                       muffled <- FALSE
[13:23:32.449]                       if (inherits(cond, "message")) {
[13:23:32.449]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.449]                         if (muffled) 
[13:23:32.449]                           invokeRestart("muffleMessage")
[13:23:32.449]                       }
[13:23:32.449]                       else if (inherits(cond, "warning")) {
[13:23:32.449]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.449]                         if (muffled) 
[13:23:32.449]                           invokeRestart("muffleWarning")
[13:23:32.449]                       }
[13:23:32.449]                       else if (inherits(cond, "condition")) {
[13:23:32.449]                         if (!is.null(pattern)) {
[13:23:32.449]                           computeRestarts <- base::computeRestarts
[13:23:32.449]                           grepl <- base::grepl
[13:23:32.449]                           restarts <- computeRestarts(cond)
[13:23:32.449]                           for (restart in restarts) {
[13:23:32.449]                             name <- restart$name
[13:23:32.449]                             if (is.null(name)) 
[13:23:32.449]                               next
[13:23:32.449]                             if (!grepl(pattern, name)) 
[13:23:32.449]                               next
[13:23:32.449]                             invokeRestart(restart)
[13:23:32.449]                             muffled <- TRUE
[13:23:32.449]                             break
[13:23:32.449]                           }
[13:23:32.449]                         }
[13:23:32.449]                       }
[13:23:32.449]                       invisible(muffled)
[13:23:32.449]                     }
[13:23:32.449]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.449]                   }
[13:23:32.449]                 }
[13:23:32.449]             }
[13:23:32.449]         }))
[13:23:32.449]     }, error = function(ex) {
[13:23:32.449]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.449]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.449]                 ...future.rng), started = ...future.startTime, 
[13:23:32.449]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.449]             version = "1.8"), class = "FutureResult")
[13:23:32.449]     }, finally = {
[13:23:32.449]         if (!identical(...future.workdir, getwd())) 
[13:23:32.449]             setwd(...future.workdir)
[13:23:32.449]         {
[13:23:32.449]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.449]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.449]             }
[13:23:32.449]             base::options(...future.oldOptions)
[13:23:32.449]             if (.Platform$OS.type == "windows") {
[13:23:32.449]                 old_names <- names(...future.oldEnvVars)
[13:23:32.449]                 envs <- base::Sys.getenv()
[13:23:32.449]                 names <- names(envs)
[13:23:32.449]                 common <- intersect(names, old_names)
[13:23:32.449]                 added <- setdiff(names, old_names)
[13:23:32.449]                 removed <- setdiff(old_names, names)
[13:23:32.449]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.449]                   envs[common]]
[13:23:32.449]                 NAMES <- toupper(changed)
[13:23:32.449]                 args <- list()
[13:23:32.449]                 for (kk in seq_along(NAMES)) {
[13:23:32.449]                   name <- changed[[kk]]
[13:23:32.449]                   NAME <- NAMES[[kk]]
[13:23:32.449]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.449]                     next
[13:23:32.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.449]                 }
[13:23:32.449]                 NAMES <- toupper(added)
[13:23:32.449]                 for (kk in seq_along(NAMES)) {
[13:23:32.449]                   name <- added[[kk]]
[13:23:32.449]                   NAME <- NAMES[[kk]]
[13:23:32.449]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.449]                     next
[13:23:32.449]                   args[[name]] <- ""
[13:23:32.449]                 }
[13:23:32.449]                 NAMES <- toupper(removed)
[13:23:32.449]                 for (kk in seq_along(NAMES)) {
[13:23:32.449]                   name <- removed[[kk]]
[13:23:32.449]                   NAME <- NAMES[[kk]]
[13:23:32.449]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.449]                     next
[13:23:32.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.449]                 }
[13:23:32.449]                 if (length(args) > 0) 
[13:23:32.449]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.449]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.449]             }
[13:23:32.449]             else {
[13:23:32.449]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.449]             }
[13:23:32.449]             {
[13:23:32.449]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.449]                   0L) {
[13:23:32.449]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.449]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.449]                   base::options(opts)
[13:23:32.449]                 }
[13:23:32.449]                 {
[13:23:32.449]                   {
[13:23:32.449]                     NULL
[13:23:32.449]                     RNGkind("Mersenne-Twister")
[13:23:32.449]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.449]                       inherits = FALSE)
[13:23:32.449]                   }
[13:23:32.449]                   options(future.plan = NULL)
[13:23:32.449]                   if (is.na(NA_character_)) 
[13:23:32.449]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.449]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.449]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.449]                   {
[13:23:32.449]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.449]                     if (!future$lazy) 
[13:23:32.449]                       future <- run(future)
[13:23:32.449]                     invisible(future)
[13:23:32.449]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.449]                 }
[13:23:32.449]             }
[13:23:32.449]         }
[13:23:32.449]     })
[13:23:32.449]     if (TRUE) {
[13:23:32.449]         base::sink(type = "output", split = FALSE)
[13:23:32.449]         if (TRUE) {
[13:23:32.449]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.449]         }
[13:23:32.449]         else {
[13:23:32.449]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.449]         }
[13:23:32.449]         base::close(...future.stdout)
[13:23:32.449]         ...future.stdout <- NULL
[13:23:32.449]     }
[13:23:32.449]     ...future.result$conditions <- ...future.conditions
[13:23:32.449]     ...future.result$finished <- base::Sys.time()
[13:23:32.449]     ...future.result
[13:23:32.449] }
[13:23:32.451] assign_globals() ...
[13:23:32.451] List of 1
[13:23:32.451]  $ x: num 1
[13:23:32.451]  - attr(*, "where")=List of 1
[13:23:32.451]   ..$ x:<environment: R_EmptyEnv> 
[13:23:32.451]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.451]  - attr(*, "resolved")= logi TRUE
[13:23:32.451]  - attr(*, "total_size")= num 56
[13:23:32.451]  - attr(*, "already-done")= logi TRUE
[13:23:32.454] - copied ‘x’ to environment
[13:23:32.454] assign_globals() ... done
[13:23:32.454] plan(): Setting new future strategy stack:
[13:23:32.455] List of future strategies:
[13:23:32.455] 1. sequential:
[13:23:32.455]    - args: function (..., envir = parent.frame())
[13:23:32.455]    - tweaked: FALSE
[13:23:32.455]    - call: NULL
[13:23:32.455] plan(): nbrOfWorkers() = 1
[13:23:32.456] plan(): Setting new future strategy stack:
[13:23:32.456] List of future strategies:
[13:23:32.456] 1. sequential:
[13:23:32.456]    - args: function (..., envir = parent.frame())
[13:23:32.456]    - tweaked: FALSE
[13:23:32.456]    - call: plan(strategy)
[13:23:32.456] plan(): nbrOfWorkers() = 1
[13:23:32.456] SequentialFuture started (and completed)
[13:23:32.457] - Launch lazy future ... done
[13:23:32.457] run() for ‘SequentialFuture’ ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.457] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.457] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:32.459] - globals found: [3] ‘{’, ‘<-’, ‘x’
[13:23:32.459] Searching for globals ... DONE
[13:23:32.459] Resolving globals: TRUE
[13:23:32.460] Resolving any globals that are futures ...
[13:23:32.460] - globals: [3] ‘{’, ‘<-’, ‘x’
[13:23:32.460] Resolving any globals that are futures ... DONE
[13:23:32.460] Resolving futures part of globals (recursively) ...
[13:23:32.460] resolve() on list ...
[13:23:32.461]  recursive: 99
[13:23:32.461]  length: 1
[13:23:32.461]  elements: ‘x’
[13:23:32.461]  length: 0 (resolved future 1)
[13:23:32.461] resolve() on list ... DONE
[13:23:32.461] - globals: [1] ‘x’
[13:23:32.461] Resolving futures part of globals (recursively) ... DONE
[13:23:32.461] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[13:23:32.464] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[13:23:32.464] - globals: [1] ‘x’
[13:23:32.464] 
[13:23:32.464] getGlobalsAndPackages() ... DONE
[13:23:32.465] run() for ‘Future’ ...
[13:23:32.465] - state: ‘created’
[13:23:32.465] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:32.465] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:32.465] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:32.466]   - Field: ‘label’
[13:23:32.466]   - Field: ‘local’
[13:23:32.466]   - Field: ‘owner’
[13:23:32.466]   - Field: ‘envir’
[13:23:32.466]   - Field: ‘packages’
[13:23:32.466]   - Field: ‘gc’
[13:23:32.466]   - Field: ‘conditions’
[13:23:32.466]   - Field: ‘expr’
[13:23:32.467]   - Field: ‘uuid’
[13:23:32.467]   - Field: ‘seed’
[13:23:32.467]   - Field: ‘version’
[13:23:32.467]   - Field: ‘result’
[13:23:32.467]   - Field: ‘asynchronous’
[13:23:32.467]   - Field: ‘calls’
[13:23:32.467]   - Field: ‘globals’
[13:23:32.467]   - Field: ‘stdout’
[13:23:32.467]   - Field: ‘earlySignal’
[13:23:32.467]   - Field: ‘lazy’
[13:23:32.468]   - Field: ‘state’
[13:23:32.468] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:32.468] - Launch lazy future ...
[13:23:32.468] Packages needed by the future expression (n = 0): <none>
[13:23:32.468] Packages needed by future strategies (n = 0): <none>
[13:23:32.469] {
[13:23:32.469]     {
[13:23:32.469]         {
[13:23:32.469]             ...future.startTime <- base::Sys.time()
[13:23:32.469]             {
[13:23:32.469]                 {
[13:23:32.469]                   {
[13:23:32.469]                     base::local({
[13:23:32.469]                       has_future <- base::requireNamespace("future", 
[13:23:32.469]                         quietly = TRUE)
[13:23:32.469]                       if (has_future) {
[13:23:32.469]                         ns <- base::getNamespace("future")
[13:23:32.469]                         version <- ns[[".package"]][["version"]]
[13:23:32.469]                         if (is.null(version)) 
[13:23:32.469]                           version <- utils::packageVersion("future")
[13:23:32.469]                       }
[13:23:32.469]                       else {
[13:23:32.469]                         version <- NULL
[13:23:32.469]                       }
[13:23:32.469]                       if (!has_future || version < "1.8.0") {
[13:23:32.469]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.469]                           "", base::R.version$version.string), 
[13:23:32.469]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:32.469]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.469]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.469]                             "release", "version")], collapse = " "), 
[13:23:32.469]                           hostname = base::Sys.info()[["nodename"]])
[13:23:32.469]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.469]                           info)
[13:23:32.469]                         info <- base::paste(info, collapse = "; ")
[13:23:32.469]                         if (!has_future) {
[13:23:32.469]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.469]                             info)
[13:23:32.469]                         }
[13:23:32.469]                         else {
[13:23:32.469]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.469]                             info, version)
[13:23:32.469]                         }
[13:23:32.469]                         base::stop(msg)
[13:23:32.469]                       }
[13:23:32.469]                     })
[13:23:32.469]                   }
[13:23:32.469]                   options(future.plan = NULL)
[13:23:32.469]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.469]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.469]                 }
[13:23:32.469]                 ...future.workdir <- getwd()
[13:23:32.469]             }
[13:23:32.469]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.469]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.469]         }
[13:23:32.469]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.469]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:32.469]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.469]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.469]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.469]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.469]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.469]             base::names(...future.oldOptions))
[13:23:32.469]     }
[13:23:32.469]     if (FALSE) {
[13:23:32.469]     }
[13:23:32.469]     else {
[13:23:32.469]         if (TRUE) {
[13:23:32.469]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.469]                 open = "w")
[13:23:32.469]         }
[13:23:32.469]         else {
[13:23:32.469]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.469]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.469]         }
[13:23:32.469]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.469]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.469]             base::sink(type = "output", split = FALSE)
[13:23:32.469]             base::close(...future.stdout)
[13:23:32.469]         }, add = TRUE)
[13:23:32.469]     }
[13:23:32.469]     ...future.frame <- base::sys.nframe()
[13:23:32.469]     ...future.conditions <- base::list()
[13:23:32.469]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.469]     if (FALSE) {
[13:23:32.469]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.469]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.469]     }
[13:23:32.469]     ...future.result <- base::tryCatch({
[13:23:32.469]         base::withCallingHandlers({
[13:23:32.469]             ...future.value <- base::withVisible(base::local({
[13:23:32.469]                 x <- x()
[13:23:32.469]                 x
[13:23:32.469]             }))
[13:23:32.469]             future::FutureResult(value = ...future.value$value, 
[13:23:32.469]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.469]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.469]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.469]                     ...future.globalenv.names))
[13:23:32.469]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.469]         }, condition = base::local({
[13:23:32.469]             c <- base::c
[13:23:32.469]             inherits <- base::inherits
[13:23:32.469]             invokeRestart <- base::invokeRestart
[13:23:32.469]             length <- base::length
[13:23:32.469]             list <- base::list
[13:23:32.469]             seq.int <- base::seq.int
[13:23:32.469]             signalCondition <- base::signalCondition
[13:23:32.469]             sys.calls <- base::sys.calls
[13:23:32.469]             `[[` <- base::`[[`
[13:23:32.469]             `+` <- base::`+`
[13:23:32.469]             `<<-` <- base::`<<-`
[13:23:32.469]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.469]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.469]                   3L)]
[13:23:32.469]             }
[13:23:32.469]             function(cond) {
[13:23:32.469]                 is_error <- inherits(cond, "error")
[13:23:32.469]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.469]                   NULL)
[13:23:32.469]                 if (is_error) {
[13:23:32.469]                   sessionInformation <- function() {
[13:23:32.469]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.469]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.469]                       search = base::search(), system = base::Sys.info())
[13:23:32.469]                   }
[13:23:32.469]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.469]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.469]                     cond$call), session = sessionInformation(), 
[13:23:32.469]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.469]                   signalCondition(cond)
[13:23:32.469]                 }
[13:23:32.469]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.469]                 "immediateCondition"))) {
[13:23:32.469]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.469]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.469]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.469]                   if (TRUE && !signal) {
[13:23:32.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.469]                     {
[13:23:32.469]                       inherits <- base::inherits
[13:23:32.469]                       invokeRestart <- base::invokeRestart
[13:23:32.469]                       is.null <- base::is.null
[13:23:32.469]                       muffled <- FALSE
[13:23:32.469]                       if (inherits(cond, "message")) {
[13:23:32.469]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.469]                         if (muffled) 
[13:23:32.469]                           invokeRestart("muffleMessage")
[13:23:32.469]                       }
[13:23:32.469]                       else if (inherits(cond, "warning")) {
[13:23:32.469]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.469]                         if (muffled) 
[13:23:32.469]                           invokeRestart("muffleWarning")
[13:23:32.469]                       }
[13:23:32.469]                       else if (inherits(cond, "condition")) {
[13:23:32.469]                         if (!is.null(pattern)) {
[13:23:32.469]                           computeRestarts <- base::computeRestarts
[13:23:32.469]                           grepl <- base::grepl
[13:23:32.469]                           restarts <- computeRestarts(cond)
[13:23:32.469]                           for (restart in restarts) {
[13:23:32.469]                             name <- restart$name
[13:23:32.469]                             if (is.null(name)) 
[13:23:32.469]                               next
[13:23:32.469]                             if (!grepl(pattern, name)) 
[13:23:32.469]                               next
[13:23:32.469]                             invokeRestart(restart)
[13:23:32.469]                             muffled <- TRUE
[13:23:32.469]                             break
[13:23:32.469]                           }
[13:23:32.469]                         }
[13:23:32.469]                       }
[13:23:32.469]                       invisible(muffled)
[13:23:32.469]                     }
[13:23:32.469]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.469]                   }
[13:23:32.469]                 }
[13:23:32.469]                 else {
[13:23:32.469]                   if (TRUE) {
[13:23:32.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.469]                     {
[13:23:32.469]                       inherits <- base::inherits
[13:23:32.469]                       invokeRestart <- base::invokeRestart
[13:23:32.469]                       is.null <- base::is.null
[13:23:32.469]                       muffled <- FALSE
[13:23:32.469]                       if (inherits(cond, "message")) {
[13:23:32.469]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.469]                         if (muffled) 
[13:23:32.469]                           invokeRestart("muffleMessage")
[13:23:32.469]                       }
[13:23:32.469]                       else if (inherits(cond, "warning")) {
[13:23:32.469]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.469]                         if (muffled) 
[13:23:32.469]                           invokeRestart("muffleWarning")
[13:23:32.469]                       }
[13:23:32.469]                       else if (inherits(cond, "condition")) {
[13:23:32.469]                         if (!is.null(pattern)) {
[13:23:32.469]                           computeRestarts <- base::computeRestarts
[13:23:32.469]                           grepl <- base::grepl
[13:23:32.469]                           restarts <- computeRestarts(cond)
[13:23:32.469]                           for (restart in restarts) {
[13:23:32.469]                             name <- restart$name
[13:23:32.469]                             if (is.null(name)) 
[13:23:32.469]                               next
[13:23:32.469]                             if (!grepl(pattern, name)) 
[13:23:32.469]                               next
[13:23:32.469]                             invokeRestart(restart)
[13:23:32.469]                             muffled <- TRUE
[13:23:32.469]                             break
[13:23:32.469]                           }
[13:23:32.469]                         }
[13:23:32.469]                       }
[13:23:32.469]                       invisible(muffled)
[13:23:32.469]                     }
[13:23:32.469]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.469]                   }
[13:23:32.469]                 }
[13:23:32.469]             }
[13:23:32.469]         }))
[13:23:32.469]     }, error = function(ex) {
[13:23:32.469]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.469]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.469]                 ...future.rng), started = ...future.startTime, 
[13:23:32.469]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.469]             version = "1.8"), class = "FutureResult")
[13:23:32.469]     }, finally = {
[13:23:32.469]         if (!identical(...future.workdir, getwd())) 
[13:23:32.469]             setwd(...future.workdir)
[13:23:32.469]         {
[13:23:32.469]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.469]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.469]             }
[13:23:32.469]             base::options(...future.oldOptions)
[13:23:32.469]             if (.Platform$OS.type == "windows") {
[13:23:32.469]                 old_names <- names(...future.oldEnvVars)
[13:23:32.469]                 envs <- base::Sys.getenv()
[13:23:32.469]                 names <- names(envs)
[13:23:32.469]                 common <- intersect(names, old_names)
[13:23:32.469]                 added <- setdiff(names, old_names)
[13:23:32.469]                 removed <- setdiff(old_names, names)
[13:23:32.469]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.469]                   envs[common]]
[13:23:32.469]                 NAMES <- toupper(changed)
[13:23:32.469]                 args <- list()
[13:23:32.469]                 for (kk in seq_along(NAMES)) {
[13:23:32.469]                   name <- changed[[kk]]
[13:23:32.469]                   NAME <- NAMES[[kk]]
[13:23:32.469]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.469]                     next
[13:23:32.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.469]                 }
[13:23:32.469]                 NAMES <- toupper(added)
[13:23:32.469]                 for (kk in seq_along(NAMES)) {
[13:23:32.469]                   name <- added[[kk]]
[13:23:32.469]                   NAME <- NAMES[[kk]]
[13:23:32.469]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.469]                     next
[13:23:32.469]                   args[[name]] <- ""
[13:23:32.469]                 }
[13:23:32.469]                 NAMES <- toupper(removed)
[13:23:32.469]                 for (kk in seq_along(NAMES)) {
[13:23:32.469]                   name <- removed[[kk]]
[13:23:32.469]                   NAME <- NAMES[[kk]]
[13:23:32.469]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.469]                     next
[13:23:32.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.469]                 }
[13:23:32.469]                 if (length(args) > 0) 
[13:23:32.469]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.469]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.469]             }
[13:23:32.469]             else {
[13:23:32.469]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.469]             }
[13:23:32.469]             {
[13:23:32.469]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.469]                   0L) {
[13:23:32.469]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.469]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.469]                   base::options(opts)
[13:23:32.469]                 }
[13:23:32.469]                 {
[13:23:32.469]                   {
[13:23:32.469]                     NULL
[13:23:32.469]                     RNGkind("Mersenne-Twister")
[13:23:32.469]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:32.469]                       inherits = FALSE)
[13:23:32.469]                   }
[13:23:32.469]                   options(future.plan = NULL)
[13:23:32.469]                   if (is.na(NA_character_)) 
[13:23:32.469]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.469]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.469]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:32.469]                   {
[13:23:32.469]                     future <- SequentialFuture(..., envir = envir)
[13:23:32.469]                     if (!future$lazy) 
[13:23:32.469]                       future <- run(future)
[13:23:32.469]                     invisible(future)
[13:23:32.469]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.469]                 }
[13:23:32.469]             }
[13:23:32.469]         }
[13:23:32.469]     })
[13:23:32.469]     if (TRUE) {
[13:23:32.469]         base::sink(type = "output", split = FALSE)
[13:23:32.469]         if (TRUE) {
[13:23:32.469]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.469]         }
[13:23:32.469]         else {
[13:23:32.469]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.469]         }
[13:23:32.469]         base::close(...future.stdout)
[13:23:32.469]         ...future.stdout <- NULL
[13:23:32.469]     }
[13:23:32.469]     ...future.result$conditions <- ...future.conditions
[13:23:32.469]     ...future.result$finished <- base::Sys.time()
[13:23:32.469]     ...future.result
[13:23:32.469] }
[13:23:32.470] assign_globals() ...
[13:23:32.470] List of 1
[13:23:32.470]  $ x:function ()  
[13:23:32.470]  - attr(*, "where")=List of 1
[13:23:32.470]   ..$ x:<environment: R_EmptyEnv> 
[13:23:32.470]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.470]  - attr(*, "resolved")= logi TRUE
[13:23:32.470]  - attr(*, "total_size")= num 1032
[13:23:32.470]  - attr(*, "already-done")= logi TRUE
[13:23:32.473] - reassign environment for ‘x’
[13:23:32.473] - copied ‘x’ to environment
[13:23:32.473] assign_globals() ... done
[13:23:32.474] plan(): Setting new future strategy stack:
[13:23:32.474] List of future strategies:
[13:23:32.474] 1. sequential:
[13:23:32.474]    - args: function (..., envir = parent.frame())
[13:23:32.474]    - tweaked: FALSE
[13:23:32.474]    - call: NULL
[13:23:32.474] plan(): nbrOfWorkers() = 1
[13:23:32.475] plan(): Setting new future strategy stack:
[13:23:32.475] List of future strategies:
[13:23:32.475] 1. sequential:
[13:23:32.475]    - args: function (..., envir = parent.frame())
[13:23:32.475]    - tweaked: FALSE
[13:23:32.475]    - call: plan(strategy)
[13:23:32.476] plan(): nbrOfWorkers() = 1
[13:23:32.476] SequentialFuture started (and completed)
[13:23:32.476] - Launch lazy future ... done
[13:23:32.476] run() for ‘SequentialFuture’ ... done
value(f) = ‘TRUE’
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- Local variables with the same name as globals ...
- plan('multicore') ...
[13:23:32.486] plan(): Setting new future strategy stack:
[13:23:32.486] List of future strategies:
[13:23:32.486] 1. multicore:
[13:23:32.486]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:32.486]    - tweaked: FALSE
[13:23:32.486]    - call: plan(strategy)
[13:23:32.490] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.491] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.491] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:32.492] - globals found: [3] ‘{’, ‘<-’, ‘*’
[13:23:32.492] Searching for globals ... DONE
[13:23:32.493] Resolving globals: TRUE
[13:23:32.493] Resolving any globals that are futures ...
[13:23:32.493] - globals: [3] ‘{’, ‘<-’, ‘*’
[13:23:32.493] Resolving any globals that are futures ... DONE
[13:23:32.493] 
[13:23:32.493] 
[13:23:32.493] getGlobalsAndPackages() ... DONE
[13:23:32.494] run() for ‘Future’ ...
[13:23:32.494] - state: ‘created’
[13:23:32.494] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:32.498] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:32.498] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:32.498]   - Field: ‘label’
[13:23:32.498]   - Field: ‘local’
[13:23:32.498]   - Field: ‘owner’
[13:23:32.498]   - Field: ‘envir’
[13:23:32.499]   - Field: ‘workers’
[13:23:32.499]   - Field: ‘packages’
[13:23:32.501]   - Field: ‘gc’
[13:23:32.501]   - Field: ‘job’
[13:23:32.501]   - Field: ‘conditions’
[13:23:32.501]   - Field: ‘expr’
[13:23:32.501]   - Field: ‘uuid’
[13:23:32.501]   - Field: ‘seed’
[13:23:32.501]   - Field: ‘version’
[13:23:32.501]   - Field: ‘result’
[13:23:32.502]   - Field: ‘asynchronous’
[13:23:32.502]   - Field: ‘calls’
[13:23:32.502]   - Field: ‘globals’
[13:23:32.502]   - Field: ‘stdout’
[13:23:32.502]   - Field: ‘earlySignal’
[13:23:32.502]   - Field: ‘lazy’
[13:23:32.502]   - Field: ‘state’
[13:23:32.502] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:32.502] - Launch lazy future ...
[13:23:32.504] Packages needed by the future expression (n = 0): <none>
[13:23:32.504] Packages needed by future strategies (n = 0): <none>
[13:23:32.504] {
[13:23:32.504]     {
[13:23:32.504]         {
[13:23:32.504]             ...future.startTime <- base::Sys.time()
[13:23:32.504]             {
[13:23:32.504]                 {
[13:23:32.504]                   {
[13:23:32.504]                     {
[13:23:32.504]                       base::local({
[13:23:32.504]                         has_future <- base::requireNamespace("future", 
[13:23:32.504]                           quietly = TRUE)
[13:23:32.504]                         if (has_future) {
[13:23:32.504]                           ns <- base::getNamespace("future")
[13:23:32.504]                           version <- ns[[".package"]][["version"]]
[13:23:32.504]                           if (is.null(version)) 
[13:23:32.504]                             version <- utils::packageVersion("future")
[13:23:32.504]                         }
[13:23:32.504]                         else {
[13:23:32.504]                           version <- NULL
[13:23:32.504]                         }
[13:23:32.504]                         if (!has_future || version < "1.8.0") {
[13:23:32.504]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.504]                             "", base::R.version$version.string), 
[13:23:32.504]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:32.504]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.504]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.504]                               "release", "version")], collapse = " "), 
[13:23:32.504]                             hostname = base::Sys.info()[["nodename"]])
[13:23:32.504]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.504]                             info)
[13:23:32.504]                           info <- base::paste(info, collapse = "; ")
[13:23:32.504]                           if (!has_future) {
[13:23:32.504]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.504]                               info)
[13:23:32.504]                           }
[13:23:32.504]                           else {
[13:23:32.504]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.504]                               info, version)
[13:23:32.504]                           }
[13:23:32.504]                           base::stop(msg)
[13:23:32.504]                         }
[13:23:32.504]                       })
[13:23:32.504]                     }
[13:23:32.504]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:32.504]                     base::options(mc.cores = 1L)
[13:23:32.504]                   }
[13:23:32.504]                   options(future.plan = NULL)
[13:23:32.504]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.504]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.504]                 }
[13:23:32.504]                 ...future.workdir <- getwd()
[13:23:32.504]             }
[13:23:32.504]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.504]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.504]         }
[13:23:32.504]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.504]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:32.504]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.504]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.504]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.504]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.504]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.504]             base::names(...future.oldOptions))
[13:23:32.504]     }
[13:23:32.504]     if (FALSE) {
[13:23:32.504]     }
[13:23:32.504]     else {
[13:23:32.504]         if (TRUE) {
[13:23:32.504]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.504]                 open = "w")
[13:23:32.504]         }
[13:23:32.504]         else {
[13:23:32.504]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.504]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.504]         }
[13:23:32.504]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.504]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.504]             base::sink(type = "output", split = FALSE)
[13:23:32.504]             base::close(...future.stdout)
[13:23:32.504]         }, add = TRUE)
[13:23:32.504]     }
[13:23:32.504]     ...future.frame <- base::sys.nframe()
[13:23:32.504]     ...future.conditions <- base::list()
[13:23:32.504]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.504]     if (FALSE) {
[13:23:32.504]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.504]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.504]     }
[13:23:32.504]     ...future.result <- base::tryCatch({
[13:23:32.504]         base::withCallingHandlers({
[13:23:32.504]             ...future.value <- base::withVisible(base::local({
[13:23:32.504]                 withCallingHandlers({
[13:23:32.504]                   {
[13:23:32.504]                     b <- a
[13:23:32.504]                     a <- 2
[13:23:32.504]                     a * b
[13:23:32.504]                   }
[13:23:32.504]                 }, immediateCondition = function(cond) {
[13:23:32.504]                   save_rds <- function (object, pathname, ...) 
[13:23:32.504]                   {
[13:23:32.504]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:32.504]                     if (file_test("-f", pathname_tmp)) {
[13:23:32.504]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.504]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:32.504]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.504]                         fi_tmp[["mtime"]])
[13:23:32.504]                     }
[13:23:32.504]                     tryCatch({
[13:23:32.504]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:32.504]                     }, error = function(ex) {
[13:23:32.504]                       msg <- conditionMessage(ex)
[13:23:32.504]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.504]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:32.504]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.504]                         fi_tmp[["mtime"]], msg)
[13:23:32.504]                       ex$message <- msg
[13:23:32.504]                       stop(ex)
[13:23:32.504]                     })
[13:23:32.504]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:32.504]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:32.504]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:32.504]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.504]                       fi <- file.info(pathname)
[13:23:32.504]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:32.504]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.504]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:32.504]                         fi[["size"]], fi[["mtime"]])
[13:23:32.504]                       stop(msg)
[13:23:32.504]                     }
[13:23:32.504]                     invisible(pathname)
[13:23:32.504]                   }
[13:23:32.504]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:32.504]                     rootPath = tempdir()) 
[13:23:32.504]                   {
[13:23:32.504]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:32.504]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:32.504]                       tmpdir = path, fileext = ".rds")
[13:23:32.504]                     save_rds(obj, file)
[13:23:32.504]                   }
[13:23:32.504]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:32.504]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.504]                   {
[13:23:32.504]                     inherits <- base::inherits
[13:23:32.504]                     invokeRestart <- base::invokeRestart
[13:23:32.504]                     is.null <- base::is.null
[13:23:32.504]                     muffled <- FALSE
[13:23:32.504]                     if (inherits(cond, "message")) {
[13:23:32.504]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:32.504]                       if (muffled) 
[13:23:32.504]                         invokeRestart("muffleMessage")
[13:23:32.504]                     }
[13:23:32.504]                     else if (inherits(cond, "warning")) {
[13:23:32.504]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:32.504]                       if (muffled) 
[13:23:32.504]                         invokeRestart("muffleWarning")
[13:23:32.504]                     }
[13:23:32.504]                     else if (inherits(cond, "condition")) {
[13:23:32.504]                       if (!is.null(pattern)) {
[13:23:32.504]                         computeRestarts <- base::computeRestarts
[13:23:32.504]                         grepl <- base::grepl
[13:23:32.504]                         restarts <- computeRestarts(cond)
[13:23:32.504]                         for (restart in restarts) {
[13:23:32.504]                           name <- restart$name
[13:23:32.504]                           if (is.null(name)) 
[13:23:32.504]                             next
[13:23:32.504]                           if (!grepl(pattern, name)) 
[13:23:32.504]                             next
[13:23:32.504]                           invokeRestart(restart)
[13:23:32.504]                           muffled <- TRUE
[13:23:32.504]                           break
[13:23:32.504]                         }
[13:23:32.504]                       }
[13:23:32.504]                     }
[13:23:32.504]                     invisible(muffled)
[13:23:32.504]                   }
[13:23:32.504]                   muffleCondition(cond)
[13:23:32.504]                 })
[13:23:32.504]             }))
[13:23:32.504]             future::FutureResult(value = ...future.value$value, 
[13:23:32.504]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.504]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.504]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.504]                     ...future.globalenv.names))
[13:23:32.504]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.504]         }, condition = base::local({
[13:23:32.504]             c <- base::c
[13:23:32.504]             inherits <- base::inherits
[13:23:32.504]             invokeRestart <- base::invokeRestart
[13:23:32.504]             length <- base::length
[13:23:32.504]             list <- base::list
[13:23:32.504]             seq.int <- base::seq.int
[13:23:32.504]             signalCondition <- base::signalCondition
[13:23:32.504]             sys.calls <- base::sys.calls
[13:23:32.504]             `[[` <- base::`[[`
[13:23:32.504]             `+` <- base::`+`
[13:23:32.504]             `<<-` <- base::`<<-`
[13:23:32.504]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.504]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.504]                   3L)]
[13:23:32.504]             }
[13:23:32.504]             function(cond) {
[13:23:32.504]                 is_error <- inherits(cond, "error")
[13:23:32.504]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.504]                   NULL)
[13:23:32.504]                 if (is_error) {
[13:23:32.504]                   sessionInformation <- function() {
[13:23:32.504]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.504]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.504]                       search = base::search(), system = base::Sys.info())
[13:23:32.504]                   }
[13:23:32.504]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.504]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.504]                     cond$call), session = sessionInformation(), 
[13:23:32.504]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.504]                   signalCondition(cond)
[13:23:32.504]                 }
[13:23:32.504]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.504]                 "immediateCondition"))) {
[13:23:32.504]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.504]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.504]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.504]                   if (TRUE && !signal) {
[13:23:32.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.504]                     {
[13:23:32.504]                       inherits <- base::inherits
[13:23:32.504]                       invokeRestart <- base::invokeRestart
[13:23:32.504]                       is.null <- base::is.null
[13:23:32.504]                       muffled <- FALSE
[13:23:32.504]                       if (inherits(cond, "message")) {
[13:23:32.504]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.504]                         if (muffled) 
[13:23:32.504]                           invokeRestart("muffleMessage")
[13:23:32.504]                       }
[13:23:32.504]                       else if (inherits(cond, "warning")) {
[13:23:32.504]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.504]                         if (muffled) 
[13:23:32.504]                           invokeRestart("muffleWarning")
[13:23:32.504]                       }
[13:23:32.504]                       else if (inherits(cond, "condition")) {
[13:23:32.504]                         if (!is.null(pattern)) {
[13:23:32.504]                           computeRestarts <- base::computeRestarts
[13:23:32.504]                           grepl <- base::grepl
[13:23:32.504]                           restarts <- computeRestarts(cond)
[13:23:32.504]                           for (restart in restarts) {
[13:23:32.504]                             name <- restart$name
[13:23:32.504]                             if (is.null(name)) 
[13:23:32.504]                               next
[13:23:32.504]                             if (!grepl(pattern, name)) 
[13:23:32.504]                               next
[13:23:32.504]                             invokeRestart(restart)
[13:23:32.504]                             muffled <- TRUE
[13:23:32.504]                             break
[13:23:32.504]                           }
[13:23:32.504]                         }
[13:23:32.504]                       }
[13:23:32.504]                       invisible(muffled)
[13:23:32.504]                     }
[13:23:32.504]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.504]                   }
[13:23:32.504]                 }
[13:23:32.504]                 else {
[13:23:32.504]                   if (TRUE) {
[13:23:32.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.504]                     {
[13:23:32.504]                       inherits <- base::inherits
[13:23:32.504]                       invokeRestart <- base::invokeRestart
[13:23:32.504]                       is.null <- base::is.null
[13:23:32.504]                       muffled <- FALSE
[13:23:32.504]                       if (inherits(cond, "message")) {
[13:23:32.504]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.504]                         if (muffled) 
[13:23:32.504]                           invokeRestart("muffleMessage")
[13:23:32.504]                       }
[13:23:32.504]                       else if (inherits(cond, "warning")) {
[13:23:32.504]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.504]                         if (muffled) 
[13:23:32.504]                           invokeRestart("muffleWarning")
[13:23:32.504]                       }
[13:23:32.504]                       else if (inherits(cond, "condition")) {
[13:23:32.504]                         if (!is.null(pattern)) {
[13:23:32.504]                           computeRestarts <- base::computeRestarts
[13:23:32.504]                           grepl <- base::grepl
[13:23:32.504]                           restarts <- computeRestarts(cond)
[13:23:32.504]                           for (restart in restarts) {
[13:23:32.504]                             name <- restart$name
[13:23:32.504]                             if (is.null(name)) 
[13:23:32.504]                               next
[13:23:32.504]                             if (!grepl(pattern, name)) 
[13:23:32.504]                               next
[13:23:32.504]                             invokeRestart(restart)
[13:23:32.504]                             muffled <- TRUE
[13:23:32.504]                             break
[13:23:32.504]                           }
[13:23:32.504]                         }
[13:23:32.504]                       }
[13:23:32.504]                       invisible(muffled)
[13:23:32.504]                     }
[13:23:32.504]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.504]                   }
[13:23:32.504]                 }
[13:23:32.504]             }
[13:23:32.504]         }))
[13:23:32.504]     }, error = function(ex) {
[13:23:32.504]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.504]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.504]                 ...future.rng), started = ...future.startTime, 
[13:23:32.504]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.504]             version = "1.8"), class = "FutureResult")
[13:23:32.504]     }, finally = {
[13:23:32.504]         if (!identical(...future.workdir, getwd())) 
[13:23:32.504]             setwd(...future.workdir)
[13:23:32.504]         {
[13:23:32.504]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.504]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.504]             }
[13:23:32.504]             base::options(...future.oldOptions)
[13:23:32.504]             if (.Platform$OS.type == "windows") {
[13:23:32.504]                 old_names <- names(...future.oldEnvVars)
[13:23:32.504]                 envs <- base::Sys.getenv()
[13:23:32.504]                 names <- names(envs)
[13:23:32.504]                 common <- intersect(names, old_names)
[13:23:32.504]                 added <- setdiff(names, old_names)
[13:23:32.504]                 removed <- setdiff(old_names, names)
[13:23:32.504]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.504]                   envs[common]]
[13:23:32.504]                 NAMES <- toupper(changed)
[13:23:32.504]                 args <- list()
[13:23:32.504]                 for (kk in seq_along(NAMES)) {
[13:23:32.504]                   name <- changed[[kk]]
[13:23:32.504]                   NAME <- NAMES[[kk]]
[13:23:32.504]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.504]                     next
[13:23:32.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.504]                 }
[13:23:32.504]                 NAMES <- toupper(added)
[13:23:32.504]                 for (kk in seq_along(NAMES)) {
[13:23:32.504]                   name <- added[[kk]]
[13:23:32.504]                   NAME <- NAMES[[kk]]
[13:23:32.504]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.504]                     next
[13:23:32.504]                   args[[name]] <- ""
[13:23:32.504]                 }
[13:23:32.504]                 NAMES <- toupper(removed)
[13:23:32.504]                 for (kk in seq_along(NAMES)) {
[13:23:32.504]                   name <- removed[[kk]]
[13:23:32.504]                   NAME <- NAMES[[kk]]
[13:23:32.504]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.504]                     next
[13:23:32.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.504]                 }
[13:23:32.504]                 if (length(args) > 0) 
[13:23:32.504]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.504]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.504]             }
[13:23:32.504]             else {
[13:23:32.504]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.504]             }
[13:23:32.504]             {
[13:23:32.504]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.504]                   0L) {
[13:23:32.504]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.504]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.504]                   base::options(opts)
[13:23:32.504]                 }
[13:23:32.504]                 {
[13:23:32.504]                   {
[13:23:32.504]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:32.504]                     NULL
[13:23:32.504]                   }
[13:23:32.504]                   options(future.plan = NULL)
[13:23:32.504]                   if (is.na(NA_character_)) 
[13:23:32.504]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.504]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.504]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:32.504]                     envir = parent.frame()) 
[13:23:32.504]                   {
[13:23:32.504]                     default_workers <- missing(workers)
[13:23:32.504]                     if (is.function(workers)) 
[13:23:32.504]                       workers <- workers()
[13:23:32.504]                     workers <- structure(as.integer(workers), 
[13:23:32.504]                       class = class(workers))
[13:23:32.504]                     stop_if_not(is.finite(workers), workers >= 
[13:23:32.504]                       1L)
[13:23:32.504]                     if ((workers == 1L && !inherits(workers, 
[13:23:32.504]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:32.504]                       if (default_workers) 
[13:23:32.504]                         supportsMulticore(warn = TRUE)
[13:23:32.504]                       return(sequential(..., envir = envir))
[13:23:32.504]                     }
[13:23:32.504]                     oopts <- options(mc.cores = workers)
[13:23:32.504]                     on.exit(options(oopts))
[13:23:32.504]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:32.504]                       envir = envir)
[13:23:32.504]                     if (!future$lazy) 
[13:23:32.504]                       future <- run(future)
[13:23:32.504]                     invisible(future)
[13:23:32.504]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.504]                 }
[13:23:32.504]             }
[13:23:32.504]         }
[13:23:32.504]     })
[13:23:32.504]     if (TRUE) {
[13:23:32.504]         base::sink(type = "output", split = FALSE)
[13:23:32.504]         if (TRUE) {
[13:23:32.504]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.504]         }
[13:23:32.504]         else {
[13:23:32.504]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.504]         }
[13:23:32.504]         base::close(...future.stdout)
[13:23:32.504]         ...future.stdout <- NULL
[13:23:32.504]     }
[13:23:32.504]     ...future.result$conditions <- ...future.conditions
[13:23:32.504]     ...future.result$finished <- base::Sys.time()
[13:23:32.504]     ...future.result
[13:23:32.504] }
[13:23:32.507] requestCore(): workers = 2
[13:23:32.510] MulticoreFuture started
[13:23:32.511] - Launch lazy future ... done
[13:23:32.511] plan(): Setting new future strategy stack:
[13:23:32.511] run() for ‘MulticoreFuture’ ... done
[13:23:32.511] List of future strategies:
[13:23:32.511] 1. sequential:
[13:23:32.511]    - args: function (..., envir = parent.frame())
[13:23:32.511]    - tweaked: FALSE
[13:23:32.511]    - call: NULL
[13:23:32.512] plan(): nbrOfWorkers() = 1
[13:23:32.513] result() for MulticoreFuture ...
[13:23:32.515] plan(): Setting new future strategy stack:
[13:23:32.515] List of future strategies:
[13:23:32.515] 1. multicore:
[13:23:32.515]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:32.515]    - tweaked: FALSE
[13:23:32.515]    - call: plan(strategy)
[13:23:32.521] plan(): nbrOfWorkers() = 2
[13:23:32.526] result() for MulticoreFuture ...
[13:23:32.526] result() for MulticoreFuture ... done
[13:23:32.527] result() for MulticoreFuture ... done
[13:23:32.527] result() for MulticoreFuture ...
[13:23:32.527] result() for MulticoreFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.528] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.528] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:32.530] - globals found: [3] ‘{’, ‘<-’, ‘*’
[13:23:32.530] Searching for globals ... DONE
[13:23:32.530] Resolving globals: TRUE
[13:23:32.530] Resolving any globals that are futures ...
[13:23:32.530] - globals: [3] ‘{’, ‘<-’, ‘*’
[13:23:32.530] Resolving any globals that are futures ... DONE
[13:23:32.531] 
[13:23:32.531] 
[13:23:32.531] getGlobalsAndPackages() ... DONE
[13:23:32.532] run() for ‘Future’ ...
[13:23:32.532] - state: ‘created’
[13:23:32.532] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:32.536] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:32.536] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:32.537]   - Field: ‘label’
[13:23:32.537]   - Field: ‘local’
[13:23:32.537]   - Field: ‘owner’
[13:23:32.537]   - Field: ‘envir’
[13:23:32.537]   - Field: ‘workers’
[13:23:32.537]   - Field: ‘packages’
[13:23:32.537]   - Field: ‘gc’
[13:23:32.537]   - Field: ‘job’
[13:23:32.538]   - Field: ‘conditions’
[13:23:32.538]   - Field: ‘expr’
[13:23:32.538]   - Field: ‘uuid’
[13:23:32.538]   - Field: ‘seed’
[13:23:32.538]   - Field: ‘version’
[13:23:32.538]   - Field: ‘result’
[13:23:32.538]   - Field: ‘asynchronous’
[13:23:32.538]   - Field: ‘calls’
[13:23:32.538]   - Field: ‘globals’
[13:23:32.539]   - Field: ‘stdout’
[13:23:32.539]   - Field: ‘earlySignal’
[13:23:32.539]   - Field: ‘lazy’
[13:23:32.539]   - Field: ‘state’
[13:23:32.539] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:32.539] - Launch lazy future ...
[13:23:32.540] Packages needed by the future expression (n = 0): <none>
[13:23:32.540] Packages needed by future strategies (n = 0): <none>
[13:23:32.540] {
[13:23:32.540]     {
[13:23:32.540]         {
[13:23:32.540]             ...future.startTime <- base::Sys.time()
[13:23:32.540]             {
[13:23:32.540]                 {
[13:23:32.540]                   {
[13:23:32.540]                     {
[13:23:32.540]                       base::local({
[13:23:32.540]                         has_future <- base::requireNamespace("future", 
[13:23:32.540]                           quietly = TRUE)
[13:23:32.540]                         if (has_future) {
[13:23:32.540]                           ns <- base::getNamespace("future")
[13:23:32.540]                           version <- ns[[".package"]][["version"]]
[13:23:32.540]                           if (is.null(version)) 
[13:23:32.540]                             version <- utils::packageVersion("future")
[13:23:32.540]                         }
[13:23:32.540]                         else {
[13:23:32.540]                           version <- NULL
[13:23:32.540]                         }
[13:23:32.540]                         if (!has_future || version < "1.8.0") {
[13:23:32.540]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.540]                             "", base::R.version$version.string), 
[13:23:32.540]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:32.540]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.540]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.540]                               "release", "version")], collapse = " "), 
[13:23:32.540]                             hostname = base::Sys.info()[["nodename"]])
[13:23:32.540]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.540]                             info)
[13:23:32.540]                           info <- base::paste(info, collapse = "; ")
[13:23:32.540]                           if (!has_future) {
[13:23:32.540]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.540]                               info)
[13:23:32.540]                           }
[13:23:32.540]                           else {
[13:23:32.540]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.540]                               info, version)
[13:23:32.540]                           }
[13:23:32.540]                           base::stop(msg)
[13:23:32.540]                         }
[13:23:32.540]                       })
[13:23:32.540]                     }
[13:23:32.540]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:32.540]                     base::options(mc.cores = 1L)
[13:23:32.540]                   }
[13:23:32.540]                   options(future.plan = NULL)
[13:23:32.540]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.540]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.540]                 }
[13:23:32.540]                 ...future.workdir <- getwd()
[13:23:32.540]             }
[13:23:32.540]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.540]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.540]         }
[13:23:32.540]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.540]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:32.540]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.540]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.540]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.540]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.540]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.540]             base::names(...future.oldOptions))
[13:23:32.540]     }
[13:23:32.540]     if (FALSE) {
[13:23:32.540]     }
[13:23:32.540]     else {
[13:23:32.540]         if (TRUE) {
[13:23:32.540]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.540]                 open = "w")
[13:23:32.540]         }
[13:23:32.540]         else {
[13:23:32.540]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.540]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.540]         }
[13:23:32.540]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.540]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.540]             base::sink(type = "output", split = FALSE)
[13:23:32.540]             base::close(...future.stdout)
[13:23:32.540]         }, add = TRUE)
[13:23:32.540]     }
[13:23:32.540]     ...future.frame <- base::sys.nframe()
[13:23:32.540]     ...future.conditions <- base::list()
[13:23:32.540]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.540]     if (FALSE) {
[13:23:32.540]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.540]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.540]     }
[13:23:32.540]     ...future.result <- base::tryCatch({
[13:23:32.540]         base::withCallingHandlers({
[13:23:32.540]             ...future.value <- base::withVisible(base::local({
[13:23:32.540]                 withCallingHandlers({
[13:23:32.540]                   {
[13:23:32.540]                     b <- a
[13:23:32.540]                     a <- 2
[13:23:32.540]                     a * b
[13:23:32.540]                   }
[13:23:32.540]                 }, immediateCondition = function(cond) {
[13:23:32.540]                   save_rds <- function (object, pathname, ...) 
[13:23:32.540]                   {
[13:23:32.540]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:32.540]                     if (file_test("-f", pathname_tmp)) {
[13:23:32.540]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.540]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:32.540]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.540]                         fi_tmp[["mtime"]])
[13:23:32.540]                     }
[13:23:32.540]                     tryCatch({
[13:23:32.540]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:32.540]                     }, error = function(ex) {
[13:23:32.540]                       msg <- conditionMessage(ex)
[13:23:32.540]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.540]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:32.540]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.540]                         fi_tmp[["mtime"]], msg)
[13:23:32.540]                       ex$message <- msg
[13:23:32.540]                       stop(ex)
[13:23:32.540]                     })
[13:23:32.540]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:32.540]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:32.540]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:32.540]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.540]                       fi <- file.info(pathname)
[13:23:32.540]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:32.540]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.540]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:32.540]                         fi[["size"]], fi[["mtime"]])
[13:23:32.540]                       stop(msg)
[13:23:32.540]                     }
[13:23:32.540]                     invisible(pathname)
[13:23:32.540]                   }
[13:23:32.540]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:32.540]                     rootPath = tempdir()) 
[13:23:32.540]                   {
[13:23:32.540]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:32.540]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:32.540]                       tmpdir = path, fileext = ".rds")
[13:23:32.540]                     save_rds(obj, file)
[13:23:32.540]                   }
[13:23:32.540]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:32.540]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.540]                   {
[13:23:32.540]                     inherits <- base::inherits
[13:23:32.540]                     invokeRestart <- base::invokeRestart
[13:23:32.540]                     is.null <- base::is.null
[13:23:32.540]                     muffled <- FALSE
[13:23:32.540]                     if (inherits(cond, "message")) {
[13:23:32.540]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:32.540]                       if (muffled) 
[13:23:32.540]                         invokeRestart("muffleMessage")
[13:23:32.540]                     }
[13:23:32.540]                     else if (inherits(cond, "warning")) {
[13:23:32.540]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:32.540]                       if (muffled) 
[13:23:32.540]                         invokeRestart("muffleWarning")
[13:23:32.540]                     }
[13:23:32.540]                     else if (inherits(cond, "condition")) {
[13:23:32.540]                       if (!is.null(pattern)) {
[13:23:32.540]                         computeRestarts <- base::computeRestarts
[13:23:32.540]                         grepl <- base::grepl
[13:23:32.540]                         restarts <- computeRestarts(cond)
[13:23:32.540]                         for (restart in restarts) {
[13:23:32.540]                           name <- restart$name
[13:23:32.540]                           if (is.null(name)) 
[13:23:32.540]                             next
[13:23:32.540]                           if (!grepl(pattern, name)) 
[13:23:32.540]                             next
[13:23:32.540]                           invokeRestart(restart)
[13:23:32.540]                           muffled <- TRUE
[13:23:32.540]                           break
[13:23:32.540]                         }
[13:23:32.540]                       }
[13:23:32.540]                     }
[13:23:32.540]                     invisible(muffled)
[13:23:32.540]                   }
[13:23:32.540]                   muffleCondition(cond)
[13:23:32.540]                 })
[13:23:32.540]             }))
[13:23:32.540]             future::FutureResult(value = ...future.value$value, 
[13:23:32.540]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.540]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.540]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.540]                     ...future.globalenv.names))
[13:23:32.540]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.540]         }, condition = base::local({
[13:23:32.540]             c <- base::c
[13:23:32.540]             inherits <- base::inherits
[13:23:32.540]             invokeRestart <- base::invokeRestart
[13:23:32.540]             length <- base::length
[13:23:32.540]             list <- base::list
[13:23:32.540]             seq.int <- base::seq.int
[13:23:32.540]             signalCondition <- base::signalCondition
[13:23:32.540]             sys.calls <- base::sys.calls
[13:23:32.540]             `[[` <- base::`[[`
[13:23:32.540]             `+` <- base::`+`
[13:23:32.540]             `<<-` <- base::`<<-`
[13:23:32.540]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.540]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.540]                   3L)]
[13:23:32.540]             }
[13:23:32.540]             function(cond) {
[13:23:32.540]                 is_error <- inherits(cond, "error")
[13:23:32.540]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.540]                   NULL)
[13:23:32.540]                 if (is_error) {
[13:23:32.540]                   sessionInformation <- function() {
[13:23:32.540]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.540]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.540]                       search = base::search(), system = base::Sys.info())
[13:23:32.540]                   }
[13:23:32.540]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.540]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.540]                     cond$call), session = sessionInformation(), 
[13:23:32.540]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.540]                   signalCondition(cond)
[13:23:32.540]                 }
[13:23:32.540]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.540]                 "immediateCondition"))) {
[13:23:32.540]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.540]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.540]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.540]                   if (TRUE && !signal) {
[13:23:32.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.540]                     {
[13:23:32.540]                       inherits <- base::inherits
[13:23:32.540]                       invokeRestart <- base::invokeRestart
[13:23:32.540]                       is.null <- base::is.null
[13:23:32.540]                       muffled <- FALSE
[13:23:32.540]                       if (inherits(cond, "message")) {
[13:23:32.540]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.540]                         if (muffled) 
[13:23:32.540]                           invokeRestart("muffleMessage")
[13:23:32.540]                       }
[13:23:32.540]                       else if (inherits(cond, "warning")) {
[13:23:32.540]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.540]                         if (muffled) 
[13:23:32.540]                           invokeRestart("muffleWarning")
[13:23:32.540]                       }
[13:23:32.540]                       else if (inherits(cond, "condition")) {
[13:23:32.540]                         if (!is.null(pattern)) {
[13:23:32.540]                           computeRestarts <- base::computeRestarts
[13:23:32.540]                           grepl <- base::grepl
[13:23:32.540]                           restarts <- computeRestarts(cond)
[13:23:32.540]                           for (restart in restarts) {
[13:23:32.540]                             name <- restart$name
[13:23:32.540]                             if (is.null(name)) 
[13:23:32.540]                               next
[13:23:32.540]                             if (!grepl(pattern, name)) 
[13:23:32.540]                               next
[13:23:32.540]                             invokeRestart(restart)
[13:23:32.540]                             muffled <- TRUE
[13:23:32.540]                             break
[13:23:32.540]                           }
[13:23:32.540]                         }
[13:23:32.540]                       }
[13:23:32.540]                       invisible(muffled)
[13:23:32.540]                     }
[13:23:32.540]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.540]                   }
[13:23:32.540]                 }
[13:23:32.540]                 else {
[13:23:32.540]                   if (TRUE) {
[13:23:32.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.540]                     {
[13:23:32.540]                       inherits <- base::inherits
[13:23:32.540]                       invokeRestart <- base::invokeRestart
[13:23:32.540]                       is.null <- base::is.null
[13:23:32.540]                       muffled <- FALSE
[13:23:32.540]                       if (inherits(cond, "message")) {
[13:23:32.540]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.540]                         if (muffled) 
[13:23:32.540]                           invokeRestart("muffleMessage")
[13:23:32.540]                       }
[13:23:32.540]                       else if (inherits(cond, "warning")) {
[13:23:32.540]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.540]                         if (muffled) 
[13:23:32.540]                           invokeRestart("muffleWarning")
[13:23:32.540]                       }
[13:23:32.540]                       else if (inherits(cond, "condition")) {
[13:23:32.540]                         if (!is.null(pattern)) {
[13:23:32.540]                           computeRestarts <- base::computeRestarts
[13:23:32.540]                           grepl <- base::grepl
[13:23:32.540]                           restarts <- computeRestarts(cond)
[13:23:32.540]                           for (restart in restarts) {
[13:23:32.540]                             name <- restart$name
[13:23:32.540]                             if (is.null(name)) 
[13:23:32.540]                               next
[13:23:32.540]                             if (!grepl(pattern, name)) 
[13:23:32.540]                               next
[13:23:32.540]                             invokeRestart(restart)
[13:23:32.540]                             muffled <- TRUE
[13:23:32.540]                             break
[13:23:32.540]                           }
[13:23:32.540]                         }
[13:23:32.540]                       }
[13:23:32.540]                       invisible(muffled)
[13:23:32.540]                     }
[13:23:32.540]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.540]                   }
[13:23:32.540]                 }
[13:23:32.540]             }
[13:23:32.540]         }))
[13:23:32.540]     }, error = function(ex) {
[13:23:32.540]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.540]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.540]                 ...future.rng), started = ...future.startTime, 
[13:23:32.540]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.540]             version = "1.8"), class = "FutureResult")
[13:23:32.540]     }, finally = {
[13:23:32.540]         if (!identical(...future.workdir, getwd())) 
[13:23:32.540]             setwd(...future.workdir)
[13:23:32.540]         {
[13:23:32.540]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.540]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.540]             }
[13:23:32.540]             base::options(...future.oldOptions)
[13:23:32.540]             if (.Platform$OS.type == "windows") {
[13:23:32.540]                 old_names <- names(...future.oldEnvVars)
[13:23:32.540]                 envs <- base::Sys.getenv()
[13:23:32.540]                 names <- names(envs)
[13:23:32.540]                 common <- intersect(names, old_names)
[13:23:32.540]                 added <- setdiff(names, old_names)
[13:23:32.540]                 removed <- setdiff(old_names, names)
[13:23:32.540]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.540]                   envs[common]]
[13:23:32.540]                 NAMES <- toupper(changed)
[13:23:32.540]                 args <- list()
[13:23:32.540]                 for (kk in seq_along(NAMES)) {
[13:23:32.540]                   name <- changed[[kk]]
[13:23:32.540]                   NAME <- NAMES[[kk]]
[13:23:32.540]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.540]                     next
[13:23:32.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.540]                 }
[13:23:32.540]                 NAMES <- toupper(added)
[13:23:32.540]                 for (kk in seq_along(NAMES)) {
[13:23:32.540]                   name <- added[[kk]]
[13:23:32.540]                   NAME <- NAMES[[kk]]
[13:23:32.540]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.540]                     next
[13:23:32.540]                   args[[name]] <- ""
[13:23:32.540]                 }
[13:23:32.540]                 NAMES <- toupper(removed)
[13:23:32.540]                 for (kk in seq_along(NAMES)) {
[13:23:32.540]                   name <- removed[[kk]]
[13:23:32.540]                   NAME <- NAMES[[kk]]
[13:23:32.540]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.540]                     next
[13:23:32.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.540]                 }
[13:23:32.540]                 if (length(args) > 0) 
[13:23:32.540]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.540]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.540]             }
[13:23:32.540]             else {
[13:23:32.540]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.540]             }
[13:23:32.540]             {
[13:23:32.540]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.540]                   0L) {
[13:23:32.540]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.540]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.540]                   base::options(opts)
[13:23:32.540]                 }
[13:23:32.540]                 {
[13:23:32.540]                   {
[13:23:32.540]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:32.540]                     NULL
[13:23:32.540]                   }
[13:23:32.540]                   options(future.plan = NULL)
[13:23:32.540]                   if (is.na(NA_character_)) 
[13:23:32.540]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.540]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.540]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:32.540]                     envir = parent.frame()) 
[13:23:32.540]                   {
[13:23:32.540]                     default_workers <- missing(workers)
[13:23:32.540]                     if (is.function(workers)) 
[13:23:32.540]                       workers <- workers()
[13:23:32.540]                     workers <- structure(as.integer(workers), 
[13:23:32.540]                       class = class(workers))
[13:23:32.540]                     stop_if_not(is.finite(workers), workers >= 
[13:23:32.540]                       1L)
[13:23:32.540]                     if ((workers == 1L && !inherits(workers, 
[13:23:32.540]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:32.540]                       if (default_workers) 
[13:23:32.540]                         supportsMulticore(warn = TRUE)
[13:23:32.540]                       return(sequential(..., envir = envir))
[13:23:32.540]                     }
[13:23:32.540]                     oopts <- options(mc.cores = workers)
[13:23:32.540]                     on.exit(options(oopts))
[13:23:32.540]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:32.540]                       envir = envir)
[13:23:32.540]                     if (!future$lazy) 
[13:23:32.540]                       future <- run(future)
[13:23:32.540]                     invisible(future)
[13:23:32.540]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.540]                 }
[13:23:32.540]             }
[13:23:32.540]         }
[13:23:32.540]     })
[13:23:32.540]     if (TRUE) {
[13:23:32.540]         base::sink(type = "output", split = FALSE)
[13:23:32.540]         if (TRUE) {
[13:23:32.540]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.540]         }
[13:23:32.540]         else {
[13:23:32.540]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.540]         }
[13:23:32.540]         base::close(...future.stdout)
[13:23:32.540]         ...future.stdout <- NULL
[13:23:32.540]     }
[13:23:32.540]     ...future.result$conditions <- ...future.conditions
[13:23:32.540]     ...future.result$finished <- base::Sys.time()
[13:23:32.540]     ...future.result
[13:23:32.540] }
[13:23:32.543] requestCore(): workers = 2
[13:23:32.545] MulticoreFuture started
[13:23:32.546] - Launch lazy future ... done
[13:23:32.546] run() for ‘MulticoreFuture’ ... done
[13:23:32.546] result() for MulticoreFuture ...
[13:23:32.547] plan(): Setting new future strategy stack:
[13:23:32.547] List of future strategies:
[13:23:32.547] 1. sequential:
[13:23:32.547]    - args: function (..., envir = parent.frame())
[13:23:32.547]    - tweaked: FALSE
[13:23:32.547]    - call: NULL
[13:23:32.548] plan(): nbrOfWorkers() = 1
[13:23:32.550] plan(): Setting new future strategy stack:
[13:23:32.550] List of future strategies:
[13:23:32.550] 1. multicore:
[13:23:32.550]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:32.550]    - tweaked: FALSE
[13:23:32.550]    - call: plan(strategy)
[13:23:32.555] plan(): nbrOfWorkers() = 2
[13:23:32.562] result() for MulticoreFuture ...
[13:23:32.562] result() for MulticoreFuture ... done
[13:23:32.562] signalConditions() ...
[13:23:32.562]  - include = ‘immediateCondition’
[13:23:32.562]  - exclude = 
[13:23:32.562]  - resignal = FALSE
[13:23:32.562]  - Number of conditions: 1
[13:23:32.563] signalConditions() ... done
[13:23:32.563] result() for MulticoreFuture ... done
[13:23:32.563] result() for MulticoreFuture ...
[13:23:32.563] result() for MulticoreFuture ... done
[13:23:32.563] signalConditions() ...
[13:23:32.563]  - include = ‘immediateCondition’
[13:23:32.563]  - exclude = 
[13:23:32.563]  - resignal = FALSE
[13:23:32.564]  - Number of conditions: 1
[13:23:32.564] signalConditions() ... done
[13:23:32.564] Future state: ‘finished’
[13:23:32.564] result() for MulticoreFuture ...
[13:23:32.564] result() for MulticoreFuture ... done
[13:23:32.564] signalConditions() ...
[13:23:32.564]  - include = ‘condition’
[13:23:32.564]  - exclude = ‘immediateCondition’
[13:23:32.565]  - resignal = TRUE
[13:23:32.565]  - Number of conditions: 1
[13:23:32.565]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:23:32.565] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 39
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "47b98e4ec3a9" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:23:32"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.598] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.598] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:32.600] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:32.600] Searching for globals ... DONE
[13:23:32.601] Resolving globals: TRUE
[13:23:32.601] Resolving any globals that are futures ...
[13:23:32.601] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:32.601] Resolving any globals that are futures ... DONE
[13:23:32.601] Resolving futures part of globals (recursively) ...
[13:23:32.601] resolve() on list ...
[13:23:32.602]  recursive: 99
[13:23:32.602]  length: 1
[13:23:32.602]  elements: ‘ii’
[13:23:32.602]  length: 0 (resolved future 1)
[13:23:32.602] resolve() on list ... DONE
[13:23:32.602] - globals: [1] ‘ii’
[13:23:32.602] Resolving futures part of globals (recursively) ... DONE
[13:23:32.602] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:32.603] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:32.603] - globals: [1] ‘ii’
[13:23:32.603] 
[13:23:32.603] getGlobalsAndPackages() ... DONE
[13:23:32.603] run() for ‘Future’ ...
[13:23:32.603] - state: ‘created’
[13:23:32.604] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:32.607] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:32.608] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:32.608]   - Field: ‘label’
[13:23:32.608]   - Field: ‘local’
[13:23:32.608]   - Field: ‘owner’
[13:23:32.608]   - Field: ‘envir’
[13:23:32.608]   - Field: ‘workers’
[13:23:32.608]   - Field: ‘packages’
[13:23:32.608]   - Field: ‘gc’
[13:23:32.608]   - Field: ‘job’
[13:23:32.609]   - Field: ‘conditions’
[13:23:32.609]   - Field: ‘expr’
[13:23:32.609]   - Field: ‘uuid’
[13:23:32.609]   - Field: ‘seed’
[13:23:32.609]   - Field: ‘version’
[13:23:32.609]   - Field: ‘result’
[13:23:32.609]   - Field: ‘asynchronous’
[13:23:32.609]   - Field: ‘calls’
[13:23:32.609]   - Field: ‘globals’
[13:23:32.609]   - Field: ‘stdout’
[13:23:32.609]   - Field: ‘earlySignal’
[13:23:32.610]   - Field: ‘lazy’
[13:23:32.610]   - Field: ‘state’
[13:23:32.610] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:32.610] - Launch lazy future ...
[13:23:32.610] Packages needed by the future expression (n = 0): <none>
[13:23:32.610] Packages needed by future strategies (n = 0): <none>
[13:23:32.611] {
[13:23:32.611]     {
[13:23:32.611]         {
[13:23:32.611]             ...future.startTime <- base::Sys.time()
[13:23:32.611]             {
[13:23:32.611]                 {
[13:23:32.611]                   {
[13:23:32.611]                     {
[13:23:32.611]                       base::local({
[13:23:32.611]                         has_future <- base::requireNamespace("future", 
[13:23:32.611]                           quietly = TRUE)
[13:23:32.611]                         if (has_future) {
[13:23:32.611]                           ns <- base::getNamespace("future")
[13:23:32.611]                           version <- ns[[".package"]][["version"]]
[13:23:32.611]                           if (is.null(version)) 
[13:23:32.611]                             version <- utils::packageVersion("future")
[13:23:32.611]                         }
[13:23:32.611]                         else {
[13:23:32.611]                           version <- NULL
[13:23:32.611]                         }
[13:23:32.611]                         if (!has_future || version < "1.8.0") {
[13:23:32.611]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.611]                             "", base::R.version$version.string), 
[13:23:32.611]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:32.611]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.611]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.611]                               "release", "version")], collapse = " "), 
[13:23:32.611]                             hostname = base::Sys.info()[["nodename"]])
[13:23:32.611]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.611]                             info)
[13:23:32.611]                           info <- base::paste(info, collapse = "; ")
[13:23:32.611]                           if (!has_future) {
[13:23:32.611]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.611]                               info)
[13:23:32.611]                           }
[13:23:32.611]                           else {
[13:23:32.611]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.611]                               info, version)
[13:23:32.611]                           }
[13:23:32.611]                           base::stop(msg)
[13:23:32.611]                         }
[13:23:32.611]                       })
[13:23:32.611]                     }
[13:23:32.611]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:32.611]                     base::options(mc.cores = 1L)
[13:23:32.611]                   }
[13:23:32.611]                   options(future.plan = NULL)
[13:23:32.611]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.611]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.611]                 }
[13:23:32.611]                 ...future.workdir <- getwd()
[13:23:32.611]             }
[13:23:32.611]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.611]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.611]         }
[13:23:32.611]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.611]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:32.611]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.611]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.611]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.611]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.611]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.611]             base::names(...future.oldOptions))
[13:23:32.611]     }
[13:23:32.611]     if (FALSE) {
[13:23:32.611]     }
[13:23:32.611]     else {
[13:23:32.611]         if (TRUE) {
[13:23:32.611]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.611]                 open = "w")
[13:23:32.611]         }
[13:23:32.611]         else {
[13:23:32.611]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.611]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.611]         }
[13:23:32.611]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.611]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.611]             base::sink(type = "output", split = FALSE)
[13:23:32.611]             base::close(...future.stdout)
[13:23:32.611]         }, add = TRUE)
[13:23:32.611]     }
[13:23:32.611]     ...future.frame <- base::sys.nframe()
[13:23:32.611]     ...future.conditions <- base::list()
[13:23:32.611]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.611]     if (FALSE) {
[13:23:32.611]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.611]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.611]     }
[13:23:32.611]     ...future.result <- base::tryCatch({
[13:23:32.611]         base::withCallingHandlers({
[13:23:32.611]             ...future.value <- base::withVisible(base::local({
[13:23:32.611]                 withCallingHandlers({
[13:23:32.611]                   {
[13:23:32.611]                     b <- a * ii
[13:23:32.611]                     a <- 0
[13:23:32.611]                     b
[13:23:32.611]                   }
[13:23:32.611]                 }, immediateCondition = function(cond) {
[13:23:32.611]                   save_rds <- function (object, pathname, ...) 
[13:23:32.611]                   {
[13:23:32.611]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:32.611]                     if (file_test("-f", pathname_tmp)) {
[13:23:32.611]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.611]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:32.611]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.611]                         fi_tmp[["mtime"]])
[13:23:32.611]                     }
[13:23:32.611]                     tryCatch({
[13:23:32.611]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:32.611]                     }, error = function(ex) {
[13:23:32.611]                       msg <- conditionMessage(ex)
[13:23:32.611]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.611]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:32.611]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.611]                         fi_tmp[["mtime"]], msg)
[13:23:32.611]                       ex$message <- msg
[13:23:32.611]                       stop(ex)
[13:23:32.611]                     })
[13:23:32.611]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:32.611]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:32.611]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:32.611]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.611]                       fi <- file.info(pathname)
[13:23:32.611]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:32.611]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.611]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:32.611]                         fi[["size"]], fi[["mtime"]])
[13:23:32.611]                       stop(msg)
[13:23:32.611]                     }
[13:23:32.611]                     invisible(pathname)
[13:23:32.611]                   }
[13:23:32.611]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:32.611]                     rootPath = tempdir()) 
[13:23:32.611]                   {
[13:23:32.611]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:32.611]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:32.611]                       tmpdir = path, fileext = ".rds")
[13:23:32.611]                     save_rds(obj, file)
[13:23:32.611]                   }
[13:23:32.611]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:32.611]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.611]                   {
[13:23:32.611]                     inherits <- base::inherits
[13:23:32.611]                     invokeRestart <- base::invokeRestart
[13:23:32.611]                     is.null <- base::is.null
[13:23:32.611]                     muffled <- FALSE
[13:23:32.611]                     if (inherits(cond, "message")) {
[13:23:32.611]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:32.611]                       if (muffled) 
[13:23:32.611]                         invokeRestart("muffleMessage")
[13:23:32.611]                     }
[13:23:32.611]                     else if (inherits(cond, "warning")) {
[13:23:32.611]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:32.611]                       if (muffled) 
[13:23:32.611]                         invokeRestart("muffleWarning")
[13:23:32.611]                     }
[13:23:32.611]                     else if (inherits(cond, "condition")) {
[13:23:32.611]                       if (!is.null(pattern)) {
[13:23:32.611]                         computeRestarts <- base::computeRestarts
[13:23:32.611]                         grepl <- base::grepl
[13:23:32.611]                         restarts <- computeRestarts(cond)
[13:23:32.611]                         for (restart in restarts) {
[13:23:32.611]                           name <- restart$name
[13:23:32.611]                           if (is.null(name)) 
[13:23:32.611]                             next
[13:23:32.611]                           if (!grepl(pattern, name)) 
[13:23:32.611]                             next
[13:23:32.611]                           invokeRestart(restart)
[13:23:32.611]                           muffled <- TRUE
[13:23:32.611]                           break
[13:23:32.611]                         }
[13:23:32.611]                       }
[13:23:32.611]                     }
[13:23:32.611]                     invisible(muffled)
[13:23:32.611]                   }
[13:23:32.611]                   muffleCondition(cond)
[13:23:32.611]                 })
[13:23:32.611]             }))
[13:23:32.611]             future::FutureResult(value = ...future.value$value, 
[13:23:32.611]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.611]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.611]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.611]                     ...future.globalenv.names))
[13:23:32.611]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.611]         }, condition = base::local({
[13:23:32.611]             c <- base::c
[13:23:32.611]             inherits <- base::inherits
[13:23:32.611]             invokeRestart <- base::invokeRestart
[13:23:32.611]             length <- base::length
[13:23:32.611]             list <- base::list
[13:23:32.611]             seq.int <- base::seq.int
[13:23:32.611]             signalCondition <- base::signalCondition
[13:23:32.611]             sys.calls <- base::sys.calls
[13:23:32.611]             `[[` <- base::`[[`
[13:23:32.611]             `+` <- base::`+`
[13:23:32.611]             `<<-` <- base::`<<-`
[13:23:32.611]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.611]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.611]                   3L)]
[13:23:32.611]             }
[13:23:32.611]             function(cond) {
[13:23:32.611]                 is_error <- inherits(cond, "error")
[13:23:32.611]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.611]                   NULL)
[13:23:32.611]                 if (is_error) {
[13:23:32.611]                   sessionInformation <- function() {
[13:23:32.611]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.611]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.611]                       search = base::search(), system = base::Sys.info())
[13:23:32.611]                   }
[13:23:32.611]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.611]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.611]                     cond$call), session = sessionInformation(), 
[13:23:32.611]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.611]                   signalCondition(cond)
[13:23:32.611]                 }
[13:23:32.611]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.611]                 "immediateCondition"))) {
[13:23:32.611]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.611]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.611]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.611]                   if (TRUE && !signal) {
[13:23:32.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.611]                     {
[13:23:32.611]                       inherits <- base::inherits
[13:23:32.611]                       invokeRestart <- base::invokeRestart
[13:23:32.611]                       is.null <- base::is.null
[13:23:32.611]                       muffled <- FALSE
[13:23:32.611]                       if (inherits(cond, "message")) {
[13:23:32.611]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.611]                         if (muffled) 
[13:23:32.611]                           invokeRestart("muffleMessage")
[13:23:32.611]                       }
[13:23:32.611]                       else if (inherits(cond, "warning")) {
[13:23:32.611]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.611]                         if (muffled) 
[13:23:32.611]                           invokeRestart("muffleWarning")
[13:23:32.611]                       }
[13:23:32.611]                       else if (inherits(cond, "condition")) {
[13:23:32.611]                         if (!is.null(pattern)) {
[13:23:32.611]                           computeRestarts <- base::computeRestarts
[13:23:32.611]                           grepl <- base::grepl
[13:23:32.611]                           restarts <- computeRestarts(cond)
[13:23:32.611]                           for (restart in restarts) {
[13:23:32.611]                             name <- restart$name
[13:23:32.611]                             if (is.null(name)) 
[13:23:32.611]                               next
[13:23:32.611]                             if (!grepl(pattern, name)) 
[13:23:32.611]                               next
[13:23:32.611]                             invokeRestart(restart)
[13:23:32.611]                             muffled <- TRUE
[13:23:32.611]                             break
[13:23:32.611]                           }
[13:23:32.611]                         }
[13:23:32.611]                       }
[13:23:32.611]                       invisible(muffled)
[13:23:32.611]                     }
[13:23:32.611]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.611]                   }
[13:23:32.611]                 }
[13:23:32.611]                 else {
[13:23:32.611]                   if (TRUE) {
[13:23:32.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.611]                     {
[13:23:32.611]                       inherits <- base::inherits
[13:23:32.611]                       invokeRestart <- base::invokeRestart
[13:23:32.611]                       is.null <- base::is.null
[13:23:32.611]                       muffled <- FALSE
[13:23:32.611]                       if (inherits(cond, "message")) {
[13:23:32.611]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.611]                         if (muffled) 
[13:23:32.611]                           invokeRestart("muffleMessage")
[13:23:32.611]                       }
[13:23:32.611]                       else if (inherits(cond, "warning")) {
[13:23:32.611]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.611]                         if (muffled) 
[13:23:32.611]                           invokeRestart("muffleWarning")
[13:23:32.611]                       }
[13:23:32.611]                       else if (inherits(cond, "condition")) {
[13:23:32.611]                         if (!is.null(pattern)) {
[13:23:32.611]                           computeRestarts <- base::computeRestarts
[13:23:32.611]                           grepl <- base::grepl
[13:23:32.611]                           restarts <- computeRestarts(cond)
[13:23:32.611]                           for (restart in restarts) {
[13:23:32.611]                             name <- restart$name
[13:23:32.611]                             if (is.null(name)) 
[13:23:32.611]                               next
[13:23:32.611]                             if (!grepl(pattern, name)) 
[13:23:32.611]                               next
[13:23:32.611]                             invokeRestart(restart)
[13:23:32.611]                             muffled <- TRUE
[13:23:32.611]                             break
[13:23:32.611]                           }
[13:23:32.611]                         }
[13:23:32.611]                       }
[13:23:32.611]                       invisible(muffled)
[13:23:32.611]                     }
[13:23:32.611]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.611]                   }
[13:23:32.611]                 }
[13:23:32.611]             }
[13:23:32.611]         }))
[13:23:32.611]     }, error = function(ex) {
[13:23:32.611]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.611]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.611]                 ...future.rng), started = ...future.startTime, 
[13:23:32.611]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.611]             version = "1.8"), class = "FutureResult")
[13:23:32.611]     }, finally = {
[13:23:32.611]         if (!identical(...future.workdir, getwd())) 
[13:23:32.611]             setwd(...future.workdir)
[13:23:32.611]         {
[13:23:32.611]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.611]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.611]             }
[13:23:32.611]             base::options(...future.oldOptions)
[13:23:32.611]             if (.Platform$OS.type == "windows") {
[13:23:32.611]                 old_names <- names(...future.oldEnvVars)
[13:23:32.611]                 envs <- base::Sys.getenv()
[13:23:32.611]                 names <- names(envs)
[13:23:32.611]                 common <- intersect(names, old_names)
[13:23:32.611]                 added <- setdiff(names, old_names)
[13:23:32.611]                 removed <- setdiff(old_names, names)
[13:23:32.611]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.611]                   envs[common]]
[13:23:32.611]                 NAMES <- toupper(changed)
[13:23:32.611]                 args <- list()
[13:23:32.611]                 for (kk in seq_along(NAMES)) {
[13:23:32.611]                   name <- changed[[kk]]
[13:23:32.611]                   NAME <- NAMES[[kk]]
[13:23:32.611]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.611]                     next
[13:23:32.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.611]                 }
[13:23:32.611]                 NAMES <- toupper(added)
[13:23:32.611]                 for (kk in seq_along(NAMES)) {
[13:23:32.611]                   name <- added[[kk]]
[13:23:32.611]                   NAME <- NAMES[[kk]]
[13:23:32.611]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.611]                     next
[13:23:32.611]                   args[[name]] <- ""
[13:23:32.611]                 }
[13:23:32.611]                 NAMES <- toupper(removed)
[13:23:32.611]                 for (kk in seq_along(NAMES)) {
[13:23:32.611]                   name <- removed[[kk]]
[13:23:32.611]                   NAME <- NAMES[[kk]]
[13:23:32.611]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.611]                     next
[13:23:32.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.611]                 }
[13:23:32.611]                 if (length(args) > 0) 
[13:23:32.611]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.611]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.611]             }
[13:23:32.611]             else {
[13:23:32.611]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.611]             }
[13:23:32.611]             {
[13:23:32.611]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.611]                   0L) {
[13:23:32.611]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.611]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.611]                   base::options(opts)
[13:23:32.611]                 }
[13:23:32.611]                 {
[13:23:32.611]                   {
[13:23:32.611]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:32.611]                     NULL
[13:23:32.611]                   }
[13:23:32.611]                   options(future.plan = NULL)
[13:23:32.611]                   if (is.na(NA_character_)) 
[13:23:32.611]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.611]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.611]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:32.611]                     envir = parent.frame()) 
[13:23:32.611]                   {
[13:23:32.611]                     default_workers <- missing(workers)
[13:23:32.611]                     if (is.function(workers)) 
[13:23:32.611]                       workers <- workers()
[13:23:32.611]                     workers <- structure(as.integer(workers), 
[13:23:32.611]                       class = class(workers))
[13:23:32.611]                     stop_if_not(is.finite(workers), workers >= 
[13:23:32.611]                       1L)
[13:23:32.611]                     if ((workers == 1L && !inherits(workers, 
[13:23:32.611]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:32.611]                       if (default_workers) 
[13:23:32.611]                         supportsMulticore(warn = TRUE)
[13:23:32.611]                       return(sequential(..., envir = envir))
[13:23:32.611]                     }
[13:23:32.611]                     oopts <- options(mc.cores = workers)
[13:23:32.611]                     on.exit(options(oopts))
[13:23:32.611]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:32.611]                       envir = envir)
[13:23:32.611]                     if (!future$lazy) 
[13:23:32.611]                       future <- run(future)
[13:23:32.611]                     invisible(future)
[13:23:32.611]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.611]                 }
[13:23:32.611]             }
[13:23:32.611]         }
[13:23:32.611]     })
[13:23:32.611]     if (TRUE) {
[13:23:32.611]         base::sink(type = "output", split = FALSE)
[13:23:32.611]         if (TRUE) {
[13:23:32.611]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.611]         }
[13:23:32.611]         else {
[13:23:32.611]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.611]         }
[13:23:32.611]         base::close(...future.stdout)
[13:23:32.611]         ...future.stdout <- NULL
[13:23:32.611]     }
[13:23:32.611]     ...future.result$conditions <- ...future.conditions
[13:23:32.611]     ...future.result$finished <- base::Sys.time()
[13:23:32.611]     ...future.result
[13:23:32.611] }
[13:23:32.613] assign_globals() ...
[13:23:32.613] List of 1
[13:23:32.613]  $ ii: int 1
[13:23:32.613]  - attr(*, "where")=List of 1
[13:23:32.613]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:32.613]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.613]  - attr(*, "resolved")= logi TRUE
[13:23:32.613]  - attr(*, "total_size")= num 56
[13:23:32.613]  - attr(*, "already-done")= logi TRUE
[13:23:32.616] - copied ‘ii’ to environment
[13:23:32.616] assign_globals() ... done
[13:23:32.616] requestCore(): workers = 2
[13:23:32.619] MulticoreFuture started
[13:23:32.619] - Launch lazy future ... done
[13:23:32.619] run() for ‘MulticoreFuture’ ... done
[13:23:32.620] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.621] getGlobalsAndPackages() ...
[13:23:32.620] List of future strategies:
[13:23:32.620] 1. sequential:
[13:23:32.620]    - args: function (..., envir = parent.frame())
[13:23:32.620]    - tweaked: FALSE
[13:23:32.620]    - call: NULL
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.621] plan(): nbrOfWorkers() = 1
[13:23:32.621] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:32.623] plan(): Setting new future strategy stack:
[13:23:32.623] List of future strategies:
[13:23:32.623] 1. multicore:
[13:23:32.623]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:32.623]    - tweaked: FALSE
[13:23:32.623]    - call: plan(strategy)
[13:23:32.624] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:32.624] Searching for globals ... DONE
[13:23:32.624] Resolving globals: TRUE
[13:23:32.624] Resolving any globals that are futures ...
[13:23:32.625] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:32.625] Resolving any globals that are futures ... DONE
[13:23:32.625] Resolving futures part of globals (recursively) ...
[13:23:32.626] resolve() on list ...
[13:23:32.626]  recursive: 99
[13:23:32.626]  length: 1
[13:23:32.626]  elements: ‘ii’
[13:23:32.627]  length: 0 (resolved future 1)
[13:23:32.627] resolve() on list ... DONE
[13:23:32.627] - globals: [1] ‘ii’
[13:23:32.627] Resolving futures part of globals (recursively) ... DONE
[13:23:32.627] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:32.628] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:32.628] plan(): nbrOfWorkers() = 2
[13:23:32.628] - globals: [1] ‘ii’
[13:23:32.628] 
[13:23:32.629] getGlobalsAndPackages() ... DONE
[13:23:32.629] run() for ‘Future’ ...
[13:23:32.629] - state: ‘created’
[13:23:32.629] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:32.634] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:32.634] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:32.635]   - Field: ‘label’
[13:23:32.635]   - Field: ‘local’
[13:23:32.635]   - Field: ‘owner’
[13:23:32.635]   - Field: ‘envir’
[13:23:32.635]   - Field: ‘workers’
[13:23:32.635]   - Field: ‘packages’
[13:23:32.636]   - Field: ‘gc’
[13:23:32.636]   - Field: ‘job’
[13:23:32.639]   - Field: ‘conditions’
[13:23:32.640]   - Field: ‘expr’
[13:23:32.640]   - Field: ‘uuid’
[13:23:32.640]   - Field: ‘seed’
[13:23:32.640]   - Field: ‘version’
[13:23:32.641]   - Field: ‘result’
[13:23:32.641]   - Field: ‘asynchronous’
[13:23:32.641]   - Field: ‘calls’
[13:23:32.642]   - Field: ‘globals’
[13:23:32.642]   - Field: ‘stdout’
[13:23:32.642]   - Field: ‘earlySignal’
[13:23:32.642]   - Field: ‘lazy’
[13:23:32.643]   - Field: ‘state’
[13:23:32.643] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:32.643] - Launch lazy future ...
[13:23:32.644] Packages needed by the future expression (n = 0): <none>
[13:23:32.644] Packages needed by future strategies (n = 0): <none>
[13:23:32.645] {
[13:23:32.645]     {
[13:23:32.645]         {
[13:23:32.645]             ...future.startTime <- base::Sys.time()
[13:23:32.645]             {
[13:23:32.645]                 {
[13:23:32.645]                   {
[13:23:32.645]                     {
[13:23:32.645]                       base::local({
[13:23:32.645]                         has_future <- base::requireNamespace("future", 
[13:23:32.645]                           quietly = TRUE)
[13:23:32.645]                         if (has_future) {
[13:23:32.645]                           ns <- base::getNamespace("future")
[13:23:32.645]                           version <- ns[[".package"]][["version"]]
[13:23:32.645]                           if (is.null(version)) 
[13:23:32.645]                             version <- utils::packageVersion("future")
[13:23:32.645]                         }
[13:23:32.645]                         else {
[13:23:32.645]                           version <- NULL
[13:23:32.645]                         }
[13:23:32.645]                         if (!has_future || version < "1.8.0") {
[13:23:32.645]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.645]                             "", base::R.version$version.string), 
[13:23:32.645]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:32.645]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.645]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.645]                               "release", "version")], collapse = " "), 
[13:23:32.645]                             hostname = base::Sys.info()[["nodename"]])
[13:23:32.645]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.645]                             info)
[13:23:32.645]                           info <- base::paste(info, collapse = "; ")
[13:23:32.645]                           if (!has_future) {
[13:23:32.645]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.645]                               info)
[13:23:32.645]                           }
[13:23:32.645]                           else {
[13:23:32.645]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.645]                               info, version)
[13:23:32.645]                           }
[13:23:32.645]                           base::stop(msg)
[13:23:32.645]                         }
[13:23:32.645]                       })
[13:23:32.645]                     }
[13:23:32.645]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:32.645]                     base::options(mc.cores = 1L)
[13:23:32.645]                   }
[13:23:32.645]                   options(future.plan = NULL)
[13:23:32.645]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.645]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.645]                 }
[13:23:32.645]                 ...future.workdir <- getwd()
[13:23:32.645]             }
[13:23:32.645]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.645]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.645]         }
[13:23:32.645]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.645]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:32.645]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.645]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.645]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.645]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.645]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.645]             base::names(...future.oldOptions))
[13:23:32.645]     }
[13:23:32.645]     if (FALSE) {
[13:23:32.645]     }
[13:23:32.645]     else {
[13:23:32.645]         if (TRUE) {
[13:23:32.645]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.645]                 open = "w")
[13:23:32.645]         }
[13:23:32.645]         else {
[13:23:32.645]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.645]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.645]         }
[13:23:32.645]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.645]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.645]             base::sink(type = "output", split = FALSE)
[13:23:32.645]             base::close(...future.stdout)
[13:23:32.645]         }, add = TRUE)
[13:23:32.645]     }
[13:23:32.645]     ...future.frame <- base::sys.nframe()
[13:23:32.645]     ...future.conditions <- base::list()
[13:23:32.645]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.645]     if (FALSE) {
[13:23:32.645]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.645]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.645]     }
[13:23:32.645]     ...future.result <- base::tryCatch({
[13:23:32.645]         base::withCallingHandlers({
[13:23:32.645]             ...future.value <- base::withVisible(base::local({
[13:23:32.645]                 withCallingHandlers({
[13:23:32.645]                   {
[13:23:32.645]                     b <- a * ii
[13:23:32.645]                     a <- 0
[13:23:32.645]                     b
[13:23:32.645]                   }
[13:23:32.645]                 }, immediateCondition = function(cond) {
[13:23:32.645]                   save_rds <- function (object, pathname, ...) 
[13:23:32.645]                   {
[13:23:32.645]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:32.645]                     if (file_test("-f", pathname_tmp)) {
[13:23:32.645]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.645]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:32.645]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.645]                         fi_tmp[["mtime"]])
[13:23:32.645]                     }
[13:23:32.645]                     tryCatch({
[13:23:32.645]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:32.645]                     }, error = function(ex) {
[13:23:32.645]                       msg <- conditionMessage(ex)
[13:23:32.645]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.645]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:32.645]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.645]                         fi_tmp[["mtime"]], msg)
[13:23:32.645]                       ex$message <- msg
[13:23:32.645]                       stop(ex)
[13:23:32.645]                     })
[13:23:32.645]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:32.645]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:32.645]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:32.645]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.645]                       fi <- file.info(pathname)
[13:23:32.645]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:32.645]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.645]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:32.645]                         fi[["size"]], fi[["mtime"]])
[13:23:32.645]                       stop(msg)
[13:23:32.645]                     }
[13:23:32.645]                     invisible(pathname)
[13:23:32.645]                   }
[13:23:32.645]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:32.645]                     rootPath = tempdir()) 
[13:23:32.645]                   {
[13:23:32.645]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:32.645]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:32.645]                       tmpdir = path, fileext = ".rds")
[13:23:32.645]                     save_rds(obj, file)
[13:23:32.645]                   }
[13:23:32.645]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:32.645]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.645]                   {
[13:23:32.645]                     inherits <- base::inherits
[13:23:32.645]                     invokeRestart <- base::invokeRestart
[13:23:32.645]                     is.null <- base::is.null
[13:23:32.645]                     muffled <- FALSE
[13:23:32.645]                     if (inherits(cond, "message")) {
[13:23:32.645]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:32.645]                       if (muffled) 
[13:23:32.645]                         invokeRestart("muffleMessage")
[13:23:32.645]                     }
[13:23:32.645]                     else if (inherits(cond, "warning")) {
[13:23:32.645]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:32.645]                       if (muffled) 
[13:23:32.645]                         invokeRestart("muffleWarning")
[13:23:32.645]                     }
[13:23:32.645]                     else if (inherits(cond, "condition")) {
[13:23:32.645]                       if (!is.null(pattern)) {
[13:23:32.645]                         computeRestarts <- base::computeRestarts
[13:23:32.645]                         grepl <- base::grepl
[13:23:32.645]                         restarts <- computeRestarts(cond)
[13:23:32.645]                         for (restart in restarts) {
[13:23:32.645]                           name <- restart$name
[13:23:32.645]                           if (is.null(name)) 
[13:23:32.645]                             next
[13:23:32.645]                           if (!grepl(pattern, name)) 
[13:23:32.645]                             next
[13:23:32.645]                           invokeRestart(restart)
[13:23:32.645]                           muffled <- TRUE
[13:23:32.645]                           break
[13:23:32.645]                         }
[13:23:32.645]                       }
[13:23:32.645]                     }
[13:23:32.645]                     invisible(muffled)
[13:23:32.645]                   }
[13:23:32.645]                   muffleCondition(cond)
[13:23:32.645]                 })
[13:23:32.645]             }))
[13:23:32.645]             future::FutureResult(value = ...future.value$value, 
[13:23:32.645]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.645]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.645]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.645]                     ...future.globalenv.names))
[13:23:32.645]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.645]         }, condition = base::local({
[13:23:32.645]             c <- base::c
[13:23:32.645]             inherits <- base::inherits
[13:23:32.645]             invokeRestart <- base::invokeRestart
[13:23:32.645]             length <- base::length
[13:23:32.645]             list <- base::list
[13:23:32.645]             seq.int <- base::seq.int
[13:23:32.645]             signalCondition <- base::signalCondition
[13:23:32.645]             sys.calls <- base::sys.calls
[13:23:32.645]             `[[` <- base::`[[`
[13:23:32.645]             `+` <- base::`+`
[13:23:32.645]             `<<-` <- base::`<<-`
[13:23:32.645]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.645]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.645]                   3L)]
[13:23:32.645]             }
[13:23:32.645]             function(cond) {
[13:23:32.645]                 is_error <- inherits(cond, "error")
[13:23:32.645]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.645]                   NULL)
[13:23:32.645]                 if (is_error) {
[13:23:32.645]                   sessionInformation <- function() {
[13:23:32.645]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.645]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.645]                       search = base::search(), system = base::Sys.info())
[13:23:32.645]                   }
[13:23:32.645]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.645]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.645]                     cond$call), session = sessionInformation(), 
[13:23:32.645]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.645]                   signalCondition(cond)
[13:23:32.645]                 }
[13:23:32.645]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.645]                 "immediateCondition"))) {
[13:23:32.645]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.645]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.645]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.645]                   if (TRUE && !signal) {
[13:23:32.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.645]                     {
[13:23:32.645]                       inherits <- base::inherits
[13:23:32.645]                       invokeRestart <- base::invokeRestart
[13:23:32.645]                       is.null <- base::is.null
[13:23:32.645]                       muffled <- FALSE
[13:23:32.645]                       if (inherits(cond, "message")) {
[13:23:32.645]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.645]                         if (muffled) 
[13:23:32.645]                           invokeRestart("muffleMessage")
[13:23:32.645]                       }
[13:23:32.645]                       else if (inherits(cond, "warning")) {
[13:23:32.645]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.645]                         if (muffled) 
[13:23:32.645]                           invokeRestart("muffleWarning")
[13:23:32.645]                       }
[13:23:32.645]                       else if (inherits(cond, "condition")) {
[13:23:32.645]                         if (!is.null(pattern)) {
[13:23:32.645]                           computeRestarts <- base::computeRestarts
[13:23:32.645]                           grepl <- base::grepl
[13:23:32.645]                           restarts <- computeRestarts(cond)
[13:23:32.645]                           for (restart in restarts) {
[13:23:32.645]                             name <- restart$name
[13:23:32.645]                             if (is.null(name)) 
[13:23:32.645]                               next
[13:23:32.645]                             if (!grepl(pattern, name)) 
[13:23:32.645]                               next
[13:23:32.645]                             invokeRestart(restart)
[13:23:32.645]                             muffled <- TRUE
[13:23:32.645]                             break
[13:23:32.645]                           }
[13:23:32.645]                         }
[13:23:32.645]                       }
[13:23:32.645]                       invisible(muffled)
[13:23:32.645]                     }
[13:23:32.645]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.645]                   }
[13:23:32.645]                 }
[13:23:32.645]                 else {
[13:23:32.645]                   if (TRUE) {
[13:23:32.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.645]                     {
[13:23:32.645]                       inherits <- base::inherits
[13:23:32.645]                       invokeRestart <- base::invokeRestart
[13:23:32.645]                       is.null <- base::is.null
[13:23:32.645]                       muffled <- FALSE
[13:23:32.645]                       if (inherits(cond, "message")) {
[13:23:32.645]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.645]                         if (muffled) 
[13:23:32.645]                           invokeRestart("muffleMessage")
[13:23:32.645]                       }
[13:23:32.645]                       else if (inherits(cond, "warning")) {
[13:23:32.645]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.645]                         if (muffled) 
[13:23:32.645]                           invokeRestart("muffleWarning")
[13:23:32.645]                       }
[13:23:32.645]                       else if (inherits(cond, "condition")) {
[13:23:32.645]                         if (!is.null(pattern)) {
[13:23:32.645]                           computeRestarts <- base::computeRestarts
[13:23:32.645]                           grepl <- base::grepl
[13:23:32.645]                           restarts <- computeRestarts(cond)
[13:23:32.645]                           for (restart in restarts) {
[13:23:32.645]                             name <- restart$name
[13:23:32.645]                             if (is.null(name)) 
[13:23:32.645]                               next
[13:23:32.645]                             if (!grepl(pattern, name)) 
[13:23:32.645]                               next
[13:23:32.645]                             invokeRestart(restart)
[13:23:32.645]                             muffled <- TRUE
[13:23:32.645]                             break
[13:23:32.645]                           }
[13:23:32.645]                         }
[13:23:32.645]                       }
[13:23:32.645]                       invisible(muffled)
[13:23:32.645]                     }
[13:23:32.645]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.645]                   }
[13:23:32.645]                 }
[13:23:32.645]             }
[13:23:32.645]         }))
[13:23:32.645]     }, error = function(ex) {
[13:23:32.645]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.645]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.645]                 ...future.rng), started = ...future.startTime, 
[13:23:32.645]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.645]             version = "1.8"), class = "FutureResult")
[13:23:32.645]     }, finally = {
[13:23:32.645]         if (!identical(...future.workdir, getwd())) 
[13:23:32.645]             setwd(...future.workdir)
[13:23:32.645]         {
[13:23:32.645]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.645]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.645]             }
[13:23:32.645]             base::options(...future.oldOptions)
[13:23:32.645]             if (.Platform$OS.type == "windows") {
[13:23:32.645]                 old_names <- names(...future.oldEnvVars)
[13:23:32.645]                 envs <- base::Sys.getenv()
[13:23:32.645]                 names <- names(envs)
[13:23:32.645]                 common <- intersect(names, old_names)
[13:23:32.645]                 added <- setdiff(names, old_names)
[13:23:32.645]                 removed <- setdiff(old_names, names)
[13:23:32.645]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.645]                   envs[common]]
[13:23:32.645]                 NAMES <- toupper(changed)
[13:23:32.645]                 args <- list()
[13:23:32.645]                 for (kk in seq_along(NAMES)) {
[13:23:32.645]                   name <- changed[[kk]]
[13:23:32.645]                   NAME <- NAMES[[kk]]
[13:23:32.645]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.645]                     next
[13:23:32.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.645]                 }
[13:23:32.645]                 NAMES <- toupper(added)
[13:23:32.645]                 for (kk in seq_along(NAMES)) {
[13:23:32.645]                   name <- added[[kk]]
[13:23:32.645]                   NAME <- NAMES[[kk]]
[13:23:32.645]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.645]                     next
[13:23:32.645]                   args[[name]] <- ""
[13:23:32.645]                 }
[13:23:32.645]                 NAMES <- toupper(removed)
[13:23:32.645]                 for (kk in seq_along(NAMES)) {
[13:23:32.645]                   name <- removed[[kk]]
[13:23:32.645]                   NAME <- NAMES[[kk]]
[13:23:32.645]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.645]                     next
[13:23:32.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.645]                 }
[13:23:32.645]                 if (length(args) > 0) 
[13:23:32.645]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.645]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.645]             }
[13:23:32.645]             else {
[13:23:32.645]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.645]             }
[13:23:32.645]             {
[13:23:32.645]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.645]                   0L) {
[13:23:32.645]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.645]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.645]                   base::options(opts)
[13:23:32.645]                 }
[13:23:32.645]                 {
[13:23:32.645]                   {
[13:23:32.645]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:32.645]                     NULL
[13:23:32.645]                   }
[13:23:32.645]                   options(future.plan = NULL)
[13:23:32.645]                   if (is.na(NA_character_)) 
[13:23:32.645]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.645]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.645]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:32.645]                     envir = parent.frame()) 
[13:23:32.645]                   {
[13:23:32.645]                     default_workers <- missing(workers)
[13:23:32.645]                     if (is.function(workers)) 
[13:23:32.645]                       workers <- workers()
[13:23:32.645]                     workers <- structure(as.integer(workers), 
[13:23:32.645]                       class = class(workers))
[13:23:32.645]                     stop_if_not(is.finite(workers), workers >= 
[13:23:32.645]                       1L)
[13:23:32.645]                     if ((workers == 1L && !inherits(workers, 
[13:23:32.645]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:32.645]                       if (default_workers) 
[13:23:32.645]                         supportsMulticore(warn = TRUE)
[13:23:32.645]                       return(sequential(..., envir = envir))
[13:23:32.645]                     }
[13:23:32.645]                     oopts <- options(mc.cores = workers)
[13:23:32.645]                     on.exit(options(oopts))
[13:23:32.645]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:32.645]                       envir = envir)
[13:23:32.645]                     if (!future$lazy) 
[13:23:32.645]                       future <- run(future)
[13:23:32.645]                     invisible(future)
[13:23:32.645]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.645]                 }
[13:23:32.645]             }
[13:23:32.645]         }
[13:23:32.645]     })
[13:23:32.645]     if (TRUE) {
[13:23:32.645]         base::sink(type = "output", split = FALSE)
[13:23:32.645]         if (TRUE) {
[13:23:32.645]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.645]         }
[13:23:32.645]         else {
[13:23:32.645]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.645]         }
[13:23:32.645]         base::close(...future.stdout)
[13:23:32.645]         ...future.stdout <- NULL
[13:23:32.645]     }
[13:23:32.645]     ...future.result$conditions <- ...future.conditions
[13:23:32.645]     ...future.result$finished <- base::Sys.time()
[13:23:32.645]     ...future.result
[13:23:32.645] }
[13:23:32.648] assign_globals() ...
[13:23:32.648] List of 1
[13:23:32.648]  $ ii: int 2
[13:23:32.648]  - attr(*, "where")=List of 1
[13:23:32.648]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:32.648]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.648]  - attr(*, "resolved")= logi TRUE
[13:23:32.648]  - attr(*, "total_size")= num 56
[13:23:32.648]  - attr(*, "already-done")= logi TRUE
[13:23:32.652] - copied ‘ii’ to environment
[13:23:32.652] assign_globals() ... done
[13:23:32.653] requestCore(): workers = 2
[13:23:32.655] MulticoreFuture started
[13:23:32.656] - Launch lazy future ... done
[13:23:32.656] run() for ‘MulticoreFuture’ ... done
[13:23:32.656] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.657] getGlobalsAndPackages() ...
[13:23:32.657] List of future strategies:
[13:23:32.657] 1. sequential:
[13:23:32.657]    - args: function (..., envir = parent.frame())
[13:23:32.657]    - tweaked: FALSE
[13:23:32.657]    - call: NULL
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.658] plan(): nbrOfWorkers() = 1
[13:23:32.658] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:32.660] plan(): Setting new future strategy stack:
[13:23:32.660] List of future strategies:
[13:23:32.660] 1. multicore:
[13:23:32.660]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:32.660]    - tweaked: FALSE
[13:23:32.660]    - call: plan(strategy)
[13:23:32.661] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:32.661] Searching for globals ... DONE
[13:23:32.661] Resolving globals: TRUE
[13:23:32.661] Resolving any globals that are futures ...
[13:23:32.661] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:32.662] Resolving any globals that are futures ... DONE
[13:23:32.662] Resolving futures part of globals (recursively) ...
[13:23:32.663] resolve() on list ...
[13:23:32.663]  recursive: 99
[13:23:32.663]  length: 1
[13:23:32.663]  elements: ‘ii’
[13:23:32.664]  length: 0 (resolved future 1)
[13:23:32.664] resolve() on list ... DONE
[13:23:32.664] - globals: [1] ‘ii’
[13:23:32.664] Resolving futures part of globals (recursively) ... DONE
[13:23:32.664] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:32.665] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:32.665] plan(): nbrOfWorkers() = 2
[13:23:32.665] - globals: [1] ‘ii’
[13:23:32.665] 
[13:23:32.666] getGlobalsAndPackages() ... DONE
[13:23:32.666] run() for ‘Future’ ...
[13:23:32.666] - state: ‘created’
[13:23:32.666] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:32.672] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:32.672] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:32.672]   - Field: ‘label’
[13:23:32.673]   - Field: ‘local’
[13:23:32.673]   - Field: ‘owner’
[13:23:32.673]   - Field: ‘envir’
[13:23:32.673]   - Field: ‘workers’
[13:23:32.673]   - Field: ‘packages’
[13:23:32.673]   - Field: ‘gc’
[13:23:32.673]   - Field: ‘job’
[13:23:32.674]   - Field: ‘conditions’
[13:23:32.674]   - Field: ‘expr’
[13:23:32.674]   - Field: ‘uuid’
[13:23:32.674]   - Field: ‘seed’
[13:23:32.674]   - Field: ‘version’
[13:23:32.674]   - Field: ‘result’
[13:23:32.674]   - Field: ‘asynchronous’
[13:23:32.675]   - Field: ‘calls’
[13:23:32.675]   - Field: ‘globals’
[13:23:32.675]   - Field: ‘stdout’
[13:23:32.675]   - Field: ‘earlySignal’
[13:23:32.675]   - Field: ‘lazy’
[13:23:32.675]   - Field: ‘state’
[13:23:32.675] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:32.676] - Launch lazy future ...
[13:23:32.676] Packages needed by the future expression (n = 0): <none>
[13:23:32.676] Packages needed by future strategies (n = 0): <none>
[13:23:32.677] {
[13:23:32.677]     {
[13:23:32.677]         {
[13:23:32.677]             ...future.startTime <- base::Sys.time()
[13:23:32.677]             {
[13:23:32.677]                 {
[13:23:32.677]                   {
[13:23:32.677]                     {
[13:23:32.677]                       base::local({
[13:23:32.677]                         has_future <- base::requireNamespace("future", 
[13:23:32.677]                           quietly = TRUE)
[13:23:32.677]                         if (has_future) {
[13:23:32.677]                           ns <- base::getNamespace("future")
[13:23:32.677]                           version <- ns[[".package"]][["version"]]
[13:23:32.677]                           if (is.null(version)) 
[13:23:32.677]                             version <- utils::packageVersion("future")
[13:23:32.677]                         }
[13:23:32.677]                         else {
[13:23:32.677]                           version <- NULL
[13:23:32.677]                         }
[13:23:32.677]                         if (!has_future || version < "1.8.0") {
[13:23:32.677]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.677]                             "", base::R.version$version.string), 
[13:23:32.677]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:32.677]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.677]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.677]                               "release", "version")], collapse = " "), 
[13:23:32.677]                             hostname = base::Sys.info()[["nodename"]])
[13:23:32.677]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.677]                             info)
[13:23:32.677]                           info <- base::paste(info, collapse = "; ")
[13:23:32.677]                           if (!has_future) {
[13:23:32.677]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.677]                               info)
[13:23:32.677]                           }
[13:23:32.677]                           else {
[13:23:32.677]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.677]                               info, version)
[13:23:32.677]                           }
[13:23:32.677]                           base::stop(msg)
[13:23:32.677]                         }
[13:23:32.677]                       })
[13:23:32.677]                     }
[13:23:32.677]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:32.677]                     base::options(mc.cores = 1L)
[13:23:32.677]                   }
[13:23:32.677]                   options(future.plan = NULL)
[13:23:32.677]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.677]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.677]                 }
[13:23:32.677]                 ...future.workdir <- getwd()
[13:23:32.677]             }
[13:23:32.677]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.677]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.677]         }
[13:23:32.677]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.677]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:32.677]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.677]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.677]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.677]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.677]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.677]             base::names(...future.oldOptions))
[13:23:32.677]     }
[13:23:32.677]     if (FALSE) {
[13:23:32.677]     }
[13:23:32.677]     else {
[13:23:32.677]         if (TRUE) {
[13:23:32.677]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.677]                 open = "w")
[13:23:32.677]         }
[13:23:32.677]         else {
[13:23:32.677]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.677]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.677]         }
[13:23:32.677]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.677]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.677]             base::sink(type = "output", split = FALSE)
[13:23:32.677]             base::close(...future.stdout)
[13:23:32.677]         }, add = TRUE)
[13:23:32.677]     }
[13:23:32.677]     ...future.frame <- base::sys.nframe()
[13:23:32.677]     ...future.conditions <- base::list()
[13:23:32.677]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.677]     if (FALSE) {
[13:23:32.677]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.677]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.677]     }
[13:23:32.677]     ...future.result <- base::tryCatch({
[13:23:32.677]         base::withCallingHandlers({
[13:23:32.677]             ...future.value <- base::withVisible(base::local({
[13:23:32.677]                 withCallingHandlers({
[13:23:32.677]                   {
[13:23:32.677]                     b <- a * ii
[13:23:32.677]                     a <- 0
[13:23:32.677]                     b
[13:23:32.677]                   }
[13:23:32.677]                 }, immediateCondition = function(cond) {
[13:23:32.677]                   save_rds <- function (object, pathname, ...) 
[13:23:32.677]                   {
[13:23:32.677]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:32.677]                     if (file_test("-f", pathname_tmp)) {
[13:23:32.677]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.677]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:32.677]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.677]                         fi_tmp[["mtime"]])
[13:23:32.677]                     }
[13:23:32.677]                     tryCatch({
[13:23:32.677]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:32.677]                     }, error = function(ex) {
[13:23:32.677]                       msg <- conditionMessage(ex)
[13:23:32.677]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.677]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:32.677]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.677]                         fi_tmp[["mtime"]], msg)
[13:23:32.677]                       ex$message <- msg
[13:23:32.677]                       stop(ex)
[13:23:32.677]                     })
[13:23:32.677]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:32.677]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:32.677]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:32.677]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.677]                       fi <- file.info(pathname)
[13:23:32.677]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:32.677]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.677]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:32.677]                         fi[["size"]], fi[["mtime"]])
[13:23:32.677]                       stop(msg)
[13:23:32.677]                     }
[13:23:32.677]                     invisible(pathname)
[13:23:32.677]                   }
[13:23:32.677]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:32.677]                     rootPath = tempdir()) 
[13:23:32.677]                   {
[13:23:32.677]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:32.677]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:32.677]                       tmpdir = path, fileext = ".rds")
[13:23:32.677]                     save_rds(obj, file)
[13:23:32.677]                   }
[13:23:32.677]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:32.677]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.677]                   {
[13:23:32.677]                     inherits <- base::inherits
[13:23:32.677]                     invokeRestart <- base::invokeRestart
[13:23:32.677]                     is.null <- base::is.null
[13:23:32.677]                     muffled <- FALSE
[13:23:32.677]                     if (inherits(cond, "message")) {
[13:23:32.677]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:32.677]                       if (muffled) 
[13:23:32.677]                         invokeRestart("muffleMessage")
[13:23:32.677]                     }
[13:23:32.677]                     else if (inherits(cond, "warning")) {
[13:23:32.677]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:32.677]                       if (muffled) 
[13:23:32.677]                         invokeRestart("muffleWarning")
[13:23:32.677]                     }
[13:23:32.677]                     else if (inherits(cond, "condition")) {
[13:23:32.677]                       if (!is.null(pattern)) {
[13:23:32.677]                         computeRestarts <- base::computeRestarts
[13:23:32.677]                         grepl <- base::grepl
[13:23:32.677]                         restarts <- computeRestarts(cond)
[13:23:32.677]                         for (restart in restarts) {
[13:23:32.677]                           name <- restart$name
[13:23:32.677]                           if (is.null(name)) 
[13:23:32.677]                             next
[13:23:32.677]                           if (!grepl(pattern, name)) 
[13:23:32.677]                             next
[13:23:32.677]                           invokeRestart(restart)
[13:23:32.677]                           muffled <- TRUE
[13:23:32.677]                           break
[13:23:32.677]                         }
[13:23:32.677]                       }
[13:23:32.677]                     }
[13:23:32.677]                     invisible(muffled)
[13:23:32.677]                   }
[13:23:32.677]                   muffleCondition(cond)
[13:23:32.677]                 })
[13:23:32.677]             }))
[13:23:32.677]             future::FutureResult(value = ...future.value$value, 
[13:23:32.677]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.677]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.677]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.677]                     ...future.globalenv.names))
[13:23:32.677]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.677]         }, condition = base::local({
[13:23:32.677]             c <- base::c
[13:23:32.677]             inherits <- base::inherits
[13:23:32.677]             invokeRestart <- base::invokeRestart
[13:23:32.677]             length <- base::length
[13:23:32.677]             list <- base::list
[13:23:32.677]             seq.int <- base::seq.int
[13:23:32.677]             signalCondition <- base::signalCondition
[13:23:32.677]             sys.calls <- base::sys.calls
[13:23:32.677]             `[[` <- base::`[[`
[13:23:32.677]             `+` <- base::`+`
[13:23:32.677]             `<<-` <- base::`<<-`
[13:23:32.677]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.677]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.677]                   3L)]
[13:23:32.677]             }
[13:23:32.677]             function(cond) {
[13:23:32.677]                 is_error <- inherits(cond, "error")
[13:23:32.677]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.677]                   NULL)
[13:23:32.677]                 if (is_error) {
[13:23:32.677]                   sessionInformation <- function() {
[13:23:32.677]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.677]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.677]                       search = base::search(), system = base::Sys.info())
[13:23:32.677]                   }
[13:23:32.677]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.677]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.677]                     cond$call), session = sessionInformation(), 
[13:23:32.677]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.677]                   signalCondition(cond)
[13:23:32.677]                 }
[13:23:32.677]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.677]                 "immediateCondition"))) {
[13:23:32.677]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.677]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.677]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.677]                   if (TRUE && !signal) {
[13:23:32.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.677]                     {
[13:23:32.677]                       inherits <- base::inherits
[13:23:32.677]                       invokeRestart <- base::invokeRestart
[13:23:32.677]                       is.null <- base::is.null
[13:23:32.677]                       muffled <- FALSE
[13:23:32.677]                       if (inherits(cond, "message")) {
[13:23:32.677]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.677]                         if (muffled) 
[13:23:32.677]                           invokeRestart("muffleMessage")
[13:23:32.677]                       }
[13:23:32.677]                       else if (inherits(cond, "warning")) {
[13:23:32.677]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.677]                         if (muffled) 
[13:23:32.677]                           invokeRestart("muffleWarning")
[13:23:32.677]                       }
[13:23:32.677]                       else if (inherits(cond, "condition")) {
[13:23:32.677]                         if (!is.null(pattern)) {
[13:23:32.677]                           computeRestarts <- base::computeRestarts
[13:23:32.677]                           grepl <- base::grepl
[13:23:32.677]                           restarts <- computeRestarts(cond)
[13:23:32.677]                           for (restart in restarts) {
[13:23:32.677]                             name <- restart$name
[13:23:32.677]                             if (is.null(name)) 
[13:23:32.677]                               next
[13:23:32.677]                             if (!grepl(pattern, name)) 
[13:23:32.677]                               next
[13:23:32.677]                             invokeRestart(restart)
[13:23:32.677]                             muffled <- TRUE
[13:23:32.677]                             break
[13:23:32.677]                           }
[13:23:32.677]                         }
[13:23:32.677]                       }
[13:23:32.677]                       invisible(muffled)
[13:23:32.677]                     }
[13:23:32.677]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.677]                   }
[13:23:32.677]                 }
[13:23:32.677]                 else {
[13:23:32.677]                   if (TRUE) {
[13:23:32.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.677]                     {
[13:23:32.677]                       inherits <- base::inherits
[13:23:32.677]                       invokeRestart <- base::invokeRestart
[13:23:32.677]                       is.null <- base::is.null
[13:23:32.677]                       muffled <- FALSE
[13:23:32.677]                       if (inherits(cond, "message")) {
[13:23:32.677]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.677]                         if (muffled) 
[13:23:32.677]                           invokeRestart("muffleMessage")
[13:23:32.677]                       }
[13:23:32.677]                       else if (inherits(cond, "warning")) {
[13:23:32.677]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.677]                         if (muffled) 
[13:23:32.677]                           invokeRestart("muffleWarning")
[13:23:32.677]                       }
[13:23:32.677]                       else if (inherits(cond, "condition")) {
[13:23:32.677]                         if (!is.null(pattern)) {
[13:23:32.677]                           computeRestarts <- base::computeRestarts
[13:23:32.677]                           grepl <- base::grepl
[13:23:32.677]                           restarts <- computeRestarts(cond)
[13:23:32.677]                           for (restart in restarts) {
[13:23:32.677]                             name <- restart$name
[13:23:32.677]                             if (is.null(name)) 
[13:23:32.677]                               next
[13:23:32.677]                             if (!grepl(pattern, name)) 
[13:23:32.677]                               next
[13:23:32.677]                             invokeRestart(restart)
[13:23:32.677]                             muffled <- TRUE
[13:23:32.677]                             break
[13:23:32.677]                           }
[13:23:32.677]                         }
[13:23:32.677]                       }
[13:23:32.677]                       invisible(muffled)
[13:23:32.677]                     }
[13:23:32.677]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.677]                   }
[13:23:32.677]                 }
[13:23:32.677]             }
[13:23:32.677]         }))
[13:23:32.677]     }, error = function(ex) {
[13:23:32.677]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.677]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.677]                 ...future.rng), started = ...future.startTime, 
[13:23:32.677]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.677]             version = "1.8"), class = "FutureResult")
[13:23:32.677]     }, finally = {
[13:23:32.677]         if (!identical(...future.workdir, getwd())) 
[13:23:32.677]             setwd(...future.workdir)
[13:23:32.677]         {
[13:23:32.677]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.677]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.677]             }
[13:23:32.677]             base::options(...future.oldOptions)
[13:23:32.677]             if (.Platform$OS.type == "windows") {
[13:23:32.677]                 old_names <- names(...future.oldEnvVars)
[13:23:32.677]                 envs <- base::Sys.getenv()
[13:23:32.677]                 names <- names(envs)
[13:23:32.677]                 common <- intersect(names, old_names)
[13:23:32.677]                 added <- setdiff(names, old_names)
[13:23:32.677]                 removed <- setdiff(old_names, names)
[13:23:32.677]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.677]                   envs[common]]
[13:23:32.677]                 NAMES <- toupper(changed)
[13:23:32.677]                 args <- list()
[13:23:32.677]                 for (kk in seq_along(NAMES)) {
[13:23:32.677]                   name <- changed[[kk]]
[13:23:32.677]                   NAME <- NAMES[[kk]]
[13:23:32.677]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.677]                     next
[13:23:32.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.677]                 }
[13:23:32.677]                 NAMES <- toupper(added)
[13:23:32.677]                 for (kk in seq_along(NAMES)) {
[13:23:32.677]                   name <- added[[kk]]
[13:23:32.677]                   NAME <- NAMES[[kk]]
[13:23:32.677]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.677]                     next
[13:23:32.677]                   args[[name]] <- ""
[13:23:32.677]                 }
[13:23:32.677]                 NAMES <- toupper(removed)
[13:23:32.677]                 for (kk in seq_along(NAMES)) {
[13:23:32.677]                   name <- removed[[kk]]
[13:23:32.677]                   NAME <- NAMES[[kk]]
[13:23:32.677]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.677]                     next
[13:23:32.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.677]                 }
[13:23:32.677]                 if (length(args) > 0) 
[13:23:32.677]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.677]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.677]             }
[13:23:32.677]             else {
[13:23:32.677]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.677]             }
[13:23:32.677]             {
[13:23:32.677]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.677]                   0L) {
[13:23:32.677]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.677]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.677]                   base::options(opts)
[13:23:32.677]                 }
[13:23:32.677]                 {
[13:23:32.677]                   {
[13:23:32.677]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:32.677]                     NULL
[13:23:32.677]                   }
[13:23:32.677]                   options(future.plan = NULL)
[13:23:32.677]                   if (is.na(NA_character_)) 
[13:23:32.677]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.677]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.677]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:32.677]                     envir = parent.frame()) 
[13:23:32.677]                   {
[13:23:32.677]                     default_workers <- missing(workers)
[13:23:32.677]                     if (is.function(workers)) 
[13:23:32.677]                       workers <- workers()
[13:23:32.677]                     workers <- structure(as.integer(workers), 
[13:23:32.677]                       class = class(workers))
[13:23:32.677]                     stop_if_not(is.finite(workers), workers >= 
[13:23:32.677]                       1L)
[13:23:32.677]                     if ((workers == 1L && !inherits(workers, 
[13:23:32.677]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:32.677]                       if (default_workers) 
[13:23:32.677]                         supportsMulticore(warn = TRUE)
[13:23:32.677]                       return(sequential(..., envir = envir))
[13:23:32.677]                     }
[13:23:32.677]                     oopts <- options(mc.cores = workers)
[13:23:32.677]                     on.exit(options(oopts))
[13:23:32.677]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:32.677]                       envir = envir)
[13:23:32.677]                     if (!future$lazy) 
[13:23:32.677]                       future <- run(future)
[13:23:32.677]                     invisible(future)
[13:23:32.677]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.677]                 }
[13:23:32.677]             }
[13:23:32.677]         }
[13:23:32.677]     })
[13:23:32.677]     if (TRUE) {
[13:23:32.677]         base::sink(type = "output", split = FALSE)
[13:23:32.677]         if (TRUE) {
[13:23:32.677]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.677]         }
[13:23:32.677]         else {
[13:23:32.677]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.677]         }
[13:23:32.677]         base::close(...future.stdout)
[13:23:32.677]         ...future.stdout <- NULL
[13:23:32.677]     }
[13:23:32.677]     ...future.result$conditions <- ...future.conditions
[13:23:32.677]     ...future.result$finished <- base::Sys.time()
[13:23:32.677]     ...future.result
[13:23:32.677] }
[13:23:32.681] assign_globals() ...
[13:23:32.681] List of 1
[13:23:32.681]  $ ii: int 3
[13:23:32.681]  - attr(*, "where")=List of 1
[13:23:32.681]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:32.681]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.681]  - attr(*, "resolved")= logi TRUE
[13:23:32.681]  - attr(*, "total_size")= num 56
[13:23:32.681]  - attr(*, "already-done")= logi TRUE
[13:23:32.685] - copied ‘ii’ to environment
[13:23:32.685] assign_globals() ... done
[13:23:32.685] requestCore(): workers = 2
[13:23:32.686] Poll #1 (0): usedCores() = 2, workers = 2
[13:23:32.697] result() for MulticoreFuture ...
[13:23:32.698] result() for MulticoreFuture ...
[13:23:32.698] result() for MulticoreFuture ... done
[13:23:32.699] result() for MulticoreFuture ... done
[13:23:32.699] result() for MulticoreFuture ...
[13:23:32.699] result() for MulticoreFuture ... done
[13:23:32.708] MulticoreFuture started
[13:23:32.709] - Launch lazy future ... done
[13:23:32.709] plan(): Setting new future strategy stack:
[13:23:32.709] run() for ‘MulticoreFuture’ ... done
[13:23:32.710] result() for MulticoreFuture ...
[13:23:32.710] List of future strategies:
[13:23:32.710] 1. sequential:
[13:23:32.710]    - args: function (..., envir = parent.frame())
[13:23:32.710]    - tweaked: FALSE
[13:23:32.710]    - call: NULL
[13:23:32.711] result() for MulticoreFuture ... done
[13:23:32.711] plan(): nbrOfWorkers() = 1
[13:23:32.711] result() for MulticoreFuture ...
[13:23:32.712] result() for MulticoreFuture ... done
[13:23:32.712] result() for MulticoreFuture ...
[13:23:32.714] plan(): Setting new future strategy stack:
[13:23:32.714] result() for MulticoreFuture ...
[13:23:32.715] result() for MulticoreFuture ... done
[13:23:32.714] List of future strategies:
[13:23:32.714] 1. multicore:
[13:23:32.714]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:32.714]    - tweaked: FALSE
[13:23:32.714]    - call: plan(strategy)
[13:23:32.715] result() for MulticoreFuture ... done
[13:23:32.715] result() for MulticoreFuture ...
[13:23:32.716] result() for MulticoreFuture ... done
[13:23:32.716] result() for MulticoreFuture ...
[13:23:32.720] plan(): nbrOfWorkers() = 2
[13:23:32.721] result() for MulticoreFuture ...
[13:23:32.721] result() for MulticoreFuture ... done
[13:23:32.721] result() for MulticoreFuture ... done
[13:23:32.721] result() for MulticoreFuture ...
[13:23:32.722] result() for MulticoreFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.723] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.723] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:32.725] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:32.725] Searching for globals ... DONE
[13:23:32.725] Resolving globals: TRUE
[13:23:32.726] Resolving any globals that are futures ...
[13:23:32.726] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:32.726] Resolving any globals that are futures ... DONE
[13:23:32.726] Resolving futures part of globals (recursively) ...
[13:23:32.727] resolve() on list ...
[13:23:32.727]  recursive: 99
[13:23:32.727]  length: 1
[13:23:32.727]  elements: ‘ii’
[13:23:32.727]  length: 0 (resolved future 1)
[13:23:32.727] resolve() on list ... DONE
[13:23:32.727] - globals: [1] ‘ii’
[13:23:32.727] Resolving futures part of globals (recursively) ... DONE
[13:23:32.728] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:32.728] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:32.728] - globals: [1] ‘ii’
[13:23:32.728] 
[13:23:32.728] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.729] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.730] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:32.731] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:32.731] Searching for globals ... DONE
[13:23:32.731] Resolving globals: TRUE
[13:23:32.732] Resolving any globals that are futures ...
[13:23:32.732] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:32.732] Resolving any globals that are futures ... DONE
[13:23:32.732] Resolving futures part of globals (recursively) ...
[13:23:32.733] resolve() on list ...
[13:23:32.733]  recursive: 99
[13:23:32.733]  length: 1
[13:23:32.733]  elements: ‘ii’
[13:23:32.733]  length: 0 (resolved future 1)
[13:23:32.733] resolve() on list ... DONE
[13:23:32.733] - globals: [1] ‘ii’
[13:23:32.733] Resolving futures part of globals (recursively) ... DONE
[13:23:32.733] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:32.734] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:32.734] - globals: [1] ‘ii’
[13:23:32.734] 
[13:23:32.734] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.735] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.735] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:32.737] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:32.737] Searching for globals ... DONE
[13:23:32.737] Resolving globals: TRUE
[13:23:32.737] Resolving any globals that are futures ...
[13:23:32.737] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:32.737] Resolving any globals that are futures ... DONE
[13:23:32.738] Resolving futures part of globals (recursively) ...
[13:23:32.738] resolve() on list ...
[13:23:32.738]  recursive: 99
[13:23:32.738]  length: 1
[13:23:32.738]  elements: ‘ii’
[13:23:32.738]  length: 0 (resolved future 1)
[13:23:32.738] resolve() on list ... DONE
[13:23:32.739] - globals: [1] ‘ii’
[13:23:32.739] Resolving futures part of globals (recursively) ... DONE
[13:23:32.739] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:32.739] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:32.739] - globals: [1] ‘ii’
[13:23:32.739] 
[13:23:32.740] getGlobalsAndPackages() ... DONE
[13:23:32.740] run() for ‘Future’ ...
[13:23:32.740] - state: ‘created’
[13:23:32.740] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:32.745] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:32.745] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:32.745]   - Field: ‘label’
[13:23:32.745]   - Field: ‘local’
[13:23:32.746]   - Field: ‘owner’
[13:23:32.746]   - Field: ‘envir’
[13:23:32.746]   - Field: ‘workers’
[13:23:32.746]   - Field: ‘packages’
[13:23:32.746]   - Field: ‘gc’
[13:23:32.746]   - Field: ‘job’
[13:23:32.746]   - Field: ‘conditions’
[13:23:32.746]   - Field: ‘expr’
[13:23:32.746]   - Field: ‘uuid’
[13:23:32.748]   - Field: ‘seed’
[13:23:32.749]   - Field: ‘version’
[13:23:32.749]   - Field: ‘result’
[13:23:32.749]   - Field: ‘asynchronous’
[13:23:32.749]   - Field: ‘calls’
[13:23:32.749]   - Field: ‘globals’
[13:23:32.749]   - Field: ‘stdout’
[13:23:32.749]   - Field: ‘earlySignal’
[13:23:32.749]   - Field: ‘lazy’
[13:23:32.750]   - Field: ‘state’
[13:23:32.750] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:32.750] - Launch lazy future ...
[13:23:32.750] Packages needed by the future expression (n = 0): <none>
[13:23:32.750] Packages needed by future strategies (n = 0): <none>
[13:23:32.751] {
[13:23:32.751]     {
[13:23:32.751]         {
[13:23:32.751]             ...future.startTime <- base::Sys.time()
[13:23:32.751]             {
[13:23:32.751]                 {
[13:23:32.751]                   {
[13:23:32.751]                     {
[13:23:32.751]                       base::local({
[13:23:32.751]                         has_future <- base::requireNamespace("future", 
[13:23:32.751]                           quietly = TRUE)
[13:23:32.751]                         if (has_future) {
[13:23:32.751]                           ns <- base::getNamespace("future")
[13:23:32.751]                           version <- ns[[".package"]][["version"]]
[13:23:32.751]                           if (is.null(version)) 
[13:23:32.751]                             version <- utils::packageVersion("future")
[13:23:32.751]                         }
[13:23:32.751]                         else {
[13:23:32.751]                           version <- NULL
[13:23:32.751]                         }
[13:23:32.751]                         if (!has_future || version < "1.8.0") {
[13:23:32.751]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.751]                             "", base::R.version$version.string), 
[13:23:32.751]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:32.751]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.751]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.751]                               "release", "version")], collapse = " "), 
[13:23:32.751]                             hostname = base::Sys.info()[["nodename"]])
[13:23:32.751]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.751]                             info)
[13:23:32.751]                           info <- base::paste(info, collapse = "; ")
[13:23:32.751]                           if (!has_future) {
[13:23:32.751]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.751]                               info)
[13:23:32.751]                           }
[13:23:32.751]                           else {
[13:23:32.751]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.751]                               info, version)
[13:23:32.751]                           }
[13:23:32.751]                           base::stop(msg)
[13:23:32.751]                         }
[13:23:32.751]                       })
[13:23:32.751]                     }
[13:23:32.751]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:32.751]                     base::options(mc.cores = 1L)
[13:23:32.751]                   }
[13:23:32.751]                   options(future.plan = NULL)
[13:23:32.751]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.751]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.751]                 }
[13:23:32.751]                 ...future.workdir <- getwd()
[13:23:32.751]             }
[13:23:32.751]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.751]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.751]         }
[13:23:32.751]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.751]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:32.751]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.751]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.751]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.751]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.751]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.751]             base::names(...future.oldOptions))
[13:23:32.751]     }
[13:23:32.751]     if (FALSE) {
[13:23:32.751]     }
[13:23:32.751]     else {
[13:23:32.751]         if (TRUE) {
[13:23:32.751]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.751]                 open = "w")
[13:23:32.751]         }
[13:23:32.751]         else {
[13:23:32.751]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.751]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.751]         }
[13:23:32.751]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.751]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.751]             base::sink(type = "output", split = FALSE)
[13:23:32.751]             base::close(...future.stdout)
[13:23:32.751]         }, add = TRUE)
[13:23:32.751]     }
[13:23:32.751]     ...future.frame <- base::sys.nframe()
[13:23:32.751]     ...future.conditions <- base::list()
[13:23:32.751]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.751]     if (FALSE) {
[13:23:32.751]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.751]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.751]     }
[13:23:32.751]     ...future.result <- base::tryCatch({
[13:23:32.751]         base::withCallingHandlers({
[13:23:32.751]             ...future.value <- base::withVisible(base::local({
[13:23:32.751]                 withCallingHandlers({
[13:23:32.751]                   {
[13:23:32.751]                     b <- a * ii
[13:23:32.751]                     a <- 0
[13:23:32.751]                     b
[13:23:32.751]                   }
[13:23:32.751]                 }, immediateCondition = function(cond) {
[13:23:32.751]                   save_rds <- function (object, pathname, ...) 
[13:23:32.751]                   {
[13:23:32.751]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:32.751]                     if (file_test("-f", pathname_tmp)) {
[13:23:32.751]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.751]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:32.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.751]                         fi_tmp[["mtime"]])
[13:23:32.751]                     }
[13:23:32.751]                     tryCatch({
[13:23:32.751]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:32.751]                     }, error = function(ex) {
[13:23:32.751]                       msg <- conditionMessage(ex)
[13:23:32.751]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.751]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:32.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.751]                         fi_tmp[["mtime"]], msg)
[13:23:32.751]                       ex$message <- msg
[13:23:32.751]                       stop(ex)
[13:23:32.751]                     })
[13:23:32.751]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:32.751]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:32.751]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:32.751]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.751]                       fi <- file.info(pathname)
[13:23:32.751]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:32.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.751]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:32.751]                         fi[["size"]], fi[["mtime"]])
[13:23:32.751]                       stop(msg)
[13:23:32.751]                     }
[13:23:32.751]                     invisible(pathname)
[13:23:32.751]                   }
[13:23:32.751]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:32.751]                     rootPath = tempdir()) 
[13:23:32.751]                   {
[13:23:32.751]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:32.751]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:32.751]                       tmpdir = path, fileext = ".rds")
[13:23:32.751]                     save_rds(obj, file)
[13:23:32.751]                   }
[13:23:32.751]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:32.751]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.751]                   {
[13:23:32.751]                     inherits <- base::inherits
[13:23:32.751]                     invokeRestart <- base::invokeRestart
[13:23:32.751]                     is.null <- base::is.null
[13:23:32.751]                     muffled <- FALSE
[13:23:32.751]                     if (inherits(cond, "message")) {
[13:23:32.751]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:32.751]                       if (muffled) 
[13:23:32.751]                         invokeRestart("muffleMessage")
[13:23:32.751]                     }
[13:23:32.751]                     else if (inherits(cond, "warning")) {
[13:23:32.751]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:32.751]                       if (muffled) 
[13:23:32.751]                         invokeRestart("muffleWarning")
[13:23:32.751]                     }
[13:23:32.751]                     else if (inherits(cond, "condition")) {
[13:23:32.751]                       if (!is.null(pattern)) {
[13:23:32.751]                         computeRestarts <- base::computeRestarts
[13:23:32.751]                         grepl <- base::grepl
[13:23:32.751]                         restarts <- computeRestarts(cond)
[13:23:32.751]                         for (restart in restarts) {
[13:23:32.751]                           name <- restart$name
[13:23:32.751]                           if (is.null(name)) 
[13:23:32.751]                             next
[13:23:32.751]                           if (!grepl(pattern, name)) 
[13:23:32.751]                             next
[13:23:32.751]                           invokeRestart(restart)
[13:23:32.751]                           muffled <- TRUE
[13:23:32.751]                           break
[13:23:32.751]                         }
[13:23:32.751]                       }
[13:23:32.751]                     }
[13:23:32.751]                     invisible(muffled)
[13:23:32.751]                   }
[13:23:32.751]                   muffleCondition(cond)
[13:23:32.751]                 })
[13:23:32.751]             }))
[13:23:32.751]             future::FutureResult(value = ...future.value$value, 
[13:23:32.751]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.751]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.751]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.751]                     ...future.globalenv.names))
[13:23:32.751]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.751]         }, condition = base::local({
[13:23:32.751]             c <- base::c
[13:23:32.751]             inherits <- base::inherits
[13:23:32.751]             invokeRestart <- base::invokeRestart
[13:23:32.751]             length <- base::length
[13:23:32.751]             list <- base::list
[13:23:32.751]             seq.int <- base::seq.int
[13:23:32.751]             signalCondition <- base::signalCondition
[13:23:32.751]             sys.calls <- base::sys.calls
[13:23:32.751]             `[[` <- base::`[[`
[13:23:32.751]             `+` <- base::`+`
[13:23:32.751]             `<<-` <- base::`<<-`
[13:23:32.751]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.751]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.751]                   3L)]
[13:23:32.751]             }
[13:23:32.751]             function(cond) {
[13:23:32.751]                 is_error <- inherits(cond, "error")
[13:23:32.751]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.751]                   NULL)
[13:23:32.751]                 if (is_error) {
[13:23:32.751]                   sessionInformation <- function() {
[13:23:32.751]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.751]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.751]                       search = base::search(), system = base::Sys.info())
[13:23:32.751]                   }
[13:23:32.751]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.751]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.751]                     cond$call), session = sessionInformation(), 
[13:23:32.751]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.751]                   signalCondition(cond)
[13:23:32.751]                 }
[13:23:32.751]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.751]                 "immediateCondition"))) {
[13:23:32.751]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.751]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.751]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.751]                   if (TRUE && !signal) {
[13:23:32.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.751]                     {
[13:23:32.751]                       inherits <- base::inherits
[13:23:32.751]                       invokeRestart <- base::invokeRestart
[13:23:32.751]                       is.null <- base::is.null
[13:23:32.751]                       muffled <- FALSE
[13:23:32.751]                       if (inherits(cond, "message")) {
[13:23:32.751]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.751]                         if (muffled) 
[13:23:32.751]                           invokeRestart("muffleMessage")
[13:23:32.751]                       }
[13:23:32.751]                       else if (inherits(cond, "warning")) {
[13:23:32.751]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.751]                         if (muffled) 
[13:23:32.751]                           invokeRestart("muffleWarning")
[13:23:32.751]                       }
[13:23:32.751]                       else if (inherits(cond, "condition")) {
[13:23:32.751]                         if (!is.null(pattern)) {
[13:23:32.751]                           computeRestarts <- base::computeRestarts
[13:23:32.751]                           grepl <- base::grepl
[13:23:32.751]                           restarts <- computeRestarts(cond)
[13:23:32.751]                           for (restart in restarts) {
[13:23:32.751]                             name <- restart$name
[13:23:32.751]                             if (is.null(name)) 
[13:23:32.751]                               next
[13:23:32.751]                             if (!grepl(pattern, name)) 
[13:23:32.751]                               next
[13:23:32.751]                             invokeRestart(restart)
[13:23:32.751]                             muffled <- TRUE
[13:23:32.751]                             break
[13:23:32.751]                           }
[13:23:32.751]                         }
[13:23:32.751]                       }
[13:23:32.751]                       invisible(muffled)
[13:23:32.751]                     }
[13:23:32.751]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.751]                   }
[13:23:32.751]                 }
[13:23:32.751]                 else {
[13:23:32.751]                   if (TRUE) {
[13:23:32.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.751]                     {
[13:23:32.751]                       inherits <- base::inherits
[13:23:32.751]                       invokeRestart <- base::invokeRestart
[13:23:32.751]                       is.null <- base::is.null
[13:23:32.751]                       muffled <- FALSE
[13:23:32.751]                       if (inherits(cond, "message")) {
[13:23:32.751]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.751]                         if (muffled) 
[13:23:32.751]                           invokeRestart("muffleMessage")
[13:23:32.751]                       }
[13:23:32.751]                       else if (inherits(cond, "warning")) {
[13:23:32.751]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.751]                         if (muffled) 
[13:23:32.751]                           invokeRestart("muffleWarning")
[13:23:32.751]                       }
[13:23:32.751]                       else if (inherits(cond, "condition")) {
[13:23:32.751]                         if (!is.null(pattern)) {
[13:23:32.751]                           computeRestarts <- base::computeRestarts
[13:23:32.751]                           grepl <- base::grepl
[13:23:32.751]                           restarts <- computeRestarts(cond)
[13:23:32.751]                           for (restart in restarts) {
[13:23:32.751]                             name <- restart$name
[13:23:32.751]                             if (is.null(name)) 
[13:23:32.751]                               next
[13:23:32.751]                             if (!grepl(pattern, name)) 
[13:23:32.751]                               next
[13:23:32.751]                             invokeRestart(restart)
[13:23:32.751]                             muffled <- TRUE
[13:23:32.751]                             break
[13:23:32.751]                           }
[13:23:32.751]                         }
[13:23:32.751]                       }
[13:23:32.751]                       invisible(muffled)
[13:23:32.751]                     }
[13:23:32.751]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.751]                   }
[13:23:32.751]                 }
[13:23:32.751]             }
[13:23:32.751]         }))
[13:23:32.751]     }, error = function(ex) {
[13:23:32.751]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.751]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.751]                 ...future.rng), started = ...future.startTime, 
[13:23:32.751]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.751]             version = "1.8"), class = "FutureResult")
[13:23:32.751]     }, finally = {
[13:23:32.751]         if (!identical(...future.workdir, getwd())) 
[13:23:32.751]             setwd(...future.workdir)
[13:23:32.751]         {
[13:23:32.751]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.751]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.751]             }
[13:23:32.751]             base::options(...future.oldOptions)
[13:23:32.751]             if (.Platform$OS.type == "windows") {
[13:23:32.751]                 old_names <- names(...future.oldEnvVars)
[13:23:32.751]                 envs <- base::Sys.getenv()
[13:23:32.751]                 names <- names(envs)
[13:23:32.751]                 common <- intersect(names, old_names)
[13:23:32.751]                 added <- setdiff(names, old_names)
[13:23:32.751]                 removed <- setdiff(old_names, names)
[13:23:32.751]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.751]                   envs[common]]
[13:23:32.751]                 NAMES <- toupper(changed)
[13:23:32.751]                 args <- list()
[13:23:32.751]                 for (kk in seq_along(NAMES)) {
[13:23:32.751]                   name <- changed[[kk]]
[13:23:32.751]                   NAME <- NAMES[[kk]]
[13:23:32.751]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.751]                     next
[13:23:32.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.751]                 }
[13:23:32.751]                 NAMES <- toupper(added)
[13:23:32.751]                 for (kk in seq_along(NAMES)) {
[13:23:32.751]                   name <- added[[kk]]
[13:23:32.751]                   NAME <- NAMES[[kk]]
[13:23:32.751]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.751]                     next
[13:23:32.751]                   args[[name]] <- ""
[13:23:32.751]                 }
[13:23:32.751]                 NAMES <- toupper(removed)
[13:23:32.751]                 for (kk in seq_along(NAMES)) {
[13:23:32.751]                   name <- removed[[kk]]
[13:23:32.751]                   NAME <- NAMES[[kk]]
[13:23:32.751]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.751]                     next
[13:23:32.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.751]                 }
[13:23:32.751]                 if (length(args) > 0) 
[13:23:32.751]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.751]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.751]             }
[13:23:32.751]             else {
[13:23:32.751]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.751]             }
[13:23:32.751]             {
[13:23:32.751]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.751]                   0L) {
[13:23:32.751]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.751]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.751]                   base::options(opts)
[13:23:32.751]                 }
[13:23:32.751]                 {
[13:23:32.751]                   {
[13:23:32.751]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:32.751]                     NULL
[13:23:32.751]                   }
[13:23:32.751]                   options(future.plan = NULL)
[13:23:32.751]                   if (is.na(NA_character_)) 
[13:23:32.751]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.751]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.751]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:32.751]                     envir = parent.frame()) 
[13:23:32.751]                   {
[13:23:32.751]                     default_workers <- missing(workers)
[13:23:32.751]                     if (is.function(workers)) 
[13:23:32.751]                       workers <- workers()
[13:23:32.751]                     workers <- structure(as.integer(workers), 
[13:23:32.751]                       class = class(workers))
[13:23:32.751]                     stop_if_not(is.finite(workers), workers >= 
[13:23:32.751]                       1L)
[13:23:32.751]                     if ((workers == 1L && !inherits(workers, 
[13:23:32.751]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:32.751]                       if (default_workers) 
[13:23:32.751]                         supportsMulticore(warn = TRUE)
[13:23:32.751]                       return(sequential(..., envir = envir))
[13:23:32.751]                     }
[13:23:32.751]                     oopts <- options(mc.cores = workers)
[13:23:32.751]                     on.exit(options(oopts))
[13:23:32.751]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:32.751]                       envir = envir)
[13:23:32.751]                     if (!future$lazy) 
[13:23:32.751]                       future <- run(future)
[13:23:32.751]                     invisible(future)
[13:23:32.751]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.751]                 }
[13:23:32.751]             }
[13:23:32.751]         }
[13:23:32.751]     })
[13:23:32.751]     if (TRUE) {
[13:23:32.751]         base::sink(type = "output", split = FALSE)
[13:23:32.751]         if (TRUE) {
[13:23:32.751]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.751]         }
[13:23:32.751]         else {
[13:23:32.751]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.751]         }
[13:23:32.751]         base::close(...future.stdout)
[13:23:32.751]         ...future.stdout <- NULL
[13:23:32.751]     }
[13:23:32.751]     ...future.result$conditions <- ...future.conditions
[13:23:32.751]     ...future.result$finished <- base::Sys.time()
[13:23:32.751]     ...future.result
[13:23:32.751] }
[13:23:32.753] assign_globals() ...
[13:23:32.754] List of 1
[13:23:32.754]  $ ii: int 1
[13:23:32.754]  - attr(*, "where")=List of 1
[13:23:32.754]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:32.754]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.754]  - attr(*, "resolved")= logi TRUE
[13:23:32.754]  - attr(*, "total_size")= num 56
[13:23:32.754]  - attr(*, "already-done")= logi TRUE
[13:23:32.757] - copied ‘ii’ to environment
[13:23:32.757] assign_globals() ... done
[13:23:32.757] requestCore(): workers = 2
[13:23:32.759] MulticoreFuture started
[13:23:32.760] - Launch lazy future ... done
[13:23:32.760] run() for ‘MulticoreFuture’ ... done
[13:23:32.760] result() for MulticoreFuture ...
[13:23:32.761] plan(): Setting new future strategy stack:
[13:23:32.761] List of future strategies:
[13:23:32.761] 1. sequential:
[13:23:32.761]    - args: function (..., envir = parent.frame())
[13:23:32.761]    - tweaked: FALSE
[13:23:32.761]    - call: NULL
[13:23:32.762] plan(): nbrOfWorkers() = 1
[13:23:32.764] plan(): Setting new future strategy stack:
[13:23:32.764] List of future strategies:
[13:23:32.764] 1. multicore:
[13:23:32.764]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:32.764]    - tweaked: FALSE
[13:23:32.764]    - call: plan(strategy)
[13:23:32.770] plan(): nbrOfWorkers() = 2
[13:23:32.778] result() for MulticoreFuture ...
[13:23:32.778] result() for MulticoreFuture ... done
[13:23:32.778] signalConditions() ...
[13:23:32.778]  - include = ‘immediateCondition’
[13:23:32.778]  - exclude = 
[13:23:32.778]  - resignal = FALSE
[13:23:32.779]  - Number of conditions: 1
[13:23:32.779] signalConditions() ... done
[13:23:32.779] result() for MulticoreFuture ... done
[13:23:32.779] result() for MulticoreFuture ...
[13:23:32.779] result() for MulticoreFuture ... done
[13:23:32.779] signalConditions() ...
[13:23:32.779]  - include = ‘immediateCondition’
[13:23:32.779]  - exclude = 
[13:23:32.780]  - resignal = FALSE
[13:23:32.780]  - Number of conditions: 1
[13:23:32.780] signalConditions() ... done
[13:23:32.780] Future state: ‘finished’
[13:23:32.780] result() for MulticoreFuture ...
[13:23:32.780] result() for MulticoreFuture ... done
[13:23:32.780] signalConditions() ...
[13:23:32.781]  - include = ‘condition’
[13:23:32.781]  - exclude = ‘immediateCondition’
[13:23:32.781]  - resignal = TRUE
[13:23:32.781]  - Number of conditions: 1
[13:23:32.781]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:23:32.781] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 45
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language local({     value <- value(future) ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "47b98e4ec3a9" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:23:32"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.813] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.813] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:32.814] 
[13:23:32.814] Searching for globals ... DONE
[13:23:32.814] - globals: [0] <none>
[13:23:32.814] getGlobalsAndPackages() ... DONE
[13:23:32.814] run() for ‘Future’ ...
[13:23:32.814] - state: ‘created’
[13:23:32.815] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:32.821] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:32.821] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:32.821]   - Field: ‘label’
[13:23:32.822]   - Field: ‘local’
[13:23:32.822]   - Field: ‘owner’
[13:23:32.822]   - Field: ‘envir’
[13:23:32.822]   - Field: ‘workers’
[13:23:32.822]   - Field: ‘packages’
[13:23:32.822]   - Field: ‘gc’
[13:23:32.822]   - Field: ‘job’
[13:23:32.823]   - Field: ‘conditions’
[13:23:32.823]   - Field: ‘expr’
[13:23:32.823]   - Field: ‘uuid’
[13:23:32.823]   - Field: ‘seed’
[13:23:32.823]   - Field: ‘version’
[13:23:32.823]   - Field: ‘result’
[13:23:32.823]   - Field: ‘asynchronous’
[13:23:32.823]   - Field: ‘calls’
[13:23:32.823]   - Field: ‘globals’
[13:23:32.824]   - Field: ‘stdout’
[13:23:32.824]   - Field: ‘earlySignal’
[13:23:32.824]   - Field: ‘lazy’
[13:23:32.824]   - Field: ‘state’
[13:23:32.824] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:32.824] - Launch lazy future ...
[13:23:32.824] Packages needed by the future expression (n = 0): <none>
[13:23:32.825] Packages needed by future strategies (n = 0): <none>
[13:23:32.825] {
[13:23:32.825]     {
[13:23:32.825]         {
[13:23:32.825]             ...future.startTime <- base::Sys.time()
[13:23:32.825]             {
[13:23:32.825]                 {
[13:23:32.825]                   {
[13:23:32.825]                     {
[13:23:32.825]                       base::local({
[13:23:32.825]                         has_future <- base::requireNamespace("future", 
[13:23:32.825]                           quietly = TRUE)
[13:23:32.825]                         if (has_future) {
[13:23:32.825]                           ns <- base::getNamespace("future")
[13:23:32.825]                           version <- ns[[".package"]][["version"]]
[13:23:32.825]                           if (is.null(version)) 
[13:23:32.825]                             version <- utils::packageVersion("future")
[13:23:32.825]                         }
[13:23:32.825]                         else {
[13:23:32.825]                           version <- NULL
[13:23:32.825]                         }
[13:23:32.825]                         if (!has_future || version < "1.8.0") {
[13:23:32.825]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.825]                             "", base::R.version$version.string), 
[13:23:32.825]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:32.825]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.825]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.825]                               "release", "version")], collapse = " "), 
[13:23:32.825]                             hostname = base::Sys.info()[["nodename"]])
[13:23:32.825]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.825]                             info)
[13:23:32.825]                           info <- base::paste(info, collapse = "; ")
[13:23:32.825]                           if (!has_future) {
[13:23:32.825]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.825]                               info)
[13:23:32.825]                           }
[13:23:32.825]                           else {
[13:23:32.825]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.825]                               info, version)
[13:23:32.825]                           }
[13:23:32.825]                           base::stop(msg)
[13:23:32.825]                         }
[13:23:32.825]                       })
[13:23:32.825]                     }
[13:23:32.825]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:32.825]                     base::options(mc.cores = 1L)
[13:23:32.825]                   }
[13:23:32.825]                   options(future.plan = NULL)
[13:23:32.825]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.825]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.825]                 }
[13:23:32.825]                 ...future.workdir <- getwd()
[13:23:32.825]             }
[13:23:32.825]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.825]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.825]         }
[13:23:32.825]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.825]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:32.825]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.825]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.825]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.825]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.825]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.825]             base::names(...future.oldOptions))
[13:23:32.825]     }
[13:23:32.825]     if (FALSE) {
[13:23:32.825]     }
[13:23:32.825]     else {
[13:23:32.825]         if (TRUE) {
[13:23:32.825]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.825]                 open = "w")
[13:23:32.825]         }
[13:23:32.825]         else {
[13:23:32.825]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.825]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.825]         }
[13:23:32.825]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.825]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.825]             base::sink(type = "output", split = FALSE)
[13:23:32.825]             base::close(...future.stdout)
[13:23:32.825]         }, add = TRUE)
[13:23:32.825]     }
[13:23:32.825]     ...future.frame <- base::sys.nframe()
[13:23:32.825]     ...future.conditions <- base::list()
[13:23:32.825]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.825]     if (FALSE) {
[13:23:32.825]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.825]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.825]     }
[13:23:32.825]     ...future.result <- base::tryCatch({
[13:23:32.825]         base::withCallingHandlers({
[13:23:32.825]             ...future.value <- base::withVisible(base::local({
[13:23:32.825]                 withCallingHandlers({
[13:23:32.825]                   1
[13:23:32.825]                 }, immediateCondition = function(cond) {
[13:23:32.825]                   save_rds <- function (object, pathname, ...) 
[13:23:32.825]                   {
[13:23:32.825]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:32.825]                     if (file_test("-f", pathname_tmp)) {
[13:23:32.825]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.825]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:32.825]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.825]                         fi_tmp[["mtime"]])
[13:23:32.825]                     }
[13:23:32.825]                     tryCatch({
[13:23:32.825]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:32.825]                     }, error = function(ex) {
[13:23:32.825]                       msg <- conditionMessage(ex)
[13:23:32.825]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.825]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:32.825]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.825]                         fi_tmp[["mtime"]], msg)
[13:23:32.825]                       ex$message <- msg
[13:23:32.825]                       stop(ex)
[13:23:32.825]                     })
[13:23:32.825]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:32.825]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:32.825]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:32.825]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.825]                       fi <- file.info(pathname)
[13:23:32.825]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:32.825]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.825]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:32.825]                         fi[["size"]], fi[["mtime"]])
[13:23:32.825]                       stop(msg)
[13:23:32.825]                     }
[13:23:32.825]                     invisible(pathname)
[13:23:32.825]                   }
[13:23:32.825]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:32.825]                     rootPath = tempdir()) 
[13:23:32.825]                   {
[13:23:32.825]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:32.825]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:32.825]                       tmpdir = path, fileext = ".rds")
[13:23:32.825]                     save_rds(obj, file)
[13:23:32.825]                   }
[13:23:32.825]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:32.825]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.825]                   {
[13:23:32.825]                     inherits <- base::inherits
[13:23:32.825]                     invokeRestart <- base::invokeRestart
[13:23:32.825]                     is.null <- base::is.null
[13:23:32.825]                     muffled <- FALSE
[13:23:32.825]                     if (inherits(cond, "message")) {
[13:23:32.825]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:32.825]                       if (muffled) 
[13:23:32.825]                         invokeRestart("muffleMessage")
[13:23:32.825]                     }
[13:23:32.825]                     else if (inherits(cond, "warning")) {
[13:23:32.825]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:32.825]                       if (muffled) 
[13:23:32.825]                         invokeRestart("muffleWarning")
[13:23:32.825]                     }
[13:23:32.825]                     else if (inherits(cond, "condition")) {
[13:23:32.825]                       if (!is.null(pattern)) {
[13:23:32.825]                         computeRestarts <- base::computeRestarts
[13:23:32.825]                         grepl <- base::grepl
[13:23:32.825]                         restarts <- computeRestarts(cond)
[13:23:32.825]                         for (restart in restarts) {
[13:23:32.825]                           name <- restart$name
[13:23:32.825]                           if (is.null(name)) 
[13:23:32.825]                             next
[13:23:32.825]                           if (!grepl(pattern, name)) 
[13:23:32.825]                             next
[13:23:32.825]                           invokeRestart(restart)
[13:23:32.825]                           muffled <- TRUE
[13:23:32.825]                           break
[13:23:32.825]                         }
[13:23:32.825]                       }
[13:23:32.825]                     }
[13:23:32.825]                     invisible(muffled)
[13:23:32.825]                   }
[13:23:32.825]                   muffleCondition(cond)
[13:23:32.825]                 })
[13:23:32.825]             }))
[13:23:32.825]             future::FutureResult(value = ...future.value$value, 
[13:23:32.825]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.825]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.825]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.825]                     ...future.globalenv.names))
[13:23:32.825]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.825]         }, condition = base::local({
[13:23:32.825]             c <- base::c
[13:23:32.825]             inherits <- base::inherits
[13:23:32.825]             invokeRestart <- base::invokeRestart
[13:23:32.825]             length <- base::length
[13:23:32.825]             list <- base::list
[13:23:32.825]             seq.int <- base::seq.int
[13:23:32.825]             signalCondition <- base::signalCondition
[13:23:32.825]             sys.calls <- base::sys.calls
[13:23:32.825]             `[[` <- base::`[[`
[13:23:32.825]             `+` <- base::`+`
[13:23:32.825]             `<<-` <- base::`<<-`
[13:23:32.825]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.825]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.825]                   3L)]
[13:23:32.825]             }
[13:23:32.825]             function(cond) {
[13:23:32.825]                 is_error <- inherits(cond, "error")
[13:23:32.825]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.825]                   NULL)
[13:23:32.825]                 if (is_error) {
[13:23:32.825]                   sessionInformation <- function() {
[13:23:32.825]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.825]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.825]                       search = base::search(), system = base::Sys.info())
[13:23:32.825]                   }
[13:23:32.825]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.825]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.825]                     cond$call), session = sessionInformation(), 
[13:23:32.825]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.825]                   signalCondition(cond)
[13:23:32.825]                 }
[13:23:32.825]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.825]                 "immediateCondition"))) {
[13:23:32.825]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.825]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.825]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.825]                   if (TRUE && !signal) {
[13:23:32.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.825]                     {
[13:23:32.825]                       inherits <- base::inherits
[13:23:32.825]                       invokeRestart <- base::invokeRestart
[13:23:32.825]                       is.null <- base::is.null
[13:23:32.825]                       muffled <- FALSE
[13:23:32.825]                       if (inherits(cond, "message")) {
[13:23:32.825]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.825]                         if (muffled) 
[13:23:32.825]                           invokeRestart("muffleMessage")
[13:23:32.825]                       }
[13:23:32.825]                       else if (inherits(cond, "warning")) {
[13:23:32.825]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.825]                         if (muffled) 
[13:23:32.825]                           invokeRestart("muffleWarning")
[13:23:32.825]                       }
[13:23:32.825]                       else if (inherits(cond, "condition")) {
[13:23:32.825]                         if (!is.null(pattern)) {
[13:23:32.825]                           computeRestarts <- base::computeRestarts
[13:23:32.825]                           grepl <- base::grepl
[13:23:32.825]                           restarts <- computeRestarts(cond)
[13:23:32.825]                           for (restart in restarts) {
[13:23:32.825]                             name <- restart$name
[13:23:32.825]                             if (is.null(name)) 
[13:23:32.825]                               next
[13:23:32.825]                             if (!grepl(pattern, name)) 
[13:23:32.825]                               next
[13:23:32.825]                             invokeRestart(restart)
[13:23:32.825]                             muffled <- TRUE
[13:23:32.825]                             break
[13:23:32.825]                           }
[13:23:32.825]                         }
[13:23:32.825]                       }
[13:23:32.825]                       invisible(muffled)
[13:23:32.825]                     }
[13:23:32.825]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.825]                   }
[13:23:32.825]                 }
[13:23:32.825]                 else {
[13:23:32.825]                   if (TRUE) {
[13:23:32.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.825]                     {
[13:23:32.825]                       inherits <- base::inherits
[13:23:32.825]                       invokeRestart <- base::invokeRestart
[13:23:32.825]                       is.null <- base::is.null
[13:23:32.825]                       muffled <- FALSE
[13:23:32.825]                       if (inherits(cond, "message")) {
[13:23:32.825]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.825]                         if (muffled) 
[13:23:32.825]                           invokeRestart("muffleMessage")
[13:23:32.825]                       }
[13:23:32.825]                       else if (inherits(cond, "warning")) {
[13:23:32.825]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.825]                         if (muffled) 
[13:23:32.825]                           invokeRestart("muffleWarning")
[13:23:32.825]                       }
[13:23:32.825]                       else if (inherits(cond, "condition")) {
[13:23:32.825]                         if (!is.null(pattern)) {
[13:23:32.825]                           computeRestarts <- base::computeRestarts
[13:23:32.825]                           grepl <- base::grepl
[13:23:32.825]                           restarts <- computeRestarts(cond)
[13:23:32.825]                           for (restart in restarts) {
[13:23:32.825]                             name <- restart$name
[13:23:32.825]                             if (is.null(name)) 
[13:23:32.825]                               next
[13:23:32.825]                             if (!grepl(pattern, name)) 
[13:23:32.825]                               next
[13:23:32.825]                             invokeRestart(restart)
[13:23:32.825]                             muffled <- TRUE
[13:23:32.825]                             break
[13:23:32.825]                           }
[13:23:32.825]                         }
[13:23:32.825]                       }
[13:23:32.825]                       invisible(muffled)
[13:23:32.825]                     }
[13:23:32.825]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.825]                   }
[13:23:32.825]                 }
[13:23:32.825]             }
[13:23:32.825]         }))
[13:23:32.825]     }, error = function(ex) {
[13:23:32.825]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.825]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.825]                 ...future.rng), started = ...future.startTime, 
[13:23:32.825]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.825]             version = "1.8"), class = "FutureResult")
[13:23:32.825]     }, finally = {
[13:23:32.825]         if (!identical(...future.workdir, getwd())) 
[13:23:32.825]             setwd(...future.workdir)
[13:23:32.825]         {
[13:23:32.825]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.825]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.825]             }
[13:23:32.825]             base::options(...future.oldOptions)
[13:23:32.825]             if (.Platform$OS.type == "windows") {
[13:23:32.825]                 old_names <- names(...future.oldEnvVars)
[13:23:32.825]                 envs <- base::Sys.getenv()
[13:23:32.825]                 names <- names(envs)
[13:23:32.825]                 common <- intersect(names, old_names)
[13:23:32.825]                 added <- setdiff(names, old_names)
[13:23:32.825]                 removed <- setdiff(old_names, names)
[13:23:32.825]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.825]                   envs[common]]
[13:23:32.825]                 NAMES <- toupper(changed)
[13:23:32.825]                 args <- list()
[13:23:32.825]                 for (kk in seq_along(NAMES)) {
[13:23:32.825]                   name <- changed[[kk]]
[13:23:32.825]                   NAME <- NAMES[[kk]]
[13:23:32.825]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.825]                     next
[13:23:32.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.825]                 }
[13:23:32.825]                 NAMES <- toupper(added)
[13:23:32.825]                 for (kk in seq_along(NAMES)) {
[13:23:32.825]                   name <- added[[kk]]
[13:23:32.825]                   NAME <- NAMES[[kk]]
[13:23:32.825]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.825]                     next
[13:23:32.825]                   args[[name]] <- ""
[13:23:32.825]                 }
[13:23:32.825]                 NAMES <- toupper(removed)
[13:23:32.825]                 for (kk in seq_along(NAMES)) {
[13:23:32.825]                   name <- removed[[kk]]
[13:23:32.825]                   NAME <- NAMES[[kk]]
[13:23:32.825]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.825]                     next
[13:23:32.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.825]                 }
[13:23:32.825]                 if (length(args) > 0) 
[13:23:32.825]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.825]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.825]             }
[13:23:32.825]             else {
[13:23:32.825]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.825]             }
[13:23:32.825]             {
[13:23:32.825]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.825]                   0L) {
[13:23:32.825]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.825]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.825]                   base::options(opts)
[13:23:32.825]                 }
[13:23:32.825]                 {
[13:23:32.825]                   {
[13:23:32.825]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:32.825]                     NULL
[13:23:32.825]                   }
[13:23:32.825]                   options(future.plan = NULL)
[13:23:32.825]                   if (is.na(NA_character_)) 
[13:23:32.825]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.825]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.825]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:32.825]                     envir = parent.frame()) 
[13:23:32.825]                   {
[13:23:32.825]                     default_workers <- missing(workers)
[13:23:32.825]                     if (is.function(workers)) 
[13:23:32.825]                       workers <- workers()
[13:23:32.825]                     workers <- structure(as.integer(workers), 
[13:23:32.825]                       class = class(workers))
[13:23:32.825]                     stop_if_not(is.finite(workers), workers >= 
[13:23:32.825]                       1L)
[13:23:32.825]                     if ((workers == 1L && !inherits(workers, 
[13:23:32.825]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:32.825]                       if (default_workers) 
[13:23:32.825]                         supportsMulticore(warn = TRUE)
[13:23:32.825]                       return(sequential(..., envir = envir))
[13:23:32.825]                     }
[13:23:32.825]                     oopts <- options(mc.cores = workers)
[13:23:32.825]                     on.exit(options(oopts))
[13:23:32.825]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:32.825]                       envir = envir)
[13:23:32.825]                     if (!future$lazy) 
[13:23:32.825]                       future <- run(future)
[13:23:32.825]                     invisible(future)
[13:23:32.825]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.825]                 }
[13:23:32.825]             }
[13:23:32.825]         }
[13:23:32.825]     })
[13:23:32.825]     if (TRUE) {
[13:23:32.825]         base::sink(type = "output", split = FALSE)
[13:23:32.825]         if (TRUE) {
[13:23:32.825]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.825]         }
[13:23:32.825]         else {
[13:23:32.825]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.825]         }
[13:23:32.825]         base::close(...future.stdout)
[13:23:32.825]         ...future.stdout <- NULL
[13:23:32.825]     }
[13:23:32.825]     ...future.result$conditions <- ...future.conditions
[13:23:32.825]     ...future.result$finished <- base::Sys.time()
[13:23:32.825]     ...future.result
[13:23:32.825] }
[13:23:32.828] requestCore(): workers = 2
[13:23:32.830] MulticoreFuture started
[13:23:32.831] - Launch lazy future ... done
[13:23:32.831] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.832] plan(): Setting new future strategy stack:
[13:23:32.832] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.832] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:32.832] List of future strategies:
[13:23:32.832] 1. sequential:
[13:23:32.832]    - args: function (..., envir = parent.frame())
[13:23:32.832]    - tweaked: FALSE
[13:23:32.832]    - call: NULL
[13:23:32.833] plan(): nbrOfWorkers() = 1
[13:23:32.835] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:32.835] Searching for globals ... DONE
[13:23:32.835] plan(): Setting new future strategy stack:
[13:23:32.835] Resolving globals: TRUE
[13:23:32.835] Resolving any globals that are futures ...
[13:23:32.836] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:32.836] Resolving any globals that are futures ... DONE
[13:23:32.835] List of future strategies:
[13:23:32.835] 1. multicore:
[13:23:32.835]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:32.835]    - tweaked: FALSE
[13:23:32.835]    - call: plan(strategy)
[13:23:32.836] Resolving futures part of globals (recursively) ...
[13:23:32.837] resolve() on list ...
[13:23:32.837]  recursive: 99
[13:23:32.837]  length: 1
[13:23:32.838]  elements: ‘a’
[13:23:32.840] plan(): nbrOfWorkers() = 2
[13:23:32.841] Future #1
[13:23:32.841] result() for MulticoreFuture ...
[13:23:32.842] result() for MulticoreFuture ...
[13:23:32.842] result() for MulticoreFuture ... done
[13:23:32.843] result() for MulticoreFuture ... done
[13:23:32.843] result() for MulticoreFuture ...
[13:23:32.843] result() for MulticoreFuture ... done
[13:23:32.843] A MulticoreFuture was resolved
[13:23:32.843]  length: 0 (resolved future 1)
[13:23:32.844] resolve() on list ... DONE
[13:23:32.844] - globals: [1] ‘a’
[13:23:32.844] Resolving futures part of globals (recursively) ... DONE
[13:23:32.845] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[13:23:32.846] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[13:23:32.846] - globals: [1] ‘a’
[13:23:32.846] - packages: [1] ‘future’
[13:23:32.846] getGlobalsAndPackages() ... DONE
[13:23:32.847] run() for ‘Future’ ...
[13:23:32.847] - state: ‘created’
[13:23:32.847] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:32.851] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:32.852] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:32.852]   - Field: ‘label’
[13:23:32.852]   - Field: ‘local’
[13:23:32.852]   - Field: ‘owner’
[13:23:32.852]   - Field: ‘envir’
[13:23:32.852]   - Field: ‘workers’
[13:23:32.852]   - Field: ‘packages’
[13:23:32.853]   - Field: ‘gc’
[13:23:32.853]   - Field: ‘job’
[13:23:32.853]   - Field: ‘conditions’
[13:23:32.853]   - Field: ‘expr’
[13:23:32.853]   - Field: ‘uuid’
[13:23:32.853]   - Field: ‘seed’
[13:23:32.853]   - Field: ‘version’
[13:23:32.853]   - Field: ‘result’
[13:23:32.854]   - Field: ‘asynchronous’
[13:23:32.854]   - Field: ‘calls’
[13:23:32.854]   - Field: ‘globals’
[13:23:32.854]   - Field: ‘stdout’
[13:23:32.854]   - Field: ‘earlySignal’
[13:23:32.854]   - Field: ‘lazy’
[13:23:32.854]   - Field: ‘state’
[13:23:32.854] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:32.854] - Launch lazy future ...
[13:23:32.855] Packages needed by the future expression (n = 1): ‘future’
[13:23:32.855] Packages needed by future strategies (n = 0): <none>
[13:23:32.856] {
[13:23:32.856]     {
[13:23:32.856]         {
[13:23:32.856]             ...future.startTime <- base::Sys.time()
[13:23:32.856]             {
[13:23:32.856]                 {
[13:23:32.856]                   {
[13:23:32.856]                     {
[13:23:32.856]                       {
[13:23:32.856]                         base::local({
[13:23:32.856]                           has_future <- base::requireNamespace("future", 
[13:23:32.856]                             quietly = TRUE)
[13:23:32.856]                           if (has_future) {
[13:23:32.856]                             ns <- base::getNamespace("future")
[13:23:32.856]                             version <- ns[[".package"]][["version"]]
[13:23:32.856]                             if (is.null(version)) 
[13:23:32.856]                               version <- utils::packageVersion("future")
[13:23:32.856]                           }
[13:23:32.856]                           else {
[13:23:32.856]                             version <- NULL
[13:23:32.856]                           }
[13:23:32.856]                           if (!has_future || version < "1.8.0") {
[13:23:32.856]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.856]                               "", base::R.version$version.string), 
[13:23:32.856]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:32.856]                                 base::R.version$platform, 8 * 
[13:23:32.856]                                   base::.Machine$sizeof.pointer), 
[13:23:32.856]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.856]                                 "release", "version")], collapse = " "), 
[13:23:32.856]                               hostname = base::Sys.info()[["nodename"]])
[13:23:32.856]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.856]                               info)
[13:23:32.856]                             info <- base::paste(info, collapse = "; ")
[13:23:32.856]                             if (!has_future) {
[13:23:32.856]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.856]                                 info)
[13:23:32.856]                             }
[13:23:32.856]                             else {
[13:23:32.856]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.856]                                 info, version)
[13:23:32.856]                             }
[13:23:32.856]                             base::stop(msg)
[13:23:32.856]                           }
[13:23:32.856]                         })
[13:23:32.856]                       }
[13:23:32.856]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:32.856]                       base::options(mc.cores = 1L)
[13:23:32.856]                     }
[13:23:32.856]                     base::local({
[13:23:32.856]                       for (pkg in "future") {
[13:23:32.856]                         base::loadNamespace(pkg)
[13:23:32.856]                         base::library(pkg, character.only = TRUE)
[13:23:32.856]                       }
[13:23:32.856]                     })
[13:23:32.856]                   }
[13:23:32.856]                   options(future.plan = NULL)
[13:23:32.856]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.856]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.856]                 }
[13:23:32.856]                 ...future.workdir <- getwd()
[13:23:32.856]             }
[13:23:32.856]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.856]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.856]         }
[13:23:32.856]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.856]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:32.856]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.856]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.856]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.856]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.856]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.856]             base::names(...future.oldOptions))
[13:23:32.856]     }
[13:23:32.856]     if (FALSE) {
[13:23:32.856]     }
[13:23:32.856]     else {
[13:23:32.856]         if (TRUE) {
[13:23:32.856]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.856]                 open = "w")
[13:23:32.856]         }
[13:23:32.856]         else {
[13:23:32.856]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.856]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.856]         }
[13:23:32.856]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.856]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.856]             base::sink(type = "output", split = FALSE)
[13:23:32.856]             base::close(...future.stdout)
[13:23:32.856]         }, add = TRUE)
[13:23:32.856]     }
[13:23:32.856]     ...future.frame <- base::sys.nframe()
[13:23:32.856]     ...future.conditions <- base::list()
[13:23:32.856]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.856]     if (FALSE) {
[13:23:32.856]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.856]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.856]     }
[13:23:32.856]     ...future.result <- base::tryCatch({
[13:23:32.856]         base::withCallingHandlers({
[13:23:32.856]             ...future.value <- base::withVisible(base::local({
[13:23:32.856]                 withCallingHandlers({
[13:23:32.856]                   value(a) + 1
[13:23:32.856]                 }, immediateCondition = function(cond) {
[13:23:32.856]                   save_rds <- function (object, pathname, ...) 
[13:23:32.856]                   {
[13:23:32.856]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:32.856]                     if (file_test("-f", pathname_tmp)) {
[13:23:32.856]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.856]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:32.856]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.856]                         fi_tmp[["mtime"]])
[13:23:32.856]                     }
[13:23:32.856]                     tryCatch({
[13:23:32.856]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:32.856]                     }, error = function(ex) {
[13:23:32.856]                       msg <- conditionMessage(ex)
[13:23:32.856]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.856]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:32.856]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.856]                         fi_tmp[["mtime"]], msg)
[13:23:32.856]                       ex$message <- msg
[13:23:32.856]                       stop(ex)
[13:23:32.856]                     })
[13:23:32.856]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:32.856]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:32.856]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:32.856]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.856]                       fi <- file.info(pathname)
[13:23:32.856]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:32.856]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.856]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:32.856]                         fi[["size"]], fi[["mtime"]])
[13:23:32.856]                       stop(msg)
[13:23:32.856]                     }
[13:23:32.856]                     invisible(pathname)
[13:23:32.856]                   }
[13:23:32.856]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:32.856]                     rootPath = tempdir()) 
[13:23:32.856]                   {
[13:23:32.856]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:32.856]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:32.856]                       tmpdir = path, fileext = ".rds")
[13:23:32.856]                     save_rds(obj, file)
[13:23:32.856]                   }
[13:23:32.856]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:32.856]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.856]                   {
[13:23:32.856]                     inherits <- base::inherits
[13:23:32.856]                     invokeRestart <- base::invokeRestart
[13:23:32.856]                     is.null <- base::is.null
[13:23:32.856]                     muffled <- FALSE
[13:23:32.856]                     if (inherits(cond, "message")) {
[13:23:32.856]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:32.856]                       if (muffled) 
[13:23:32.856]                         invokeRestart("muffleMessage")
[13:23:32.856]                     }
[13:23:32.856]                     else if (inherits(cond, "warning")) {
[13:23:32.856]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:32.856]                       if (muffled) 
[13:23:32.856]                         invokeRestart("muffleWarning")
[13:23:32.856]                     }
[13:23:32.856]                     else if (inherits(cond, "condition")) {
[13:23:32.856]                       if (!is.null(pattern)) {
[13:23:32.856]                         computeRestarts <- base::computeRestarts
[13:23:32.856]                         grepl <- base::grepl
[13:23:32.856]                         restarts <- computeRestarts(cond)
[13:23:32.856]                         for (restart in restarts) {
[13:23:32.856]                           name <- restart$name
[13:23:32.856]                           if (is.null(name)) 
[13:23:32.856]                             next
[13:23:32.856]                           if (!grepl(pattern, name)) 
[13:23:32.856]                             next
[13:23:32.856]                           invokeRestart(restart)
[13:23:32.856]                           muffled <- TRUE
[13:23:32.856]                           break
[13:23:32.856]                         }
[13:23:32.856]                       }
[13:23:32.856]                     }
[13:23:32.856]                     invisible(muffled)
[13:23:32.856]                   }
[13:23:32.856]                   muffleCondition(cond)
[13:23:32.856]                 })
[13:23:32.856]             }))
[13:23:32.856]             future::FutureResult(value = ...future.value$value, 
[13:23:32.856]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.856]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.856]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.856]                     ...future.globalenv.names))
[13:23:32.856]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.856]         }, condition = base::local({
[13:23:32.856]             c <- base::c
[13:23:32.856]             inherits <- base::inherits
[13:23:32.856]             invokeRestart <- base::invokeRestart
[13:23:32.856]             length <- base::length
[13:23:32.856]             list <- base::list
[13:23:32.856]             seq.int <- base::seq.int
[13:23:32.856]             signalCondition <- base::signalCondition
[13:23:32.856]             sys.calls <- base::sys.calls
[13:23:32.856]             `[[` <- base::`[[`
[13:23:32.856]             `+` <- base::`+`
[13:23:32.856]             `<<-` <- base::`<<-`
[13:23:32.856]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.856]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.856]                   3L)]
[13:23:32.856]             }
[13:23:32.856]             function(cond) {
[13:23:32.856]                 is_error <- inherits(cond, "error")
[13:23:32.856]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.856]                   NULL)
[13:23:32.856]                 if (is_error) {
[13:23:32.856]                   sessionInformation <- function() {
[13:23:32.856]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.856]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.856]                       search = base::search(), system = base::Sys.info())
[13:23:32.856]                   }
[13:23:32.856]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.856]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.856]                     cond$call), session = sessionInformation(), 
[13:23:32.856]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.856]                   signalCondition(cond)
[13:23:32.856]                 }
[13:23:32.856]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.856]                 "immediateCondition"))) {
[13:23:32.856]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.856]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.856]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.856]                   if (TRUE && !signal) {
[13:23:32.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.856]                     {
[13:23:32.856]                       inherits <- base::inherits
[13:23:32.856]                       invokeRestart <- base::invokeRestart
[13:23:32.856]                       is.null <- base::is.null
[13:23:32.856]                       muffled <- FALSE
[13:23:32.856]                       if (inherits(cond, "message")) {
[13:23:32.856]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.856]                         if (muffled) 
[13:23:32.856]                           invokeRestart("muffleMessage")
[13:23:32.856]                       }
[13:23:32.856]                       else if (inherits(cond, "warning")) {
[13:23:32.856]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.856]                         if (muffled) 
[13:23:32.856]                           invokeRestart("muffleWarning")
[13:23:32.856]                       }
[13:23:32.856]                       else if (inherits(cond, "condition")) {
[13:23:32.856]                         if (!is.null(pattern)) {
[13:23:32.856]                           computeRestarts <- base::computeRestarts
[13:23:32.856]                           grepl <- base::grepl
[13:23:32.856]                           restarts <- computeRestarts(cond)
[13:23:32.856]                           for (restart in restarts) {
[13:23:32.856]                             name <- restart$name
[13:23:32.856]                             if (is.null(name)) 
[13:23:32.856]                               next
[13:23:32.856]                             if (!grepl(pattern, name)) 
[13:23:32.856]                               next
[13:23:32.856]                             invokeRestart(restart)
[13:23:32.856]                             muffled <- TRUE
[13:23:32.856]                             break
[13:23:32.856]                           }
[13:23:32.856]                         }
[13:23:32.856]                       }
[13:23:32.856]                       invisible(muffled)
[13:23:32.856]                     }
[13:23:32.856]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.856]                   }
[13:23:32.856]                 }
[13:23:32.856]                 else {
[13:23:32.856]                   if (TRUE) {
[13:23:32.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.856]                     {
[13:23:32.856]                       inherits <- base::inherits
[13:23:32.856]                       invokeRestart <- base::invokeRestart
[13:23:32.856]                       is.null <- base::is.null
[13:23:32.856]                       muffled <- FALSE
[13:23:32.856]                       if (inherits(cond, "message")) {
[13:23:32.856]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.856]                         if (muffled) 
[13:23:32.856]                           invokeRestart("muffleMessage")
[13:23:32.856]                       }
[13:23:32.856]                       else if (inherits(cond, "warning")) {
[13:23:32.856]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.856]                         if (muffled) 
[13:23:32.856]                           invokeRestart("muffleWarning")
[13:23:32.856]                       }
[13:23:32.856]                       else if (inherits(cond, "condition")) {
[13:23:32.856]                         if (!is.null(pattern)) {
[13:23:32.856]                           computeRestarts <- base::computeRestarts
[13:23:32.856]                           grepl <- base::grepl
[13:23:32.856]                           restarts <- computeRestarts(cond)
[13:23:32.856]                           for (restart in restarts) {
[13:23:32.856]                             name <- restart$name
[13:23:32.856]                             if (is.null(name)) 
[13:23:32.856]                               next
[13:23:32.856]                             if (!grepl(pattern, name)) 
[13:23:32.856]                               next
[13:23:32.856]                             invokeRestart(restart)
[13:23:32.856]                             muffled <- TRUE
[13:23:32.856]                             break
[13:23:32.856]                           }
[13:23:32.856]                         }
[13:23:32.856]                       }
[13:23:32.856]                       invisible(muffled)
[13:23:32.856]                     }
[13:23:32.856]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.856]                   }
[13:23:32.856]                 }
[13:23:32.856]             }
[13:23:32.856]         }))
[13:23:32.856]     }, error = function(ex) {
[13:23:32.856]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.856]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.856]                 ...future.rng), started = ...future.startTime, 
[13:23:32.856]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.856]             version = "1.8"), class = "FutureResult")
[13:23:32.856]     }, finally = {
[13:23:32.856]         if (!identical(...future.workdir, getwd())) 
[13:23:32.856]             setwd(...future.workdir)
[13:23:32.856]         {
[13:23:32.856]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.856]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.856]             }
[13:23:32.856]             base::options(...future.oldOptions)
[13:23:32.856]             if (.Platform$OS.type == "windows") {
[13:23:32.856]                 old_names <- names(...future.oldEnvVars)
[13:23:32.856]                 envs <- base::Sys.getenv()
[13:23:32.856]                 names <- names(envs)
[13:23:32.856]                 common <- intersect(names, old_names)
[13:23:32.856]                 added <- setdiff(names, old_names)
[13:23:32.856]                 removed <- setdiff(old_names, names)
[13:23:32.856]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.856]                   envs[common]]
[13:23:32.856]                 NAMES <- toupper(changed)
[13:23:32.856]                 args <- list()
[13:23:32.856]                 for (kk in seq_along(NAMES)) {
[13:23:32.856]                   name <- changed[[kk]]
[13:23:32.856]                   NAME <- NAMES[[kk]]
[13:23:32.856]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.856]                     next
[13:23:32.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.856]                 }
[13:23:32.856]                 NAMES <- toupper(added)
[13:23:32.856]                 for (kk in seq_along(NAMES)) {
[13:23:32.856]                   name <- added[[kk]]
[13:23:32.856]                   NAME <- NAMES[[kk]]
[13:23:32.856]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.856]                     next
[13:23:32.856]                   args[[name]] <- ""
[13:23:32.856]                 }
[13:23:32.856]                 NAMES <- toupper(removed)
[13:23:32.856]                 for (kk in seq_along(NAMES)) {
[13:23:32.856]                   name <- removed[[kk]]
[13:23:32.856]                   NAME <- NAMES[[kk]]
[13:23:32.856]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.856]                     next
[13:23:32.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.856]                 }
[13:23:32.856]                 if (length(args) > 0) 
[13:23:32.856]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.856]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.856]             }
[13:23:32.856]             else {
[13:23:32.856]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.856]             }
[13:23:32.856]             {
[13:23:32.856]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.856]                   0L) {
[13:23:32.856]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.856]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.856]                   base::options(opts)
[13:23:32.856]                 }
[13:23:32.856]                 {
[13:23:32.856]                   {
[13:23:32.856]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:32.856]                     NULL
[13:23:32.856]                   }
[13:23:32.856]                   options(future.plan = NULL)
[13:23:32.856]                   if (is.na(NA_character_)) 
[13:23:32.856]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.856]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.856]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:32.856]                     envir = parent.frame()) 
[13:23:32.856]                   {
[13:23:32.856]                     default_workers <- missing(workers)
[13:23:32.856]                     if (is.function(workers)) 
[13:23:32.856]                       workers <- workers()
[13:23:32.856]                     workers <- structure(as.integer(workers), 
[13:23:32.856]                       class = class(workers))
[13:23:32.856]                     stop_if_not(is.finite(workers), workers >= 
[13:23:32.856]                       1L)
[13:23:32.856]                     if ((workers == 1L && !inherits(workers, 
[13:23:32.856]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:32.856]                       if (default_workers) 
[13:23:32.856]                         supportsMulticore(warn = TRUE)
[13:23:32.856]                       return(sequential(..., envir = envir))
[13:23:32.856]                     }
[13:23:32.856]                     oopts <- options(mc.cores = workers)
[13:23:32.856]                     on.exit(options(oopts))
[13:23:32.856]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:32.856]                       envir = envir)
[13:23:32.856]                     if (!future$lazy) 
[13:23:32.856]                       future <- run(future)
[13:23:32.856]                     invisible(future)
[13:23:32.856]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.856]                 }
[13:23:32.856]             }
[13:23:32.856]         }
[13:23:32.856]     })
[13:23:32.856]     if (TRUE) {
[13:23:32.856]         base::sink(type = "output", split = FALSE)
[13:23:32.856]         if (TRUE) {
[13:23:32.856]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.856]         }
[13:23:32.856]         else {
[13:23:32.856]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.856]         }
[13:23:32.856]         base::close(...future.stdout)
[13:23:32.856]         ...future.stdout <- NULL
[13:23:32.856]     }
[13:23:32.856]     ...future.result$conditions <- ...future.conditions
[13:23:32.856]     ...future.result$finished <- base::Sys.time()
[13:23:32.856]     ...future.result
[13:23:32.856] }
[13:23:32.859] assign_globals() ...
[13:23:32.859] List of 1
[13:23:32.859]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5589bf646ca8> 
[13:23:32.859]  - attr(*, "where")=List of 1
[13:23:32.859]   ..$ a:<environment: R_EmptyEnv> 
[13:23:32.859]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.859]  - attr(*, "resolved")= logi TRUE
[13:23:32.859]  - attr(*, "total_size")= num 10816
[13:23:32.859]  - attr(*, "already-done")= logi TRUE
[13:23:32.865] - copied ‘a’ to environment
[13:23:32.865] assign_globals() ... done
[13:23:32.866] requestCore(): workers = 2
[13:23:32.868] MulticoreFuture started
[13:23:32.869] - Launch lazy future ... done
[13:23:32.870] run() for ‘MulticoreFuture’ ... done
[13:23:32.871] plan(): Setting new future strategy stack:
[13:23:32.871] result() for MulticoreFuture ...
[13:23:32.871] List of future strategies:
[13:23:32.871] 1. sequential:
[13:23:32.871]    - args: function (..., envir = parent.frame())
[13:23:32.871]    - tweaked: FALSE
[13:23:32.871]    - call: NULL
[13:23:32.873] plan(): nbrOfWorkers() = 1
[13:23:32.877] plan(): Setting new future strategy stack:
[13:23:32.877] List of future strategies:
[13:23:32.877] 1. multicore:
[13:23:32.877]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:32.877]    - tweaked: FALSE
[13:23:32.877]    - call: plan(strategy)
[13:23:32.883] plan(): nbrOfWorkers() = 2
[13:23:32.885] result() for MulticoreFuture ...
[13:23:32.885] result() for MulticoreFuture ... done
[13:23:32.885] signalConditions() ...
[13:23:32.886]  - include = ‘immediateCondition’
[13:23:32.886]  - exclude = 
[13:23:32.886]  - resignal = FALSE
[13:23:32.886]  - Number of conditions: 4
[13:23:32.886] signalConditions() ... done
[13:23:32.887] result() for MulticoreFuture ... done
[13:23:32.887] result() for MulticoreFuture ...
[13:23:32.887] result() for MulticoreFuture ... done
[13:23:32.887] signalConditions() ...
[13:23:32.887]  - include = ‘immediateCondition’
[13:23:32.888]  - exclude = 
[13:23:32.888]  - resignal = FALSE
[13:23:32.888]  - Number of conditions: 4
[13:23:32.888] signalConditions() ... done
[13:23:32.888] Future state: ‘finished’
[13:23:32.889] result() for MulticoreFuture ...
[13:23:32.889] result() for MulticoreFuture ... done
[13:23:32.889] signalConditions() ...
[13:23:32.889]  - include = ‘condition’
[13:23:32.889]  - exclude = ‘immediateCondition’
[13:23:32.889]  - resignal = TRUE
[13:23:32.889]  - Number of conditions: 4
[13:23:32.889]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:32.875] result() for MulticoreFuture ...
[13:23:32.890]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:32.875] result() for MulticoreFuture ... done
[13:23:32.890]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:32.875] result() for MulticoreFuture ...
[13:23:32.890]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:32.876] result() for MulticoreFuture ... done
[13:23:32.890] signalConditions() ... done
value(b) = 2
[13:23:32.891] result() for MulticoreFuture ...
[13:23:32.891] result() for MulticoreFuture ... done
[13:23:32.891] result() for MulticoreFuture ...
[13:23:32.891] result() for MulticoreFuture ... done
[13:23:32.891] signalConditions() ...
[13:23:32.891]  - include = ‘immediateCondition’
[13:23:32.891]  - exclude = 
[13:23:32.891]  - resignal = FALSE
[13:23:32.891]  - Number of conditions: 4
[13:23:32.892] signalConditions() ... done
[13:23:32.892] Future state: ‘finished’
[13:23:32.892] result() for MulticoreFuture ...
[13:23:32.892] result() for MulticoreFuture ... done
[13:23:32.892] signalConditions() ...
[13:23:32.892]  - include = ‘condition’
[13:23:32.892]  - exclude = ‘immediateCondition’
[13:23:32.892]  - resignal = TRUE
[13:23:32.893]  - Number of conditions: 4
[13:23:32.893]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:32.875] result() for MulticoreFuture ...
[13:23:32.893]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:32.875] result() for MulticoreFuture ... done
[13:23:32.893]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:32.875] result() for MulticoreFuture ...
[13:23:32.893]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:32.876] result() for MulticoreFuture ... done
[13:23:32.893] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.894] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.894] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:32.895] 
[13:23:32.895] Searching for globals ... DONE
[13:23:32.895] - globals: [0] <none>
[13:23:32.895] getGlobalsAndPackages() ... DONE
[13:23:32.895] run() for ‘Future’ ...
[13:23:32.895] - state: ‘created’
[13:23:32.896] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:32.900] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:32.900] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:32.900]   - Field: ‘label’
[13:23:32.901]   - Field: ‘local’
[13:23:32.901]   - Field: ‘owner’
[13:23:32.901]   - Field: ‘envir’
[13:23:32.901]   - Field: ‘workers’
[13:23:32.901]   - Field: ‘packages’
[13:23:32.901]   - Field: ‘gc’
[13:23:32.901]   - Field: ‘job’
[13:23:32.901]   - Field: ‘conditions’
[13:23:32.902]   - Field: ‘expr’
[13:23:32.902]   - Field: ‘uuid’
[13:23:32.902]   - Field: ‘seed’
[13:23:32.902]   - Field: ‘version’
[13:23:32.902]   - Field: ‘result’
[13:23:32.902]   - Field: ‘asynchronous’
[13:23:32.902]   - Field: ‘calls’
[13:23:32.902]   - Field: ‘globals’
[13:23:32.902]   - Field: ‘stdout’
[13:23:32.903]   - Field: ‘earlySignal’
[13:23:32.903]   - Field: ‘lazy’
[13:23:32.903]   - Field: ‘state’
[13:23:32.903] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:32.903] - Launch lazy future ...
[13:23:32.903] Packages needed by the future expression (n = 0): <none>
[13:23:32.904] Packages needed by future strategies (n = 0): <none>
[13:23:32.904] {
[13:23:32.904]     {
[13:23:32.904]         {
[13:23:32.904]             ...future.startTime <- base::Sys.time()
[13:23:32.904]             {
[13:23:32.904]                 {
[13:23:32.904]                   {
[13:23:32.904]                     {
[13:23:32.904]                       base::local({
[13:23:32.904]                         has_future <- base::requireNamespace("future", 
[13:23:32.904]                           quietly = TRUE)
[13:23:32.904]                         if (has_future) {
[13:23:32.904]                           ns <- base::getNamespace("future")
[13:23:32.904]                           version <- ns[[".package"]][["version"]]
[13:23:32.904]                           if (is.null(version)) 
[13:23:32.904]                             version <- utils::packageVersion("future")
[13:23:32.904]                         }
[13:23:32.904]                         else {
[13:23:32.904]                           version <- NULL
[13:23:32.904]                         }
[13:23:32.904]                         if (!has_future || version < "1.8.0") {
[13:23:32.904]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.904]                             "", base::R.version$version.string), 
[13:23:32.904]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:32.904]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.904]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.904]                               "release", "version")], collapse = " "), 
[13:23:32.904]                             hostname = base::Sys.info()[["nodename"]])
[13:23:32.904]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.904]                             info)
[13:23:32.904]                           info <- base::paste(info, collapse = "; ")
[13:23:32.904]                           if (!has_future) {
[13:23:32.904]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.904]                               info)
[13:23:32.904]                           }
[13:23:32.904]                           else {
[13:23:32.904]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.904]                               info, version)
[13:23:32.904]                           }
[13:23:32.904]                           base::stop(msg)
[13:23:32.904]                         }
[13:23:32.904]                       })
[13:23:32.904]                     }
[13:23:32.904]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:32.904]                     base::options(mc.cores = 1L)
[13:23:32.904]                   }
[13:23:32.904]                   options(future.plan = NULL)
[13:23:32.904]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.904]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.904]                 }
[13:23:32.904]                 ...future.workdir <- getwd()
[13:23:32.904]             }
[13:23:32.904]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.904]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.904]         }
[13:23:32.904]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.904]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:32.904]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.904]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.904]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.904]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.904]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.904]             base::names(...future.oldOptions))
[13:23:32.904]     }
[13:23:32.904]     if (FALSE) {
[13:23:32.904]     }
[13:23:32.904]     else {
[13:23:32.904]         if (TRUE) {
[13:23:32.904]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.904]                 open = "w")
[13:23:32.904]         }
[13:23:32.904]         else {
[13:23:32.904]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.904]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.904]         }
[13:23:32.904]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.904]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.904]             base::sink(type = "output", split = FALSE)
[13:23:32.904]             base::close(...future.stdout)
[13:23:32.904]         }, add = TRUE)
[13:23:32.904]     }
[13:23:32.904]     ...future.frame <- base::sys.nframe()
[13:23:32.904]     ...future.conditions <- base::list()
[13:23:32.904]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.904]     if (FALSE) {
[13:23:32.904]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.904]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.904]     }
[13:23:32.904]     ...future.result <- base::tryCatch({
[13:23:32.904]         base::withCallingHandlers({
[13:23:32.904]             ...future.value <- base::withVisible(base::local({
[13:23:32.904]                 withCallingHandlers({
[13:23:32.904]                   1
[13:23:32.904]                 }, immediateCondition = function(cond) {
[13:23:32.904]                   save_rds <- function (object, pathname, ...) 
[13:23:32.904]                   {
[13:23:32.904]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:32.904]                     if (file_test("-f", pathname_tmp)) {
[13:23:32.904]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.904]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:32.904]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.904]                         fi_tmp[["mtime"]])
[13:23:32.904]                     }
[13:23:32.904]                     tryCatch({
[13:23:32.904]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:32.904]                     }, error = function(ex) {
[13:23:32.904]                       msg <- conditionMessage(ex)
[13:23:32.904]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.904]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:32.904]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.904]                         fi_tmp[["mtime"]], msg)
[13:23:32.904]                       ex$message <- msg
[13:23:32.904]                       stop(ex)
[13:23:32.904]                     })
[13:23:32.904]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:32.904]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:32.904]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:32.904]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.904]                       fi <- file.info(pathname)
[13:23:32.904]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:32.904]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.904]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:32.904]                         fi[["size"]], fi[["mtime"]])
[13:23:32.904]                       stop(msg)
[13:23:32.904]                     }
[13:23:32.904]                     invisible(pathname)
[13:23:32.904]                   }
[13:23:32.904]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:32.904]                     rootPath = tempdir()) 
[13:23:32.904]                   {
[13:23:32.904]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:32.904]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:32.904]                       tmpdir = path, fileext = ".rds")
[13:23:32.904]                     save_rds(obj, file)
[13:23:32.904]                   }
[13:23:32.904]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:32.904]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.904]                   {
[13:23:32.904]                     inherits <- base::inherits
[13:23:32.904]                     invokeRestart <- base::invokeRestart
[13:23:32.904]                     is.null <- base::is.null
[13:23:32.904]                     muffled <- FALSE
[13:23:32.904]                     if (inherits(cond, "message")) {
[13:23:32.904]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:32.904]                       if (muffled) 
[13:23:32.904]                         invokeRestart("muffleMessage")
[13:23:32.904]                     }
[13:23:32.904]                     else if (inherits(cond, "warning")) {
[13:23:32.904]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:32.904]                       if (muffled) 
[13:23:32.904]                         invokeRestart("muffleWarning")
[13:23:32.904]                     }
[13:23:32.904]                     else if (inherits(cond, "condition")) {
[13:23:32.904]                       if (!is.null(pattern)) {
[13:23:32.904]                         computeRestarts <- base::computeRestarts
[13:23:32.904]                         grepl <- base::grepl
[13:23:32.904]                         restarts <- computeRestarts(cond)
[13:23:32.904]                         for (restart in restarts) {
[13:23:32.904]                           name <- restart$name
[13:23:32.904]                           if (is.null(name)) 
[13:23:32.904]                             next
[13:23:32.904]                           if (!grepl(pattern, name)) 
[13:23:32.904]                             next
[13:23:32.904]                           invokeRestart(restart)
[13:23:32.904]                           muffled <- TRUE
[13:23:32.904]                           break
[13:23:32.904]                         }
[13:23:32.904]                       }
[13:23:32.904]                     }
[13:23:32.904]                     invisible(muffled)
[13:23:32.904]                   }
[13:23:32.904]                   muffleCondition(cond)
[13:23:32.904]                 })
[13:23:32.904]             }))
[13:23:32.904]             future::FutureResult(value = ...future.value$value, 
[13:23:32.904]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.904]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.904]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.904]                     ...future.globalenv.names))
[13:23:32.904]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.904]         }, condition = base::local({
[13:23:32.904]             c <- base::c
[13:23:32.904]             inherits <- base::inherits
[13:23:32.904]             invokeRestart <- base::invokeRestart
[13:23:32.904]             length <- base::length
[13:23:32.904]             list <- base::list
[13:23:32.904]             seq.int <- base::seq.int
[13:23:32.904]             signalCondition <- base::signalCondition
[13:23:32.904]             sys.calls <- base::sys.calls
[13:23:32.904]             `[[` <- base::`[[`
[13:23:32.904]             `+` <- base::`+`
[13:23:32.904]             `<<-` <- base::`<<-`
[13:23:32.904]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.904]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.904]                   3L)]
[13:23:32.904]             }
[13:23:32.904]             function(cond) {
[13:23:32.904]                 is_error <- inherits(cond, "error")
[13:23:32.904]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.904]                   NULL)
[13:23:32.904]                 if (is_error) {
[13:23:32.904]                   sessionInformation <- function() {
[13:23:32.904]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.904]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.904]                       search = base::search(), system = base::Sys.info())
[13:23:32.904]                   }
[13:23:32.904]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.904]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.904]                     cond$call), session = sessionInformation(), 
[13:23:32.904]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.904]                   signalCondition(cond)
[13:23:32.904]                 }
[13:23:32.904]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.904]                 "immediateCondition"))) {
[13:23:32.904]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.904]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.904]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.904]                   if (TRUE && !signal) {
[13:23:32.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.904]                     {
[13:23:32.904]                       inherits <- base::inherits
[13:23:32.904]                       invokeRestart <- base::invokeRestart
[13:23:32.904]                       is.null <- base::is.null
[13:23:32.904]                       muffled <- FALSE
[13:23:32.904]                       if (inherits(cond, "message")) {
[13:23:32.904]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.904]                         if (muffled) 
[13:23:32.904]                           invokeRestart("muffleMessage")
[13:23:32.904]                       }
[13:23:32.904]                       else if (inherits(cond, "warning")) {
[13:23:32.904]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.904]                         if (muffled) 
[13:23:32.904]                           invokeRestart("muffleWarning")
[13:23:32.904]                       }
[13:23:32.904]                       else if (inherits(cond, "condition")) {
[13:23:32.904]                         if (!is.null(pattern)) {
[13:23:32.904]                           computeRestarts <- base::computeRestarts
[13:23:32.904]                           grepl <- base::grepl
[13:23:32.904]                           restarts <- computeRestarts(cond)
[13:23:32.904]                           for (restart in restarts) {
[13:23:32.904]                             name <- restart$name
[13:23:32.904]                             if (is.null(name)) 
[13:23:32.904]                               next
[13:23:32.904]                             if (!grepl(pattern, name)) 
[13:23:32.904]                               next
[13:23:32.904]                             invokeRestart(restart)
[13:23:32.904]                             muffled <- TRUE
[13:23:32.904]                             break
[13:23:32.904]                           }
[13:23:32.904]                         }
[13:23:32.904]                       }
[13:23:32.904]                       invisible(muffled)
[13:23:32.904]                     }
[13:23:32.904]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.904]                   }
[13:23:32.904]                 }
[13:23:32.904]                 else {
[13:23:32.904]                   if (TRUE) {
[13:23:32.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.904]                     {
[13:23:32.904]                       inherits <- base::inherits
[13:23:32.904]                       invokeRestart <- base::invokeRestart
[13:23:32.904]                       is.null <- base::is.null
[13:23:32.904]                       muffled <- FALSE
[13:23:32.904]                       if (inherits(cond, "message")) {
[13:23:32.904]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.904]                         if (muffled) 
[13:23:32.904]                           invokeRestart("muffleMessage")
[13:23:32.904]                       }
[13:23:32.904]                       else if (inherits(cond, "warning")) {
[13:23:32.904]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.904]                         if (muffled) 
[13:23:32.904]                           invokeRestart("muffleWarning")
[13:23:32.904]                       }
[13:23:32.904]                       else if (inherits(cond, "condition")) {
[13:23:32.904]                         if (!is.null(pattern)) {
[13:23:32.904]                           computeRestarts <- base::computeRestarts
[13:23:32.904]                           grepl <- base::grepl
[13:23:32.904]                           restarts <- computeRestarts(cond)
[13:23:32.904]                           for (restart in restarts) {
[13:23:32.904]                             name <- restart$name
[13:23:32.904]                             if (is.null(name)) 
[13:23:32.904]                               next
[13:23:32.904]                             if (!grepl(pattern, name)) 
[13:23:32.904]                               next
[13:23:32.904]                             invokeRestart(restart)
[13:23:32.904]                             muffled <- TRUE
[13:23:32.904]                             break
[13:23:32.904]                           }
[13:23:32.904]                         }
[13:23:32.904]                       }
[13:23:32.904]                       invisible(muffled)
[13:23:32.904]                     }
[13:23:32.904]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.904]                   }
[13:23:32.904]                 }
[13:23:32.904]             }
[13:23:32.904]         }))
[13:23:32.904]     }, error = function(ex) {
[13:23:32.904]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.904]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.904]                 ...future.rng), started = ...future.startTime, 
[13:23:32.904]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.904]             version = "1.8"), class = "FutureResult")
[13:23:32.904]     }, finally = {
[13:23:32.904]         if (!identical(...future.workdir, getwd())) 
[13:23:32.904]             setwd(...future.workdir)
[13:23:32.904]         {
[13:23:32.904]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.904]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.904]             }
[13:23:32.904]             base::options(...future.oldOptions)
[13:23:32.904]             if (.Platform$OS.type == "windows") {
[13:23:32.904]                 old_names <- names(...future.oldEnvVars)
[13:23:32.904]                 envs <- base::Sys.getenv()
[13:23:32.904]                 names <- names(envs)
[13:23:32.904]                 common <- intersect(names, old_names)
[13:23:32.904]                 added <- setdiff(names, old_names)
[13:23:32.904]                 removed <- setdiff(old_names, names)
[13:23:32.904]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.904]                   envs[common]]
[13:23:32.904]                 NAMES <- toupper(changed)
[13:23:32.904]                 args <- list()
[13:23:32.904]                 for (kk in seq_along(NAMES)) {
[13:23:32.904]                   name <- changed[[kk]]
[13:23:32.904]                   NAME <- NAMES[[kk]]
[13:23:32.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.904]                     next
[13:23:32.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.904]                 }
[13:23:32.904]                 NAMES <- toupper(added)
[13:23:32.904]                 for (kk in seq_along(NAMES)) {
[13:23:32.904]                   name <- added[[kk]]
[13:23:32.904]                   NAME <- NAMES[[kk]]
[13:23:32.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.904]                     next
[13:23:32.904]                   args[[name]] <- ""
[13:23:32.904]                 }
[13:23:32.904]                 NAMES <- toupper(removed)
[13:23:32.904]                 for (kk in seq_along(NAMES)) {
[13:23:32.904]                   name <- removed[[kk]]
[13:23:32.904]                   NAME <- NAMES[[kk]]
[13:23:32.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.904]                     next
[13:23:32.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.904]                 }
[13:23:32.904]                 if (length(args) > 0) 
[13:23:32.904]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.904]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.904]             }
[13:23:32.904]             else {
[13:23:32.904]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.904]             }
[13:23:32.904]             {
[13:23:32.904]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.904]                   0L) {
[13:23:32.904]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.904]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.904]                   base::options(opts)
[13:23:32.904]                 }
[13:23:32.904]                 {
[13:23:32.904]                   {
[13:23:32.904]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:32.904]                     NULL
[13:23:32.904]                   }
[13:23:32.904]                   options(future.plan = NULL)
[13:23:32.904]                   if (is.na(NA_character_)) 
[13:23:32.904]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.904]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.904]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:32.904]                     envir = parent.frame()) 
[13:23:32.904]                   {
[13:23:32.904]                     default_workers <- missing(workers)
[13:23:32.904]                     if (is.function(workers)) 
[13:23:32.904]                       workers <- workers()
[13:23:32.904]                     workers <- structure(as.integer(workers), 
[13:23:32.904]                       class = class(workers))
[13:23:32.904]                     stop_if_not(is.finite(workers), workers >= 
[13:23:32.904]                       1L)
[13:23:32.904]                     if ((workers == 1L && !inherits(workers, 
[13:23:32.904]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:32.904]                       if (default_workers) 
[13:23:32.904]                         supportsMulticore(warn = TRUE)
[13:23:32.904]                       return(sequential(..., envir = envir))
[13:23:32.904]                     }
[13:23:32.904]                     oopts <- options(mc.cores = workers)
[13:23:32.904]                     on.exit(options(oopts))
[13:23:32.904]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:32.904]                       envir = envir)
[13:23:32.904]                     if (!future$lazy) 
[13:23:32.904]                       future <- run(future)
[13:23:32.904]                     invisible(future)
[13:23:32.904]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.904]                 }
[13:23:32.904]             }
[13:23:32.904]         }
[13:23:32.904]     })
[13:23:32.904]     if (TRUE) {
[13:23:32.904]         base::sink(type = "output", split = FALSE)
[13:23:32.904]         if (TRUE) {
[13:23:32.904]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.904]         }
[13:23:32.904]         else {
[13:23:32.904]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.904]         }
[13:23:32.904]         base::close(...future.stdout)
[13:23:32.904]         ...future.stdout <- NULL
[13:23:32.904]     }
[13:23:32.904]     ...future.result$conditions <- ...future.conditions
[13:23:32.904]     ...future.result$finished <- base::Sys.time()
[13:23:32.904]     ...future.result
[13:23:32.904] }
[13:23:32.907] requestCore(): workers = 2
[13:23:32.909] MulticoreFuture started
[13:23:32.910] - Launch lazy future ... done
[13:23:32.910] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.911] getGlobalsAndPackages() ...
[13:23:32.911] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.911] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:32.911] List of future strategies:
[13:23:32.911] 1. sequential:
[13:23:32.911]    - args: function (..., envir = parent.frame())
[13:23:32.911]    - tweaked: FALSE
[13:23:32.911]    - call: NULL
[13:23:32.912] plan(): nbrOfWorkers() = 1
[13:23:32.913] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:32.913] Searching for globals ... DONE
[13:23:32.913] Resolving globals: TRUE
[13:23:32.914] Resolving any globals that are futures ...
[13:23:32.914] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:32.914] Resolving any globals that are futures ... DONE
[13:23:32.914] plan(): Setting new future strategy stack:
[13:23:32.915] Resolving futures part of globals (recursively) ...
[13:23:32.914] List of future strategies:
[13:23:32.914] 1. multicore:
[13:23:32.914]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:32.914]    - tweaked: FALSE
[13:23:32.914]    - call: plan(strategy)
[13:23:32.915] resolve() on list ...
[13:23:32.915]  recursive: 99
[13:23:32.915]  length: 1
[13:23:32.916]  elements: ‘a’
[13:23:32.919] plan(): nbrOfWorkers() = 2
[13:23:32.920] Future #1
[13:23:32.920] result() for MulticoreFuture ...
[13:23:32.921] result() for MulticoreFuture ...
[13:23:32.925] result() for MulticoreFuture ... done
[13:23:32.925] result() for MulticoreFuture ... done
[13:23:32.925] result() for MulticoreFuture ...
[13:23:32.925] result() for MulticoreFuture ... done
[13:23:32.926] A MulticoreFuture was resolved
[13:23:32.926]  length: 0 (resolved future 1)
[13:23:32.926] resolve() on list ... DONE
[13:23:32.926] - globals: [1] ‘a’
[13:23:32.927] Resolving futures part of globals (recursively) ... DONE
[13:23:32.928] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[13:23:32.929] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[13:23:32.929] - globals: [1] ‘a’
[13:23:32.929] - packages: [1] ‘future’
[13:23:32.930] getGlobalsAndPackages() ... DONE
[13:23:32.930] run() for ‘Future’ ...
[13:23:32.930] - state: ‘created’
[13:23:32.930] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:32.935] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:32.935] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:32.936]   - Field: ‘label’
[13:23:32.936]   - Field: ‘local’
[13:23:32.936]   - Field: ‘owner’
[13:23:32.936]   - Field: ‘envir’
[13:23:32.936]   - Field: ‘workers’
[13:23:32.936]   - Field: ‘packages’
[13:23:32.936]   - Field: ‘gc’
[13:23:32.937]   - Field: ‘job’
[13:23:32.937]   - Field: ‘conditions’
[13:23:32.937]   - Field: ‘expr’
[13:23:32.937]   - Field: ‘uuid’
[13:23:32.937]   - Field: ‘seed’
[13:23:32.937]   - Field: ‘version’
[13:23:32.937]   - Field: ‘result’
[13:23:32.937]   - Field: ‘asynchronous’
[13:23:32.938]   - Field: ‘calls’
[13:23:32.938]   - Field: ‘globals’
[13:23:32.938]   - Field: ‘stdout’
[13:23:32.938]   - Field: ‘earlySignal’
[13:23:32.938]   - Field: ‘lazy’
[13:23:32.938]   - Field: ‘state’
[13:23:32.938] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:32.938] - Launch lazy future ...
[13:23:32.939] Packages needed by the future expression (n = 1): ‘future’
[13:23:32.939] Packages needed by future strategies (n = 0): <none>
[13:23:32.939] {
[13:23:32.939]     {
[13:23:32.939]         {
[13:23:32.939]             ...future.startTime <- base::Sys.time()
[13:23:32.939]             {
[13:23:32.939]                 {
[13:23:32.939]                   {
[13:23:32.939]                     {
[13:23:32.939]                       {
[13:23:32.939]                         base::local({
[13:23:32.939]                           has_future <- base::requireNamespace("future", 
[13:23:32.939]                             quietly = TRUE)
[13:23:32.939]                           if (has_future) {
[13:23:32.939]                             ns <- base::getNamespace("future")
[13:23:32.939]                             version <- ns[[".package"]][["version"]]
[13:23:32.939]                             if (is.null(version)) 
[13:23:32.939]                               version <- utils::packageVersion("future")
[13:23:32.939]                           }
[13:23:32.939]                           else {
[13:23:32.939]                             version <- NULL
[13:23:32.939]                           }
[13:23:32.939]                           if (!has_future || version < "1.8.0") {
[13:23:32.939]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.939]                               "", base::R.version$version.string), 
[13:23:32.939]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:32.939]                                 base::R.version$platform, 8 * 
[13:23:32.939]                                   base::.Machine$sizeof.pointer), 
[13:23:32.939]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.939]                                 "release", "version")], collapse = " "), 
[13:23:32.939]                               hostname = base::Sys.info()[["nodename"]])
[13:23:32.939]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.939]                               info)
[13:23:32.939]                             info <- base::paste(info, collapse = "; ")
[13:23:32.939]                             if (!has_future) {
[13:23:32.939]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.939]                                 info)
[13:23:32.939]                             }
[13:23:32.939]                             else {
[13:23:32.939]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.939]                                 info, version)
[13:23:32.939]                             }
[13:23:32.939]                             base::stop(msg)
[13:23:32.939]                           }
[13:23:32.939]                         })
[13:23:32.939]                       }
[13:23:32.939]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:32.939]                       base::options(mc.cores = 1L)
[13:23:32.939]                     }
[13:23:32.939]                     base::local({
[13:23:32.939]                       for (pkg in "future") {
[13:23:32.939]                         base::loadNamespace(pkg)
[13:23:32.939]                         base::library(pkg, character.only = TRUE)
[13:23:32.939]                       }
[13:23:32.939]                     })
[13:23:32.939]                   }
[13:23:32.939]                   options(future.plan = NULL)
[13:23:32.939]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.939]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.939]                 }
[13:23:32.939]                 ...future.workdir <- getwd()
[13:23:32.939]             }
[13:23:32.939]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.939]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.939]         }
[13:23:32.939]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.939]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:32.939]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.939]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.939]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.939]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.939]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.939]             base::names(...future.oldOptions))
[13:23:32.939]     }
[13:23:32.939]     if (FALSE) {
[13:23:32.939]     }
[13:23:32.939]     else {
[13:23:32.939]         if (TRUE) {
[13:23:32.939]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.939]                 open = "w")
[13:23:32.939]         }
[13:23:32.939]         else {
[13:23:32.939]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.939]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.939]         }
[13:23:32.939]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.939]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.939]             base::sink(type = "output", split = FALSE)
[13:23:32.939]             base::close(...future.stdout)
[13:23:32.939]         }, add = TRUE)
[13:23:32.939]     }
[13:23:32.939]     ...future.frame <- base::sys.nframe()
[13:23:32.939]     ...future.conditions <- base::list()
[13:23:32.939]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.939]     if (FALSE) {
[13:23:32.939]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.939]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.939]     }
[13:23:32.939]     ...future.result <- base::tryCatch({
[13:23:32.939]         base::withCallingHandlers({
[13:23:32.939]             ...future.value <- base::withVisible(base::local({
[13:23:32.939]                 withCallingHandlers({
[13:23:32.939]                   value(a) + 1
[13:23:32.939]                 }, immediateCondition = function(cond) {
[13:23:32.939]                   save_rds <- function (object, pathname, ...) 
[13:23:32.939]                   {
[13:23:32.939]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:32.939]                     if (file_test("-f", pathname_tmp)) {
[13:23:32.939]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.939]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:32.939]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.939]                         fi_tmp[["mtime"]])
[13:23:32.939]                     }
[13:23:32.939]                     tryCatch({
[13:23:32.939]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:32.939]                     }, error = function(ex) {
[13:23:32.939]                       msg <- conditionMessage(ex)
[13:23:32.939]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.939]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:32.939]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.939]                         fi_tmp[["mtime"]], msg)
[13:23:32.939]                       ex$message <- msg
[13:23:32.939]                       stop(ex)
[13:23:32.939]                     })
[13:23:32.939]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:32.939]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:32.939]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:32.939]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.939]                       fi <- file.info(pathname)
[13:23:32.939]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:32.939]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.939]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:32.939]                         fi[["size"]], fi[["mtime"]])
[13:23:32.939]                       stop(msg)
[13:23:32.939]                     }
[13:23:32.939]                     invisible(pathname)
[13:23:32.939]                   }
[13:23:32.939]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:32.939]                     rootPath = tempdir()) 
[13:23:32.939]                   {
[13:23:32.939]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:32.939]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:32.939]                       tmpdir = path, fileext = ".rds")
[13:23:32.939]                     save_rds(obj, file)
[13:23:32.939]                   }
[13:23:32.939]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:32.939]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.939]                   {
[13:23:32.939]                     inherits <- base::inherits
[13:23:32.939]                     invokeRestart <- base::invokeRestart
[13:23:32.939]                     is.null <- base::is.null
[13:23:32.939]                     muffled <- FALSE
[13:23:32.939]                     if (inherits(cond, "message")) {
[13:23:32.939]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:32.939]                       if (muffled) 
[13:23:32.939]                         invokeRestart("muffleMessage")
[13:23:32.939]                     }
[13:23:32.939]                     else if (inherits(cond, "warning")) {
[13:23:32.939]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:32.939]                       if (muffled) 
[13:23:32.939]                         invokeRestart("muffleWarning")
[13:23:32.939]                     }
[13:23:32.939]                     else if (inherits(cond, "condition")) {
[13:23:32.939]                       if (!is.null(pattern)) {
[13:23:32.939]                         computeRestarts <- base::computeRestarts
[13:23:32.939]                         grepl <- base::grepl
[13:23:32.939]                         restarts <- computeRestarts(cond)
[13:23:32.939]                         for (restart in restarts) {
[13:23:32.939]                           name <- restart$name
[13:23:32.939]                           if (is.null(name)) 
[13:23:32.939]                             next
[13:23:32.939]                           if (!grepl(pattern, name)) 
[13:23:32.939]                             next
[13:23:32.939]                           invokeRestart(restart)
[13:23:32.939]                           muffled <- TRUE
[13:23:32.939]                           break
[13:23:32.939]                         }
[13:23:32.939]                       }
[13:23:32.939]                     }
[13:23:32.939]                     invisible(muffled)
[13:23:32.939]                   }
[13:23:32.939]                   muffleCondition(cond)
[13:23:32.939]                 })
[13:23:32.939]             }))
[13:23:32.939]             future::FutureResult(value = ...future.value$value, 
[13:23:32.939]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.939]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.939]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.939]                     ...future.globalenv.names))
[13:23:32.939]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.939]         }, condition = base::local({
[13:23:32.939]             c <- base::c
[13:23:32.939]             inherits <- base::inherits
[13:23:32.939]             invokeRestart <- base::invokeRestart
[13:23:32.939]             length <- base::length
[13:23:32.939]             list <- base::list
[13:23:32.939]             seq.int <- base::seq.int
[13:23:32.939]             signalCondition <- base::signalCondition
[13:23:32.939]             sys.calls <- base::sys.calls
[13:23:32.939]             `[[` <- base::`[[`
[13:23:32.939]             `+` <- base::`+`
[13:23:32.939]             `<<-` <- base::`<<-`
[13:23:32.939]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.939]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.939]                   3L)]
[13:23:32.939]             }
[13:23:32.939]             function(cond) {
[13:23:32.939]                 is_error <- inherits(cond, "error")
[13:23:32.939]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.939]                   NULL)
[13:23:32.939]                 if (is_error) {
[13:23:32.939]                   sessionInformation <- function() {
[13:23:32.939]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.939]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.939]                       search = base::search(), system = base::Sys.info())
[13:23:32.939]                   }
[13:23:32.939]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.939]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.939]                     cond$call), session = sessionInformation(), 
[13:23:32.939]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.939]                   signalCondition(cond)
[13:23:32.939]                 }
[13:23:32.939]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.939]                 "immediateCondition"))) {
[13:23:32.939]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.939]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.939]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.939]                   if (TRUE && !signal) {
[13:23:32.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.939]                     {
[13:23:32.939]                       inherits <- base::inherits
[13:23:32.939]                       invokeRestart <- base::invokeRestart
[13:23:32.939]                       is.null <- base::is.null
[13:23:32.939]                       muffled <- FALSE
[13:23:32.939]                       if (inherits(cond, "message")) {
[13:23:32.939]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.939]                         if (muffled) 
[13:23:32.939]                           invokeRestart("muffleMessage")
[13:23:32.939]                       }
[13:23:32.939]                       else if (inherits(cond, "warning")) {
[13:23:32.939]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.939]                         if (muffled) 
[13:23:32.939]                           invokeRestart("muffleWarning")
[13:23:32.939]                       }
[13:23:32.939]                       else if (inherits(cond, "condition")) {
[13:23:32.939]                         if (!is.null(pattern)) {
[13:23:32.939]                           computeRestarts <- base::computeRestarts
[13:23:32.939]                           grepl <- base::grepl
[13:23:32.939]                           restarts <- computeRestarts(cond)
[13:23:32.939]                           for (restart in restarts) {
[13:23:32.939]                             name <- restart$name
[13:23:32.939]                             if (is.null(name)) 
[13:23:32.939]                               next
[13:23:32.939]                             if (!grepl(pattern, name)) 
[13:23:32.939]                               next
[13:23:32.939]                             invokeRestart(restart)
[13:23:32.939]                             muffled <- TRUE
[13:23:32.939]                             break
[13:23:32.939]                           }
[13:23:32.939]                         }
[13:23:32.939]                       }
[13:23:32.939]                       invisible(muffled)
[13:23:32.939]                     }
[13:23:32.939]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.939]                   }
[13:23:32.939]                 }
[13:23:32.939]                 else {
[13:23:32.939]                   if (TRUE) {
[13:23:32.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.939]                     {
[13:23:32.939]                       inherits <- base::inherits
[13:23:32.939]                       invokeRestart <- base::invokeRestart
[13:23:32.939]                       is.null <- base::is.null
[13:23:32.939]                       muffled <- FALSE
[13:23:32.939]                       if (inherits(cond, "message")) {
[13:23:32.939]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.939]                         if (muffled) 
[13:23:32.939]                           invokeRestart("muffleMessage")
[13:23:32.939]                       }
[13:23:32.939]                       else if (inherits(cond, "warning")) {
[13:23:32.939]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.939]                         if (muffled) 
[13:23:32.939]                           invokeRestart("muffleWarning")
[13:23:32.939]                       }
[13:23:32.939]                       else if (inherits(cond, "condition")) {
[13:23:32.939]                         if (!is.null(pattern)) {
[13:23:32.939]                           computeRestarts <- base::computeRestarts
[13:23:32.939]                           grepl <- base::grepl
[13:23:32.939]                           restarts <- computeRestarts(cond)
[13:23:32.939]                           for (restart in restarts) {
[13:23:32.939]                             name <- restart$name
[13:23:32.939]                             if (is.null(name)) 
[13:23:32.939]                               next
[13:23:32.939]                             if (!grepl(pattern, name)) 
[13:23:32.939]                               next
[13:23:32.939]                             invokeRestart(restart)
[13:23:32.939]                             muffled <- TRUE
[13:23:32.939]                             break
[13:23:32.939]                           }
[13:23:32.939]                         }
[13:23:32.939]                       }
[13:23:32.939]                       invisible(muffled)
[13:23:32.939]                     }
[13:23:32.939]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.939]                   }
[13:23:32.939]                 }
[13:23:32.939]             }
[13:23:32.939]         }))
[13:23:32.939]     }, error = function(ex) {
[13:23:32.939]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.939]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.939]                 ...future.rng), started = ...future.startTime, 
[13:23:32.939]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.939]             version = "1.8"), class = "FutureResult")
[13:23:32.939]     }, finally = {
[13:23:32.939]         if (!identical(...future.workdir, getwd())) 
[13:23:32.939]             setwd(...future.workdir)
[13:23:32.939]         {
[13:23:32.939]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.939]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.939]             }
[13:23:32.939]             base::options(...future.oldOptions)
[13:23:32.939]             if (.Platform$OS.type == "windows") {
[13:23:32.939]                 old_names <- names(...future.oldEnvVars)
[13:23:32.939]                 envs <- base::Sys.getenv()
[13:23:32.939]                 names <- names(envs)
[13:23:32.939]                 common <- intersect(names, old_names)
[13:23:32.939]                 added <- setdiff(names, old_names)
[13:23:32.939]                 removed <- setdiff(old_names, names)
[13:23:32.939]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.939]                   envs[common]]
[13:23:32.939]                 NAMES <- toupper(changed)
[13:23:32.939]                 args <- list()
[13:23:32.939]                 for (kk in seq_along(NAMES)) {
[13:23:32.939]                   name <- changed[[kk]]
[13:23:32.939]                   NAME <- NAMES[[kk]]
[13:23:32.939]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.939]                     next
[13:23:32.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.939]                 }
[13:23:32.939]                 NAMES <- toupper(added)
[13:23:32.939]                 for (kk in seq_along(NAMES)) {
[13:23:32.939]                   name <- added[[kk]]
[13:23:32.939]                   NAME <- NAMES[[kk]]
[13:23:32.939]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.939]                     next
[13:23:32.939]                   args[[name]] <- ""
[13:23:32.939]                 }
[13:23:32.939]                 NAMES <- toupper(removed)
[13:23:32.939]                 for (kk in seq_along(NAMES)) {
[13:23:32.939]                   name <- removed[[kk]]
[13:23:32.939]                   NAME <- NAMES[[kk]]
[13:23:32.939]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.939]                     next
[13:23:32.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.939]                 }
[13:23:32.939]                 if (length(args) > 0) 
[13:23:32.939]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.939]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.939]             }
[13:23:32.939]             else {
[13:23:32.939]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.939]             }
[13:23:32.939]             {
[13:23:32.939]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.939]                   0L) {
[13:23:32.939]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.939]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.939]                   base::options(opts)
[13:23:32.939]                 }
[13:23:32.939]                 {
[13:23:32.939]                   {
[13:23:32.939]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:32.939]                     NULL
[13:23:32.939]                   }
[13:23:32.939]                   options(future.plan = NULL)
[13:23:32.939]                   if (is.na(NA_character_)) 
[13:23:32.939]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.939]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.939]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:32.939]                     envir = parent.frame()) 
[13:23:32.939]                   {
[13:23:32.939]                     default_workers <- missing(workers)
[13:23:32.939]                     if (is.function(workers)) 
[13:23:32.939]                       workers <- workers()
[13:23:32.939]                     workers <- structure(as.integer(workers), 
[13:23:32.939]                       class = class(workers))
[13:23:32.939]                     stop_if_not(is.finite(workers), workers >= 
[13:23:32.939]                       1L)
[13:23:32.939]                     if ((workers == 1L && !inherits(workers, 
[13:23:32.939]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:32.939]                       if (default_workers) 
[13:23:32.939]                         supportsMulticore(warn = TRUE)
[13:23:32.939]                       return(sequential(..., envir = envir))
[13:23:32.939]                     }
[13:23:32.939]                     oopts <- options(mc.cores = workers)
[13:23:32.939]                     on.exit(options(oopts))
[13:23:32.939]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:32.939]                       envir = envir)
[13:23:32.939]                     if (!future$lazy) 
[13:23:32.939]                       future <- run(future)
[13:23:32.939]                     invisible(future)
[13:23:32.939]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.939]                 }
[13:23:32.939]             }
[13:23:32.939]         }
[13:23:32.939]     })
[13:23:32.939]     if (TRUE) {
[13:23:32.939]         base::sink(type = "output", split = FALSE)
[13:23:32.939]         if (TRUE) {
[13:23:32.939]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.939]         }
[13:23:32.939]         else {
[13:23:32.939]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.939]         }
[13:23:32.939]         base::close(...future.stdout)
[13:23:32.939]         ...future.stdout <- NULL
[13:23:32.939]     }
[13:23:32.939]     ...future.result$conditions <- ...future.conditions
[13:23:32.939]     ...future.result$finished <- base::Sys.time()
[13:23:32.939]     ...future.result
[13:23:32.939] }
[13:23:32.942] assign_globals() ...
[13:23:32.942] List of 1
[13:23:32.942]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5589bec9c348> 
[13:23:32.942]  - attr(*, "where")=List of 1
[13:23:32.942]   ..$ a:<environment: R_EmptyEnv> 
[13:23:32.942]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:32.942]  - attr(*, "resolved")= logi TRUE
[13:23:32.942]  - attr(*, "total_size")= num 10816
[13:23:32.942]  - attr(*, "already-done")= logi TRUE
[13:23:32.945] - copied ‘a’ to environment
[13:23:32.946] assign_globals() ... done
[13:23:32.946] requestCore(): workers = 2
[13:23:32.948] MulticoreFuture started
[13:23:32.949] - Launch lazy future ... done
[13:23:32.949] run() for ‘MulticoreFuture’ ... done
[13:23:32.949] result() for MulticoreFuture ...
[13:23:32.950] plan(): Setting new future strategy stack:
[13:23:32.950] List of future strategies:
[13:23:32.950] 1. sequential:
[13:23:32.950]    - args: function (..., envir = parent.frame())
[13:23:32.950]    - tweaked: FALSE
[13:23:32.950]    - call: NULL
[13:23:32.951] plan(): nbrOfWorkers() = 1
[13:23:32.955] plan(): Setting new future strategy stack:
[13:23:32.955] List of future strategies:
[13:23:32.955] 1. multicore:
[13:23:32.955]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:32.955]    - tweaked: FALSE
[13:23:32.955]    - call: plan(strategy)
[13:23:32.960] plan(): nbrOfWorkers() = 2
[13:23:32.961] result() for MulticoreFuture ...
[13:23:32.961] result() for MulticoreFuture ... done
[13:23:32.962] signalConditions() ...
[13:23:32.962]  - include = ‘immediateCondition’
[13:23:32.962]  - exclude = 
[13:23:32.962]  - resignal = FALSE
[13:23:32.962]  - Number of conditions: 4
[13:23:32.962] signalConditions() ... done
[13:23:32.962] result() for MulticoreFuture ... done
[13:23:32.963] result() for MulticoreFuture ...
[13:23:32.963] result() for MulticoreFuture ... done
[13:23:32.963] signalConditions() ...
[13:23:32.963]  - include = ‘immediateCondition’
[13:23:32.963]  - exclude = 
[13:23:32.963]  - resignal = FALSE
[13:23:32.963]  - Number of conditions: 4
[13:23:32.963] signalConditions() ... done
[13:23:32.964] Future state: ‘finished’
[13:23:32.964] result() for MulticoreFuture ...
[13:23:32.964] result() for MulticoreFuture ... done
[13:23:32.964] signalConditions() ...
[13:23:32.964]  - include = ‘condition’
[13:23:32.964]  - exclude = ‘immediateCondition’
[13:23:32.964]  - resignal = TRUE
[13:23:32.965]  - Number of conditions: 4
[13:23:32.965]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:32.952] result() for MulticoreFuture ...
[13:23:32.965]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:32.953] result() for MulticoreFuture ... done
[13:23:32.965]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:32.953] result() for MulticoreFuture ...
[13:23:32.965]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:32.953] result() for MulticoreFuture ... done
[13:23:32.965] signalConditions() ... done
value(b) = 2
[13:23:32.966] result() for MulticoreFuture ...
[13:23:32.966] result() for MulticoreFuture ... done
[13:23:32.966] result() for MulticoreFuture ...
[13:23:32.966] result() for MulticoreFuture ... done
[13:23:32.966] signalConditions() ...
[13:23:32.966]  - include = ‘immediateCondition’
[13:23:32.966]  - exclude = 
[13:23:32.966]  - resignal = FALSE
[13:23:32.967]  - Number of conditions: 4
[13:23:32.967] signalConditions() ... done
[13:23:32.967] Future state: ‘finished’
[13:23:32.967] result() for MulticoreFuture ...
[13:23:32.967] result() for MulticoreFuture ... done
[13:23:32.967] signalConditions() ...
[13:23:32.967]  - include = ‘condition’
[13:23:32.967]  - exclude = ‘immediateCondition’
[13:23:32.967]  - resignal = TRUE
[13:23:32.968]  - Number of conditions: 4
[13:23:32.968]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:32.952] result() for MulticoreFuture ...
[13:23:32.968]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:32.953] result() for MulticoreFuture ... done
[13:23:32.968]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:32.953] result() for MulticoreFuture ...
[13:23:32.968]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:32.953] result() for MulticoreFuture ... done
[13:23:32.968] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.971] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.972] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:32.973] 
[13:23:32.973] Searching for globals ... DONE
[13:23:32.973] - globals: [0] <none>
[13:23:32.974] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:32.974] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:32.975] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:32.976] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:32.976] Searching for globals ... DONE
[13:23:32.976] Resolving globals: TRUE
[13:23:32.976] Resolving any globals that are futures ...
[13:23:32.976] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:32.977] Resolving any globals that are futures ... DONE
[13:23:32.977] Resolving futures part of globals (recursively) ...
[13:23:32.977] resolve() on list ...
[13:23:32.977]  recursive: 99
[13:23:32.978]  length: 1
[13:23:32.978]  elements: ‘a’
[13:23:32.978] run() for ‘Future’ ...
[13:23:32.978] - state: ‘created’
[13:23:32.978] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:32.983] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:32.983] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:32.983]   - Field: ‘label’
[13:23:32.983]   - Field: ‘local’
[13:23:32.983]   - Field: ‘owner’
[13:23:32.983]   - Field: ‘envir’
[13:23:32.983]   - Field: ‘workers’
[13:23:32.983]   - Field: ‘packages’
[13:23:32.984]   - Field: ‘gc’
[13:23:32.984]   - Field: ‘job’
[13:23:32.984]   - Field: ‘conditions’
[13:23:32.984]   - Field: ‘expr’
[13:23:32.984]   - Field: ‘uuid’
[13:23:32.984]   - Field: ‘seed’
[13:23:32.984]   - Field: ‘version’
[13:23:32.984]   - Field: ‘result’
[13:23:32.984]   - Field: ‘asynchronous’
[13:23:32.985]   - Field: ‘calls’
[13:23:32.985]   - Field: ‘globals’
[13:23:32.985]   - Field: ‘stdout’
[13:23:32.985]   - Field: ‘earlySignal’
[13:23:32.985]   - Field: ‘lazy’
[13:23:32.985]   - Field: ‘state’
[13:23:32.985] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:32.985] - Launch lazy future ...
[13:23:32.986] Packages needed by the future expression (n = 0): <none>
[13:23:32.986] Packages needed by future strategies (n = 0): <none>
[13:23:32.986] {
[13:23:32.986]     {
[13:23:32.986]         {
[13:23:32.986]             ...future.startTime <- base::Sys.time()
[13:23:32.986]             {
[13:23:32.986]                 {
[13:23:32.986]                   {
[13:23:32.986]                     {
[13:23:32.986]                       base::local({
[13:23:32.986]                         has_future <- base::requireNamespace("future", 
[13:23:32.986]                           quietly = TRUE)
[13:23:32.986]                         if (has_future) {
[13:23:32.986]                           ns <- base::getNamespace("future")
[13:23:32.986]                           version <- ns[[".package"]][["version"]]
[13:23:32.986]                           if (is.null(version)) 
[13:23:32.986]                             version <- utils::packageVersion("future")
[13:23:32.986]                         }
[13:23:32.986]                         else {
[13:23:32.986]                           version <- NULL
[13:23:32.986]                         }
[13:23:32.986]                         if (!has_future || version < "1.8.0") {
[13:23:32.986]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:32.986]                             "", base::R.version$version.string), 
[13:23:32.986]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:32.986]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:32.986]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:32.986]                               "release", "version")], collapse = " "), 
[13:23:32.986]                             hostname = base::Sys.info()[["nodename"]])
[13:23:32.986]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:32.986]                             info)
[13:23:32.986]                           info <- base::paste(info, collapse = "; ")
[13:23:32.986]                           if (!has_future) {
[13:23:32.986]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:32.986]                               info)
[13:23:32.986]                           }
[13:23:32.986]                           else {
[13:23:32.986]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:32.986]                               info, version)
[13:23:32.986]                           }
[13:23:32.986]                           base::stop(msg)
[13:23:32.986]                         }
[13:23:32.986]                       })
[13:23:32.986]                     }
[13:23:32.986]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:32.986]                     base::options(mc.cores = 1L)
[13:23:32.986]                   }
[13:23:32.986]                   options(future.plan = NULL)
[13:23:32.986]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.986]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:32.986]                 }
[13:23:32.986]                 ...future.workdir <- getwd()
[13:23:32.986]             }
[13:23:32.986]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:32.986]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:32.986]         }
[13:23:32.986]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:32.986]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:32.986]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:32.986]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:32.986]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:32.986]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:32.986]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:32.986]             base::names(...future.oldOptions))
[13:23:32.986]     }
[13:23:32.986]     if (FALSE) {
[13:23:32.986]     }
[13:23:32.986]     else {
[13:23:32.986]         if (TRUE) {
[13:23:32.986]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:32.986]                 open = "w")
[13:23:32.986]         }
[13:23:32.986]         else {
[13:23:32.986]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:32.986]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:32.986]         }
[13:23:32.986]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:32.986]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:32.986]             base::sink(type = "output", split = FALSE)
[13:23:32.986]             base::close(...future.stdout)
[13:23:32.986]         }, add = TRUE)
[13:23:32.986]     }
[13:23:32.986]     ...future.frame <- base::sys.nframe()
[13:23:32.986]     ...future.conditions <- base::list()
[13:23:32.986]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:32.986]     if (FALSE) {
[13:23:32.986]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:32.986]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:32.986]     }
[13:23:32.986]     ...future.result <- base::tryCatch({
[13:23:32.986]         base::withCallingHandlers({
[13:23:32.986]             ...future.value <- base::withVisible(base::local({
[13:23:32.986]                 withCallingHandlers({
[13:23:32.986]                   1
[13:23:32.986]                 }, immediateCondition = function(cond) {
[13:23:32.986]                   save_rds <- function (object, pathname, ...) 
[13:23:32.986]                   {
[13:23:32.986]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:32.986]                     if (file_test("-f", pathname_tmp)) {
[13:23:32.986]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.986]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:32.986]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.986]                         fi_tmp[["mtime"]])
[13:23:32.986]                     }
[13:23:32.986]                     tryCatch({
[13:23:32.986]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:32.986]                     }, error = function(ex) {
[13:23:32.986]                       msg <- conditionMessage(ex)
[13:23:32.986]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.986]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:32.986]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.986]                         fi_tmp[["mtime"]], msg)
[13:23:32.986]                       ex$message <- msg
[13:23:32.986]                       stop(ex)
[13:23:32.986]                     })
[13:23:32.986]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:32.986]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:32.986]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:32.986]                       fi_tmp <- file.info(pathname_tmp)
[13:23:32.986]                       fi <- file.info(pathname)
[13:23:32.986]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:32.986]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:32.986]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:32.986]                         fi[["size"]], fi[["mtime"]])
[13:23:32.986]                       stop(msg)
[13:23:32.986]                     }
[13:23:32.986]                     invisible(pathname)
[13:23:32.986]                   }
[13:23:32.986]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:32.986]                     rootPath = tempdir()) 
[13:23:32.986]                   {
[13:23:32.986]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:32.986]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:32.986]                       tmpdir = path, fileext = ".rds")
[13:23:32.986]                     save_rds(obj, file)
[13:23:32.986]                   }
[13:23:32.986]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:32.986]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.986]                   {
[13:23:32.986]                     inherits <- base::inherits
[13:23:32.986]                     invokeRestart <- base::invokeRestart
[13:23:32.986]                     is.null <- base::is.null
[13:23:32.986]                     muffled <- FALSE
[13:23:32.986]                     if (inherits(cond, "message")) {
[13:23:32.986]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:32.986]                       if (muffled) 
[13:23:32.986]                         invokeRestart("muffleMessage")
[13:23:32.986]                     }
[13:23:32.986]                     else if (inherits(cond, "warning")) {
[13:23:32.986]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:32.986]                       if (muffled) 
[13:23:32.986]                         invokeRestart("muffleWarning")
[13:23:32.986]                     }
[13:23:32.986]                     else if (inherits(cond, "condition")) {
[13:23:32.986]                       if (!is.null(pattern)) {
[13:23:32.986]                         computeRestarts <- base::computeRestarts
[13:23:32.986]                         grepl <- base::grepl
[13:23:32.986]                         restarts <- computeRestarts(cond)
[13:23:32.986]                         for (restart in restarts) {
[13:23:32.986]                           name <- restart$name
[13:23:32.986]                           if (is.null(name)) 
[13:23:32.986]                             next
[13:23:32.986]                           if (!grepl(pattern, name)) 
[13:23:32.986]                             next
[13:23:32.986]                           invokeRestart(restart)
[13:23:32.986]                           muffled <- TRUE
[13:23:32.986]                           break
[13:23:32.986]                         }
[13:23:32.986]                       }
[13:23:32.986]                     }
[13:23:32.986]                     invisible(muffled)
[13:23:32.986]                   }
[13:23:32.986]                   muffleCondition(cond)
[13:23:32.986]                 })
[13:23:32.986]             }))
[13:23:32.986]             future::FutureResult(value = ...future.value$value, 
[13:23:32.986]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.986]                   ...future.rng), globalenv = if (FALSE) 
[13:23:32.986]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:32.986]                     ...future.globalenv.names))
[13:23:32.986]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:32.986]         }, condition = base::local({
[13:23:32.986]             c <- base::c
[13:23:32.986]             inherits <- base::inherits
[13:23:32.986]             invokeRestart <- base::invokeRestart
[13:23:32.986]             length <- base::length
[13:23:32.986]             list <- base::list
[13:23:32.986]             seq.int <- base::seq.int
[13:23:32.986]             signalCondition <- base::signalCondition
[13:23:32.986]             sys.calls <- base::sys.calls
[13:23:32.986]             `[[` <- base::`[[`
[13:23:32.986]             `+` <- base::`+`
[13:23:32.986]             `<<-` <- base::`<<-`
[13:23:32.986]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:32.986]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:32.986]                   3L)]
[13:23:32.986]             }
[13:23:32.986]             function(cond) {
[13:23:32.986]                 is_error <- inherits(cond, "error")
[13:23:32.986]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:32.986]                   NULL)
[13:23:32.986]                 if (is_error) {
[13:23:32.986]                   sessionInformation <- function() {
[13:23:32.986]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:32.986]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:32.986]                       search = base::search(), system = base::Sys.info())
[13:23:32.986]                   }
[13:23:32.986]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.986]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:32.986]                     cond$call), session = sessionInformation(), 
[13:23:32.986]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:32.986]                   signalCondition(cond)
[13:23:32.986]                 }
[13:23:32.986]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:32.986]                 "immediateCondition"))) {
[13:23:32.986]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:32.986]                   ...future.conditions[[length(...future.conditions) + 
[13:23:32.986]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:32.986]                   if (TRUE && !signal) {
[13:23:32.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.986]                     {
[13:23:32.986]                       inherits <- base::inherits
[13:23:32.986]                       invokeRestart <- base::invokeRestart
[13:23:32.986]                       is.null <- base::is.null
[13:23:32.986]                       muffled <- FALSE
[13:23:32.986]                       if (inherits(cond, "message")) {
[13:23:32.986]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.986]                         if (muffled) 
[13:23:32.986]                           invokeRestart("muffleMessage")
[13:23:32.986]                       }
[13:23:32.986]                       else if (inherits(cond, "warning")) {
[13:23:32.986]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.986]                         if (muffled) 
[13:23:32.986]                           invokeRestart("muffleWarning")
[13:23:32.986]                       }
[13:23:32.986]                       else if (inherits(cond, "condition")) {
[13:23:32.986]                         if (!is.null(pattern)) {
[13:23:32.986]                           computeRestarts <- base::computeRestarts
[13:23:32.986]                           grepl <- base::grepl
[13:23:32.986]                           restarts <- computeRestarts(cond)
[13:23:32.986]                           for (restart in restarts) {
[13:23:32.986]                             name <- restart$name
[13:23:32.986]                             if (is.null(name)) 
[13:23:32.986]                               next
[13:23:32.986]                             if (!grepl(pattern, name)) 
[13:23:32.986]                               next
[13:23:32.986]                             invokeRestart(restart)
[13:23:32.986]                             muffled <- TRUE
[13:23:32.986]                             break
[13:23:32.986]                           }
[13:23:32.986]                         }
[13:23:32.986]                       }
[13:23:32.986]                       invisible(muffled)
[13:23:32.986]                     }
[13:23:32.986]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.986]                   }
[13:23:32.986]                 }
[13:23:32.986]                 else {
[13:23:32.986]                   if (TRUE) {
[13:23:32.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:32.986]                     {
[13:23:32.986]                       inherits <- base::inherits
[13:23:32.986]                       invokeRestart <- base::invokeRestart
[13:23:32.986]                       is.null <- base::is.null
[13:23:32.986]                       muffled <- FALSE
[13:23:32.986]                       if (inherits(cond, "message")) {
[13:23:32.986]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:32.986]                         if (muffled) 
[13:23:32.986]                           invokeRestart("muffleMessage")
[13:23:32.986]                       }
[13:23:32.986]                       else if (inherits(cond, "warning")) {
[13:23:32.986]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:32.986]                         if (muffled) 
[13:23:32.986]                           invokeRestart("muffleWarning")
[13:23:32.986]                       }
[13:23:32.986]                       else if (inherits(cond, "condition")) {
[13:23:32.986]                         if (!is.null(pattern)) {
[13:23:32.986]                           computeRestarts <- base::computeRestarts
[13:23:32.986]                           grepl <- base::grepl
[13:23:32.986]                           restarts <- computeRestarts(cond)
[13:23:32.986]                           for (restart in restarts) {
[13:23:32.986]                             name <- restart$name
[13:23:32.986]                             if (is.null(name)) 
[13:23:32.986]                               next
[13:23:32.986]                             if (!grepl(pattern, name)) 
[13:23:32.986]                               next
[13:23:32.986]                             invokeRestart(restart)
[13:23:32.986]                             muffled <- TRUE
[13:23:32.986]                             break
[13:23:32.986]                           }
[13:23:32.986]                         }
[13:23:32.986]                       }
[13:23:32.986]                       invisible(muffled)
[13:23:32.986]                     }
[13:23:32.986]                     muffleCondition(cond, pattern = "^muffle")
[13:23:32.986]                   }
[13:23:32.986]                 }
[13:23:32.986]             }
[13:23:32.986]         }))
[13:23:32.986]     }, error = function(ex) {
[13:23:32.986]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:32.986]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:32.986]                 ...future.rng), started = ...future.startTime, 
[13:23:32.986]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:32.986]             version = "1.8"), class = "FutureResult")
[13:23:32.986]     }, finally = {
[13:23:32.986]         if (!identical(...future.workdir, getwd())) 
[13:23:32.986]             setwd(...future.workdir)
[13:23:32.986]         {
[13:23:32.986]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:32.986]                 ...future.oldOptions$nwarnings <- NULL
[13:23:32.986]             }
[13:23:32.986]             base::options(...future.oldOptions)
[13:23:32.986]             if (.Platform$OS.type == "windows") {
[13:23:32.986]                 old_names <- names(...future.oldEnvVars)
[13:23:32.986]                 envs <- base::Sys.getenv()
[13:23:32.986]                 names <- names(envs)
[13:23:32.986]                 common <- intersect(names, old_names)
[13:23:32.986]                 added <- setdiff(names, old_names)
[13:23:32.986]                 removed <- setdiff(old_names, names)
[13:23:32.986]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:32.986]                   envs[common]]
[13:23:32.986]                 NAMES <- toupper(changed)
[13:23:32.986]                 args <- list()
[13:23:32.986]                 for (kk in seq_along(NAMES)) {
[13:23:32.986]                   name <- changed[[kk]]
[13:23:32.986]                   NAME <- NAMES[[kk]]
[13:23:32.986]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.986]                     next
[13:23:32.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.986]                 }
[13:23:32.986]                 NAMES <- toupper(added)
[13:23:32.986]                 for (kk in seq_along(NAMES)) {
[13:23:32.986]                   name <- added[[kk]]
[13:23:32.986]                   NAME <- NAMES[[kk]]
[13:23:32.986]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.986]                     next
[13:23:32.986]                   args[[name]] <- ""
[13:23:32.986]                 }
[13:23:32.986]                 NAMES <- toupper(removed)
[13:23:32.986]                 for (kk in seq_along(NAMES)) {
[13:23:32.986]                   name <- removed[[kk]]
[13:23:32.986]                   NAME <- NAMES[[kk]]
[13:23:32.986]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:32.986]                     next
[13:23:32.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:32.986]                 }
[13:23:32.986]                 if (length(args) > 0) 
[13:23:32.986]                   base::do.call(base::Sys.setenv, args = args)
[13:23:32.986]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:32.986]             }
[13:23:32.986]             else {
[13:23:32.986]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:32.986]             }
[13:23:32.986]             {
[13:23:32.986]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:32.986]                   0L) {
[13:23:32.986]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:32.986]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:32.986]                   base::options(opts)
[13:23:32.986]                 }
[13:23:32.986]                 {
[13:23:32.986]                   {
[13:23:32.986]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:32.986]                     NULL
[13:23:32.986]                   }
[13:23:32.986]                   options(future.plan = NULL)
[13:23:32.986]                   if (is.na(NA_character_)) 
[13:23:32.986]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:32.986]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:32.986]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:32.986]                     envir = parent.frame()) 
[13:23:32.986]                   {
[13:23:32.986]                     default_workers <- missing(workers)
[13:23:32.986]                     if (is.function(workers)) 
[13:23:32.986]                       workers <- workers()
[13:23:32.986]                     workers <- structure(as.integer(workers), 
[13:23:32.986]                       class = class(workers))
[13:23:32.986]                     stop_if_not(is.finite(workers), workers >= 
[13:23:32.986]                       1L)
[13:23:32.986]                     if ((workers == 1L && !inherits(workers, 
[13:23:32.986]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:32.986]                       if (default_workers) 
[13:23:32.986]                         supportsMulticore(warn = TRUE)
[13:23:32.986]                       return(sequential(..., envir = envir))
[13:23:32.986]                     }
[13:23:32.986]                     oopts <- options(mc.cores = workers)
[13:23:32.986]                     on.exit(options(oopts))
[13:23:32.986]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:32.986]                       envir = envir)
[13:23:32.986]                     if (!future$lazy) 
[13:23:32.986]                       future <- run(future)
[13:23:32.986]                     invisible(future)
[13:23:32.986]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:32.986]                 }
[13:23:32.986]             }
[13:23:32.986]         }
[13:23:32.986]     })
[13:23:32.986]     if (TRUE) {
[13:23:32.986]         base::sink(type = "output", split = FALSE)
[13:23:32.986]         if (TRUE) {
[13:23:32.986]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:32.986]         }
[13:23:32.986]         else {
[13:23:32.986]             ...future.result["stdout"] <- base::list(NULL)
[13:23:32.986]         }
[13:23:32.986]         base::close(...future.stdout)
[13:23:32.986]         ...future.stdout <- NULL
[13:23:32.986]     }
[13:23:32.986]     ...future.result$conditions <- ...future.conditions
[13:23:32.986]     ...future.result$finished <- base::Sys.time()
[13:23:32.986]     ...future.result
[13:23:32.986] }
[13:23:32.989] requestCore(): workers = 2
[13:23:32.991] MulticoreFuture started
[13:23:32.992] - Launch lazy future ... done
[13:23:32.992] run() for ‘MulticoreFuture’ ... done
[13:23:32.993] plan(): Setting new future strategy stack:
[13:23:32.993] List of future strategies:
[13:23:32.993] 1. sequential:
[13:23:32.993]    - args: function (..., envir = parent.frame())
[13:23:32.993]    - tweaked: FALSE
[13:23:32.993]    - call: NULL
[13:23:32.994] plan(): nbrOfWorkers() = 1
[13:23:32.996] plan(): Setting new future strategy stack:
[13:23:32.996] List of future strategies:
[13:23:32.996] 1. multicore:
[13:23:32.996]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:32.996]    - tweaked: FALSE
[13:23:32.996]    - call: plan(strategy)
[13:23:33.002] plan(): nbrOfWorkers() = 2
[13:23:33.003] Future #1
[13:23:33.003] result() for MulticoreFuture ...
[13:23:33.004] result() for MulticoreFuture ...
[13:23:33.004] result() for MulticoreFuture ... done
[13:23:33.004] result() for MulticoreFuture ... done
[13:23:33.004] result() for MulticoreFuture ...
[13:23:33.004] result() for MulticoreFuture ... done
[13:23:33.005] A MulticoreFuture was resolved
[13:23:33.005]  length: 0 (resolved future 1)
[13:23:33.005] resolve() on list ... DONE
[13:23:33.005] - globals: [1] ‘a’
[13:23:33.005] Resolving futures part of globals (recursively) ... DONE
[13:23:33.007] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[13:23:33.007] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[13:23:33.008] - globals: [1] ‘a’
[13:23:33.008] - packages: [1] ‘future’
[13:23:33.008] getGlobalsAndPackages() ... DONE
[13:23:33.008] run() for ‘Future’ ...
[13:23:33.009] - state: ‘created’
[13:23:33.009] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:33.013] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:33.013] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:33.013]   - Field: ‘label’
[13:23:33.014]   - Field: ‘local’
[13:23:33.014]   - Field: ‘owner’
[13:23:33.014]   - Field: ‘envir’
[13:23:33.014]   - Field: ‘workers’
[13:23:33.014]   - Field: ‘packages’
[13:23:33.014]   - Field: ‘gc’
[13:23:33.014]   - Field: ‘job’
[13:23:33.014]   - Field: ‘conditions’
[13:23:33.015]   - Field: ‘expr’
[13:23:33.015]   - Field: ‘uuid’
[13:23:33.015]   - Field: ‘seed’
[13:23:33.015]   - Field: ‘version’
[13:23:33.015]   - Field: ‘result’
[13:23:33.015]   - Field: ‘asynchronous’
[13:23:33.015]   - Field: ‘calls’
[13:23:33.015]   - Field: ‘globals’
[13:23:33.016]   - Field: ‘stdout’
[13:23:33.016]   - Field: ‘earlySignal’
[13:23:33.016]   - Field: ‘lazy’
[13:23:33.016]   - Field: ‘state’
[13:23:33.016] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:33.016] - Launch lazy future ...
[13:23:33.017] Packages needed by the future expression (n = 1): ‘future’
[13:23:33.017] Packages needed by future strategies (n = 0): <none>
[13:23:33.020] {
[13:23:33.020]     {
[13:23:33.020]         {
[13:23:33.020]             ...future.startTime <- base::Sys.time()
[13:23:33.020]             {
[13:23:33.020]                 {
[13:23:33.020]                   {
[13:23:33.020]                     {
[13:23:33.020]                       {
[13:23:33.020]                         base::local({
[13:23:33.020]                           has_future <- base::requireNamespace("future", 
[13:23:33.020]                             quietly = TRUE)
[13:23:33.020]                           if (has_future) {
[13:23:33.020]                             ns <- base::getNamespace("future")
[13:23:33.020]                             version <- ns[[".package"]][["version"]]
[13:23:33.020]                             if (is.null(version)) 
[13:23:33.020]                               version <- utils::packageVersion("future")
[13:23:33.020]                           }
[13:23:33.020]                           else {
[13:23:33.020]                             version <- NULL
[13:23:33.020]                           }
[13:23:33.020]                           if (!has_future || version < "1.8.0") {
[13:23:33.020]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.020]                               "", base::R.version$version.string), 
[13:23:33.020]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:33.020]                                 base::R.version$platform, 8 * 
[13:23:33.020]                                   base::.Machine$sizeof.pointer), 
[13:23:33.020]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.020]                                 "release", "version")], collapse = " "), 
[13:23:33.020]                               hostname = base::Sys.info()[["nodename"]])
[13:23:33.020]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.020]                               info)
[13:23:33.020]                             info <- base::paste(info, collapse = "; ")
[13:23:33.020]                             if (!has_future) {
[13:23:33.020]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.020]                                 info)
[13:23:33.020]                             }
[13:23:33.020]                             else {
[13:23:33.020]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.020]                                 info, version)
[13:23:33.020]                             }
[13:23:33.020]                             base::stop(msg)
[13:23:33.020]                           }
[13:23:33.020]                         })
[13:23:33.020]                       }
[13:23:33.020]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:33.020]                       base::options(mc.cores = 1L)
[13:23:33.020]                     }
[13:23:33.020]                     base::local({
[13:23:33.020]                       for (pkg in "future") {
[13:23:33.020]                         base::loadNamespace(pkg)
[13:23:33.020]                         base::library(pkg, character.only = TRUE)
[13:23:33.020]                       }
[13:23:33.020]                     })
[13:23:33.020]                   }
[13:23:33.020]                   options(future.plan = NULL)
[13:23:33.020]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.020]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.020]                 }
[13:23:33.020]                 ...future.workdir <- getwd()
[13:23:33.020]             }
[13:23:33.020]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.020]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.020]         }
[13:23:33.020]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.020]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:33.020]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.020]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.020]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.020]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.020]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.020]             base::names(...future.oldOptions))
[13:23:33.020]     }
[13:23:33.020]     if (FALSE) {
[13:23:33.020]     }
[13:23:33.020]     else {
[13:23:33.020]         if (TRUE) {
[13:23:33.020]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.020]                 open = "w")
[13:23:33.020]         }
[13:23:33.020]         else {
[13:23:33.020]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.020]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.020]         }
[13:23:33.020]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.020]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.020]             base::sink(type = "output", split = FALSE)
[13:23:33.020]             base::close(...future.stdout)
[13:23:33.020]         }, add = TRUE)
[13:23:33.020]     }
[13:23:33.020]     ...future.frame <- base::sys.nframe()
[13:23:33.020]     ...future.conditions <- base::list()
[13:23:33.020]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.020]     if (FALSE) {
[13:23:33.020]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.020]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.020]     }
[13:23:33.020]     ...future.result <- base::tryCatch({
[13:23:33.020]         base::withCallingHandlers({
[13:23:33.020]             ...future.value <- base::withVisible(base::local({
[13:23:33.020]                 withCallingHandlers({
[13:23:33.020]                   value(a) + 1
[13:23:33.020]                 }, immediateCondition = function(cond) {
[13:23:33.020]                   save_rds <- function (object, pathname, ...) 
[13:23:33.020]                   {
[13:23:33.020]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:33.020]                     if (file_test("-f", pathname_tmp)) {
[13:23:33.020]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.020]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:33.020]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.020]                         fi_tmp[["mtime"]])
[13:23:33.020]                     }
[13:23:33.020]                     tryCatch({
[13:23:33.020]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:33.020]                     }, error = function(ex) {
[13:23:33.020]                       msg <- conditionMessage(ex)
[13:23:33.020]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.020]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:33.020]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.020]                         fi_tmp[["mtime"]], msg)
[13:23:33.020]                       ex$message <- msg
[13:23:33.020]                       stop(ex)
[13:23:33.020]                     })
[13:23:33.020]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:33.020]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:33.020]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:33.020]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.020]                       fi <- file.info(pathname)
[13:23:33.020]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:33.020]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.020]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:33.020]                         fi[["size"]], fi[["mtime"]])
[13:23:33.020]                       stop(msg)
[13:23:33.020]                     }
[13:23:33.020]                     invisible(pathname)
[13:23:33.020]                   }
[13:23:33.020]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:33.020]                     rootPath = tempdir()) 
[13:23:33.020]                   {
[13:23:33.020]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:33.020]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:33.020]                       tmpdir = path, fileext = ".rds")
[13:23:33.020]                     save_rds(obj, file)
[13:23:33.020]                   }
[13:23:33.020]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:33.020]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.020]                   {
[13:23:33.020]                     inherits <- base::inherits
[13:23:33.020]                     invokeRestart <- base::invokeRestart
[13:23:33.020]                     is.null <- base::is.null
[13:23:33.020]                     muffled <- FALSE
[13:23:33.020]                     if (inherits(cond, "message")) {
[13:23:33.020]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:33.020]                       if (muffled) 
[13:23:33.020]                         invokeRestart("muffleMessage")
[13:23:33.020]                     }
[13:23:33.020]                     else if (inherits(cond, "warning")) {
[13:23:33.020]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:33.020]                       if (muffled) 
[13:23:33.020]                         invokeRestart("muffleWarning")
[13:23:33.020]                     }
[13:23:33.020]                     else if (inherits(cond, "condition")) {
[13:23:33.020]                       if (!is.null(pattern)) {
[13:23:33.020]                         computeRestarts <- base::computeRestarts
[13:23:33.020]                         grepl <- base::grepl
[13:23:33.020]                         restarts <- computeRestarts(cond)
[13:23:33.020]                         for (restart in restarts) {
[13:23:33.020]                           name <- restart$name
[13:23:33.020]                           if (is.null(name)) 
[13:23:33.020]                             next
[13:23:33.020]                           if (!grepl(pattern, name)) 
[13:23:33.020]                             next
[13:23:33.020]                           invokeRestart(restart)
[13:23:33.020]                           muffled <- TRUE
[13:23:33.020]                           break
[13:23:33.020]                         }
[13:23:33.020]                       }
[13:23:33.020]                     }
[13:23:33.020]                     invisible(muffled)
[13:23:33.020]                   }
[13:23:33.020]                   muffleCondition(cond)
[13:23:33.020]                 })
[13:23:33.020]             }))
[13:23:33.020]             future::FutureResult(value = ...future.value$value, 
[13:23:33.020]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.020]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.020]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.020]                     ...future.globalenv.names))
[13:23:33.020]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.020]         }, condition = base::local({
[13:23:33.020]             c <- base::c
[13:23:33.020]             inherits <- base::inherits
[13:23:33.020]             invokeRestart <- base::invokeRestart
[13:23:33.020]             length <- base::length
[13:23:33.020]             list <- base::list
[13:23:33.020]             seq.int <- base::seq.int
[13:23:33.020]             signalCondition <- base::signalCondition
[13:23:33.020]             sys.calls <- base::sys.calls
[13:23:33.020]             `[[` <- base::`[[`
[13:23:33.020]             `+` <- base::`+`
[13:23:33.020]             `<<-` <- base::`<<-`
[13:23:33.020]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.020]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.020]                   3L)]
[13:23:33.020]             }
[13:23:33.020]             function(cond) {
[13:23:33.020]                 is_error <- inherits(cond, "error")
[13:23:33.020]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.020]                   NULL)
[13:23:33.020]                 if (is_error) {
[13:23:33.020]                   sessionInformation <- function() {
[13:23:33.020]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.020]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.020]                       search = base::search(), system = base::Sys.info())
[13:23:33.020]                   }
[13:23:33.020]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.020]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.020]                     cond$call), session = sessionInformation(), 
[13:23:33.020]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.020]                   signalCondition(cond)
[13:23:33.020]                 }
[13:23:33.020]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.020]                 "immediateCondition"))) {
[13:23:33.020]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.020]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.020]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.020]                   if (TRUE && !signal) {
[13:23:33.020]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.020]                     {
[13:23:33.020]                       inherits <- base::inherits
[13:23:33.020]                       invokeRestart <- base::invokeRestart
[13:23:33.020]                       is.null <- base::is.null
[13:23:33.020]                       muffled <- FALSE
[13:23:33.020]                       if (inherits(cond, "message")) {
[13:23:33.020]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.020]                         if (muffled) 
[13:23:33.020]                           invokeRestart("muffleMessage")
[13:23:33.020]                       }
[13:23:33.020]                       else if (inherits(cond, "warning")) {
[13:23:33.020]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.020]                         if (muffled) 
[13:23:33.020]                           invokeRestart("muffleWarning")
[13:23:33.020]                       }
[13:23:33.020]                       else if (inherits(cond, "condition")) {
[13:23:33.020]                         if (!is.null(pattern)) {
[13:23:33.020]                           computeRestarts <- base::computeRestarts
[13:23:33.020]                           grepl <- base::grepl
[13:23:33.020]                           restarts <- computeRestarts(cond)
[13:23:33.020]                           for (restart in restarts) {
[13:23:33.020]                             name <- restart$name
[13:23:33.020]                             if (is.null(name)) 
[13:23:33.020]                               next
[13:23:33.020]                             if (!grepl(pattern, name)) 
[13:23:33.020]                               next
[13:23:33.020]                             invokeRestart(restart)
[13:23:33.020]                             muffled <- TRUE
[13:23:33.020]                             break
[13:23:33.020]                           }
[13:23:33.020]                         }
[13:23:33.020]                       }
[13:23:33.020]                       invisible(muffled)
[13:23:33.020]                     }
[13:23:33.020]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.020]                   }
[13:23:33.020]                 }
[13:23:33.020]                 else {
[13:23:33.020]                   if (TRUE) {
[13:23:33.020]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.020]                     {
[13:23:33.020]                       inherits <- base::inherits
[13:23:33.020]                       invokeRestart <- base::invokeRestart
[13:23:33.020]                       is.null <- base::is.null
[13:23:33.020]                       muffled <- FALSE
[13:23:33.020]                       if (inherits(cond, "message")) {
[13:23:33.020]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.020]                         if (muffled) 
[13:23:33.020]                           invokeRestart("muffleMessage")
[13:23:33.020]                       }
[13:23:33.020]                       else if (inherits(cond, "warning")) {
[13:23:33.020]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.020]                         if (muffled) 
[13:23:33.020]                           invokeRestart("muffleWarning")
[13:23:33.020]                       }
[13:23:33.020]                       else if (inherits(cond, "condition")) {
[13:23:33.020]                         if (!is.null(pattern)) {
[13:23:33.020]                           computeRestarts <- base::computeRestarts
[13:23:33.020]                           grepl <- base::grepl
[13:23:33.020]                           restarts <- computeRestarts(cond)
[13:23:33.020]                           for (restart in restarts) {
[13:23:33.020]                             name <- restart$name
[13:23:33.020]                             if (is.null(name)) 
[13:23:33.020]                               next
[13:23:33.020]                             if (!grepl(pattern, name)) 
[13:23:33.020]                               next
[13:23:33.020]                             invokeRestart(restart)
[13:23:33.020]                             muffled <- TRUE
[13:23:33.020]                             break
[13:23:33.020]                           }
[13:23:33.020]                         }
[13:23:33.020]                       }
[13:23:33.020]                       invisible(muffled)
[13:23:33.020]                     }
[13:23:33.020]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.020]                   }
[13:23:33.020]                 }
[13:23:33.020]             }
[13:23:33.020]         }))
[13:23:33.020]     }, error = function(ex) {
[13:23:33.020]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.020]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.020]                 ...future.rng), started = ...future.startTime, 
[13:23:33.020]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.020]             version = "1.8"), class = "FutureResult")
[13:23:33.020]     }, finally = {
[13:23:33.020]         if (!identical(...future.workdir, getwd())) 
[13:23:33.020]             setwd(...future.workdir)
[13:23:33.020]         {
[13:23:33.020]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.020]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.020]             }
[13:23:33.020]             base::options(...future.oldOptions)
[13:23:33.020]             if (.Platform$OS.type == "windows") {
[13:23:33.020]                 old_names <- names(...future.oldEnvVars)
[13:23:33.020]                 envs <- base::Sys.getenv()
[13:23:33.020]                 names <- names(envs)
[13:23:33.020]                 common <- intersect(names, old_names)
[13:23:33.020]                 added <- setdiff(names, old_names)
[13:23:33.020]                 removed <- setdiff(old_names, names)
[13:23:33.020]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.020]                   envs[common]]
[13:23:33.020]                 NAMES <- toupper(changed)
[13:23:33.020]                 args <- list()
[13:23:33.020]                 for (kk in seq_along(NAMES)) {
[13:23:33.020]                   name <- changed[[kk]]
[13:23:33.020]                   NAME <- NAMES[[kk]]
[13:23:33.020]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.020]                     next
[13:23:33.020]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.020]                 }
[13:23:33.020]                 NAMES <- toupper(added)
[13:23:33.020]                 for (kk in seq_along(NAMES)) {
[13:23:33.020]                   name <- added[[kk]]
[13:23:33.020]                   NAME <- NAMES[[kk]]
[13:23:33.020]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.020]                     next
[13:23:33.020]                   args[[name]] <- ""
[13:23:33.020]                 }
[13:23:33.020]                 NAMES <- toupper(removed)
[13:23:33.020]                 for (kk in seq_along(NAMES)) {
[13:23:33.020]                   name <- removed[[kk]]
[13:23:33.020]                   NAME <- NAMES[[kk]]
[13:23:33.020]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.020]                     next
[13:23:33.020]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.020]                 }
[13:23:33.020]                 if (length(args) > 0) 
[13:23:33.020]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.020]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.020]             }
[13:23:33.020]             else {
[13:23:33.020]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.020]             }
[13:23:33.020]             {
[13:23:33.020]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.020]                   0L) {
[13:23:33.020]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.020]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.020]                   base::options(opts)
[13:23:33.020]                 }
[13:23:33.020]                 {
[13:23:33.020]                   {
[13:23:33.020]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:33.020]                     NULL
[13:23:33.020]                   }
[13:23:33.020]                   options(future.plan = NULL)
[13:23:33.020]                   if (is.na(NA_character_)) 
[13:23:33.020]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.020]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.020]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.020]                     envir = parent.frame()) 
[13:23:33.020]                   {
[13:23:33.020]                     default_workers <- missing(workers)
[13:23:33.020]                     if (is.function(workers)) 
[13:23:33.020]                       workers <- workers()
[13:23:33.020]                     workers <- structure(as.integer(workers), 
[13:23:33.020]                       class = class(workers))
[13:23:33.020]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.020]                       1L)
[13:23:33.020]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.020]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.020]                       if (default_workers) 
[13:23:33.020]                         supportsMulticore(warn = TRUE)
[13:23:33.020]                       return(sequential(..., envir = envir))
[13:23:33.020]                     }
[13:23:33.020]                     oopts <- options(mc.cores = workers)
[13:23:33.020]                     on.exit(options(oopts))
[13:23:33.020]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.020]                       envir = envir)
[13:23:33.020]                     if (!future$lazy) 
[13:23:33.020]                       future <- run(future)
[13:23:33.020]                     invisible(future)
[13:23:33.020]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.020]                 }
[13:23:33.020]             }
[13:23:33.020]         }
[13:23:33.020]     })
[13:23:33.020]     if (TRUE) {
[13:23:33.020]         base::sink(type = "output", split = FALSE)
[13:23:33.020]         if (TRUE) {
[13:23:33.020]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.020]         }
[13:23:33.020]         else {
[13:23:33.020]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.020]         }
[13:23:33.020]         base::close(...future.stdout)
[13:23:33.020]         ...future.stdout <- NULL
[13:23:33.020]     }
[13:23:33.020]     ...future.result$conditions <- ...future.conditions
[13:23:33.020]     ...future.result$finished <- base::Sys.time()
[13:23:33.020]     ...future.result
[13:23:33.020] }
[13:23:33.023] assign_globals() ...
[13:23:33.023] List of 1
[13:23:33.023]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5589bf377a28> 
[13:23:33.023]  - attr(*, "where")=List of 1
[13:23:33.023]   ..$ a:<environment: R_EmptyEnv> 
[13:23:33.023]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:33.023]  - attr(*, "resolved")= logi TRUE
[13:23:33.023]  - attr(*, "total_size")= num 10984
[13:23:33.023]  - attr(*, "already-done")= logi TRUE
[13:23:33.027] - copied ‘a’ to environment
[13:23:33.028] assign_globals() ... done
[13:23:33.028] requestCore(): workers = 2
[13:23:33.030] MulticoreFuture started
[13:23:33.031] - Launch lazy future ... done
[13:23:33.031] run() for ‘MulticoreFuture’ ... done
[13:23:33.032] result() for MulticoreFuture ...
[13:23:33.032] plan(): Setting new future strategy stack:
[13:23:33.032] List of future strategies:
[13:23:33.032] 1. sequential:
[13:23:33.032]    - args: function (..., envir = parent.frame())
[13:23:33.032]    - tweaked: FALSE
[13:23:33.032]    - call: NULL
[13:23:33.034] plan(): nbrOfWorkers() = 1
[13:23:33.037] plan(): Setting new future strategy stack:
[13:23:33.038] List of future strategies:
[13:23:33.038] 1. multicore:
[13:23:33.038]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:33.038]    - tweaked: FALSE
[13:23:33.038]    - call: plan(strategy)
[13:23:33.043] plan(): nbrOfWorkers() = 2
[13:23:33.044] result() for MulticoreFuture ...
[13:23:33.044] result() for MulticoreFuture ... done
[13:23:33.045] signalConditions() ...
[13:23:33.045]  - include = ‘immediateCondition’
[13:23:33.045]  - exclude = 
[13:23:33.045]  - resignal = FALSE
[13:23:33.045]  - Number of conditions: 4
[13:23:33.045] signalConditions() ... done
[13:23:33.046] result() for MulticoreFuture ... done
[13:23:33.046] result() for MulticoreFuture ...
[13:23:33.046] result() for MulticoreFuture ... done
[13:23:33.046] signalConditions() ...
[13:23:33.046]  - include = ‘immediateCondition’
[13:23:33.046]  - exclude = 
[13:23:33.046]  - resignal = FALSE
[13:23:33.047]  - Number of conditions: 4
[13:23:33.047] signalConditions() ... done
[13:23:33.047] Future state: ‘finished’
[13:23:33.047] result() for MulticoreFuture ...
[13:23:33.047] result() for MulticoreFuture ... done
[13:23:33.047] signalConditions() ...
[13:23:33.047]  - include = ‘condition’
[13:23:33.047]  - exclude = ‘immediateCondition’
[13:23:33.048]  - resignal = TRUE
[13:23:33.048]  - Number of conditions: 4
[13:23:33.048]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.035] result() for MulticoreFuture ...
[13:23:33.048]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.036] result() for MulticoreFuture ... done
[13:23:33.048]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.036] result() for MulticoreFuture ...
[13:23:33.048]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.036] result() for MulticoreFuture ... done
[13:23:33.049] signalConditions() ... done
value(b) = 2
[13:23:33.049] result() for MulticoreFuture ...
[13:23:33.049] result() for MulticoreFuture ... done
[13:23:33.049] result() for MulticoreFuture ...
[13:23:33.049] result() for MulticoreFuture ... done
[13:23:33.049] signalConditions() ...
[13:23:33.049]  - include = ‘immediateCondition’
[13:23:33.050]  - exclude = 
[13:23:33.050]  - resignal = FALSE
[13:23:33.050]  - Number of conditions: 4
[13:23:33.050] signalConditions() ... done
[13:23:33.050] Future state: ‘finished’
[13:23:33.050] result() for MulticoreFuture ...
[13:23:33.050] result() for MulticoreFuture ... done
[13:23:33.050] signalConditions() ...
[13:23:33.051]  - include = ‘condition’
[13:23:33.051]  - exclude = ‘immediateCondition’
[13:23:33.051]  - resignal = TRUE
[13:23:33.051]  - Number of conditions: 4
[13:23:33.051]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.035] result() for MulticoreFuture ...
[13:23:33.051]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.036] result() for MulticoreFuture ... done
[13:23:33.051]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.036] result() for MulticoreFuture ...
[13:23:33.051]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.036] result() for MulticoreFuture ... done
[13:23:33.052] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:33.052] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:33.052] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:33.053] 
[13:23:33.053] Searching for globals ... DONE
[13:23:33.053] - globals: [0] <none>
[13:23:33.053] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:33.054] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:33.054] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:33.055] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:33.056] Searching for globals ... DONE
[13:23:33.056] Resolving globals: TRUE
[13:23:33.056] Resolving any globals that are futures ...
[13:23:33.056] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:33.056] Resolving any globals that are futures ... DONE
[13:23:33.057] Resolving futures part of globals (recursively) ...
[13:23:33.057] resolve() on list ...
[13:23:33.057]  recursive: 99
[13:23:33.057]  length: 1
[13:23:33.057]  elements: ‘a’
[13:23:33.057] run() for ‘Future’ ...
[13:23:33.058] - state: ‘created’
[13:23:33.058] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:33.062] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:33.063] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:33.063]   - Field: ‘label’
[13:23:33.063]   - Field: ‘local’
[13:23:33.063]   - Field: ‘owner’
[13:23:33.063]   - Field: ‘envir’
[13:23:33.063]   - Field: ‘workers’
[13:23:33.063]   - Field: ‘packages’
[13:23:33.064]   - Field: ‘gc’
[13:23:33.064]   - Field: ‘job’
[13:23:33.064]   - Field: ‘conditions’
[13:23:33.064]   - Field: ‘expr’
[13:23:33.064]   - Field: ‘uuid’
[13:23:33.064]   - Field: ‘seed’
[13:23:33.064]   - Field: ‘version’
[13:23:33.067]   - Field: ‘result’
[13:23:33.067]   - Field: ‘asynchronous’
[13:23:33.067]   - Field: ‘calls’
[13:23:33.068]   - Field: ‘globals’
[13:23:33.068]   - Field: ‘stdout’
[13:23:33.068]   - Field: ‘earlySignal’
[13:23:33.068]   - Field: ‘lazy’
[13:23:33.068]   - Field: ‘state’
[13:23:33.068] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:33.069] - Launch lazy future ...
[13:23:33.069] Packages needed by the future expression (n = 0): <none>
[13:23:33.069] Packages needed by future strategies (n = 0): <none>
[13:23:33.070] {
[13:23:33.070]     {
[13:23:33.070]         {
[13:23:33.070]             ...future.startTime <- base::Sys.time()
[13:23:33.070]             {
[13:23:33.070]                 {
[13:23:33.070]                   {
[13:23:33.070]                     {
[13:23:33.070]                       base::local({
[13:23:33.070]                         has_future <- base::requireNamespace("future", 
[13:23:33.070]                           quietly = TRUE)
[13:23:33.070]                         if (has_future) {
[13:23:33.070]                           ns <- base::getNamespace("future")
[13:23:33.070]                           version <- ns[[".package"]][["version"]]
[13:23:33.070]                           if (is.null(version)) 
[13:23:33.070]                             version <- utils::packageVersion("future")
[13:23:33.070]                         }
[13:23:33.070]                         else {
[13:23:33.070]                           version <- NULL
[13:23:33.070]                         }
[13:23:33.070]                         if (!has_future || version < "1.8.0") {
[13:23:33.070]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.070]                             "", base::R.version$version.string), 
[13:23:33.070]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:33.070]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:33.070]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.070]                               "release", "version")], collapse = " "), 
[13:23:33.070]                             hostname = base::Sys.info()[["nodename"]])
[13:23:33.070]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.070]                             info)
[13:23:33.070]                           info <- base::paste(info, collapse = "; ")
[13:23:33.070]                           if (!has_future) {
[13:23:33.070]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.070]                               info)
[13:23:33.070]                           }
[13:23:33.070]                           else {
[13:23:33.070]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.070]                               info, version)
[13:23:33.070]                           }
[13:23:33.070]                           base::stop(msg)
[13:23:33.070]                         }
[13:23:33.070]                       })
[13:23:33.070]                     }
[13:23:33.070]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:33.070]                     base::options(mc.cores = 1L)
[13:23:33.070]                   }
[13:23:33.070]                   options(future.plan = NULL)
[13:23:33.070]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.070]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.070]                 }
[13:23:33.070]                 ...future.workdir <- getwd()
[13:23:33.070]             }
[13:23:33.070]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.070]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.070]         }
[13:23:33.070]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.070]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:33.070]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.070]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.070]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.070]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.070]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.070]             base::names(...future.oldOptions))
[13:23:33.070]     }
[13:23:33.070]     if (FALSE) {
[13:23:33.070]     }
[13:23:33.070]     else {
[13:23:33.070]         if (TRUE) {
[13:23:33.070]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.070]                 open = "w")
[13:23:33.070]         }
[13:23:33.070]         else {
[13:23:33.070]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.070]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.070]         }
[13:23:33.070]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.070]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.070]             base::sink(type = "output", split = FALSE)
[13:23:33.070]             base::close(...future.stdout)
[13:23:33.070]         }, add = TRUE)
[13:23:33.070]     }
[13:23:33.070]     ...future.frame <- base::sys.nframe()
[13:23:33.070]     ...future.conditions <- base::list()
[13:23:33.070]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.070]     if (FALSE) {
[13:23:33.070]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.070]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.070]     }
[13:23:33.070]     ...future.result <- base::tryCatch({
[13:23:33.070]         base::withCallingHandlers({
[13:23:33.070]             ...future.value <- base::withVisible(base::local({
[13:23:33.070]                 withCallingHandlers({
[13:23:33.070]                   1
[13:23:33.070]                 }, immediateCondition = function(cond) {
[13:23:33.070]                   save_rds <- function (object, pathname, ...) 
[13:23:33.070]                   {
[13:23:33.070]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:33.070]                     if (file_test("-f", pathname_tmp)) {
[13:23:33.070]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.070]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:33.070]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.070]                         fi_tmp[["mtime"]])
[13:23:33.070]                     }
[13:23:33.070]                     tryCatch({
[13:23:33.070]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:33.070]                     }, error = function(ex) {
[13:23:33.070]                       msg <- conditionMessage(ex)
[13:23:33.070]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.070]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:33.070]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.070]                         fi_tmp[["mtime"]], msg)
[13:23:33.070]                       ex$message <- msg
[13:23:33.070]                       stop(ex)
[13:23:33.070]                     })
[13:23:33.070]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:33.070]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:33.070]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:33.070]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.070]                       fi <- file.info(pathname)
[13:23:33.070]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:33.070]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.070]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:33.070]                         fi[["size"]], fi[["mtime"]])
[13:23:33.070]                       stop(msg)
[13:23:33.070]                     }
[13:23:33.070]                     invisible(pathname)
[13:23:33.070]                   }
[13:23:33.070]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:33.070]                     rootPath = tempdir()) 
[13:23:33.070]                   {
[13:23:33.070]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:33.070]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:33.070]                       tmpdir = path, fileext = ".rds")
[13:23:33.070]                     save_rds(obj, file)
[13:23:33.070]                   }
[13:23:33.070]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:33.070]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.070]                   {
[13:23:33.070]                     inherits <- base::inherits
[13:23:33.070]                     invokeRestart <- base::invokeRestart
[13:23:33.070]                     is.null <- base::is.null
[13:23:33.070]                     muffled <- FALSE
[13:23:33.070]                     if (inherits(cond, "message")) {
[13:23:33.070]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:33.070]                       if (muffled) 
[13:23:33.070]                         invokeRestart("muffleMessage")
[13:23:33.070]                     }
[13:23:33.070]                     else if (inherits(cond, "warning")) {
[13:23:33.070]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:33.070]                       if (muffled) 
[13:23:33.070]                         invokeRestart("muffleWarning")
[13:23:33.070]                     }
[13:23:33.070]                     else if (inherits(cond, "condition")) {
[13:23:33.070]                       if (!is.null(pattern)) {
[13:23:33.070]                         computeRestarts <- base::computeRestarts
[13:23:33.070]                         grepl <- base::grepl
[13:23:33.070]                         restarts <- computeRestarts(cond)
[13:23:33.070]                         for (restart in restarts) {
[13:23:33.070]                           name <- restart$name
[13:23:33.070]                           if (is.null(name)) 
[13:23:33.070]                             next
[13:23:33.070]                           if (!grepl(pattern, name)) 
[13:23:33.070]                             next
[13:23:33.070]                           invokeRestart(restart)
[13:23:33.070]                           muffled <- TRUE
[13:23:33.070]                           break
[13:23:33.070]                         }
[13:23:33.070]                       }
[13:23:33.070]                     }
[13:23:33.070]                     invisible(muffled)
[13:23:33.070]                   }
[13:23:33.070]                   muffleCondition(cond)
[13:23:33.070]                 })
[13:23:33.070]             }))
[13:23:33.070]             future::FutureResult(value = ...future.value$value, 
[13:23:33.070]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.070]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.070]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.070]                     ...future.globalenv.names))
[13:23:33.070]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.070]         }, condition = base::local({
[13:23:33.070]             c <- base::c
[13:23:33.070]             inherits <- base::inherits
[13:23:33.070]             invokeRestart <- base::invokeRestart
[13:23:33.070]             length <- base::length
[13:23:33.070]             list <- base::list
[13:23:33.070]             seq.int <- base::seq.int
[13:23:33.070]             signalCondition <- base::signalCondition
[13:23:33.070]             sys.calls <- base::sys.calls
[13:23:33.070]             `[[` <- base::`[[`
[13:23:33.070]             `+` <- base::`+`
[13:23:33.070]             `<<-` <- base::`<<-`
[13:23:33.070]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.070]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.070]                   3L)]
[13:23:33.070]             }
[13:23:33.070]             function(cond) {
[13:23:33.070]                 is_error <- inherits(cond, "error")
[13:23:33.070]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.070]                   NULL)
[13:23:33.070]                 if (is_error) {
[13:23:33.070]                   sessionInformation <- function() {
[13:23:33.070]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.070]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.070]                       search = base::search(), system = base::Sys.info())
[13:23:33.070]                   }
[13:23:33.070]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.070]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.070]                     cond$call), session = sessionInformation(), 
[13:23:33.070]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.070]                   signalCondition(cond)
[13:23:33.070]                 }
[13:23:33.070]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.070]                 "immediateCondition"))) {
[13:23:33.070]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.070]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.070]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.070]                   if (TRUE && !signal) {
[13:23:33.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.070]                     {
[13:23:33.070]                       inherits <- base::inherits
[13:23:33.070]                       invokeRestart <- base::invokeRestart
[13:23:33.070]                       is.null <- base::is.null
[13:23:33.070]                       muffled <- FALSE
[13:23:33.070]                       if (inherits(cond, "message")) {
[13:23:33.070]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.070]                         if (muffled) 
[13:23:33.070]                           invokeRestart("muffleMessage")
[13:23:33.070]                       }
[13:23:33.070]                       else if (inherits(cond, "warning")) {
[13:23:33.070]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.070]                         if (muffled) 
[13:23:33.070]                           invokeRestart("muffleWarning")
[13:23:33.070]                       }
[13:23:33.070]                       else if (inherits(cond, "condition")) {
[13:23:33.070]                         if (!is.null(pattern)) {
[13:23:33.070]                           computeRestarts <- base::computeRestarts
[13:23:33.070]                           grepl <- base::grepl
[13:23:33.070]                           restarts <- computeRestarts(cond)
[13:23:33.070]                           for (restart in restarts) {
[13:23:33.070]                             name <- restart$name
[13:23:33.070]                             if (is.null(name)) 
[13:23:33.070]                               next
[13:23:33.070]                             if (!grepl(pattern, name)) 
[13:23:33.070]                               next
[13:23:33.070]                             invokeRestart(restart)
[13:23:33.070]                             muffled <- TRUE
[13:23:33.070]                             break
[13:23:33.070]                           }
[13:23:33.070]                         }
[13:23:33.070]                       }
[13:23:33.070]                       invisible(muffled)
[13:23:33.070]                     }
[13:23:33.070]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.070]                   }
[13:23:33.070]                 }
[13:23:33.070]                 else {
[13:23:33.070]                   if (TRUE) {
[13:23:33.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.070]                     {
[13:23:33.070]                       inherits <- base::inherits
[13:23:33.070]                       invokeRestart <- base::invokeRestart
[13:23:33.070]                       is.null <- base::is.null
[13:23:33.070]                       muffled <- FALSE
[13:23:33.070]                       if (inherits(cond, "message")) {
[13:23:33.070]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.070]                         if (muffled) 
[13:23:33.070]                           invokeRestart("muffleMessage")
[13:23:33.070]                       }
[13:23:33.070]                       else if (inherits(cond, "warning")) {
[13:23:33.070]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.070]                         if (muffled) 
[13:23:33.070]                           invokeRestart("muffleWarning")
[13:23:33.070]                       }
[13:23:33.070]                       else if (inherits(cond, "condition")) {
[13:23:33.070]                         if (!is.null(pattern)) {
[13:23:33.070]                           computeRestarts <- base::computeRestarts
[13:23:33.070]                           grepl <- base::grepl
[13:23:33.070]                           restarts <- computeRestarts(cond)
[13:23:33.070]                           for (restart in restarts) {
[13:23:33.070]                             name <- restart$name
[13:23:33.070]                             if (is.null(name)) 
[13:23:33.070]                               next
[13:23:33.070]                             if (!grepl(pattern, name)) 
[13:23:33.070]                               next
[13:23:33.070]                             invokeRestart(restart)
[13:23:33.070]                             muffled <- TRUE
[13:23:33.070]                             break
[13:23:33.070]                           }
[13:23:33.070]                         }
[13:23:33.070]                       }
[13:23:33.070]                       invisible(muffled)
[13:23:33.070]                     }
[13:23:33.070]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.070]                   }
[13:23:33.070]                 }
[13:23:33.070]             }
[13:23:33.070]         }))
[13:23:33.070]     }, error = function(ex) {
[13:23:33.070]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.070]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.070]                 ...future.rng), started = ...future.startTime, 
[13:23:33.070]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.070]             version = "1.8"), class = "FutureResult")
[13:23:33.070]     }, finally = {
[13:23:33.070]         if (!identical(...future.workdir, getwd())) 
[13:23:33.070]             setwd(...future.workdir)
[13:23:33.070]         {
[13:23:33.070]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.070]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.070]             }
[13:23:33.070]             base::options(...future.oldOptions)
[13:23:33.070]             if (.Platform$OS.type == "windows") {
[13:23:33.070]                 old_names <- names(...future.oldEnvVars)
[13:23:33.070]                 envs <- base::Sys.getenv()
[13:23:33.070]                 names <- names(envs)
[13:23:33.070]                 common <- intersect(names, old_names)
[13:23:33.070]                 added <- setdiff(names, old_names)
[13:23:33.070]                 removed <- setdiff(old_names, names)
[13:23:33.070]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.070]                   envs[common]]
[13:23:33.070]                 NAMES <- toupper(changed)
[13:23:33.070]                 args <- list()
[13:23:33.070]                 for (kk in seq_along(NAMES)) {
[13:23:33.070]                   name <- changed[[kk]]
[13:23:33.070]                   NAME <- NAMES[[kk]]
[13:23:33.070]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.070]                     next
[13:23:33.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.070]                 }
[13:23:33.070]                 NAMES <- toupper(added)
[13:23:33.070]                 for (kk in seq_along(NAMES)) {
[13:23:33.070]                   name <- added[[kk]]
[13:23:33.070]                   NAME <- NAMES[[kk]]
[13:23:33.070]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.070]                     next
[13:23:33.070]                   args[[name]] <- ""
[13:23:33.070]                 }
[13:23:33.070]                 NAMES <- toupper(removed)
[13:23:33.070]                 for (kk in seq_along(NAMES)) {
[13:23:33.070]                   name <- removed[[kk]]
[13:23:33.070]                   NAME <- NAMES[[kk]]
[13:23:33.070]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.070]                     next
[13:23:33.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.070]                 }
[13:23:33.070]                 if (length(args) > 0) 
[13:23:33.070]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.070]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.070]             }
[13:23:33.070]             else {
[13:23:33.070]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.070]             }
[13:23:33.070]             {
[13:23:33.070]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.070]                   0L) {
[13:23:33.070]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.070]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.070]                   base::options(opts)
[13:23:33.070]                 }
[13:23:33.070]                 {
[13:23:33.070]                   {
[13:23:33.070]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:33.070]                     NULL
[13:23:33.070]                   }
[13:23:33.070]                   options(future.plan = NULL)
[13:23:33.070]                   if (is.na(NA_character_)) 
[13:23:33.070]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.070]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.070]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.070]                     envir = parent.frame()) 
[13:23:33.070]                   {
[13:23:33.070]                     default_workers <- missing(workers)
[13:23:33.070]                     if (is.function(workers)) 
[13:23:33.070]                       workers <- workers()
[13:23:33.070]                     workers <- structure(as.integer(workers), 
[13:23:33.070]                       class = class(workers))
[13:23:33.070]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.070]                       1L)
[13:23:33.070]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.070]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.070]                       if (default_workers) 
[13:23:33.070]                         supportsMulticore(warn = TRUE)
[13:23:33.070]                       return(sequential(..., envir = envir))
[13:23:33.070]                     }
[13:23:33.070]                     oopts <- options(mc.cores = workers)
[13:23:33.070]                     on.exit(options(oopts))
[13:23:33.070]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.070]                       envir = envir)
[13:23:33.070]                     if (!future$lazy) 
[13:23:33.070]                       future <- run(future)
[13:23:33.070]                     invisible(future)
[13:23:33.070]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.070]                 }
[13:23:33.070]             }
[13:23:33.070]         }
[13:23:33.070]     })
[13:23:33.070]     if (TRUE) {
[13:23:33.070]         base::sink(type = "output", split = FALSE)
[13:23:33.070]         if (TRUE) {
[13:23:33.070]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.070]         }
[13:23:33.070]         else {
[13:23:33.070]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.070]         }
[13:23:33.070]         base::close(...future.stdout)
[13:23:33.070]         ...future.stdout <- NULL
[13:23:33.070]     }
[13:23:33.070]     ...future.result$conditions <- ...future.conditions
[13:23:33.070]     ...future.result$finished <- base::Sys.time()
[13:23:33.070]     ...future.result
[13:23:33.070] }
[13:23:33.073] requestCore(): workers = 2
[13:23:33.075] MulticoreFuture started
[13:23:33.076] - Launch lazy future ... done
[13:23:33.076] run() for ‘MulticoreFuture’ ... done
[13:23:33.076] plan(): Setting new future strategy stack:
[13:23:33.077] List of future strategies:
[13:23:33.077] 1. sequential:
[13:23:33.077]    - args: function (..., envir = parent.frame())
[13:23:33.077]    - tweaked: FALSE
[13:23:33.077]    - call: NULL
[13:23:33.078] plan(): nbrOfWorkers() = 1
[13:23:33.081] plan(): Setting new future strategy stack:
[13:23:33.081] List of future strategies:
[13:23:33.081] 1. multicore:
[13:23:33.081]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:33.081]    - tweaked: FALSE
[13:23:33.081]    - call: plan(strategy)
[13:23:33.087] plan(): nbrOfWorkers() = 2
[13:23:33.097] Future #1
[13:23:33.098] result() for MulticoreFuture ...
[13:23:33.099] result() for MulticoreFuture ...
[13:23:33.099] result() for MulticoreFuture ... done
[13:23:33.099] result() for MulticoreFuture ... done
[13:23:33.099] result() for MulticoreFuture ...
[13:23:33.099] result() for MulticoreFuture ... done
[13:23:33.100] A MulticoreFuture was resolved
[13:23:33.100]  length: 0 (resolved future 1)
[13:23:33.100] resolve() on list ... DONE
[13:23:33.100] - globals: [1] ‘a’
[13:23:33.101] Resolving futures part of globals (recursively) ... DONE
[13:23:33.102] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[13:23:33.103] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[13:23:33.103] - globals: [1] ‘a’
[13:23:33.103] - packages: [1] ‘future’
[13:23:33.103] getGlobalsAndPackages() ... DONE
[13:23:33.104] run() for ‘Future’ ...
[13:23:33.104] - state: ‘created’
[13:23:33.104] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:33.109] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:33.109] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:33.109]   - Field: ‘label’
[13:23:33.109]   - Field: ‘local’
[13:23:33.109]   - Field: ‘owner’
[13:23:33.109]   - Field: ‘envir’
[13:23:33.109]   - Field: ‘workers’
[13:23:33.110]   - Field: ‘packages’
[13:23:33.110]   - Field: ‘gc’
[13:23:33.110]   - Field: ‘job’
[13:23:33.110]   - Field: ‘conditions’
[13:23:33.110]   - Field: ‘expr’
[13:23:33.110]   - Field: ‘uuid’
[13:23:33.110]   - Field: ‘seed’
[13:23:33.110]   - Field: ‘version’
[13:23:33.111]   - Field: ‘result’
[13:23:33.111]   - Field: ‘asynchronous’
[13:23:33.111]   - Field: ‘calls’
[13:23:33.111]   - Field: ‘globals’
[13:23:33.111]   - Field: ‘stdout’
[13:23:33.111]   - Field: ‘earlySignal’
[13:23:33.111]   - Field: ‘lazy’
[13:23:33.111]   - Field: ‘state’
[13:23:33.112] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:33.112] - Launch lazy future ...
[13:23:33.112] Packages needed by the future expression (n = 1): ‘future’
[13:23:33.112] Packages needed by future strategies (n = 0): <none>
[13:23:33.113] {
[13:23:33.113]     {
[13:23:33.113]         {
[13:23:33.113]             ...future.startTime <- base::Sys.time()
[13:23:33.113]             {
[13:23:33.113]                 {
[13:23:33.113]                   {
[13:23:33.113]                     {
[13:23:33.113]                       {
[13:23:33.113]                         base::local({
[13:23:33.113]                           has_future <- base::requireNamespace("future", 
[13:23:33.113]                             quietly = TRUE)
[13:23:33.113]                           if (has_future) {
[13:23:33.113]                             ns <- base::getNamespace("future")
[13:23:33.113]                             version <- ns[[".package"]][["version"]]
[13:23:33.113]                             if (is.null(version)) 
[13:23:33.113]                               version <- utils::packageVersion("future")
[13:23:33.113]                           }
[13:23:33.113]                           else {
[13:23:33.113]                             version <- NULL
[13:23:33.113]                           }
[13:23:33.113]                           if (!has_future || version < "1.8.0") {
[13:23:33.113]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.113]                               "", base::R.version$version.string), 
[13:23:33.113]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:33.113]                                 base::R.version$platform, 8 * 
[13:23:33.113]                                   base::.Machine$sizeof.pointer), 
[13:23:33.113]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.113]                                 "release", "version")], collapse = " "), 
[13:23:33.113]                               hostname = base::Sys.info()[["nodename"]])
[13:23:33.113]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.113]                               info)
[13:23:33.113]                             info <- base::paste(info, collapse = "; ")
[13:23:33.113]                             if (!has_future) {
[13:23:33.113]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.113]                                 info)
[13:23:33.113]                             }
[13:23:33.113]                             else {
[13:23:33.113]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.113]                                 info, version)
[13:23:33.113]                             }
[13:23:33.113]                             base::stop(msg)
[13:23:33.113]                           }
[13:23:33.113]                         })
[13:23:33.113]                       }
[13:23:33.113]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:33.113]                       base::options(mc.cores = 1L)
[13:23:33.113]                     }
[13:23:33.113]                     base::local({
[13:23:33.113]                       for (pkg in "future") {
[13:23:33.113]                         base::loadNamespace(pkg)
[13:23:33.113]                         base::library(pkg, character.only = TRUE)
[13:23:33.113]                       }
[13:23:33.113]                     })
[13:23:33.113]                   }
[13:23:33.113]                   options(future.plan = NULL)
[13:23:33.113]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.113]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.113]                 }
[13:23:33.113]                 ...future.workdir <- getwd()
[13:23:33.113]             }
[13:23:33.113]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.113]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.113]         }
[13:23:33.113]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.113]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:33.113]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.113]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.113]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.113]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.113]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.113]             base::names(...future.oldOptions))
[13:23:33.113]     }
[13:23:33.113]     if (FALSE) {
[13:23:33.113]     }
[13:23:33.113]     else {
[13:23:33.113]         if (TRUE) {
[13:23:33.113]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.113]                 open = "w")
[13:23:33.113]         }
[13:23:33.113]         else {
[13:23:33.113]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.113]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.113]         }
[13:23:33.113]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.113]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.113]             base::sink(type = "output", split = FALSE)
[13:23:33.113]             base::close(...future.stdout)
[13:23:33.113]         }, add = TRUE)
[13:23:33.113]     }
[13:23:33.113]     ...future.frame <- base::sys.nframe()
[13:23:33.113]     ...future.conditions <- base::list()
[13:23:33.113]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.113]     if (FALSE) {
[13:23:33.113]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.113]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.113]     }
[13:23:33.113]     ...future.result <- base::tryCatch({
[13:23:33.113]         base::withCallingHandlers({
[13:23:33.113]             ...future.value <- base::withVisible(base::local({
[13:23:33.113]                 withCallingHandlers({
[13:23:33.113]                   value(a) + 1
[13:23:33.113]                 }, immediateCondition = function(cond) {
[13:23:33.113]                   save_rds <- function (object, pathname, ...) 
[13:23:33.113]                   {
[13:23:33.113]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:33.113]                     if (file_test("-f", pathname_tmp)) {
[13:23:33.113]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.113]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:33.113]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.113]                         fi_tmp[["mtime"]])
[13:23:33.113]                     }
[13:23:33.113]                     tryCatch({
[13:23:33.113]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:33.113]                     }, error = function(ex) {
[13:23:33.113]                       msg <- conditionMessage(ex)
[13:23:33.113]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.113]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:33.113]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.113]                         fi_tmp[["mtime"]], msg)
[13:23:33.113]                       ex$message <- msg
[13:23:33.113]                       stop(ex)
[13:23:33.113]                     })
[13:23:33.113]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:33.113]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:33.113]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:33.113]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.113]                       fi <- file.info(pathname)
[13:23:33.113]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:33.113]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.113]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:33.113]                         fi[["size"]], fi[["mtime"]])
[13:23:33.113]                       stop(msg)
[13:23:33.113]                     }
[13:23:33.113]                     invisible(pathname)
[13:23:33.113]                   }
[13:23:33.113]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:33.113]                     rootPath = tempdir()) 
[13:23:33.113]                   {
[13:23:33.113]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:33.113]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:33.113]                       tmpdir = path, fileext = ".rds")
[13:23:33.113]                     save_rds(obj, file)
[13:23:33.113]                   }
[13:23:33.113]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:33.113]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.113]                   {
[13:23:33.113]                     inherits <- base::inherits
[13:23:33.113]                     invokeRestart <- base::invokeRestart
[13:23:33.113]                     is.null <- base::is.null
[13:23:33.113]                     muffled <- FALSE
[13:23:33.113]                     if (inherits(cond, "message")) {
[13:23:33.113]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:33.113]                       if (muffled) 
[13:23:33.113]                         invokeRestart("muffleMessage")
[13:23:33.113]                     }
[13:23:33.113]                     else if (inherits(cond, "warning")) {
[13:23:33.113]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:33.113]                       if (muffled) 
[13:23:33.113]                         invokeRestart("muffleWarning")
[13:23:33.113]                     }
[13:23:33.113]                     else if (inherits(cond, "condition")) {
[13:23:33.113]                       if (!is.null(pattern)) {
[13:23:33.113]                         computeRestarts <- base::computeRestarts
[13:23:33.113]                         grepl <- base::grepl
[13:23:33.113]                         restarts <- computeRestarts(cond)
[13:23:33.113]                         for (restart in restarts) {
[13:23:33.113]                           name <- restart$name
[13:23:33.113]                           if (is.null(name)) 
[13:23:33.113]                             next
[13:23:33.113]                           if (!grepl(pattern, name)) 
[13:23:33.113]                             next
[13:23:33.113]                           invokeRestart(restart)
[13:23:33.113]                           muffled <- TRUE
[13:23:33.113]                           break
[13:23:33.113]                         }
[13:23:33.113]                       }
[13:23:33.113]                     }
[13:23:33.113]                     invisible(muffled)
[13:23:33.113]                   }
[13:23:33.113]                   muffleCondition(cond)
[13:23:33.113]                 })
[13:23:33.113]             }))
[13:23:33.113]             future::FutureResult(value = ...future.value$value, 
[13:23:33.113]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.113]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.113]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.113]                     ...future.globalenv.names))
[13:23:33.113]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.113]         }, condition = base::local({
[13:23:33.113]             c <- base::c
[13:23:33.113]             inherits <- base::inherits
[13:23:33.113]             invokeRestart <- base::invokeRestart
[13:23:33.113]             length <- base::length
[13:23:33.113]             list <- base::list
[13:23:33.113]             seq.int <- base::seq.int
[13:23:33.113]             signalCondition <- base::signalCondition
[13:23:33.113]             sys.calls <- base::sys.calls
[13:23:33.113]             `[[` <- base::`[[`
[13:23:33.113]             `+` <- base::`+`
[13:23:33.113]             `<<-` <- base::`<<-`
[13:23:33.113]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.113]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.113]                   3L)]
[13:23:33.113]             }
[13:23:33.113]             function(cond) {
[13:23:33.113]                 is_error <- inherits(cond, "error")
[13:23:33.113]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.113]                   NULL)
[13:23:33.113]                 if (is_error) {
[13:23:33.113]                   sessionInformation <- function() {
[13:23:33.113]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.113]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.113]                       search = base::search(), system = base::Sys.info())
[13:23:33.113]                   }
[13:23:33.113]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.113]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.113]                     cond$call), session = sessionInformation(), 
[13:23:33.113]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.113]                   signalCondition(cond)
[13:23:33.113]                 }
[13:23:33.113]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.113]                 "immediateCondition"))) {
[13:23:33.113]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.113]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.113]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.113]                   if (TRUE && !signal) {
[13:23:33.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.113]                     {
[13:23:33.113]                       inherits <- base::inherits
[13:23:33.113]                       invokeRestart <- base::invokeRestart
[13:23:33.113]                       is.null <- base::is.null
[13:23:33.113]                       muffled <- FALSE
[13:23:33.113]                       if (inherits(cond, "message")) {
[13:23:33.113]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.113]                         if (muffled) 
[13:23:33.113]                           invokeRestart("muffleMessage")
[13:23:33.113]                       }
[13:23:33.113]                       else if (inherits(cond, "warning")) {
[13:23:33.113]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.113]                         if (muffled) 
[13:23:33.113]                           invokeRestart("muffleWarning")
[13:23:33.113]                       }
[13:23:33.113]                       else if (inherits(cond, "condition")) {
[13:23:33.113]                         if (!is.null(pattern)) {
[13:23:33.113]                           computeRestarts <- base::computeRestarts
[13:23:33.113]                           grepl <- base::grepl
[13:23:33.113]                           restarts <- computeRestarts(cond)
[13:23:33.113]                           for (restart in restarts) {
[13:23:33.113]                             name <- restart$name
[13:23:33.113]                             if (is.null(name)) 
[13:23:33.113]                               next
[13:23:33.113]                             if (!grepl(pattern, name)) 
[13:23:33.113]                               next
[13:23:33.113]                             invokeRestart(restart)
[13:23:33.113]                             muffled <- TRUE
[13:23:33.113]                             break
[13:23:33.113]                           }
[13:23:33.113]                         }
[13:23:33.113]                       }
[13:23:33.113]                       invisible(muffled)
[13:23:33.113]                     }
[13:23:33.113]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.113]                   }
[13:23:33.113]                 }
[13:23:33.113]                 else {
[13:23:33.113]                   if (TRUE) {
[13:23:33.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.113]                     {
[13:23:33.113]                       inherits <- base::inherits
[13:23:33.113]                       invokeRestart <- base::invokeRestart
[13:23:33.113]                       is.null <- base::is.null
[13:23:33.113]                       muffled <- FALSE
[13:23:33.113]                       if (inherits(cond, "message")) {
[13:23:33.113]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.113]                         if (muffled) 
[13:23:33.113]                           invokeRestart("muffleMessage")
[13:23:33.113]                       }
[13:23:33.113]                       else if (inherits(cond, "warning")) {
[13:23:33.113]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.113]                         if (muffled) 
[13:23:33.113]                           invokeRestart("muffleWarning")
[13:23:33.113]                       }
[13:23:33.113]                       else if (inherits(cond, "condition")) {
[13:23:33.113]                         if (!is.null(pattern)) {
[13:23:33.113]                           computeRestarts <- base::computeRestarts
[13:23:33.113]                           grepl <- base::grepl
[13:23:33.113]                           restarts <- computeRestarts(cond)
[13:23:33.113]                           for (restart in restarts) {
[13:23:33.113]                             name <- restart$name
[13:23:33.113]                             if (is.null(name)) 
[13:23:33.113]                               next
[13:23:33.113]                             if (!grepl(pattern, name)) 
[13:23:33.113]                               next
[13:23:33.113]                             invokeRestart(restart)
[13:23:33.113]                             muffled <- TRUE
[13:23:33.113]                             break
[13:23:33.113]                           }
[13:23:33.113]                         }
[13:23:33.113]                       }
[13:23:33.113]                       invisible(muffled)
[13:23:33.113]                     }
[13:23:33.113]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.113]                   }
[13:23:33.113]                 }
[13:23:33.113]             }
[13:23:33.113]         }))
[13:23:33.113]     }, error = function(ex) {
[13:23:33.113]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.113]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.113]                 ...future.rng), started = ...future.startTime, 
[13:23:33.113]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.113]             version = "1.8"), class = "FutureResult")
[13:23:33.113]     }, finally = {
[13:23:33.113]         if (!identical(...future.workdir, getwd())) 
[13:23:33.113]             setwd(...future.workdir)
[13:23:33.113]         {
[13:23:33.113]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.113]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.113]             }
[13:23:33.113]             base::options(...future.oldOptions)
[13:23:33.113]             if (.Platform$OS.type == "windows") {
[13:23:33.113]                 old_names <- names(...future.oldEnvVars)
[13:23:33.113]                 envs <- base::Sys.getenv()
[13:23:33.113]                 names <- names(envs)
[13:23:33.113]                 common <- intersect(names, old_names)
[13:23:33.113]                 added <- setdiff(names, old_names)
[13:23:33.113]                 removed <- setdiff(old_names, names)
[13:23:33.113]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.113]                   envs[common]]
[13:23:33.113]                 NAMES <- toupper(changed)
[13:23:33.113]                 args <- list()
[13:23:33.113]                 for (kk in seq_along(NAMES)) {
[13:23:33.113]                   name <- changed[[kk]]
[13:23:33.113]                   NAME <- NAMES[[kk]]
[13:23:33.113]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.113]                     next
[13:23:33.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.113]                 }
[13:23:33.113]                 NAMES <- toupper(added)
[13:23:33.113]                 for (kk in seq_along(NAMES)) {
[13:23:33.113]                   name <- added[[kk]]
[13:23:33.113]                   NAME <- NAMES[[kk]]
[13:23:33.113]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.113]                     next
[13:23:33.113]                   args[[name]] <- ""
[13:23:33.113]                 }
[13:23:33.113]                 NAMES <- toupper(removed)
[13:23:33.113]                 for (kk in seq_along(NAMES)) {
[13:23:33.113]                   name <- removed[[kk]]
[13:23:33.113]                   NAME <- NAMES[[kk]]
[13:23:33.113]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.113]                     next
[13:23:33.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.113]                 }
[13:23:33.113]                 if (length(args) > 0) 
[13:23:33.113]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.113]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.113]             }
[13:23:33.113]             else {
[13:23:33.113]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.113]             }
[13:23:33.113]             {
[13:23:33.113]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.113]                   0L) {
[13:23:33.113]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.113]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.113]                   base::options(opts)
[13:23:33.113]                 }
[13:23:33.113]                 {
[13:23:33.113]                   {
[13:23:33.113]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:33.113]                     NULL
[13:23:33.113]                   }
[13:23:33.113]                   options(future.plan = NULL)
[13:23:33.113]                   if (is.na(NA_character_)) 
[13:23:33.113]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.113]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.113]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.113]                     envir = parent.frame()) 
[13:23:33.113]                   {
[13:23:33.113]                     default_workers <- missing(workers)
[13:23:33.113]                     if (is.function(workers)) 
[13:23:33.113]                       workers <- workers()
[13:23:33.113]                     workers <- structure(as.integer(workers), 
[13:23:33.113]                       class = class(workers))
[13:23:33.113]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.113]                       1L)
[13:23:33.113]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.113]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.113]                       if (default_workers) 
[13:23:33.113]                         supportsMulticore(warn = TRUE)
[13:23:33.113]                       return(sequential(..., envir = envir))
[13:23:33.113]                     }
[13:23:33.113]                     oopts <- options(mc.cores = workers)
[13:23:33.113]                     on.exit(options(oopts))
[13:23:33.113]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.113]                       envir = envir)
[13:23:33.113]                     if (!future$lazy) 
[13:23:33.113]                       future <- run(future)
[13:23:33.113]                     invisible(future)
[13:23:33.113]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.113]                 }
[13:23:33.113]             }
[13:23:33.113]         }
[13:23:33.113]     })
[13:23:33.113]     if (TRUE) {
[13:23:33.113]         base::sink(type = "output", split = FALSE)
[13:23:33.113]         if (TRUE) {
[13:23:33.113]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.113]         }
[13:23:33.113]         else {
[13:23:33.113]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.113]         }
[13:23:33.113]         base::close(...future.stdout)
[13:23:33.113]         ...future.stdout <- NULL
[13:23:33.113]     }
[13:23:33.113]     ...future.result$conditions <- ...future.conditions
[13:23:33.113]     ...future.result$finished <- base::Sys.time()
[13:23:33.113]     ...future.result
[13:23:33.113] }
[13:23:33.116] assign_globals() ...
[13:23:33.116] List of 1
[13:23:33.116]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5589bf0bb660> 
[13:23:33.116]  - attr(*, "where")=List of 1
[13:23:33.116]   ..$ a:<environment: R_EmptyEnv> 
[13:23:33.116]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:33.116]  - attr(*, "resolved")= logi TRUE
[13:23:33.116]  - attr(*, "total_size")= num 10984
[13:23:33.116]  - attr(*, "already-done")= logi TRUE
[13:23:33.120] - copied ‘a’ to environment
[13:23:33.120] assign_globals() ... done
[13:23:33.120] requestCore(): workers = 2
[13:23:33.122] MulticoreFuture started
[13:23:33.123] - Launch lazy future ... done
[13:23:33.123] run() for ‘MulticoreFuture’ ... done
[13:23:33.123] result() for MulticoreFuture ...
[13:23:33.124] plan(): Setting new future strategy stack:
[13:23:33.124] List of future strategies:
[13:23:33.124] 1. sequential:
[13:23:33.124]    - args: function (..., envir = parent.frame())
[13:23:33.124]    - tweaked: FALSE
[13:23:33.124]    - call: NULL
[13:23:33.125] plan(): nbrOfWorkers() = 1
[13:23:33.128] plan(): Setting new future strategy stack:
[13:23:33.128] List of future strategies:
[13:23:33.128] 1. multicore:
[13:23:33.128]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:33.128]    - tweaked: FALSE
[13:23:33.128]    - call: plan(strategy)
[13:23:33.140] plan(): nbrOfWorkers() = 2
[13:23:33.141] result() for MulticoreFuture ...
[13:23:33.141] result() for MulticoreFuture ... done
[13:23:33.141] signalConditions() ...
[13:23:33.141]  - include = ‘immediateCondition’
[13:23:33.142]  - exclude = 
[13:23:33.142]  - resignal = FALSE
[13:23:33.142]  - Number of conditions: 4
[13:23:33.142] signalConditions() ... done
[13:23:33.142] result() for MulticoreFuture ... done
[13:23:33.142] result() for MulticoreFuture ...
[13:23:33.142] result() for MulticoreFuture ... done
[13:23:33.142] signalConditions() ...
[13:23:33.143]  - include = ‘immediateCondition’
[13:23:33.143]  - exclude = 
[13:23:33.143]  - resignal = FALSE
[13:23:33.143]  - Number of conditions: 4
[13:23:33.143] signalConditions() ... done
[13:23:33.143] Future state: ‘finished’
[13:23:33.143] result() for MulticoreFuture ...
[13:23:33.144] result() for MulticoreFuture ... done
[13:23:33.144] signalConditions() ...
[13:23:33.144]  - include = ‘condition’
[13:23:33.147]  - exclude = ‘immediateCondition’
[13:23:33.147]  - resignal = TRUE
[13:23:33.148]  - Number of conditions: 4
[13:23:33.148]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.126] result() for MulticoreFuture ...
[13:23:33.148]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.127] result() for MulticoreFuture ... done
[13:23:33.148]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.127] result() for MulticoreFuture ...
[13:23:33.149]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.127] result() for MulticoreFuture ... done
[13:23:33.149] signalConditions() ... done
value(b) = 2
[13:23:33.149] result() for MulticoreFuture ...
[13:23:33.150] result() for MulticoreFuture ... done
[13:23:33.150] result() for MulticoreFuture ...
[13:23:33.150] result() for MulticoreFuture ... done
[13:23:33.150] signalConditions() ...
[13:23:33.150]  - include = ‘immediateCondition’
[13:23:33.151]  - exclude = 
[13:23:33.151]  - resignal = FALSE
[13:23:33.151]  - Number of conditions: 4
[13:23:33.151] signalConditions() ... done
[13:23:33.151] Future state: ‘finished’
[13:23:33.151] result() for MulticoreFuture ...
[13:23:33.151] result() for MulticoreFuture ... done
[13:23:33.152] signalConditions() ...
[13:23:33.152]  - include = ‘condition’
[13:23:33.152]  - exclude = ‘immediateCondition’
[13:23:33.152]  - resignal = TRUE
[13:23:33.152]  - Number of conditions: 4
[13:23:33.152]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.126] result() for MulticoreFuture ...
[13:23:33.152]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.127] result() for MulticoreFuture ... done
[13:23:33.153]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.127] result() for MulticoreFuture ...
[13:23:33.153]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.127] result() for MulticoreFuture ... done
[13:23:33.153] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:33.153] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:33.154] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:33.155] - globals found: [2] ‘{’, ‘pkg’
[13:23:33.155] Searching for globals ... DONE
[13:23:33.155] Resolving globals: TRUE
[13:23:33.155] Resolving any globals that are futures ...
[13:23:33.155] - globals: [2] ‘{’, ‘pkg’
[13:23:33.156] Resolving any globals that are futures ... DONE
[13:23:33.156] Resolving futures part of globals (recursively) ...
[13:23:33.156] resolve() on list ...
[13:23:33.156]  recursive: 99
[13:23:33.157]  length: 1
[13:23:33.157]  elements: ‘pkg’
[13:23:33.157]  length: 0 (resolved future 1)
[13:23:33.157] resolve() on list ... DONE
[13:23:33.157] - globals: [1] ‘pkg’
[13:23:33.157] Resolving futures part of globals (recursively) ... DONE
[13:23:33.157] The total size of the 1 globals is 112 bytes (112 bytes)
[13:23:33.158] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[13:23:33.158] - globals: [1] ‘pkg’
[13:23:33.158] 
[13:23:33.158] getGlobalsAndPackages() ... DONE
[13:23:33.159] Packages needed by the future expression (n = 0): <none>
[13:23:33.159] Packages needed by future strategies (n = 0): <none>
[13:23:33.159] {
[13:23:33.159]     {
[13:23:33.159]         {
[13:23:33.159]             ...future.startTime <- base::Sys.time()
[13:23:33.159]             {
[13:23:33.159]                 {
[13:23:33.159]                   {
[13:23:33.159]                     base::local({
[13:23:33.159]                       has_future <- base::requireNamespace("future", 
[13:23:33.159]                         quietly = TRUE)
[13:23:33.159]                       if (has_future) {
[13:23:33.159]                         ns <- base::getNamespace("future")
[13:23:33.159]                         version <- ns[[".package"]][["version"]]
[13:23:33.159]                         if (is.null(version)) 
[13:23:33.159]                           version <- utils::packageVersion("future")
[13:23:33.159]                       }
[13:23:33.159]                       else {
[13:23:33.159]                         version <- NULL
[13:23:33.159]                       }
[13:23:33.159]                       if (!has_future || version < "1.8.0") {
[13:23:33.159]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.159]                           "", base::R.version$version.string), 
[13:23:33.159]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:33.159]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:33.159]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.159]                             "release", "version")], collapse = " "), 
[13:23:33.159]                           hostname = base::Sys.info()[["nodename"]])
[13:23:33.159]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.159]                           info)
[13:23:33.159]                         info <- base::paste(info, collapse = "; ")
[13:23:33.159]                         if (!has_future) {
[13:23:33.159]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.159]                             info)
[13:23:33.159]                         }
[13:23:33.159]                         else {
[13:23:33.159]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.159]                             info, version)
[13:23:33.159]                         }
[13:23:33.159]                         base::stop(msg)
[13:23:33.159]                       }
[13:23:33.159]                     })
[13:23:33.159]                   }
[13:23:33.159]                   options(future.plan = NULL)
[13:23:33.159]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.159]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.159]                 }
[13:23:33.159]                 ...future.workdir <- getwd()
[13:23:33.159]             }
[13:23:33.159]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.159]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.159]         }
[13:23:33.159]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.159]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:33.159]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.159]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.159]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.159]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.159]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.159]             base::names(...future.oldOptions))
[13:23:33.159]     }
[13:23:33.159]     if (FALSE) {
[13:23:33.159]     }
[13:23:33.159]     else {
[13:23:33.159]         if (TRUE) {
[13:23:33.159]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.159]                 open = "w")
[13:23:33.159]         }
[13:23:33.159]         else {
[13:23:33.159]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.159]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.159]         }
[13:23:33.159]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.159]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.159]             base::sink(type = "output", split = FALSE)
[13:23:33.159]             base::close(...future.stdout)
[13:23:33.159]         }, add = TRUE)
[13:23:33.159]     }
[13:23:33.159]     ...future.frame <- base::sys.nframe()
[13:23:33.159]     ...future.conditions <- base::list()
[13:23:33.159]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.159]     if (FALSE) {
[13:23:33.159]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.159]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.159]     }
[13:23:33.159]     ...future.result <- base::tryCatch({
[13:23:33.159]         base::withCallingHandlers({
[13:23:33.159]             ...future.value <- base::withVisible(base::local({
[13:23:33.159]                 pkg
[13:23:33.159]             }))
[13:23:33.159]             future::FutureResult(value = ...future.value$value, 
[13:23:33.159]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.159]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.159]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.159]                     ...future.globalenv.names))
[13:23:33.159]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.159]         }, condition = base::local({
[13:23:33.159]             c <- base::c
[13:23:33.159]             inherits <- base::inherits
[13:23:33.159]             invokeRestart <- base::invokeRestart
[13:23:33.159]             length <- base::length
[13:23:33.159]             list <- base::list
[13:23:33.159]             seq.int <- base::seq.int
[13:23:33.159]             signalCondition <- base::signalCondition
[13:23:33.159]             sys.calls <- base::sys.calls
[13:23:33.159]             `[[` <- base::`[[`
[13:23:33.159]             `+` <- base::`+`
[13:23:33.159]             `<<-` <- base::`<<-`
[13:23:33.159]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.159]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.159]                   3L)]
[13:23:33.159]             }
[13:23:33.159]             function(cond) {
[13:23:33.159]                 is_error <- inherits(cond, "error")
[13:23:33.159]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.159]                   NULL)
[13:23:33.159]                 if (is_error) {
[13:23:33.159]                   sessionInformation <- function() {
[13:23:33.159]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.159]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.159]                       search = base::search(), system = base::Sys.info())
[13:23:33.159]                   }
[13:23:33.159]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.159]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.159]                     cond$call), session = sessionInformation(), 
[13:23:33.159]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.159]                   signalCondition(cond)
[13:23:33.159]                 }
[13:23:33.159]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.159]                 "immediateCondition"))) {
[13:23:33.159]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.159]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.159]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.159]                   if (TRUE && !signal) {
[13:23:33.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.159]                     {
[13:23:33.159]                       inherits <- base::inherits
[13:23:33.159]                       invokeRestart <- base::invokeRestart
[13:23:33.159]                       is.null <- base::is.null
[13:23:33.159]                       muffled <- FALSE
[13:23:33.159]                       if (inherits(cond, "message")) {
[13:23:33.159]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.159]                         if (muffled) 
[13:23:33.159]                           invokeRestart("muffleMessage")
[13:23:33.159]                       }
[13:23:33.159]                       else if (inherits(cond, "warning")) {
[13:23:33.159]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.159]                         if (muffled) 
[13:23:33.159]                           invokeRestart("muffleWarning")
[13:23:33.159]                       }
[13:23:33.159]                       else if (inherits(cond, "condition")) {
[13:23:33.159]                         if (!is.null(pattern)) {
[13:23:33.159]                           computeRestarts <- base::computeRestarts
[13:23:33.159]                           grepl <- base::grepl
[13:23:33.159]                           restarts <- computeRestarts(cond)
[13:23:33.159]                           for (restart in restarts) {
[13:23:33.159]                             name <- restart$name
[13:23:33.159]                             if (is.null(name)) 
[13:23:33.159]                               next
[13:23:33.159]                             if (!grepl(pattern, name)) 
[13:23:33.159]                               next
[13:23:33.159]                             invokeRestart(restart)
[13:23:33.159]                             muffled <- TRUE
[13:23:33.159]                             break
[13:23:33.159]                           }
[13:23:33.159]                         }
[13:23:33.159]                       }
[13:23:33.159]                       invisible(muffled)
[13:23:33.159]                     }
[13:23:33.159]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.159]                   }
[13:23:33.159]                 }
[13:23:33.159]                 else {
[13:23:33.159]                   if (TRUE) {
[13:23:33.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.159]                     {
[13:23:33.159]                       inherits <- base::inherits
[13:23:33.159]                       invokeRestart <- base::invokeRestart
[13:23:33.159]                       is.null <- base::is.null
[13:23:33.159]                       muffled <- FALSE
[13:23:33.159]                       if (inherits(cond, "message")) {
[13:23:33.159]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.159]                         if (muffled) 
[13:23:33.159]                           invokeRestart("muffleMessage")
[13:23:33.159]                       }
[13:23:33.159]                       else if (inherits(cond, "warning")) {
[13:23:33.159]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.159]                         if (muffled) 
[13:23:33.159]                           invokeRestart("muffleWarning")
[13:23:33.159]                       }
[13:23:33.159]                       else if (inherits(cond, "condition")) {
[13:23:33.159]                         if (!is.null(pattern)) {
[13:23:33.159]                           computeRestarts <- base::computeRestarts
[13:23:33.159]                           grepl <- base::grepl
[13:23:33.159]                           restarts <- computeRestarts(cond)
[13:23:33.159]                           for (restart in restarts) {
[13:23:33.159]                             name <- restart$name
[13:23:33.159]                             if (is.null(name)) 
[13:23:33.159]                               next
[13:23:33.159]                             if (!grepl(pattern, name)) 
[13:23:33.159]                               next
[13:23:33.159]                             invokeRestart(restart)
[13:23:33.159]                             muffled <- TRUE
[13:23:33.159]                             break
[13:23:33.159]                           }
[13:23:33.159]                         }
[13:23:33.159]                       }
[13:23:33.159]                       invisible(muffled)
[13:23:33.159]                     }
[13:23:33.159]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.159]                   }
[13:23:33.159]                 }
[13:23:33.159]             }
[13:23:33.159]         }))
[13:23:33.159]     }, error = function(ex) {
[13:23:33.159]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.159]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.159]                 ...future.rng), started = ...future.startTime, 
[13:23:33.159]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.159]             version = "1.8"), class = "FutureResult")
[13:23:33.159]     }, finally = {
[13:23:33.159]         if (!identical(...future.workdir, getwd())) 
[13:23:33.159]             setwd(...future.workdir)
[13:23:33.159]         {
[13:23:33.159]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.159]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.159]             }
[13:23:33.159]             base::options(...future.oldOptions)
[13:23:33.159]             if (.Platform$OS.type == "windows") {
[13:23:33.159]                 old_names <- names(...future.oldEnvVars)
[13:23:33.159]                 envs <- base::Sys.getenv()
[13:23:33.159]                 names <- names(envs)
[13:23:33.159]                 common <- intersect(names, old_names)
[13:23:33.159]                 added <- setdiff(names, old_names)
[13:23:33.159]                 removed <- setdiff(old_names, names)
[13:23:33.159]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.159]                   envs[common]]
[13:23:33.159]                 NAMES <- toupper(changed)
[13:23:33.159]                 args <- list()
[13:23:33.159]                 for (kk in seq_along(NAMES)) {
[13:23:33.159]                   name <- changed[[kk]]
[13:23:33.159]                   NAME <- NAMES[[kk]]
[13:23:33.159]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.159]                     next
[13:23:33.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.159]                 }
[13:23:33.159]                 NAMES <- toupper(added)
[13:23:33.159]                 for (kk in seq_along(NAMES)) {
[13:23:33.159]                   name <- added[[kk]]
[13:23:33.159]                   NAME <- NAMES[[kk]]
[13:23:33.159]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.159]                     next
[13:23:33.159]                   args[[name]] <- ""
[13:23:33.159]                 }
[13:23:33.159]                 NAMES <- toupper(removed)
[13:23:33.159]                 for (kk in seq_along(NAMES)) {
[13:23:33.159]                   name <- removed[[kk]]
[13:23:33.159]                   NAME <- NAMES[[kk]]
[13:23:33.159]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.159]                     next
[13:23:33.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.159]                 }
[13:23:33.159]                 if (length(args) > 0) 
[13:23:33.159]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.159]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.159]             }
[13:23:33.159]             else {
[13:23:33.159]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.159]             }
[13:23:33.159]             {
[13:23:33.159]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.159]                   0L) {
[13:23:33.159]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.159]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.159]                   base::options(opts)
[13:23:33.159]                 }
[13:23:33.159]                 {
[13:23:33.159]                   {
[13:23:33.159]                     NULL
[13:23:33.159]                     RNGkind("Mersenne-Twister")
[13:23:33.159]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:33.159]                       inherits = FALSE)
[13:23:33.159]                   }
[13:23:33.159]                   options(future.plan = NULL)
[13:23:33.159]                   if (is.na(NA_character_)) 
[13:23:33.159]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.159]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.159]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.159]                     envir = parent.frame()) 
[13:23:33.159]                   {
[13:23:33.159]                     default_workers <- missing(workers)
[13:23:33.159]                     if (is.function(workers)) 
[13:23:33.159]                       workers <- workers()
[13:23:33.159]                     workers <- structure(as.integer(workers), 
[13:23:33.159]                       class = class(workers))
[13:23:33.159]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.159]                       1L)
[13:23:33.159]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.159]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.159]                       if (default_workers) 
[13:23:33.159]                         supportsMulticore(warn = TRUE)
[13:23:33.159]                       return(sequential(..., envir = envir))
[13:23:33.159]                     }
[13:23:33.159]                     oopts <- options(mc.cores = workers)
[13:23:33.159]                     on.exit(options(oopts))
[13:23:33.159]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.159]                       envir = envir)
[13:23:33.159]                     if (!future$lazy) 
[13:23:33.159]                       future <- run(future)
[13:23:33.159]                     invisible(future)
[13:23:33.159]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.159]                 }
[13:23:33.159]             }
[13:23:33.159]         }
[13:23:33.159]     })
[13:23:33.159]     if (TRUE) {
[13:23:33.159]         base::sink(type = "output", split = FALSE)
[13:23:33.159]         if (TRUE) {
[13:23:33.159]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.159]         }
[13:23:33.159]         else {
[13:23:33.159]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.159]         }
[13:23:33.159]         base::close(...future.stdout)
[13:23:33.159]         ...future.stdout <- NULL
[13:23:33.159]     }
[13:23:33.159]     ...future.result$conditions <- ...future.conditions
[13:23:33.159]     ...future.result$finished <- base::Sys.time()
[13:23:33.159]     ...future.result
[13:23:33.159] }
[13:23:33.161] assign_globals() ...
[13:23:33.161] List of 1
[13:23:33.161]  $ pkg: chr "foo"
[13:23:33.161]  - attr(*, "where")=List of 1
[13:23:33.161]   ..$ pkg:<environment: R_EmptyEnv> 
[13:23:33.161]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:33.161]  - attr(*, "resolved")= logi TRUE
[13:23:33.161]  - attr(*, "total_size")= num 112
[13:23:33.164] - copied ‘pkg’ to environment
[13:23:33.164] assign_globals() ... done
[13:23:33.165] plan(): Setting new future strategy stack:
[13:23:33.165] List of future strategies:
[13:23:33.165] 1. sequential:
[13:23:33.165]    - args: function (..., envir = parent.frame())
[13:23:33.165]    - tweaked: FALSE
[13:23:33.165]    - call: NULL
[13:23:33.165] plan(): nbrOfWorkers() = 1
[13:23:33.166] plan(): Setting new future strategy stack:
[13:23:33.166] List of future strategies:
[13:23:33.166] 1. multicore:
[13:23:33.166]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:33.166]    - tweaked: FALSE
[13:23:33.166]    - call: plan(strategy)
[13:23:33.170] plan(): nbrOfWorkers() = 2
[13:23:33.171] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:33.172] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:33.172] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:33.174] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:23:33.174] Searching for globals ... DONE
[13:23:33.174] Resolving globals: TRUE
[13:23:33.174] Resolving any globals that are futures ...
[13:23:33.182] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:23:33.182] Resolving any globals that are futures ... DONE
[13:23:33.183] Resolving futures part of globals (recursively) ...
[13:23:33.183] resolve() on list ...
[13:23:33.183]  recursive: 99
[13:23:33.183]  length: 1
[13:23:33.183]  elements: ‘a’
[13:23:33.183]  length: 0 (resolved future 1)
[13:23:33.184] resolve() on list ... DONE
[13:23:33.184] - globals: [1] ‘a’
[13:23:33.184] Resolving futures part of globals (recursively) ... DONE
[13:23:33.184] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:33.184] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:23:33.185] - globals: [1] ‘a’
[13:23:33.185] 
[13:23:33.185] getGlobalsAndPackages() ... DONE
[13:23:33.185] run() for ‘Future’ ...
[13:23:33.185] - state: ‘created’
[13:23:33.185] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:33.190] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:33.190] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:33.190]   - Field: ‘label’
[13:23:33.190]   - Field: ‘local’
[13:23:33.190]   - Field: ‘owner’
[13:23:33.191]   - Field: ‘envir’
[13:23:33.191]   - Field: ‘workers’
[13:23:33.191]   - Field: ‘packages’
[13:23:33.191]   - Field: ‘gc’
[13:23:33.191]   - Field: ‘job’
[13:23:33.191]   - Field: ‘conditions’
[13:23:33.191]   - Field: ‘expr’
[13:23:33.191]   - Field: ‘uuid’
[13:23:33.191]   - Field: ‘seed’
[13:23:33.192]   - Field: ‘version’
[13:23:33.192]   - Field: ‘result’
[13:23:33.192]   - Field: ‘asynchronous’
[13:23:33.192]   - Field: ‘calls’
[13:23:33.192]   - Field: ‘globals’
[13:23:33.192]   - Field: ‘stdout’
[13:23:33.192]   - Field: ‘earlySignal’
[13:23:33.192]   - Field: ‘lazy’
[13:23:33.192]   - Field: ‘state’
[13:23:33.192] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:33.193] - Launch lazy future ...
[13:23:33.193] Packages needed by the future expression (n = 0): <none>
[13:23:33.193] Packages needed by future strategies (n = 0): <none>
[13:23:33.193] {
[13:23:33.193]     {
[13:23:33.193]         {
[13:23:33.193]             ...future.startTime <- base::Sys.time()
[13:23:33.193]             {
[13:23:33.193]                 {
[13:23:33.193]                   {
[13:23:33.193]                     {
[13:23:33.193]                       base::local({
[13:23:33.193]                         has_future <- base::requireNamespace("future", 
[13:23:33.193]                           quietly = TRUE)
[13:23:33.193]                         if (has_future) {
[13:23:33.193]                           ns <- base::getNamespace("future")
[13:23:33.193]                           version <- ns[[".package"]][["version"]]
[13:23:33.193]                           if (is.null(version)) 
[13:23:33.193]                             version <- utils::packageVersion("future")
[13:23:33.193]                         }
[13:23:33.193]                         else {
[13:23:33.193]                           version <- NULL
[13:23:33.193]                         }
[13:23:33.193]                         if (!has_future || version < "1.8.0") {
[13:23:33.193]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.193]                             "", base::R.version$version.string), 
[13:23:33.193]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:33.193]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:33.193]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.193]                               "release", "version")], collapse = " "), 
[13:23:33.193]                             hostname = base::Sys.info()[["nodename"]])
[13:23:33.193]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.193]                             info)
[13:23:33.193]                           info <- base::paste(info, collapse = "; ")
[13:23:33.193]                           if (!has_future) {
[13:23:33.193]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.193]                               info)
[13:23:33.193]                           }
[13:23:33.193]                           else {
[13:23:33.193]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.193]                               info, version)
[13:23:33.193]                           }
[13:23:33.193]                           base::stop(msg)
[13:23:33.193]                         }
[13:23:33.193]                       })
[13:23:33.193]                     }
[13:23:33.193]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:33.193]                     base::options(mc.cores = 1L)
[13:23:33.193]                   }
[13:23:33.193]                   options(future.plan = NULL)
[13:23:33.193]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.193]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.193]                 }
[13:23:33.193]                 ...future.workdir <- getwd()
[13:23:33.193]             }
[13:23:33.193]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.193]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.193]         }
[13:23:33.193]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.193]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:33.193]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.193]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.193]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.193]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.193]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.193]             base::names(...future.oldOptions))
[13:23:33.193]     }
[13:23:33.193]     if (FALSE) {
[13:23:33.193]     }
[13:23:33.193]     else {
[13:23:33.193]         if (TRUE) {
[13:23:33.193]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.193]                 open = "w")
[13:23:33.193]         }
[13:23:33.193]         else {
[13:23:33.193]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.193]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.193]         }
[13:23:33.193]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.193]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.193]             base::sink(type = "output", split = FALSE)
[13:23:33.193]             base::close(...future.stdout)
[13:23:33.193]         }, add = TRUE)
[13:23:33.193]     }
[13:23:33.193]     ...future.frame <- base::sys.nframe()
[13:23:33.193]     ...future.conditions <- base::list()
[13:23:33.193]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.193]     if (FALSE) {
[13:23:33.193]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.193]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.193]     }
[13:23:33.193]     ...future.result <- base::tryCatch({
[13:23:33.193]         base::withCallingHandlers({
[13:23:33.193]             ...future.value <- base::withVisible(base::local({
[13:23:33.193]                 withCallingHandlers({
[13:23:33.193]                   {
[13:23:33.193]                     b <- a
[13:23:33.193]                     a <- 2
[13:23:33.193]                     a * b
[13:23:33.193]                   }
[13:23:33.193]                 }, immediateCondition = function(cond) {
[13:23:33.193]                   save_rds <- function (object, pathname, ...) 
[13:23:33.193]                   {
[13:23:33.193]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:33.193]                     if (file_test("-f", pathname_tmp)) {
[13:23:33.193]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.193]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:33.193]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.193]                         fi_tmp[["mtime"]])
[13:23:33.193]                     }
[13:23:33.193]                     tryCatch({
[13:23:33.193]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:33.193]                     }, error = function(ex) {
[13:23:33.193]                       msg <- conditionMessage(ex)
[13:23:33.193]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.193]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:33.193]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.193]                         fi_tmp[["mtime"]], msg)
[13:23:33.193]                       ex$message <- msg
[13:23:33.193]                       stop(ex)
[13:23:33.193]                     })
[13:23:33.193]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:33.193]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:33.193]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:33.193]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.193]                       fi <- file.info(pathname)
[13:23:33.193]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:33.193]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.193]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:33.193]                         fi[["size"]], fi[["mtime"]])
[13:23:33.193]                       stop(msg)
[13:23:33.193]                     }
[13:23:33.193]                     invisible(pathname)
[13:23:33.193]                   }
[13:23:33.193]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:33.193]                     rootPath = tempdir()) 
[13:23:33.193]                   {
[13:23:33.193]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:33.193]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:33.193]                       tmpdir = path, fileext = ".rds")
[13:23:33.193]                     save_rds(obj, file)
[13:23:33.193]                   }
[13:23:33.193]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:33.193]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.193]                   {
[13:23:33.193]                     inherits <- base::inherits
[13:23:33.193]                     invokeRestart <- base::invokeRestart
[13:23:33.193]                     is.null <- base::is.null
[13:23:33.193]                     muffled <- FALSE
[13:23:33.193]                     if (inherits(cond, "message")) {
[13:23:33.193]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:33.193]                       if (muffled) 
[13:23:33.193]                         invokeRestart("muffleMessage")
[13:23:33.193]                     }
[13:23:33.193]                     else if (inherits(cond, "warning")) {
[13:23:33.193]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:33.193]                       if (muffled) 
[13:23:33.193]                         invokeRestart("muffleWarning")
[13:23:33.193]                     }
[13:23:33.193]                     else if (inherits(cond, "condition")) {
[13:23:33.193]                       if (!is.null(pattern)) {
[13:23:33.193]                         computeRestarts <- base::computeRestarts
[13:23:33.193]                         grepl <- base::grepl
[13:23:33.193]                         restarts <- computeRestarts(cond)
[13:23:33.193]                         for (restart in restarts) {
[13:23:33.193]                           name <- restart$name
[13:23:33.193]                           if (is.null(name)) 
[13:23:33.193]                             next
[13:23:33.193]                           if (!grepl(pattern, name)) 
[13:23:33.193]                             next
[13:23:33.193]                           invokeRestart(restart)
[13:23:33.193]                           muffled <- TRUE
[13:23:33.193]                           break
[13:23:33.193]                         }
[13:23:33.193]                       }
[13:23:33.193]                     }
[13:23:33.193]                     invisible(muffled)
[13:23:33.193]                   }
[13:23:33.193]                   muffleCondition(cond)
[13:23:33.193]                 })
[13:23:33.193]             }))
[13:23:33.193]             future::FutureResult(value = ...future.value$value, 
[13:23:33.193]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.193]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.193]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.193]                     ...future.globalenv.names))
[13:23:33.193]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.193]         }, condition = base::local({
[13:23:33.193]             c <- base::c
[13:23:33.193]             inherits <- base::inherits
[13:23:33.193]             invokeRestart <- base::invokeRestart
[13:23:33.193]             length <- base::length
[13:23:33.193]             list <- base::list
[13:23:33.193]             seq.int <- base::seq.int
[13:23:33.193]             signalCondition <- base::signalCondition
[13:23:33.193]             sys.calls <- base::sys.calls
[13:23:33.193]             `[[` <- base::`[[`
[13:23:33.193]             `+` <- base::`+`
[13:23:33.193]             `<<-` <- base::`<<-`
[13:23:33.193]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.193]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.193]                   3L)]
[13:23:33.193]             }
[13:23:33.193]             function(cond) {
[13:23:33.193]                 is_error <- inherits(cond, "error")
[13:23:33.193]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.193]                   NULL)
[13:23:33.193]                 if (is_error) {
[13:23:33.193]                   sessionInformation <- function() {
[13:23:33.193]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.193]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.193]                       search = base::search(), system = base::Sys.info())
[13:23:33.193]                   }
[13:23:33.193]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.193]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.193]                     cond$call), session = sessionInformation(), 
[13:23:33.193]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.193]                   signalCondition(cond)
[13:23:33.193]                 }
[13:23:33.193]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.193]                 "immediateCondition"))) {
[13:23:33.193]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.193]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.193]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.193]                   if (TRUE && !signal) {
[13:23:33.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.193]                     {
[13:23:33.193]                       inherits <- base::inherits
[13:23:33.193]                       invokeRestart <- base::invokeRestart
[13:23:33.193]                       is.null <- base::is.null
[13:23:33.193]                       muffled <- FALSE
[13:23:33.193]                       if (inherits(cond, "message")) {
[13:23:33.193]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.193]                         if (muffled) 
[13:23:33.193]                           invokeRestart("muffleMessage")
[13:23:33.193]                       }
[13:23:33.193]                       else if (inherits(cond, "warning")) {
[13:23:33.193]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.193]                         if (muffled) 
[13:23:33.193]                           invokeRestart("muffleWarning")
[13:23:33.193]                       }
[13:23:33.193]                       else if (inherits(cond, "condition")) {
[13:23:33.193]                         if (!is.null(pattern)) {
[13:23:33.193]                           computeRestarts <- base::computeRestarts
[13:23:33.193]                           grepl <- base::grepl
[13:23:33.193]                           restarts <- computeRestarts(cond)
[13:23:33.193]                           for (restart in restarts) {
[13:23:33.193]                             name <- restart$name
[13:23:33.193]                             if (is.null(name)) 
[13:23:33.193]                               next
[13:23:33.193]                             if (!grepl(pattern, name)) 
[13:23:33.193]                               next
[13:23:33.193]                             invokeRestart(restart)
[13:23:33.193]                             muffled <- TRUE
[13:23:33.193]                             break
[13:23:33.193]                           }
[13:23:33.193]                         }
[13:23:33.193]                       }
[13:23:33.193]                       invisible(muffled)
[13:23:33.193]                     }
[13:23:33.193]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.193]                   }
[13:23:33.193]                 }
[13:23:33.193]                 else {
[13:23:33.193]                   if (TRUE) {
[13:23:33.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.193]                     {
[13:23:33.193]                       inherits <- base::inherits
[13:23:33.193]                       invokeRestart <- base::invokeRestart
[13:23:33.193]                       is.null <- base::is.null
[13:23:33.193]                       muffled <- FALSE
[13:23:33.193]                       if (inherits(cond, "message")) {
[13:23:33.193]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.193]                         if (muffled) 
[13:23:33.193]                           invokeRestart("muffleMessage")
[13:23:33.193]                       }
[13:23:33.193]                       else if (inherits(cond, "warning")) {
[13:23:33.193]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.193]                         if (muffled) 
[13:23:33.193]                           invokeRestart("muffleWarning")
[13:23:33.193]                       }
[13:23:33.193]                       else if (inherits(cond, "condition")) {
[13:23:33.193]                         if (!is.null(pattern)) {
[13:23:33.193]                           computeRestarts <- base::computeRestarts
[13:23:33.193]                           grepl <- base::grepl
[13:23:33.193]                           restarts <- computeRestarts(cond)
[13:23:33.193]                           for (restart in restarts) {
[13:23:33.193]                             name <- restart$name
[13:23:33.193]                             if (is.null(name)) 
[13:23:33.193]                               next
[13:23:33.193]                             if (!grepl(pattern, name)) 
[13:23:33.193]                               next
[13:23:33.193]                             invokeRestart(restart)
[13:23:33.193]                             muffled <- TRUE
[13:23:33.193]                             break
[13:23:33.193]                           }
[13:23:33.193]                         }
[13:23:33.193]                       }
[13:23:33.193]                       invisible(muffled)
[13:23:33.193]                     }
[13:23:33.193]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.193]                   }
[13:23:33.193]                 }
[13:23:33.193]             }
[13:23:33.193]         }))
[13:23:33.193]     }, error = function(ex) {
[13:23:33.193]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.193]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.193]                 ...future.rng), started = ...future.startTime, 
[13:23:33.193]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.193]             version = "1.8"), class = "FutureResult")
[13:23:33.193]     }, finally = {
[13:23:33.193]         if (!identical(...future.workdir, getwd())) 
[13:23:33.193]             setwd(...future.workdir)
[13:23:33.193]         {
[13:23:33.193]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.193]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.193]             }
[13:23:33.193]             base::options(...future.oldOptions)
[13:23:33.193]             if (.Platform$OS.type == "windows") {
[13:23:33.193]                 old_names <- names(...future.oldEnvVars)
[13:23:33.193]                 envs <- base::Sys.getenv()
[13:23:33.193]                 names <- names(envs)
[13:23:33.193]                 common <- intersect(names, old_names)
[13:23:33.193]                 added <- setdiff(names, old_names)
[13:23:33.193]                 removed <- setdiff(old_names, names)
[13:23:33.193]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.193]                   envs[common]]
[13:23:33.193]                 NAMES <- toupper(changed)
[13:23:33.193]                 args <- list()
[13:23:33.193]                 for (kk in seq_along(NAMES)) {
[13:23:33.193]                   name <- changed[[kk]]
[13:23:33.193]                   NAME <- NAMES[[kk]]
[13:23:33.193]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.193]                     next
[13:23:33.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.193]                 }
[13:23:33.193]                 NAMES <- toupper(added)
[13:23:33.193]                 for (kk in seq_along(NAMES)) {
[13:23:33.193]                   name <- added[[kk]]
[13:23:33.193]                   NAME <- NAMES[[kk]]
[13:23:33.193]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.193]                     next
[13:23:33.193]                   args[[name]] <- ""
[13:23:33.193]                 }
[13:23:33.193]                 NAMES <- toupper(removed)
[13:23:33.193]                 for (kk in seq_along(NAMES)) {
[13:23:33.193]                   name <- removed[[kk]]
[13:23:33.193]                   NAME <- NAMES[[kk]]
[13:23:33.193]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.193]                     next
[13:23:33.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.193]                 }
[13:23:33.193]                 if (length(args) > 0) 
[13:23:33.193]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.193]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.193]             }
[13:23:33.193]             else {
[13:23:33.193]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.193]             }
[13:23:33.193]             {
[13:23:33.193]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.193]                   0L) {
[13:23:33.193]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.193]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.193]                   base::options(opts)
[13:23:33.193]                 }
[13:23:33.193]                 {
[13:23:33.193]                   {
[13:23:33.193]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:33.193]                     NULL
[13:23:33.193]                   }
[13:23:33.193]                   options(future.plan = NULL)
[13:23:33.193]                   if (is.na(NA_character_)) 
[13:23:33.193]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.193]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.193]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.193]                     envir = parent.frame()) 
[13:23:33.193]                   {
[13:23:33.193]                     default_workers <- missing(workers)
[13:23:33.193]                     if (is.function(workers)) 
[13:23:33.193]                       workers <- workers()
[13:23:33.193]                     workers <- structure(as.integer(workers), 
[13:23:33.193]                       class = class(workers))
[13:23:33.193]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.193]                       1L)
[13:23:33.193]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.193]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.193]                       if (default_workers) 
[13:23:33.193]                         supportsMulticore(warn = TRUE)
[13:23:33.193]                       return(sequential(..., envir = envir))
[13:23:33.193]                     }
[13:23:33.193]                     oopts <- options(mc.cores = workers)
[13:23:33.193]                     on.exit(options(oopts))
[13:23:33.193]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.193]                       envir = envir)
[13:23:33.193]                     if (!future$lazy) 
[13:23:33.193]                       future <- run(future)
[13:23:33.193]                     invisible(future)
[13:23:33.193]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.193]                 }
[13:23:33.193]             }
[13:23:33.193]         }
[13:23:33.193]     })
[13:23:33.193]     if (TRUE) {
[13:23:33.193]         base::sink(type = "output", split = FALSE)
[13:23:33.193]         if (TRUE) {
[13:23:33.193]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.193]         }
[13:23:33.193]         else {
[13:23:33.193]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.193]         }
[13:23:33.193]         base::close(...future.stdout)
[13:23:33.193]         ...future.stdout <- NULL
[13:23:33.193]     }
[13:23:33.193]     ...future.result$conditions <- ...future.conditions
[13:23:33.193]     ...future.result$finished <- base::Sys.time()
[13:23:33.193]     ...future.result
[13:23:33.193] }
[13:23:33.196] assign_globals() ...
[13:23:33.196] List of 1
[13:23:33.196]  $ a: num 3
[13:23:33.196]  - attr(*, "where")=List of 1
[13:23:33.196]   ..$ a:<environment: R_EmptyEnv> 
[13:23:33.196]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:33.196]  - attr(*, "resolved")= logi TRUE
[13:23:33.196]  - attr(*, "total_size")= num 56
[13:23:33.196]  - attr(*, "already-done")= logi TRUE
[13:23:33.199] - copied ‘a’ to environment
[13:23:33.199] assign_globals() ... done
[13:23:33.199] requestCore(): workers = 2
[13:23:33.202] MulticoreFuture started
[13:23:33.202] - Launch lazy future ... done
[13:23:33.202] run() for ‘MulticoreFuture’ ... done
[13:23:33.203] result() for MulticoreFuture ...
[13:23:33.203] plan(): Setting new future strategy stack:
[13:23:33.203] List of future strategies:
[13:23:33.203] 1. sequential:
[13:23:33.203]    - args: function (..., envir = parent.frame())
[13:23:33.203]    - tweaked: FALSE
[13:23:33.203]    - call: NULL
[13:23:33.204] plan(): nbrOfWorkers() = 1
[13:23:33.206] plan(): Setting new future strategy stack:
[13:23:33.207] List of future strategies:
[13:23:33.207] 1. multicore:
[13:23:33.207]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:33.207]    - tweaked: FALSE
[13:23:33.207]    - call: plan(strategy)
[13:23:33.212] plan(): nbrOfWorkers() = 2
[13:23:33.213] result() for MulticoreFuture ...
[13:23:33.213] result() for MulticoreFuture ... done
[13:23:33.213] result() for MulticoreFuture ... done
[13:23:33.214] result() for MulticoreFuture ...
[13:23:33.214] result() for MulticoreFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:33.215] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:33.215] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:33.218] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:23:33.218] Searching for globals ... DONE
[13:23:33.218] Resolving globals: TRUE
[13:23:33.218] Resolving any globals that are futures ...
[13:23:33.218] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:23:33.219] Resolving any globals that are futures ... DONE
[13:23:33.219] Resolving futures part of globals (recursively) ...
[13:23:33.219] resolve() on list ...
[13:23:33.220]  recursive: 99
[13:23:33.220]  length: 1
[13:23:33.220]  elements: ‘a’
[13:23:33.220]  length: 0 (resolved future 1)
[13:23:33.220] resolve() on list ... DONE
[13:23:33.220] - globals: [1] ‘a’
[13:23:33.220] Resolving futures part of globals (recursively) ... DONE
[13:23:33.221] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:33.221] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:23:33.221] - globals: [1] ‘a’
[13:23:33.221] 
[13:23:33.221] getGlobalsAndPackages() ... DONE
[13:23:33.222] run() for ‘Future’ ...
[13:23:33.222] - state: ‘created’
[13:23:33.222] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:33.227] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:33.227] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:33.227]   - Field: ‘label’
[13:23:33.227]   - Field: ‘local’
[13:23:33.227]   - Field: ‘owner’
[13:23:33.228]   - Field: ‘envir’
[13:23:33.228]   - Field: ‘workers’
[13:23:33.231]   - Field: ‘packages’
[13:23:33.231]   - Field: ‘gc’
[13:23:33.231]   - Field: ‘job’
[13:23:33.231]   - Field: ‘conditions’
[13:23:33.231]   - Field: ‘expr’
[13:23:33.232]   - Field: ‘uuid’
[13:23:33.232]   - Field: ‘seed’
[13:23:33.232]   - Field: ‘version’
[13:23:33.232]   - Field: ‘result’
[13:23:33.232]   - Field: ‘asynchronous’
[13:23:33.232]   - Field: ‘calls’
[13:23:33.232]   - Field: ‘globals’
[13:23:33.233]   - Field: ‘stdout’
[13:23:33.233]   - Field: ‘earlySignal’
[13:23:33.233]   - Field: ‘lazy’
[13:23:33.233]   - Field: ‘state’
[13:23:33.233] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:33.233] - Launch lazy future ...
[13:23:33.234] Packages needed by the future expression (n = 0): <none>
[13:23:33.234] Packages needed by future strategies (n = 0): <none>
[13:23:33.235] {
[13:23:33.235]     {
[13:23:33.235]         {
[13:23:33.235]             ...future.startTime <- base::Sys.time()
[13:23:33.235]             {
[13:23:33.235]                 {
[13:23:33.235]                   {
[13:23:33.235]                     {
[13:23:33.235]                       base::local({
[13:23:33.235]                         has_future <- base::requireNamespace("future", 
[13:23:33.235]                           quietly = TRUE)
[13:23:33.235]                         if (has_future) {
[13:23:33.235]                           ns <- base::getNamespace("future")
[13:23:33.235]                           version <- ns[[".package"]][["version"]]
[13:23:33.235]                           if (is.null(version)) 
[13:23:33.235]                             version <- utils::packageVersion("future")
[13:23:33.235]                         }
[13:23:33.235]                         else {
[13:23:33.235]                           version <- NULL
[13:23:33.235]                         }
[13:23:33.235]                         if (!has_future || version < "1.8.0") {
[13:23:33.235]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.235]                             "", base::R.version$version.string), 
[13:23:33.235]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:33.235]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:33.235]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.235]                               "release", "version")], collapse = " "), 
[13:23:33.235]                             hostname = base::Sys.info()[["nodename"]])
[13:23:33.235]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.235]                             info)
[13:23:33.235]                           info <- base::paste(info, collapse = "; ")
[13:23:33.235]                           if (!has_future) {
[13:23:33.235]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.235]                               info)
[13:23:33.235]                           }
[13:23:33.235]                           else {
[13:23:33.235]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.235]                               info, version)
[13:23:33.235]                           }
[13:23:33.235]                           base::stop(msg)
[13:23:33.235]                         }
[13:23:33.235]                       })
[13:23:33.235]                     }
[13:23:33.235]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:33.235]                     base::options(mc.cores = 1L)
[13:23:33.235]                   }
[13:23:33.235]                   options(future.plan = NULL)
[13:23:33.235]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.235]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.235]                 }
[13:23:33.235]                 ...future.workdir <- getwd()
[13:23:33.235]             }
[13:23:33.235]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.235]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.235]         }
[13:23:33.235]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.235]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:33.235]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.235]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.235]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.235]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.235]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.235]             base::names(...future.oldOptions))
[13:23:33.235]     }
[13:23:33.235]     if (FALSE) {
[13:23:33.235]     }
[13:23:33.235]     else {
[13:23:33.235]         if (TRUE) {
[13:23:33.235]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.235]                 open = "w")
[13:23:33.235]         }
[13:23:33.235]         else {
[13:23:33.235]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.235]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.235]         }
[13:23:33.235]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.235]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.235]             base::sink(type = "output", split = FALSE)
[13:23:33.235]             base::close(...future.stdout)
[13:23:33.235]         }, add = TRUE)
[13:23:33.235]     }
[13:23:33.235]     ...future.frame <- base::sys.nframe()
[13:23:33.235]     ...future.conditions <- base::list()
[13:23:33.235]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.235]     if (FALSE) {
[13:23:33.235]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.235]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.235]     }
[13:23:33.235]     ...future.result <- base::tryCatch({
[13:23:33.235]         base::withCallingHandlers({
[13:23:33.235]             ...future.value <- base::withVisible(base::local({
[13:23:33.235]                 withCallingHandlers({
[13:23:33.235]                   {
[13:23:33.235]                     b <- a
[13:23:33.235]                     a <- 2
[13:23:33.235]                     a * b
[13:23:33.235]                   }
[13:23:33.235]                 }, immediateCondition = function(cond) {
[13:23:33.235]                   save_rds <- function (object, pathname, ...) 
[13:23:33.235]                   {
[13:23:33.235]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:33.235]                     if (file_test("-f", pathname_tmp)) {
[13:23:33.235]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.235]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:33.235]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.235]                         fi_tmp[["mtime"]])
[13:23:33.235]                     }
[13:23:33.235]                     tryCatch({
[13:23:33.235]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:33.235]                     }, error = function(ex) {
[13:23:33.235]                       msg <- conditionMessage(ex)
[13:23:33.235]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.235]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:33.235]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.235]                         fi_tmp[["mtime"]], msg)
[13:23:33.235]                       ex$message <- msg
[13:23:33.235]                       stop(ex)
[13:23:33.235]                     })
[13:23:33.235]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:33.235]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:33.235]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:33.235]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.235]                       fi <- file.info(pathname)
[13:23:33.235]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:33.235]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.235]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:33.235]                         fi[["size"]], fi[["mtime"]])
[13:23:33.235]                       stop(msg)
[13:23:33.235]                     }
[13:23:33.235]                     invisible(pathname)
[13:23:33.235]                   }
[13:23:33.235]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:33.235]                     rootPath = tempdir()) 
[13:23:33.235]                   {
[13:23:33.235]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:33.235]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:33.235]                       tmpdir = path, fileext = ".rds")
[13:23:33.235]                     save_rds(obj, file)
[13:23:33.235]                   }
[13:23:33.235]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:33.235]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.235]                   {
[13:23:33.235]                     inherits <- base::inherits
[13:23:33.235]                     invokeRestart <- base::invokeRestart
[13:23:33.235]                     is.null <- base::is.null
[13:23:33.235]                     muffled <- FALSE
[13:23:33.235]                     if (inherits(cond, "message")) {
[13:23:33.235]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:33.235]                       if (muffled) 
[13:23:33.235]                         invokeRestart("muffleMessage")
[13:23:33.235]                     }
[13:23:33.235]                     else if (inherits(cond, "warning")) {
[13:23:33.235]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:33.235]                       if (muffled) 
[13:23:33.235]                         invokeRestart("muffleWarning")
[13:23:33.235]                     }
[13:23:33.235]                     else if (inherits(cond, "condition")) {
[13:23:33.235]                       if (!is.null(pattern)) {
[13:23:33.235]                         computeRestarts <- base::computeRestarts
[13:23:33.235]                         grepl <- base::grepl
[13:23:33.235]                         restarts <- computeRestarts(cond)
[13:23:33.235]                         for (restart in restarts) {
[13:23:33.235]                           name <- restart$name
[13:23:33.235]                           if (is.null(name)) 
[13:23:33.235]                             next
[13:23:33.235]                           if (!grepl(pattern, name)) 
[13:23:33.235]                             next
[13:23:33.235]                           invokeRestart(restart)
[13:23:33.235]                           muffled <- TRUE
[13:23:33.235]                           break
[13:23:33.235]                         }
[13:23:33.235]                       }
[13:23:33.235]                     }
[13:23:33.235]                     invisible(muffled)
[13:23:33.235]                   }
[13:23:33.235]                   muffleCondition(cond)
[13:23:33.235]                 })
[13:23:33.235]             }))
[13:23:33.235]             future::FutureResult(value = ...future.value$value, 
[13:23:33.235]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.235]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.235]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.235]                     ...future.globalenv.names))
[13:23:33.235]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.235]         }, condition = base::local({
[13:23:33.235]             c <- base::c
[13:23:33.235]             inherits <- base::inherits
[13:23:33.235]             invokeRestart <- base::invokeRestart
[13:23:33.235]             length <- base::length
[13:23:33.235]             list <- base::list
[13:23:33.235]             seq.int <- base::seq.int
[13:23:33.235]             signalCondition <- base::signalCondition
[13:23:33.235]             sys.calls <- base::sys.calls
[13:23:33.235]             `[[` <- base::`[[`
[13:23:33.235]             `+` <- base::`+`
[13:23:33.235]             `<<-` <- base::`<<-`
[13:23:33.235]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.235]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.235]                   3L)]
[13:23:33.235]             }
[13:23:33.235]             function(cond) {
[13:23:33.235]                 is_error <- inherits(cond, "error")
[13:23:33.235]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.235]                   NULL)
[13:23:33.235]                 if (is_error) {
[13:23:33.235]                   sessionInformation <- function() {
[13:23:33.235]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.235]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.235]                       search = base::search(), system = base::Sys.info())
[13:23:33.235]                   }
[13:23:33.235]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.235]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.235]                     cond$call), session = sessionInformation(), 
[13:23:33.235]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.235]                   signalCondition(cond)
[13:23:33.235]                 }
[13:23:33.235]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.235]                 "immediateCondition"))) {
[13:23:33.235]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.235]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.235]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.235]                   if (TRUE && !signal) {
[13:23:33.235]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.235]                     {
[13:23:33.235]                       inherits <- base::inherits
[13:23:33.235]                       invokeRestart <- base::invokeRestart
[13:23:33.235]                       is.null <- base::is.null
[13:23:33.235]                       muffled <- FALSE
[13:23:33.235]                       if (inherits(cond, "message")) {
[13:23:33.235]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.235]                         if (muffled) 
[13:23:33.235]                           invokeRestart("muffleMessage")
[13:23:33.235]                       }
[13:23:33.235]                       else if (inherits(cond, "warning")) {
[13:23:33.235]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.235]                         if (muffled) 
[13:23:33.235]                           invokeRestart("muffleWarning")
[13:23:33.235]                       }
[13:23:33.235]                       else if (inherits(cond, "condition")) {
[13:23:33.235]                         if (!is.null(pattern)) {
[13:23:33.235]                           computeRestarts <- base::computeRestarts
[13:23:33.235]                           grepl <- base::grepl
[13:23:33.235]                           restarts <- computeRestarts(cond)
[13:23:33.235]                           for (restart in restarts) {
[13:23:33.235]                             name <- restart$name
[13:23:33.235]                             if (is.null(name)) 
[13:23:33.235]                               next
[13:23:33.235]                             if (!grepl(pattern, name)) 
[13:23:33.235]                               next
[13:23:33.235]                             invokeRestart(restart)
[13:23:33.235]                             muffled <- TRUE
[13:23:33.235]                             break
[13:23:33.235]                           }
[13:23:33.235]                         }
[13:23:33.235]                       }
[13:23:33.235]                       invisible(muffled)
[13:23:33.235]                     }
[13:23:33.235]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.235]                   }
[13:23:33.235]                 }
[13:23:33.235]                 else {
[13:23:33.235]                   if (TRUE) {
[13:23:33.235]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.235]                     {
[13:23:33.235]                       inherits <- base::inherits
[13:23:33.235]                       invokeRestart <- base::invokeRestart
[13:23:33.235]                       is.null <- base::is.null
[13:23:33.235]                       muffled <- FALSE
[13:23:33.235]                       if (inherits(cond, "message")) {
[13:23:33.235]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.235]                         if (muffled) 
[13:23:33.235]                           invokeRestart("muffleMessage")
[13:23:33.235]                       }
[13:23:33.235]                       else if (inherits(cond, "warning")) {
[13:23:33.235]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.235]                         if (muffled) 
[13:23:33.235]                           invokeRestart("muffleWarning")
[13:23:33.235]                       }
[13:23:33.235]                       else if (inherits(cond, "condition")) {
[13:23:33.235]                         if (!is.null(pattern)) {
[13:23:33.235]                           computeRestarts <- base::computeRestarts
[13:23:33.235]                           grepl <- base::grepl
[13:23:33.235]                           restarts <- computeRestarts(cond)
[13:23:33.235]                           for (restart in restarts) {
[13:23:33.235]                             name <- restart$name
[13:23:33.235]                             if (is.null(name)) 
[13:23:33.235]                               next
[13:23:33.235]                             if (!grepl(pattern, name)) 
[13:23:33.235]                               next
[13:23:33.235]                             invokeRestart(restart)
[13:23:33.235]                             muffled <- TRUE
[13:23:33.235]                             break
[13:23:33.235]                           }
[13:23:33.235]                         }
[13:23:33.235]                       }
[13:23:33.235]                       invisible(muffled)
[13:23:33.235]                     }
[13:23:33.235]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.235]                   }
[13:23:33.235]                 }
[13:23:33.235]             }
[13:23:33.235]         }))
[13:23:33.235]     }, error = function(ex) {
[13:23:33.235]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.235]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.235]                 ...future.rng), started = ...future.startTime, 
[13:23:33.235]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.235]             version = "1.8"), class = "FutureResult")
[13:23:33.235]     }, finally = {
[13:23:33.235]         if (!identical(...future.workdir, getwd())) 
[13:23:33.235]             setwd(...future.workdir)
[13:23:33.235]         {
[13:23:33.235]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.235]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.235]             }
[13:23:33.235]             base::options(...future.oldOptions)
[13:23:33.235]             if (.Platform$OS.type == "windows") {
[13:23:33.235]                 old_names <- names(...future.oldEnvVars)
[13:23:33.235]                 envs <- base::Sys.getenv()
[13:23:33.235]                 names <- names(envs)
[13:23:33.235]                 common <- intersect(names, old_names)
[13:23:33.235]                 added <- setdiff(names, old_names)
[13:23:33.235]                 removed <- setdiff(old_names, names)
[13:23:33.235]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.235]                   envs[common]]
[13:23:33.235]                 NAMES <- toupper(changed)
[13:23:33.235]                 args <- list()
[13:23:33.235]                 for (kk in seq_along(NAMES)) {
[13:23:33.235]                   name <- changed[[kk]]
[13:23:33.235]                   NAME <- NAMES[[kk]]
[13:23:33.235]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.235]                     next
[13:23:33.235]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.235]                 }
[13:23:33.235]                 NAMES <- toupper(added)
[13:23:33.235]                 for (kk in seq_along(NAMES)) {
[13:23:33.235]                   name <- added[[kk]]
[13:23:33.235]                   NAME <- NAMES[[kk]]
[13:23:33.235]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.235]                     next
[13:23:33.235]                   args[[name]] <- ""
[13:23:33.235]                 }
[13:23:33.235]                 NAMES <- toupper(removed)
[13:23:33.235]                 for (kk in seq_along(NAMES)) {
[13:23:33.235]                   name <- removed[[kk]]
[13:23:33.235]                   NAME <- NAMES[[kk]]
[13:23:33.235]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.235]                     next
[13:23:33.235]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.235]                 }
[13:23:33.235]                 if (length(args) > 0) 
[13:23:33.235]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.235]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.235]             }
[13:23:33.235]             else {
[13:23:33.235]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.235]             }
[13:23:33.235]             {
[13:23:33.235]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.235]                   0L) {
[13:23:33.235]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.235]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.235]                   base::options(opts)
[13:23:33.235]                 }
[13:23:33.235]                 {
[13:23:33.235]                   {
[13:23:33.235]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:33.235]                     NULL
[13:23:33.235]                   }
[13:23:33.235]                   options(future.plan = NULL)
[13:23:33.235]                   if (is.na(NA_character_)) 
[13:23:33.235]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.235]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.235]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.235]                     envir = parent.frame()) 
[13:23:33.235]                   {
[13:23:33.235]                     default_workers <- missing(workers)
[13:23:33.235]                     if (is.function(workers)) 
[13:23:33.235]                       workers <- workers()
[13:23:33.235]                     workers <- structure(as.integer(workers), 
[13:23:33.235]                       class = class(workers))
[13:23:33.235]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.235]                       1L)
[13:23:33.235]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.235]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.235]                       if (default_workers) 
[13:23:33.235]                         supportsMulticore(warn = TRUE)
[13:23:33.235]                       return(sequential(..., envir = envir))
[13:23:33.235]                     }
[13:23:33.235]                     oopts <- options(mc.cores = workers)
[13:23:33.235]                     on.exit(options(oopts))
[13:23:33.235]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.235]                       envir = envir)
[13:23:33.235]                     if (!future$lazy) 
[13:23:33.235]                       future <- run(future)
[13:23:33.235]                     invisible(future)
[13:23:33.235]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.235]                 }
[13:23:33.235]             }
[13:23:33.235]         }
[13:23:33.235]     })
[13:23:33.235]     if (TRUE) {
[13:23:33.235]         base::sink(type = "output", split = FALSE)
[13:23:33.235]         if (TRUE) {
[13:23:33.235]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.235]         }
[13:23:33.235]         else {
[13:23:33.235]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.235]         }
[13:23:33.235]         base::close(...future.stdout)
[13:23:33.235]         ...future.stdout <- NULL
[13:23:33.235]     }
[13:23:33.235]     ...future.result$conditions <- ...future.conditions
[13:23:33.235]     ...future.result$finished <- base::Sys.time()
[13:23:33.235]     ...future.result
[13:23:33.235] }
[13:23:33.237] assign_globals() ...
[13:23:33.238] List of 1
[13:23:33.238]  $ a: num 3
[13:23:33.238]  - attr(*, "where")=List of 1
[13:23:33.238]   ..$ a:<environment: R_EmptyEnv> 
[13:23:33.238]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:33.238]  - attr(*, "resolved")= logi TRUE
[13:23:33.238]  - attr(*, "total_size")= num 56
[13:23:33.238]  - attr(*, "already-done")= logi TRUE
[13:23:33.242] - copied ‘a’ to environment
[13:23:33.242] assign_globals() ... done
[13:23:33.242] requestCore(): workers = 2
[13:23:33.244] MulticoreFuture started
[13:23:33.245] - Launch lazy future ... done
[13:23:33.245] run() for ‘MulticoreFuture’ ... done
[13:23:33.246] result() for MulticoreFuture ...
[13:23:33.246] plan(): Setting new future strategy stack:
[13:23:33.246] List of future strategies:
[13:23:33.246] 1. sequential:
[13:23:33.246]    - args: function (..., envir = parent.frame())
[13:23:33.246]    - tweaked: FALSE
[13:23:33.246]    - call: NULL
[13:23:33.247] plan(): nbrOfWorkers() = 1
[13:23:33.250] plan(): Setting new future strategy stack:
[13:23:33.250] List of future strategies:
[13:23:33.250] 1. multicore:
[13:23:33.250]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:33.250]    - tweaked: FALSE
[13:23:33.250]    - call: plan(strategy)
[13:23:33.256] plan(): nbrOfWorkers() = 2
[13:23:33.257] result() for MulticoreFuture ...
[13:23:33.257] result() for MulticoreFuture ... done
[13:23:33.257] result() for MulticoreFuture ... done
[13:23:33.257] result() for MulticoreFuture ...
[13:23:33.258] result() for MulticoreFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:33.259] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:33.259] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:33.262] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:33.262] Searching for globals ... DONE
[13:23:33.262] Resolving globals: TRUE
[13:23:33.262] Resolving any globals that are futures ...
[13:23:33.262] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:33.263] Resolving any globals that are futures ... DONE
[13:23:33.263] Resolving futures part of globals (recursively) ...
[13:23:33.264] resolve() on list ...
[13:23:33.264]  recursive: 99
[13:23:33.264]  length: 2
[13:23:33.264]  elements: ‘a’, ‘ii’
[13:23:33.264]  length: 1 (resolved future 1)
[13:23:33.264]  length: 0 (resolved future 2)
[13:23:33.264] resolve() on list ... DONE
[13:23:33.264] - globals: [2] ‘a’, ‘ii’
[13:23:33.265] Resolving futures part of globals (recursively) ... DONE
[13:23:33.265] The total size of the 2 globals is 112 bytes (112 bytes)
[13:23:33.265] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:23:33.265] - globals: [2] ‘a’, ‘ii’
[13:23:33.266] 
[13:23:33.266] getGlobalsAndPackages() ... DONE
[13:23:33.266] run() for ‘Future’ ...
[13:23:33.266] - state: ‘created’
[13:23:33.266] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:33.271] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:33.271] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:33.271]   - Field: ‘label’
[13:23:33.271]   - Field: ‘local’
[13:23:33.271]   - Field: ‘owner’
[13:23:33.271]   - Field: ‘envir’
[13:23:33.272]   - Field: ‘workers’
[13:23:33.272]   - Field: ‘packages’
[13:23:33.272]   - Field: ‘gc’
[13:23:33.272]   - Field: ‘job’
[13:23:33.272]   - Field: ‘conditions’
[13:23:33.272]   - Field: ‘expr’
[13:23:33.272]   - Field: ‘uuid’
[13:23:33.272]   - Field: ‘seed’
[13:23:33.273]   - Field: ‘version’
[13:23:33.273]   - Field: ‘result’
[13:23:33.273]   - Field: ‘asynchronous’
[13:23:33.273]   - Field: ‘calls’
[13:23:33.273]   - Field: ‘globals’
[13:23:33.273]   - Field: ‘stdout’
[13:23:33.273]   - Field: ‘earlySignal’
[13:23:33.273]   - Field: ‘lazy’
[13:23:33.273]   - Field: ‘state’
[13:23:33.274] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:33.274] - Launch lazy future ...
[13:23:33.274] Packages needed by the future expression (n = 0): <none>
[13:23:33.274] Packages needed by future strategies (n = 0): <none>
[13:23:33.275] {
[13:23:33.275]     {
[13:23:33.275]         {
[13:23:33.275]             ...future.startTime <- base::Sys.time()
[13:23:33.275]             {
[13:23:33.275]                 {
[13:23:33.275]                   {
[13:23:33.275]                     {
[13:23:33.275]                       base::local({
[13:23:33.275]                         has_future <- base::requireNamespace("future", 
[13:23:33.275]                           quietly = TRUE)
[13:23:33.275]                         if (has_future) {
[13:23:33.275]                           ns <- base::getNamespace("future")
[13:23:33.275]                           version <- ns[[".package"]][["version"]]
[13:23:33.275]                           if (is.null(version)) 
[13:23:33.275]                             version <- utils::packageVersion("future")
[13:23:33.275]                         }
[13:23:33.275]                         else {
[13:23:33.275]                           version <- NULL
[13:23:33.275]                         }
[13:23:33.275]                         if (!has_future || version < "1.8.0") {
[13:23:33.275]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.275]                             "", base::R.version$version.string), 
[13:23:33.275]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:33.275]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:33.275]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.275]                               "release", "version")], collapse = " "), 
[13:23:33.275]                             hostname = base::Sys.info()[["nodename"]])
[13:23:33.275]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.275]                             info)
[13:23:33.275]                           info <- base::paste(info, collapse = "; ")
[13:23:33.275]                           if (!has_future) {
[13:23:33.275]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.275]                               info)
[13:23:33.275]                           }
[13:23:33.275]                           else {
[13:23:33.275]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.275]                               info, version)
[13:23:33.275]                           }
[13:23:33.275]                           base::stop(msg)
[13:23:33.275]                         }
[13:23:33.275]                       })
[13:23:33.275]                     }
[13:23:33.275]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:33.275]                     base::options(mc.cores = 1L)
[13:23:33.275]                   }
[13:23:33.275]                   options(future.plan = NULL)
[13:23:33.275]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.275]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.275]                 }
[13:23:33.275]                 ...future.workdir <- getwd()
[13:23:33.275]             }
[13:23:33.275]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.275]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.275]         }
[13:23:33.275]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.275]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:33.275]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.275]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.275]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.275]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.275]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.275]             base::names(...future.oldOptions))
[13:23:33.275]     }
[13:23:33.275]     if (FALSE) {
[13:23:33.275]     }
[13:23:33.275]     else {
[13:23:33.275]         if (TRUE) {
[13:23:33.275]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.275]                 open = "w")
[13:23:33.275]         }
[13:23:33.275]         else {
[13:23:33.275]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.275]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.275]         }
[13:23:33.275]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.275]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.275]             base::sink(type = "output", split = FALSE)
[13:23:33.275]             base::close(...future.stdout)
[13:23:33.275]         }, add = TRUE)
[13:23:33.275]     }
[13:23:33.275]     ...future.frame <- base::sys.nframe()
[13:23:33.275]     ...future.conditions <- base::list()
[13:23:33.275]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.275]     if (FALSE) {
[13:23:33.275]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.275]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.275]     }
[13:23:33.275]     ...future.result <- base::tryCatch({
[13:23:33.275]         base::withCallingHandlers({
[13:23:33.275]             ...future.value <- base::withVisible(base::local({
[13:23:33.275]                 withCallingHandlers({
[13:23:33.275]                   {
[13:23:33.275]                     b <- a * ii
[13:23:33.275]                     a <- 0
[13:23:33.275]                     b
[13:23:33.275]                   }
[13:23:33.275]                 }, immediateCondition = function(cond) {
[13:23:33.275]                   save_rds <- function (object, pathname, ...) 
[13:23:33.275]                   {
[13:23:33.275]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:33.275]                     if (file_test("-f", pathname_tmp)) {
[13:23:33.275]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.275]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:33.275]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.275]                         fi_tmp[["mtime"]])
[13:23:33.275]                     }
[13:23:33.275]                     tryCatch({
[13:23:33.275]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:33.275]                     }, error = function(ex) {
[13:23:33.275]                       msg <- conditionMessage(ex)
[13:23:33.275]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.275]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:33.275]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.275]                         fi_tmp[["mtime"]], msg)
[13:23:33.275]                       ex$message <- msg
[13:23:33.275]                       stop(ex)
[13:23:33.275]                     })
[13:23:33.275]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:33.275]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:33.275]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:33.275]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.275]                       fi <- file.info(pathname)
[13:23:33.275]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:33.275]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.275]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:33.275]                         fi[["size"]], fi[["mtime"]])
[13:23:33.275]                       stop(msg)
[13:23:33.275]                     }
[13:23:33.275]                     invisible(pathname)
[13:23:33.275]                   }
[13:23:33.275]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:33.275]                     rootPath = tempdir()) 
[13:23:33.275]                   {
[13:23:33.275]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:33.275]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:33.275]                       tmpdir = path, fileext = ".rds")
[13:23:33.275]                     save_rds(obj, file)
[13:23:33.275]                   }
[13:23:33.275]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:33.275]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.275]                   {
[13:23:33.275]                     inherits <- base::inherits
[13:23:33.275]                     invokeRestart <- base::invokeRestart
[13:23:33.275]                     is.null <- base::is.null
[13:23:33.275]                     muffled <- FALSE
[13:23:33.275]                     if (inherits(cond, "message")) {
[13:23:33.275]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:33.275]                       if (muffled) 
[13:23:33.275]                         invokeRestart("muffleMessage")
[13:23:33.275]                     }
[13:23:33.275]                     else if (inherits(cond, "warning")) {
[13:23:33.275]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:33.275]                       if (muffled) 
[13:23:33.275]                         invokeRestart("muffleWarning")
[13:23:33.275]                     }
[13:23:33.275]                     else if (inherits(cond, "condition")) {
[13:23:33.275]                       if (!is.null(pattern)) {
[13:23:33.275]                         computeRestarts <- base::computeRestarts
[13:23:33.275]                         grepl <- base::grepl
[13:23:33.275]                         restarts <- computeRestarts(cond)
[13:23:33.275]                         for (restart in restarts) {
[13:23:33.275]                           name <- restart$name
[13:23:33.275]                           if (is.null(name)) 
[13:23:33.275]                             next
[13:23:33.275]                           if (!grepl(pattern, name)) 
[13:23:33.275]                             next
[13:23:33.275]                           invokeRestart(restart)
[13:23:33.275]                           muffled <- TRUE
[13:23:33.275]                           break
[13:23:33.275]                         }
[13:23:33.275]                       }
[13:23:33.275]                     }
[13:23:33.275]                     invisible(muffled)
[13:23:33.275]                   }
[13:23:33.275]                   muffleCondition(cond)
[13:23:33.275]                 })
[13:23:33.275]             }))
[13:23:33.275]             future::FutureResult(value = ...future.value$value, 
[13:23:33.275]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.275]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.275]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.275]                     ...future.globalenv.names))
[13:23:33.275]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.275]         }, condition = base::local({
[13:23:33.275]             c <- base::c
[13:23:33.275]             inherits <- base::inherits
[13:23:33.275]             invokeRestart <- base::invokeRestart
[13:23:33.275]             length <- base::length
[13:23:33.275]             list <- base::list
[13:23:33.275]             seq.int <- base::seq.int
[13:23:33.275]             signalCondition <- base::signalCondition
[13:23:33.275]             sys.calls <- base::sys.calls
[13:23:33.275]             `[[` <- base::`[[`
[13:23:33.275]             `+` <- base::`+`
[13:23:33.275]             `<<-` <- base::`<<-`
[13:23:33.275]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.275]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.275]                   3L)]
[13:23:33.275]             }
[13:23:33.275]             function(cond) {
[13:23:33.275]                 is_error <- inherits(cond, "error")
[13:23:33.275]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.275]                   NULL)
[13:23:33.275]                 if (is_error) {
[13:23:33.275]                   sessionInformation <- function() {
[13:23:33.275]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.275]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.275]                       search = base::search(), system = base::Sys.info())
[13:23:33.275]                   }
[13:23:33.275]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.275]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.275]                     cond$call), session = sessionInformation(), 
[13:23:33.275]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.275]                   signalCondition(cond)
[13:23:33.275]                 }
[13:23:33.275]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.275]                 "immediateCondition"))) {
[13:23:33.275]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.275]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.275]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.275]                   if (TRUE && !signal) {
[13:23:33.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.275]                     {
[13:23:33.275]                       inherits <- base::inherits
[13:23:33.275]                       invokeRestart <- base::invokeRestart
[13:23:33.275]                       is.null <- base::is.null
[13:23:33.275]                       muffled <- FALSE
[13:23:33.275]                       if (inherits(cond, "message")) {
[13:23:33.275]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.275]                         if (muffled) 
[13:23:33.275]                           invokeRestart("muffleMessage")
[13:23:33.275]                       }
[13:23:33.275]                       else if (inherits(cond, "warning")) {
[13:23:33.275]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.275]                         if (muffled) 
[13:23:33.275]                           invokeRestart("muffleWarning")
[13:23:33.275]                       }
[13:23:33.275]                       else if (inherits(cond, "condition")) {
[13:23:33.275]                         if (!is.null(pattern)) {
[13:23:33.275]                           computeRestarts <- base::computeRestarts
[13:23:33.275]                           grepl <- base::grepl
[13:23:33.275]                           restarts <- computeRestarts(cond)
[13:23:33.275]                           for (restart in restarts) {
[13:23:33.275]                             name <- restart$name
[13:23:33.275]                             if (is.null(name)) 
[13:23:33.275]                               next
[13:23:33.275]                             if (!grepl(pattern, name)) 
[13:23:33.275]                               next
[13:23:33.275]                             invokeRestart(restart)
[13:23:33.275]                             muffled <- TRUE
[13:23:33.275]                             break
[13:23:33.275]                           }
[13:23:33.275]                         }
[13:23:33.275]                       }
[13:23:33.275]                       invisible(muffled)
[13:23:33.275]                     }
[13:23:33.275]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.275]                   }
[13:23:33.275]                 }
[13:23:33.275]                 else {
[13:23:33.275]                   if (TRUE) {
[13:23:33.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.275]                     {
[13:23:33.275]                       inherits <- base::inherits
[13:23:33.275]                       invokeRestart <- base::invokeRestart
[13:23:33.275]                       is.null <- base::is.null
[13:23:33.275]                       muffled <- FALSE
[13:23:33.275]                       if (inherits(cond, "message")) {
[13:23:33.275]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.275]                         if (muffled) 
[13:23:33.275]                           invokeRestart("muffleMessage")
[13:23:33.275]                       }
[13:23:33.275]                       else if (inherits(cond, "warning")) {
[13:23:33.275]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.275]                         if (muffled) 
[13:23:33.275]                           invokeRestart("muffleWarning")
[13:23:33.275]                       }
[13:23:33.275]                       else if (inherits(cond, "condition")) {
[13:23:33.275]                         if (!is.null(pattern)) {
[13:23:33.275]                           computeRestarts <- base::computeRestarts
[13:23:33.275]                           grepl <- base::grepl
[13:23:33.275]                           restarts <- computeRestarts(cond)
[13:23:33.275]                           for (restart in restarts) {
[13:23:33.275]                             name <- restart$name
[13:23:33.275]                             if (is.null(name)) 
[13:23:33.275]                               next
[13:23:33.275]                             if (!grepl(pattern, name)) 
[13:23:33.275]                               next
[13:23:33.275]                             invokeRestart(restart)
[13:23:33.275]                             muffled <- TRUE
[13:23:33.275]                             break
[13:23:33.275]                           }
[13:23:33.275]                         }
[13:23:33.275]                       }
[13:23:33.275]                       invisible(muffled)
[13:23:33.275]                     }
[13:23:33.275]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.275]                   }
[13:23:33.275]                 }
[13:23:33.275]             }
[13:23:33.275]         }))
[13:23:33.275]     }, error = function(ex) {
[13:23:33.275]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.275]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.275]                 ...future.rng), started = ...future.startTime, 
[13:23:33.275]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.275]             version = "1.8"), class = "FutureResult")
[13:23:33.275]     }, finally = {
[13:23:33.275]         if (!identical(...future.workdir, getwd())) 
[13:23:33.275]             setwd(...future.workdir)
[13:23:33.275]         {
[13:23:33.275]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.275]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.275]             }
[13:23:33.275]             base::options(...future.oldOptions)
[13:23:33.275]             if (.Platform$OS.type == "windows") {
[13:23:33.275]                 old_names <- names(...future.oldEnvVars)
[13:23:33.275]                 envs <- base::Sys.getenv()
[13:23:33.275]                 names <- names(envs)
[13:23:33.275]                 common <- intersect(names, old_names)
[13:23:33.275]                 added <- setdiff(names, old_names)
[13:23:33.275]                 removed <- setdiff(old_names, names)
[13:23:33.275]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.275]                   envs[common]]
[13:23:33.275]                 NAMES <- toupper(changed)
[13:23:33.275]                 args <- list()
[13:23:33.275]                 for (kk in seq_along(NAMES)) {
[13:23:33.275]                   name <- changed[[kk]]
[13:23:33.275]                   NAME <- NAMES[[kk]]
[13:23:33.275]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.275]                     next
[13:23:33.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.275]                 }
[13:23:33.275]                 NAMES <- toupper(added)
[13:23:33.275]                 for (kk in seq_along(NAMES)) {
[13:23:33.275]                   name <- added[[kk]]
[13:23:33.275]                   NAME <- NAMES[[kk]]
[13:23:33.275]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.275]                     next
[13:23:33.275]                   args[[name]] <- ""
[13:23:33.275]                 }
[13:23:33.275]                 NAMES <- toupper(removed)
[13:23:33.275]                 for (kk in seq_along(NAMES)) {
[13:23:33.275]                   name <- removed[[kk]]
[13:23:33.275]                   NAME <- NAMES[[kk]]
[13:23:33.275]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.275]                     next
[13:23:33.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.275]                 }
[13:23:33.275]                 if (length(args) > 0) 
[13:23:33.275]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.275]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.275]             }
[13:23:33.275]             else {
[13:23:33.275]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.275]             }
[13:23:33.275]             {
[13:23:33.275]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.275]                   0L) {
[13:23:33.275]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.275]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.275]                   base::options(opts)
[13:23:33.275]                 }
[13:23:33.275]                 {
[13:23:33.275]                   {
[13:23:33.275]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:33.275]                     NULL
[13:23:33.275]                   }
[13:23:33.275]                   options(future.plan = NULL)
[13:23:33.275]                   if (is.na(NA_character_)) 
[13:23:33.275]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.275]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.275]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.275]                     envir = parent.frame()) 
[13:23:33.275]                   {
[13:23:33.275]                     default_workers <- missing(workers)
[13:23:33.275]                     if (is.function(workers)) 
[13:23:33.275]                       workers <- workers()
[13:23:33.275]                     workers <- structure(as.integer(workers), 
[13:23:33.275]                       class = class(workers))
[13:23:33.275]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.275]                       1L)
[13:23:33.275]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.275]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.275]                       if (default_workers) 
[13:23:33.275]                         supportsMulticore(warn = TRUE)
[13:23:33.275]                       return(sequential(..., envir = envir))
[13:23:33.275]                     }
[13:23:33.275]                     oopts <- options(mc.cores = workers)
[13:23:33.275]                     on.exit(options(oopts))
[13:23:33.275]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.275]                       envir = envir)
[13:23:33.275]                     if (!future$lazy) 
[13:23:33.275]                       future <- run(future)
[13:23:33.275]                     invisible(future)
[13:23:33.275]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.275]                 }
[13:23:33.275]             }
[13:23:33.275]         }
[13:23:33.275]     })
[13:23:33.275]     if (TRUE) {
[13:23:33.275]         base::sink(type = "output", split = FALSE)
[13:23:33.275]         if (TRUE) {
[13:23:33.275]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.275]         }
[13:23:33.275]         else {
[13:23:33.275]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.275]         }
[13:23:33.275]         base::close(...future.stdout)
[13:23:33.275]         ...future.stdout <- NULL
[13:23:33.275]     }
[13:23:33.275]     ...future.result$conditions <- ...future.conditions
[13:23:33.275]     ...future.result$finished <- base::Sys.time()
[13:23:33.275]     ...future.result
[13:23:33.275] }
[13:23:33.278] assign_globals() ...
[13:23:33.278] List of 2
[13:23:33.278]  $ a : num 1
[13:23:33.278]  $ ii: int 1
[13:23:33.278]  - attr(*, "where")=List of 2
[13:23:33.278]   ..$ a :<environment: R_EmptyEnv> 
[13:23:33.278]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:33.278]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:33.278]  - attr(*, "resolved")= logi TRUE
[13:23:33.278]  - attr(*, "total_size")= num 112
[13:23:33.278]  - attr(*, "already-done")= logi TRUE
[13:23:33.285] - copied ‘a’ to environment
[13:23:33.285] - copied ‘ii’ to environment
[13:23:33.286] assign_globals() ... done
[13:23:33.286] requestCore(): workers = 2
[13:23:33.289] MulticoreFuture started
[13:23:33.289] - Launch lazy future ... done
[13:23:33.290] run() for ‘MulticoreFuture’ ... done
[13:23:33.290] plan(): Setting new future strategy stack:
[13:23:33.290] List of future strategies:
[13:23:33.290] 1. sequential:
[13:23:33.290]    - args: function (..., envir = parent.frame())
[13:23:33.290]    - tweaked: FALSE
[13:23:33.290]    - call: NULL
[13:23:33.292] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:33.292] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:33.293] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:33.294] plan(): Setting new future strategy stack:
[13:23:33.295] List of future strategies:
[13:23:33.295] 1. multicore:
[13:23:33.295]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:33.295]    - tweaked: FALSE
[13:23:33.295]    - call: plan(strategy)
[13:23:33.299] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:33.299] Searching for globals ... DONE
[13:23:33.300] Resolving globals: TRUE
[13:23:33.300] Resolving any globals that are futures ...
[13:23:33.300] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:33.301] Resolving any globals that are futures ... DONE
[13:23:33.301] plan(): nbrOfWorkers() = 2
[13:23:33.302] Resolving futures part of globals (recursively) ...
[13:23:33.302] resolve() on list ...
[13:23:33.302]  recursive: 99
[13:23:33.303]  length: 2
[13:23:33.303]  elements: ‘a’, ‘ii’
[13:23:33.303]  length: 1 (resolved future 1)
[13:23:33.303]  length: 0 (resolved future 2)
[13:23:33.303] resolve() on list ... DONE
[13:23:33.303] - globals: [2] ‘a’, ‘ii’
[13:23:33.304] Resolving futures part of globals (recursively) ... DONE
[13:23:33.304] The total size of the 2 globals is 112 bytes (112 bytes)
[13:23:33.305] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:23:33.305] - globals: [2] ‘a’, ‘ii’
[13:23:33.305] 
[13:23:33.305] getGlobalsAndPackages() ... DONE
[13:23:33.306] run() for ‘Future’ ...
[13:23:33.306] - state: ‘created’
[13:23:33.306] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:33.311] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:33.311] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:33.311]   - Field: ‘label’
[13:23:33.311]   - Field: ‘local’
[13:23:33.312]   - Field: ‘owner’
[13:23:33.312]   - Field: ‘envir’
[13:23:33.312]   - Field: ‘workers’
[13:23:33.312]   - Field: ‘packages’
[13:23:33.312]   - Field: ‘gc’
[13:23:33.312]   - Field: ‘job’
[13:23:33.313]   - Field: ‘conditions’
[13:23:33.313]   - Field: ‘expr’
[13:23:33.313]   - Field: ‘uuid’
[13:23:33.313]   - Field: ‘seed’
[13:23:33.313]   - Field: ‘version’
[13:23:33.313]   - Field: ‘result’
[13:23:33.313]   - Field: ‘asynchronous’
[13:23:33.313]   - Field: ‘calls’
[13:23:33.314]   - Field: ‘globals’
[13:23:33.314]   - Field: ‘stdout’
[13:23:33.314]   - Field: ‘earlySignal’
[13:23:33.314]   - Field: ‘lazy’
[13:23:33.314]   - Field: ‘state’
[13:23:33.314] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:33.314] - Launch lazy future ...
[13:23:33.315] Packages needed by the future expression (n = 0): <none>
[13:23:33.315] Packages needed by future strategies (n = 0): <none>
[13:23:33.316] {
[13:23:33.316]     {
[13:23:33.316]         {
[13:23:33.316]             ...future.startTime <- base::Sys.time()
[13:23:33.316]             {
[13:23:33.316]                 {
[13:23:33.316]                   {
[13:23:33.316]                     {
[13:23:33.316]                       base::local({
[13:23:33.316]                         has_future <- base::requireNamespace("future", 
[13:23:33.316]                           quietly = TRUE)
[13:23:33.316]                         if (has_future) {
[13:23:33.316]                           ns <- base::getNamespace("future")
[13:23:33.316]                           version <- ns[[".package"]][["version"]]
[13:23:33.316]                           if (is.null(version)) 
[13:23:33.316]                             version <- utils::packageVersion("future")
[13:23:33.316]                         }
[13:23:33.316]                         else {
[13:23:33.316]                           version <- NULL
[13:23:33.316]                         }
[13:23:33.316]                         if (!has_future || version < "1.8.0") {
[13:23:33.316]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.316]                             "", base::R.version$version.string), 
[13:23:33.316]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:33.316]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:33.316]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.316]                               "release", "version")], collapse = " "), 
[13:23:33.316]                             hostname = base::Sys.info()[["nodename"]])
[13:23:33.316]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.316]                             info)
[13:23:33.316]                           info <- base::paste(info, collapse = "; ")
[13:23:33.316]                           if (!has_future) {
[13:23:33.316]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.316]                               info)
[13:23:33.316]                           }
[13:23:33.316]                           else {
[13:23:33.316]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.316]                               info, version)
[13:23:33.316]                           }
[13:23:33.316]                           base::stop(msg)
[13:23:33.316]                         }
[13:23:33.316]                       })
[13:23:33.316]                     }
[13:23:33.316]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:33.316]                     base::options(mc.cores = 1L)
[13:23:33.316]                   }
[13:23:33.316]                   options(future.plan = NULL)
[13:23:33.316]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.316]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.316]                 }
[13:23:33.316]                 ...future.workdir <- getwd()
[13:23:33.316]             }
[13:23:33.316]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.316]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.316]         }
[13:23:33.316]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.316]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:33.316]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.316]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.316]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.316]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.316]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.316]             base::names(...future.oldOptions))
[13:23:33.316]     }
[13:23:33.316]     if (FALSE) {
[13:23:33.316]     }
[13:23:33.316]     else {
[13:23:33.316]         if (TRUE) {
[13:23:33.316]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.316]                 open = "w")
[13:23:33.316]         }
[13:23:33.316]         else {
[13:23:33.316]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.316]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.316]         }
[13:23:33.316]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.316]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.316]             base::sink(type = "output", split = FALSE)
[13:23:33.316]             base::close(...future.stdout)
[13:23:33.316]         }, add = TRUE)
[13:23:33.316]     }
[13:23:33.316]     ...future.frame <- base::sys.nframe()
[13:23:33.316]     ...future.conditions <- base::list()
[13:23:33.316]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.316]     if (FALSE) {
[13:23:33.316]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.316]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.316]     }
[13:23:33.316]     ...future.result <- base::tryCatch({
[13:23:33.316]         base::withCallingHandlers({
[13:23:33.316]             ...future.value <- base::withVisible(base::local({
[13:23:33.316]                 withCallingHandlers({
[13:23:33.316]                   {
[13:23:33.316]                     b <- a * ii
[13:23:33.316]                     a <- 0
[13:23:33.316]                     b
[13:23:33.316]                   }
[13:23:33.316]                 }, immediateCondition = function(cond) {
[13:23:33.316]                   save_rds <- function (object, pathname, ...) 
[13:23:33.316]                   {
[13:23:33.316]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:33.316]                     if (file_test("-f", pathname_tmp)) {
[13:23:33.316]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.316]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:33.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.316]                         fi_tmp[["mtime"]])
[13:23:33.316]                     }
[13:23:33.316]                     tryCatch({
[13:23:33.316]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:33.316]                     }, error = function(ex) {
[13:23:33.316]                       msg <- conditionMessage(ex)
[13:23:33.316]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.316]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:33.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.316]                         fi_tmp[["mtime"]], msg)
[13:23:33.316]                       ex$message <- msg
[13:23:33.316]                       stop(ex)
[13:23:33.316]                     })
[13:23:33.316]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:33.316]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:33.316]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:33.316]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.316]                       fi <- file.info(pathname)
[13:23:33.316]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:33.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.316]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:33.316]                         fi[["size"]], fi[["mtime"]])
[13:23:33.316]                       stop(msg)
[13:23:33.316]                     }
[13:23:33.316]                     invisible(pathname)
[13:23:33.316]                   }
[13:23:33.316]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:33.316]                     rootPath = tempdir()) 
[13:23:33.316]                   {
[13:23:33.316]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:33.316]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:33.316]                       tmpdir = path, fileext = ".rds")
[13:23:33.316]                     save_rds(obj, file)
[13:23:33.316]                   }
[13:23:33.316]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:33.316]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.316]                   {
[13:23:33.316]                     inherits <- base::inherits
[13:23:33.316]                     invokeRestart <- base::invokeRestart
[13:23:33.316]                     is.null <- base::is.null
[13:23:33.316]                     muffled <- FALSE
[13:23:33.316]                     if (inherits(cond, "message")) {
[13:23:33.316]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:33.316]                       if (muffled) 
[13:23:33.316]                         invokeRestart("muffleMessage")
[13:23:33.316]                     }
[13:23:33.316]                     else if (inherits(cond, "warning")) {
[13:23:33.316]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:33.316]                       if (muffled) 
[13:23:33.316]                         invokeRestart("muffleWarning")
[13:23:33.316]                     }
[13:23:33.316]                     else if (inherits(cond, "condition")) {
[13:23:33.316]                       if (!is.null(pattern)) {
[13:23:33.316]                         computeRestarts <- base::computeRestarts
[13:23:33.316]                         grepl <- base::grepl
[13:23:33.316]                         restarts <- computeRestarts(cond)
[13:23:33.316]                         for (restart in restarts) {
[13:23:33.316]                           name <- restart$name
[13:23:33.316]                           if (is.null(name)) 
[13:23:33.316]                             next
[13:23:33.316]                           if (!grepl(pattern, name)) 
[13:23:33.316]                             next
[13:23:33.316]                           invokeRestart(restart)
[13:23:33.316]                           muffled <- TRUE
[13:23:33.316]                           break
[13:23:33.316]                         }
[13:23:33.316]                       }
[13:23:33.316]                     }
[13:23:33.316]                     invisible(muffled)
[13:23:33.316]                   }
[13:23:33.316]                   muffleCondition(cond)
[13:23:33.316]                 })
[13:23:33.316]             }))
[13:23:33.316]             future::FutureResult(value = ...future.value$value, 
[13:23:33.316]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.316]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.316]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.316]                     ...future.globalenv.names))
[13:23:33.316]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.316]         }, condition = base::local({
[13:23:33.316]             c <- base::c
[13:23:33.316]             inherits <- base::inherits
[13:23:33.316]             invokeRestart <- base::invokeRestart
[13:23:33.316]             length <- base::length
[13:23:33.316]             list <- base::list
[13:23:33.316]             seq.int <- base::seq.int
[13:23:33.316]             signalCondition <- base::signalCondition
[13:23:33.316]             sys.calls <- base::sys.calls
[13:23:33.316]             `[[` <- base::`[[`
[13:23:33.316]             `+` <- base::`+`
[13:23:33.316]             `<<-` <- base::`<<-`
[13:23:33.316]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.316]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.316]                   3L)]
[13:23:33.316]             }
[13:23:33.316]             function(cond) {
[13:23:33.316]                 is_error <- inherits(cond, "error")
[13:23:33.316]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.316]                   NULL)
[13:23:33.316]                 if (is_error) {
[13:23:33.316]                   sessionInformation <- function() {
[13:23:33.316]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.316]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.316]                       search = base::search(), system = base::Sys.info())
[13:23:33.316]                   }
[13:23:33.316]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.316]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.316]                     cond$call), session = sessionInformation(), 
[13:23:33.316]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.316]                   signalCondition(cond)
[13:23:33.316]                 }
[13:23:33.316]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.316]                 "immediateCondition"))) {
[13:23:33.316]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.316]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.316]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.316]                   if (TRUE && !signal) {
[13:23:33.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.316]                     {
[13:23:33.316]                       inherits <- base::inherits
[13:23:33.316]                       invokeRestart <- base::invokeRestart
[13:23:33.316]                       is.null <- base::is.null
[13:23:33.316]                       muffled <- FALSE
[13:23:33.316]                       if (inherits(cond, "message")) {
[13:23:33.316]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.316]                         if (muffled) 
[13:23:33.316]                           invokeRestart("muffleMessage")
[13:23:33.316]                       }
[13:23:33.316]                       else if (inherits(cond, "warning")) {
[13:23:33.316]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.316]                         if (muffled) 
[13:23:33.316]                           invokeRestart("muffleWarning")
[13:23:33.316]                       }
[13:23:33.316]                       else if (inherits(cond, "condition")) {
[13:23:33.316]                         if (!is.null(pattern)) {
[13:23:33.316]                           computeRestarts <- base::computeRestarts
[13:23:33.316]                           grepl <- base::grepl
[13:23:33.316]                           restarts <- computeRestarts(cond)
[13:23:33.316]                           for (restart in restarts) {
[13:23:33.316]                             name <- restart$name
[13:23:33.316]                             if (is.null(name)) 
[13:23:33.316]                               next
[13:23:33.316]                             if (!grepl(pattern, name)) 
[13:23:33.316]                               next
[13:23:33.316]                             invokeRestart(restart)
[13:23:33.316]                             muffled <- TRUE
[13:23:33.316]                             break
[13:23:33.316]                           }
[13:23:33.316]                         }
[13:23:33.316]                       }
[13:23:33.316]                       invisible(muffled)
[13:23:33.316]                     }
[13:23:33.316]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.316]                   }
[13:23:33.316]                 }
[13:23:33.316]                 else {
[13:23:33.316]                   if (TRUE) {
[13:23:33.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.316]                     {
[13:23:33.316]                       inherits <- base::inherits
[13:23:33.316]                       invokeRestart <- base::invokeRestart
[13:23:33.316]                       is.null <- base::is.null
[13:23:33.316]                       muffled <- FALSE
[13:23:33.316]                       if (inherits(cond, "message")) {
[13:23:33.316]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.316]                         if (muffled) 
[13:23:33.316]                           invokeRestart("muffleMessage")
[13:23:33.316]                       }
[13:23:33.316]                       else if (inherits(cond, "warning")) {
[13:23:33.316]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.316]                         if (muffled) 
[13:23:33.316]                           invokeRestart("muffleWarning")
[13:23:33.316]                       }
[13:23:33.316]                       else if (inherits(cond, "condition")) {
[13:23:33.316]                         if (!is.null(pattern)) {
[13:23:33.316]                           computeRestarts <- base::computeRestarts
[13:23:33.316]                           grepl <- base::grepl
[13:23:33.316]                           restarts <- computeRestarts(cond)
[13:23:33.316]                           for (restart in restarts) {
[13:23:33.316]                             name <- restart$name
[13:23:33.316]                             if (is.null(name)) 
[13:23:33.316]                               next
[13:23:33.316]                             if (!grepl(pattern, name)) 
[13:23:33.316]                               next
[13:23:33.316]                             invokeRestart(restart)
[13:23:33.316]                             muffled <- TRUE
[13:23:33.316]                             break
[13:23:33.316]                           }
[13:23:33.316]                         }
[13:23:33.316]                       }
[13:23:33.316]                       invisible(muffled)
[13:23:33.316]                     }
[13:23:33.316]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.316]                   }
[13:23:33.316]                 }
[13:23:33.316]             }
[13:23:33.316]         }))
[13:23:33.316]     }, error = function(ex) {
[13:23:33.316]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.316]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.316]                 ...future.rng), started = ...future.startTime, 
[13:23:33.316]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.316]             version = "1.8"), class = "FutureResult")
[13:23:33.316]     }, finally = {
[13:23:33.316]         if (!identical(...future.workdir, getwd())) 
[13:23:33.316]             setwd(...future.workdir)
[13:23:33.316]         {
[13:23:33.316]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.316]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.316]             }
[13:23:33.316]             base::options(...future.oldOptions)
[13:23:33.316]             if (.Platform$OS.type == "windows") {
[13:23:33.316]                 old_names <- names(...future.oldEnvVars)
[13:23:33.316]                 envs <- base::Sys.getenv()
[13:23:33.316]                 names <- names(envs)
[13:23:33.316]                 common <- intersect(names, old_names)
[13:23:33.316]                 added <- setdiff(names, old_names)
[13:23:33.316]                 removed <- setdiff(old_names, names)
[13:23:33.316]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.316]                   envs[common]]
[13:23:33.316]                 NAMES <- toupper(changed)
[13:23:33.316]                 args <- list()
[13:23:33.316]                 for (kk in seq_along(NAMES)) {
[13:23:33.316]                   name <- changed[[kk]]
[13:23:33.316]                   NAME <- NAMES[[kk]]
[13:23:33.316]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.316]                     next
[13:23:33.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.316]                 }
[13:23:33.316]                 NAMES <- toupper(added)
[13:23:33.316]                 for (kk in seq_along(NAMES)) {
[13:23:33.316]                   name <- added[[kk]]
[13:23:33.316]                   NAME <- NAMES[[kk]]
[13:23:33.316]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.316]                     next
[13:23:33.316]                   args[[name]] <- ""
[13:23:33.316]                 }
[13:23:33.316]                 NAMES <- toupper(removed)
[13:23:33.316]                 for (kk in seq_along(NAMES)) {
[13:23:33.316]                   name <- removed[[kk]]
[13:23:33.316]                   NAME <- NAMES[[kk]]
[13:23:33.316]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.316]                     next
[13:23:33.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.316]                 }
[13:23:33.316]                 if (length(args) > 0) 
[13:23:33.316]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.316]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.316]             }
[13:23:33.316]             else {
[13:23:33.316]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.316]             }
[13:23:33.316]             {
[13:23:33.316]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.316]                   0L) {
[13:23:33.316]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.316]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.316]                   base::options(opts)
[13:23:33.316]                 }
[13:23:33.316]                 {
[13:23:33.316]                   {
[13:23:33.316]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:33.316]                     NULL
[13:23:33.316]                   }
[13:23:33.316]                   options(future.plan = NULL)
[13:23:33.316]                   if (is.na(NA_character_)) 
[13:23:33.316]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.316]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.316]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.316]                     envir = parent.frame()) 
[13:23:33.316]                   {
[13:23:33.316]                     default_workers <- missing(workers)
[13:23:33.316]                     if (is.function(workers)) 
[13:23:33.316]                       workers <- workers()
[13:23:33.316]                     workers <- structure(as.integer(workers), 
[13:23:33.316]                       class = class(workers))
[13:23:33.316]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.316]                       1L)
[13:23:33.316]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.316]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.316]                       if (default_workers) 
[13:23:33.316]                         supportsMulticore(warn = TRUE)
[13:23:33.316]                       return(sequential(..., envir = envir))
[13:23:33.316]                     }
[13:23:33.316]                     oopts <- options(mc.cores = workers)
[13:23:33.316]                     on.exit(options(oopts))
[13:23:33.316]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.316]                       envir = envir)
[13:23:33.316]                     if (!future$lazy) 
[13:23:33.316]                       future <- run(future)
[13:23:33.316]                     invisible(future)
[13:23:33.316]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.316]                 }
[13:23:33.316]             }
[13:23:33.316]         }
[13:23:33.316]     })
[13:23:33.316]     if (TRUE) {
[13:23:33.316]         base::sink(type = "output", split = FALSE)
[13:23:33.316]         if (TRUE) {
[13:23:33.316]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.316]         }
[13:23:33.316]         else {
[13:23:33.316]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.316]         }
[13:23:33.316]         base::close(...future.stdout)
[13:23:33.316]         ...future.stdout <- NULL
[13:23:33.316]     }
[13:23:33.316]     ...future.result$conditions <- ...future.conditions
[13:23:33.316]     ...future.result$finished <- base::Sys.time()
[13:23:33.316]     ...future.result
[13:23:33.316] }
[13:23:33.319] assign_globals() ...
[13:23:33.319] List of 2
[13:23:33.319]  $ a : num 1
[13:23:33.319]  $ ii: int 2
[13:23:33.319]  - attr(*, "where")=List of 2
[13:23:33.319]   ..$ a :<environment: R_EmptyEnv> 
[13:23:33.319]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:33.319]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:33.319]  - attr(*, "resolved")= logi TRUE
[13:23:33.319]  - attr(*, "total_size")= num 112
[13:23:33.319]  - attr(*, "already-done")= logi TRUE
[13:23:33.324] - copied ‘a’ to environment
[13:23:33.324] - copied ‘ii’ to environment
[13:23:33.324] assign_globals() ... done
[13:23:33.324] requestCore(): workers = 2
[13:23:33.327] MulticoreFuture started
[13:23:33.327] - Launch lazy future ... done
[13:23:33.327] run() for ‘MulticoreFuture’ ... done
[13:23:33.328] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:33.329] getGlobalsAndPackages() ...
[13:23:33.328] List of future strategies:
[13:23:33.328] 1. sequential:
[13:23:33.328]    - args: function (..., envir = parent.frame())
[13:23:33.328]    - tweaked: FALSE
[13:23:33.328]    - call: NULL
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:33.329] Searching for globals...
[13:23:33.329] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:33.331] plan(): Setting new future strategy stack:
[13:23:33.331] List of future strategies:
[13:23:33.331] 1. multicore:
[13:23:33.331]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:33.331]    - tweaked: FALSE
[13:23:33.331]    - call: plan(strategy)
[13:23:33.340] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:33.340] Searching for globals ... DONE
[13:23:33.341] plan(): nbrOfWorkers() = 2
[13:23:33.341] Resolving globals: TRUE
[13:23:33.341] Resolving any globals that are futures ...
[13:23:33.341] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:33.341] Resolving any globals that are futures ... DONE
[13:23:33.342] Resolving futures part of globals (recursively) ...
[13:23:33.343] resolve() on list ...
[13:23:33.343]  recursive: 99
[13:23:33.344]  length: 2
[13:23:33.344]  elements: ‘a’, ‘ii’
[13:23:33.344]  length: 1 (resolved future 1)
[13:23:33.344]  length: 0 (resolved future 2)
[13:23:33.345] resolve() on list ... DONE
[13:23:33.345] - globals: [2] ‘a’, ‘ii’
[13:23:33.345] Resolving futures part of globals (recursively) ... DONE
[13:23:33.345] The total size of the 2 globals is 112 bytes (112 bytes)
[13:23:33.346] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:23:33.346] - globals: [2] ‘a’, ‘ii’
[13:23:33.347] 
[13:23:33.347] getGlobalsAndPackages() ... DONE
[13:23:33.347] run() for ‘Future’ ...
[13:23:33.348] - state: ‘created’
[13:23:33.348] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:33.353] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:33.353] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:33.353]   - Field: ‘label’
[13:23:33.354]   - Field: ‘local’
[13:23:33.354]   - Field: ‘owner’
[13:23:33.354]   - Field: ‘envir’
[13:23:33.354]   - Field: ‘workers’
[13:23:33.354]   - Field: ‘packages’
[13:23:33.354]   - Field: ‘gc’
[13:23:33.355]   - Field: ‘job’
[13:23:33.355]   - Field: ‘conditions’
[13:23:33.355]   - Field: ‘expr’
[13:23:33.355]   - Field: ‘uuid’
[13:23:33.355]   - Field: ‘seed’
[13:23:33.355]   - Field: ‘version’
[13:23:33.355]   - Field: ‘result’
[13:23:33.356]   - Field: ‘asynchronous’
[13:23:33.356]   - Field: ‘calls’
[13:23:33.356]   - Field: ‘globals’
[13:23:33.356]   - Field: ‘stdout’
[13:23:33.356]   - Field: ‘earlySignal’
[13:23:33.356]   - Field: ‘lazy’
[13:23:33.356]   - Field: ‘state’
[13:23:33.357] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:33.357] - Launch lazy future ...
[13:23:33.357] Packages needed by the future expression (n = 0): <none>
[13:23:33.357] Packages needed by future strategies (n = 0): <none>
[13:23:33.358] {
[13:23:33.358]     {
[13:23:33.358]         {
[13:23:33.358]             ...future.startTime <- base::Sys.time()
[13:23:33.358]             {
[13:23:33.358]                 {
[13:23:33.358]                   {
[13:23:33.358]                     {
[13:23:33.358]                       base::local({
[13:23:33.358]                         has_future <- base::requireNamespace("future", 
[13:23:33.358]                           quietly = TRUE)
[13:23:33.358]                         if (has_future) {
[13:23:33.358]                           ns <- base::getNamespace("future")
[13:23:33.358]                           version <- ns[[".package"]][["version"]]
[13:23:33.358]                           if (is.null(version)) 
[13:23:33.358]                             version <- utils::packageVersion("future")
[13:23:33.358]                         }
[13:23:33.358]                         else {
[13:23:33.358]                           version <- NULL
[13:23:33.358]                         }
[13:23:33.358]                         if (!has_future || version < "1.8.0") {
[13:23:33.358]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.358]                             "", base::R.version$version.string), 
[13:23:33.358]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:33.358]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:33.358]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.358]                               "release", "version")], collapse = " "), 
[13:23:33.358]                             hostname = base::Sys.info()[["nodename"]])
[13:23:33.358]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.358]                             info)
[13:23:33.358]                           info <- base::paste(info, collapse = "; ")
[13:23:33.358]                           if (!has_future) {
[13:23:33.358]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.358]                               info)
[13:23:33.358]                           }
[13:23:33.358]                           else {
[13:23:33.358]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.358]                               info, version)
[13:23:33.358]                           }
[13:23:33.358]                           base::stop(msg)
[13:23:33.358]                         }
[13:23:33.358]                       })
[13:23:33.358]                     }
[13:23:33.358]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:33.358]                     base::options(mc.cores = 1L)
[13:23:33.358]                   }
[13:23:33.358]                   options(future.plan = NULL)
[13:23:33.358]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.358]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.358]                 }
[13:23:33.358]                 ...future.workdir <- getwd()
[13:23:33.358]             }
[13:23:33.358]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.358]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.358]         }
[13:23:33.358]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.358]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:33.358]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.358]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.358]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.358]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.358]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.358]             base::names(...future.oldOptions))
[13:23:33.358]     }
[13:23:33.358]     if (FALSE) {
[13:23:33.358]     }
[13:23:33.358]     else {
[13:23:33.358]         if (TRUE) {
[13:23:33.358]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.358]                 open = "w")
[13:23:33.358]         }
[13:23:33.358]         else {
[13:23:33.358]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.358]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.358]         }
[13:23:33.358]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.358]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.358]             base::sink(type = "output", split = FALSE)
[13:23:33.358]             base::close(...future.stdout)
[13:23:33.358]         }, add = TRUE)
[13:23:33.358]     }
[13:23:33.358]     ...future.frame <- base::sys.nframe()
[13:23:33.358]     ...future.conditions <- base::list()
[13:23:33.358]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.358]     if (FALSE) {
[13:23:33.358]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.358]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.358]     }
[13:23:33.358]     ...future.result <- base::tryCatch({
[13:23:33.358]         base::withCallingHandlers({
[13:23:33.358]             ...future.value <- base::withVisible(base::local({
[13:23:33.358]                 withCallingHandlers({
[13:23:33.358]                   {
[13:23:33.358]                     b <- a * ii
[13:23:33.358]                     a <- 0
[13:23:33.358]                     b
[13:23:33.358]                   }
[13:23:33.358]                 }, immediateCondition = function(cond) {
[13:23:33.358]                   save_rds <- function (object, pathname, ...) 
[13:23:33.358]                   {
[13:23:33.358]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:33.358]                     if (file_test("-f", pathname_tmp)) {
[13:23:33.358]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.358]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:33.358]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.358]                         fi_tmp[["mtime"]])
[13:23:33.358]                     }
[13:23:33.358]                     tryCatch({
[13:23:33.358]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:33.358]                     }, error = function(ex) {
[13:23:33.358]                       msg <- conditionMessage(ex)
[13:23:33.358]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.358]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:33.358]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.358]                         fi_tmp[["mtime"]], msg)
[13:23:33.358]                       ex$message <- msg
[13:23:33.358]                       stop(ex)
[13:23:33.358]                     })
[13:23:33.358]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:33.358]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:33.358]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:33.358]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.358]                       fi <- file.info(pathname)
[13:23:33.358]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:33.358]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.358]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:33.358]                         fi[["size"]], fi[["mtime"]])
[13:23:33.358]                       stop(msg)
[13:23:33.358]                     }
[13:23:33.358]                     invisible(pathname)
[13:23:33.358]                   }
[13:23:33.358]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:33.358]                     rootPath = tempdir()) 
[13:23:33.358]                   {
[13:23:33.358]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:33.358]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:33.358]                       tmpdir = path, fileext = ".rds")
[13:23:33.358]                     save_rds(obj, file)
[13:23:33.358]                   }
[13:23:33.358]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:33.358]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.358]                   {
[13:23:33.358]                     inherits <- base::inherits
[13:23:33.358]                     invokeRestart <- base::invokeRestart
[13:23:33.358]                     is.null <- base::is.null
[13:23:33.358]                     muffled <- FALSE
[13:23:33.358]                     if (inherits(cond, "message")) {
[13:23:33.358]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:33.358]                       if (muffled) 
[13:23:33.358]                         invokeRestart("muffleMessage")
[13:23:33.358]                     }
[13:23:33.358]                     else if (inherits(cond, "warning")) {
[13:23:33.358]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:33.358]                       if (muffled) 
[13:23:33.358]                         invokeRestart("muffleWarning")
[13:23:33.358]                     }
[13:23:33.358]                     else if (inherits(cond, "condition")) {
[13:23:33.358]                       if (!is.null(pattern)) {
[13:23:33.358]                         computeRestarts <- base::computeRestarts
[13:23:33.358]                         grepl <- base::grepl
[13:23:33.358]                         restarts <- computeRestarts(cond)
[13:23:33.358]                         for (restart in restarts) {
[13:23:33.358]                           name <- restart$name
[13:23:33.358]                           if (is.null(name)) 
[13:23:33.358]                             next
[13:23:33.358]                           if (!grepl(pattern, name)) 
[13:23:33.358]                             next
[13:23:33.358]                           invokeRestart(restart)
[13:23:33.358]                           muffled <- TRUE
[13:23:33.358]                           break
[13:23:33.358]                         }
[13:23:33.358]                       }
[13:23:33.358]                     }
[13:23:33.358]                     invisible(muffled)
[13:23:33.358]                   }
[13:23:33.358]                   muffleCondition(cond)
[13:23:33.358]                 })
[13:23:33.358]             }))
[13:23:33.358]             future::FutureResult(value = ...future.value$value, 
[13:23:33.358]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.358]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.358]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.358]                     ...future.globalenv.names))
[13:23:33.358]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.358]         }, condition = base::local({
[13:23:33.358]             c <- base::c
[13:23:33.358]             inherits <- base::inherits
[13:23:33.358]             invokeRestart <- base::invokeRestart
[13:23:33.358]             length <- base::length
[13:23:33.358]             list <- base::list
[13:23:33.358]             seq.int <- base::seq.int
[13:23:33.358]             signalCondition <- base::signalCondition
[13:23:33.358]             sys.calls <- base::sys.calls
[13:23:33.358]             `[[` <- base::`[[`
[13:23:33.358]             `+` <- base::`+`
[13:23:33.358]             `<<-` <- base::`<<-`
[13:23:33.358]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.358]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.358]                   3L)]
[13:23:33.358]             }
[13:23:33.358]             function(cond) {
[13:23:33.358]                 is_error <- inherits(cond, "error")
[13:23:33.358]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.358]                   NULL)
[13:23:33.358]                 if (is_error) {
[13:23:33.358]                   sessionInformation <- function() {
[13:23:33.358]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.358]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.358]                       search = base::search(), system = base::Sys.info())
[13:23:33.358]                   }
[13:23:33.358]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.358]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.358]                     cond$call), session = sessionInformation(), 
[13:23:33.358]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.358]                   signalCondition(cond)
[13:23:33.358]                 }
[13:23:33.358]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.358]                 "immediateCondition"))) {
[13:23:33.358]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.358]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.358]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.358]                   if (TRUE && !signal) {
[13:23:33.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.358]                     {
[13:23:33.358]                       inherits <- base::inherits
[13:23:33.358]                       invokeRestart <- base::invokeRestart
[13:23:33.358]                       is.null <- base::is.null
[13:23:33.358]                       muffled <- FALSE
[13:23:33.358]                       if (inherits(cond, "message")) {
[13:23:33.358]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.358]                         if (muffled) 
[13:23:33.358]                           invokeRestart("muffleMessage")
[13:23:33.358]                       }
[13:23:33.358]                       else if (inherits(cond, "warning")) {
[13:23:33.358]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.358]                         if (muffled) 
[13:23:33.358]                           invokeRestart("muffleWarning")
[13:23:33.358]                       }
[13:23:33.358]                       else if (inherits(cond, "condition")) {
[13:23:33.358]                         if (!is.null(pattern)) {
[13:23:33.358]                           computeRestarts <- base::computeRestarts
[13:23:33.358]                           grepl <- base::grepl
[13:23:33.358]                           restarts <- computeRestarts(cond)
[13:23:33.358]                           for (restart in restarts) {
[13:23:33.358]                             name <- restart$name
[13:23:33.358]                             if (is.null(name)) 
[13:23:33.358]                               next
[13:23:33.358]                             if (!grepl(pattern, name)) 
[13:23:33.358]                               next
[13:23:33.358]                             invokeRestart(restart)
[13:23:33.358]                             muffled <- TRUE
[13:23:33.358]                             break
[13:23:33.358]                           }
[13:23:33.358]                         }
[13:23:33.358]                       }
[13:23:33.358]                       invisible(muffled)
[13:23:33.358]                     }
[13:23:33.358]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.358]                   }
[13:23:33.358]                 }
[13:23:33.358]                 else {
[13:23:33.358]                   if (TRUE) {
[13:23:33.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.358]                     {
[13:23:33.358]                       inherits <- base::inherits
[13:23:33.358]                       invokeRestart <- base::invokeRestart
[13:23:33.358]                       is.null <- base::is.null
[13:23:33.358]                       muffled <- FALSE
[13:23:33.358]                       if (inherits(cond, "message")) {
[13:23:33.358]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.358]                         if (muffled) 
[13:23:33.358]                           invokeRestart("muffleMessage")
[13:23:33.358]                       }
[13:23:33.358]                       else if (inherits(cond, "warning")) {
[13:23:33.358]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.358]                         if (muffled) 
[13:23:33.358]                           invokeRestart("muffleWarning")
[13:23:33.358]                       }
[13:23:33.358]                       else if (inherits(cond, "condition")) {
[13:23:33.358]                         if (!is.null(pattern)) {
[13:23:33.358]                           computeRestarts <- base::computeRestarts
[13:23:33.358]                           grepl <- base::grepl
[13:23:33.358]                           restarts <- computeRestarts(cond)
[13:23:33.358]                           for (restart in restarts) {
[13:23:33.358]                             name <- restart$name
[13:23:33.358]                             if (is.null(name)) 
[13:23:33.358]                               next
[13:23:33.358]                             if (!grepl(pattern, name)) 
[13:23:33.358]                               next
[13:23:33.358]                             invokeRestart(restart)
[13:23:33.358]                             muffled <- TRUE
[13:23:33.358]                             break
[13:23:33.358]                           }
[13:23:33.358]                         }
[13:23:33.358]                       }
[13:23:33.358]                       invisible(muffled)
[13:23:33.358]                     }
[13:23:33.358]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.358]                   }
[13:23:33.358]                 }
[13:23:33.358]             }
[13:23:33.358]         }))
[13:23:33.358]     }, error = function(ex) {
[13:23:33.358]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.358]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.358]                 ...future.rng), started = ...future.startTime, 
[13:23:33.358]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.358]             version = "1.8"), class = "FutureResult")
[13:23:33.358]     }, finally = {
[13:23:33.358]         if (!identical(...future.workdir, getwd())) 
[13:23:33.358]             setwd(...future.workdir)
[13:23:33.358]         {
[13:23:33.358]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.358]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.358]             }
[13:23:33.358]             base::options(...future.oldOptions)
[13:23:33.358]             if (.Platform$OS.type == "windows") {
[13:23:33.358]                 old_names <- names(...future.oldEnvVars)
[13:23:33.358]                 envs <- base::Sys.getenv()
[13:23:33.358]                 names <- names(envs)
[13:23:33.358]                 common <- intersect(names, old_names)
[13:23:33.358]                 added <- setdiff(names, old_names)
[13:23:33.358]                 removed <- setdiff(old_names, names)
[13:23:33.358]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.358]                   envs[common]]
[13:23:33.358]                 NAMES <- toupper(changed)
[13:23:33.358]                 args <- list()
[13:23:33.358]                 for (kk in seq_along(NAMES)) {
[13:23:33.358]                   name <- changed[[kk]]
[13:23:33.358]                   NAME <- NAMES[[kk]]
[13:23:33.358]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.358]                     next
[13:23:33.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.358]                 }
[13:23:33.358]                 NAMES <- toupper(added)
[13:23:33.358]                 for (kk in seq_along(NAMES)) {
[13:23:33.358]                   name <- added[[kk]]
[13:23:33.358]                   NAME <- NAMES[[kk]]
[13:23:33.358]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.358]                     next
[13:23:33.358]                   args[[name]] <- ""
[13:23:33.358]                 }
[13:23:33.358]                 NAMES <- toupper(removed)
[13:23:33.358]                 for (kk in seq_along(NAMES)) {
[13:23:33.358]                   name <- removed[[kk]]
[13:23:33.358]                   NAME <- NAMES[[kk]]
[13:23:33.358]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.358]                     next
[13:23:33.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.358]                 }
[13:23:33.358]                 if (length(args) > 0) 
[13:23:33.358]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.358]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.358]             }
[13:23:33.358]             else {
[13:23:33.358]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.358]             }
[13:23:33.358]             {
[13:23:33.358]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.358]                   0L) {
[13:23:33.358]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.358]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.358]                   base::options(opts)
[13:23:33.358]                 }
[13:23:33.358]                 {
[13:23:33.358]                   {
[13:23:33.358]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:33.358]                     NULL
[13:23:33.358]                   }
[13:23:33.358]                   options(future.plan = NULL)
[13:23:33.358]                   if (is.na(NA_character_)) 
[13:23:33.358]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.358]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.358]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.358]                     envir = parent.frame()) 
[13:23:33.358]                   {
[13:23:33.358]                     default_workers <- missing(workers)
[13:23:33.358]                     if (is.function(workers)) 
[13:23:33.358]                       workers <- workers()
[13:23:33.358]                     workers <- structure(as.integer(workers), 
[13:23:33.358]                       class = class(workers))
[13:23:33.358]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.358]                       1L)
[13:23:33.358]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.358]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.358]                       if (default_workers) 
[13:23:33.358]                         supportsMulticore(warn = TRUE)
[13:23:33.358]                       return(sequential(..., envir = envir))
[13:23:33.358]                     }
[13:23:33.358]                     oopts <- options(mc.cores = workers)
[13:23:33.358]                     on.exit(options(oopts))
[13:23:33.358]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.358]                       envir = envir)
[13:23:33.358]                     if (!future$lazy) 
[13:23:33.358]                       future <- run(future)
[13:23:33.358]                     invisible(future)
[13:23:33.358]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.358]                 }
[13:23:33.358]             }
[13:23:33.358]         }
[13:23:33.358]     })
[13:23:33.358]     if (TRUE) {
[13:23:33.358]         base::sink(type = "output", split = FALSE)
[13:23:33.358]         if (TRUE) {
[13:23:33.358]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.358]         }
[13:23:33.358]         else {
[13:23:33.358]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.358]         }
[13:23:33.358]         base::close(...future.stdout)
[13:23:33.358]         ...future.stdout <- NULL
[13:23:33.358]     }
[13:23:33.358]     ...future.result$conditions <- ...future.conditions
[13:23:33.358]     ...future.result$finished <- base::Sys.time()
[13:23:33.358]     ...future.result
[13:23:33.358] }
[13:23:33.361] assign_globals() ...
[13:23:33.361] List of 2
[13:23:33.361]  $ a : num 1
[13:23:33.361]  $ ii: int 3
[13:23:33.361]  - attr(*, "where")=List of 2
[13:23:33.361]   ..$ a :<environment: R_EmptyEnv> 
[13:23:33.361]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:33.361]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:33.361]  - attr(*, "resolved")= logi TRUE
[13:23:33.361]  - attr(*, "total_size")= num 112
[13:23:33.361]  - attr(*, "already-done")= logi TRUE
[13:23:33.365] - copied ‘a’ to environment
[13:23:33.365] - copied ‘ii’ to environment
[13:23:33.365] assign_globals() ... done
[13:23:33.366] requestCore(): workers = 2
[13:23:33.366] Poll #1 (0): usedCores() = 2, workers = 2
[13:23:33.389] result() for MulticoreFuture ...
[13:23:33.390] result() for MulticoreFuture ...
[13:23:33.390] result() for MulticoreFuture ... done
[13:23:33.390] result() for MulticoreFuture ... done
[13:23:33.390] result() for MulticoreFuture ...
[13:23:33.390] result() for MulticoreFuture ... done
[13:23:33.393] MulticoreFuture started
[13:23:33.394] - Launch lazy future ... done
[13:23:33.394] run() for ‘MulticoreFuture’ ... done
[13:23:33.394] plan(): Setting new future strategy stack:
[13:23:33.395] result() for MulticoreFuture ...
[13:23:33.396] result() for MulticoreFuture ... done
[13:23:33.395] List of future strategies:
[13:23:33.395] 1. sequential:
[13:23:33.395]    - args: function (..., envir = parent.frame())
[13:23:33.395]    - tweaked: FALSE
[13:23:33.395]    - call: NULL
[13:23:33.396] result() for MulticoreFuture ...
[13:23:33.396] plan(): nbrOfWorkers() = 1
[13:23:33.396] result() for MulticoreFuture ... done
[13:23:33.397] result() for MulticoreFuture ...
[13:23:33.399] result() for MulticoreFuture ...
[13:23:33.399] result() for MulticoreFuture ... done
[13:23:33.399] plan(): Setting new future strategy stack:
[13:23:33.399] result() for MulticoreFuture ... done
[13:23:33.400] result() for MulticoreFuture ...
[13:23:33.399] List of future strategies:
[13:23:33.399] 1. multicore:
[13:23:33.399]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:33.399]    - tweaked: FALSE
[13:23:33.399]    - call: plan(strategy)
[13:23:33.400] result() for MulticoreFuture ... done
[13:23:33.400] result() for MulticoreFuture ...
[13:23:33.405] plan(): nbrOfWorkers() = 2
[13:23:33.406] result() for MulticoreFuture ...
[13:23:33.406] result() for MulticoreFuture ... done
[13:23:33.406] result() for MulticoreFuture ... done
[13:23:33.407] result() for MulticoreFuture ...
[13:23:33.407] result() for MulticoreFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:33.408] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:33.408] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:33.411] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:33.411] Searching for globals ... DONE
[13:23:33.411] Resolving globals: TRUE
[13:23:33.411] Resolving any globals that are futures ...
[13:23:33.412] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:33.412] Resolving any globals that are futures ... DONE
[13:23:33.412] Resolving futures part of globals (recursively) ...
[13:23:33.413] resolve() on list ...
[13:23:33.413]  recursive: 99
[13:23:33.413]  length: 2
[13:23:33.413]  elements: ‘a’, ‘ii’
[13:23:33.413]  length: 1 (resolved future 1)
[13:23:33.413]  length: 0 (resolved future 2)
[13:23:33.413] resolve() on list ... DONE
[13:23:33.413] - globals: [2] ‘a’, ‘ii’
[13:23:33.414] Resolving futures part of globals (recursively) ... DONE
[13:23:33.414] The total size of the 2 globals is 112 bytes (112 bytes)
[13:23:33.414] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:23:33.414] - globals: [2] ‘a’, ‘ii’
[13:23:33.415] 
[13:23:33.415] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:33.416] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:33.416] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:33.418] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:33.418] Searching for globals ... DONE
[13:23:33.418] Resolving globals: TRUE
[13:23:33.419] Resolving any globals that are futures ...
[13:23:33.419] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:33.419] Resolving any globals that are futures ... DONE
[13:23:33.419] Resolving futures part of globals (recursively) ...
[13:23:33.420] resolve() on list ...
[13:23:33.420]  recursive: 99
[13:23:33.422]  length: 2
[13:23:33.422]  elements: ‘a’, ‘ii’
[13:23:33.422]  length: 1 (resolved future 1)
[13:23:33.422]  length: 0 (resolved future 2)
[13:23:33.423] resolve() on list ... DONE
[13:23:33.423] - globals: [2] ‘a’, ‘ii’
[13:23:33.423] Resolving futures part of globals (recursively) ... DONE
[13:23:33.423] The total size of the 2 globals is 112 bytes (112 bytes)
[13:23:33.424] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:23:33.424] - globals: [2] ‘a’, ‘ii’
[13:23:33.424] 
[13:23:33.424] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:33.425] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:33.425] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:33.429] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:33.429] Searching for globals ... DONE
[13:23:33.429] Resolving globals: TRUE
[13:23:33.429] Resolving any globals that are futures ...
[13:23:33.429] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:33.429] Resolving any globals that are futures ... DONE
[13:23:33.430] Resolving futures part of globals (recursively) ...
[13:23:33.430] resolve() on list ...
[13:23:33.430]  recursive: 99
[13:23:33.430]  length: 2
[13:23:33.430]  elements: ‘a’, ‘ii’
[13:23:33.430]  length: 1 (resolved future 1)
[13:23:33.431]  length: 0 (resolved future 2)
[13:23:33.431] resolve() on list ... DONE
[13:23:33.431] - globals: [2] ‘a’, ‘ii’
[13:23:33.431] Resolving futures part of globals (recursively) ... DONE
[13:23:33.431] The total size of the 2 globals is 112 bytes (112 bytes)
[13:23:33.431] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:23:33.432] - globals: [2] ‘a’, ‘ii’
[13:23:33.432] 
[13:23:33.432] getGlobalsAndPackages() ... DONE
[13:23:33.432] run() for ‘Future’ ...
[13:23:33.432] - state: ‘created’
[13:23:33.433] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:33.437] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:33.437] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:33.437]   - Field: ‘label’
[13:23:33.437]   - Field: ‘local’
[13:23:33.437]   - Field: ‘owner’
[13:23:33.437]   - Field: ‘envir’
[13:23:33.437]   - Field: ‘workers’
[13:23:33.437]   - Field: ‘packages’
[13:23:33.438]   - Field: ‘gc’
[13:23:33.438]   - Field: ‘job’
[13:23:33.438]   - Field: ‘conditions’
[13:23:33.438]   - Field: ‘expr’
[13:23:33.438]   - Field: ‘uuid’
[13:23:33.438]   - Field: ‘seed’
[13:23:33.438]   - Field: ‘version’
[13:23:33.438]   - Field: ‘result’
[13:23:33.438]   - Field: ‘asynchronous’
[13:23:33.438]   - Field: ‘calls’
[13:23:33.438]   - Field: ‘globals’
[13:23:33.439]   - Field: ‘stdout’
[13:23:33.439]   - Field: ‘earlySignal’
[13:23:33.439]   - Field: ‘lazy’
[13:23:33.439]   - Field: ‘state’
[13:23:33.439] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:33.439] - Launch lazy future ...
[13:23:33.439] Packages needed by the future expression (n = 0): <none>
[13:23:33.440] Packages needed by future strategies (n = 0): <none>
[13:23:33.440] {
[13:23:33.440]     {
[13:23:33.440]         {
[13:23:33.440]             ...future.startTime <- base::Sys.time()
[13:23:33.440]             {
[13:23:33.440]                 {
[13:23:33.440]                   {
[13:23:33.440]                     {
[13:23:33.440]                       base::local({
[13:23:33.440]                         has_future <- base::requireNamespace("future", 
[13:23:33.440]                           quietly = TRUE)
[13:23:33.440]                         if (has_future) {
[13:23:33.440]                           ns <- base::getNamespace("future")
[13:23:33.440]                           version <- ns[[".package"]][["version"]]
[13:23:33.440]                           if (is.null(version)) 
[13:23:33.440]                             version <- utils::packageVersion("future")
[13:23:33.440]                         }
[13:23:33.440]                         else {
[13:23:33.440]                           version <- NULL
[13:23:33.440]                         }
[13:23:33.440]                         if (!has_future || version < "1.8.0") {
[13:23:33.440]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.440]                             "", base::R.version$version.string), 
[13:23:33.440]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:33.440]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:33.440]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.440]                               "release", "version")], collapse = " "), 
[13:23:33.440]                             hostname = base::Sys.info()[["nodename"]])
[13:23:33.440]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.440]                             info)
[13:23:33.440]                           info <- base::paste(info, collapse = "; ")
[13:23:33.440]                           if (!has_future) {
[13:23:33.440]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.440]                               info)
[13:23:33.440]                           }
[13:23:33.440]                           else {
[13:23:33.440]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.440]                               info, version)
[13:23:33.440]                           }
[13:23:33.440]                           base::stop(msg)
[13:23:33.440]                         }
[13:23:33.440]                       })
[13:23:33.440]                     }
[13:23:33.440]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:33.440]                     base::options(mc.cores = 1L)
[13:23:33.440]                   }
[13:23:33.440]                   options(future.plan = NULL)
[13:23:33.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.440]                 }
[13:23:33.440]                 ...future.workdir <- getwd()
[13:23:33.440]             }
[13:23:33.440]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.440]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.440]         }
[13:23:33.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.440]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:33.440]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.440]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.440]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.440]             base::names(...future.oldOptions))
[13:23:33.440]     }
[13:23:33.440]     if (FALSE) {
[13:23:33.440]     }
[13:23:33.440]     else {
[13:23:33.440]         if (TRUE) {
[13:23:33.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.440]                 open = "w")
[13:23:33.440]         }
[13:23:33.440]         else {
[13:23:33.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.440]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.440]         }
[13:23:33.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.440]             base::sink(type = "output", split = FALSE)
[13:23:33.440]             base::close(...future.stdout)
[13:23:33.440]         }, add = TRUE)
[13:23:33.440]     }
[13:23:33.440]     ...future.frame <- base::sys.nframe()
[13:23:33.440]     ...future.conditions <- base::list()
[13:23:33.440]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.440]     if (FALSE) {
[13:23:33.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.440]     }
[13:23:33.440]     ...future.result <- base::tryCatch({
[13:23:33.440]         base::withCallingHandlers({
[13:23:33.440]             ...future.value <- base::withVisible(base::local({
[13:23:33.440]                 withCallingHandlers({
[13:23:33.440]                   {
[13:23:33.440]                     b <- a * ii
[13:23:33.440]                     a <- 0
[13:23:33.440]                     b
[13:23:33.440]                   }
[13:23:33.440]                 }, immediateCondition = function(cond) {
[13:23:33.440]                   save_rds <- function (object, pathname, ...) 
[13:23:33.440]                   {
[13:23:33.440]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:33.440]                     if (file_test("-f", pathname_tmp)) {
[13:23:33.440]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.440]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:33.440]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.440]                         fi_tmp[["mtime"]])
[13:23:33.440]                     }
[13:23:33.440]                     tryCatch({
[13:23:33.440]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:33.440]                     }, error = function(ex) {
[13:23:33.440]                       msg <- conditionMessage(ex)
[13:23:33.440]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.440]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:33.440]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.440]                         fi_tmp[["mtime"]], msg)
[13:23:33.440]                       ex$message <- msg
[13:23:33.440]                       stop(ex)
[13:23:33.440]                     })
[13:23:33.440]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:33.440]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:33.440]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:33.440]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.440]                       fi <- file.info(pathname)
[13:23:33.440]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:33.440]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.440]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:33.440]                         fi[["size"]], fi[["mtime"]])
[13:23:33.440]                       stop(msg)
[13:23:33.440]                     }
[13:23:33.440]                     invisible(pathname)
[13:23:33.440]                   }
[13:23:33.440]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:33.440]                     rootPath = tempdir()) 
[13:23:33.440]                   {
[13:23:33.440]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:33.440]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:33.440]                       tmpdir = path, fileext = ".rds")
[13:23:33.440]                     save_rds(obj, file)
[13:23:33.440]                   }
[13:23:33.440]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:33.440]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.440]                   {
[13:23:33.440]                     inherits <- base::inherits
[13:23:33.440]                     invokeRestart <- base::invokeRestart
[13:23:33.440]                     is.null <- base::is.null
[13:23:33.440]                     muffled <- FALSE
[13:23:33.440]                     if (inherits(cond, "message")) {
[13:23:33.440]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:33.440]                       if (muffled) 
[13:23:33.440]                         invokeRestart("muffleMessage")
[13:23:33.440]                     }
[13:23:33.440]                     else if (inherits(cond, "warning")) {
[13:23:33.440]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:33.440]                       if (muffled) 
[13:23:33.440]                         invokeRestart("muffleWarning")
[13:23:33.440]                     }
[13:23:33.440]                     else if (inherits(cond, "condition")) {
[13:23:33.440]                       if (!is.null(pattern)) {
[13:23:33.440]                         computeRestarts <- base::computeRestarts
[13:23:33.440]                         grepl <- base::grepl
[13:23:33.440]                         restarts <- computeRestarts(cond)
[13:23:33.440]                         for (restart in restarts) {
[13:23:33.440]                           name <- restart$name
[13:23:33.440]                           if (is.null(name)) 
[13:23:33.440]                             next
[13:23:33.440]                           if (!grepl(pattern, name)) 
[13:23:33.440]                             next
[13:23:33.440]                           invokeRestart(restart)
[13:23:33.440]                           muffled <- TRUE
[13:23:33.440]                           break
[13:23:33.440]                         }
[13:23:33.440]                       }
[13:23:33.440]                     }
[13:23:33.440]                     invisible(muffled)
[13:23:33.440]                   }
[13:23:33.440]                   muffleCondition(cond)
[13:23:33.440]                 })
[13:23:33.440]             }))
[13:23:33.440]             future::FutureResult(value = ...future.value$value, 
[13:23:33.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.440]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.440]                     ...future.globalenv.names))
[13:23:33.440]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.440]         }, condition = base::local({
[13:23:33.440]             c <- base::c
[13:23:33.440]             inherits <- base::inherits
[13:23:33.440]             invokeRestart <- base::invokeRestart
[13:23:33.440]             length <- base::length
[13:23:33.440]             list <- base::list
[13:23:33.440]             seq.int <- base::seq.int
[13:23:33.440]             signalCondition <- base::signalCondition
[13:23:33.440]             sys.calls <- base::sys.calls
[13:23:33.440]             `[[` <- base::`[[`
[13:23:33.440]             `+` <- base::`+`
[13:23:33.440]             `<<-` <- base::`<<-`
[13:23:33.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.440]                   3L)]
[13:23:33.440]             }
[13:23:33.440]             function(cond) {
[13:23:33.440]                 is_error <- inherits(cond, "error")
[13:23:33.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.440]                   NULL)
[13:23:33.440]                 if (is_error) {
[13:23:33.440]                   sessionInformation <- function() {
[13:23:33.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.440]                       search = base::search(), system = base::Sys.info())
[13:23:33.440]                   }
[13:23:33.440]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.440]                     cond$call), session = sessionInformation(), 
[13:23:33.440]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.440]                   signalCondition(cond)
[13:23:33.440]                 }
[13:23:33.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.440]                 "immediateCondition"))) {
[13:23:33.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.440]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.440]                   if (TRUE && !signal) {
[13:23:33.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.440]                     {
[13:23:33.440]                       inherits <- base::inherits
[13:23:33.440]                       invokeRestart <- base::invokeRestart
[13:23:33.440]                       is.null <- base::is.null
[13:23:33.440]                       muffled <- FALSE
[13:23:33.440]                       if (inherits(cond, "message")) {
[13:23:33.440]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.440]                         if (muffled) 
[13:23:33.440]                           invokeRestart("muffleMessage")
[13:23:33.440]                       }
[13:23:33.440]                       else if (inherits(cond, "warning")) {
[13:23:33.440]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.440]                         if (muffled) 
[13:23:33.440]                           invokeRestart("muffleWarning")
[13:23:33.440]                       }
[13:23:33.440]                       else if (inherits(cond, "condition")) {
[13:23:33.440]                         if (!is.null(pattern)) {
[13:23:33.440]                           computeRestarts <- base::computeRestarts
[13:23:33.440]                           grepl <- base::grepl
[13:23:33.440]                           restarts <- computeRestarts(cond)
[13:23:33.440]                           for (restart in restarts) {
[13:23:33.440]                             name <- restart$name
[13:23:33.440]                             if (is.null(name)) 
[13:23:33.440]                               next
[13:23:33.440]                             if (!grepl(pattern, name)) 
[13:23:33.440]                               next
[13:23:33.440]                             invokeRestart(restart)
[13:23:33.440]                             muffled <- TRUE
[13:23:33.440]                             break
[13:23:33.440]                           }
[13:23:33.440]                         }
[13:23:33.440]                       }
[13:23:33.440]                       invisible(muffled)
[13:23:33.440]                     }
[13:23:33.440]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.440]                   }
[13:23:33.440]                 }
[13:23:33.440]                 else {
[13:23:33.440]                   if (TRUE) {
[13:23:33.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.440]                     {
[13:23:33.440]                       inherits <- base::inherits
[13:23:33.440]                       invokeRestart <- base::invokeRestart
[13:23:33.440]                       is.null <- base::is.null
[13:23:33.440]                       muffled <- FALSE
[13:23:33.440]                       if (inherits(cond, "message")) {
[13:23:33.440]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.440]                         if (muffled) 
[13:23:33.440]                           invokeRestart("muffleMessage")
[13:23:33.440]                       }
[13:23:33.440]                       else if (inherits(cond, "warning")) {
[13:23:33.440]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.440]                         if (muffled) 
[13:23:33.440]                           invokeRestart("muffleWarning")
[13:23:33.440]                       }
[13:23:33.440]                       else if (inherits(cond, "condition")) {
[13:23:33.440]                         if (!is.null(pattern)) {
[13:23:33.440]                           computeRestarts <- base::computeRestarts
[13:23:33.440]                           grepl <- base::grepl
[13:23:33.440]                           restarts <- computeRestarts(cond)
[13:23:33.440]                           for (restart in restarts) {
[13:23:33.440]                             name <- restart$name
[13:23:33.440]                             if (is.null(name)) 
[13:23:33.440]                               next
[13:23:33.440]                             if (!grepl(pattern, name)) 
[13:23:33.440]                               next
[13:23:33.440]                             invokeRestart(restart)
[13:23:33.440]                             muffled <- TRUE
[13:23:33.440]                             break
[13:23:33.440]                           }
[13:23:33.440]                         }
[13:23:33.440]                       }
[13:23:33.440]                       invisible(muffled)
[13:23:33.440]                     }
[13:23:33.440]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.440]                   }
[13:23:33.440]                 }
[13:23:33.440]             }
[13:23:33.440]         }))
[13:23:33.440]     }, error = function(ex) {
[13:23:33.440]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.440]                 ...future.rng), started = ...future.startTime, 
[13:23:33.440]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.440]             version = "1.8"), class = "FutureResult")
[13:23:33.440]     }, finally = {
[13:23:33.440]         if (!identical(...future.workdir, getwd())) 
[13:23:33.440]             setwd(...future.workdir)
[13:23:33.440]         {
[13:23:33.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.440]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.440]             }
[13:23:33.440]             base::options(...future.oldOptions)
[13:23:33.440]             if (.Platform$OS.type == "windows") {
[13:23:33.440]                 old_names <- names(...future.oldEnvVars)
[13:23:33.440]                 envs <- base::Sys.getenv()
[13:23:33.440]                 names <- names(envs)
[13:23:33.440]                 common <- intersect(names, old_names)
[13:23:33.440]                 added <- setdiff(names, old_names)
[13:23:33.440]                 removed <- setdiff(old_names, names)
[13:23:33.440]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.440]                   envs[common]]
[13:23:33.440]                 NAMES <- toupper(changed)
[13:23:33.440]                 args <- list()
[13:23:33.440]                 for (kk in seq_along(NAMES)) {
[13:23:33.440]                   name <- changed[[kk]]
[13:23:33.440]                   NAME <- NAMES[[kk]]
[13:23:33.440]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.440]                     next
[13:23:33.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.440]                 }
[13:23:33.440]                 NAMES <- toupper(added)
[13:23:33.440]                 for (kk in seq_along(NAMES)) {
[13:23:33.440]                   name <- added[[kk]]
[13:23:33.440]                   NAME <- NAMES[[kk]]
[13:23:33.440]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.440]                     next
[13:23:33.440]                   args[[name]] <- ""
[13:23:33.440]                 }
[13:23:33.440]                 NAMES <- toupper(removed)
[13:23:33.440]                 for (kk in seq_along(NAMES)) {
[13:23:33.440]                   name <- removed[[kk]]
[13:23:33.440]                   NAME <- NAMES[[kk]]
[13:23:33.440]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.440]                     next
[13:23:33.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.440]                 }
[13:23:33.440]                 if (length(args) > 0) 
[13:23:33.440]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.440]             }
[13:23:33.440]             else {
[13:23:33.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.440]             }
[13:23:33.440]             {
[13:23:33.440]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.440]                   0L) {
[13:23:33.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.440]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.440]                   base::options(opts)
[13:23:33.440]                 }
[13:23:33.440]                 {
[13:23:33.440]                   {
[13:23:33.440]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:33.440]                     NULL
[13:23:33.440]                   }
[13:23:33.440]                   options(future.plan = NULL)
[13:23:33.440]                   if (is.na(NA_character_)) 
[13:23:33.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.440]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.440]                     envir = parent.frame()) 
[13:23:33.440]                   {
[13:23:33.440]                     default_workers <- missing(workers)
[13:23:33.440]                     if (is.function(workers)) 
[13:23:33.440]                       workers <- workers()
[13:23:33.440]                     workers <- structure(as.integer(workers), 
[13:23:33.440]                       class = class(workers))
[13:23:33.440]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.440]                       1L)
[13:23:33.440]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.440]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.440]                       if (default_workers) 
[13:23:33.440]                         supportsMulticore(warn = TRUE)
[13:23:33.440]                       return(sequential(..., envir = envir))
[13:23:33.440]                     }
[13:23:33.440]                     oopts <- options(mc.cores = workers)
[13:23:33.440]                     on.exit(options(oopts))
[13:23:33.440]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.440]                       envir = envir)
[13:23:33.440]                     if (!future$lazy) 
[13:23:33.440]                       future <- run(future)
[13:23:33.440]                     invisible(future)
[13:23:33.440]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.440]                 }
[13:23:33.440]             }
[13:23:33.440]         }
[13:23:33.440]     })
[13:23:33.440]     if (TRUE) {
[13:23:33.440]         base::sink(type = "output", split = FALSE)
[13:23:33.440]         if (TRUE) {
[13:23:33.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.440]         }
[13:23:33.440]         else {
[13:23:33.440]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.440]         }
[13:23:33.440]         base::close(...future.stdout)
[13:23:33.440]         ...future.stdout <- NULL
[13:23:33.440]     }
[13:23:33.440]     ...future.result$conditions <- ...future.conditions
[13:23:33.440]     ...future.result$finished <- base::Sys.time()
[13:23:33.440]     ...future.result
[13:23:33.440] }
[13:23:33.443] assign_globals() ...
[13:23:33.443] List of 2
[13:23:33.443]  $ a : num 1
[13:23:33.443]  $ ii: int 1
[13:23:33.443]  - attr(*, "where")=List of 2
[13:23:33.443]   ..$ a :<environment: R_EmptyEnv> 
[13:23:33.443]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:33.443]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:33.443]  - attr(*, "resolved")= logi TRUE
[13:23:33.443]  - attr(*, "total_size")= num 112
[13:23:33.443]  - attr(*, "already-done")= logi TRUE
[13:23:33.446] - copied ‘a’ to environment
[13:23:33.446] - copied ‘ii’ to environment
[13:23:33.446] assign_globals() ... done
[13:23:33.447] requestCore(): workers = 2
[13:23:33.449] MulticoreFuture started
[13:23:33.449] - Launch lazy future ... done
[13:23:33.450] run() for ‘MulticoreFuture’ ... done
[13:23:33.450] result() for MulticoreFuture ...
[13:23:33.450] plan(): Setting new future strategy stack:
[13:23:33.450] List of future strategies:
[13:23:33.450] 1. sequential:
[13:23:33.450]    - args: function (..., envir = parent.frame())
[13:23:33.450]    - tweaked: FALSE
[13:23:33.450]    - call: NULL
[13:23:33.451] plan(): nbrOfWorkers() = 1
[13:23:33.454] plan(): Setting new future strategy stack:
[13:23:33.454] List of future strategies:
[13:23:33.454] 1. multicore:
[13:23:33.454]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:33.454]    - tweaked: FALSE
[13:23:33.454]    - call: plan(strategy)
[13:23:33.464] plan(): nbrOfWorkers() = 2
[13:23:33.465] result() for MulticoreFuture ...
[13:23:33.466] result() for MulticoreFuture ... done
[13:23:33.466] result() for MulticoreFuture ... done
[13:23:33.466] result() for MulticoreFuture ...
[13:23:33.466] result() for MulticoreFuture ... done
[13:23:33.466] run() for ‘Future’ ...
[13:23:33.467] - state: ‘created’
[13:23:33.467] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:33.475] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:33.476] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:33.476]   - Field: ‘label’
[13:23:33.476]   - Field: ‘local’
[13:23:33.477]   - Field: ‘owner’
[13:23:33.477]   - Field: ‘envir’
[13:23:33.477]   - Field: ‘workers’
[13:23:33.477]   - Field: ‘packages’
[13:23:33.477]   - Field: ‘gc’
[13:23:33.477]   - Field: ‘job’
[13:23:33.478]   - Field: ‘conditions’
[13:23:33.478]   - Field: ‘expr’
[13:23:33.478]   - Field: ‘uuid’
[13:23:33.478]   - Field: ‘seed’
[13:23:33.478]   - Field: ‘version’
[13:23:33.478]   - Field: ‘result’
[13:23:33.478]   - Field: ‘asynchronous’
[13:23:33.479]   - Field: ‘calls’
[13:23:33.479]   - Field: ‘globals’
[13:23:33.479]   - Field: ‘stdout’
[13:23:33.479]   - Field: ‘earlySignal’
[13:23:33.479]   - Field: ‘lazy’
[13:23:33.479]   - Field: ‘state’
[13:23:33.480] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:33.480] - Launch lazy future ...
[13:23:33.480] Packages needed by the future expression (n = 0): <none>
[13:23:33.481] Packages needed by future strategies (n = 0): <none>
[13:23:33.481] {
[13:23:33.481]     {
[13:23:33.481]         {
[13:23:33.481]             ...future.startTime <- base::Sys.time()
[13:23:33.481]             {
[13:23:33.481]                 {
[13:23:33.481]                   {
[13:23:33.481]                     {
[13:23:33.481]                       base::local({
[13:23:33.481]                         has_future <- base::requireNamespace("future", 
[13:23:33.481]                           quietly = TRUE)
[13:23:33.481]                         if (has_future) {
[13:23:33.481]                           ns <- base::getNamespace("future")
[13:23:33.481]                           version <- ns[[".package"]][["version"]]
[13:23:33.481]                           if (is.null(version)) 
[13:23:33.481]                             version <- utils::packageVersion("future")
[13:23:33.481]                         }
[13:23:33.481]                         else {
[13:23:33.481]                           version <- NULL
[13:23:33.481]                         }
[13:23:33.481]                         if (!has_future || version < "1.8.0") {
[13:23:33.481]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.481]                             "", base::R.version$version.string), 
[13:23:33.481]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:33.481]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:33.481]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.481]                               "release", "version")], collapse = " "), 
[13:23:33.481]                             hostname = base::Sys.info()[["nodename"]])
[13:23:33.481]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.481]                             info)
[13:23:33.481]                           info <- base::paste(info, collapse = "; ")
[13:23:33.481]                           if (!has_future) {
[13:23:33.481]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.481]                               info)
[13:23:33.481]                           }
[13:23:33.481]                           else {
[13:23:33.481]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.481]                               info, version)
[13:23:33.481]                           }
[13:23:33.481]                           base::stop(msg)
[13:23:33.481]                         }
[13:23:33.481]                       })
[13:23:33.481]                     }
[13:23:33.481]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:33.481]                     base::options(mc.cores = 1L)
[13:23:33.481]                   }
[13:23:33.481]                   options(future.plan = NULL)
[13:23:33.481]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.481]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.481]                 }
[13:23:33.481]                 ...future.workdir <- getwd()
[13:23:33.481]             }
[13:23:33.481]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.481]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.481]         }
[13:23:33.481]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.481]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:33.481]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.481]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.481]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.481]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.481]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.481]             base::names(...future.oldOptions))
[13:23:33.481]     }
[13:23:33.481]     if (FALSE) {
[13:23:33.481]     }
[13:23:33.481]     else {
[13:23:33.481]         if (TRUE) {
[13:23:33.481]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.481]                 open = "w")
[13:23:33.481]         }
[13:23:33.481]         else {
[13:23:33.481]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.481]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.481]         }
[13:23:33.481]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.481]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.481]             base::sink(type = "output", split = FALSE)
[13:23:33.481]             base::close(...future.stdout)
[13:23:33.481]         }, add = TRUE)
[13:23:33.481]     }
[13:23:33.481]     ...future.frame <- base::sys.nframe()
[13:23:33.481]     ...future.conditions <- base::list()
[13:23:33.481]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.481]     if (FALSE) {
[13:23:33.481]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.481]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.481]     }
[13:23:33.481]     ...future.result <- base::tryCatch({
[13:23:33.481]         base::withCallingHandlers({
[13:23:33.481]             ...future.value <- base::withVisible(base::local({
[13:23:33.481]                 withCallingHandlers({
[13:23:33.481]                   {
[13:23:33.481]                     b <- a * ii
[13:23:33.481]                     a <- 0
[13:23:33.481]                     b
[13:23:33.481]                   }
[13:23:33.481]                 }, immediateCondition = function(cond) {
[13:23:33.481]                   save_rds <- function (object, pathname, ...) 
[13:23:33.481]                   {
[13:23:33.481]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:33.481]                     if (file_test("-f", pathname_tmp)) {
[13:23:33.481]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.481]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:33.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.481]                         fi_tmp[["mtime"]])
[13:23:33.481]                     }
[13:23:33.481]                     tryCatch({
[13:23:33.481]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:33.481]                     }, error = function(ex) {
[13:23:33.481]                       msg <- conditionMessage(ex)
[13:23:33.481]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.481]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:33.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.481]                         fi_tmp[["mtime"]], msg)
[13:23:33.481]                       ex$message <- msg
[13:23:33.481]                       stop(ex)
[13:23:33.481]                     })
[13:23:33.481]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:33.481]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:33.481]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:33.481]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.481]                       fi <- file.info(pathname)
[13:23:33.481]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:33.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.481]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:33.481]                         fi[["size"]], fi[["mtime"]])
[13:23:33.481]                       stop(msg)
[13:23:33.481]                     }
[13:23:33.481]                     invisible(pathname)
[13:23:33.481]                   }
[13:23:33.481]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:33.481]                     rootPath = tempdir()) 
[13:23:33.481]                   {
[13:23:33.481]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:33.481]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:33.481]                       tmpdir = path, fileext = ".rds")
[13:23:33.481]                     save_rds(obj, file)
[13:23:33.481]                   }
[13:23:33.481]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:33.481]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.481]                   {
[13:23:33.481]                     inherits <- base::inherits
[13:23:33.481]                     invokeRestart <- base::invokeRestart
[13:23:33.481]                     is.null <- base::is.null
[13:23:33.481]                     muffled <- FALSE
[13:23:33.481]                     if (inherits(cond, "message")) {
[13:23:33.481]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:33.481]                       if (muffled) 
[13:23:33.481]                         invokeRestart("muffleMessage")
[13:23:33.481]                     }
[13:23:33.481]                     else if (inherits(cond, "warning")) {
[13:23:33.481]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:33.481]                       if (muffled) 
[13:23:33.481]                         invokeRestart("muffleWarning")
[13:23:33.481]                     }
[13:23:33.481]                     else if (inherits(cond, "condition")) {
[13:23:33.481]                       if (!is.null(pattern)) {
[13:23:33.481]                         computeRestarts <- base::computeRestarts
[13:23:33.481]                         grepl <- base::grepl
[13:23:33.481]                         restarts <- computeRestarts(cond)
[13:23:33.481]                         for (restart in restarts) {
[13:23:33.481]                           name <- restart$name
[13:23:33.481]                           if (is.null(name)) 
[13:23:33.481]                             next
[13:23:33.481]                           if (!grepl(pattern, name)) 
[13:23:33.481]                             next
[13:23:33.481]                           invokeRestart(restart)
[13:23:33.481]                           muffled <- TRUE
[13:23:33.481]                           break
[13:23:33.481]                         }
[13:23:33.481]                       }
[13:23:33.481]                     }
[13:23:33.481]                     invisible(muffled)
[13:23:33.481]                   }
[13:23:33.481]                   muffleCondition(cond)
[13:23:33.481]                 })
[13:23:33.481]             }))
[13:23:33.481]             future::FutureResult(value = ...future.value$value, 
[13:23:33.481]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.481]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.481]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.481]                     ...future.globalenv.names))
[13:23:33.481]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.481]         }, condition = base::local({
[13:23:33.481]             c <- base::c
[13:23:33.481]             inherits <- base::inherits
[13:23:33.481]             invokeRestart <- base::invokeRestart
[13:23:33.481]             length <- base::length
[13:23:33.481]             list <- base::list
[13:23:33.481]             seq.int <- base::seq.int
[13:23:33.481]             signalCondition <- base::signalCondition
[13:23:33.481]             sys.calls <- base::sys.calls
[13:23:33.481]             `[[` <- base::`[[`
[13:23:33.481]             `+` <- base::`+`
[13:23:33.481]             `<<-` <- base::`<<-`
[13:23:33.481]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.481]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.481]                   3L)]
[13:23:33.481]             }
[13:23:33.481]             function(cond) {
[13:23:33.481]                 is_error <- inherits(cond, "error")
[13:23:33.481]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.481]                   NULL)
[13:23:33.481]                 if (is_error) {
[13:23:33.481]                   sessionInformation <- function() {
[13:23:33.481]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.481]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.481]                       search = base::search(), system = base::Sys.info())
[13:23:33.481]                   }
[13:23:33.481]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.481]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.481]                     cond$call), session = sessionInformation(), 
[13:23:33.481]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.481]                   signalCondition(cond)
[13:23:33.481]                 }
[13:23:33.481]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.481]                 "immediateCondition"))) {
[13:23:33.481]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.481]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.481]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.481]                   if (TRUE && !signal) {
[13:23:33.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.481]                     {
[13:23:33.481]                       inherits <- base::inherits
[13:23:33.481]                       invokeRestart <- base::invokeRestart
[13:23:33.481]                       is.null <- base::is.null
[13:23:33.481]                       muffled <- FALSE
[13:23:33.481]                       if (inherits(cond, "message")) {
[13:23:33.481]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.481]                         if (muffled) 
[13:23:33.481]                           invokeRestart("muffleMessage")
[13:23:33.481]                       }
[13:23:33.481]                       else if (inherits(cond, "warning")) {
[13:23:33.481]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.481]                         if (muffled) 
[13:23:33.481]                           invokeRestart("muffleWarning")
[13:23:33.481]                       }
[13:23:33.481]                       else if (inherits(cond, "condition")) {
[13:23:33.481]                         if (!is.null(pattern)) {
[13:23:33.481]                           computeRestarts <- base::computeRestarts
[13:23:33.481]                           grepl <- base::grepl
[13:23:33.481]                           restarts <- computeRestarts(cond)
[13:23:33.481]                           for (restart in restarts) {
[13:23:33.481]                             name <- restart$name
[13:23:33.481]                             if (is.null(name)) 
[13:23:33.481]                               next
[13:23:33.481]                             if (!grepl(pattern, name)) 
[13:23:33.481]                               next
[13:23:33.481]                             invokeRestart(restart)
[13:23:33.481]                             muffled <- TRUE
[13:23:33.481]                             break
[13:23:33.481]                           }
[13:23:33.481]                         }
[13:23:33.481]                       }
[13:23:33.481]                       invisible(muffled)
[13:23:33.481]                     }
[13:23:33.481]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.481]                   }
[13:23:33.481]                 }
[13:23:33.481]                 else {
[13:23:33.481]                   if (TRUE) {
[13:23:33.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.481]                     {
[13:23:33.481]                       inherits <- base::inherits
[13:23:33.481]                       invokeRestart <- base::invokeRestart
[13:23:33.481]                       is.null <- base::is.null
[13:23:33.481]                       muffled <- FALSE
[13:23:33.481]                       if (inherits(cond, "message")) {
[13:23:33.481]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.481]                         if (muffled) 
[13:23:33.481]                           invokeRestart("muffleMessage")
[13:23:33.481]                       }
[13:23:33.481]                       else if (inherits(cond, "warning")) {
[13:23:33.481]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.481]                         if (muffled) 
[13:23:33.481]                           invokeRestart("muffleWarning")
[13:23:33.481]                       }
[13:23:33.481]                       else if (inherits(cond, "condition")) {
[13:23:33.481]                         if (!is.null(pattern)) {
[13:23:33.481]                           computeRestarts <- base::computeRestarts
[13:23:33.481]                           grepl <- base::grepl
[13:23:33.481]                           restarts <- computeRestarts(cond)
[13:23:33.481]                           for (restart in restarts) {
[13:23:33.481]                             name <- restart$name
[13:23:33.481]                             if (is.null(name)) 
[13:23:33.481]                               next
[13:23:33.481]                             if (!grepl(pattern, name)) 
[13:23:33.481]                               next
[13:23:33.481]                             invokeRestart(restart)
[13:23:33.481]                             muffled <- TRUE
[13:23:33.481]                             break
[13:23:33.481]                           }
[13:23:33.481]                         }
[13:23:33.481]                       }
[13:23:33.481]                       invisible(muffled)
[13:23:33.481]                     }
[13:23:33.481]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.481]                   }
[13:23:33.481]                 }
[13:23:33.481]             }
[13:23:33.481]         }))
[13:23:33.481]     }, error = function(ex) {
[13:23:33.481]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.481]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.481]                 ...future.rng), started = ...future.startTime, 
[13:23:33.481]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.481]             version = "1.8"), class = "FutureResult")
[13:23:33.481]     }, finally = {
[13:23:33.481]         if (!identical(...future.workdir, getwd())) 
[13:23:33.481]             setwd(...future.workdir)
[13:23:33.481]         {
[13:23:33.481]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.481]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.481]             }
[13:23:33.481]             base::options(...future.oldOptions)
[13:23:33.481]             if (.Platform$OS.type == "windows") {
[13:23:33.481]                 old_names <- names(...future.oldEnvVars)
[13:23:33.481]                 envs <- base::Sys.getenv()
[13:23:33.481]                 names <- names(envs)
[13:23:33.481]                 common <- intersect(names, old_names)
[13:23:33.481]                 added <- setdiff(names, old_names)
[13:23:33.481]                 removed <- setdiff(old_names, names)
[13:23:33.481]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.481]                   envs[common]]
[13:23:33.481]                 NAMES <- toupper(changed)
[13:23:33.481]                 args <- list()
[13:23:33.481]                 for (kk in seq_along(NAMES)) {
[13:23:33.481]                   name <- changed[[kk]]
[13:23:33.481]                   NAME <- NAMES[[kk]]
[13:23:33.481]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.481]                     next
[13:23:33.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.481]                 }
[13:23:33.481]                 NAMES <- toupper(added)
[13:23:33.481]                 for (kk in seq_along(NAMES)) {
[13:23:33.481]                   name <- added[[kk]]
[13:23:33.481]                   NAME <- NAMES[[kk]]
[13:23:33.481]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.481]                     next
[13:23:33.481]                   args[[name]] <- ""
[13:23:33.481]                 }
[13:23:33.481]                 NAMES <- toupper(removed)
[13:23:33.481]                 for (kk in seq_along(NAMES)) {
[13:23:33.481]                   name <- removed[[kk]]
[13:23:33.481]                   NAME <- NAMES[[kk]]
[13:23:33.481]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.481]                     next
[13:23:33.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.481]                 }
[13:23:33.481]                 if (length(args) > 0) 
[13:23:33.481]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.481]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.481]             }
[13:23:33.481]             else {
[13:23:33.481]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.481]             }
[13:23:33.481]             {
[13:23:33.481]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.481]                   0L) {
[13:23:33.481]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.481]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.481]                   base::options(opts)
[13:23:33.481]                 }
[13:23:33.481]                 {
[13:23:33.481]                   {
[13:23:33.481]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:33.481]                     NULL
[13:23:33.481]                   }
[13:23:33.481]                   options(future.plan = NULL)
[13:23:33.481]                   if (is.na(NA_character_)) 
[13:23:33.481]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.481]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.481]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.481]                     envir = parent.frame()) 
[13:23:33.481]                   {
[13:23:33.481]                     default_workers <- missing(workers)
[13:23:33.481]                     if (is.function(workers)) 
[13:23:33.481]                       workers <- workers()
[13:23:33.481]                     workers <- structure(as.integer(workers), 
[13:23:33.481]                       class = class(workers))
[13:23:33.481]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.481]                       1L)
[13:23:33.481]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.481]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.481]                       if (default_workers) 
[13:23:33.481]                         supportsMulticore(warn = TRUE)
[13:23:33.481]                       return(sequential(..., envir = envir))
[13:23:33.481]                     }
[13:23:33.481]                     oopts <- options(mc.cores = workers)
[13:23:33.481]                     on.exit(options(oopts))
[13:23:33.481]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.481]                       envir = envir)
[13:23:33.481]                     if (!future$lazy) 
[13:23:33.481]                       future <- run(future)
[13:23:33.481]                     invisible(future)
[13:23:33.481]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.481]                 }
[13:23:33.481]             }
[13:23:33.481]         }
[13:23:33.481]     })
[13:23:33.481]     if (TRUE) {
[13:23:33.481]         base::sink(type = "output", split = FALSE)
[13:23:33.481]         if (TRUE) {
[13:23:33.481]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.481]         }
[13:23:33.481]         else {
[13:23:33.481]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.481]         }
[13:23:33.481]         base::close(...future.stdout)
[13:23:33.481]         ...future.stdout <- NULL
[13:23:33.481]     }
[13:23:33.481]     ...future.result$conditions <- ...future.conditions
[13:23:33.481]     ...future.result$finished <- base::Sys.time()
[13:23:33.481]     ...future.result
[13:23:33.481] }
[13:23:33.484] assign_globals() ...
[13:23:33.484] List of 2
[13:23:33.484]  $ a : num 1
[13:23:33.484]  $ ii: int 2
[13:23:33.484]  - attr(*, "where")=List of 2
[13:23:33.484]   ..$ a :<environment: R_EmptyEnv> 
[13:23:33.484]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:33.484]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:33.484]  - attr(*, "resolved")= logi TRUE
[13:23:33.484]  - attr(*, "total_size")= num 112
[13:23:33.484]  - attr(*, "already-done")= logi TRUE
[13:23:33.489] - copied ‘a’ to environment
[13:23:33.489] - copied ‘ii’ to environment
[13:23:33.489] assign_globals() ... done
[13:23:33.489] requestCore(): workers = 2
[13:23:33.492] MulticoreFuture started
[13:23:33.492] - Launch lazy future ... done
[13:23:33.492] run() for ‘MulticoreFuture’ ... done
[13:23:33.493] result() for MulticoreFuture ...
[13:23:33.493] plan(): Setting new future strategy stack:
[13:23:33.493] List of future strategies:
[13:23:33.493] 1. sequential:
[13:23:33.493]    - args: function (..., envir = parent.frame())
[13:23:33.493]    - tweaked: FALSE
[13:23:33.493]    - call: NULL
[13:23:33.494] plan(): nbrOfWorkers() = 1
[13:23:33.496] plan(): Setting new future strategy stack:
[13:23:33.497] List of future strategies:
[13:23:33.497] 1. multicore:
[13:23:33.497]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:33.497]    - tweaked: FALSE
[13:23:33.497]    - call: plan(strategy)
[13:23:33.502] plan(): nbrOfWorkers() = 2
[13:23:33.504] result() for MulticoreFuture ...
[13:23:33.504] result() for MulticoreFuture ... done
[13:23:33.504] result() for MulticoreFuture ... done
[13:23:33.504] result() for MulticoreFuture ...
[13:23:33.504] result() for MulticoreFuture ... done
[13:23:33.505] run() for ‘Future’ ...
[13:23:33.505] - state: ‘created’
[13:23:33.505] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:33.510] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:33.510] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:33.510]   - Field: ‘label’
[13:23:33.510]   - Field: ‘local’
[13:23:33.510]   - Field: ‘owner’
[13:23:33.510]   - Field: ‘envir’
[13:23:33.511]   - Field: ‘workers’
[13:23:33.511]   - Field: ‘packages’
[13:23:33.511]   - Field: ‘gc’
[13:23:33.511]   - Field: ‘job’
[13:23:33.511]   - Field: ‘conditions’
[13:23:33.511]   - Field: ‘expr’
[13:23:33.511]   - Field: ‘uuid’
[13:23:33.511]   - Field: ‘seed’
[13:23:33.512]   - Field: ‘version’
[13:23:33.512]   - Field: ‘result’
[13:23:33.512]   - Field: ‘asynchronous’
[13:23:33.512]   - Field: ‘calls’
[13:23:33.512]   - Field: ‘globals’
[13:23:33.512]   - Field: ‘stdout’
[13:23:33.512]   - Field: ‘earlySignal’
[13:23:33.512]   - Field: ‘lazy’
[13:23:33.513]   - Field: ‘state’
[13:23:33.513] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:33.513] - Launch lazy future ...
[13:23:33.513] Packages needed by the future expression (n = 0): <none>
[13:23:33.513] Packages needed by future strategies (n = 0): <none>
[13:23:33.514] {
[13:23:33.514]     {
[13:23:33.514]         {
[13:23:33.514]             ...future.startTime <- base::Sys.time()
[13:23:33.514]             {
[13:23:33.514]                 {
[13:23:33.514]                   {
[13:23:33.514]                     {
[13:23:33.514]                       base::local({
[13:23:33.514]                         has_future <- base::requireNamespace("future", 
[13:23:33.514]                           quietly = TRUE)
[13:23:33.514]                         if (has_future) {
[13:23:33.514]                           ns <- base::getNamespace("future")
[13:23:33.514]                           version <- ns[[".package"]][["version"]]
[13:23:33.514]                           if (is.null(version)) 
[13:23:33.514]                             version <- utils::packageVersion("future")
[13:23:33.514]                         }
[13:23:33.514]                         else {
[13:23:33.514]                           version <- NULL
[13:23:33.514]                         }
[13:23:33.514]                         if (!has_future || version < "1.8.0") {
[13:23:33.514]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.514]                             "", base::R.version$version.string), 
[13:23:33.514]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:33.514]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:33.514]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.514]                               "release", "version")], collapse = " "), 
[13:23:33.514]                             hostname = base::Sys.info()[["nodename"]])
[13:23:33.514]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.514]                             info)
[13:23:33.514]                           info <- base::paste(info, collapse = "; ")
[13:23:33.514]                           if (!has_future) {
[13:23:33.514]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.514]                               info)
[13:23:33.514]                           }
[13:23:33.514]                           else {
[13:23:33.514]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.514]                               info, version)
[13:23:33.514]                           }
[13:23:33.514]                           base::stop(msg)
[13:23:33.514]                         }
[13:23:33.514]                       })
[13:23:33.514]                     }
[13:23:33.514]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:33.514]                     base::options(mc.cores = 1L)
[13:23:33.514]                   }
[13:23:33.514]                   options(future.plan = NULL)
[13:23:33.514]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.514]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.514]                 }
[13:23:33.514]                 ...future.workdir <- getwd()
[13:23:33.514]             }
[13:23:33.514]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.514]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.514]         }
[13:23:33.514]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.514]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:33.514]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.514]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.514]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.514]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.514]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.514]             base::names(...future.oldOptions))
[13:23:33.514]     }
[13:23:33.514]     if (FALSE) {
[13:23:33.514]     }
[13:23:33.514]     else {
[13:23:33.514]         if (TRUE) {
[13:23:33.514]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.514]                 open = "w")
[13:23:33.514]         }
[13:23:33.514]         else {
[13:23:33.514]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.514]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.514]         }
[13:23:33.514]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.514]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.514]             base::sink(type = "output", split = FALSE)
[13:23:33.514]             base::close(...future.stdout)
[13:23:33.514]         }, add = TRUE)
[13:23:33.514]     }
[13:23:33.514]     ...future.frame <- base::sys.nframe()
[13:23:33.514]     ...future.conditions <- base::list()
[13:23:33.514]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.514]     if (FALSE) {
[13:23:33.514]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.514]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.514]     }
[13:23:33.514]     ...future.result <- base::tryCatch({
[13:23:33.514]         base::withCallingHandlers({
[13:23:33.514]             ...future.value <- base::withVisible(base::local({
[13:23:33.514]                 withCallingHandlers({
[13:23:33.514]                   {
[13:23:33.514]                     b <- a * ii
[13:23:33.514]                     a <- 0
[13:23:33.514]                     b
[13:23:33.514]                   }
[13:23:33.514]                 }, immediateCondition = function(cond) {
[13:23:33.514]                   save_rds <- function (object, pathname, ...) 
[13:23:33.514]                   {
[13:23:33.514]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:33.514]                     if (file_test("-f", pathname_tmp)) {
[13:23:33.514]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.514]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:33.514]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.514]                         fi_tmp[["mtime"]])
[13:23:33.514]                     }
[13:23:33.514]                     tryCatch({
[13:23:33.514]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:33.514]                     }, error = function(ex) {
[13:23:33.514]                       msg <- conditionMessage(ex)
[13:23:33.514]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.514]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:33.514]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.514]                         fi_tmp[["mtime"]], msg)
[13:23:33.514]                       ex$message <- msg
[13:23:33.514]                       stop(ex)
[13:23:33.514]                     })
[13:23:33.514]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:33.514]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:33.514]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:33.514]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.514]                       fi <- file.info(pathname)
[13:23:33.514]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:33.514]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.514]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:33.514]                         fi[["size"]], fi[["mtime"]])
[13:23:33.514]                       stop(msg)
[13:23:33.514]                     }
[13:23:33.514]                     invisible(pathname)
[13:23:33.514]                   }
[13:23:33.514]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:33.514]                     rootPath = tempdir()) 
[13:23:33.514]                   {
[13:23:33.514]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:33.514]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:33.514]                       tmpdir = path, fileext = ".rds")
[13:23:33.514]                     save_rds(obj, file)
[13:23:33.514]                   }
[13:23:33.514]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:33.514]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.514]                   {
[13:23:33.514]                     inherits <- base::inherits
[13:23:33.514]                     invokeRestart <- base::invokeRestart
[13:23:33.514]                     is.null <- base::is.null
[13:23:33.514]                     muffled <- FALSE
[13:23:33.514]                     if (inherits(cond, "message")) {
[13:23:33.514]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:33.514]                       if (muffled) 
[13:23:33.514]                         invokeRestart("muffleMessage")
[13:23:33.514]                     }
[13:23:33.514]                     else if (inherits(cond, "warning")) {
[13:23:33.514]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:33.514]                       if (muffled) 
[13:23:33.514]                         invokeRestart("muffleWarning")
[13:23:33.514]                     }
[13:23:33.514]                     else if (inherits(cond, "condition")) {
[13:23:33.514]                       if (!is.null(pattern)) {
[13:23:33.514]                         computeRestarts <- base::computeRestarts
[13:23:33.514]                         grepl <- base::grepl
[13:23:33.514]                         restarts <- computeRestarts(cond)
[13:23:33.514]                         for (restart in restarts) {
[13:23:33.514]                           name <- restart$name
[13:23:33.514]                           if (is.null(name)) 
[13:23:33.514]                             next
[13:23:33.514]                           if (!grepl(pattern, name)) 
[13:23:33.514]                             next
[13:23:33.514]                           invokeRestart(restart)
[13:23:33.514]                           muffled <- TRUE
[13:23:33.514]                           break
[13:23:33.514]                         }
[13:23:33.514]                       }
[13:23:33.514]                     }
[13:23:33.514]                     invisible(muffled)
[13:23:33.514]                   }
[13:23:33.514]                   muffleCondition(cond)
[13:23:33.514]                 })
[13:23:33.514]             }))
[13:23:33.514]             future::FutureResult(value = ...future.value$value, 
[13:23:33.514]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.514]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.514]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.514]                     ...future.globalenv.names))
[13:23:33.514]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.514]         }, condition = base::local({
[13:23:33.514]             c <- base::c
[13:23:33.514]             inherits <- base::inherits
[13:23:33.514]             invokeRestart <- base::invokeRestart
[13:23:33.514]             length <- base::length
[13:23:33.514]             list <- base::list
[13:23:33.514]             seq.int <- base::seq.int
[13:23:33.514]             signalCondition <- base::signalCondition
[13:23:33.514]             sys.calls <- base::sys.calls
[13:23:33.514]             `[[` <- base::`[[`
[13:23:33.514]             `+` <- base::`+`
[13:23:33.514]             `<<-` <- base::`<<-`
[13:23:33.514]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.514]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.514]                   3L)]
[13:23:33.514]             }
[13:23:33.514]             function(cond) {
[13:23:33.514]                 is_error <- inherits(cond, "error")
[13:23:33.514]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.514]                   NULL)
[13:23:33.514]                 if (is_error) {
[13:23:33.514]                   sessionInformation <- function() {
[13:23:33.514]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.514]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.514]                       search = base::search(), system = base::Sys.info())
[13:23:33.514]                   }
[13:23:33.514]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.514]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.514]                     cond$call), session = sessionInformation(), 
[13:23:33.514]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.514]                   signalCondition(cond)
[13:23:33.514]                 }
[13:23:33.514]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.514]                 "immediateCondition"))) {
[13:23:33.514]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.514]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.514]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.514]                   if (TRUE && !signal) {
[13:23:33.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.514]                     {
[13:23:33.514]                       inherits <- base::inherits
[13:23:33.514]                       invokeRestart <- base::invokeRestart
[13:23:33.514]                       is.null <- base::is.null
[13:23:33.514]                       muffled <- FALSE
[13:23:33.514]                       if (inherits(cond, "message")) {
[13:23:33.514]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.514]                         if (muffled) 
[13:23:33.514]                           invokeRestart("muffleMessage")
[13:23:33.514]                       }
[13:23:33.514]                       else if (inherits(cond, "warning")) {
[13:23:33.514]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.514]                         if (muffled) 
[13:23:33.514]                           invokeRestart("muffleWarning")
[13:23:33.514]                       }
[13:23:33.514]                       else if (inherits(cond, "condition")) {
[13:23:33.514]                         if (!is.null(pattern)) {
[13:23:33.514]                           computeRestarts <- base::computeRestarts
[13:23:33.514]                           grepl <- base::grepl
[13:23:33.514]                           restarts <- computeRestarts(cond)
[13:23:33.514]                           for (restart in restarts) {
[13:23:33.514]                             name <- restart$name
[13:23:33.514]                             if (is.null(name)) 
[13:23:33.514]                               next
[13:23:33.514]                             if (!grepl(pattern, name)) 
[13:23:33.514]                               next
[13:23:33.514]                             invokeRestart(restart)
[13:23:33.514]                             muffled <- TRUE
[13:23:33.514]                             break
[13:23:33.514]                           }
[13:23:33.514]                         }
[13:23:33.514]                       }
[13:23:33.514]                       invisible(muffled)
[13:23:33.514]                     }
[13:23:33.514]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.514]                   }
[13:23:33.514]                 }
[13:23:33.514]                 else {
[13:23:33.514]                   if (TRUE) {
[13:23:33.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.514]                     {
[13:23:33.514]                       inherits <- base::inherits
[13:23:33.514]                       invokeRestart <- base::invokeRestart
[13:23:33.514]                       is.null <- base::is.null
[13:23:33.514]                       muffled <- FALSE
[13:23:33.514]                       if (inherits(cond, "message")) {
[13:23:33.514]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.514]                         if (muffled) 
[13:23:33.514]                           invokeRestart("muffleMessage")
[13:23:33.514]                       }
[13:23:33.514]                       else if (inherits(cond, "warning")) {
[13:23:33.514]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.514]                         if (muffled) 
[13:23:33.514]                           invokeRestart("muffleWarning")
[13:23:33.514]                       }
[13:23:33.514]                       else if (inherits(cond, "condition")) {
[13:23:33.514]                         if (!is.null(pattern)) {
[13:23:33.514]                           computeRestarts <- base::computeRestarts
[13:23:33.514]                           grepl <- base::grepl
[13:23:33.514]                           restarts <- computeRestarts(cond)
[13:23:33.514]                           for (restart in restarts) {
[13:23:33.514]                             name <- restart$name
[13:23:33.514]                             if (is.null(name)) 
[13:23:33.514]                               next
[13:23:33.514]                             if (!grepl(pattern, name)) 
[13:23:33.514]                               next
[13:23:33.514]                             invokeRestart(restart)
[13:23:33.514]                             muffled <- TRUE
[13:23:33.514]                             break
[13:23:33.514]                           }
[13:23:33.514]                         }
[13:23:33.514]                       }
[13:23:33.514]                       invisible(muffled)
[13:23:33.514]                     }
[13:23:33.514]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.514]                   }
[13:23:33.514]                 }
[13:23:33.514]             }
[13:23:33.514]         }))
[13:23:33.514]     }, error = function(ex) {
[13:23:33.514]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.514]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.514]                 ...future.rng), started = ...future.startTime, 
[13:23:33.514]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.514]             version = "1.8"), class = "FutureResult")
[13:23:33.514]     }, finally = {
[13:23:33.514]         if (!identical(...future.workdir, getwd())) 
[13:23:33.514]             setwd(...future.workdir)
[13:23:33.514]         {
[13:23:33.514]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.514]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.514]             }
[13:23:33.514]             base::options(...future.oldOptions)
[13:23:33.514]             if (.Platform$OS.type == "windows") {
[13:23:33.514]                 old_names <- names(...future.oldEnvVars)
[13:23:33.514]                 envs <- base::Sys.getenv()
[13:23:33.514]                 names <- names(envs)
[13:23:33.514]                 common <- intersect(names, old_names)
[13:23:33.514]                 added <- setdiff(names, old_names)
[13:23:33.514]                 removed <- setdiff(old_names, names)
[13:23:33.514]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.514]                   envs[common]]
[13:23:33.514]                 NAMES <- toupper(changed)
[13:23:33.514]                 args <- list()
[13:23:33.514]                 for (kk in seq_along(NAMES)) {
[13:23:33.514]                   name <- changed[[kk]]
[13:23:33.514]                   NAME <- NAMES[[kk]]
[13:23:33.514]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.514]                     next
[13:23:33.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.514]                 }
[13:23:33.514]                 NAMES <- toupper(added)
[13:23:33.514]                 for (kk in seq_along(NAMES)) {
[13:23:33.514]                   name <- added[[kk]]
[13:23:33.514]                   NAME <- NAMES[[kk]]
[13:23:33.514]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.514]                     next
[13:23:33.514]                   args[[name]] <- ""
[13:23:33.514]                 }
[13:23:33.514]                 NAMES <- toupper(removed)
[13:23:33.514]                 for (kk in seq_along(NAMES)) {
[13:23:33.514]                   name <- removed[[kk]]
[13:23:33.514]                   NAME <- NAMES[[kk]]
[13:23:33.514]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.514]                     next
[13:23:33.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.514]                 }
[13:23:33.514]                 if (length(args) > 0) 
[13:23:33.514]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.514]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.514]             }
[13:23:33.514]             else {
[13:23:33.514]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.514]             }
[13:23:33.514]             {
[13:23:33.514]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.514]                   0L) {
[13:23:33.514]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.514]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.514]                   base::options(opts)
[13:23:33.514]                 }
[13:23:33.514]                 {
[13:23:33.514]                   {
[13:23:33.514]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:33.514]                     NULL
[13:23:33.514]                   }
[13:23:33.514]                   options(future.plan = NULL)
[13:23:33.514]                   if (is.na(NA_character_)) 
[13:23:33.514]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.514]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.514]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.514]                     envir = parent.frame()) 
[13:23:33.514]                   {
[13:23:33.514]                     default_workers <- missing(workers)
[13:23:33.514]                     if (is.function(workers)) 
[13:23:33.514]                       workers <- workers()
[13:23:33.514]                     workers <- structure(as.integer(workers), 
[13:23:33.514]                       class = class(workers))
[13:23:33.514]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.514]                       1L)
[13:23:33.514]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.514]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.514]                       if (default_workers) 
[13:23:33.514]                         supportsMulticore(warn = TRUE)
[13:23:33.514]                       return(sequential(..., envir = envir))
[13:23:33.514]                     }
[13:23:33.514]                     oopts <- options(mc.cores = workers)
[13:23:33.514]                     on.exit(options(oopts))
[13:23:33.514]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.514]                       envir = envir)
[13:23:33.514]                     if (!future$lazy) 
[13:23:33.514]                       future <- run(future)
[13:23:33.514]                     invisible(future)
[13:23:33.514]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.514]                 }
[13:23:33.514]             }
[13:23:33.514]         }
[13:23:33.514]     })
[13:23:33.514]     if (TRUE) {
[13:23:33.514]         base::sink(type = "output", split = FALSE)
[13:23:33.514]         if (TRUE) {
[13:23:33.514]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.514]         }
[13:23:33.514]         else {
[13:23:33.514]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.514]         }
[13:23:33.514]         base::close(...future.stdout)
[13:23:33.514]         ...future.stdout <- NULL
[13:23:33.514]     }
[13:23:33.514]     ...future.result$conditions <- ...future.conditions
[13:23:33.514]     ...future.result$finished <- base::Sys.time()
[13:23:33.514]     ...future.result
[13:23:33.514] }
[13:23:33.517] assign_globals() ...
[13:23:33.517] List of 2
[13:23:33.517]  $ a : num 1
[13:23:33.517]  $ ii: int 3
[13:23:33.517]  - attr(*, "where")=List of 2
[13:23:33.517]   ..$ a :<environment: R_EmptyEnv> 
[13:23:33.517]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:33.517]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:33.517]  - attr(*, "resolved")= logi TRUE
[13:23:33.517]  - attr(*, "total_size")= num 112
[13:23:33.517]  - attr(*, "already-done")= logi TRUE
[13:23:33.521] - copied ‘a’ to environment
[13:23:33.521] - copied ‘ii’ to environment
[13:23:33.521] assign_globals() ... done
[13:23:33.522] requestCore(): workers = 2
[13:23:33.524] MulticoreFuture started
[13:23:33.525] - Launch lazy future ... done
[13:23:33.525] run() for ‘MulticoreFuture’ ... done
[13:23:33.525] result() for MulticoreFuture ...
[13:23:33.526] plan(): Setting new future strategy stack:
[13:23:33.526] List of future strategies:
[13:23:33.526] 1. sequential:
[13:23:33.526]    - args: function (..., envir = parent.frame())
[13:23:33.526]    - tweaked: FALSE
[13:23:33.526]    - call: NULL
[13:23:33.527] plan(): nbrOfWorkers() = 1
[13:23:33.535] plan(): Setting new future strategy stack:
[13:23:33.536] List of future strategies:
[13:23:33.536] 1. multicore:
[13:23:33.536]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:33.536]    - tweaked: FALSE
[13:23:33.536]    - call: plan(strategy)
[13:23:33.542] plan(): nbrOfWorkers() = 2
[13:23:33.543] result() for MulticoreFuture ...
[13:23:33.546] result() for MulticoreFuture ... done
[13:23:33.547] result() for MulticoreFuture ... done
[13:23:33.547] result() for MulticoreFuture ...
[13:23:33.547] result() for MulticoreFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:33.548] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:33.548] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:33.549] 
[13:23:33.549] Searching for globals ... DONE
[13:23:33.550] - globals: [0] <none>
[13:23:33.550] getGlobalsAndPackages() ... DONE
[13:23:33.550] run() for ‘Future’ ...
[13:23:33.550] - state: ‘created’
[13:23:33.551] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:33.556] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:33.556] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:33.556]   - Field: ‘label’
[13:23:33.556]   - Field: ‘local’
[13:23:33.556]   - Field: ‘owner’
[13:23:33.557]   - Field: ‘envir’
[13:23:33.557]   - Field: ‘workers’
[13:23:33.557]   - Field: ‘packages’
[13:23:33.557]   - Field: ‘gc’
[13:23:33.557]   - Field: ‘job’
[13:23:33.557]   - Field: ‘conditions’
[13:23:33.557]   - Field: ‘expr’
[13:23:33.558]   - Field: ‘uuid’
[13:23:33.558]   - Field: ‘seed’
[13:23:33.558]   - Field: ‘version’
[13:23:33.558]   - Field: ‘result’
[13:23:33.558]   - Field: ‘asynchronous’
[13:23:33.558]   - Field: ‘calls’
[13:23:33.558]   - Field: ‘globals’
[13:23:33.558]   - Field: ‘stdout’
[13:23:33.559]   - Field: ‘earlySignal’
[13:23:33.559]   - Field: ‘lazy’
[13:23:33.559]   - Field: ‘state’
[13:23:33.559] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:33.559] - Launch lazy future ...
[13:23:33.559] Packages needed by the future expression (n = 0): <none>
[13:23:33.560] Packages needed by future strategies (n = 0): <none>
[13:23:33.560] {
[13:23:33.560]     {
[13:23:33.560]         {
[13:23:33.560]             ...future.startTime <- base::Sys.time()
[13:23:33.560]             {
[13:23:33.560]                 {
[13:23:33.560]                   {
[13:23:33.560]                     {
[13:23:33.560]                       base::local({
[13:23:33.560]                         has_future <- base::requireNamespace("future", 
[13:23:33.560]                           quietly = TRUE)
[13:23:33.560]                         if (has_future) {
[13:23:33.560]                           ns <- base::getNamespace("future")
[13:23:33.560]                           version <- ns[[".package"]][["version"]]
[13:23:33.560]                           if (is.null(version)) 
[13:23:33.560]                             version <- utils::packageVersion("future")
[13:23:33.560]                         }
[13:23:33.560]                         else {
[13:23:33.560]                           version <- NULL
[13:23:33.560]                         }
[13:23:33.560]                         if (!has_future || version < "1.8.0") {
[13:23:33.560]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.560]                             "", base::R.version$version.string), 
[13:23:33.560]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:33.560]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:33.560]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.560]                               "release", "version")], collapse = " "), 
[13:23:33.560]                             hostname = base::Sys.info()[["nodename"]])
[13:23:33.560]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.560]                             info)
[13:23:33.560]                           info <- base::paste(info, collapse = "; ")
[13:23:33.560]                           if (!has_future) {
[13:23:33.560]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.560]                               info)
[13:23:33.560]                           }
[13:23:33.560]                           else {
[13:23:33.560]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.560]                               info, version)
[13:23:33.560]                           }
[13:23:33.560]                           base::stop(msg)
[13:23:33.560]                         }
[13:23:33.560]                       })
[13:23:33.560]                     }
[13:23:33.560]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:33.560]                     base::options(mc.cores = 1L)
[13:23:33.560]                   }
[13:23:33.560]                   options(future.plan = NULL)
[13:23:33.560]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.560]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.560]                 }
[13:23:33.560]                 ...future.workdir <- getwd()
[13:23:33.560]             }
[13:23:33.560]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.560]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.560]         }
[13:23:33.560]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.560]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:33.560]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.560]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.560]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.560]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.560]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.560]             base::names(...future.oldOptions))
[13:23:33.560]     }
[13:23:33.560]     if (FALSE) {
[13:23:33.560]     }
[13:23:33.560]     else {
[13:23:33.560]         if (TRUE) {
[13:23:33.560]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.560]                 open = "w")
[13:23:33.560]         }
[13:23:33.560]         else {
[13:23:33.560]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.560]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.560]         }
[13:23:33.560]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.560]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.560]             base::sink(type = "output", split = FALSE)
[13:23:33.560]             base::close(...future.stdout)
[13:23:33.560]         }, add = TRUE)
[13:23:33.560]     }
[13:23:33.560]     ...future.frame <- base::sys.nframe()
[13:23:33.560]     ...future.conditions <- base::list()
[13:23:33.560]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.560]     if (FALSE) {
[13:23:33.560]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.560]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.560]     }
[13:23:33.560]     ...future.result <- base::tryCatch({
[13:23:33.560]         base::withCallingHandlers({
[13:23:33.560]             ...future.value <- base::withVisible(base::local({
[13:23:33.560]                 withCallingHandlers({
[13:23:33.560]                   1
[13:23:33.560]                 }, immediateCondition = function(cond) {
[13:23:33.560]                   save_rds <- function (object, pathname, ...) 
[13:23:33.560]                   {
[13:23:33.560]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:33.560]                     if (file_test("-f", pathname_tmp)) {
[13:23:33.560]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.560]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:33.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.560]                         fi_tmp[["mtime"]])
[13:23:33.560]                     }
[13:23:33.560]                     tryCatch({
[13:23:33.560]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:33.560]                     }, error = function(ex) {
[13:23:33.560]                       msg <- conditionMessage(ex)
[13:23:33.560]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.560]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:33.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.560]                         fi_tmp[["mtime"]], msg)
[13:23:33.560]                       ex$message <- msg
[13:23:33.560]                       stop(ex)
[13:23:33.560]                     })
[13:23:33.560]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:33.560]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:33.560]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:33.560]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.560]                       fi <- file.info(pathname)
[13:23:33.560]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:33.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.560]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:33.560]                         fi[["size"]], fi[["mtime"]])
[13:23:33.560]                       stop(msg)
[13:23:33.560]                     }
[13:23:33.560]                     invisible(pathname)
[13:23:33.560]                   }
[13:23:33.560]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:33.560]                     rootPath = tempdir()) 
[13:23:33.560]                   {
[13:23:33.560]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:33.560]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:33.560]                       tmpdir = path, fileext = ".rds")
[13:23:33.560]                     save_rds(obj, file)
[13:23:33.560]                   }
[13:23:33.560]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:33.560]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.560]                   {
[13:23:33.560]                     inherits <- base::inherits
[13:23:33.560]                     invokeRestart <- base::invokeRestart
[13:23:33.560]                     is.null <- base::is.null
[13:23:33.560]                     muffled <- FALSE
[13:23:33.560]                     if (inherits(cond, "message")) {
[13:23:33.560]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:33.560]                       if (muffled) 
[13:23:33.560]                         invokeRestart("muffleMessage")
[13:23:33.560]                     }
[13:23:33.560]                     else if (inherits(cond, "warning")) {
[13:23:33.560]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:33.560]                       if (muffled) 
[13:23:33.560]                         invokeRestart("muffleWarning")
[13:23:33.560]                     }
[13:23:33.560]                     else if (inherits(cond, "condition")) {
[13:23:33.560]                       if (!is.null(pattern)) {
[13:23:33.560]                         computeRestarts <- base::computeRestarts
[13:23:33.560]                         grepl <- base::grepl
[13:23:33.560]                         restarts <- computeRestarts(cond)
[13:23:33.560]                         for (restart in restarts) {
[13:23:33.560]                           name <- restart$name
[13:23:33.560]                           if (is.null(name)) 
[13:23:33.560]                             next
[13:23:33.560]                           if (!grepl(pattern, name)) 
[13:23:33.560]                             next
[13:23:33.560]                           invokeRestart(restart)
[13:23:33.560]                           muffled <- TRUE
[13:23:33.560]                           break
[13:23:33.560]                         }
[13:23:33.560]                       }
[13:23:33.560]                     }
[13:23:33.560]                     invisible(muffled)
[13:23:33.560]                   }
[13:23:33.560]                   muffleCondition(cond)
[13:23:33.560]                 })
[13:23:33.560]             }))
[13:23:33.560]             future::FutureResult(value = ...future.value$value, 
[13:23:33.560]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.560]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.560]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.560]                     ...future.globalenv.names))
[13:23:33.560]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.560]         }, condition = base::local({
[13:23:33.560]             c <- base::c
[13:23:33.560]             inherits <- base::inherits
[13:23:33.560]             invokeRestart <- base::invokeRestart
[13:23:33.560]             length <- base::length
[13:23:33.560]             list <- base::list
[13:23:33.560]             seq.int <- base::seq.int
[13:23:33.560]             signalCondition <- base::signalCondition
[13:23:33.560]             sys.calls <- base::sys.calls
[13:23:33.560]             `[[` <- base::`[[`
[13:23:33.560]             `+` <- base::`+`
[13:23:33.560]             `<<-` <- base::`<<-`
[13:23:33.560]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.560]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.560]                   3L)]
[13:23:33.560]             }
[13:23:33.560]             function(cond) {
[13:23:33.560]                 is_error <- inherits(cond, "error")
[13:23:33.560]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.560]                   NULL)
[13:23:33.560]                 if (is_error) {
[13:23:33.560]                   sessionInformation <- function() {
[13:23:33.560]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.560]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.560]                       search = base::search(), system = base::Sys.info())
[13:23:33.560]                   }
[13:23:33.560]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.560]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.560]                     cond$call), session = sessionInformation(), 
[13:23:33.560]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.560]                   signalCondition(cond)
[13:23:33.560]                 }
[13:23:33.560]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.560]                 "immediateCondition"))) {
[13:23:33.560]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.560]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.560]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.560]                   if (TRUE && !signal) {
[13:23:33.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.560]                     {
[13:23:33.560]                       inherits <- base::inherits
[13:23:33.560]                       invokeRestart <- base::invokeRestart
[13:23:33.560]                       is.null <- base::is.null
[13:23:33.560]                       muffled <- FALSE
[13:23:33.560]                       if (inherits(cond, "message")) {
[13:23:33.560]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.560]                         if (muffled) 
[13:23:33.560]                           invokeRestart("muffleMessage")
[13:23:33.560]                       }
[13:23:33.560]                       else if (inherits(cond, "warning")) {
[13:23:33.560]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.560]                         if (muffled) 
[13:23:33.560]                           invokeRestart("muffleWarning")
[13:23:33.560]                       }
[13:23:33.560]                       else if (inherits(cond, "condition")) {
[13:23:33.560]                         if (!is.null(pattern)) {
[13:23:33.560]                           computeRestarts <- base::computeRestarts
[13:23:33.560]                           grepl <- base::grepl
[13:23:33.560]                           restarts <- computeRestarts(cond)
[13:23:33.560]                           for (restart in restarts) {
[13:23:33.560]                             name <- restart$name
[13:23:33.560]                             if (is.null(name)) 
[13:23:33.560]                               next
[13:23:33.560]                             if (!grepl(pattern, name)) 
[13:23:33.560]                               next
[13:23:33.560]                             invokeRestart(restart)
[13:23:33.560]                             muffled <- TRUE
[13:23:33.560]                             break
[13:23:33.560]                           }
[13:23:33.560]                         }
[13:23:33.560]                       }
[13:23:33.560]                       invisible(muffled)
[13:23:33.560]                     }
[13:23:33.560]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.560]                   }
[13:23:33.560]                 }
[13:23:33.560]                 else {
[13:23:33.560]                   if (TRUE) {
[13:23:33.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.560]                     {
[13:23:33.560]                       inherits <- base::inherits
[13:23:33.560]                       invokeRestart <- base::invokeRestart
[13:23:33.560]                       is.null <- base::is.null
[13:23:33.560]                       muffled <- FALSE
[13:23:33.560]                       if (inherits(cond, "message")) {
[13:23:33.560]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.560]                         if (muffled) 
[13:23:33.560]                           invokeRestart("muffleMessage")
[13:23:33.560]                       }
[13:23:33.560]                       else if (inherits(cond, "warning")) {
[13:23:33.560]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.560]                         if (muffled) 
[13:23:33.560]                           invokeRestart("muffleWarning")
[13:23:33.560]                       }
[13:23:33.560]                       else if (inherits(cond, "condition")) {
[13:23:33.560]                         if (!is.null(pattern)) {
[13:23:33.560]                           computeRestarts <- base::computeRestarts
[13:23:33.560]                           grepl <- base::grepl
[13:23:33.560]                           restarts <- computeRestarts(cond)
[13:23:33.560]                           for (restart in restarts) {
[13:23:33.560]                             name <- restart$name
[13:23:33.560]                             if (is.null(name)) 
[13:23:33.560]                               next
[13:23:33.560]                             if (!grepl(pattern, name)) 
[13:23:33.560]                               next
[13:23:33.560]                             invokeRestart(restart)
[13:23:33.560]                             muffled <- TRUE
[13:23:33.560]                             break
[13:23:33.560]                           }
[13:23:33.560]                         }
[13:23:33.560]                       }
[13:23:33.560]                       invisible(muffled)
[13:23:33.560]                     }
[13:23:33.560]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.560]                   }
[13:23:33.560]                 }
[13:23:33.560]             }
[13:23:33.560]         }))
[13:23:33.560]     }, error = function(ex) {
[13:23:33.560]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.560]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.560]                 ...future.rng), started = ...future.startTime, 
[13:23:33.560]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.560]             version = "1.8"), class = "FutureResult")
[13:23:33.560]     }, finally = {
[13:23:33.560]         if (!identical(...future.workdir, getwd())) 
[13:23:33.560]             setwd(...future.workdir)
[13:23:33.560]         {
[13:23:33.560]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.560]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.560]             }
[13:23:33.560]             base::options(...future.oldOptions)
[13:23:33.560]             if (.Platform$OS.type == "windows") {
[13:23:33.560]                 old_names <- names(...future.oldEnvVars)
[13:23:33.560]                 envs <- base::Sys.getenv()
[13:23:33.560]                 names <- names(envs)
[13:23:33.560]                 common <- intersect(names, old_names)
[13:23:33.560]                 added <- setdiff(names, old_names)
[13:23:33.560]                 removed <- setdiff(old_names, names)
[13:23:33.560]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.560]                   envs[common]]
[13:23:33.560]                 NAMES <- toupper(changed)
[13:23:33.560]                 args <- list()
[13:23:33.560]                 for (kk in seq_along(NAMES)) {
[13:23:33.560]                   name <- changed[[kk]]
[13:23:33.560]                   NAME <- NAMES[[kk]]
[13:23:33.560]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.560]                     next
[13:23:33.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.560]                 }
[13:23:33.560]                 NAMES <- toupper(added)
[13:23:33.560]                 for (kk in seq_along(NAMES)) {
[13:23:33.560]                   name <- added[[kk]]
[13:23:33.560]                   NAME <- NAMES[[kk]]
[13:23:33.560]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.560]                     next
[13:23:33.560]                   args[[name]] <- ""
[13:23:33.560]                 }
[13:23:33.560]                 NAMES <- toupper(removed)
[13:23:33.560]                 for (kk in seq_along(NAMES)) {
[13:23:33.560]                   name <- removed[[kk]]
[13:23:33.560]                   NAME <- NAMES[[kk]]
[13:23:33.560]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.560]                     next
[13:23:33.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.560]                 }
[13:23:33.560]                 if (length(args) > 0) 
[13:23:33.560]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.560]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.560]             }
[13:23:33.560]             else {
[13:23:33.560]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.560]             }
[13:23:33.560]             {
[13:23:33.560]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.560]                   0L) {
[13:23:33.560]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.560]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.560]                   base::options(opts)
[13:23:33.560]                 }
[13:23:33.560]                 {
[13:23:33.560]                   {
[13:23:33.560]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:33.560]                     NULL
[13:23:33.560]                   }
[13:23:33.560]                   options(future.plan = NULL)
[13:23:33.560]                   if (is.na(NA_character_)) 
[13:23:33.560]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.560]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.560]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.560]                     envir = parent.frame()) 
[13:23:33.560]                   {
[13:23:33.560]                     default_workers <- missing(workers)
[13:23:33.560]                     if (is.function(workers)) 
[13:23:33.560]                       workers <- workers()
[13:23:33.560]                     workers <- structure(as.integer(workers), 
[13:23:33.560]                       class = class(workers))
[13:23:33.560]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.560]                       1L)
[13:23:33.560]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.560]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.560]                       if (default_workers) 
[13:23:33.560]                         supportsMulticore(warn = TRUE)
[13:23:33.560]                       return(sequential(..., envir = envir))
[13:23:33.560]                     }
[13:23:33.560]                     oopts <- options(mc.cores = workers)
[13:23:33.560]                     on.exit(options(oopts))
[13:23:33.560]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.560]                       envir = envir)
[13:23:33.560]                     if (!future$lazy) 
[13:23:33.560]                       future <- run(future)
[13:23:33.560]                     invisible(future)
[13:23:33.560]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.560]                 }
[13:23:33.560]             }
[13:23:33.560]         }
[13:23:33.560]     })
[13:23:33.560]     if (TRUE) {
[13:23:33.560]         base::sink(type = "output", split = FALSE)
[13:23:33.560]         if (TRUE) {
[13:23:33.560]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.560]         }
[13:23:33.560]         else {
[13:23:33.560]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.560]         }
[13:23:33.560]         base::close(...future.stdout)
[13:23:33.560]         ...future.stdout <- NULL
[13:23:33.560]     }
[13:23:33.560]     ...future.result$conditions <- ...future.conditions
[13:23:33.560]     ...future.result$finished <- base::Sys.time()
[13:23:33.560]     ...future.result
[13:23:33.560] }
[13:23:33.563] requestCore(): workers = 2
[13:23:33.565] MulticoreFuture started
[13:23:33.566] - Launch lazy future ... done
[13:23:33.566] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:33.566] plan(): Setting new future strategy stack:
[13:23:33.567] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:33.567] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:33.567] List of future strategies:
[13:23:33.567] 1. sequential:
[13:23:33.567]    - args: function (..., envir = parent.frame())
[13:23:33.567]    - tweaked: FALSE
[13:23:33.567]    - call: NULL
[13:23:33.568] plan(): nbrOfWorkers() = 1
[13:23:33.569] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:33.569] Searching for globals ... DONE
[13:23:33.569] Resolving globals: TRUE
[13:23:33.569] Resolving any globals that are futures ...
[13:23:33.570] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:33.570] plan(): Setting new future strategy stack:
[13:23:33.570] Resolving any globals that are futures ... DONE
[13:23:33.570] List of future strategies:
[13:23:33.570] 1. multicore:
[13:23:33.570]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:33.570]    - tweaked: FALSE
[13:23:33.570]    - call: plan(strategy)
[13:23:33.570] Resolving futures part of globals (recursively) ...
[13:23:33.571] resolve() on list ...
[13:23:33.571]  recursive: 99
[13:23:33.571]  length: 1
[13:23:33.572]  elements: ‘a’
[13:23:33.575] plan(): nbrOfWorkers() = 2
[13:23:33.575] Future #1
[13:23:33.576] result() for MulticoreFuture ...
[13:23:33.577] result() for MulticoreFuture ...
[13:23:33.577] result() for MulticoreFuture ... done
[13:23:33.577] result() for MulticoreFuture ... done
[13:23:33.577] result() for MulticoreFuture ...
[13:23:33.577] result() for MulticoreFuture ... done
[13:23:33.578] A MulticoreFuture was resolved
[13:23:33.578]  length: 0 (resolved future 1)
[13:23:33.578] resolve() on list ... DONE
[13:23:33.578] - globals: [1] ‘a’
[13:23:33.578] Resolving futures part of globals (recursively) ... DONE
[13:23:33.581] The total size of the 1 globals is 1.57 MiB (1641120 bytes)
[13:23:33.582] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[13:23:33.582] - globals: [1] ‘a’
[13:23:33.582] - packages: [1] ‘future’
[13:23:33.582] getGlobalsAndPackages() ... DONE
[13:23:33.583] run() for ‘Future’ ...
[13:23:33.583] - state: ‘created’
[13:23:33.583] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:33.588] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:33.588] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:33.588]   - Field: ‘label’
[13:23:33.588]   - Field: ‘local’
[13:23:33.588]   - Field: ‘owner’
[13:23:33.588]   - Field: ‘envir’
[13:23:33.588]   - Field: ‘workers’
[13:23:33.589]   - Field: ‘packages’
[13:23:33.589]   - Field: ‘gc’
[13:23:33.589]   - Field: ‘job’
[13:23:33.589]   - Field: ‘conditions’
[13:23:33.589]   - Field: ‘expr’
[13:23:33.589]   - Field: ‘uuid’
[13:23:33.589]   - Field: ‘seed’
[13:23:33.589]   - Field: ‘version’
[13:23:33.590]   - Field: ‘result’
[13:23:33.590]   - Field: ‘asynchronous’
[13:23:33.590]   - Field: ‘calls’
[13:23:33.590]   - Field: ‘globals’
[13:23:33.590]   - Field: ‘stdout’
[13:23:33.590]   - Field: ‘earlySignal’
[13:23:33.590]   - Field: ‘lazy’
[13:23:33.590]   - Field: ‘state’
[13:23:33.593] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:33.593] - Launch lazy future ...
[13:23:33.594] Packages needed by the future expression (n = 1): ‘future’
[13:23:33.594] Packages needed by future strategies (n = 0): <none>
[13:23:33.595] {
[13:23:33.595]     {
[13:23:33.595]         {
[13:23:33.595]             ...future.startTime <- base::Sys.time()
[13:23:33.595]             {
[13:23:33.595]                 {
[13:23:33.595]                   {
[13:23:33.595]                     {
[13:23:33.595]                       {
[13:23:33.595]                         base::local({
[13:23:33.595]                           has_future <- base::requireNamespace("future", 
[13:23:33.595]                             quietly = TRUE)
[13:23:33.595]                           if (has_future) {
[13:23:33.595]                             ns <- base::getNamespace("future")
[13:23:33.595]                             version <- ns[[".package"]][["version"]]
[13:23:33.595]                             if (is.null(version)) 
[13:23:33.595]                               version <- utils::packageVersion("future")
[13:23:33.595]                           }
[13:23:33.595]                           else {
[13:23:33.595]                             version <- NULL
[13:23:33.595]                           }
[13:23:33.595]                           if (!has_future || version < "1.8.0") {
[13:23:33.595]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.595]                               "", base::R.version$version.string), 
[13:23:33.595]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:33.595]                                 base::R.version$platform, 8 * 
[13:23:33.595]                                   base::.Machine$sizeof.pointer), 
[13:23:33.595]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.595]                                 "release", "version")], collapse = " "), 
[13:23:33.595]                               hostname = base::Sys.info()[["nodename"]])
[13:23:33.595]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.595]                               info)
[13:23:33.595]                             info <- base::paste(info, collapse = "; ")
[13:23:33.595]                             if (!has_future) {
[13:23:33.595]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.595]                                 info)
[13:23:33.595]                             }
[13:23:33.595]                             else {
[13:23:33.595]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.595]                                 info, version)
[13:23:33.595]                             }
[13:23:33.595]                             base::stop(msg)
[13:23:33.595]                           }
[13:23:33.595]                         })
[13:23:33.595]                       }
[13:23:33.595]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:33.595]                       base::options(mc.cores = 1L)
[13:23:33.595]                     }
[13:23:33.595]                     base::local({
[13:23:33.595]                       for (pkg in "future") {
[13:23:33.595]                         base::loadNamespace(pkg)
[13:23:33.595]                         base::library(pkg, character.only = TRUE)
[13:23:33.595]                       }
[13:23:33.595]                     })
[13:23:33.595]                   }
[13:23:33.595]                   options(future.plan = NULL)
[13:23:33.595]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.595]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.595]                 }
[13:23:33.595]                 ...future.workdir <- getwd()
[13:23:33.595]             }
[13:23:33.595]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.595]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.595]         }
[13:23:33.595]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.595]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:33.595]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.595]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.595]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.595]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.595]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.595]             base::names(...future.oldOptions))
[13:23:33.595]     }
[13:23:33.595]     if (FALSE) {
[13:23:33.595]     }
[13:23:33.595]     else {
[13:23:33.595]         if (TRUE) {
[13:23:33.595]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.595]                 open = "w")
[13:23:33.595]         }
[13:23:33.595]         else {
[13:23:33.595]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.595]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.595]         }
[13:23:33.595]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.595]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.595]             base::sink(type = "output", split = FALSE)
[13:23:33.595]             base::close(...future.stdout)
[13:23:33.595]         }, add = TRUE)
[13:23:33.595]     }
[13:23:33.595]     ...future.frame <- base::sys.nframe()
[13:23:33.595]     ...future.conditions <- base::list()
[13:23:33.595]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.595]     if (FALSE) {
[13:23:33.595]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.595]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.595]     }
[13:23:33.595]     ...future.result <- base::tryCatch({
[13:23:33.595]         base::withCallingHandlers({
[13:23:33.595]             ...future.value <- base::withVisible(base::local({
[13:23:33.595]                 withCallingHandlers({
[13:23:33.595]                   value(a) + 1
[13:23:33.595]                 }, immediateCondition = function(cond) {
[13:23:33.595]                   save_rds <- function (object, pathname, ...) 
[13:23:33.595]                   {
[13:23:33.595]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:33.595]                     if (file_test("-f", pathname_tmp)) {
[13:23:33.595]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.595]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:33.595]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.595]                         fi_tmp[["mtime"]])
[13:23:33.595]                     }
[13:23:33.595]                     tryCatch({
[13:23:33.595]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:33.595]                     }, error = function(ex) {
[13:23:33.595]                       msg <- conditionMessage(ex)
[13:23:33.595]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.595]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:33.595]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.595]                         fi_tmp[["mtime"]], msg)
[13:23:33.595]                       ex$message <- msg
[13:23:33.595]                       stop(ex)
[13:23:33.595]                     })
[13:23:33.595]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:33.595]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:33.595]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:33.595]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.595]                       fi <- file.info(pathname)
[13:23:33.595]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:33.595]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.595]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:33.595]                         fi[["size"]], fi[["mtime"]])
[13:23:33.595]                       stop(msg)
[13:23:33.595]                     }
[13:23:33.595]                     invisible(pathname)
[13:23:33.595]                   }
[13:23:33.595]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:33.595]                     rootPath = tempdir()) 
[13:23:33.595]                   {
[13:23:33.595]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:33.595]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:33.595]                       tmpdir = path, fileext = ".rds")
[13:23:33.595]                     save_rds(obj, file)
[13:23:33.595]                   }
[13:23:33.595]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:33.595]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.595]                   {
[13:23:33.595]                     inherits <- base::inherits
[13:23:33.595]                     invokeRestart <- base::invokeRestart
[13:23:33.595]                     is.null <- base::is.null
[13:23:33.595]                     muffled <- FALSE
[13:23:33.595]                     if (inherits(cond, "message")) {
[13:23:33.595]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:33.595]                       if (muffled) 
[13:23:33.595]                         invokeRestart("muffleMessage")
[13:23:33.595]                     }
[13:23:33.595]                     else if (inherits(cond, "warning")) {
[13:23:33.595]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:33.595]                       if (muffled) 
[13:23:33.595]                         invokeRestart("muffleWarning")
[13:23:33.595]                     }
[13:23:33.595]                     else if (inherits(cond, "condition")) {
[13:23:33.595]                       if (!is.null(pattern)) {
[13:23:33.595]                         computeRestarts <- base::computeRestarts
[13:23:33.595]                         grepl <- base::grepl
[13:23:33.595]                         restarts <- computeRestarts(cond)
[13:23:33.595]                         for (restart in restarts) {
[13:23:33.595]                           name <- restart$name
[13:23:33.595]                           if (is.null(name)) 
[13:23:33.595]                             next
[13:23:33.595]                           if (!grepl(pattern, name)) 
[13:23:33.595]                             next
[13:23:33.595]                           invokeRestart(restart)
[13:23:33.595]                           muffled <- TRUE
[13:23:33.595]                           break
[13:23:33.595]                         }
[13:23:33.595]                       }
[13:23:33.595]                     }
[13:23:33.595]                     invisible(muffled)
[13:23:33.595]                   }
[13:23:33.595]                   muffleCondition(cond)
[13:23:33.595]                 })
[13:23:33.595]             }))
[13:23:33.595]             future::FutureResult(value = ...future.value$value, 
[13:23:33.595]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.595]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.595]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.595]                     ...future.globalenv.names))
[13:23:33.595]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.595]         }, condition = base::local({
[13:23:33.595]             c <- base::c
[13:23:33.595]             inherits <- base::inherits
[13:23:33.595]             invokeRestart <- base::invokeRestart
[13:23:33.595]             length <- base::length
[13:23:33.595]             list <- base::list
[13:23:33.595]             seq.int <- base::seq.int
[13:23:33.595]             signalCondition <- base::signalCondition
[13:23:33.595]             sys.calls <- base::sys.calls
[13:23:33.595]             `[[` <- base::`[[`
[13:23:33.595]             `+` <- base::`+`
[13:23:33.595]             `<<-` <- base::`<<-`
[13:23:33.595]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.595]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.595]                   3L)]
[13:23:33.595]             }
[13:23:33.595]             function(cond) {
[13:23:33.595]                 is_error <- inherits(cond, "error")
[13:23:33.595]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.595]                   NULL)
[13:23:33.595]                 if (is_error) {
[13:23:33.595]                   sessionInformation <- function() {
[13:23:33.595]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.595]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.595]                       search = base::search(), system = base::Sys.info())
[13:23:33.595]                   }
[13:23:33.595]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.595]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.595]                     cond$call), session = sessionInformation(), 
[13:23:33.595]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.595]                   signalCondition(cond)
[13:23:33.595]                 }
[13:23:33.595]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.595]                 "immediateCondition"))) {
[13:23:33.595]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.595]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.595]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.595]                   if (TRUE && !signal) {
[13:23:33.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.595]                     {
[13:23:33.595]                       inherits <- base::inherits
[13:23:33.595]                       invokeRestart <- base::invokeRestart
[13:23:33.595]                       is.null <- base::is.null
[13:23:33.595]                       muffled <- FALSE
[13:23:33.595]                       if (inherits(cond, "message")) {
[13:23:33.595]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.595]                         if (muffled) 
[13:23:33.595]                           invokeRestart("muffleMessage")
[13:23:33.595]                       }
[13:23:33.595]                       else if (inherits(cond, "warning")) {
[13:23:33.595]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.595]                         if (muffled) 
[13:23:33.595]                           invokeRestart("muffleWarning")
[13:23:33.595]                       }
[13:23:33.595]                       else if (inherits(cond, "condition")) {
[13:23:33.595]                         if (!is.null(pattern)) {
[13:23:33.595]                           computeRestarts <- base::computeRestarts
[13:23:33.595]                           grepl <- base::grepl
[13:23:33.595]                           restarts <- computeRestarts(cond)
[13:23:33.595]                           for (restart in restarts) {
[13:23:33.595]                             name <- restart$name
[13:23:33.595]                             if (is.null(name)) 
[13:23:33.595]                               next
[13:23:33.595]                             if (!grepl(pattern, name)) 
[13:23:33.595]                               next
[13:23:33.595]                             invokeRestart(restart)
[13:23:33.595]                             muffled <- TRUE
[13:23:33.595]                             break
[13:23:33.595]                           }
[13:23:33.595]                         }
[13:23:33.595]                       }
[13:23:33.595]                       invisible(muffled)
[13:23:33.595]                     }
[13:23:33.595]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.595]                   }
[13:23:33.595]                 }
[13:23:33.595]                 else {
[13:23:33.595]                   if (TRUE) {
[13:23:33.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.595]                     {
[13:23:33.595]                       inherits <- base::inherits
[13:23:33.595]                       invokeRestart <- base::invokeRestart
[13:23:33.595]                       is.null <- base::is.null
[13:23:33.595]                       muffled <- FALSE
[13:23:33.595]                       if (inherits(cond, "message")) {
[13:23:33.595]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.595]                         if (muffled) 
[13:23:33.595]                           invokeRestart("muffleMessage")
[13:23:33.595]                       }
[13:23:33.595]                       else if (inherits(cond, "warning")) {
[13:23:33.595]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.595]                         if (muffled) 
[13:23:33.595]                           invokeRestart("muffleWarning")
[13:23:33.595]                       }
[13:23:33.595]                       else if (inherits(cond, "condition")) {
[13:23:33.595]                         if (!is.null(pattern)) {
[13:23:33.595]                           computeRestarts <- base::computeRestarts
[13:23:33.595]                           grepl <- base::grepl
[13:23:33.595]                           restarts <- computeRestarts(cond)
[13:23:33.595]                           for (restart in restarts) {
[13:23:33.595]                             name <- restart$name
[13:23:33.595]                             if (is.null(name)) 
[13:23:33.595]                               next
[13:23:33.595]                             if (!grepl(pattern, name)) 
[13:23:33.595]                               next
[13:23:33.595]                             invokeRestart(restart)
[13:23:33.595]                             muffled <- TRUE
[13:23:33.595]                             break
[13:23:33.595]                           }
[13:23:33.595]                         }
[13:23:33.595]                       }
[13:23:33.595]                       invisible(muffled)
[13:23:33.595]                     }
[13:23:33.595]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.595]                   }
[13:23:33.595]                 }
[13:23:33.595]             }
[13:23:33.595]         }))
[13:23:33.595]     }, error = function(ex) {
[13:23:33.595]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.595]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.595]                 ...future.rng), started = ...future.startTime, 
[13:23:33.595]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.595]             version = "1.8"), class = "FutureResult")
[13:23:33.595]     }, finally = {
[13:23:33.595]         if (!identical(...future.workdir, getwd())) 
[13:23:33.595]             setwd(...future.workdir)
[13:23:33.595]         {
[13:23:33.595]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.595]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.595]             }
[13:23:33.595]             base::options(...future.oldOptions)
[13:23:33.595]             if (.Platform$OS.type == "windows") {
[13:23:33.595]                 old_names <- names(...future.oldEnvVars)
[13:23:33.595]                 envs <- base::Sys.getenv()
[13:23:33.595]                 names <- names(envs)
[13:23:33.595]                 common <- intersect(names, old_names)
[13:23:33.595]                 added <- setdiff(names, old_names)
[13:23:33.595]                 removed <- setdiff(old_names, names)
[13:23:33.595]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.595]                   envs[common]]
[13:23:33.595]                 NAMES <- toupper(changed)
[13:23:33.595]                 args <- list()
[13:23:33.595]                 for (kk in seq_along(NAMES)) {
[13:23:33.595]                   name <- changed[[kk]]
[13:23:33.595]                   NAME <- NAMES[[kk]]
[13:23:33.595]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.595]                     next
[13:23:33.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.595]                 }
[13:23:33.595]                 NAMES <- toupper(added)
[13:23:33.595]                 for (kk in seq_along(NAMES)) {
[13:23:33.595]                   name <- added[[kk]]
[13:23:33.595]                   NAME <- NAMES[[kk]]
[13:23:33.595]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.595]                     next
[13:23:33.595]                   args[[name]] <- ""
[13:23:33.595]                 }
[13:23:33.595]                 NAMES <- toupper(removed)
[13:23:33.595]                 for (kk in seq_along(NAMES)) {
[13:23:33.595]                   name <- removed[[kk]]
[13:23:33.595]                   NAME <- NAMES[[kk]]
[13:23:33.595]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.595]                     next
[13:23:33.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.595]                 }
[13:23:33.595]                 if (length(args) > 0) 
[13:23:33.595]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.595]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.595]             }
[13:23:33.595]             else {
[13:23:33.595]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.595]             }
[13:23:33.595]             {
[13:23:33.595]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.595]                   0L) {
[13:23:33.595]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.595]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.595]                   base::options(opts)
[13:23:33.595]                 }
[13:23:33.595]                 {
[13:23:33.595]                   {
[13:23:33.595]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:33.595]                     NULL
[13:23:33.595]                   }
[13:23:33.595]                   options(future.plan = NULL)
[13:23:33.595]                   if (is.na(NA_character_)) 
[13:23:33.595]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.595]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.595]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.595]                     envir = parent.frame()) 
[13:23:33.595]                   {
[13:23:33.595]                     default_workers <- missing(workers)
[13:23:33.595]                     if (is.function(workers)) 
[13:23:33.595]                       workers <- workers()
[13:23:33.595]                     workers <- structure(as.integer(workers), 
[13:23:33.595]                       class = class(workers))
[13:23:33.595]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.595]                       1L)
[13:23:33.595]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.595]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.595]                       if (default_workers) 
[13:23:33.595]                         supportsMulticore(warn = TRUE)
[13:23:33.595]                       return(sequential(..., envir = envir))
[13:23:33.595]                     }
[13:23:33.595]                     oopts <- options(mc.cores = workers)
[13:23:33.595]                     on.exit(options(oopts))
[13:23:33.595]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.595]                       envir = envir)
[13:23:33.595]                     if (!future$lazy) 
[13:23:33.595]                       future <- run(future)
[13:23:33.595]                     invisible(future)
[13:23:33.595]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.595]                 }
[13:23:33.595]             }
[13:23:33.595]         }
[13:23:33.595]     })
[13:23:33.595]     if (TRUE) {
[13:23:33.595]         base::sink(type = "output", split = FALSE)
[13:23:33.595]         if (TRUE) {
[13:23:33.595]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.595]         }
[13:23:33.595]         else {
[13:23:33.595]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.595]         }
[13:23:33.595]         base::close(...future.stdout)
[13:23:33.595]         ...future.stdout <- NULL
[13:23:33.595]     }
[13:23:33.595]     ...future.result$conditions <- ...future.conditions
[13:23:33.595]     ...future.result$finished <- base::Sys.time()
[13:23:33.595]     ...future.result
[13:23:33.595] }
[13:23:33.597] assign_globals() ...
[13:23:33.597] List of 1
[13:23:33.597]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5589bf0103e0> 
[13:23:33.597]  - attr(*, "where")=List of 1
[13:23:33.597]   ..$ a:<environment: R_EmptyEnv> 
[13:23:33.597]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:33.597]  - attr(*, "resolved")= logi TRUE
[13:23:33.597]  - attr(*, "total_size")= num 1641120
[13:23:33.597]  - attr(*, "already-done")= logi TRUE
[13:23:33.601] - copied ‘a’ to environment
[13:23:33.602] assign_globals() ... done
[13:23:33.602] requestCore(): workers = 2
[13:23:33.604] MulticoreFuture started
[13:23:33.605] - Launch lazy future ... done
[13:23:33.606] run() for ‘MulticoreFuture’ ... done
[13:23:33.606] plan(): Setting new future strategy stack:
[13:23:33.606] result() for MulticoreFuture ...
[13:23:33.607] List of future strategies:
[13:23:33.607] 1. sequential:
[13:23:33.607]    - args: function (..., envir = parent.frame())
[13:23:33.607]    - tweaked: FALSE
[13:23:33.607]    - call: NULL
[13:23:33.608] plan(): nbrOfWorkers() = 1
[13:23:33.612] plan(): Setting new future strategy stack:
[13:23:33.612] List of future strategies:
[13:23:33.612] 1. multicore:
[13:23:33.612]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:33.612]    - tweaked: FALSE
[13:23:33.612]    - call: plan(strategy)
[13:23:33.618] plan(): nbrOfWorkers() = 2
[13:23:33.619] result() for MulticoreFuture ...
[13:23:33.619] result() for MulticoreFuture ... done
[13:23:33.619] signalConditions() ...
[13:23:33.620]  - include = ‘immediateCondition’
[13:23:33.620]  - exclude = 
[13:23:33.620]  - resignal = FALSE
[13:23:33.620]  - Number of conditions: 4
[13:23:33.620] signalConditions() ... done
[13:23:33.620] result() for MulticoreFuture ... done
[13:23:33.621] result() for MulticoreFuture ...
[13:23:33.621] result() for MulticoreFuture ... done
[13:23:33.621] signalConditions() ...
[13:23:33.621]  - include = ‘immediateCondition’
[13:23:33.621]  - exclude = 
[13:23:33.621]  - resignal = FALSE
[13:23:33.621]  - Number of conditions: 4
[13:23:33.622] signalConditions() ... done
[13:23:33.622] Future state: ‘finished’
[13:23:33.622] result() for MulticoreFuture ...
[13:23:33.622] result() for MulticoreFuture ... done
[13:23:33.622] signalConditions() ...
[13:23:33.622]  - include = ‘condition’
[13:23:33.622]  - exclude = ‘immediateCondition’
[13:23:33.623]  - resignal = TRUE
[13:23:33.623]  - Number of conditions: 4
[13:23:33.623]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.609] result() for MulticoreFuture ...
[13:23:33.623]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.610] result() for MulticoreFuture ... done
[13:23:33.623]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.610] result() for MulticoreFuture ...
[13:23:33.623]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.611] result() for MulticoreFuture ... done
[13:23:33.624] signalConditions() ... done
value(b) = 2
[13:23:33.624] result() for MulticoreFuture ...
[13:23:33.624] result() for MulticoreFuture ... done
[13:23:33.624] result() for MulticoreFuture ...
[13:23:33.624] result() for MulticoreFuture ... done
[13:23:33.624] signalConditions() ...
[13:23:33.624]  - include = ‘immediateCondition’
[13:23:33.625]  - exclude = 
[13:23:33.625]  - resignal = FALSE
[13:23:33.625]  - Number of conditions: 4
[13:23:33.625] signalConditions() ... done
[13:23:33.625] Future state: ‘finished’
[13:23:33.625] result() for MulticoreFuture ...
[13:23:33.625] result() for MulticoreFuture ... done
[13:23:33.625] signalConditions() ...
[13:23:33.625]  - include = ‘condition’
[13:23:33.626]  - exclude = ‘immediateCondition’
[13:23:33.626]  - resignal = TRUE
[13:23:33.626]  - Number of conditions: 4
[13:23:33.626]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.609] result() for MulticoreFuture ...
[13:23:33.626]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.610] result() for MulticoreFuture ... done
[13:23:33.626]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.610] result() for MulticoreFuture ...
[13:23:33.626]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.611] result() for MulticoreFuture ... done
[13:23:33.627] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:33.627] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:33.627] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:33.628] 
[13:23:33.628] Searching for globals ... DONE
[13:23:33.628] - globals: [0] <none>
[13:23:33.628] getGlobalsAndPackages() ... DONE
[13:23:33.628] run() for ‘Future’ ...
[13:23:33.629] - state: ‘created’
[13:23:33.629] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:33.633] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:33.633] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:33.634]   - Field: ‘label’
[13:23:33.634]   - Field: ‘local’
[13:23:33.634]   - Field: ‘owner’
[13:23:33.634]   - Field: ‘envir’
[13:23:33.634]   - Field: ‘workers’
[13:23:33.634]   - Field: ‘packages’
[13:23:33.634]   - Field: ‘gc’
[13:23:33.634]   - Field: ‘job’
[13:23:33.635]   - Field: ‘conditions’
[13:23:33.635]   - Field: ‘expr’
[13:23:33.635]   - Field: ‘uuid’
[13:23:33.635]   - Field: ‘seed’
[13:23:33.635]   - Field: ‘version’
[13:23:33.635]   - Field: ‘result’
[13:23:33.635]   - Field: ‘asynchronous’
[13:23:33.635]   - Field: ‘calls’
[13:23:33.635]   - Field: ‘globals’
[13:23:33.636]   - Field: ‘stdout’
[13:23:33.636]   - Field: ‘earlySignal’
[13:23:33.636]   - Field: ‘lazy’
[13:23:33.636]   - Field: ‘state’
[13:23:33.636] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:33.636] - Launch lazy future ...
[13:23:33.637] Packages needed by the future expression (n = 0): <none>
[13:23:33.637] Packages needed by future strategies (n = 0): <none>
[13:23:33.637] {
[13:23:33.637]     {
[13:23:33.637]         {
[13:23:33.637]             ...future.startTime <- base::Sys.time()
[13:23:33.637]             {
[13:23:33.637]                 {
[13:23:33.637]                   {
[13:23:33.637]                     {
[13:23:33.637]                       base::local({
[13:23:33.637]                         has_future <- base::requireNamespace("future", 
[13:23:33.637]                           quietly = TRUE)
[13:23:33.637]                         if (has_future) {
[13:23:33.637]                           ns <- base::getNamespace("future")
[13:23:33.637]                           version <- ns[[".package"]][["version"]]
[13:23:33.637]                           if (is.null(version)) 
[13:23:33.637]                             version <- utils::packageVersion("future")
[13:23:33.637]                         }
[13:23:33.637]                         else {
[13:23:33.637]                           version <- NULL
[13:23:33.637]                         }
[13:23:33.637]                         if (!has_future || version < "1.8.0") {
[13:23:33.637]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.637]                             "", base::R.version$version.string), 
[13:23:33.637]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:33.637]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:33.637]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.637]                               "release", "version")], collapse = " "), 
[13:23:33.637]                             hostname = base::Sys.info()[["nodename"]])
[13:23:33.637]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.637]                             info)
[13:23:33.637]                           info <- base::paste(info, collapse = "; ")
[13:23:33.637]                           if (!has_future) {
[13:23:33.637]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.637]                               info)
[13:23:33.637]                           }
[13:23:33.637]                           else {
[13:23:33.637]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.637]                               info, version)
[13:23:33.637]                           }
[13:23:33.637]                           base::stop(msg)
[13:23:33.637]                         }
[13:23:33.637]                       })
[13:23:33.637]                     }
[13:23:33.637]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:33.637]                     base::options(mc.cores = 1L)
[13:23:33.637]                   }
[13:23:33.637]                   options(future.plan = NULL)
[13:23:33.637]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.637]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.637]                 }
[13:23:33.637]                 ...future.workdir <- getwd()
[13:23:33.637]             }
[13:23:33.637]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.637]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.637]         }
[13:23:33.637]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.637]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:33.637]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.637]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.637]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.637]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.637]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.637]             base::names(...future.oldOptions))
[13:23:33.637]     }
[13:23:33.637]     if (FALSE) {
[13:23:33.637]     }
[13:23:33.637]     else {
[13:23:33.637]         if (TRUE) {
[13:23:33.637]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.637]                 open = "w")
[13:23:33.637]         }
[13:23:33.637]         else {
[13:23:33.637]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.637]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.637]         }
[13:23:33.637]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.637]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.637]             base::sink(type = "output", split = FALSE)
[13:23:33.637]             base::close(...future.stdout)
[13:23:33.637]         }, add = TRUE)
[13:23:33.637]     }
[13:23:33.637]     ...future.frame <- base::sys.nframe()
[13:23:33.637]     ...future.conditions <- base::list()
[13:23:33.637]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.637]     if (FALSE) {
[13:23:33.637]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.637]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.637]     }
[13:23:33.637]     ...future.result <- base::tryCatch({
[13:23:33.637]         base::withCallingHandlers({
[13:23:33.637]             ...future.value <- base::withVisible(base::local({
[13:23:33.637]                 withCallingHandlers({
[13:23:33.637]                   1
[13:23:33.637]                 }, immediateCondition = function(cond) {
[13:23:33.637]                   save_rds <- function (object, pathname, ...) 
[13:23:33.637]                   {
[13:23:33.637]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:33.637]                     if (file_test("-f", pathname_tmp)) {
[13:23:33.637]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.637]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:33.637]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.637]                         fi_tmp[["mtime"]])
[13:23:33.637]                     }
[13:23:33.637]                     tryCatch({
[13:23:33.637]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:33.637]                     }, error = function(ex) {
[13:23:33.637]                       msg <- conditionMessage(ex)
[13:23:33.637]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.637]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:33.637]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.637]                         fi_tmp[["mtime"]], msg)
[13:23:33.637]                       ex$message <- msg
[13:23:33.637]                       stop(ex)
[13:23:33.637]                     })
[13:23:33.637]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:33.637]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:33.637]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:33.637]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.637]                       fi <- file.info(pathname)
[13:23:33.637]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:33.637]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.637]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:33.637]                         fi[["size"]], fi[["mtime"]])
[13:23:33.637]                       stop(msg)
[13:23:33.637]                     }
[13:23:33.637]                     invisible(pathname)
[13:23:33.637]                   }
[13:23:33.637]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:33.637]                     rootPath = tempdir()) 
[13:23:33.637]                   {
[13:23:33.637]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:33.637]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:33.637]                       tmpdir = path, fileext = ".rds")
[13:23:33.637]                     save_rds(obj, file)
[13:23:33.637]                   }
[13:23:33.637]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:33.637]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.637]                   {
[13:23:33.637]                     inherits <- base::inherits
[13:23:33.637]                     invokeRestart <- base::invokeRestart
[13:23:33.637]                     is.null <- base::is.null
[13:23:33.637]                     muffled <- FALSE
[13:23:33.637]                     if (inherits(cond, "message")) {
[13:23:33.637]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:33.637]                       if (muffled) 
[13:23:33.637]                         invokeRestart("muffleMessage")
[13:23:33.637]                     }
[13:23:33.637]                     else if (inherits(cond, "warning")) {
[13:23:33.637]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:33.637]                       if (muffled) 
[13:23:33.637]                         invokeRestart("muffleWarning")
[13:23:33.637]                     }
[13:23:33.637]                     else if (inherits(cond, "condition")) {
[13:23:33.637]                       if (!is.null(pattern)) {
[13:23:33.637]                         computeRestarts <- base::computeRestarts
[13:23:33.637]                         grepl <- base::grepl
[13:23:33.637]                         restarts <- computeRestarts(cond)
[13:23:33.637]                         for (restart in restarts) {
[13:23:33.637]                           name <- restart$name
[13:23:33.637]                           if (is.null(name)) 
[13:23:33.637]                             next
[13:23:33.637]                           if (!grepl(pattern, name)) 
[13:23:33.637]                             next
[13:23:33.637]                           invokeRestart(restart)
[13:23:33.637]                           muffled <- TRUE
[13:23:33.637]                           break
[13:23:33.637]                         }
[13:23:33.637]                       }
[13:23:33.637]                     }
[13:23:33.637]                     invisible(muffled)
[13:23:33.637]                   }
[13:23:33.637]                   muffleCondition(cond)
[13:23:33.637]                 })
[13:23:33.637]             }))
[13:23:33.637]             future::FutureResult(value = ...future.value$value, 
[13:23:33.637]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.637]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.637]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.637]                     ...future.globalenv.names))
[13:23:33.637]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.637]         }, condition = base::local({
[13:23:33.637]             c <- base::c
[13:23:33.637]             inherits <- base::inherits
[13:23:33.637]             invokeRestart <- base::invokeRestart
[13:23:33.637]             length <- base::length
[13:23:33.637]             list <- base::list
[13:23:33.637]             seq.int <- base::seq.int
[13:23:33.637]             signalCondition <- base::signalCondition
[13:23:33.637]             sys.calls <- base::sys.calls
[13:23:33.637]             `[[` <- base::`[[`
[13:23:33.637]             `+` <- base::`+`
[13:23:33.637]             `<<-` <- base::`<<-`
[13:23:33.637]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.637]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.637]                   3L)]
[13:23:33.637]             }
[13:23:33.637]             function(cond) {
[13:23:33.637]                 is_error <- inherits(cond, "error")
[13:23:33.637]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.637]                   NULL)
[13:23:33.637]                 if (is_error) {
[13:23:33.637]                   sessionInformation <- function() {
[13:23:33.637]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.637]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.637]                       search = base::search(), system = base::Sys.info())
[13:23:33.637]                   }
[13:23:33.637]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.637]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.637]                     cond$call), session = sessionInformation(), 
[13:23:33.637]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.637]                   signalCondition(cond)
[13:23:33.637]                 }
[13:23:33.637]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.637]                 "immediateCondition"))) {
[13:23:33.637]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.637]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.637]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.637]                   if (TRUE && !signal) {
[13:23:33.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.637]                     {
[13:23:33.637]                       inherits <- base::inherits
[13:23:33.637]                       invokeRestart <- base::invokeRestart
[13:23:33.637]                       is.null <- base::is.null
[13:23:33.637]                       muffled <- FALSE
[13:23:33.637]                       if (inherits(cond, "message")) {
[13:23:33.637]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.637]                         if (muffled) 
[13:23:33.637]                           invokeRestart("muffleMessage")
[13:23:33.637]                       }
[13:23:33.637]                       else if (inherits(cond, "warning")) {
[13:23:33.637]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.637]                         if (muffled) 
[13:23:33.637]                           invokeRestart("muffleWarning")
[13:23:33.637]                       }
[13:23:33.637]                       else if (inherits(cond, "condition")) {
[13:23:33.637]                         if (!is.null(pattern)) {
[13:23:33.637]                           computeRestarts <- base::computeRestarts
[13:23:33.637]                           grepl <- base::grepl
[13:23:33.637]                           restarts <- computeRestarts(cond)
[13:23:33.637]                           for (restart in restarts) {
[13:23:33.637]                             name <- restart$name
[13:23:33.637]                             if (is.null(name)) 
[13:23:33.637]                               next
[13:23:33.637]                             if (!grepl(pattern, name)) 
[13:23:33.637]                               next
[13:23:33.637]                             invokeRestart(restart)
[13:23:33.637]                             muffled <- TRUE
[13:23:33.637]                             break
[13:23:33.637]                           }
[13:23:33.637]                         }
[13:23:33.637]                       }
[13:23:33.637]                       invisible(muffled)
[13:23:33.637]                     }
[13:23:33.637]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.637]                   }
[13:23:33.637]                 }
[13:23:33.637]                 else {
[13:23:33.637]                   if (TRUE) {
[13:23:33.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.637]                     {
[13:23:33.637]                       inherits <- base::inherits
[13:23:33.637]                       invokeRestart <- base::invokeRestart
[13:23:33.637]                       is.null <- base::is.null
[13:23:33.637]                       muffled <- FALSE
[13:23:33.637]                       if (inherits(cond, "message")) {
[13:23:33.637]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.637]                         if (muffled) 
[13:23:33.637]                           invokeRestart("muffleMessage")
[13:23:33.637]                       }
[13:23:33.637]                       else if (inherits(cond, "warning")) {
[13:23:33.637]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.637]                         if (muffled) 
[13:23:33.637]                           invokeRestart("muffleWarning")
[13:23:33.637]                       }
[13:23:33.637]                       else if (inherits(cond, "condition")) {
[13:23:33.637]                         if (!is.null(pattern)) {
[13:23:33.637]                           computeRestarts <- base::computeRestarts
[13:23:33.637]                           grepl <- base::grepl
[13:23:33.637]                           restarts <- computeRestarts(cond)
[13:23:33.637]                           for (restart in restarts) {
[13:23:33.637]                             name <- restart$name
[13:23:33.637]                             if (is.null(name)) 
[13:23:33.637]                               next
[13:23:33.637]                             if (!grepl(pattern, name)) 
[13:23:33.637]                               next
[13:23:33.637]                             invokeRestart(restart)
[13:23:33.637]                             muffled <- TRUE
[13:23:33.637]                             break
[13:23:33.637]                           }
[13:23:33.637]                         }
[13:23:33.637]                       }
[13:23:33.637]                       invisible(muffled)
[13:23:33.637]                     }
[13:23:33.637]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.637]                   }
[13:23:33.637]                 }
[13:23:33.637]             }
[13:23:33.637]         }))
[13:23:33.637]     }, error = function(ex) {
[13:23:33.637]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.637]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.637]                 ...future.rng), started = ...future.startTime, 
[13:23:33.637]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.637]             version = "1.8"), class = "FutureResult")
[13:23:33.637]     }, finally = {
[13:23:33.637]         if (!identical(...future.workdir, getwd())) 
[13:23:33.637]             setwd(...future.workdir)
[13:23:33.637]         {
[13:23:33.637]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.637]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.637]             }
[13:23:33.637]             base::options(...future.oldOptions)
[13:23:33.637]             if (.Platform$OS.type == "windows") {
[13:23:33.637]                 old_names <- names(...future.oldEnvVars)
[13:23:33.637]                 envs <- base::Sys.getenv()
[13:23:33.637]                 names <- names(envs)
[13:23:33.637]                 common <- intersect(names, old_names)
[13:23:33.637]                 added <- setdiff(names, old_names)
[13:23:33.637]                 removed <- setdiff(old_names, names)
[13:23:33.637]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.637]                   envs[common]]
[13:23:33.637]                 NAMES <- toupper(changed)
[13:23:33.637]                 args <- list()
[13:23:33.637]                 for (kk in seq_along(NAMES)) {
[13:23:33.637]                   name <- changed[[kk]]
[13:23:33.637]                   NAME <- NAMES[[kk]]
[13:23:33.637]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.637]                     next
[13:23:33.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.637]                 }
[13:23:33.637]                 NAMES <- toupper(added)
[13:23:33.637]                 for (kk in seq_along(NAMES)) {
[13:23:33.637]                   name <- added[[kk]]
[13:23:33.637]                   NAME <- NAMES[[kk]]
[13:23:33.637]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.637]                     next
[13:23:33.637]                   args[[name]] <- ""
[13:23:33.637]                 }
[13:23:33.637]                 NAMES <- toupper(removed)
[13:23:33.637]                 for (kk in seq_along(NAMES)) {
[13:23:33.637]                   name <- removed[[kk]]
[13:23:33.637]                   NAME <- NAMES[[kk]]
[13:23:33.637]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.637]                     next
[13:23:33.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.637]                 }
[13:23:33.637]                 if (length(args) > 0) 
[13:23:33.637]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.637]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.637]             }
[13:23:33.637]             else {
[13:23:33.637]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.637]             }
[13:23:33.637]             {
[13:23:33.637]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.637]                   0L) {
[13:23:33.637]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.637]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.637]                   base::options(opts)
[13:23:33.637]                 }
[13:23:33.637]                 {
[13:23:33.637]                   {
[13:23:33.637]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:33.637]                     NULL
[13:23:33.637]                   }
[13:23:33.637]                   options(future.plan = NULL)
[13:23:33.637]                   if (is.na(NA_character_)) 
[13:23:33.637]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.637]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.637]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.637]                     envir = parent.frame()) 
[13:23:33.637]                   {
[13:23:33.637]                     default_workers <- missing(workers)
[13:23:33.637]                     if (is.function(workers)) 
[13:23:33.637]                       workers <- workers()
[13:23:33.637]                     workers <- structure(as.integer(workers), 
[13:23:33.637]                       class = class(workers))
[13:23:33.637]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.637]                       1L)
[13:23:33.637]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.637]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.637]                       if (default_workers) 
[13:23:33.637]                         supportsMulticore(warn = TRUE)
[13:23:33.637]                       return(sequential(..., envir = envir))
[13:23:33.637]                     }
[13:23:33.637]                     oopts <- options(mc.cores = workers)
[13:23:33.637]                     on.exit(options(oopts))
[13:23:33.637]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.637]                       envir = envir)
[13:23:33.637]                     if (!future$lazy) 
[13:23:33.637]                       future <- run(future)
[13:23:33.637]                     invisible(future)
[13:23:33.637]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.637]                 }
[13:23:33.637]             }
[13:23:33.637]         }
[13:23:33.637]     })
[13:23:33.637]     if (TRUE) {
[13:23:33.637]         base::sink(type = "output", split = FALSE)
[13:23:33.637]         if (TRUE) {
[13:23:33.637]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.637]         }
[13:23:33.637]         else {
[13:23:33.637]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.637]         }
[13:23:33.637]         base::close(...future.stdout)
[13:23:33.637]         ...future.stdout <- NULL
[13:23:33.637]     }
[13:23:33.637]     ...future.result$conditions <- ...future.conditions
[13:23:33.637]     ...future.result$finished <- base::Sys.time()
[13:23:33.637]     ...future.result
[13:23:33.637] }
[13:23:33.640] requestCore(): workers = 2
[13:23:33.643] MulticoreFuture started
[13:23:33.643] - Launch lazy future ... done
[13:23:33.643] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:33.644] getGlobalsAndPackages() ...
[13:23:33.644] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:33.644] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:33.644] List of future strategies:
[13:23:33.644] 1. sequential:
[13:23:33.644]    - args: function (..., envir = parent.frame())
[13:23:33.644]    - tweaked: FALSE
[13:23:33.644]    - call: NULL
[13:23:33.645] plan(): nbrOfWorkers() = 1
[13:23:33.647] plan(): Setting new future strategy stack:
[13:23:33.650] List of future strategies:
[13:23:33.650] 1. multicore:
[13:23:33.650]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:33.650]    - tweaked: FALSE
[13:23:33.650]    - call: plan(strategy)
[13:23:33.651] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:33.651] Searching for globals ... DONE
[13:23:33.652] Resolving globals: TRUE
[13:23:33.652] Resolving any globals that are futures ...
[13:23:33.653] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:33.653] Resolving any globals that are futures ... DONE
[13:23:33.654] Resolving futures part of globals (recursively) ...
[13:23:33.654] resolve() on list ...
[13:23:33.655]  recursive: 99
[13:23:33.655]  length: 1
[13:23:33.656]  elements: ‘a’
[13:23:33.657] plan(): nbrOfWorkers() = 2
[13:23:33.657] Future #1
[13:23:33.658] result() for MulticoreFuture ...
[13:23:33.659] result() for MulticoreFuture ...
[13:23:33.659] result() for MulticoreFuture ... done
[13:23:33.659] result() for MulticoreFuture ... done
[13:23:33.659] result() for MulticoreFuture ...
[13:23:33.660] result() for MulticoreFuture ... done
[13:23:33.660] A MulticoreFuture was resolved
[13:23:33.661]  length: 0 (resolved future 1)
[13:23:33.661] resolve() on list ... DONE
[13:23:33.661] - globals: [1] ‘a’
[13:23:33.661] Resolving futures part of globals (recursively) ... DONE
[13:23:33.665] The total size of the 1 globals is 1.57 MiB (1641120 bytes)
[13:23:33.665] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[13:23:33.666] - globals: [1] ‘a’
[13:23:33.666] - packages: [1] ‘future’
[13:23:33.666] getGlobalsAndPackages() ... DONE
[13:23:33.666] run() for ‘Future’ ...
[13:23:33.666] - state: ‘created’
[13:23:33.667] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:33.671] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:33.671] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:33.671]   - Field: ‘label’
[13:23:33.672]   - Field: ‘local’
[13:23:33.672]   - Field: ‘owner’
[13:23:33.672]   - Field: ‘envir’
[13:23:33.672]   - Field: ‘workers’
[13:23:33.672]   - Field: ‘packages’
[13:23:33.672]   - Field: ‘gc’
[13:23:33.672]   - Field: ‘job’
[13:23:33.672]   - Field: ‘conditions’
[13:23:33.673]   - Field: ‘expr’
[13:23:33.673]   - Field: ‘uuid’
[13:23:33.673]   - Field: ‘seed’
[13:23:33.673]   - Field: ‘version’
[13:23:33.673]   - Field: ‘result’
[13:23:33.673]   - Field: ‘asynchronous’
[13:23:33.673]   - Field: ‘calls’
[13:23:33.673]   - Field: ‘globals’
[13:23:33.673]   - Field: ‘stdout’
[13:23:33.674]   - Field: ‘earlySignal’
[13:23:33.674]   - Field: ‘lazy’
[13:23:33.674]   - Field: ‘state’
[13:23:33.674] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:33.674] - Launch lazy future ...
[13:23:33.674] Packages needed by the future expression (n = 1): ‘future’
[13:23:33.674] Packages needed by future strategies (n = 0): <none>
[13:23:33.675] {
[13:23:33.675]     {
[13:23:33.675]         {
[13:23:33.675]             ...future.startTime <- base::Sys.time()
[13:23:33.675]             {
[13:23:33.675]                 {
[13:23:33.675]                   {
[13:23:33.675]                     {
[13:23:33.675]                       {
[13:23:33.675]                         base::local({
[13:23:33.675]                           has_future <- base::requireNamespace("future", 
[13:23:33.675]                             quietly = TRUE)
[13:23:33.675]                           if (has_future) {
[13:23:33.675]                             ns <- base::getNamespace("future")
[13:23:33.675]                             version <- ns[[".package"]][["version"]]
[13:23:33.675]                             if (is.null(version)) 
[13:23:33.675]                               version <- utils::packageVersion("future")
[13:23:33.675]                           }
[13:23:33.675]                           else {
[13:23:33.675]                             version <- NULL
[13:23:33.675]                           }
[13:23:33.675]                           if (!has_future || version < "1.8.0") {
[13:23:33.675]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.675]                               "", base::R.version$version.string), 
[13:23:33.675]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:33.675]                                 base::R.version$platform, 8 * 
[13:23:33.675]                                   base::.Machine$sizeof.pointer), 
[13:23:33.675]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.675]                                 "release", "version")], collapse = " "), 
[13:23:33.675]                               hostname = base::Sys.info()[["nodename"]])
[13:23:33.675]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.675]                               info)
[13:23:33.675]                             info <- base::paste(info, collapse = "; ")
[13:23:33.675]                             if (!has_future) {
[13:23:33.675]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.675]                                 info)
[13:23:33.675]                             }
[13:23:33.675]                             else {
[13:23:33.675]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.675]                                 info, version)
[13:23:33.675]                             }
[13:23:33.675]                             base::stop(msg)
[13:23:33.675]                           }
[13:23:33.675]                         })
[13:23:33.675]                       }
[13:23:33.675]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:33.675]                       base::options(mc.cores = 1L)
[13:23:33.675]                     }
[13:23:33.675]                     base::local({
[13:23:33.675]                       for (pkg in "future") {
[13:23:33.675]                         base::loadNamespace(pkg)
[13:23:33.675]                         base::library(pkg, character.only = TRUE)
[13:23:33.675]                       }
[13:23:33.675]                     })
[13:23:33.675]                   }
[13:23:33.675]                   options(future.plan = NULL)
[13:23:33.675]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.675]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.675]                 }
[13:23:33.675]                 ...future.workdir <- getwd()
[13:23:33.675]             }
[13:23:33.675]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.675]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.675]         }
[13:23:33.675]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.675]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:33.675]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.675]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.675]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.675]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.675]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.675]             base::names(...future.oldOptions))
[13:23:33.675]     }
[13:23:33.675]     if (FALSE) {
[13:23:33.675]     }
[13:23:33.675]     else {
[13:23:33.675]         if (TRUE) {
[13:23:33.675]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.675]                 open = "w")
[13:23:33.675]         }
[13:23:33.675]         else {
[13:23:33.675]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.675]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.675]         }
[13:23:33.675]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.675]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.675]             base::sink(type = "output", split = FALSE)
[13:23:33.675]             base::close(...future.stdout)
[13:23:33.675]         }, add = TRUE)
[13:23:33.675]     }
[13:23:33.675]     ...future.frame <- base::sys.nframe()
[13:23:33.675]     ...future.conditions <- base::list()
[13:23:33.675]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.675]     if (FALSE) {
[13:23:33.675]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.675]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.675]     }
[13:23:33.675]     ...future.result <- base::tryCatch({
[13:23:33.675]         base::withCallingHandlers({
[13:23:33.675]             ...future.value <- base::withVisible(base::local({
[13:23:33.675]                 withCallingHandlers({
[13:23:33.675]                   value(a) + 1
[13:23:33.675]                 }, immediateCondition = function(cond) {
[13:23:33.675]                   save_rds <- function (object, pathname, ...) 
[13:23:33.675]                   {
[13:23:33.675]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:33.675]                     if (file_test("-f", pathname_tmp)) {
[13:23:33.675]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.675]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:33.675]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.675]                         fi_tmp[["mtime"]])
[13:23:33.675]                     }
[13:23:33.675]                     tryCatch({
[13:23:33.675]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:33.675]                     }, error = function(ex) {
[13:23:33.675]                       msg <- conditionMessage(ex)
[13:23:33.675]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.675]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:33.675]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.675]                         fi_tmp[["mtime"]], msg)
[13:23:33.675]                       ex$message <- msg
[13:23:33.675]                       stop(ex)
[13:23:33.675]                     })
[13:23:33.675]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:33.675]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:33.675]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:33.675]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.675]                       fi <- file.info(pathname)
[13:23:33.675]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:33.675]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.675]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:33.675]                         fi[["size"]], fi[["mtime"]])
[13:23:33.675]                       stop(msg)
[13:23:33.675]                     }
[13:23:33.675]                     invisible(pathname)
[13:23:33.675]                   }
[13:23:33.675]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:33.675]                     rootPath = tempdir()) 
[13:23:33.675]                   {
[13:23:33.675]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:33.675]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:33.675]                       tmpdir = path, fileext = ".rds")
[13:23:33.675]                     save_rds(obj, file)
[13:23:33.675]                   }
[13:23:33.675]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:33.675]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.675]                   {
[13:23:33.675]                     inherits <- base::inherits
[13:23:33.675]                     invokeRestart <- base::invokeRestart
[13:23:33.675]                     is.null <- base::is.null
[13:23:33.675]                     muffled <- FALSE
[13:23:33.675]                     if (inherits(cond, "message")) {
[13:23:33.675]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:33.675]                       if (muffled) 
[13:23:33.675]                         invokeRestart("muffleMessage")
[13:23:33.675]                     }
[13:23:33.675]                     else if (inherits(cond, "warning")) {
[13:23:33.675]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:33.675]                       if (muffled) 
[13:23:33.675]                         invokeRestart("muffleWarning")
[13:23:33.675]                     }
[13:23:33.675]                     else if (inherits(cond, "condition")) {
[13:23:33.675]                       if (!is.null(pattern)) {
[13:23:33.675]                         computeRestarts <- base::computeRestarts
[13:23:33.675]                         grepl <- base::grepl
[13:23:33.675]                         restarts <- computeRestarts(cond)
[13:23:33.675]                         for (restart in restarts) {
[13:23:33.675]                           name <- restart$name
[13:23:33.675]                           if (is.null(name)) 
[13:23:33.675]                             next
[13:23:33.675]                           if (!grepl(pattern, name)) 
[13:23:33.675]                             next
[13:23:33.675]                           invokeRestart(restart)
[13:23:33.675]                           muffled <- TRUE
[13:23:33.675]                           break
[13:23:33.675]                         }
[13:23:33.675]                       }
[13:23:33.675]                     }
[13:23:33.675]                     invisible(muffled)
[13:23:33.675]                   }
[13:23:33.675]                   muffleCondition(cond)
[13:23:33.675]                 })
[13:23:33.675]             }))
[13:23:33.675]             future::FutureResult(value = ...future.value$value, 
[13:23:33.675]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.675]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.675]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.675]                     ...future.globalenv.names))
[13:23:33.675]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.675]         }, condition = base::local({
[13:23:33.675]             c <- base::c
[13:23:33.675]             inherits <- base::inherits
[13:23:33.675]             invokeRestart <- base::invokeRestart
[13:23:33.675]             length <- base::length
[13:23:33.675]             list <- base::list
[13:23:33.675]             seq.int <- base::seq.int
[13:23:33.675]             signalCondition <- base::signalCondition
[13:23:33.675]             sys.calls <- base::sys.calls
[13:23:33.675]             `[[` <- base::`[[`
[13:23:33.675]             `+` <- base::`+`
[13:23:33.675]             `<<-` <- base::`<<-`
[13:23:33.675]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.675]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.675]                   3L)]
[13:23:33.675]             }
[13:23:33.675]             function(cond) {
[13:23:33.675]                 is_error <- inherits(cond, "error")
[13:23:33.675]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.675]                   NULL)
[13:23:33.675]                 if (is_error) {
[13:23:33.675]                   sessionInformation <- function() {
[13:23:33.675]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.675]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.675]                       search = base::search(), system = base::Sys.info())
[13:23:33.675]                   }
[13:23:33.675]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.675]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.675]                     cond$call), session = sessionInformation(), 
[13:23:33.675]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.675]                   signalCondition(cond)
[13:23:33.675]                 }
[13:23:33.675]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.675]                 "immediateCondition"))) {
[13:23:33.675]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.675]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.675]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.675]                   if (TRUE && !signal) {
[13:23:33.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.675]                     {
[13:23:33.675]                       inherits <- base::inherits
[13:23:33.675]                       invokeRestart <- base::invokeRestart
[13:23:33.675]                       is.null <- base::is.null
[13:23:33.675]                       muffled <- FALSE
[13:23:33.675]                       if (inherits(cond, "message")) {
[13:23:33.675]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.675]                         if (muffled) 
[13:23:33.675]                           invokeRestart("muffleMessage")
[13:23:33.675]                       }
[13:23:33.675]                       else if (inherits(cond, "warning")) {
[13:23:33.675]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.675]                         if (muffled) 
[13:23:33.675]                           invokeRestart("muffleWarning")
[13:23:33.675]                       }
[13:23:33.675]                       else if (inherits(cond, "condition")) {
[13:23:33.675]                         if (!is.null(pattern)) {
[13:23:33.675]                           computeRestarts <- base::computeRestarts
[13:23:33.675]                           grepl <- base::grepl
[13:23:33.675]                           restarts <- computeRestarts(cond)
[13:23:33.675]                           for (restart in restarts) {
[13:23:33.675]                             name <- restart$name
[13:23:33.675]                             if (is.null(name)) 
[13:23:33.675]                               next
[13:23:33.675]                             if (!grepl(pattern, name)) 
[13:23:33.675]                               next
[13:23:33.675]                             invokeRestart(restart)
[13:23:33.675]                             muffled <- TRUE
[13:23:33.675]                             break
[13:23:33.675]                           }
[13:23:33.675]                         }
[13:23:33.675]                       }
[13:23:33.675]                       invisible(muffled)
[13:23:33.675]                     }
[13:23:33.675]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.675]                   }
[13:23:33.675]                 }
[13:23:33.675]                 else {
[13:23:33.675]                   if (TRUE) {
[13:23:33.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.675]                     {
[13:23:33.675]                       inherits <- base::inherits
[13:23:33.675]                       invokeRestart <- base::invokeRestart
[13:23:33.675]                       is.null <- base::is.null
[13:23:33.675]                       muffled <- FALSE
[13:23:33.675]                       if (inherits(cond, "message")) {
[13:23:33.675]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.675]                         if (muffled) 
[13:23:33.675]                           invokeRestart("muffleMessage")
[13:23:33.675]                       }
[13:23:33.675]                       else if (inherits(cond, "warning")) {
[13:23:33.675]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.675]                         if (muffled) 
[13:23:33.675]                           invokeRestart("muffleWarning")
[13:23:33.675]                       }
[13:23:33.675]                       else if (inherits(cond, "condition")) {
[13:23:33.675]                         if (!is.null(pattern)) {
[13:23:33.675]                           computeRestarts <- base::computeRestarts
[13:23:33.675]                           grepl <- base::grepl
[13:23:33.675]                           restarts <- computeRestarts(cond)
[13:23:33.675]                           for (restart in restarts) {
[13:23:33.675]                             name <- restart$name
[13:23:33.675]                             if (is.null(name)) 
[13:23:33.675]                               next
[13:23:33.675]                             if (!grepl(pattern, name)) 
[13:23:33.675]                               next
[13:23:33.675]                             invokeRestart(restart)
[13:23:33.675]                             muffled <- TRUE
[13:23:33.675]                             break
[13:23:33.675]                           }
[13:23:33.675]                         }
[13:23:33.675]                       }
[13:23:33.675]                       invisible(muffled)
[13:23:33.675]                     }
[13:23:33.675]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.675]                   }
[13:23:33.675]                 }
[13:23:33.675]             }
[13:23:33.675]         }))
[13:23:33.675]     }, error = function(ex) {
[13:23:33.675]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.675]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.675]                 ...future.rng), started = ...future.startTime, 
[13:23:33.675]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.675]             version = "1.8"), class = "FutureResult")
[13:23:33.675]     }, finally = {
[13:23:33.675]         if (!identical(...future.workdir, getwd())) 
[13:23:33.675]             setwd(...future.workdir)
[13:23:33.675]         {
[13:23:33.675]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.675]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.675]             }
[13:23:33.675]             base::options(...future.oldOptions)
[13:23:33.675]             if (.Platform$OS.type == "windows") {
[13:23:33.675]                 old_names <- names(...future.oldEnvVars)
[13:23:33.675]                 envs <- base::Sys.getenv()
[13:23:33.675]                 names <- names(envs)
[13:23:33.675]                 common <- intersect(names, old_names)
[13:23:33.675]                 added <- setdiff(names, old_names)
[13:23:33.675]                 removed <- setdiff(old_names, names)
[13:23:33.675]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.675]                   envs[common]]
[13:23:33.675]                 NAMES <- toupper(changed)
[13:23:33.675]                 args <- list()
[13:23:33.675]                 for (kk in seq_along(NAMES)) {
[13:23:33.675]                   name <- changed[[kk]]
[13:23:33.675]                   NAME <- NAMES[[kk]]
[13:23:33.675]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.675]                     next
[13:23:33.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.675]                 }
[13:23:33.675]                 NAMES <- toupper(added)
[13:23:33.675]                 for (kk in seq_along(NAMES)) {
[13:23:33.675]                   name <- added[[kk]]
[13:23:33.675]                   NAME <- NAMES[[kk]]
[13:23:33.675]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.675]                     next
[13:23:33.675]                   args[[name]] <- ""
[13:23:33.675]                 }
[13:23:33.675]                 NAMES <- toupper(removed)
[13:23:33.675]                 for (kk in seq_along(NAMES)) {
[13:23:33.675]                   name <- removed[[kk]]
[13:23:33.675]                   NAME <- NAMES[[kk]]
[13:23:33.675]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.675]                     next
[13:23:33.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.675]                 }
[13:23:33.675]                 if (length(args) > 0) 
[13:23:33.675]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.675]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.675]             }
[13:23:33.675]             else {
[13:23:33.675]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.675]             }
[13:23:33.675]             {
[13:23:33.675]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.675]                   0L) {
[13:23:33.675]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.675]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.675]                   base::options(opts)
[13:23:33.675]                 }
[13:23:33.675]                 {
[13:23:33.675]                   {
[13:23:33.675]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:33.675]                     NULL
[13:23:33.675]                   }
[13:23:33.675]                   options(future.plan = NULL)
[13:23:33.675]                   if (is.na(NA_character_)) 
[13:23:33.675]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.675]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.675]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.675]                     envir = parent.frame()) 
[13:23:33.675]                   {
[13:23:33.675]                     default_workers <- missing(workers)
[13:23:33.675]                     if (is.function(workers)) 
[13:23:33.675]                       workers <- workers()
[13:23:33.675]                     workers <- structure(as.integer(workers), 
[13:23:33.675]                       class = class(workers))
[13:23:33.675]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.675]                       1L)
[13:23:33.675]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.675]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.675]                       if (default_workers) 
[13:23:33.675]                         supportsMulticore(warn = TRUE)
[13:23:33.675]                       return(sequential(..., envir = envir))
[13:23:33.675]                     }
[13:23:33.675]                     oopts <- options(mc.cores = workers)
[13:23:33.675]                     on.exit(options(oopts))
[13:23:33.675]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.675]                       envir = envir)
[13:23:33.675]                     if (!future$lazy) 
[13:23:33.675]                       future <- run(future)
[13:23:33.675]                     invisible(future)
[13:23:33.675]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.675]                 }
[13:23:33.675]             }
[13:23:33.675]         }
[13:23:33.675]     })
[13:23:33.675]     if (TRUE) {
[13:23:33.675]         base::sink(type = "output", split = FALSE)
[13:23:33.675]         if (TRUE) {
[13:23:33.675]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.675]         }
[13:23:33.675]         else {
[13:23:33.675]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.675]         }
[13:23:33.675]         base::close(...future.stdout)
[13:23:33.675]         ...future.stdout <- NULL
[13:23:33.675]     }
[13:23:33.675]     ...future.result$conditions <- ...future.conditions
[13:23:33.675]     ...future.result$finished <- base::Sys.time()
[13:23:33.675]     ...future.result
[13:23:33.675] }
[13:23:33.678] assign_globals() ...
[13:23:33.678] List of 1
[13:23:33.678]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5589becf41b0> 
[13:23:33.678]  - attr(*, "where")=List of 1
[13:23:33.678]   ..$ a:<environment: R_EmptyEnv> 
[13:23:33.678]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:33.678]  - attr(*, "resolved")= logi TRUE
[13:23:33.678]  - attr(*, "total_size")= num 1641120
[13:23:33.678]  - attr(*, "already-done")= logi TRUE
[13:23:33.681] - copied ‘a’ to environment
[13:23:33.681] assign_globals() ... done
[13:23:33.681] requestCore(): workers = 2
[13:23:33.684] MulticoreFuture started
[13:23:33.684] - Launch lazy future ... done
[13:23:33.684] run() for ‘MulticoreFuture’ ... done
[13:23:33.685] result() for MulticoreFuture ...
[13:23:33.685] plan(): Setting new future strategy stack:
[13:23:33.686] List of future strategies:
[13:23:33.686] 1. sequential:
[13:23:33.686]    - args: function (..., envir = parent.frame())
[13:23:33.686]    - tweaked: FALSE
[13:23:33.686]    - call: NULL
[13:23:33.687] plan(): nbrOfWorkers() = 1
[13:23:33.690] plan(): Setting new future strategy stack:
[13:23:33.690] List of future strategies:
[13:23:33.690] 1. multicore:
[13:23:33.690]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:33.690]    - tweaked: FALSE
[13:23:33.690]    - call: plan(strategy)
[13:23:33.696] plan(): nbrOfWorkers() = 2
[13:23:33.697] result() for MulticoreFuture ...
[13:23:33.697] result() for MulticoreFuture ... done
[13:23:33.697] signalConditions() ...
[13:23:33.697]  - include = ‘immediateCondition’
[13:23:33.698]  - exclude = 
[13:23:33.698]  - resignal = FALSE
[13:23:33.698]  - Number of conditions: 4
[13:23:33.698] signalConditions() ... done
[13:23:33.698] result() for MulticoreFuture ... done
[13:23:33.698] result() for MulticoreFuture ...
[13:23:33.698] result() for MulticoreFuture ... done
[13:23:33.698] signalConditions() ...
[13:23:33.699]  - include = ‘immediateCondition’
[13:23:33.699]  - exclude = 
[13:23:33.699]  - resignal = FALSE
[13:23:33.699]  - Number of conditions: 4
[13:23:33.699] signalConditions() ... done
[13:23:33.699] Future state: ‘finished’
[13:23:33.699] result() for MulticoreFuture ...
[13:23:33.699] result() for MulticoreFuture ... done
[13:23:33.700] signalConditions() ...
[13:23:33.700]  - include = ‘condition’
[13:23:33.700]  - exclude = ‘immediateCondition’
[13:23:33.700]  - resignal = TRUE
[13:23:33.700]  - Number of conditions: 4
[13:23:33.700]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.688] result() for MulticoreFuture ...
[13:23:33.700]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.689] result() for MulticoreFuture ... done
[13:23:33.701]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.689] result() for MulticoreFuture ...
[13:23:33.704]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.689] result() for MulticoreFuture ... done
[13:23:33.704] signalConditions() ... done
value(b) = 2
[13:23:33.704] result() for MulticoreFuture ...
[13:23:33.705] result() for MulticoreFuture ... done
[13:23:33.705] result() for MulticoreFuture ...
[13:23:33.705] result() for MulticoreFuture ... done
[13:23:33.705] signalConditions() ...
[13:23:33.705]  - include = ‘immediateCondition’
[13:23:33.705]  - exclude = 
[13:23:33.705]  - resignal = FALSE
[13:23:33.706]  - Number of conditions: 4
[13:23:33.706] signalConditions() ... done
[13:23:33.706] Future state: ‘finished’
[13:23:33.706] result() for MulticoreFuture ...
[13:23:33.706] result() for MulticoreFuture ... done
[13:23:33.707] signalConditions() ...
[13:23:33.707]  - include = ‘condition’
[13:23:33.707]  - exclude = ‘immediateCondition’
[13:23:33.707]  - resignal = TRUE
[13:23:33.707]  - Number of conditions: 4
[13:23:33.707]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.688] result() for MulticoreFuture ...
[13:23:33.707]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.689] result() for MulticoreFuture ... done
[13:23:33.708]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.689] result() for MulticoreFuture ...
[13:23:33.708]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.689] result() for MulticoreFuture ... done
[13:23:33.708] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:33.709] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:33.709] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:33.710] 
[13:23:33.710] Searching for globals ... DONE
[13:23:33.710] - globals: [0] <none>
[13:23:33.710] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:33.711] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:33.711] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:33.712] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:33.712] Searching for globals ... DONE
[13:23:33.712] Resolving globals: TRUE
[13:23:33.713] Resolving any globals that are futures ...
[13:23:33.713] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:33.713] Resolving any globals that are futures ... DONE
[13:23:33.713] Resolving futures part of globals (recursively) ...
[13:23:33.714] resolve() on list ...
[13:23:33.714]  recursive: 99
[13:23:33.714]  length: 1
[13:23:33.714]  elements: ‘a’
[13:23:33.714] run() for ‘Future’ ...
[13:23:33.714] - state: ‘created’
[13:23:33.714] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:33.719] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:33.719] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:33.719]   - Field: ‘label’
[13:23:33.719]   - Field: ‘local’
[13:23:33.719]   - Field: ‘owner’
[13:23:33.719]   - Field: ‘envir’
[13:23:33.720]   - Field: ‘workers’
[13:23:33.720]   - Field: ‘packages’
[13:23:33.720]   - Field: ‘gc’
[13:23:33.720]   - Field: ‘job’
[13:23:33.720]   - Field: ‘conditions’
[13:23:33.720]   - Field: ‘expr’
[13:23:33.720]   - Field: ‘uuid’
[13:23:33.720]   - Field: ‘seed’
[13:23:33.721]   - Field: ‘version’
[13:23:33.721]   - Field: ‘result’
[13:23:33.721]   - Field: ‘asynchronous’
[13:23:33.721]   - Field: ‘calls’
[13:23:33.721]   - Field: ‘globals’
[13:23:33.721]   - Field: ‘stdout’
[13:23:33.721]   - Field: ‘earlySignal’
[13:23:33.721]   - Field: ‘lazy’
[13:23:33.721]   - Field: ‘state’
[13:23:33.722] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:33.722] - Launch lazy future ...
[13:23:33.722] Packages needed by the future expression (n = 0): <none>
[13:23:33.722] Packages needed by future strategies (n = 0): <none>
[13:23:33.723] {
[13:23:33.723]     {
[13:23:33.723]         {
[13:23:33.723]             ...future.startTime <- base::Sys.time()
[13:23:33.723]             {
[13:23:33.723]                 {
[13:23:33.723]                   {
[13:23:33.723]                     {
[13:23:33.723]                       base::local({
[13:23:33.723]                         has_future <- base::requireNamespace("future", 
[13:23:33.723]                           quietly = TRUE)
[13:23:33.723]                         if (has_future) {
[13:23:33.723]                           ns <- base::getNamespace("future")
[13:23:33.723]                           version <- ns[[".package"]][["version"]]
[13:23:33.723]                           if (is.null(version)) 
[13:23:33.723]                             version <- utils::packageVersion("future")
[13:23:33.723]                         }
[13:23:33.723]                         else {
[13:23:33.723]                           version <- NULL
[13:23:33.723]                         }
[13:23:33.723]                         if (!has_future || version < "1.8.0") {
[13:23:33.723]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.723]                             "", base::R.version$version.string), 
[13:23:33.723]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:33.723]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:33.723]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.723]                               "release", "version")], collapse = " "), 
[13:23:33.723]                             hostname = base::Sys.info()[["nodename"]])
[13:23:33.723]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.723]                             info)
[13:23:33.723]                           info <- base::paste(info, collapse = "; ")
[13:23:33.723]                           if (!has_future) {
[13:23:33.723]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.723]                               info)
[13:23:33.723]                           }
[13:23:33.723]                           else {
[13:23:33.723]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.723]                               info, version)
[13:23:33.723]                           }
[13:23:33.723]                           base::stop(msg)
[13:23:33.723]                         }
[13:23:33.723]                       })
[13:23:33.723]                     }
[13:23:33.723]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:33.723]                     base::options(mc.cores = 1L)
[13:23:33.723]                   }
[13:23:33.723]                   options(future.plan = NULL)
[13:23:33.723]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.723]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.723]                 }
[13:23:33.723]                 ...future.workdir <- getwd()
[13:23:33.723]             }
[13:23:33.723]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.723]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.723]         }
[13:23:33.723]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.723]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:33.723]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.723]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.723]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.723]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.723]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.723]             base::names(...future.oldOptions))
[13:23:33.723]     }
[13:23:33.723]     if (FALSE) {
[13:23:33.723]     }
[13:23:33.723]     else {
[13:23:33.723]         if (TRUE) {
[13:23:33.723]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.723]                 open = "w")
[13:23:33.723]         }
[13:23:33.723]         else {
[13:23:33.723]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.723]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.723]         }
[13:23:33.723]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.723]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.723]             base::sink(type = "output", split = FALSE)
[13:23:33.723]             base::close(...future.stdout)
[13:23:33.723]         }, add = TRUE)
[13:23:33.723]     }
[13:23:33.723]     ...future.frame <- base::sys.nframe()
[13:23:33.723]     ...future.conditions <- base::list()
[13:23:33.723]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.723]     if (FALSE) {
[13:23:33.723]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.723]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.723]     }
[13:23:33.723]     ...future.result <- base::tryCatch({
[13:23:33.723]         base::withCallingHandlers({
[13:23:33.723]             ...future.value <- base::withVisible(base::local({
[13:23:33.723]                 withCallingHandlers({
[13:23:33.723]                   1
[13:23:33.723]                 }, immediateCondition = function(cond) {
[13:23:33.723]                   save_rds <- function (object, pathname, ...) 
[13:23:33.723]                   {
[13:23:33.723]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:33.723]                     if (file_test("-f", pathname_tmp)) {
[13:23:33.723]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.723]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:33.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.723]                         fi_tmp[["mtime"]])
[13:23:33.723]                     }
[13:23:33.723]                     tryCatch({
[13:23:33.723]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:33.723]                     }, error = function(ex) {
[13:23:33.723]                       msg <- conditionMessage(ex)
[13:23:33.723]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.723]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:33.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.723]                         fi_tmp[["mtime"]], msg)
[13:23:33.723]                       ex$message <- msg
[13:23:33.723]                       stop(ex)
[13:23:33.723]                     })
[13:23:33.723]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:33.723]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:33.723]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:33.723]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.723]                       fi <- file.info(pathname)
[13:23:33.723]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:33.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.723]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:33.723]                         fi[["size"]], fi[["mtime"]])
[13:23:33.723]                       stop(msg)
[13:23:33.723]                     }
[13:23:33.723]                     invisible(pathname)
[13:23:33.723]                   }
[13:23:33.723]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:33.723]                     rootPath = tempdir()) 
[13:23:33.723]                   {
[13:23:33.723]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:33.723]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:33.723]                       tmpdir = path, fileext = ".rds")
[13:23:33.723]                     save_rds(obj, file)
[13:23:33.723]                   }
[13:23:33.723]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:33.723]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.723]                   {
[13:23:33.723]                     inherits <- base::inherits
[13:23:33.723]                     invokeRestart <- base::invokeRestart
[13:23:33.723]                     is.null <- base::is.null
[13:23:33.723]                     muffled <- FALSE
[13:23:33.723]                     if (inherits(cond, "message")) {
[13:23:33.723]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:33.723]                       if (muffled) 
[13:23:33.723]                         invokeRestart("muffleMessage")
[13:23:33.723]                     }
[13:23:33.723]                     else if (inherits(cond, "warning")) {
[13:23:33.723]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:33.723]                       if (muffled) 
[13:23:33.723]                         invokeRestart("muffleWarning")
[13:23:33.723]                     }
[13:23:33.723]                     else if (inherits(cond, "condition")) {
[13:23:33.723]                       if (!is.null(pattern)) {
[13:23:33.723]                         computeRestarts <- base::computeRestarts
[13:23:33.723]                         grepl <- base::grepl
[13:23:33.723]                         restarts <- computeRestarts(cond)
[13:23:33.723]                         for (restart in restarts) {
[13:23:33.723]                           name <- restart$name
[13:23:33.723]                           if (is.null(name)) 
[13:23:33.723]                             next
[13:23:33.723]                           if (!grepl(pattern, name)) 
[13:23:33.723]                             next
[13:23:33.723]                           invokeRestart(restart)
[13:23:33.723]                           muffled <- TRUE
[13:23:33.723]                           break
[13:23:33.723]                         }
[13:23:33.723]                       }
[13:23:33.723]                     }
[13:23:33.723]                     invisible(muffled)
[13:23:33.723]                   }
[13:23:33.723]                   muffleCondition(cond)
[13:23:33.723]                 })
[13:23:33.723]             }))
[13:23:33.723]             future::FutureResult(value = ...future.value$value, 
[13:23:33.723]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.723]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.723]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.723]                     ...future.globalenv.names))
[13:23:33.723]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.723]         }, condition = base::local({
[13:23:33.723]             c <- base::c
[13:23:33.723]             inherits <- base::inherits
[13:23:33.723]             invokeRestart <- base::invokeRestart
[13:23:33.723]             length <- base::length
[13:23:33.723]             list <- base::list
[13:23:33.723]             seq.int <- base::seq.int
[13:23:33.723]             signalCondition <- base::signalCondition
[13:23:33.723]             sys.calls <- base::sys.calls
[13:23:33.723]             `[[` <- base::`[[`
[13:23:33.723]             `+` <- base::`+`
[13:23:33.723]             `<<-` <- base::`<<-`
[13:23:33.723]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.723]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.723]                   3L)]
[13:23:33.723]             }
[13:23:33.723]             function(cond) {
[13:23:33.723]                 is_error <- inherits(cond, "error")
[13:23:33.723]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.723]                   NULL)
[13:23:33.723]                 if (is_error) {
[13:23:33.723]                   sessionInformation <- function() {
[13:23:33.723]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.723]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.723]                       search = base::search(), system = base::Sys.info())
[13:23:33.723]                   }
[13:23:33.723]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.723]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.723]                     cond$call), session = sessionInformation(), 
[13:23:33.723]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.723]                   signalCondition(cond)
[13:23:33.723]                 }
[13:23:33.723]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.723]                 "immediateCondition"))) {
[13:23:33.723]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.723]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.723]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.723]                   if (TRUE && !signal) {
[13:23:33.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.723]                     {
[13:23:33.723]                       inherits <- base::inherits
[13:23:33.723]                       invokeRestart <- base::invokeRestart
[13:23:33.723]                       is.null <- base::is.null
[13:23:33.723]                       muffled <- FALSE
[13:23:33.723]                       if (inherits(cond, "message")) {
[13:23:33.723]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.723]                         if (muffled) 
[13:23:33.723]                           invokeRestart("muffleMessage")
[13:23:33.723]                       }
[13:23:33.723]                       else if (inherits(cond, "warning")) {
[13:23:33.723]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.723]                         if (muffled) 
[13:23:33.723]                           invokeRestart("muffleWarning")
[13:23:33.723]                       }
[13:23:33.723]                       else if (inherits(cond, "condition")) {
[13:23:33.723]                         if (!is.null(pattern)) {
[13:23:33.723]                           computeRestarts <- base::computeRestarts
[13:23:33.723]                           grepl <- base::grepl
[13:23:33.723]                           restarts <- computeRestarts(cond)
[13:23:33.723]                           for (restart in restarts) {
[13:23:33.723]                             name <- restart$name
[13:23:33.723]                             if (is.null(name)) 
[13:23:33.723]                               next
[13:23:33.723]                             if (!grepl(pattern, name)) 
[13:23:33.723]                               next
[13:23:33.723]                             invokeRestart(restart)
[13:23:33.723]                             muffled <- TRUE
[13:23:33.723]                             break
[13:23:33.723]                           }
[13:23:33.723]                         }
[13:23:33.723]                       }
[13:23:33.723]                       invisible(muffled)
[13:23:33.723]                     }
[13:23:33.723]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.723]                   }
[13:23:33.723]                 }
[13:23:33.723]                 else {
[13:23:33.723]                   if (TRUE) {
[13:23:33.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.723]                     {
[13:23:33.723]                       inherits <- base::inherits
[13:23:33.723]                       invokeRestart <- base::invokeRestart
[13:23:33.723]                       is.null <- base::is.null
[13:23:33.723]                       muffled <- FALSE
[13:23:33.723]                       if (inherits(cond, "message")) {
[13:23:33.723]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.723]                         if (muffled) 
[13:23:33.723]                           invokeRestart("muffleMessage")
[13:23:33.723]                       }
[13:23:33.723]                       else if (inherits(cond, "warning")) {
[13:23:33.723]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.723]                         if (muffled) 
[13:23:33.723]                           invokeRestart("muffleWarning")
[13:23:33.723]                       }
[13:23:33.723]                       else if (inherits(cond, "condition")) {
[13:23:33.723]                         if (!is.null(pattern)) {
[13:23:33.723]                           computeRestarts <- base::computeRestarts
[13:23:33.723]                           grepl <- base::grepl
[13:23:33.723]                           restarts <- computeRestarts(cond)
[13:23:33.723]                           for (restart in restarts) {
[13:23:33.723]                             name <- restart$name
[13:23:33.723]                             if (is.null(name)) 
[13:23:33.723]                               next
[13:23:33.723]                             if (!grepl(pattern, name)) 
[13:23:33.723]                               next
[13:23:33.723]                             invokeRestart(restart)
[13:23:33.723]                             muffled <- TRUE
[13:23:33.723]                             break
[13:23:33.723]                           }
[13:23:33.723]                         }
[13:23:33.723]                       }
[13:23:33.723]                       invisible(muffled)
[13:23:33.723]                     }
[13:23:33.723]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.723]                   }
[13:23:33.723]                 }
[13:23:33.723]             }
[13:23:33.723]         }))
[13:23:33.723]     }, error = function(ex) {
[13:23:33.723]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.723]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.723]                 ...future.rng), started = ...future.startTime, 
[13:23:33.723]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.723]             version = "1.8"), class = "FutureResult")
[13:23:33.723]     }, finally = {
[13:23:33.723]         if (!identical(...future.workdir, getwd())) 
[13:23:33.723]             setwd(...future.workdir)
[13:23:33.723]         {
[13:23:33.723]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.723]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.723]             }
[13:23:33.723]             base::options(...future.oldOptions)
[13:23:33.723]             if (.Platform$OS.type == "windows") {
[13:23:33.723]                 old_names <- names(...future.oldEnvVars)
[13:23:33.723]                 envs <- base::Sys.getenv()
[13:23:33.723]                 names <- names(envs)
[13:23:33.723]                 common <- intersect(names, old_names)
[13:23:33.723]                 added <- setdiff(names, old_names)
[13:23:33.723]                 removed <- setdiff(old_names, names)
[13:23:33.723]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.723]                   envs[common]]
[13:23:33.723]                 NAMES <- toupper(changed)
[13:23:33.723]                 args <- list()
[13:23:33.723]                 for (kk in seq_along(NAMES)) {
[13:23:33.723]                   name <- changed[[kk]]
[13:23:33.723]                   NAME <- NAMES[[kk]]
[13:23:33.723]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.723]                     next
[13:23:33.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.723]                 }
[13:23:33.723]                 NAMES <- toupper(added)
[13:23:33.723]                 for (kk in seq_along(NAMES)) {
[13:23:33.723]                   name <- added[[kk]]
[13:23:33.723]                   NAME <- NAMES[[kk]]
[13:23:33.723]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.723]                     next
[13:23:33.723]                   args[[name]] <- ""
[13:23:33.723]                 }
[13:23:33.723]                 NAMES <- toupper(removed)
[13:23:33.723]                 for (kk in seq_along(NAMES)) {
[13:23:33.723]                   name <- removed[[kk]]
[13:23:33.723]                   NAME <- NAMES[[kk]]
[13:23:33.723]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.723]                     next
[13:23:33.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.723]                 }
[13:23:33.723]                 if (length(args) > 0) 
[13:23:33.723]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.723]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.723]             }
[13:23:33.723]             else {
[13:23:33.723]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.723]             }
[13:23:33.723]             {
[13:23:33.723]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.723]                   0L) {
[13:23:33.723]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.723]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.723]                   base::options(opts)
[13:23:33.723]                 }
[13:23:33.723]                 {
[13:23:33.723]                   {
[13:23:33.723]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:33.723]                     NULL
[13:23:33.723]                   }
[13:23:33.723]                   options(future.plan = NULL)
[13:23:33.723]                   if (is.na(NA_character_)) 
[13:23:33.723]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.723]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.723]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.723]                     envir = parent.frame()) 
[13:23:33.723]                   {
[13:23:33.723]                     default_workers <- missing(workers)
[13:23:33.723]                     if (is.function(workers)) 
[13:23:33.723]                       workers <- workers()
[13:23:33.723]                     workers <- structure(as.integer(workers), 
[13:23:33.723]                       class = class(workers))
[13:23:33.723]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.723]                       1L)
[13:23:33.723]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.723]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.723]                       if (default_workers) 
[13:23:33.723]                         supportsMulticore(warn = TRUE)
[13:23:33.723]                       return(sequential(..., envir = envir))
[13:23:33.723]                     }
[13:23:33.723]                     oopts <- options(mc.cores = workers)
[13:23:33.723]                     on.exit(options(oopts))
[13:23:33.723]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.723]                       envir = envir)
[13:23:33.723]                     if (!future$lazy) 
[13:23:33.723]                       future <- run(future)
[13:23:33.723]                     invisible(future)
[13:23:33.723]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.723]                 }
[13:23:33.723]             }
[13:23:33.723]         }
[13:23:33.723]     })
[13:23:33.723]     if (TRUE) {
[13:23:33.723]         base::sink(type = "output", split = FALSE)
[13:23:33.723]         if (TRUE) {
[13:23:33.723]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.723]         }
[13:23:33.723]         else {
[13:23:33.723]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.723]         }
[13:23:33.723]         base::close(...future.stdout)
[13:23:33.723]         ...future.stdout <- NULL
[13:23:33.723]     }
[13:23:33.723]     ...future.result$conditions <- ...future.conditions
[13:23:33.723]     ...future.result$finished <- base::Sys.time()
[13:23:33.723]     ...future.result
[13:23:33.723] }
[13:23:33.725] requestCore(): workers = 2
[13:23:33.728] MulticoreFuture started
[13:23:33.728] - Launch lazy future ... done
[13:23:33.728] run() for ‘MulticoreFuture’ ... done
[13:23:33.729] plan(): Setting new future strategy stack:
[13:23:33.729] List of future strategies:
[13:23:33.729] 1. sequential:
[13:23:33.729]    - args: function (..., envir = parent.frame())
[13:23:33.729]    - tweaked: FALSE
[13:23:33.729]    - call: NULL
[13:23:33.730] plan(): nbrOfWorkers() = 1
[13:23:33.733] plan(): Setting new future strategy stack:
[13:23:33.733] List of future strategies:
[13:23:33.733] 1. multicore:
[13:23:33.733]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:33.733]    - tweaked: FALSE
[13:23:33.733]    - call: plan(strategy)
[13:23:33.738] plan(): nbrOfWorkers() = 2
[13:23:33.739] Future #1
[13:23:33.739] result() for MulticoreFuture ...
[13:23:33.740] result() for MulticoreFuture ...
[13:23:33.740] result() for MulticoreFuture ... done
[13:23:33.741] result() for MulticoreFuture ... done
[13:23:33.741] result() for MulticoreFuture ...
[13:23:33.741] result() for MulticoreFuture ... done
[13:23:33.741] A MulticoreFuture was resolved
[13:23:33.741]  length: 0 (resolved future 1)
[13:23:33.741] resolve() on list ... DONE
[13:23:33.742] - globals: [1] ‘a’
[13:23:33.742] Resolving futures part of globals (recursively) ... DONE
[13:23:33.745] The total size of the 1 globals is 1.57 MiB (1641288 bytes)
[13:23:33.745] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[13:23:33.746] - globals: [1] ‘a’
[13:23:33.746] - packages: [1] ‘future’
[13:23:33.746] getGlobalsAndPackages() ... DONE
[13:23:33.746] run() for ‘Future’ ...
[13:23:33.746] - state: ‘created’
[13:23:33.747] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:33.754] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:33.754] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:33.755]   - Field: ‘label’
[13:23:33.755]   - Field: ‘local’
[13:23:33.755]   - Field: ‘owner’
[13:23:33.755]   - Field: ‘envir’
[13:23:33.755]   - Field: ‘workers’
[13:23:33.755]   - Field: ‘packages’
[13:23:33.755]   - Field: ‘gc’
[13:23:33.756]   - Field: ‘job’
[13:23:33.756]   - Field: ‘conditions’
[13:23:33.756]   - Field: ‘expr’
[13:23:33.756]   - Field: ‘uuid’
[13:23:33.756]   - Field: ‘seed’
[13:23:33.756]   - Field: ‘version’
[13:23:33.757]   - Field: ‘result’
[13:23:33.757]   - Field: ‘asynchronous’
[13:23:33.757]   - Field: ‘calls’
[13:23:33.757]   - Field: ‘globals’
[13:23:33.757]   - Field: ‘stdout’
[13:23:33.757]   - Field: ‘earlySignal’
[13:23:33.757]   - Field: ‘lazy’
[13:23:33.758]   - Field: ‘state’
[13:23:33.758] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:33.758] - Launch lazy future ...
[13:23:33.758] Packages needed by the future expression (n = 1): ‘future’
[13:23:33.759] Packages needed by future strategies (n = 0): <none>
[13:23:33.759] {
[13:23:33.759]     {
[13:23:33.759]         {
[13:23:33.759]             ...future.startTime <- base::Sys.time()
[13:23:33.759]             {
[13:23:33.759]                 {
[13:23:33.759]                   {
[13:23:33.759]                     {
[13:23:33.759]                       {
[13:23:33.759]                         base::local({
[13:23:33.759]                           has_future <- base::requireNamespace("future", 
[13:23:33.759]                             quietly = TRUE)
[13:23:33.759]                           if (has_future) {
[13:23:33.759]                             ns <- base::getNamespace("future")
[13:23:33.759]                             version <- ns[[".package"]][["version"]]
[13:23:33.759]                             if (is.null(version)) 
[13:23:33.759]                               version <- utils::packageVersion("future")
[13:23:33.759]                           }
[13:23:33.759]                           else {
[13:23:33.759]                             version <- NULL
[13:23:33.759]                           }
[13:23:33.759]                           if (!has_future || version < "1.8.0") {
[13:23:33.759]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.759]                               "", base::R.version$version.string), 
[13:23:33.759]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:33.759]                                 base::R.version$platform, 8 * 
[13:23:33.759]                                   base::.Machine$sizeof.pointer), 
[13:23:33.759]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.759]                                 "release", "version")], collapse = " "), 
[13:23:33.759]                               hostname = base::Sys.info()[["nodename"]])
[13:23:33.759]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.759]                               info)
[13:23:33.759]                             info <- base::paste(info, collapse = "; ")
[13:23:33.759]                             if (!has_future) {
[13:23:33.759]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.759]                                 info)
[13:23:33.759]                             }
[13:23:33.759]                             else {
[13:23:33.759]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.759]                                 info, version)
[13:23:33.759]                             }
[13:23:33.759]                             base::stop(msg)
[13:23:33.759]                           }
[13:23:33.759]                         })
[13:23:33.759]                       }
[13:23:33.759]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:33.759]                       base::options(mc.cores = 1L)
[13:23:33.759]                     }
[13:23:33.759]                     base::local({
[13:23:33.759]                       for (pkg in "future") {
[13:23:33.759]                         base::loadNamespace(pkg)
[13:23:33.759]                         base::library(pkg, character.only = TRUE)
[13:23:33.759]                       }
[13:23:33.759]                     })
[13:23:33.759]                   }
[13:23:33.759]                   options(future.plan = NULL)
[13:23:33.759]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.759]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.759]                 }
[13:23:33.759]                 ...future.workdir <- getwd()
[13:23:33.759]             }
[13:23:33.759]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.759]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.759]         }
[13:23:33.759]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.759]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:33.759]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.759]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.759]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.759]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.759]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.759]             base::names(...future.oldOptions))
[13:23:33.759]     }
[13:23:33.759]     if (FALSE) {
[13:23:33.759]     }
[13:23:33.759]     else {
[13:23:33.759]         if (TRUE) {
[13:23:33.759]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.759]                 open = "w")
[13:23:33.759]         }
[13:23:33.759]         else {
[13:23:33.759]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.759]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.759]         }
[13:23:33.759]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.759]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.759]             base::sink(type = "output", split = FALSE)
[13:23:33.759]             base::close(...future.stdout)
[13:23:33.759]         }, add = TRUE)
[13:23:33.759]     }
[13:23:33.759]     ...future.frame <- base::sys.nframe()
[13:23:33.759]     ...future.conditions <- base::list()
[13:23:33.759]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.759]     if (FALSE) {
[13:23:33.759]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.759]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.759]     }
[13:23:33.759]     ...future.result <- base::tryCatch({
[13:23:33.759]         base::withCallingHandlers({
[13:23:33.759]             ...future.value <- base::withVisible(base::local({
[13:23:33.759]                 withCallingHandlers({
[13:23:33.759]                   value(a) + 1
[13:23:33.759]                 }, immediateCondition = function(cond) {
[13:23:33.759]                   save_rds <- function (object, pathname, ...) 
[13:23:33.759]                   {
[13:23:33.759]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:33.759]                     if (file_test("-f", pathname_tmp)) {
[13:23:33.759]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.759]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:33.759]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.759]                         fi_tmp[["mtime"]])
[13:23:33.759]                     }
[13:23:33.759]                     tryCatch({
[13:23:33.759]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:33.759]                     }, error = function(ex) {
[13:23:33.759]                       msg <- conditionMessage(ex)
[13:23:33.759]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.759]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:33.759]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.759]                         fi_tmp[["mtime"]], msg)
[13:23:33.759]                       ex$message <- msg
[13:23:33.759]                       stop(ex)
[13:23:33.759]                     })
[13:23:33.759]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:33.759]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:33.759]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:33.759]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.759]                       fi <- file.info(pathname)
[13:23:33.759]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:33.759]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.759]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:33.759]                         fi[["size"]], fi[["mtime"]])
[13:23:33.759]                       stop(msg)
[13:23:33.759]                     }
[13:23:33.759]                     invisible(pathname)
[13:23:33.759]                   }
[13:23:33.759]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:33.759]                     rootPath = tempdir()) 
[13:23:33.759]                   {
[13:23:33.759]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:33.759]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:33.759]                       tmpdir = path, fileext = ".rds")
[13:23:33.759]                     save_rds(obj, file)
[13:23:33.759]                   }
[13:23:33.759]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:33.759]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.759]                   {
[13:23:33.759]                     inherits <- base::inherits
[13:23:33.759]                     invokeRestart <- base::invokeRestart
[13:23:33.759]                     is.null <- base::is.null
[13:23:33.759]                     muffled <- FALSE
[13:23:33.759]                     if (inherits(cond, "message")) {
[13:23:33.759]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:33.759]                       if (muffled) 
[13:23:33.759]                         invokeRestart("muffleMessage")
[13:23:33.759]                     }
[13:23:33.759]                     else if (inherits(cond, "warning")) {
[13:23:33.759]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:33.759]                       if (muffled) 
[13:23:33.759]                         invokeRestart("muffleWarning")
[13:23:33.759]                     }
[13:23:33.759]                     else if (inherits(cond, "condition")) {
[13:23:33.759]                       if (!is.null(pattern)) {
[13:23:33.759]                         computeRestarts <- base::computeRestarts
[13:23:33.759]                         grepl <- base::grepl
[13:23:33.759]                         restarts <- computeRestarts(cond)
[13:23:33.759]                         for (restart in restarts) {
[13:23:33.759]                           name <- restart$name
[13:23:33.759]                           if (is.null(name)) 
[13:23:33.759]                             next
[13:23:33.759]                           if (!grepl(pattern, name)) 
[13:23:33.759]                             next
[13:23:33.759]                           invokeRestart(restart)
[13:23:33.759]                           muffled <- TRUE
[13:23:33.759]                           break
[13:23:33.759]                         }
[13:23:33.759]                       }
[13:23:33.759]                     }
[13:23:33.759]                     invisible(muffled)
[13:23:33.759]                   }
[13:23:33.759]                   muffleCondition(cond)
[13:23:33.759]                 })
[13:23:33.759]             }))
[13:23:33.759]             future::FutureResult(value = ...future.value$value, 
[13:23:33.759]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.759]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.759]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.759]                     ...future.globalenv.names))
[13:23:33.759]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.759]         }, condition = base::local({
[13:23:33.759]             c <- base::c
[13:23:33.759]             inherits <- base::inherits
[13:23:33.759]             invokeRestart <- base::invokeRestart
[13:23:33.759]             length <- base::length
[13:23:33.759]             list <- base::list
[13:23:33.759]             seq.int <- base::seq.int
[13:23:33.759]             signalCondition <- base::signalCondition
[13:23:33.759]             sys.calls <- base::sys.calls
[13:23:33.759]             `[[` <- base::`[[`
[13:23:33.759]             `+` <- base::`+`
[13:23:33.759]             `<<-` <- base::`<<-`
[13:23:33.759]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.759]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.759]                   3L)]
[13:23:33.759]             }
[13:23:33.759]             function(cond) {
[13:23:33.759]                 is_error <- inherits(cond, "error")
[13:23:33.759]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.759]                   NULL)
[13:23:33.759]                 if (is_error) {
[13:23:33.759]                   sessionInformation <- function() {
[13:23:33.759]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.759]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.759]                       search = base::search(), system = base::Sys.info())
[13:23:33.759]                   }
[13:23:33.759]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.759]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.759]                     cond$call), session = sessionInformation(), 
[13:23:33.759]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.759]                   signalCondition(cond)
[13:23:33.759]                 }
[13:23:33.759]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.759]                 "immediateCondition"))) {
[13:23:33.759]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.759]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.759]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.759]                   if (TRUE && !signal) {
[13:23:33.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.759]                     {
[13:23:33.759]                       inherits <- base::inherits
[13:23:33.759]                       invokeRestart <- base::invokeRestart
[13:23:33.759]                       is.null <- base::is.null
[13:23:33.759]                       muffled <- FALSE
[13:23:33.759]                       if (inherits(cond, "message")) {
[13:23:33.759]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.759]                         if (muffled) 
[13:23:33.759]                           invokeRestart("muffleMessage")
[13:23:33.759]                       }
[13:23:33.759]                       else if (inherits(cond, "warning")) {
[13:23:33.759]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.759]                         if (muffled) 
[13:23:33.759]                           invokeRestart("muffleWarning")
[13:23:33.759]                       }
[13:23:33.759]                       else if (inherits(cond, "condition")) {
[13:23:33.759]                         if (!is.null(pattern)) {
[13:23:33.759]                           computeRestarts <- base::computeRestarts
[13:23:33.759]                           grepl <- base::grepl
[13:23:33.759]                           restarts <- computeRestarts(cond)
[13:23:33.759]                           for (restart in restarts) {
[13:23:33.759]                             name <- restart$name
[13:23:33.759]                             if (is.null(name)) 
[13:23:33.759]                               next
[13:23:33.759]                             if (!grepl(pattern, name)) 
[13:23:33.759]                               next
[13:23:33.759]                             invokeRestart(restart)
[13:23:33.759]                             muffled <- TRUE
[13:23:33.759]                             break
[13:23:33.759]                           }
[13:23:33.759]                         }
[13:23:33.759]                       }
[13:23:33.759]                       invisible(muffled)
[13:23:33.759]                     }
[13:23:33.759]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.759]                   }
[13:23:33.759]                 }
[13:23:33.759]                 else {
[13:23:33.759]                   if (TRUE) {
[13:23:33.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.759]                     {
[13:23:33.759]                       inherits <- base::inherits
[13:23:33.759]                       invokeRestart <- base::invokeRestart
[13:23:33.759]                       is.null <- base::is.null
[13:23:33.759]                       muffled <- FALSE
[13:23:33.759]                       if (inherits(cond, "message")) {
[13:23:33.759]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.759]                         if (muffled) 
[13:23:33.759]                           invokeRestart("muffleMessage")
[13:23:33.759]                       }
[13:23:33.759]                       else if (inherits(cond, "warning")) {
[13:23:33.759]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.759]                         if (muffled) 
[13:23:33.759]                           invokeRestart("muffleWarning")
[13:23:33.759]                       }
[13:23:33.759]                       else if (inherits(cond, "condition")) {
[13:23:33.759]                         if (!is.null(pattern)) {
[13:23:33.759]                           computeRestarts <- base::computeRestarts
[13:23:33.759]                           grepl <- base::grepl
[13:23:33.759]                           restarts <- computeRestarts(cond)
[13:23:33.759]                           for (restart in restarts) {
[13:23:33.759]                             name <- restart$name
[13:23:33.759]                             if (is.null(name)) 
[13:23:33.759]                               next
[13:23:33.759]                             if (!grepl(pattern, name)) 
[13:23:33.759]                               next
[13:23:33.759]                             invokeRestart(restart)
[13:23:33.759]                             muffled <- TRUE
[13:23:33.759]                             break
[13:23:33.759]                           }
[13:23:33.759]                         }
[13:23:33.759]                       }
[13:23:33.759]                       invisible(muffled)
[13:23:33.759]                     }
[13:23:33.759]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.759]                   }
[13:23:33.759]                 }
[13:23:33.759]             }
[13:23:33.759]         }))
[13:23:33.759]     }, error = function(ex) {
[13:23:33.759]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.759]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.759]                 ...future.rng), started = ...future.startTime, 
[13:23:33.759]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.759]             version = "1.8"), class = "FutureResult")
[13:23:33.759]     }, finally = {
[13:23:33.759]         if (!identical(...future.workdir, getwd())) 
[13:23:33.759]             setwd(...future.workdir)
[13:23:33.759]         {
[13:23:33.759]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.759]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.759]             }
[13:23:33.759]             base::options(...future.oldOptions)
[13:23:33.759]             if (.Platform$OS.type == "windows") {
[13:23:33.759]                 old_names <- names(...future.oldEnvVars)
[13:23:33.759]                 envs <- base::Sys.getenv()
[13:23:33.759]                 names <- names(envs)
[13:23:33.759]                 common <- intersect(names, old_names)
[13:23:33.759]                 added <- setdiff(names, old_names)
[13:23:33.759]                 removed <- setdiff(old_names, names)
[13:23:33.759]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.759]                   envs[common]]
[13:23:33.759]                 NAMES <- toupper(changed)
[13:23:33.759]                 args <- list()
[13:23:33.759]                 for (kk in seq_along(NAMES)) {
[13:23:33.759]                   name <- changed[[kk]]
[13:23:33.759]                   NAME <- NAMES[[kk]]
[13:23:33.759]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.759]                     next
[13:23:33.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.759]                 }
[13:23:33.759]                 NAMES <- toupper(added)
[13:23:33.759]                 for (kk in seq_along(NAMES)) {
[13:23:33.759]                   name <- added[[kk]]
[13:23:33.759]                   NAME <- NAMES[[kk]]
[13:23:33.759]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.759]                     next
[13:23:33.759]                   args[[name]] <- ""
[13:23:33.759]                 }
[13:23:33.759]                 NAMES <- toupper(removed)
[13:23:33.759]                 for (kk in seq_along(NAMES)) {
[13:23:33.759]                   name <- removed[[kk]]
[13:23:33.759]                   NAME <- NAMES[[kk]]
[13:23:33.759]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.759]                     next
[13:23:33.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.759]                 }
[13:23:33.759]                 if (length(args) > 0) 
[13:23:33.759]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.759]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.759]             }
[13:23:33.759]             else {
[13:23:33.759]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.759]             }
[13:23:33.759]             {
[13:23:33.759]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.759]                   0L) {
[13:23:33.759]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.759]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.759]                   base::options(opts)
[13:23:33.759]                 }
[13:23:33.759]                 {
[13:23:33.759]                   {
[13:23:33.759]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:33.759]                     NULL
[13:23:33.759]                   }
[13:23:33.759]                   options(future.plan = NULL)
[13:23:33.759]                   if (is.na(NA_character_)) 
[13:23:33.759]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.759]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.759]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.759]                     envir = parent.frame()) 
[13:23:33.759]                   {
[13:23:33.759]                     default_workers <- missing(workers)
[13:23:33.759]                     if (is.function(workers)) 
[13:23:33.759]                       workers <- workers()
[13:23:33.759]                     workers <- structure(as.integer(workers), 
[13:23:33.759]                       class = class(workers))
[13:23:33.759]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.759]                       1L)
[13:23:33.759]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.759]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.759]                       if (default_workers) 
[13:23:33.759]                         supportsMulticore(warn = TRUE)
[13:23:33.759]                       return(sequential(..., envir = envir))
[13:23:33.759]                     }
[13:23:33.759]                     oopts <- options(mc.cores = workers)
[13:23:33.759]                     on.exit(options(oopts))
[13:23:33.759]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.759]                       envir = envir)
[13:23:33.759]                     if (!future$lazy) 
[13:23:33.759]                       future <- run(future)
[13:23:33.759]                     invisible(future)
[13:23:33.759]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.759]                 }
[13:23:33.759]             }
[13:23:33.759]         }
[13:23:33.759]     })
[13:23:33.759]     if (TRUE) {
[13:23:33.759]         base::sink(type = "output", split = FALSE)
[13:23:33.759]         if (TRUE) {
[13:23:33.759]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.759]         }
[13:23:33.759]         else {
[13:23:33.759]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.759]         }
[13:23:33.759]         base::close(...future.stdout)
[13:23:33.759]         ...future.stdout <- NULL
[13:23:33.759]     }
[13:23:33.759]     ...future.result$conditions <- ...future.conditions
[13:23:33.759]     ...future.result$finished <- base::Sys.time()
[13:23:33.759]     ...future.result
[13:23:33.759] }
[13:23:33.762] assign_globals() ...
[13:23:33.762] List of 1
[13:23:33.762]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5589bf5d7520> 
[13:23:33.762]  - attr(*, "where")=List of 1
[13:23:33.762]   ..$ a:<environment: R_EmptyEnv> 
[13:23:33.762]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:33.762]  - attr(*, "resolved")= logi TRUE
[13:23:33.762]  - attr(*, "total_size")= num 1641288
[13:23:33.762]  - attr(*, "already-done")= logi TRUE
[13:23:33.766] - copied ‘a’ to environment
[13:23:33.766] assign_globals() ... done
[13:23:33.766] requestCore(): workers = 2
[13:23:33.768] MulticoreFuture started
[13:23:33.769] - Launch lazy future ... done
[13:23:33.769] run() for ‘MulticoreFuture’ ... done
[13:23:33.770] result() for MulticoreFuture ...
[13:23:33.770] plan(): Setting new future strategy stack:
[13:23:33.770] List of future strategies:
[13:23:33.770] 1. sequential:
[13:23:33.770]    - args: function (..., envir = parent.frame())
[13:23:33.770]    - tweaked: FALSE
[13:23:33.770]    - call: NULL
[13:23:33.771] plan(): nbrOfWorkers() = 1
[13:23:33.775] plan(): Setting new future strategy stack:
[13:23:33.775] List of future strategies:
[13:23:33.775] 1. multicore:
[13:23:33.775]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:33.775]    - tweaked: FALSE
[13:23:33.775]    - call: plan(strategy)
[13:23:33.780] plan(): nbrOfWorkers() = 2
[13:23:33.781] result() for MulticoreFuture ...
[13:23:33.781] result() for MulticoreFuture ... done
[13:23:33.781] signalConditions() ...
[13:23:33.782]  - include = ‘immediateCondition’
[13:23:33.782]  - exclude = 
[13:23:33.782]  - resignal = FALSE
[13:23:33.782]  - Number of conditions: 4
[13:23:33.782] signalConditions() ... done
[13:23:33.782] result() for MulticoreFuture ... done
[13:23:33.782] result() for MulticoreFuture ...
[13:23:33.783] result() for MulticoreFuture ... done
[13:23:33.783] signalConditions() ...
[13:23:33.783]  - include = ‘immediateCondition’
[13:23:33.783]  - exclude = 
[13:23:33.783]  - resignal = FALSE
[13:23:33.783]  - Number of conditions: 4
[13:23:33.783] signalConditions() ... done
[13:23:33.783] Future state: ‘finished’
[13:23:33.784] result() for MulticoreFuture ...
[13:23:33.784] result() for MulticoreFuture ... done
[13:23:33.784] signalConditions() ...
[13:23:33.784]  - include = ‘condition’
[13:23:33.784]  - exclude = ‘immediateCondition’
[13:23:33.784]  - resignal = TRUE
[13:23:33.784]  - Number of conditions: 4
[13:23:33.784]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.773] result() for MulticoreFuture ...
[13:23:33.785]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.773] result() for MulticoreFuture ... done
[13:23:33.785]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.773] result() for MulticoreFuture ...
[13:23:33.785]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.773] result() for MulticoreFuture ... done
[13:23:33.785] signalConditions() ... done
value(b) = 2
[13:23:33.785] result() for MulticoreFuture ...
[13:23:33.786] result() for MulticoreFuture ... done
[13:23:33.786] result() for MulticoreFuture ...
[13:23:33.786] result() for MulticoreFuture ... done
[13:23:33.786] signalConditions() ...
[13:23:33.786]  - include = ‘immediateCondition’
[13:23:33.786]  - exclude = 
[13:23:33.786]  - resignal = FALSE
[13:23:33.786]  - Number of conditions: 4
[13:23:33.786] signalConditions() ... done
[13:23:33.787] Future state: ‘finished’
[13:23:33.787] result() for MulticoreFuture ...
[13:23:33.787] result() for MulticoreFuture ... done
[13:23:33.787] signalConditions() ...
[13:23:33.787]  - include = ‘condition’
[13:23:33.787]  - exclude = ‘immediateCondition’
[13:23:33.787]  - resignal = TRUE
[13:23:33.787]  - Number of conditions: 4
[13:23:33.787]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.773] result() for MulticoreFuture ...
[13:23:33.788]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.773] result() for MulticoreFuture ... done
[13:23:33.788]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.773] result() for MulticoreFuture ...
[13:23:33.788]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.773] result() for MulticoreFuture ... done
[13:23:33.788] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:33.789] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:33.789] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:33.789] 
[13:23:33.789] Searching for globals ... DONE
[13:23:33.790] - globals: [0] <none>
[13:23:33.790] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:33.790] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:33.790] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:33.791] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:33.792] Searching for globals ... DONE
[13:23:33.792] Resolving globals: TRUE
[13:23:33.792] Resolving any globals that are futures ...
[13:23:33.792] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:33.792] Resolving any globals that are futures ... DONE
[13:23:33.793] Resolving futures part of globals (recursively) ...
[13:23:33.793] resolve() on list ...
[13:23:33.793]  recursive: 99
[13:23:33.793]  length: 1
[13:23:33.793]  elements: ‘a’
[13:23:33.793] run() for ‘Future’ ...
[13:23:33.794] - state: ‘created’
[13:23:33.794] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:33.801] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:33.802] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:33.802]   - Field: ‘label’
[13:23:33.802]   - Field: ‘local’
[13:23:33.802]   - Field: ‘owner’
[13:23:33.802]   - Field: ‘envir’
[13:23:33.802]   - Field: ‘workers’
[13:23:33.803]   - Field: ‘packages’
[13:23:33.803]   - Field: ‘gc’
[13:23:33.803]   - Field: ‘job’
[13:23:33.803]   - Field: ‘conditions’
[13:23:33.803]   - Field: ‘expr’
[13:23:33.803]   - Field: ‘uuid’
[13:23:33.803]   - Field: ‘seed’
[13:23:33.804]   - Field: ‘version’
[13:23:33.804]   - Field: ‘result’
[13:23:33.804]   - Field: ‘asynchronous’
[13:23:33.804]   - Field: ‘calls’
[13:23:33.804]   - Field: ‘globals’
[13:23:33.804]   - Field: ‘stdout’
[13:23:33.804]   - Field: ‘earlySignal’
[13:23:33.805]   - Field: ‘lazy’
[13:23:33.805]   - Field: ‘state’
[13:23:33.805] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:33.805] - Launch lazy future ...
[13:23:33.806] Packages needed by the future expression (n = 0): <none>
[13:23:33.806] Packages needed by future strategies (n = 0): <none>
[13:23:33.806] {
[13:23:33.806]     {
[13:23:33.806]         {
[13:23:33.806]             ...future.startTime <- base::Sys.time()
[13:23:33.806]             {
[13:23:33.806]                 {
[13:23:33.806]                   {
[13:23:33.806]                     {
[13:23:33.806]                       base::local({
[13:23:33.806]                         has_future <- base::requireNamespace("future", 
[13:23:33.806]                           quietly = TRUE)
[13:23:33.806]                         if (has_future) {
[13:23:33.806]                           ns <- base::getNamespace("future")
[13:23:33.806]                           version <- ns[[".package"]][["version"]]
[13:23:33.806]                           if (is.null(version)) 
[13:23:33.806]                             version <- utils::packageVersion("future")
[13:23:33.806]                         }
[13:23:33.806]                         else {
[13:23:33.806]                           version <- NULL
[13:23:33.806]                         }
[13:23:33.806]                         if (!has_future || version < "1.8.0") {
[13:23:33.806]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.806]                             "", base::R.version$version.string), 
[13:23:33.806]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:33.806]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:33.806]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.806]                               "release", "version")], collapse = " "), 
[13:23:33.806]                             hostname = base::Sys.info()[["nodename"]])
[13:23:33.806]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.806]                             info)
[13:23:33.806]                           info <- base::paste(info, collapse = "; ")
[13:23:33.806]                           if (!has_future) {
[13:23:33.806]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.806]                               info)
[13:23:33.806]                           }
[13:23:33.806]                           else {
[13:23:33.806]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.806]                               info, version)
[13:23:33.806]                           }
[13:23:33.806]                           base::stop(msg)
[13:23:33.806]                         }
[13:23:33.806]                       })
[13:23:33.806]                     }
[13:23:33.806]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:33.806]                     base::options(mc.cores = 1L)
[13:23:33.806]                   }
[13:23:33.806]                   options(future.plan = NULL)
[13:23:33.806]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.806]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.806]                 }
[13:23:33.806]                 ...future.workdir <- getwd()
[13:23:33.806]             }
[13:23:33.806]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.806]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.806]         }
[13:23:33.806]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.806]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:33.806]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.806]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.806]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.806]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.806]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.806]             base::names(...future.oldOptions))
[13:23:33.806]     }
[13:23:33.806]     if (FALSE) {
[13:23:33.806]     }
[13:23:33.806]     else {
[13:23:33.806]         if (TRUE) {
[13:23:33.806]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.806]                 open = "w")
[13:23:33.806]         }
[13:23:33.806]         else {
[13:23:33.806]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.806]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.806]         }
[13:23:33.806]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.806]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.806]             base::sink(type = "output", split = FALSE)
[13:23:33.806]             base::close(...future.stdout)
[13:23:33.806]         }, add = TRUE)
[13:23:33.806]     }
[13:23:33.806]     ...future.frame <- base::sys.nframe()
[13:23:33.806]     ...future.conditions <- base::list()
[13:23:33.806]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.806]     if (FALSE) {
[13:23:33.806]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.806]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.806]     }
[13:23:33.806]     ...future.result <- base::tryCatch({
[13:23:33.806]         base::withCallingHandlers({
[13:23:33.806]             ...future.value <- base::withVisible(base::local({
[13:23:33.806]                 withCallingHandlers({
[13:23:33.806]                   1
[13:23:33.806]                 }, immediateCondition = function(cond) {
[13:23:33.806]                   save_rds <- function (object, pathname, ...) 
[13:23:33.806]                   {
[13:23:33.806]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:33.806]                     if (file_test("-f", pathname_tmp)) {
[13:23:33.806]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.806]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:33.806]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.806]                         fi_tmp[["mtime"]])
[13:23:33.806]                     }
[13:23:33.806]                     tryCatch({
[13:23:33.806]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:33.806]                     }, error = function(ex) {
[13:23:33.806]                       msg <- conditionMessage(ex)
[13:23:33.806]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.806]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:33.806]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.806]                         fi_tmp[["mtime"]], msg)
[13:23:33.806]                       ex$message <- msg
[13:23:33.806]                       stop(ex)
[13:23:33.806]                     })
[13:23:33.806]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:33.806]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:33.806]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:33.806]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.806]                       fi <- file.info(pathname)
[13:23:33.806]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:33.806]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.806]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:33.806]                         fi[["size"]], fi[["mtime"]])
[13:23:33.806]                       stop(msg)
[13:23:33.806]                     }
[13:23:33.806]                     invisible(pathname)
[13:23:33.806]                   }
[13:23:33.806]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:33.806]                     rootPath = tempdir()) 
[13:23:33.806]                   {
[13:23:33.806]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:33.806]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:33.806]                       tmpdir = path, fileext = ".rds")
[13:23:33.806]                     save_rds(obj, file)
[13:23:33.806]                   }
[13:23:33.806]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:33.806]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.806]                   {
[13:23:33.806]                     inherits <- base::inherits
[13:23:33.806]                     invokeRestart <- base::invokeRestart
[13:23:33.806]                     is.null <- base::is.null
[13:23:33.806]                     muffled <- FALSE
[13:23:33.806]                     if (inherits(cond, "message")) {
[13:23:33.806]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:33.806]                       if (muffled) 
[13:23:33.806]                         invokeRestart("muffleMessage")
[13:23:33.806]                     }
[13:23:33.806]                     else if (inherits(cond, "warning")) {
[13:23:33.806]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:33.806]                       if (muffled) 
[13:23:33.806]                         invokeRestart("muffleWarning")
[13:23:33.806]                     }
[13:23:33.806]                     else if (inherits(cond, "condition")) {
[13:23:33.806]                       if (!is.null(pattern)) {
[13:23:33.806]                         computeRestarts <- base::computeRestarts
[13:23:33.806]                         grepl <- base::grepl
[13:23:33.806]                         restarts <- computeRestarts(cond)
[13:23:33.806]                         for (restart in restarts) {
[13:23:33.806]                           name <- restart$name
[13:23:33.806]                           if (is.null(name)) 
[13:23:33.806]                             next
[13:23:33.806]                           if (!grepl(pattern, name)) 
[13:23:33.806]                             next
[13:23:33.806]                           invokeRestart(restart)
[13:23:33.806]                           muffled <- TRUE
[13:23:33.806]                           break
[13:23:33.806]                         }
[13:23:33.806]                       }
[13:23:33.806]                     }
[13:23:33.806]                     invisible(muffled)
[13:23:33.806]                   }
[13:23:33.806]                   muffleCondition(cond)
[13:23:33.806]                 })
[13:23:33.806]             }))
[13:23:33.806]             future::FutureResult(value = ...future.value$value, 
[13:23:33.806]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.806]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.806]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.806]                     ...future.globalenv.names))
[13:23:33.806]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.806]         }, condition = base::local({
[13:23:33.806]             c <- base::c
[13:23:33.806]             inherits <- base::inherits
[13:23:33.806]             invokeRestart <- base::invokeRestart
[13:23:33.806]             length <- base::length
[13:23:33.806]             list <- base::list
[13:23:33.806]             seq.int <- base::seq.int
[13:23:33.806]             signalCondition <- base::signalCondition
[13:23:33.806]             sys.calls <- base::sys.calls
[13:23:33.806]             `[[` <- base::`[[`
[13:23:33.806]             `+` <- base::`+`
[13:23:33.806]             `<<-` <- base::`<<-`
[13:23:33.806]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.806]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.806]                   3L)]
[13:23:33.806]             }
[13:23:33.806]             function(cond) {
[13:23:33.806]                 is_error <- inherits(cond, "error")
[13:23:33.806]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.806]                   NULL)
[13:23:33.806]                 if (is_error) {
[13:23:33.806]                   sessionInformation <- function() {
[13:23:33.806]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.806]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.806]                       search = base::search(), system = base::Sys.info())
[13:23:33.806]                   }
[13:23:33.806]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.806]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.806]                     cond$call), session = sessionInformation(), 
[13:23:33.806]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.806]                   signalCondition(cond)
[13:23:33.806]                 }
[13:23:33.806]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.806]                 "immediateCondition"))) {
[13:23:33.806]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.806]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.806]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.806]                   if (TRUE && !signal) {
[13:23:33.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.806]                     {
[13:23:33.806]                       inherits <- base::inherits
[13:23:33.806]                       invokeRestart <- base::invokeRestart
[13:23:33.806]                       is.null <- base::is.null
[13:23:33.806]                       muffled <- FALSE
[13:23:33.806]                       if (inherits(cond, "message")) {
[13:23:33.806]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.806]                         if (muffled) 
[13:23:33.806]                           invokeRestart("muffleMessage")
[13:23:33.806]                       }
[13:23:33.806]                       else if (inherits(cond, "warning")) {
[13:23:33.806]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.806]                         if (muffled) 
[13:23:33.806]                           invokeRestart("muffleWarning")
[13:23:33.806]                       }
[13:23:33.806]                       else if (inherits(cond, "condition")) {
[13:23:33.806]                         if (!is.null(pattern)) {
[13:23:33.806]                           computeRestarts <- base::computeRestarts
[13:23:33.806]                           grepl <- base::grepl
[13:23:33.806]                           restarts <- computeRestarts(cond)
[13:23:33.806]                           for (restart in restarts) {
[13:23:33.806]                             name <- restart$name
[13:23:33.806]                             if (is.null(name)) 
[13:23:33.806]                               next
[13:23:33.806]                             if (!grepl(pattern, name)) 
[13:23:33.806]                               next
[13:23:33.806]                             invokeRestart(restart)
[13:23:33.806]                             muffled <- TRUE
[13:23:33.806]                             break
[13:23:33.806]                           }
[13:23:33.806]                         }
[13:23:33.806]                       }
[13:23:33.806]                       invisible(muffled)
[13:23:33.806]                     }
[13:23:33.806]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.806]                   }
[13:23:33.806]                 }
[13:23:33.806]                 else {
[13:23:33.806]                   if (TRUE) {
[13:23:33.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.806]                     {
[13:23:33.806]                       inherits <- base::inherits
[13:23:33.806]                       invokeRestart <- base::invokeRestart
[13:23:33.806]                       is.null <- base::is.null
[13:23:33.806]                       muffled <- FALSE
[13:23:33.806]                       if (inherits(cond, "message")) {
[13:23:33.806]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.806]                         if (muffled) 
[13:23:33.806]                           invokeRestart("muffleMessage")
[13:23:33.806]                       }
[13:23:33.806]                       else if (inherits(cond, "warning")) {
[13:23:33.806]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.806]                         if (muffled) 
[13:23:33.806]                           invokeRestart("muffleWarning")
[13:23:33.806]                       }
[13:23:33.806]                       else if (inherits(cond, "condition")) {
[13:23:33.806]                         if (!is.null(pattern)) {
[13:23:33.806]                           computeRestarts <- base::computeRestarts
[13:23:33.806]                           grepl <- base::grepl
[13:23:33.806]                           restarts <- computeRestarts(cond)
[13:23:33.806]                           for (restart in restarts) {
[13:23:33.806]                             name <- restart$name
[13:23:33.806]                             if (is.null(name)) 
[13:23:33.806]                               next
[13:23:33.806]                             if (!grepl(pattern, name)) 
[13:23:33.806]                               next
[13:23:33.806]                             invokeRestart(restart)
[13:23:33.806]                             muffled <- TRUE
[13:23:33.806]                             break
[13:23:33.806]                           }
[13:23:33.806]                         }
[13:23:33.806]                       }
[13:23:33.806]                       invisible(muffled)
[13:23:33.806]                     }
[13:23:33.806]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.806]                   }
[13:23:33.806]                 }
[13:23:33.806]             }
[13:23:33.806]         }))
[13:23:33.806]     }, error = function(ex) {
[13:23:33.806]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.806]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.806]                 ...future.rng), started = ...future.startTime, 
[13:23:33.806]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.806]             version = "1.8"), class = "FutureResult")
[13:23:33.806]     }, finally = {
[13:23:33.806]         if (!identical(...future.workdir, getwd())) 
[13:23:33.806]             setwd(...future.workdir)
[13:23:33.806]         {
[13:23:33.806]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.806]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.806]             }
[13:23:33.806]             base::options(...future.oldOptions)
[13:23:33.806]             if (.Platform$OS.type == "windows") {
[13:23:33.806]                 old_names <- names(...future.oldEnvVars)
[13:23:33.806]                 envs <- base::Sys.getenv()
[13:23:33.806]                 names <- names(envs)
[13:23:33.806]                 common <- intersect(names, old_names)
[13:23:33.806]                 added <- setdiff(names, old_names)
[13:23:33.806]                 removed <- setdiff(old_names, names)
[13:23:33.806]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.806]                   envs[common]]
[13:23:33.806]                 NAMES <- toupper(changed)
[13:23:33.806]                 args <- list()
[13:23:33.806]                 for (kk in seq_along(NAMES)) {
[13:23:33.806]                   name <- changed[[kk]]
[13:23:33.806]                   NAME <- NAMES[[kk]]
[13:23:33.806]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.806]                     next
[13:23:33.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.806]                 }
[13:23:33.806]                 NAMES <- toupper(added)
[13:23:33.806]                 for (kk in seq_along(NAMES)) {
[13:23:33.806]                   name <- added[[kk]]
[13:23:33.806]                   NAME <- NAMES[[kk]]
[13:23:33.806]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.806]                     next
[13:23:33.806]                   args[[name]] <- ""
[13:23:33.806]                 }
[13:23:33.806]                 NAMES <- toupper(removed)
[13:23:33.806]                 for (kk in seq_along(NAMES)) {
[13:23:33.806]                   name <- removed[[kk]]
[13:23:33.806]                   NAME <- NAMES[[kk]]
[13:23:33.806]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.806]                     next
[13:23:33.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.806]                 }
[13:23:33.806]                 if (length(args) > 0) 
[13:23:33.806]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.806]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.806]             }
[13:23:33.806]             else {
[13:23:33.806]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.806]             }
[13:23:33.806]             {
[13:23:33.806]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.806]                   0L) {
[13:23:33.806]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.806]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.806]                   base::options(opts)
[13:23:33.806]                 }
[13:23:33.806]                 {
[13:23:33.806]                   {
[13:23:33.806]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:33.806]                     NULL
[13:23:33.806]                   }
[13:23:33.806]                   options(future.plan = NULL)
[13:23:33.806]                   if (is.na(NA_character_)) 
[13:23:33.806]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.806]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.806]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.806]                     envir = parent.frame()) 
[13:23:33.806]                   {
[13:23:33.806]                     default_workers <- missing(workers)
[13:23:33.806]                     if (is.function(workers)) 
[13:23:33.806]                       workers <- workers()
[13:23:33.806]                     workers <- structure(as.integer(workers), 
[13:23:33.806]                       class = class(workers))
[13:23:33.806]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.806]                       1L)
[13:23:33.806]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.806]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.806]                       if (default_workers) 
[13:23:33.806]                         supportsMulticore(warn = TRUE)
[13:23:33.806]                       return(sequential(..., envir = envir))
[13:23:33.806]                     }
[13:23:33.806]                     oopts <- options(mc.cores = workers)
[13:23:33.806]                     on.exit(options(oopts))
[13:23:33.806]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.806]                       envir = envir)
[13:23:33.806]                     if (!future$lazy) 
[13:23:33.806]                       future <- run(future)
[13:23:33.806]                     invisible(future)
[13:23:33.806]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.806]                 }
[13:23:33.806]             }
[13:23:33.806]         }
[13:23:33.806]     })
[13:23:33.806]     if (TRUE) {
[13:23:33.806]         base::sink(type = "output", split = FALSE)
[13:23:33.806]         if (TRUE) {
[13:23:33.806]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.806]         }
[13:23:33.806]         else {
[13:23:33.806]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.806]         }
[13:23:33.806]         base::close(...future.stdout)
[13:23:33.806]         ...future.stdout <- NULL
[13:23:33.806]     }
[13:23:33.806]     ...future.result$conditions <- ...future.conditions
[13:23:33.806]     ...future.result$finished <- base::Sys.time()
[13:23:33.806]     ...future.result
[13:23:33.806] }
[13:23:33.809] requestCore(): workers = 2
[13:23:33.812] MulticoreFuture started
[13:23:33.813] - Launch lazy future ... done
[13:23:33.813] run() for ‘MulticoreFuture’ ... done
[13:23:33.813] plan(): Setting new future strategy stack:
[13:23:33.814] List of future strategies:
[13:23:33.814] 1. sequential:
[13:23:33.814]    - args: function (..., envir = parent.frame())
[13:23:33.814]    - tweaked: FALSE
[13:23:33.814]    - call: NULL
[13:23:33.815] plan(): nbrOfWorkers() = 1
[13:23:33.817] plan(): Setting new future strategy stack:
[13:23:33.818] List of future strategies:
[13:23:33.818] 1. multicore:
[13:23:33.818]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:33.818]    - tweaked: FALSE
[13:23:33.818]    - call: plan(strategy)
[13:23:33.824] plan(): nbrOfWorkers() = 2
[13:23:33.835] Future #1
[13:23:33.835] result() for MulticoreFuture ...
[13:23:33.836] result() for MulticoreFuture ...
[13:23:33.836] result() for MulticoreFuture ... done
[13:23:33.837] result() for MulticoreFuture ... done
[13:23:33.837] result() for MulticoreFuture ...
[13:23:33.837] result() for MulticoreFuture ... done
[13:23:33.837] A MulticoreFuture was resolved
[13:23:33.837]  length: 0 (resolved future 1)
[13:23:33.838] resolve() on list ... DONE
[13:23:33.838] - globals: [1] ‘a’
[13:23:33.838] Resolving futures part of globals (recursively) ... DONE
[13:23:33.841] The total size of the 1 globals is 1.57 MiB (1641288 bytes)
[13:23:33.842] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[13:23:33.842] - globals: [1] ‘a’
[13:23:33.842] - packages: [1] ‘future’
[13:23:33.842] getGlobalsAndPackages() ... DONE
[13:23:33.843] run() for ‘Future’ ...
[13:23:33.843] - state: ‘created’
[13:23:33.843] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:33.847] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:33.847] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:33.848]   - Field: ‘label’
[13:23:33.848]   - Field: ‘local’
[13:23:33.848]   - Field: ‘owner’
[13:23:33.848]   - Field: ‘envir’
[13:23:33.848]   - Field: ‘workers’
[13:23:33.848]   - Field: ‘packages’
[13:23:33.848]   - Field: ‘gc’
[13:23:33.849]   - Field: ‘job’
[13:23:33.849]   - Field: ‘conditions’
[13:23:33.849]   - Field: ‘expr’
[13:23:33.849]   - Field: ‘uuid’
[13:23:33.849]   - Field: ‘seed’
[13:23:33.849]   - Field: ‘version’
[13:23:33.849]   - Field: ‘result’
[13:23:33.849]   - Field: ‘asynchronous’
[13:23:33.849]   - Field: ‘calls’
[13:23:33.850]   - Field: ‘globals’
[13:23:33.850]   - Field: ‘stdout’
[13:23:33.850]   - Field: ‘earlySignal’
[13:23:33.850]   - Field: ‘lazy’
[13:23:33.850]   - Field: ‘state’
[13:23:33.850] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:33.850] - Launch lazy future ...
[13:23:33.851] Packages needed by the future expression (n = 1): ‘future’
[13:23:33.851] Packages needed by future strategies (n = 0): <none>
[13:23:33.851] {
[13:23:33.851]     {
[13:23:33.851]         {
[13:23:33.851]             ...future.startTime <- base::Sys.time()
[13:23:33.851]             {
[13:23:33.851]                 {
[13:23:33.851]                   {
[13:23:33.851]                     {
[13:23:33.851]                       {
[13:23:33.851]                         base::local({
[13:23:33.851]                           has_future <- base::requireNamespace("future", 
[13:23:33.851]                             quietly = TRUE)
[13:23:33.851]                           if (has_future) {
[13:23:33.851]                             ns <- base::getNamespace("future")
[13:23:33.851]                             version <- ns[[".package"]][["version"]]
[13:23:33.851]                             if (is.null(version)) 
[13:23:33.851]                               version <- utils::packageVersion("future")
[13:23:33.851]                           }
[13:23:33.851]                           else {
[13:23:33.851]                             version <- NULL
[13:23:33.851]                           }
[13:23:33.851]                           if (!has_future || version < "1.8.0") {
[13:23:33.851]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.851]                               "", base::R.version$version.string), 
[13:23:33.851]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:33.851]                                 base::R.version$platform, 8 * 
[13:23:33.851]                                   base::.Machine$sizeof.pointer), 
[13:23:33.851]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.851]                                 "release", "version")], collapse = " "), 
[13:23:33.851]                               hostname = base::Sys.info()[["nodename"]])
[13:23:33.851]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.851]                               info)
[13:23:33.851]                             info <- base::paste(info, collapse = "; ")
[13:23:33.851]                             if (!has_future) {
[13:23:33.851]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.851]                                 info)
[13:23:33.851]                             }
[13:23:33.851]                             else {
[13:23:33.851]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.851]                                 info, version)
[13:23:33.851]                             }
[13:23:33.851]                             base::stop(msg)
[13:23:33.851]                           }
[13:23:33.851]                         })
[13:23:33.851]                       }
[13:23:33.851]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:33.851]                       base::options(mc.cores = 1L)
[13:23:33.851]                     }
[13:23:33.851]                     base::local({
[13:23:33.851]                       for (pkg in "future") {
[13:23:33.851]                         base::loadNamespace(pkg)
[13:23:33.851]                         base::library(pkg, character.only = TRUE)
[13:23:33.851]                       }
[13:23:33.851]                     })
[13:23:33.851]                   }
[13:23:33.851]                   options(future.plan = NULL)
[13:23:33.851]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.851]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.851]                 }
[13:23:33.851]                 ...future.workdir <- getwd()
[13:23:33.851]             }
[13:23:33.851]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.851]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.851]         }
[13:23:33.851]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.851]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:33.851]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.851]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.851]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.851]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.851]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.851]             base::names(...future.oldOptions))
[13:23:33.851]     }
[13:23:33.851]     if (FALSE) {
[13:23:33.851]     }
[13:23:33.851]     else {
[13:23:33.851]         if (TRUE) {
[13:23:33.851]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.851]                 open = "w")
[13:23:33.851]         }
[13:23:33.851]         else {
[13:23:33.851]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.851]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.851]         }
[13:23:33.851]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.851]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.851]             base::sink(type = "output", split = FALSE)
[13:23:33.851]             base::close(...future.stdout)
[13:23:33.851]         }, add = TRUE)
[13:23:33.851]     }
[13:23:33.851]     ...future.frame <- base::sys.nframe()
[13:23:33.851]     ...future.conditions <- base::list()
[13:23:33.851]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.851]     if (FALSE) {
[13:23:33.851]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.851]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.851]     }
[13:23:33.851]     ...future.result <- base::tryCatch({
[13:23:33.851]         base::withCallingHandlers({
[13:23:33.851]             ...future.value <- base::withVisible(base::local({
[13:23:33.851]                 withCallingHandlers({
[13:23:33.851]                   value(a) + 1
[13:23:33.851]                 }, immediateCondition = function(cond) {
[13:23:33.851]                   save_rds <- function (object, pathname, ...) 
[13:23:33.851]                   {
[13:23:33.851]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:33.851]                     if (file_test("-f", pathname_tmp)) {
[13:23:33.851]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.851]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:33.851]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.851]                         fi_tmp[["mtime"]])
[13:23:33.851]                     }
[13:23:33.851]                     tryCatch({
[13:23:33.851]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:33.851]                     }, error = function(ex) {
[13:23:33.851]                       msg <- conditionMessage(ex)
[13:23:33.851]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.851]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:33.851]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.851]                         fi_tmp[["mtime"]], msg)
[13:23:33.851]                       ex$message <- msg
[13:23:33.851]                       stop(ex)
[13:23:33.851]                     })
[13:23:33.851]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:33.851]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:33.851]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:33.851]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.851]                       fi <- file.info(pathname)
[13:23:33.851]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:33.851]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.851]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:33.851]                         fi[["size"]], fi[["mtime"]])
[13:23:33.851]                       stop(msg)
[13:23:33.851]                     }
[13:23:33.851]                     invisible(pathname)
[13:23:33.851]                   }
[13:23:33.851]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:33.851]                     rootPath = tempdir()) 
[13:23:33.851]                   {
[13:23:33.851]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:33.851]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:33.851]                       tmpdir = path, fileext = ".rds")
[13:23:33.851]                     save_rds(obj, file)
[13:23:33.851]                   }
[13:23:33.851]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:33.851]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.851]                   {
[13:23:33.851]                     inherits <- base::inherits
[13:23:33.851]                     invokeRestart <- base::invokeRestart
[13:23:33.851]                     is.null <- base::is.null
[13:23:33.851]                     muffled <- FALSE
[13:23:33.851]                     if (inherits(cond, "message")) {
[13:23:33.851]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:33.851]                       if (muffled) 
[13:23:33.851]                         invokeRestart("muffleMessage")
[13:23:33.851]                     }
[13:23:33.851]                     else if (inherits(cond, "warning")) {
[13:23:33.851]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:33.851]                       if (muffled) 
[13:23:33.851]                         invokeRestart("muffleWarning")
[13:23:33.851]                     }
[13:23:33.851]                     else if (inherits(cond, "condition")) {
[13:23:33.851]                       if (!is.null(pattern)) {
[13:23:33.851]                         computeRestarts <- base::computeRestarts
[13:23:33.851]                         grepl <- base::grepl
[13:23:33.851]                         restarts <- computeRestarts(cond)
[13:23:33.851]                         for (restart in restarts) {
[13:23:33.851]                           name <- restart$name
[13:23:33.851]                           if (is.null(name)) 
[13:23:33.851]                             next
[13:23:33.851]                           if (!grepl(pattern, name)) 
[13:23:33.851]                             next
[13:23:33.851]                           invokeRestart(restart)
[13:23:33.851]                           muffled <- TRUE
[13:23:33.851]                           break
[13:23:33.851]                         }
[13:23:33.851]                       }
[13:23:33.851]                     }
[13:23:33.851]                     invisible(muffled)
[13:23:33.851]                   }
[13:23:33.851]                   muffleCondition(cond)
[13:23:33.851]                 })
[13:23:33.851]             }))
[13:23:33.851]             future::FutureResult(value = ...future.value$value, 
[13:23:33.851]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.851]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.851]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.851]                     ...future.globalenv.names))
[13:23:33.851]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.851]         }, condition = base::local({
[13:23:33.851]             c <- base::c
[13:23:33.851]             inherits <- base::inherits
[13:23:33.851]             invokeRestart <- base::invokeRestart
[13:23:33.851]             length <- base::length
[13:23:33.851]             list <- base::list
[13:23:33.851]             seq.int <- base::seq.int
[13:23:33.851]             signalCondition <- base::signalCondition
[13:23:33.851]             sys.calls <- base::sys.calls
[13:23:33.851]             `[[` <- base::`[[`
[13:23:33.851]             `+` <- base::`+`
[13:23:33.851]             `<<-` <- base::`<<-`
[13:23:33.851]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.851]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.851]                   3L)]
[13:23:33.851]             }
[13:23:33.851]             function(cond) {
[13:23:33.851]                 is_error <- inherits(cond, "error")
[13:23:33.851]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.851]                   NULL)
[13:23:33.851]                 if (is_error) {
[13:23:33.851]                   sessionInformation <- function() {
[13:23:33.851]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.851]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.851]                       search = base::search(), system = base::Sys.info())
[13:23:33.851]                   }
[13:23:33.851]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.851]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.851]                     cond$call), session = sessionInformation(), 
[13:23:33.851]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.851]                   signalCondition(cond)
[13:23:33.851]                 }
[13:23:33.851]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.851]                 "immediateCondition"))) {
[13:23:33.851]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.851]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.851]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.851]                   if (TRUE && !signal) {
[13:23:33.851]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.851]                     {
[13:23:33.851]                       inherits <- base::inherits
[13:23:33.851]                       invokeRestart <- base::invokeRestart
[13:23:33.851]                       is.null <- base::is.null
[13:23:33.851]                       muffled <- FALSE
[13:23:33.851]                       if (inherits(cond, "message")) {
[13:23:33.851]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.851]                         if (muffled) 
[13:23:33.851]                           invokeRestart("muffleMessage")
[13:23:33.851]                       }
[13:23:33.851]                       else if (inherits(cond, "warning")) {
[13:23:33.851]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.851]                         if (muffled) 
[13:23:33.851]                           invokeRestart("muffleWarning")
[13:23:33.851]                       }
[13:23:33.851]                       else if (inherits(cond, "condition")) {
[13:23:33.851]                         if (!is.null(pattern)) {
[13:23:33.851]                           computeRestarts <- base::computeRestarts
[13:23:33.851]                           grepl <- base::grepl
[13:23:33.851]                           restarts <- computeRestarts(cond)
[13:23:33.851]                           for (restart in restarts) {
[13:23:33.851]                             name <- restart$name
[13:23:33.851]                             if (is.null(name)) 
[13:23:33.851]                               next
[13:23:33.851]                             if (!grepl(pattern, name)) 
[13:23:33.851]                               next
[13:23:33.851]                             invokeRestart(restart)
[13:23:33.851]                             muffled <- TRUE
[13:23:33.851]                             break
[13:23:33.851]                           }
[13:23:33.851]                         }
[13:23:33.851]                       }
[13:23:33.851]                       invisible(muffled)
[13:23:33.851]                     }
[13:23:33.851]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.851]                   }
[13:23:33.851]                 }
[13:23:33.851]                 else {
[13:23:33.851]                   if (TRUE) {
[13:23:33.851]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.851]                     {
[13:23:33.851]                       inherits <- base::inherits
[13:23:33.851]                       invokeRestart <- base::invokeRestart
[13:23:33.851]                       is.null <- base::is.null
[13:23:33.851]                       muffled <- FALSE
[13:23:33.851]                       if (inherits(cond, "message")) {
[13:23:33.851]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.851]                         if (muffled) 
[13:23:33.851]                           invokeRestart("muffleMessage")
[13:23:33.851]                       }
[13:23:33.851]                       else if (inherits(cond, "warning")) {
[13:23:33.851]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.851]                         if (muffled) 
[13:23:33.851]                           invokeRestart("muffleWarning")
[13:23:33.851]                       }
[13:23:33.851]                       else if (inherits(cond, "condition")) {
[13:23:33.851]                         if (!is.null(pattern)) {
[13:23:33.851]                           computeRestarts <- base::computeRestarts
[13:23:33.851]                           grepl <- base::grepl
[13:23:33.851]                           restarts <- computeRestarts(cond)
[13:23:33.851]                           for (restart in restarts) {
[13:23:33.851]                             name <- restart$name
[13:23:33.851]                             if (is.null(name)) 
[13:23:33.851]                               next
[13:23:33.851]                             if (!grepl(pattern, name)) 
[13:23:33.851]                               next
[13:23:33.851]                             invokeRestart(restart)
[13:23:33.851]                             muffled <- TRUE
[13:23:33.851]                             break
[13:23:33.851]                           }
[13:23:33.851]                         }
[13:23:33.851]                       }
[13:23:33.851]                       invisible(muffled)
[13:23:33.851]                     }
[13:23:33.851]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.851]                   }
[13:23:33.851]                 }
[13:23:33.851]             }
[13:23:33.851]         }))
[13:23:33.851]     }, error = function(ex) {
[13:23:33.851]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.851]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.851]                 ...future.rng), started = ...future.startTime, 
[13:23:33.851]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.851]             version = "1.8"), class = "FutureResult")
[13:23:33.851]     }, finally = {
[13:23:33.851]         if (!identical(...future.workdir, getwd())) 
[13:23:33.851]             setwd(...future.workdir)
[13:23:33.851]         {
[13:23:33.851]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.851]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.851]             }
[13:23:33.851]             base::options(...future.oldOptions)
[13:23:33.851]             if (.Platform$OS.type == "windows") {
[13:23:33.851]                 old_names <- names(...future.oldEnvVars)
[13:23:33.851]                 envs <- base::Sys.getenv()
[13:23:33.851]                 names <- names(envs)
[13:23:33.851]                 common <- intersect(names, old_names)
[13:23:33.851]                 added <- setdiff(names, old_names)
[13:23:33.851]                 removed <- setdiff(old_names, names)
[13:23:33.851]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.851]                   envs[common]]
[13:23:33.851]                 NAMES <- toupper(changed)
[13:23:33.851]                 args <- list()
[13:23:33.851]                 for (kk in seq_along(NAMES)) {
[13:23:33.851]                   name <- changed[[kk]]
[13:23:33.851]                   NAME <- NAMES[[kk]]
[13:23:33.851]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.851]                     next
[13:23:33.851]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.851]                 }
[13:23:33.851]                 NAMES <- toupper(added)
[13:23:33.851]                 for (kk in seq_along(NAMES)) {
[13:23:33.851]                   name <- added[[kk]]
[13:23:33.851]                   NAME <- NAMES[[kk]]
[13:23:33.851]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.851]                     next
[13:23:33.851]                   args[[name]] <- ""
[13:23:33.851]                 }
[13:23:33.851]                 NAMES <- toupper(removed)
[13:23:33.851]                 for (kk in seq_along(NAMES)) {
[13:23:33.851]                   name <- removed[[kk]]
[13:23:33.851]                   NAME <- NAMES[[kk]]
[13:23:33.851]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.851]                     next
[13:23:33.851]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.851]                 }
[13:23:33.851]                 if (length(args) > 0) 
[13:23:33.851]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.851]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.851]             }
[13:23:33.851]             else {
[13:23:33.851]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.851]             }
[13:23:33.851]             {
[13:23:33.851]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.851]                   0L) {
[13:23:33.851]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.851]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.851]                   base::options(opts)
[13:23:33.851]                 }
[13:23:33.851]                 {
[13:23:33.851]                   {
[13:23:33.851]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:33.851]                     NULL
[13:23:33.851]                   }
[13:23:33.851]                   options(future.plan = NULL)
[13:23:33.851]                   if (is.na(NA_character_)) 
[13:23:33.851]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.851]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.851]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.851]                     envir = parent.frame()) 
[13:23:33.851]                   {
[13:23:33.851]                     default_workers <- missing(workers)
[13:23:33.851]                     if (is.function(workers)) 
[13:23:33.851]                       workers <- workers()
[13:23:33.851]                     workers <- structure(as.integer(workers), 
[13:23:33.851]                       class = class(workers))
[13:23:33.851]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.851]                       1L)
[13:23:33.851]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.851]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.851]                       if (default_workers) 
[13:23:33.851]                         supportsMulticore(warn = TRUE)
[13:23:33.851]                       return(sequential(..., envir = envir))
[13:23:33.851]                     }
[13:23:33.851]                     oopts <- options(mc.cores = workers)
[13:23:33.851]                     on.exit(options(oopts))
[13:23:33.851]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.851]                       envir = envir)
[13:23:33.851]                     if (!future$lazy) 
[13:23:33.851]                       future <- run(future)
[13:23:33.851]                     invisible(future)
[13:23:33.851]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.851]                 }
[13:23:33.851]             }
[13:23:33.851]         }
[13:23:33.851]     })
[13:23:33.851]     if (TRUE) {
[13:23:33.851]         base::sink(type = "output", split = FALSE)
[13:23:33.851]         if (TRUE) {
[13:23:33.851]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.851]         }
[13:23:33.851]         else {
[13:23:33.851]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.851]         }
[13:23:33.851]         base::close(...future.stdout)
[13:23:33.851]         ...future.stdout <- NULL
[13:23:33.851]     }
[13:23:33.851]     ...future.result$conditions <- ...future.conditions
[13:23:33.851]     ...future.result$finished <- base::Sys.time()
[13:23:33.851]     ...future.result
[13:23:33.851] }
[13:23:33.854] assign_globals() ...
[13:23:33.855] List of 1
[13:23:33.855]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5589bf132480> 
[13:23:33.855]  - attr(*, "where")=List of 1
[13:23:33.855]   ..$ a:<environment: R_EmptyEnv> 
[13:23:33.855]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:33.855]  - attr(*, "resolved")= logi TRUE
[13:23:33.855]  - attr(*, "total_size")= num 1641288
[13:23:33.855]  - attr(*, "already-done")= logi TRUE
[13:23:33.858] - copied ‘a’ to environment
[13:23:33.858] assign_globals() ... done
[13:23:33.861] requestCore(): workers = 2
[13:23:33.863] MulticoreFuture started
[13:23:33.864] - Launch lazy future ... done
[13:23:33.865] run() for ‘MulticoreFuture’ ... done
[13:23:33.865] result() for MulticoreFuture ...
[13:23:33.866] plan(): Setting new future strategy stack:
[13:23:33.866] List of future strategies:
[13:23:33.866] 1. sequential:
[13:23:33.866]    - args: function (..., envir = parent.frame())
[13:23:33.866]    - tweaked: FALSE
[13:23:33.866]    - call: NULL
[13:23:33.867] plan(): nbrOfWorkers() = 1
[13:23:33.871] plan(): Setting new future strategy stack:
[13:23:33.872] List of future strategies:
[13:23:33.872] 1. multicore:
[13:23:33.872]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:33.872]    - tweaked: FALSE
[13:23:33.872]    - call: plan(strategy)
[13:23:33.879] plan(): nbrOfWorkers() = 2
[13:23:33.880] result() for MulticoreFuture ...
[13:23:33.880] result() for MulticoreFuture ... done
[13:23:33.880] signalConditions() ...
[13:23:33.880]  - include = ‘immediateCondition’
[13:23:33.881]  - exclude = 
[13:23:33.881]  - resignal = FALSE
[13:23:33.881]  - Number of conditions: 4
[13:23:33.881] signalConditions() ... done
[13:23:33.881] result() for MulticoreFuture ... done
[13:23:33.882] result() for MulticoreFuture ...
[13:23:33.882] result() for MulticoreFuture ... done
[13:23:33.882] signalConditions() ...
[13:23:33.882]  - include = ‘immediateCondition’
[13:23:33.882]  - exclude = 
[13:23:33.882]  - resignal = FALSE
[13:23:33.882]  - Number of conditions: 4
[13:23:33.883] signalConditions() ... done
[13:23:33.883] Future state: ‘finished’
[13:23:33.883] result() for MulticoreFuture ...
[13:23:33.883] result() for MulticoreFuture ... done
[13:23:33.884] signalConditions() ...
[13:23:33.884]  - include = ‘condition’
[13:23:33.884]  - exclude = ‘immediateCondition’
[13:23:33.884]  - resignal = TRUE
[13:23:33.884]  - Number of conditions: 4
[13:23:33.884]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.868] result() for MulticoreFuture ...
[13:23:33.885]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.869] result() for MulticoreFuture ... done
[13:23:33.885]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.870] result() for MulticoreFuture ...
[13:23:33.885]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.870] result() for MulticoreFuture ... done
[13:23:33.885] signalConditions() ... done
value(b) = 2
[13:23:33.886] result() for MulticoreFuture ...
[13:23:33.886] result() for MulticoreFuture ... done
[13:23:33.886] result() for MulticoreFuture ...
[13:23:33.886] result() for MulticoreFuture ... done
[13:23:33.886] signalConditions() ...
[13:23:33.887]  - include = ‘immediateCondition’
[13:23:33.887]  - exclude = 
[13:23:33.887]  - resignal = FALSE
[13:23:33.887]  - Number of conditions: 4
[13:23:33.887] signalConditions() ... done
[13:23:33.887] Future state: ‘finished’
[13:23:33.887] result() for MulticoreFuture ...
[13:23:33.887] result() for MulticoreFuture ... done
[13:23:33.888] signalConditions() ...
[13:23:33.888]  - include = ‘condition’
[13:23:33.888]  - exclude = ‘immediateCondition’
[13:23:33.888]  - resignal = TRUE
[13:23:33.888]  - Number of conditions: 4
[13:23:33.888]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.868] result() for MulticoreFuture ...
[13:23:33.888]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.869] result() for MulticoreFuture ... done
[13:23:33.889]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.870] result() for MulticoreFuture ...
[13:23:33.889]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:23:33.870] result() for MulticoreFuture ... done
[13:23:33.889] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:33.889] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:33.890] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:33.891] - globals found: [2] ‘{’, ‘pkg’
[13:23:33.891] Searching for globals ... DONE
[13:23:33.891] Resolving globals: TRUE
[13:23:33.891] Resolving any globals that are futures ...
[13:23:33.891] - globals: [2] ‘{’, ‘pkg’
[13:23:33.891] Resolving any globals that are futures ... DONE
[13:23:33.892] Resolving futures part of globals (recursively) ...
[13:23:33.892] resolve() on list ...
[13:23:33.892]  recursive: 99
[13:23:33.892]  length: 1
[13:23:33.893]  elements: ‘pkg’
[13:23:33.893]  length: 0 (resolved future 1)
[13:23:33.893] resolve() on list ... DONE
[13:23:33.893] - globals: [1] ‘pkg’
[13:23:33.893] Resolving futures part of globals (recursively) ... DONE
[13:23:33.893] The total size of the 1 globals is 112 bytes (112 bytes)
[13:23:33.894] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[13:23:33.894] - globals: [1] ‘pkg’
[13:23:33.894] 
[13:23:33.894] getGlobalsAndPackages() ... DONE
[13:23:33.895] Packages needed by the future expression (n = 0): <none>
[13:23:33.895] Packages needed by future strategies (n = 0): <none>
[13:23:33.895] {
[13:23:33.895]     {
[13:23:33.895]         {
[13:23:33.895]             ...future.startTime <- base::Sys.time()
[13:23:33.895]             {
[13:23:33.895]                 {
[13:23:33.895]                   {
[13:23:33.895]                     base::local({
[13:23:33.895]                       has_future <- base::requireNamespace("future", 
[13:23:33.895]                         quietly = TRUE)
[13:23:33.895]                       if (has_future) {
[13:23:33.895]                         ns <- base::getNamespace("future")
[13:23:33.895]                         version <- ns[[".package"]][["version"]]
[13:23:33.895]                         if (is.null(version)) 
[13:23:33.895]                           version <- utils::packageVersion("future")
[13:23:33.895]                       }
[13:23:33.895]                       else {
[13:23:33.895]                         version <- NULL
[13:23:33.895]                       }
[13:23:33.895]                       if (!has_future || version < "1.8.0") {
[13:23:33.895]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.895]                           "", base::R.version$version.string), 
[13:23:33.895]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:33.895]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:33.895]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.895]                             "release", "version")], collapse = " "), 
[13:23:33.895]                           hostname = base::Sys.info()[["nodename"]])
[13:23:33.895]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.895]                           info)
[13:23:33.895]                         info <- base::paste(info, collapse = "; ")
[13:23:33.895]                         if (!has_future) {
[13:23:33.895]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.895]                             info)
[13:23:33.895]                         }
[13:23:33.895]                         else {
[13:23:33.895]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.895]                             info, version)
[13:23:33.895]                         }
[13:23:33.895]                         base::stop(msg)
[13:23:33.895]                       }
[13:23:33.895]                     })
[13:23:33.895]                   }
[13:23:33.895]                   options(future.plan = NULL)
[13:23:33.895]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.895]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.895]                 }
[13:23:33.895]                 ...future.workdir <- getwd()
[13:23:33.895]             }
[13:23:33.895]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.895]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.895]         }
[13:23:33.895]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.895]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:33.895]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.895]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.895]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.895]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.895]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.895]             base::names(...future.oldOptions))
[13:23:33.895]     }
[13:23:33.895]     if (FALSE) {
[13:23:33.895]     }
[13:23:33.895]     else {
[13:23:33.895]         if (TRUE) {
[13:23:33.895]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.895]                 open = "w")
[13:23:33.895]         }
[13:23:33.895]         else {
[13:23:33.895]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.895]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.895]         }
[13:23:33.895]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.895]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.895]             base::sink(type = "output", split = FALSE)
[13:23:33.895]             base::close(...future.stdout)
[13:23:33.895]         }, add = TRUE)
[13:23:33.895]     }
[13:23:33.895]     ...future.frame <- base::sys.nframe()
[13:23:33.895]     ...future.conditions <- base::list()
[13:23:33.895]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.895]     if (FALSE) {
[13:23:33.895]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.895]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.895]     }
[13:23:33.895]     ...future.result <- base::tryCatch({
[13:23:33.895]         base::withCallingHandlers({
[13:23:33.895]             ...future.value <- base::withVisible(base::local({
[13:23:33.895]                 pkg
[13:23:33.895]             }))
[13:23:33.895]             future::FutureResult(value = ...future.value$value, 
[13:23:33.895]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.895]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.895]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.895]                     ...future.globalenv.names))
[13:23:33.895]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.895]         }, condition = base::local({
[13:23:33.895]             c <- base::c
[13:23:33.895]             inherits <- base::inherits
[13:23:33.895]             invokeRestart <- base::invokeRestart
[13:23:33.895]             length <- base::length
[13:23:33.895]             list <- base::list
[13:23:33.895]             seq.int <- base::seq.int
[13:23:33.895]             signalCondition <- base::signalCondition
[13:23:33.895]             sys.calls <- base::sys.calls
[13:23:33.895]             `[[` <- base::`[[`
[13:23:33.895]             `+` <- base::`+`
[13:23:33.895]             `<<-` <- base::`<<-`
[13:23:33.895]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.895]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.895]                   3L)]
[13:23:33.895]             }
[13:23:33.895]             function(cond) {
[13:23:33.895]                 is_error <- inherits(cond, "error")
[13:23:33.895]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.895]                   NULL)
[13:23:33.895]                 if (is_error) {
[13:23:33.895]                   sessionInformation <- function() {
[13:23:33.895]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.895]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.895]                       search = base::search(), system = base::Sys.info())
[13:23:33.895]                   }
[13:23:33.895]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.895]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.895]                     cond$call), session = sessionInformation(), 
[13:23:33.895]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.895]                   signalCondition(cond)
[13:23:33.895]                 }
[13:23:33.895]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.895]                 "immediateCondition"))) {
[13:23:33.895]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.895]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.895]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.895]                   if (TRUE && !signal) {
[13:23:33.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.895]                     {
[13:23:33.895]                       inherits <- base::inherits
[13:23:33.895]                       invokeRestart <- base::invokeRestart
[13:23:33.895]                       is.null <- base::is.null
[13:23:33.895]                       muffled <- FALSE
[13:23:33.895]                       if (inherits(cond, "message")) {
[13:23:33.895]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.895]                         if (muffled) 
[13:23:33.895]                           invokeRestart("muffleMessage")
[13:23:33.895]                       }
[13:23:33.895]                       else if (inherits(cond, "warning")) {
[13:23:33.895]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.895]                         if (muffled) 
[13:23:33.895]                           invokeRestart("muffleWarning")
[13:23:33.895]                       }
[13:23:33.895]                       else if (inherits(cond, "condition")) {
[13:23:33.895]                         if (!is.null(pattern)) {
[13:23:33.895]                           computeRestarts <- base::computeRestarts
[13:23:33.895]                           grepl <- base::grepl
[13:23:33.895]                           restarts <- computeRestarts(cond)
[13:23:33.895]                           for (restart in restarts) {
[13:23:33.895]                             name <- restart$name
[13:23:33.895]                             if (is.null(name)) 
[13:23:33.895]                               next
[13:23:33.895]                             if (!grepl(pattern, name)) 
[13:23:33.895]                               next
[13:23:33.895]                             invokeRestart(restart)
[13:23:33.895]                             muffled <- TRUE
[13:23:33.895]                             break
[13:23:33.895]                           }
[13:23:33.895]                         }
[13:23:33.895]                       }
[13:23:33.895]                       invisible(muffled)
[13:23:33.895]                     }
[13:23:33.895]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.895]                   }
[13:23:33.895]                 }
[13:23:33.895]                 else {
[13:23:33.895]                   if (TRUE) {
[13:23:33.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.895]                     {
[13:23:33.895]                       inherits <- base::inherits
[13:23:33.895]                       invokeRestart <- base::invokeRestart
[13:23:33.895]                       is.null <- base::is.null
[13:23:33.895]                       muffled <- FALSE
[13:23:33.895]                       if (inherits(cond, "message")) {
[13:23:33.895]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.895]                         if (muffled) 
[13:23:33.895]                           invokeRestart("muffleMessage")
[13:23:33.895]                       }
[13:23:33.895]                       else if (inherits(cond, "warning")) {
[13:23:33.895]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.895]                         if (muffled) 
[13:23:33.895]                           invokeRestart("muffleWarning")
[13:23:33.895]                       }
[13:23:33.895]                       else if (inherits(cond, "condition")) {
[13:23:33.895]                         if (!is.null(pattern)) {
[13:23:33.895]                           computeRestarts <- base::computeRestarts
[13:23:33.895]                           grepl <- base::grepl
[13:23:33.895]                           restarts <- computeRestarts(cond)
[13:23:33.895]                           for (restart in restarts) {
[13:23:33.895]                             name <- restart$name
[13:23:33.895]                             if (is.null(name)) 
[13:23:33.895]                               next
[13:23:33.895]                             if (!grepl(pattern, name)) 
[13:23:33.895]                               next
[13:23:33.895]                             invokeRestart(restart)
[13:23:33.895]                             muffled <- TRUE
[13:23:33.895]                             break
[13:23:33.895]                           }
[13:23:33.895]                         }
[13:23:33.895]                       }
[13:23:33.895]                       invisible(muffled)
[13:23:33.895]                     }
[13:23:33.895]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.895]                   }
[13:23:33.895]                 }
[13:23:33.895]             }
[13:23:33.895]         }))
[13:23:33.895]     }, error = function(ex) {
[13:23:33.895]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.895]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.895]                 ...future.rng), started = ...future.startTime, 
[13:23:33.895]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.895]             version = "1.8"), class = "FutureResult")
[13:23:33.895]     }, finally = {
[13:23:33.895]         if (!identical(...future.workdir, getwd())) 
[13:23:33.895]             setwd(...future.workdir)
[13:23:33.895]         {
[13:23:33.895]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.895]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.895]             }
[13:23:33.895]             base::options(...future.oldOptions)
[13:23:33.895]             if (.Platform$OS.type == "windows") {
[13:23:33.895]                 old_names <- names(...future.oldEnvVars)
[13:23:33.895]                 envs <- base::Sys.getenv()
[13:23:33.895]                 names <- names(envs)
[13:23:33.895]                 common <- intersect(names, old_names)
[13:23:33.895]                 added <- setdiff(names, old_names)
[13:23:33.895]                 removed <- setdiff(old_names, names)
[13:23:33.895]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.895]                   envs[common]]
[13:23:33.895]                 NAMES <- toupper(changed)
[13:23:33.895]                 args <- list()
[13:23:33.895]                 for (kk in seq_along(NAMES)) {
[13:23:33.895]                   name <- changed[[kk]]
[13:23:33.895]                   NAME <- NAMES[[kk]]
[13:23:33.895]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.895]                     next
[13:23:33.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.895]                 }
[13:23:33.895]                 NAMES <- toupper(added)
[13:23:33.895]                 for (kk in seq_along(NAMES)) {
[13:23:33.895]                   name <- added[[kk]]
[13:23:33.895]                   NAME <- NAMES[[kk]]
[13:23:33.895]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.895]                     next
[13:23:33.895]                   args[[name]] <- ""
[13:23:33.895]                 }
[13:23:33.895]                 NAMES <- toupper(removed)
[13:23:33.895]                 for (kk in seq_along(NAMES)) {
[13:23:33.895]                   name <- removed[[kk]]
[13:23:33.895]                   NAME <- NAMES[[kk]]
[13:23:33.895]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.895]                     next
[13:23:33.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.895]                 }
[13:23:33.895]                 if (length(args) > 0) 
[13:23:33.895]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.895]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.895]             }
[13:23:33.895]             else {
[13:23:33.895]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.895]             }
[13:23:33.895]             {
[13:23:33.895]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.895]                   0L) {
[13:23:33.895]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.895]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.895]                   base::options(opts)
[13:23:33.895]                 }
[13:23:33.895]                 {
[13:23:33.895]                   {
[13:23:33.895]                     NULL
[13:23:33.895]                     RNGkind("Mersenne-Twister")
[13:23:33.895]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:33.895]                       inherits = FALSE)
[13:23:33.895]                   }
[13:23:33.895]                   options(future.plan = NULL)
[13:23:33.895]                   if (is.na(NA_character_)) 
[13:23:33.895]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.895]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.895]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.895]                     envir = parent.frame()) 
[13:23:33.895]                   {
[13:23:33.895]                     default_workers <- missing(workers)
[13:23:33.895]                     if (is.function(workers)) 
[13:23:33.895]                       workers <- workers()
[13:23:33.895]                     workers <- structure(as.integer(workers), 
[13:23:33.895]                       class = class(workers))
[13:23:33.895]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.895]                       1L)
[13:23:33.895]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.895]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.895]                       if (default_workers) 
[13:23:33.895]                         supportsMulticore(warn = TRUE)
[13:23:33.895]                       return(sequential(..., envir = envir))
[13:23:33.895]                     }
[13:23:33.895]                     oopts <- options(mc.cores = workers)
[13:23:33.895]                     on.exit(options(oopts))
[13:23:33.895]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.895]                       envir = envir)
[13:23:33.895]                     if (!future$lazy) 
[13:23:33.895]                       future <- run(future)
[13:23:33.895]                     invisible(future)
[13:23:33.895]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.895]                 }
[13:23:33.895]             }
[13:23:33.895]         }
[13:23:33.895]     })
[13:23:33.895]     if (TRUE) {
[13:23:33.895]         base::sink(type = "output", split = FALSE)
[13:23:33.895]         if (TRUE) {
[13:23:33.895]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.895]         }
[13:23:33.895]         else {
[13:23:33.895]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.895]         }
[13:23:33.895]         base::close(...future.stdout)
[13:23:33.895]         ...future.stdout <- NULL
[13:23:33.895]     }
[13:23:33.895]     ...future.result$conditions <- ...future.conditions
[13:23:33.895]     ...future.result$finished <- base::Sys.time()
[13:23:33.895]     ...future.result
[13:23:33.895] }
[13:23:33.898] assign_globals() ...
[13:23:33.898] List of 1
[13:23:33.898]  $ pkg: chr "foo"
[13:23:33.898]  - attr(*, "where")=List of 1
[13:23:33.898]   ..$ pkg:<environment: R_EmptyEnv> 
[13:23:33.898]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:33.898]  - attr(*, "resolved")= logi TRUE
[13:23:33.898]  - attr(*, "total_size")= num 112
[13:23:33.901] - copied ‘pkg’ to environment
[13:23:33.901] assign_globals() ... done
[13:23:33.901] plan(): Setting new future strategy stack:
[13:23:33.901] List of future strategies:
[13:23:33.901] 1. sequential:
[13:23:33.901]    - args: function (..., envir = parent.frame())
[13:23:33.901]    - tweaked: FALSE
[13:23:33.901]    - call: NULL
[13:23:33.901] plan(): nbrOfWorkers() = 1
[13:23:33.902] plan(): Setting new future strategy stack:
[13:23:33.903] List of future strategies:
[13:23:33.903] 1. multicore:
[13:23:33.903]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:33.903]    - tweaked: FALSE
[13:23:33.903]    - call: plan(strategy)
[13:23:33.907] plan(): nbrOfWorkers() = 2
[13:23:33.907] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:33.907] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:33.908] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:33.912] - globals found: [3] ‘{’, ‘<-’, ‘+’
[13:23:33.912] Searching for globals ... DONE
[13:23:33.913] Resolving globals: TRUE
[13:23:33.913] Resolving any globals that are futures ...
[13:23:33.913] - globals: [3] ‘{’, ‘<-’, ‘+’
[13:23:33.913] Resolving any globals that are futures ... DONE
[13:23:33.913] 
[13:23:33.913] 
[13:23:33.914] getGlobalsAndPackages() ... DONE
[13:23:33.914] run() for ‘Future’ ...
[13:23:33.914] - state: ‘created’
[13:23:33.914] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:33.918] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:33.918] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:33.919]   - Field: ‘label’
[13:23:33.919]   - Field: ‘local’
[13:23:33.919]   - Field: ‘owner’
[13:23:33.919]   - Field: ‘envir’
[13:23:33.919]   - Field: ‘workers’
[13:23:33.919]   - Field: ‘packages’
[13:23:33.919]   - Field: ‘gc’
[13:23:33.919]   - Field: ‘job’
[13:23:33.919]   - Field: ‘conditions’
[13:23:33.920]   - Field: ‘expr’
[13:23:33.920]   - Field: ‘uuid’
[13:23:33.920]   - Field: ‘seed’
[13:23:33.920]   - Field: ‘version’
[13:23:33.920]   - Field: ‘result’
[13:23:33.920]   - Field: ‘asynchronous’
[13:23:33.920]   - Field: ‘calls’
[13:23:33.920]   - Field: ‘globals’
[13:23:33.920]   - Field: ‘stdout’
[13:23:33.920]   - Field: ‘earlySignal’
[13:23:33.921]   - Field: ‘lazy’
[13:23:33.921]   - Field: ‘state’
[13:23:33.921] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:33.921] - Launch lazy future ...
[13:23:33.921] Packages needed by the future expression (n = 0): <none>
[13:23:33.921] Packages needed by future strategies (n = 0): <none>
[13:23:33.922] {
[13:23:33.922]     {
[13:23:33.922]         {
[13:23:33.922]             ...future.startTime <- base::Sys.time()
[13:23:33.922]             {
[13:23:33.922]                 {
[13:23:33.922]                   {
[13:23:33.922]                     {
[13:23:33.922]                       base::local({
[13:23:33.922]                         has_future <- base::requireNamespace("future", 
[13:23:33.922]                           quietly = TRUE)
[13:23:33.922]                         if (has_future) {
[13:23:33.922]                           ns <- base::getNamespace("future")
[13:23:33.922]                           version <- ns[[".package"]][["version"]]
[13:23:33.922]                           if (is.null(version)) 
[13:23:33.922]                             version <- utils::packageVersion("future")
[13:23:33.922]                         }
[13:23:33.922]                         else {
[13:23:33.922]                           version <- NULL
[13:23:33.922]                         }
[13:23:33.922]                         if (!has_future || version < "1.8.0") {
[13:23:33.922]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.922]                             "", base::R.version$version.string), 
[13:23:33.922]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:33.922]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:33.922]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.922]                               "release", "version")], collapse = " "), 
[13:23:33.922]                             hostname = base::Sys.info()[["nodename"]])
[13:23:33.922]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.922]                             info)
[13:23:33.922]                           info <- base::paste(info, collapse = "; ")
[13:23:33.922]                           if (!has_future) {
[13:23:33.922]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.922]                               info)
[13:23:33.922]                           }
[13:23:33.922]                           else {
[13:23:33.922]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.922]                               info, version)
[13:23:33.922]                           }
[13:23:33.922]                           base::stop(msg)
[13:23:33.922]                         }
[13:23:33.922]                       })
[13:23:33.922]                     }
[13:23:33.922]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:33.922]                     base::options(mc.cores = 1L)
[13:23:33.922]                   }
[13:23:33.922]                   options(future.plan = NULL)
[13:23:33.922]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.922]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.922]                 }
[13:23:33.922]                 ...future.workdir <- getwd()
[13:23:33.922]             }
[13:23:33.922]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.922]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.922]         }
[13:23:33.922]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.922]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:33.922]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.922]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.922]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.922]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.922]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.922]             base::names(...future.oldOptions))
[13:23:33.922]     }
[13:23:33.922]     if (FALSE) {
[13:23:33.922]     }
[13:23:33.922]     else {
[13:23:33.922]         if (TRUE) {
[13:23:33.922]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.922]                 open = "w")
[13:23:33.922]         }
[13:23:33.922]         else {
[13:23:33.922]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.922]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.922]         }
[13:23:33.922]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.922]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.922]             base::sink(type = "output", split = FALSE)
[13:23:33.922]             base::close(...future.stdout)
[13:23:33.922]         }, add = TRUE)
[13:23:33.922]     }
[13:23:33.922]     ...future.frame <- base::sys.nframe()
[13:23:33.922]     ...future.conditions <- base::list()
[13:23:33.922]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.922]     if (FALSE) {
[13:23:33.922]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.922]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.922]     }
[13:23:33.922]     ...future.result <- base::tryCatch({
[13:23:33.922]         base::withCallingHandlers({
[13:23:33.922]             ...future.value <- base::withVisible(base::local({
[13:23:33.922]                 withCallingHandlers({
[13:23:33.922]                   {
[13:23:33.922]                     x <- 0
[13:23:33.922]                     x <- x + 1
[13:23:33.922]                     x
[13:23:33.922]                   }
[13:23:33.922]                 }, immediateCondition = function(cond) {
[13:23:33.922]                   save_rds <- function (object, pathname, ...) 
[13:23:33.922]                   {
[13:23:33.922]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:33.922]                     if (file_test("-f", pathname_tmp)) {
[13:23:33.922]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.922]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:33.922]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.922]                         fi_tmp[["mtime"]])
[13:23:33.922]                     }
[13:23:33.922]                     tryCatch({
[13:23:33.922]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:33.922]                     }, error = function(ex) {
[13:23:33.922]                       msg <- conditionMessage(ex)
[13:23:33.922]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.922]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:33.922]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.922]                         fi_tmp[["mtime"]], msg)
[13:23:33.922]                       ex$message <- msg
[13:23:33.922]                       stop(ex)
[13:23:33.922]                     })
[13:23:33.922]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:33.922]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:33.922]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:33.922]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.922]                       fi <- file.info(pathname)
[13:23:33.922]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:33.922]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.922]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:33.922]                         fi[["size"]], fi[["mtime"]])
[13:23:33.922]                       stop(msg)
[13:23:33.922]                     }
[13:23:33.922]                     invisible(pathname)
[13:23:33.922]                   }
[13:23:33.922]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:33.922]                     rootPath = tempdir()) 
[13:23:33.922]                   {
[13:23:33.922]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:33.922]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:33.922]                       tmpdir = path, fileext = ".rds")
[13:23:33.922]                     save_rds(obj, file)
[13:23:33.922]                   }
[13:23:33.922]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:33.922]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.922]                   {
[13:23:33.922]                     inherits <- base::inherits
[13:23:33.922]                     invokeRestart <- base::invokeRestart
[13:23:33.922]                     is.null <- base::is.null
[13:23:33.922]                     muffled <- FALSE
[13:23:33.922]                     if (inherits(cond, "message")) {
[13:23:33.922]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:33.922]                       if (muffled) 
[13:23:33.922]                         invokeRestart("muffleMessage")
[13:23:33.922]                     }
[13:23:33.922]                     else if (inherits(cond, "warning")) {
[13:23:33.922]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:33.922]                       if (muffled) 
[13:23:33.922]                         invokeRestart("muffleWarning")
[13:23:33.922]                     }
[13:23:33.922]                     else if (inherits(cond, "condition")) {
[13:23:33.922]                       if (!is.null(pattern)) {
[13:23:33.922]                         computeRestarts <- base::computeRestarts
[13:23:33.922]                         grepl <- base::grepl
[13:23:33.922]                         restarts <- computeRestarts(cond)
[13:23:33.922]                         for (restart in restarts) {
[13:23:33.922]                           name <- restart$name
[13:23:33.922]                           if (is.null(name)) 
[13:23:33.922]                             next
[13:23:33.922]                           if (!grepl(pattern, name)) 
[13:23:33.922]                             next
[13:23:33.922]                           invokeRestart(restart)
[13:23:33.922]                           muffled <- TRUE
[13:23:33.922]                           break
[13:23:33.922]                         }
[13:23:33.922]                       }
[13:23:33.922]                     }
[13:23:33.922]                     invisible(muffled)
[13:23:33.922]                   }
[13:23:33.922]                   muffleCondition(cond)
[13:23:33.922]                 })
[13:23:33.922]             }))
[13:23:33.922]             future::FutureResult(value = ...future.value$value, 
[13:23:33.922]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.922]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.922]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.922]                     ...future.globalenv.names))
[13:23:33.922]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.922]         }, condition = base::local({
[13:23:33.922]             c <- base::c
[13:23:33.922]             inherits <- base::inherits
[13:23:33.922]             invokeRestart <- base::invokeRestart
[13:23:33.922]             length <- base::length
[13:23:33.922]             list <- base::list
[13:23:33.922]             seq.int <- base::seq.int
[13:23:33.922]             signalCondition <- base::signalCondition
[13:23:33.922]             sys.calls <- base::sys.calls
[13:23:33.922]             `[[` <- base::`[[`
[13:23:33.922]             `+` <- base::`+`
[13:23:33.922]             `<<-` <- base::`<<-`
[13:23:33.922]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.922]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.922]                   3L)]
[13:23:33.922]             }
[13:23:33.922]             function(cond) {
[13:23:33.922]                 is_error <- inherits(cond, "error")
[13:23:33.922]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.922]                   NULL)
[13:23:33.922]                 if (is_error) {
[13:23:33.922]                   sessionInformation <- function() {
[13:23:33.922]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.922]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.922]                       search = base::search(), system = base::Sys.info())
[13:23:33.922]                   }
[13:23:33.922]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.922]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.922]                     cond$call), session = sessionInformation(), 
[13:23:33.922]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.922]                   signalCondition(cond)
[13:23:33.922]                 }
[13:23:33.922]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.922]                 "immediateCondition"))) {
[13:23:33.922]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.922]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.922]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.922]                   if (TRUE && !signal) {
[13:23:33.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.922]                     {
[13:23:33.922]                       inherits <- base::inherits
[13:23:33.922]                       invokeRestart <- base::invokeRestart
[13:23:33.922]                       is.null <- base::is.null
[13:23:33.922]                       muffled <- FALSE
[13:23:33.922]                       if (inherits(cond, "message")) {
[13:23:33.922]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.922]                         if (muffled) 
[13:23:33.922]                           invokeRestart("muffleMessage")
[13:23:33.922]                       }
[13:23:33.922]                       else if (inherits(cond, "warning")) {
[13:23:33.922]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.922]                         if (muffled) 
[13:23:33.922]                           invokeRestart("muffleWarning")
[13:23:33.922]                       }
[13:23:33.922]                       else if (inherits(cond, "condition")) {
[13:23:33.922]                         if (!is.null(pattern)) {
[13:23:33.922]                           computeRestarts <- base::computeRestarts
[13:23:33.922]                           grepl <- base::grepl
[13:23:33.922]                           restarts <- computeRestarts(cond)
[13:23:33.922]                           for (restart in restarts) {
[13:23:33.922]                             name <- restart$name
[13:23:33.922]                             if (is.null(name)) 
[13:23:33.922]                               next
[13:23:33.922]                             if (!grepl(pattern, name)) 
[13:23:33.922]                               next
[13:23:33.922]                             invokeRestart(restart)
[13:23:33.922]                             muffled <- TRUE
[13:23:33.922]                             break
[13:23:33.922]                           }
[13:23:33.922]                         }
[13:23:33.922]                       }
[13:23:33.922]                       invisible(muffled)
[13:23:33.922]                     }
[13:23:33.922]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.922]                   }
[13:23:33.922]                 }
[13:23:33.922]                 else {
[13:23:33.922]                   if (TRUE) {
[13:23:33.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.922]                     {
[13:23:33.922]                       inherits <- base::inherits
[13:23:33.922]                       invokeRestart <- base::invokeRestart
[13:23:33.922]                       is.null <- base::is.null
[13:23:33.922]                       muffled <- FALSE
[13:23:33.922]                       if (inherits(cond, "message")) {
[13:23:33.922]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.922]                         if (muffled) 
[13:23:33.922]                           invokeRestart("muffleMessage")
[13:23:33.922]                       }
[13:23:33.922]                       else if (inherits(cond, "warning")) {
[13:23:33.922]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.922]                         if (muffled) 
[13:23:33.922]                           invokeRestart("muffleWarning")
[13:23:33.922]                       }
[13:23:33.922]                       else if (inherits(cond, "condition")) {
[13:23:33.922]                         if (!is.null(pattern)) {
[13:23:33.922]                           computeRestarts <- base::computeRestarts
[13:23:33.922]                           grepl <- base::grepl
[13:23:33.922]                           restarts <- computeRestarts(cond)
[13:23:33.922]                           for (restart in restarts) {
[13:23:33.922]                             name <- restart$name
[13:23:33.922]                             if (is.null(name)) 
[13:23:33.922]                               next
[13:23:33.922]                             if (!grepl(pattern, name)) 
[13:23:33.922]                               next
[13:23:33.922]                             invokeRestart(restart)
[13:23:33.922]                             muffled <- TRUE
[13:23:33.922]                             break
[13:23:33.922]                           }
[13:23:33.922]                         }
[13:23:33.922]                       }
[13:23:33.922]                       invisible(muffled)
[13:23:33.922]                     }
[13:23:33.922]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.922]                   }
[13:23:33.922]                 }
[13:23:33.922]             }
[13:23:33.922]         }))
[13:23:33.922]     }, error = function(ex) {
[13:23:33.922]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.922]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.922]                 ...future.rng), started = ...future.startTime, 
[13:23:33.922]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.922]             version = "1.8"), class = "FutureResult")
[13:23:33.922]     }, finally = {
[13:23:33.922]         if (!identical(...future.workdir, getwd())) 
[13:23:33.922]             setwd(...future.workdir)
[13:23:33.922]         {
[13:23:33.922]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.922]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.922]             }
[13:23:33.922]             base::options(...future.oldOptions)
[13:23:33.922]             if (.Platform$OS.type == "windows") {
[13:23:33.922]                 old_names <- names(...future.oldEnvVars)
[13:23:33.922]                 envs <- base::Sys.getenv()
[13:23:33.922]                 names <- names(envs)
[13:23:33.922]                 common <- intersect(names, old_names)
[13:23:33.922]                 added <- setdiff(names, old_names)
[13:23:33.922]                 removed <- setdiff(old_names, names)
[13:23:33.922]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.922]                   envs[common]]
[13:23:33.922]                 NAMES <- toupper(changed)
[13:23:33.922]                 args <- list()
[13:23:33.922]                 for (kk in seq_along(NAMES)) {
[13:23:33.922]                   name <- changed[[kk]]
[13:23:33.922]                   NAME <- NAMES[[kk]]
[13:23:33.922]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.922]                     next
[13:23:33.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.922]                 }
[13:23:33.922]                 NAMES <- toupper(added)
[13:23:33.922]                 for (kk in seq_along(NAMES)) {
[13:23:33.922]                   name <- added[[kk]]
[13:23:33.922]                   NAME <- NAMES[[kk]]
[13:23:33.922]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.922]                     next
[13:23:33.922]                   args[[name]] <- ""
[13:23:33.922]                 }
[13:23:33.922]                 NAMES <- toupper(removed)
[13:23:33.922]                 for (kk in seq_along(NAMES)) {
[13:23:33.922]                   name <- removed[[kk]]
[13:23:33.922]                   NAME <- NAMES[[kk]]
[13:23:33.922]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.922]                     next
[13:23:33.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.922]                 }
[13:23:33.922]                 if (length(args) > 0) 
[13:23:33.922]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.922]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.922]             }
[13:23:33.922]             else {
[13:23:33.922]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.922]             }
[13:23:33.922]             {
[13:23:33.922]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.922]                   0L) {
[13:23:33.922]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.922]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.922]                   base::options(opts)
[13:23:33.922]                 }
[13:23:33.922]                 {
[13:23:33.922]                   {
[13:23:33.922]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:33.922]                     NULL
[13:23:33.922]                   }
[13:23:33.922]                   options(future.plan = NULL)
[13:23:33.922]                   if (is.na(NA_character_)) 
[13:23:33.922]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.922]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.922]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.922]                     envir = parent.frame()) 
[13:23:33.922]                   {
[13:23:33.922]                     default_workers <- missing(workers)
[13:23:33.922]                     if (is.function(workers)) 
[13:23:33.922]                       workers <- workers()
[13:23:33.922]                     workers <- structure(as.integer(workers), 
[13:23:33.922]                       class = class(workers))
[13:23:33.922]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.922]                       1L)
[13:23:33.922]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.922]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.922]                       if (default_workers) 
[13:23:33.922]                         supportsMulticore(warn = TRUE)
[13:23:33.922]                       return(sequential(..., envir = envir))
[13:23:33.922]                     }
[13:23:33.922]                     oopts <- options(mc.cores = workers)
[13:23:33.922]                     on.exit(options(oopts))
[13:23:33.922]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.922]                       envir = envir)
[13:23:33.922]                     if (!future$lazy) 
[13:23:33.922]                       future <- run(future)
[13:23:33.922]                     invisible(future)
[13:23:33.922]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.922]                 }
[13:23:33.922]             }
[13:23:33.922]         }
[13:23:33.922]     })
[13:23:33.922]     if (TRUE) {
[13:23:33.922]         base::sink(type = "output", split = FALSE)
[13:23:33.922]         if (TRUE) {
[13:23:33.922]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.922]         }
[13:23:33.922]         else {
[13:23:33.922]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.922]         }
[13:23:33.922]         base::close(...future.stdout)
[13:23:33.922]         ...future.stdout <- NULL
[13:23:33.922]     }
[13:23:33.922]     ...future.result$conditions <- ...future.conditions
[13:23:33.922]     ...future.result$finished <- base::Sys.time()
[13:23:33.922]     ...future.result
[13:23:33.922] }
[13:23:33.924] requestCore(): workers = 2
[13:23:33.927] MulticoreFuture started
[13:23:33.927] - Launch lazy future ... done
[13:23:33.927] run() for ‘MulticoreFuture’ ... done
[13:23:33.928] result() for MulticoreFuture ...
[13:23:33.928] plan(): Setting new future strategy stack:
[13:23:33.928] List of future strategies:
[13:23:33.928] 1. sequential:
[13:23:33.928]    - args: function (..., envir = parent.frame())
[13:23:33.928]    - tweaked: FALSE
[13:23:33.928]    - call: NULL
[13:23:33.929] plan(): nbrOfWorkers() = 1
[13:23:33.931] plan(): Setting new future strategy stack:
[13:23:33.932] List of future strategies:
[13:23:33.932] 1. multicore:
[13:23:33.932]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:33.932]    - tweaked: FALSE
[13:23:33.932]    - call: plan(strategy)
[13:23:33.937] plan(): nbrOfWorkers() = 2
[13:23:33.938] result() for MulticoreFuture ...
[13:23:33.939] result() for MulticoreFuture ... done
[13:23:33.939] result() for MulticoreFuture ... done
[13:23:33.939] result() for MulticoreFuture ...
[13:23:33.939] result() for MulticoreFuture ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:33.940] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:33.940] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:33.942] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[13:23:33.942] Searching for globals ... DONE
[13:23:33.942] Resolving globals: TRUE
[13:23:33.943] Resolving any globals that are futures ...
[13:23:33.943] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[13:23:33.943] Resolving any globals that are futures ... DONE
[13:23:33.943] Resolving futures part of globals (recursively) ...
[13:23:33.944] resolve() on list ...
[13:23:33.944]  recursive: 99
[13:23:33.944]  length: 1
[13:23:33.944]  elements: ‘x’
[13:23:33.944]  length: 0 (resolved future 1)
[13:23:33.944] resolve() on list ... DONE
[13:23:33.944] - globals: [1] ‘x’
[13:23:33.945] Resolving futures part of globals (recursively) ... DONE
[13:23:33.945] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:33.945] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[13:23:33.945] - globals: [1] ‘x’
[13:23:33.946] 
[13:23:33.946] getGlobalsAndPackages() ... DONE
[13:23:33.946] run() for ‘Future’ ...
[13:23:33.946] - state: ‘created’
[13:23:33.946] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:33.951] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:33.951] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:33.952]   - Field: ‘label’
[13:23:33.952]   - Field: ‘local’
[13:23:33.952]   - Field: ‘owner’
[13:23:33.952]   - Field: ‘envir’
[13:23:33.952]   - Field: ‘workers’
[13:23:33.952]   - Field: ‘packages’
[13:23:33.952]   - Field: ‘gc’
[13:23:33.953]   - Field: ‘job’
[13:23:33.953]   - Field: ‘conditions’
[13:23:33.953]   - Field: ‘expr’
[13:23:33.953]   - Field: ‘uuid’
[13:23:33.953]   - Field: ‘seed’
[13:23:33.953]   - Field: ‘version’
[13:23:33.953]   - Field: ‘result’
[13:23:33.953]   - Field: ‘asynchronous’
[13:23:33.954]   - Field: ‘calls’
[13:23:33.954]   - Field: ‘globals’
[13:23:33.957]   - Field: ‘stdout’
[13:23:33.957]   - Field: ‘earlySignal’
[13:23:33.957]   - Field: ‘lazy’
[13:23:33.957]   - Field: ‘state’
[13:23:33.958] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:33.958] - Launch lazy future ...
[13:23:33.958] Packages needed by the future expression (n = 0): <none>
[13:23:33.958] Packages needed by future strategies (n = 0): <none>
[13:23:33.959] {
[13:23:33.959]     {
[13:23:33.959]         {
[13:23:33.959]             ...future.startTime <- base::Sys.time()
[13:23:33.959]             {
[13:23:33.959]                 {
[13:23:33.959]                   {
[13:23:33.959]                     {
[13:23:33.959]                       base::local({
[13:23:33.959]                         has_future <- base::requireNamespace("future", 
[13:23:33.959]                           quietly = TRUE)
[13:23:33.959]                         if (has_future) {
[13:23:33.959]                           ns <- base::getNamespace("future")
[13:23:33.959]                           version <- ns[[".package"]][["version"]]
[13:23:33.959]                           if (is.null(version)) 
[13:23:33.959]                             version <- utils::packageVersion("future")
[13:23:33.959]                         }
[13:23:33.959]                         else {
[13:23:33.959]                           version <- NULL
[13:23:33.959]                         }
[13:23:33.959]                         if (!has_future || version < "1.8.0") {
[13:23:33.959]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.959]                             "", base::R.version$version.string), 
[13:23:33.959]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:33.959]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:33.959]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.959]                               "release", "version")], collapse = " "), 
[13:23:33.959]                             hostname = base::Sys.info()[["nodename"]])
[13:23:33.959]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.959]                             info)
[13:23:33.959]                           info <- base::paste(info, collapse = "; ")
[13:23:33.959]                           if (!has_future) {
[13:23:33.959]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.959]                               info)
[13:23:33.959]                           }
[13:23:33.959]                           else {
[13:23:33.959]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.959]                               info, version)
[13:23:33.959]                           }
[13:23:33.959]                           base::stop(msg)
[13:23:33.959]                         }
[13:23:33.959]                       })
[13:23:33.959]                     }
[13:23:33.959]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:33.959]                     base::options(mc.cores = 1L)
[13:23:33.959]                   }
[13:23:33.959]                   options(future.plan = NULL)
[13:23:33.959]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.959]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.959]                 }
[13:23:33.959]                 ...future.workdir <- getwd()
[13:23:33.959]             }
[13:23:33.959]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.959]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.959]         }
[13:23:33.959]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.959]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:33.959]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.959]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.959]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.959]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.959]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.959]             base::names(...future.oldOptions))
[13:23:33.959]     }
[13:23:33.959]     if (FALSE) {
[13:23:33.959]     }
[13:23:33.959]     else {
[13:23:33.959]         if (TRUE) {
[13:23:33.959]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.959]                 open = "w")
[13:23:33.959]         }
[13:23:33.959]         else {
[13:23:33.959]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.959]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.959]         }
[13:23:33.959]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.959]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.959]             base::sink(type = "output", split = FALSE)
[13:23:33.959]             base::close(...future.stdout)
[13:23:33.959]         }, add = TRUE)
[13:23:33.959]     }
[13:23:33.959]     ...future.frame <- base::sys.nframe()
[13:23:33.959]     ...future.conditions <- base::list()
[13:23:33.959]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.959]     if (FALSE) {
[13:23:33.959]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.959]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.959]     }
[13:23:33.959]     ...future.result <- base::tryCatch({
[13:23:33.959]         base::withCallingHandlers({
[13:23:33.959]             ...future.value <- base::withVisible(base::local({
[13:23:33.959]                 withCallingHandlers({
[13:23:33.959]                   {
[13:23:33.959]                     x <- x + 1
[13:23:33.959]                     x
[13:23:33.959]                   }
[13:23:33.959]                 }, immediateCondition = function(cond) {
[13:23:33.959]                   save_rds <- function (object, pathname, ...) 
[13:23:33.959]                   {
[13:23:33.959]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:33.959]                     if (file_test("-f", pathname_tmp)) {
[13:23:33.959]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.959]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:33.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.959]                         fi_tmp[["mtime"]])
[13:23:33.959]                     }
[13:23:33.959]                     tryCatch({
[13:23:33.959]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:33.959]                     }, error = function(ex) {
[13:23:33.959]                       msg <- conditionMessage(ex)
[13:23:33.959]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.959]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:33.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.959]                         fi_tmp[["mtime"]], msg)
[13:23:33.959]                       ex$message <- msg
[13:23:33.959]                       stop(ex)
[13:23:33.959]                     })
[13:23:33.959]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:33.959]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:33.959]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:33.959]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.959]                       fi <- file.info(pathname)
[13:23:33.959]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:33.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.959]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:33.959]                         fi[["size"]], fi[["mtime"]])
[13:23:33.959]                       stop(msg)
[13:23:33.959]                     }
[13:23:33.959]                     invisible(pathname)
[13:23:33.959]                   }
[13:23:33.959]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:33.959]                     rootPath = tempdir()) 
[13:23:33.959]                   {
[13:23:33.959]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:33.959]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:33.959]                       tmpdir = path, fileext = ".rds")
[13:23:33.959]                     save_rds(obj, file)
[13:23:33.959]                   }
[13:23:33.959]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:33.959]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.959]                   {
[13:23:33.959]                     inherits <- base::inherits
[13:23:33.959]                     invokeRestart <- base::invokeRestart
[13:23:33.959]                     is.null <- base::is.null
[13:23:33.959]                     muffled <- FALSE
[13:23:33.959]                     if (inherits(cond, "message")) {
[13:23:33.959]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:33.959]                       if (muffled) 
[13:23:33.959]                         invokeRestart("muffleMessage")
[13:23:33.959]                     }
[13:23:33.959]                     else if (inherits(cond, "warning")) {
[13:23:33.959]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:33.959]                       if (muffled) 
[13:23:33.959]                         invokeRestart("muffleWarning")
[13:23:33.959]                     }
[13:23:33.959]                     else if (inherits(cond, "condition")) {
[13:23:33.959]                       if (!is.null(pattern)) {
[13:23:33.959]                         computeRestarts <- base::computeRestarts
[13:23:33.959]                         grepl <- base::grepl
[13:23:33.959]                         restarts <- computeRestarts(cond)
[13:23:33.959]                         for (restart in restarts) {
[13:23:33.959]                           name <- restart$name
[13:23:33.959]                           if (is.null(name)) 
[13:23:33.959]                             next
[13:23:33.959]                           if (!grepl(pattern, name)) 
[13:23:33.959]                             next
[13:23:33.959]                           invokeRestart(restart)
[13:23:33.959]                           muffled <- TRUE
[13:23:33.959]                           break
[13:23:33.959]                         }
[13:23:33.959]                       }
[13:23:33.959]                     }
[13:23:33.959]                     invisible(muffled)
[13:23:33.959]                   }
[13:23:33.959]                   muffleCondition(cond)
[13:23:33.959]                 })
[13:23:33.959]             }))
[13:23:33.959]             future::FutureResult(value = ...future.value$value, 
[13:23:33.959]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.959]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.959]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.959]                     ...future.globalenv.names))
[13:23:33.959]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.959]         }, condition = base::local({
[13:23:33.959]             c <- base::c
[13:23:33.959]             inherits <- base::inherits
[13:23:33.959]             invokeRestart <- base::invokeRestart
[13:23:33.959]             length <- base::length
[13:23:33.959]             list <- base::list
[13:23:33.959]             seq.int <- base::seq.int
[13:23:33.959]             signalCondition <- base::signalCondition
[13:23:33.959]             sys.calls <- base::sys.calls
[13:23:33.959]             `[[` <- base::`[[`
[13:23:33.959]             `+` <- base::`+`
[13:23:33.959]             `<<-` <- base::`<<-`
[13:23:33.959]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.959]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.959]                   3L)]
[13:23:33.959]             }
[13:23:33.959]             function(cond) {
[13:23:33.959]                 is_error <- inherits(cond, "error")
[13:23:33.959]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.959]                   NULL)
[13:23:33.959]                 if (is_error) {
[13:23:33.959]                   sessionInformation <- function() {
[13:23:33.959]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.959]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.959]                       search = base::search(), system = base::Sys.info())
[13:23:33.959]                   }
[13:23:33.959]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.959]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.959]                     cond$call), session = sessionInformation(), 
[13:23:33.959]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.959]                   signalCondition(cond)
[13:23:33.959]                 }
[13:23:33.959]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.959]                 "immediateCondition"))) {
[13:23:33.959]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.959]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.959]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.959]                   if (TRUE && !signal) {
[13:23:33.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.959]                     {
[13:23:33.959]                       inherits <- base::inherits
[13:23:33.959]                       invokeRestart <- base::invokeRestart
[13:23:33.959]                       is.null <- base::is.null
[13:23:33.959]                       muffled <- FALSE
[13:23:33.959]                       if (inherits(cond, "message")) {
[13:23:33.959]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.959]                         if (muffled) 
[13:23:33.959]                           invokeRestart("muffleMessage")
[13:23:33.959]                       }
[13:23:33.959]                       else if (inherits(cond, "warning")) {
[13:23:33.959]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.959]                         if (muffled) 
[13:23:33.959]                           invokeRestart("muffleWarning")
[13:23:33.959]                       }
[13:23:33.959]                       else if (inherits(cond, "condition")) {
[13:23:33.959]                         if (!is.null(pattern)) {
[13:23:33.959]                           computeRestarts <- base::computeRestarts
[13:23:33.959]                           grepl <- base::grepl
[13:23:33.959]                           restarts <- computeRestarts(cond)
[13:23:33.959]                           for (restart in restarts) {
[13:23:33.959]                             name <- restart$name
[13:23:33.959]                             if (is.null(name)) 
[13:23:33.959]                               next
[13:23:33.959]                             if (!grepl(pattern, name)) 
[13:23:33.959]                               next
[13:23:33.959]                             invokeRestart(restart)
[13:23:33.959]                             muffled <- TRUE
[13:23:33.959]                             break
[13:23:33.959]                           }
[13:23:33.959]                         }
[13:23:33.959]                       }
[13:23:33.959]                       invisible(muffled)
[13:23:33.959]                     }
[13:23:33.959]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.959]                   }
[13:23:33.959]                 }
[13:23:33.959]                 else {
[13:23:33.959]                   if (TRUE) {
[13:23:33.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.959]                     {
[13:23:33.959]                       inherits <- base::inherits
[13:23:33.959]                       invokeRestart <- base::invokeRestart
[13:23:33.959]                       is.null <- base::is.null
[13:23:33.959]                       muffled <- FALSE
[13:23:33.959]                       if (inherits(cond, "message")) {
[13:23:33.959]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.959]                         if (muffled) 
[13:23:33.959]                           invokeRestart("muffleMessage")
[13:23:33.959]                       }
[13:23:33.959]                       else if (inherits(cond, "warning")) {
[13:23:33.959]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.959]                         if (muffled) 
[13:23:33.959]                           invokeRestart("muffleWarning")
[13:23:33.959]                       }
[13:23:33.959]                       else if (inherits(cond, "condition")) {
[13:23:33.959]                         if (!is.null(pattern)) {
[13:23:33.959]                           computeRestarts <- base::computeRestarts
[13:23:33.959]                           grepl <- base::grepl
[13:23:33.959]                           restarts <- computeRestarts(cond)
[13:23:33.959]                           for (restart in restarts) {
[13:23:33.959]                             name <- restart$name
[13:23:33.959]                             if (is.null(name)) 
[13:23:33.959]                               next
[13:23:33.959]                             if (!grepl(pattern, name)) 
[13:23:33.959]                               next
[13:23:33.959]                             invokeRestart(restart)
[13:23:33.959]                             muffled <- TRUE
[13:23:33.959]                             break
[13:23:33.959]                           }
[13:23:33.959]                         }
[13:23:33.959]                       }
[13:23:33.959]                       invisible(muffled)
[13:23:33.959]                     }
[13:23:33.959]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.959]                   }
[13:23:33.959]                 }
[13:23:33.959]             }
[13:23:33.959]         }))
[13:23:33.959]     }, error = function(ex) {
[13:23:33.959]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.959]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.959]                 ...future.rng), started = ...future.startTime, 
[13:23:33.959]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.959]             version = "1.8"), class = "FutureResult")
[13:23:33.959]     }, finally = {
[13:23:33.959]         if (!identical(...future.workdir, getwd())) 
[13:23:33.959]             setwd(...future.workdir)
[13:23:33.959]         {
[13:23:33.959]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.959]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.959]             }
[13:23:33.959]             base::options(...future.oldOptions)
[13:23:33.959]             if (.Platform$OS.type == "windows") {
[13:23:33.959]                 old_names <- names(...future.oldEnvVars)
[13:23:33.959]                 envs <- base::Sys.getenv()
[13:23:33.959]                 names <- names(envs)
[13:23:33.959]                 common <- intersect(names, old_names)
[13:23:33.959]                 added <- setdiff(names, old_names)
[13:23:33.959]                 removed <- setdiff(old_names, names)
[13:23:33.959]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.959]                   envs[common]]
[13:23:33.959]                 NAMES <- toupper(changed)
[13:23:33.959]                 args <- list()
[13:23:33.959]                 for (kk in seq_along(NAMES)) {
[13:23:33.959]                   name <- changed[[kk]]
[13:23:33.959]                   NAME <- NAMES[[kk]]
[13:23:33.959]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.959]                     next
[13:23:33.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.959]                 }
[13:23:33.959]                 NAMES <- toupper(added)
[13:23:33.959]                 for (kk in seq_along(NAMES)) {
[13:23:33.959]                   name <- added[[kk]]
[13:23:33.959]                   NAME <- NAMES[[kk]]
[13:23:33.959]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.959]                     next
[13:23:33.959]                   args[[name]] <- ""
[13:23:33.959]                 }
[13:23:33.959]                 NAMES <- toupper(removed)
[13:23:33.959]                 for (kk in seq_along(NAMES)) {
[13:23:33.959]                   name <- removed[[kk]]
[13:23:33.959]                   NAME <- NAMES[[kk]]
[13:23:33.959]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.959]                     next
[13:23:33.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.959]                 }
[13:23:33.959]                 if (length(args) > 0) 
[13:23:33.959]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.959]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.959]             }
[13:23:33.959]             else {
[13:23:33.959]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.959]             }
[13:23:33.959]             {
[13:23:33.959]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.959]                   0L) {
[13:23:33.959]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.959]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.959]                   base::options(opts)
[13:23:33.959]                 }
[13:23:33.959]                 {
[13:23:33.959]                   {
[13:23:33.959]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:33.959]                     NULL
[13:23:33.959]                   }
[13:23:33.959]                   options(future.plan = NULL)
[13:23:33.959]                   if (is.na(NA_character_)) 
[13:23:33.959]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.959]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.959]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.959]                     envir = parent.frame()) 
[13:23:33.959]                   {
[13:23:33.959]                     default_workers <- missing(workers)
[13:23:33.959]                     if (is.function(workers)) 
[13:23:33.959]                       workers <- workers()
[13:23:33.959]                     workers <- structure(as.integer(workers), 
[13:23:33.959]                       class = class(workers))
[13:23:33.959]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.959]                       1L)
[13:23:33.959]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.959]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.959]                       if (default_workers) 
[13:23:33.959]                         supportsMulticore(warn = TRUE)
[13:23:33.959]                       return(sequential(..., envir = envir))
[13:23:33.959]                     }
[13:23:33.959]                     oopts <- options(mc.cores = workers)
[13:23:33.959]                     on.exit(options(oopts))
[13:23:33.959]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.959]                       envir = envir)
[13:23:33.959]                     if (!future$lazy) 
[13:23:33.959]                       future <- run(future)
[13:23:33.959]                     invisible(future)
[13:23:33.959]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.959]                 }
[13:23:33.959]             }
[13:23:33.959]         }
[13:23:33.959]     })
[13:23:33.959]     if (TRUE) {
[13:23:33.959]         base::sink(type = "output", split = FALSE)
[13:23:33.959]         if (TRUE) {
[13:23:33.959]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.959]         }
[13:23:33.959]         else {
[13:23:33.959]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.959]         }
[13:23:33.959]         base::close(...future.stdout)
[13:23:33.959]         ...future.stdout <- NULL
[13:23:33.959]     }
[13:23:33.959]     ...future.result$conditions <- ...future.conditions
[13:23:33.959]     ...future.result$finished <- base::Sys.time()
[13:23:33.959]     ...future.result
[13:23:33.959] }
[13:23:33.962] assign_globals() ...
[13:23:33.962] List of 1
[13:23:33.962]  $ x: num 1
[13:23:33.962]  - attr(*, "where")=List of 1
[13:23:33.962]   ..$ x:<environment: R_EmptyEnv> 
[13:23:33.962]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:33.962]  - attr(*, "resolved")= logi TRUE
[13:23:33.962]  - attr(*, "total_size")= num 56
[13:23:33.962]  - attr(*, "already-done")= logi TRUE
[13:23:33.966] - copied ‘x’ to environment
[13:23:33.966] assign_globals() ... done
[13:23:33.966] requestCore(): workers = 2
[13:23:33.969] MulticoreFuture started
[13:23:33.970] - Launch lazy future ... done
[13:23:33.970] plan(): Setting new future strategy stack:
[13:23:33.970] run() for ‘MulticoreFuture’ ... done
[13:23:33.971] result() for MulticoreFuture ...
[13:23:33.970] List of future strategies:
[13:23:33.970] 1. sequential:
[13:23:33.970]    - args: function (..., envir = parent.frame())
[13:23:33.970]    - tweaked: FALSE
[13:23:33.970]    - call: NULL
[13:23:33.972] plan(): nbrOfWorkers() = 1
[13:23:33.974] plan(): Setting new future strategy stack:
[13:23:33.974] List of future strategies:
[13:23:33.974] 1. multicore:
[13:23:33.974]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:33.974]    - tweaked: FALSE
[13:23:33.974]    - call: plan(strategy)
[13:23:33.980] plan(): nbrOfWorkers() = 2
[13:23:33.981] result() for MulticoreFuture ...
[13:23:33.982] result() for MulticoreFuture ... done
[13:23:33.982] result() for MulticoreFuture ... done
[13:23:33.982] result() for MulticoreFuture ...
[13:23:33.982] result() for MulticoreFuture ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:33.983] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:33.983] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:33.986] - globals found: [3] ‘{’, ‘<-’, ‘x’
[13:23:33.986] Searching for globals ... DONE
[13:23:33.986] Resolving globals: TRUE
[13:23:33.986] Resolving any globals that are futures ...
[13:23:33.987] - globals: [3] ‘{’, ‘<-’, ‘x’
[13:23:33.987] Resolving any globals that are futures ... DONE
[13:23:33.987] Resolving futures part of globals (recursively) ...
[13:23:33.987] resolve() on list ...
[13:23:33.988]  recursive: 99
[13:23:33.988]  length: 1
[13:23:33.988]  elements: ‘x’
[13:23:33.988]  length: 0 (resolved future 1)
[13:23:33.988] resolve() on list ... DONE
[13:23:33.988] - globals: [1] ‘x’
[13:23:33.988] Resolving futures part of globals (recursively) ... DONE
[13:23:33.989] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[13:23:33.989] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[13:23:33.989] - globals: [1] ‘x’
[13:23:33.989] 
[13:23:33.990] getGlobalsAndPackages() ... DONE
[13:23:33.990] run() for ‘Future’ ...
[13:23:33.990] - state: ‘created’
[13:23:33.990] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:33.995] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:33.995] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:33.995]   - Field: ‘label’
[13:23:33.995]   - Field: ‘local’
[13:23:33.995]   - Field: ‘owner’
[13:23:33.995]   - Field: ‘envir’
[13:23:33.995]   - Field: ‘workers’
[13:23:33.996]   - Field: ‘packages’
[13:23:33.996]   - Field: ‘gc’
[13:23:33.996]   - Field: ‘job’
[13:23:33.996]   - Field: ‘conditions’
[13:23:33.996]   - Field: ‘expr’
[13:23:33.996]   - Field: ‘uuid’
[13:23:33.996]   - Field: ‘seed’
[13:23:33.996]   - Field: ‘version’
[13:23:33.997]   - Field: ‘result’
[13:23:33.997]   - Field: ‘asynchronous’
[13:23:33.997]   - Field: ‘calls’
[13:23:33.997]   - Field: ‘globals’
[13:23:33.997]   - Field: ‘stdout’
[13:23:33.997]   - Field: ‘earlySignal’
[13:23:33.997]   - Field: ‘lazy’
[13:23:33.997]   - Field: ‘state’
[13:23:33.998] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:33.998] - Launch lazy future ...
[13:23:33.998] Packages needed by the future expression (n = 0): <none>
[13:23:33.998] Packages needed by future strategies (n = 0): <none>
[13:23:33.999] {
[13:23:33.999]     {
[13:23:33.999]         {
[13:23:33.999]             ...future.startTime <- base::Sys.time()
[13:23:33.999]             {
[13:23:33.999]                 {
[13:23:33.999]                   {
[13:23:33.999]                     {
[13:23:33.999]                       base::local({
[13:23:33.999]                         has_future <- base::requireNamespace("future", 
[13:23:33.999]                           quietly = TRUE)
[13:23:33.999]                         if (has_future) {
[13:23:33.999]                           ns <- base::getNamespace("future")
[13:23:33.999]                           version <- ns[[".package"]][["version"]]
[13:23:33.999]                           if (is.null(version)) 
[13:23:33.999]                             version <- utils::packageVersion("future")
[13:23:33.999]                         }
[13:23:33.999]                         else {
[13:23:33.999]                           version <- NULL
[13:23:33.999]                         }
[13:23:33.999]                         if (!has_future || version < "1.8.0") {
[13:23:33.999]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:33.999]                             "", base::R.version$version.string), 
[13:23:33.999]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:33.999]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:33.999]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:33.999]                               "release", "version")], collapse = " "), 
[13:23:33.999]                             hostname = base::Sys.info()[["nodename"]])
[13:23:33.999]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:33.999]                             info)
[13:23:33.999]                           info <- base::paste(info, collapse = "; ")
[13:23:33.999]                           if (!has_future) {
[13:23:33.999]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:33.999]                               info)
[13:23:33.999]                           }
[13:23:33.999]                           else {
[13:23:33.999]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:33.999]                               info, version)
[13:23:33.999]                           }
[13:23:33.999]                           base::stop(msg)
[13:23:33.999]                         }
[13:23:33.999]                       })
[13:23:33.999]                     }
[13:23:33.999]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:33.999]                     base::options(mc.cores = 1L)
[13:23:33.999]                   }
[13:23:33.999]                   options(future.plan = NULL)
[13:23:33.999]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.999]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:33.999]                 }
[13:23:33.999]                 ...future.workdir <- getwd()
[13:23:33.999]             }
[13:23:33.999]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:33.999]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:33.999]         }
[13:23:33.999]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:33.999]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:33.999]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:33.999]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:33.999]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:33.999]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:33.999]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:33.999]             base::names(...future.oldOptions))
[13:23:33.999]     }
[13:23:33.999]     if (FALSE) {
[13:23:33.999]     }
[13:23:33.999]     else {
[13:23:33.999]         if (TRUE) {
[13:23:33.999]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:33.999]                 open = "w")
[13:23:33.999]         }
[13:23:33.999]         else {
[13:23:33.999]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:33.999]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:33.999]         }
[13:23:33.999]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:33.999]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:33.999]             base::sink(type = "output", split = FALSE)
[13:23:33.999]             base::close(...future.stdout)
[13:23:33.999]         }, add = TRUE)
[13:23:33.999]     }
[13:23:33.999]     ...future.frame <- base::sys.nframe()
[13:23:33.999]     ...future.conditions <- base::list()
[13:23:33.999]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:33.999]     if (FALSE) {
[13:23:33.999]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:33.999]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:33.999]     }
[13:23:33.999]     ...future.result <- base::tryCatch({
[13:23:33.999]         base::withCallingHandlers({
[13:23:33.999]             ...future.value <- base::withVisible(base::local({
[13:23:33.999]                 withCallingHandlers({
[13:23:33.999]                   {
[13:23:33.999]                     x <- x()
[13:23:33.999]                     x
[13:23:33.999]                   }
[13:23:33.999]                 }, immediateCondition = function(cond) {
[13:23:33.999]                   save_rds <- function (object, pathname, ...) 
[13:23:33.999]                   {
[13:23:33.999]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:33.999]                     if (file_test("-f", pathname_tmp)) {
[13:23:33.999]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.999]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:33.999]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.999]                         fi_tmp[["mtime"]])
[13:23:33.999]                     }
[13:23:33.999]                     tryCatch({
[13:23:33.999]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:33.999]                     }, error = function(ex) {
[13:23:33.999]                       msg <- conditionMessage(ex)
[13:23:33.999]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.999]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:33.999]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.999]                         fi_tmp[["mtime"]], msg)
[13:23:33.999]                       ex$message <- msg
[13:23:33.999]                       stop(ex)
[13:23:33.999]                     })
[13:23:33.999]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:33.999]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:33.999]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:33.999]                       fi_tmp <- file.info(pathname_tmp)
[13:23:33.999]                       fi <- file.info(pathname)
[13:23:33.999]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:33.999]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:33.999]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:33.999]                         fi[["size"]], fi[["mtime"]])
[13:23:33.999]                       stop(msg)
[13:23:33.999]                     }
[13:23:33.999]                     invisible(pathname)
[13:23:33.999]                   }
[13:23:33.999]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:33.999]                     rootPath = tempdir()) 
[13:23:33.999]                   {
[13:23:33.999]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:33.999]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:33.999]                       tmpdir = path, fileext = ".rds")
[13:23:33.999]                     save_rds(obj, file)
[13:23:33.999]                   }
[13:23:33.999]                   saveImmediateCondition(cond, path = "/tmp/RtmpKyIYu7/.future/immediateConditions")
[13:23:33.999]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.999]                   {
[13:23:33.999]                     inherits <- base::inherits
[13:23:33.999]                     invokeRestart <- base::invokeRestart
[13:23:33.999]                     is.null <- base::is.null
[13:23:33.999]                     muffled <- FALSE
[13:23:33.999]                     if (inherits(cond, "message")) {
[13:23:33.999]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:33.999]                       if (muffled) 
[13:23:33.999]                         invokeRestart("muffleMessage")
[13:23:33.999]                     }
[13:23:33.999]                     else if (inherits(cond, "warning")) {
[13:23:33.999]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:33.999]                       if (muffled) 
[13:23:33.999]                         invokeRestart("muffleWarning")
[13:23:33.999]                     }
[13:23:33.999]                     else if (inherits(cond, "condition")) {
[13:23:33.999]                       if (!is.null(pattern)) {
[13:23:33.999]                         computeRestarts <- base::computeRestarts
[13:23:33.999]                         grepl <- base::grepl
[13:23:33.999]                         restarts <- computeRestarts(cond)
[13:23:33.999]                         for (restart in restarts) {
[13:23:33.999]                           name <- restart$name
[13:23:33.999]                           if (is.null(name)) 
[13:23:33.999]                             next
[13:23:33.999]                           if (!grepl(pattern, name)) 
[13:23:33.999]                             next
[13:23:33.999]                           invokeRestart(restart)
[13:23:33.999]                           muffled <- TRUE
[13:23:33.999]                           break
[13:23:33.999]                         }
[13:23:33.999]                       }
[13:23:33.999]                     }
[13:23:33.999]                     invisible(muffled)
[13:23:33.999]                   }
[13:23:33.999]                   muffleCondition(cond)
[13:23:33.999]                 })
[13:23:33.999]             }))
[13:23:33.999]             future::FutureResult(value = ...future.value$value, 
[13:23:33.999]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.999]                   ...future.rng), globalenv = if (FALSE) 
[13:23:33.999]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:33.999]                     ...future.globalenv.names))
[13:23:33.999]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:33.999]         }, condition = base::local({
[13:23:33.999]             c <- base::c
[13:23:33.999]             inherits <- base::inherits
[13:23:33.999]             invokeRestart <- base::invokeRestart
[13:23:33.999]             length <- base::length
[13:23:33.999]             list <- base::list
[13:23:33.999]             seq.int <- base::seq.int
[13:23:33.999]             signalCondition <- base::signalCondition
[13:23:33.999]             sys.calls <- base::sys.calls
[13:23:33.999]             `[[` <- base::`[[`
[13:23:33.999]             `+` <- base::`+`
[13:23:33.999]             `<<-` <- base::`<<-`
[13:23:33.999]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:33.999]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:33.999]                   3L)]
[13:23:33.999]             }
[13:23:33.999]             function(cond) {
[13:23:33.999]                 is_error <- inherits(cond, "error")
[13:23:33.999]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:33.999]                   NULL)
[13:23:33.999]                 if (is_error) {
[13:23:33.999]                   sessionInformation <- function() {
[13:23:33.999]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:33.999]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:33.999]                       search = base::search(), system = base::Sys.info())
[13:23:33.999]                   }
[13:23:33.999]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.999]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:33.999]                     cond$call), session = sessionInformation(), 
[13:23:33.999]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:33.999]                   signalCondition(cond)
[13:23:33.999]                 }
[13:23:33.999]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:33.999]                 "immediateCondition"))) {
[13:23:33.999]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:33.999]                   ...future.conditions[[length(...future.conditions) + 
[13:23:33.999]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:33.999]                   if (TRUE && !signal) {
[13:23:33.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.999]                     {
[13:23:33.999]                       inherits <- base::inherits
[13:23:33.999]                       invokeRestart <- base::invokeRestart
[13:23:33.999]                       is.null <- base::is.null
[13:23:33.999]                       muffled <- FALSE
[13:23:33.999]                       if (inherits(cond, "message")) {
[13:23:33.999]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.999]                         if (muffled) 
[13:23:33.999]                           invokeRestart("muffleMessage")
[13:23:33.999]                       }
[13:23:33.999]                       else if (inherits(cond, "warning")) {
[13:23:33.999]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.999]                         if (muffled) 
[13:23:33.999]                           invokeRestart("muffleWarning")
[13:23:33.999]                       }
[13:23:33.999]                       else if (inherits(cond, "condition")) {
[13:23:33.999]                         if (!is.null(pattern)) {
[13:23:33.999]                           computeRestarts <- base::computeRestarts
[13:23:33.999]                           grepl <- base::grepl
[13:23:33.999]                           restarts <- computeRestarts(cond)
[13:23:33.999]                           for (restart in restarts) {
[13:23:33.999]                             name <- restart$name
[13:23:33.999]                             if (is.null(name)) 
[13:23:33.999]                               next
[13:23:33.999]                             if (!grepl(pattern, name)) 
[13:23:33.999]                               next
[13:23:33.999]                             invokeRestart(restart)
[13:23:33.999]                             muffled <- TRUE
[13:23:33.999]                             break
[13:23:33.999]                           }
[13:23:33.999]                         }
[13:23:33.999]                       }
[13:23:33.999]                       invisible(muffled)
[13:23:33.999]                     }
[13:23:33.999]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.999]                   }
[13:23:33.999]                 }
[13:23:33.999]                 else {
[13:23:33.999]                   if (TRUE) {
[13:23:33.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:33.999]                     {
[13:23:33.999]                       inherits <- base::inherits
[13:23:33.999]                       invokeRestart <- base::invokeRestart
[13:23:33.999]                       is.null <- base::is.null
[13:23:33.999]                       muffled <- FALSE
[13:23:33.999]                       if (inherits(cond, "message")) {
[13:23:33.999]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:33.999]                         if (muffled) 
[13:23:33.999]                           invokeRestart("muffleMessage")
[13:23:33.999]                       }
[13:23:33.999]                       else if (inherits(cond, "warning")) {
[13:23:33.999]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:33.999]                         if (muffled) 
[13:23:33.999]                           invokeRestart("muffleWarning")
[13:23:33.999]                       }
[13:23:33.999]                       else if (inherits(cond, "condition")) {
[13:23:33.999]                         if (!is.null(pattern)) {
[13:23:33.999]                           computeRestarts <- base::computeRestarts
[13:23:33.999]                           grepl <- base::grepl
[13:23:33.999]                           restarts <- computeRestarts(cond)
[13:23:33.999]                           for (restart in restarts) {
[13:23:33.999]                             name <- restart$name
[13:23:33.999]                             if (is.null(name)) 
[13:23:33.999]                               next
[13:23:33.999]                             if (!grepl(pattern, name)) 
[13:23:33.999]                               next
[13:23:33.999]                             invokeRestart(restart)
[13:23:33.999]                             muffled <- TRUE
[13:23:33.999]                             break
[13:23:33.999]                           }
[13:23:33.999]                         }
[13:23:33.999]                       }
[13:23:33.999]                       invisible(muffled)
[13:23:33.999]                     }
[13:23:33.999]                     muffleCondition(cond, pattern = "^muffle")
[13:23:33.999]                   }
[13:23:33.999]                 }
[13:23:33.999]             }
[13:23:33.999]         }))
[13:23:33.999]     }, error = function(ex) {
[13:23:33.999]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:33.999]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:33.999]                 ...future.rng), started = ...future.startTime, 
[13:23:33.999]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:33.999]             version = "1.8"), class = "FutureResult")
[13:23:33.999]     }, finally = {
[13:23:33.999]         if (!identical(...future.workdir, getwd())) 
[13:23:33.999]             setwd(...future.workdir)
[13:23:33.999]         {
[13:23:33.999]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:33.999]                 ...future.oldOptions$nwarnings <- NULL
[13:23:33.999]             }
[13:23:33.999]             base::options(...future.oldOptions)
[13:23:33.999]             if (.Platform$OS.type == "windows") {
[13:23:33.999]                 old_names <- names(...future.oldEnvVars)
[13:23:33.999]                 envs <- base::Sys.getenv()
[13:23:33.999]                 names <- names(envs)
[13:23:33.999]                 common <- intersect(names, old_names)
[13:23:33.999]                 added <- setdiff(names, old_names)
[13:23:33.999]                 removed <- setdiff(old_names, names)
[13:23:33.999]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:33.999]                   envs[common]]
[13:23:33.999]                 NAMES <- toupper(changed)
[13:23:33.999]                 args <- list()
[13:23:33.999]                 for (kk in seq_along(NAMES)) {
[13:23:33.999]                   name <- changed[[kk]]
[13:23:33.999]                   NAME <- NAMES[[kk]]
[13:23:33.999]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.999]                     next
[13:23:33.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.999]                 }
[13:23:33.999]                 NAMES <- toupper(added)
[13:23:33.999]                 for (kk in seq_along(NAMES)) {
[13:23:33.999]                   name <- added[[kk]]
[13:23:33.999]                   NAME <- NAMES[[kk]]
[13:23:33.999]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.999]                     next
[13:23:33.999]                   args[[name]] <- ""
[13:23:33.999]                 }
[13:23:33.999]                 NAMES <- toupper(removed)
[13:23:33.999]                 for (kk in seq_along(NAMES)) {
[13:23:33.999]                   name <- removed[[kk]]
[13:23:33.999]                   NAME <- NAMES[[kk]]
[13:23:33.999]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:33.999]                     next
[13:23:33.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:33.999]                 }
[13:23:33.999]                 if (length(args) > 0) 
[13:23:33.999]                   base::do.call(base::Sys.setenv, args = args)
[13:23:33.999]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:33.999]             }
[13:23:33.999]             else {
[13:23:33.999]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:33.999]             }
[13:23:33.999]             {
[13:23:33.999]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:33.999]                   0L) {
[13:23:33.999]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:33.999]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:33.999]                   base::options(opts)
[13:23:33.999]                 }
[13:23:33.999]                 {
[13:23:33.999]                   {
[13:23:33.999]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:33.999]                     NULL
[13:23:33.999]                   }
[13:23:33.999]                   options(future.plan = NULL)
[13:23:33.999]                   if (is.na(NA_character_)) 
[13:23:33.999]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:33.999]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:33.999]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:33.999]                     envir = parent.frame()) 
[13:23:33.999]                   {
[13:23:33.999]                     default_workers <- missing(workers)
[13:23:33.999]                     if (is.function(workers)) 
[13:23:33.999]                       workers <- workers()
[13:23:33.999]                     workers <- structure(as.integer(workers), 
[13:23:33.999]                       class = class(workers))
[13:23:33.999]                     stop_if_not(is.finite(workers), workers >= 
[13:23:33.999]                       1L)
[13:23:33.999]                     if ((workers == 1L && !inherits(workers, 
[13:23:33.999]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:33.999]                       if (default_workers) 
[13:23:33.999]                         supportsMulticore(warn = TRUE)
[13:23:33.999]                       return(sequential(..., envir = envir))
[13:23:33.999]                     }
[13:23:33.999]                     oopts <- options(mc.cores = workers)
[13:23:33.999]                     on.exit(options(oopts))
[13:23:33.999]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:33.999]                       envir = envir)
[13:23:33.999]                     if (!future$lazy) 
[13:23:33.999]                       future <- run(future)
[13:23:33.999]                     invisible(future)
[13:23:33.999]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:33.999]                 }
[13:23:33.999]             }
[13:23:33.999]         }
[13:23:33.999]     })
[13:23:33.999]     if (TRUE) {
[13:23:33.999]         base::sink(type = "output", split = FALSE)
[13:23:33.999]         if (TRUE) {
[13:23:33.999]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:33.999]         }
[13:23:33.999]         else {
[13:23:33.999]             ...future.result["stdout"] <- base::list(NULL)
[13:23:33.999]         }
[13:23:33.999]         base::close(...future.stdout)
[13:23:33.999]         ...future.stdout <- NULL
[13:23:33.999]     }
[13:23:33.999]     ...future.result$conditions <- ...future.conditions
[13:23:33.999]     ...future.result$finished <- base::Sys.time()
[13:23:33.999]     ...future.result
[13:23:33.999] }
[13:23:34.002] assign_globals() ...
[13:23:34.002] List of 1
[13:23:34.002]  $ x:function ()  
[13:23:34.002]  - attr(*, "where")=List of 1
[13:23:34.002]   ..$ x:<environment: R_EmptyEnv> 
[13:23:34.002]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:34.002]  - attr(*, "resolved")= logi TRUE
[13:23:34.002]  - attr(*, "total_size")= num 1032
[13:23:34.002]  - attr(*, "already-done")= logi TRUE
[13:23:34.008] - reassign environment for ‘x’
[13:23:34.008] - copied ‘x’ to environment
[13:23:34.009] assign_globals() ... done
[13:23:34.009] requestCore(): workers = 2
[13:23:34.011] MulticoreFuture started
[13:23:34.012] - Launch lazy future ... done
[13:23:34.012] run() for ‘MulticoreFuture’ ... done
[13:23:34.013] result() for MulticoreFuture ...
[13:23:34.013] plan(): Setting new future strategy stack:
[13:23:34.013] List of future strategies:
[13:23:34.013] 1. sequential:
[13:23:34.013]    - args: function (..., envir = parent.frame())
[13:23:34.013]    - tweaked: FALSE
[13:23:34.013]    - call: NULL
[13:23:34.014] plan(): nbrOfWorkers() = 1
[13:23:34.018] plan(): Setting new future strategy stack:
[13:23:34.018] List of future strategies:
[13:23:34.018] 1. multicore:
[13:23:34.018]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:34.018]    - tweaked: FALSE
[13:23:34.018]    - call: plan(strategy)
[13:23:34.025] plan(): nbrOfWorkers() = 2
[13:23:34.027] result() for MulticoreFuture ...
[13:23:34.027] result() for MulticoreFuture ... done
[13:23:34.027] result() for MulticoreFuture ... done
[13:23:34.028] result() for MulticoreFuture ...
[13:23:34.028] result() for MulticoreFuture ... done
value(f) = ‘TRUE’
- plan('multisession') ...
[13:23:34.029] plan(): Setting new future strategy stack:
[13:23:34.029] List of future strategies:
[13:23:34.029] 1. multisession:
[13:23:34.029]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:23:34.029]    - tweaked: FALSE
[13:23:34.029]    - call: plan(strategy)
[13:23:34.030] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:23:34.030] multisession:
[13:23:34.030] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:23:34.030] - tweaked: FALSE
[13:23:34.030] - call: plan(strategy)
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:34.038] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:34.039] Not searching for globals
[13:23:34.039] - globals: [0] <none>
[13:23:34.039] getGlobalsAndPackages() ... DONE
[13:23:34.040] [local output] makeClusterPSOCK() ...
[13:23:34.092] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:23:34.094] [local output] Base port: 11691
[13:23:34.094] [local output] Getting setup options for 2 cluster nodes ...
[13:23:34.094] [local output]  - Node 1 of 2 ...
[13:23:34.094] [local output] localMachine=TRUE => revtunnel=FALSE

[13:23:34.095] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpKyIYu7/worker.rank=1.parallelly.parent=87308.1550c3ae7e6e9.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpKyIYu7/worker.rank=1.parallelly.parent=87308.1550c3ae7e6e9.pid")'’
[13:23:34.290] - Possible to infer worker's PID: TRUE
[13:23:34.290] [local output] Rscript port: 11691

[13:23:34.291] [local output]  - Node 2 of 2 ...
[13:23:34.291] [local output] localMachine=TRUE => revtunnel=FALSE

[13:23:34.292] [local output] Rscript port: 11691

[13:23:34.292] [local output] Getting setup options for 2 cluster nodes ... done
[13:23:34.292] [local output]  - Parallel setup requested for some PSOCK nodes
[13:23:34.293] [local output] Setting up PSOCK nodes in parallel
[13:23:34.293] List of 36
[13:23:34.293]  $ worker          : chr "localhost"
[13:23:34.293]   ..- attr(*, "localhost")= logi TRUE
[13:23:34.293]  $ master          : chr "localhost"
[13:23:34.293]  $ port            : int 11691
[13:23:34.293]  $ connectTimeout  : num 120
[13:23:34.293]  $ timeout         : num 2592000
[13:23:34.293]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:23:34.293]  $ homogeneous     : logi TRUE
[13:23:34.293]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:23:34.293]  $ rscript_envs    : NULL
[13:23:34.293]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:23:34.293]  $ rscript_startup : NULL
[13:23:34.293]  $ rscript_sh      : chr "sh"
[13:23:34.293]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:23:34.293]  $ methods         : logi TRUE
[13:23:34.293]  $ socketOptions   : chr "no-delay"
[13:23:34.293]  $ useXDR          : logi FALSE
[13:23:34.293]  $ outfile         : chr "/dev/null"
[13:23:34.293]  $ renice          : int NA
[13:23:34.293]  $ rshcmd          : NULL
[13:23:34.293]  $ user            : chr(0) 
[13:23:34.293]  $ revtunnel       : logi FALSE
[13:23:34.293]  $ rshlogfile      : NULL
[13:23:34.293]  $ rshopts         : chr(0) 
[13:23:34.293]  $ rank            : int 1
[13:23:34.293]  $ manual          : logi FALSE
[13:23:34.293]  $ dryrun          : logi FALSE
[13:23:34.293]  $ quiet           : logi FALSE
[13:23:34.293]  $ setup_strategy  : chr "parallel"
[13:23:34.293]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:23:34.293]  $ pidfile         : chr "/tmp/RtmpKyIYu7/worker.rank=1.parallelly.parent=87308.1550c3ae7e6e9.pid"
[13:23:34.293]  $ rshcmd_label    : NULL
[13:23:34.293]  $ rsh_call        : NULL
[13:23:34.293]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:23:34.293]  $ localMachine    : logi TRUE
[13:23:34.293]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:23:34.293]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:23:34.293]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:23:34.293]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:23:34.293]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:23:34.293]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:23:34.293]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:23:34.293]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:23:34.293]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:23:34.293]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:23:34.293]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:23:34.293]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:23:34.293]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:23:34.293]  $ arguments       :List of 28
[13:23:34.293]   ..$ worker          : chr "localhost"
[13:23:34.293]   ..$ master          : NULL
[13:23:34.293]   ..$ port            : int 11691
[13:23:34.293]   ..$ connectTimeout  : num 120
[13:23:34.293]   ..$ timeout         : num 2592000
[13:23:34.293]   ..$ rscript         : NULL
[13:23:34.293]   ..$ homogeneous     : NULL
[13:23:34.293]   ..$ rscript_args    : NULL
[13:23:34.293]   ..$ rscript_envs    : NULL
[13:23:34.293]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:23:34.293]   ..$ rscript_startup : NULL
[13:23:34.293]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:23:34.293]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:23:34.293]   ..$ methods         : logi TRUE
[13:23:34.293]   ..$ socketOptions   : chr "no-delay"
[13:23:34.293]   ..$ useXDR          : logi FALSE
[13:23:34.293]   ..$ outfile         : chr "/dev/null"
[13:23:34.293]   ..$ renice          : int NA
[13:23:34.293]   ..$ rshcmd          : NULL
[13:23:34.293]   ..$ user            : NULL
[13:23:34.293]   ..$ revtunnel       : logi NA
[13:23:34.293]   ..$ rshlogfile      : NULL
[13:23:34.293]   ..$ rshopts         : NULL
[13:23:34.293]   ..$ rank            : int 1
[13:23:34.293]   ..$ manual          : logi FALSE
[13:23:34.293]   ..$ dryrun          : logi FALSE
[13:23:34.293]   ..$ quiet           : logi FALSE
[13:23:34.293]   ..$ setup_strategy  : chr "parallel"
[13:23:34.293]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:23:34.310] [local output] System call to launch all workers:
[13:23:34.310] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpKyIYu7/worker.rank=1.parallelly.parent=87308.1550c3ae7e6e9.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11691 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:23:34.310] [local output] Starting PSOCK main server
[13:23:34.316] [local output] Workers launched
[13:23:34.316] [local output] Waiting for workers to connect back
[13:23:34.317]  - [local output] 0 workers out of 2 ready
[13:23:34.585]  - [local output] 0 workers out of 2 ready
[13:23:34.586]  - [local output] 1 workers out of 2 ready
[13:23:34.588]  - [local output] 1 workers out of 2 ready
[13:23:34.589]  - [local output] 2 workers out of 2 ready
[13:23:34.589] [local output] Launching of workers completed
[13:23:34.589] [local output] Collecting session information from workers
[13:23:34.590] [local output]  - Worker #1 of 2
[13:23:34.590] [local output]  - Worker #2 of 2
[13:23:34.591] [local output] makeClusterPSOCK() ... done
[13:23:34.602] Packages needed by the future expression (n = 0): <none>
[13:23:34.602] Packages needed by future strategies (n = 0): <none>
[13:23:34.603] {
[13:23:34.603]     {
[13:23:34.603]         {
[13:23:34.603]             ...future.startTime <- base::Sys.time()
[13:23:34.603]             {
[13:23:34.603]                 {
[13:23:34.603]                   {
[13:23:34.603]                     {
[13:23:34.603]                       base::local({
[13:23:34.603]                         has_future <- base::requireNamespace("future", 
[13:23:34.603]                           quietly = TRUE)
[13:23:34.603]                         if (has_future) {
[13:23:34.603]                           ns <- base::getNamespace("future")
[13:23:34.603]                           version <- ns[[".package"]][["version"]]
[13:23:34.603]                           if (is.null(version)) 
[13:23:34.603]                             version <- utils::packageVersion("future")
[13:23:34.603]                         }
[13:23:34.603]                         else {
[13:23:34.603]                           version <- NULL
[13:23:34.603]                         }
[13:23:34.603]                         if (!has_future || version < "1.8.0") {
[13:23:34.603]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:34.603]                             "", base::R.version$version.string), 
[13:23:34.603]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:34.603]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:34.603]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:34.603]                               "release", "version")], collapse = " "), 
[13:23:34.603]                             hostname = base::Sys.info()[["nodename"]])
[13:23:34.603]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:34.603]                             info)
[13:23:34.603]                           info <- base::paste(info, collapse = "; ")
[13:23:34.603]                           if (!has_future) {
[13:23:34.603]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:34.603]                               info)
[13:23:34.603]                           }
[13:23:34.603]                           else {
[13:23:34.603]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:34.603]                               info, version)
[13:23:34.603]                           }
[13:23:34.603]                           base::stop(msg)
[13:23:34.603]                         }
[13:23:34.603]                       })
[13:23:34.603]                     }
[13:23:34.603]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:34.603]                     base::options(mc.cores = 1L)
[13:23:34.603]                   }
[13:23:34.603]                   options(future.plan = NULL)
[13:23:34.603]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:34.603]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:34.603]                 }
[13:23:34.603]                 ...future.workdir <- getwd()
[13:23:34.603]             }
[13:23:34.603]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:34.603]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:34.603]         }
[13:23:34.603]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:34.603]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:34.603]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:34.603]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:34.603]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:34.603]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:34.603]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:34.603]             base::names(...future.oldOptions))
[13:23:34.603]     }
[13:23:34.603]     if (FALSE) {
[13:23:34.603]     }
[13:23:34.603]     else {
[13:23:34.603]         if (TRUE) {
[13:23:34.603]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:34.603]                 open = "w")
[13:23:34.603]         }
[13:23:34.603]         else {
[13:23:34.603]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:34.603]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:34.603]         }
[13:23:34.603]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:34.603]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:34.603]             base::sink(type = "output", split = FALSE)
[13:23:34.603]             base::close(...future.stdout)
[13:23:34.603]         }, add = TRUE)
[13:23:34.603]     }
[13:23:34.603]     ...future.frame <- base::sys.nframe()
[13:23:34.603]     ...future.conditions <- base::list()
[13:23:34.603]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:34.603]     if (FALSE) {
[13:23:34.603]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:34.603]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:34.603]     }
[13:23:34.603]     ...future.result <- base::tryCatch({
[13:23:34.603]         base::withCallingHandlers({
[13:23:34.603]             ...future.value <- base::withVisible(base::local({
[13:23:34.603]                 ...future.makeSendCondition <- base::local({
[13:23:34.603]                   sendCondition <- NULL
[13:23:34.603]                   function(frame = 1L) {
[13:23:34.603]                     if (is.function(sendCondition)) 
[13:23:34.603]                       return(sendCondition)
[13:23:34.603]                     ns <- getNamespace("parallel")
[13:23:34.603]                     if (exists("sendData", mode = "function", 
[13:23:34.603]                       envir = ns)) {
[13:23:34.603]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:34.603]                         envir = ns)
[13:23:34.603]                       envir <- sys.frame(frame)
[13:23:34.603]                       master <- NULL
[13:23:34.603]                       while (!identical(envir, .GlobalEnv) && 
[13:23:34.603]                         !identical(envir, emptyenv())) {
[13:23:34.603]                         if (exists("master", mode = "list", envir = envir, 
[13:23:34.603]                           inherits = FALSE)) {
[13:23:34.603]                           master <- get("master", mode = "list", 
[13:23:34.603]                             envir = envir, inherits = FALSE)
[13:23:34.603]                           if (inherits(master, c("SOCKnode", 
[13:23:34.603]                             "SOCK0node"))) {
[13:23:34.603]                             sendCondition <<- function(cond) {
[13:23:34.603]                               data <- list(type = "VALUE", value = cond, 
[13:23:34.603]                                 success = TRUE)
[13:23:34.603]                               parallel_sendData(master, data)
[13:23:34.603]                             }
[13:23:34.603]                             return(sendCondition)
[13:23:34.603]                           }
[13:23:34.603]                         }
[13:23:34.603]                         frame <- frame + 1L
[13:23:34.603]                         envir <- sys.frame(frame)
[13:23:34.603]                       }
[13:23:34.603]                     }
[13:23:34.603]                     sendCondition <<- function(cond) NULL
[13:23:34.603]                   }
[13:23:34.603]                 })
[13:23:34.603]                 withCallingHandlers({
[13:23:34.603]                   NA
[13:23:34.603]                 }, immediateCondition = function(cond) {
[13:23:34.603]                   sendCondition <- ...future.makeSendCondition()
[13:23:34.603]                   sendCondition(cond)
[13:23:34.603]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:34.603]                   {
[13:23:34.603]                     inherits <- base::inherits
[13:23:34.603]                     invokeRestart <- base::invokeRestart
[13:23:34.603]                     is.null <- base::is.null
[13:23:34.603]                     muffled <- FALSE
[13:23:34.603]                     if (inherits(cond, "message")) {
[13:23:34.603]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:34.603]                       if (muffled) 
[13:23:34.603]                         invokeRestart("muffleMessage")
[13:23:34.603]                     }
[13:23:34.603]                     else if (inherits(cond, "warning")) {
[13:23:34.603]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:34.603]                       if (muffled) 
[13:23:34.603]                         invokeRestart("muffleWarning")
[13:23:34.603]                     }
[13:23:34.603]                     else if (inherits(cond, "condition")) {
[13:23:34.603]                       if (!is.null(pattern)) {
[13:23:34.603]                         computeRestarts <- base::computeRestarts
[13:23:34.603]                         grepl <- base::grepl
[13:23:34.603]                         restarts <- computeRestarts(cond)
[13:23:34.603]                         for (restart in restarts) {
[13:23:34.603]                           name <- restart$name
[13:23:34.603]                           if (is.null(name)) 
[13:23:34.603]                             next
[13:23:34.603]                           if (!grepl(pattern, name)) 
[13:23:34.603]                             next
[13:23:34.603]                           invokeRestart(restart)
[13:23:34.603]                           muffled <- TRUE
[13:23:34.603]                           break
[13:23:34.603]                         }
[13:23:34.603]                       }
[13:23:34.603]                     }
[13:23:34.603]                     invisible(muffled)
[13:23:34.603]                   }
[13:23:34.603]                   muffleCondition(cond)
[13:23:34.603]                 })
[13:23:34.603]             }))
[13:23:34.603]             future::FutureResult(value = ...future.value$value, 
[13:23:34.603]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:34.603]                   ...future.rng), globalenv = if (FALSE) 
[13:23:34.603]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:34.603]                     ...future.globalenv.names))
[13:23:34.603]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:34.603]         }, condition = base::local({
[13:23:34.603]             c <- base::c
[13:23:34.603]             inherits <- base::inherits
[13:23:34.603]             invokeRestart <- base::invokeRestart
[13:23:34.603]             length <- base::length
[13:23:34.603]             list <- base::list
[13:23:34.603]             seq.int <- base::seq.int
[13:23:34.603]             signalCondition <- base::signalCondition
[13:23:34.603]             sys.calls <- base::sys.calls
[13:23:34.603]             `[[` <- base::`[[`
[13:23:34.603]             `+` <- base::`+`
[13:23:34.603]             `<<-` <- base::`<<-`
[13:23:34.603]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:34.603]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:34.603]                   3L)]
[13:23:34.603]             }
[13:23:34.603]             function(cond) {
[13:23:34.603]                 is_error <- inherits(cond, "error")
[13:23:34.603]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:34.603]                   NULL)
[13:23:34.603]                 if (is_error) {
[13:23:34.603]                   sessionInformation <- function() {
[13:23:34.603]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:34.603]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:34.603]                       search = base::search(), system = base::Sys.info())
[13:23:34.603]                   }
[13:23:34.603]                   ...future.conditions[[length(...future.conditions) + 
[13:23:34.603]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:34.603]                     cond$call), session = sessionInformation(), 
[13:23:34.603]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:34.603]                   signalCondition(cond)
[13:23:34.603]                 }
[13:23:34.603]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:34.603]                 "immediateCondition"))) {
[13:23:34.603]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:34.603]                   ...future.conditions[[length(...future.conditions) + 
[13:23:34.603]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:34.603]                   if (TRUE && !signal) {
[13:23:34.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:34.603]                     {
[13:23:34.603]                       inherits <- base::inherits
[13:23:34.603]                       invokeRestart <- base::invokeRestart
[13:23:34.603]                       is.null <- base::is.null
[13:23:34.603]                       muffled <- FALSE
[13:23:34.603]                       if (inherits(cond, "message")) {
[13:23:34.603]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:34.603]                         if (muffled) 
[13:23:34.603]                           invokeRestart("muffleMessage")
[13:23:34.603]                       }
[13:23:34.603]                       else if (inherits(cond, "warning")) {
[13:23:34.603]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:34.603]                         if (muffled) 
[13:23:34.603]                           invokeRestart("muffleWarning")
[13:23:34.603]                       }
[13:23:34.603]                       else if (inherits(cond, "condition")) {
[13:23:34.603]                         if (!is.null(pattern)) {
[13:23:34.603]                           computeRestarts <- base::computeRestarts
[13:23:34.603]                           grepl <- base::grepl
[13:23:34.603]                           restarts <- computeRestarts(cond)
[13:23:34.603]                           for (restart in restarts) {
[13:23:34.603]                             name <- restart$name
[13:23:34.603]                             if (is.null(name)) 
[13:23:34.603]                               next
[13:23:34.603]                             if (!grepl(pattern, name)) 
[13:23:34.603]                               next
[13:23:34.603]                             invokeRestart(restart)
[13:23:34.603]                             muffled <- TRUE
[13:23:34.603]                             break
[13:23:34.603]                           }
[13:23:34.603]                         }
[13:23:34.603]                       }
[13:23:34.603]                       invisible(muffled)
[13:23:34.603]                     }
[13:23:34.603]                     muffleCondition(cond, pattern = "^muffle")
[13:23:34.603]                   }
[13:23:34.603]                 }
[13:23:34.603]                 else {
[13:23:34.603]                   if (TRUE) {
[13:23:34.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:34.603]                     {
[13:23:34.603]                       inherits <- base::inherits
[13:23:34.603]                       invokeRestart <- base::invokeRestart
[13:23:34.603]                       is.null <- base::is.null
[13:23:34.603]                       muffled <- FALSE
[13:23:34.603]                       if (inherits(cond, "message")) {
[13:23:34.603]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:34.603]                         if (muffled) 
[13:23:34.603]                           invokeRestart("muffleMessage")
[13:23:34.603]                       }
[13:23:34.603]                       else if (inherits(cond, "warning")) {
[13:23:34.603]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:34.603]                         if (muffled) 
[13:23:34.603]                           invokeRestart("muffleWarning")
[13:23:34.603]                       }
[13:23:34.603]                       else if (inherits(cond, "condition")) {
[13:23:34.603]                         if (!is.null(pattern)) {
[13:23:34.603]                           computeRestarts <- base::computeRestarts
[13:23:34.603]                           grepl <- base::grepl
[13:23:34.603]                           restarts <- computeRestarts(cond)
[13:23:34.603]                           for (restart in restarts) {
[13:23:34.603]                             name <- restart$name
[13:23:34.603]                             if (is.null(name)) 
[13:23:34.603]                               next
[13:23:34.603]                             if (!grepl(pattern, name)) 
[13:23:34.603]                               next
[13:23:34.603]                             invokeRestart(restart)
[13:23:34.603]                             muffled <- TRUE
[13:23:34.603]                             break
[13:23:34.603]                           }
[13:23:34.603]                         }
[13:23:34.603]                       }
[13:23:34.603]                       invisible(muffled)
[13:23:34.603]                     }
[13:23:34.603]                     muffleCondition(cond, pattern = "^muffle")
[13:23:34.603]                   }
[13:23:34.603]                 }
[13:23:34.603]             }
[13:23:34.603]         }))
[13:23:34.603]     }, error = function(ex) {
[13:23:34.603]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:34.603]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:34.603]                 ...future.rng), started = ...future.startTime, 
[13:23:34.603]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:34.603]             version = "1.8"), class = "FutureResult")
[13:23:34.603]     }, finally = {
[13:23:34.603]         if (!identical(...future.workdir, getwd())) 
[13:23:34.603]             setwd(...future.workdir)
[13:23:34.603]         {
[13:23:34.603]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:34.603]                 ...future.oldOptions$nwarnings <- NULL
[13:23:34.603]             }
[13:23:34.603]             base::options(...future.oldOptions)
[13:23:34.603]             if (.Platform$OS.type == "windows") {
[13:23:34.603]                 old_names <- names(...future.oldEnvVars)
[13:23:34.603]                 envs <- base::Sys.getenv()
[13:23:34.603]                 names <- names(envs)
[13:23:34.603]                 common <- intersect(names, old_names)
[13:23:34.603]                 added <- setdiff(names, old_names)
[13:23:34.603]                 removed <- setdiff(old_names, names)
[13:23:34.603]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:34.603]                   envs[common]]
[13:23:34.603]                 NAMES <- toupper(changed)
[13:23:34.603]                 args <- list()
[13:23:34.603]                 for (kk in seq_along(NAMES)) {
[13:23:34.603]                   name <- changed[[kk]]
[13:23:34.603]                   NAME <- NAMES[[kk]]
[13:23:34.603]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:34.603]                     next
[13:23:34.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:34.603]                 }
[13:23:34.603]                 NAMES <- toupper(added)
[13:23:34.603]                 for (kk in seq_along(NAMES)) {
[13:23:34.603]                   name <- added[[kk]]
[13:23:34.603]                   NAME <- NAMES[[kk]]
[13:23:34.603]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:34.603]                     next
[13:23:34.603]                   args[[name]] <- ""
[13:23:34.603]                 }
[13:23:34.603]                 NAMES <- toupper(removed)
[13:23:34.603]                 for (kk in seq_along(NAMES)) {
[13:23:34.603]                   name <- removed[[kk]]
[13:23:34.603]                   NAME <- NAMES[[kk]]
[13:23:34.603]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:34.603]                     next
[13:23:34.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:34.603]                 }
[13:23:34.603]                 if (length(args) > 0) 
[13:23:34.603]                   base::do.call(base::Sys.setenv, args = args)
[13:23:34.603]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:34.603]             }
[13:23:34.603]             else {
[13:23:34.603]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:34.603]             }
[13:23:34.603]             {
[13:23:34.603]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:34.603]                   0L) {
[13:23:34.603]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:34.603]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:34.603]                   base::options(opts)
[13:23:34.603]                 }
[13:23:34.603]                 {
[13:23:34.603]                   {
[13:23:34.603]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:34.603]                     NULL
[13:23:34.603]                   }
[13:23:34.603]                   options(future.plan = NULL)
[13:23:34.603]                   if (is.na(NA_character_)) 
[13:23:34.603]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:34.603]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:34.603]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:34.603]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:34.603]                     envir = parent.frame()) 
[13:23:34.603]                   {
[13:23:34.603]                     if (is.function(workers)) 
[13:23:34.603]                       workers <- workers()
[13:23:34.603]                     workers <- structure(as.integer(workers), 
[13:23:34.603]                       class = class(workers))
[13:23:34.603]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:34.603]                       workers >= 1)
[13:23:34.603]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:34.603]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:34.603]                     }
[13:23:34.603]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:34.603]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:34.603]                       envir = envir)
[13:23:34.603]                     if (!future$lazy) 
[13:23:34.603]                       future <- run(future)
[13:23:34.603]                     invisible(future)
[13:23:34.603]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:34.603]                 }
[13:23:34.603]             }
[13:23:34.603]         }
[13:23:34.603]     })
[13:23:34.603]     if (TRUE) {
[13:23:34.603]         base::sink(type = "output", split = FALSE)
[13:23:34.603]         if (TRUE) {
[13:23:34.603]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:34.603]         }
[13:23:34.603]         else {
[13:23:34.603]             ...future.result["stdout"] <- base::list(NULL)
[13:23:34.603]         }
[13:23:34.603]         base::close(...future.stdout)
[13:23:34.603]         ...future.stdout <- NULL
[13:23:34.603]     }
[13:23:34.603]     ...future.result$conditions <- ...future.conditions
[13:23:34.603]     ...future.result$finished <- base::Sys.time()
[13:23:34.603]     ...future.result
[13:23:34.603] }
[13:23:34.659] MultisessionFuture started
[13:23:34.660] result() for ClusterFuture ...
[13:23:34.660] receiveMessageFromWorker() for ClusterFuture ...
[13:23:34.661] - Validating connection of MultisessionFuture
[13:23:34.707] - received message: FutureResult
[13:23:34.707] - Received FutureResult
[13:23:34.707] - Erased future from FutureRegistry
[13:23:34.708] result() for ClusterFuture ...
[13:23:34.708] - result already collected: FutureResult
[13:23:34.708] result() for ClusterFuture ... done
[13:23:34.708] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:34.708] result() for ClusterFuture ... done
[13:23:34.708] result() for ClusterFuture ...
[13:23:34.708] - result already collected: FutureResult
[13:23:34.708] result() for ClusterFuture ... done
[13:23:34.708] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:23:34.712] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:34.713] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:34.713] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:34.714] - globals found: [3] ‘{’, ‘<-’, ‘*’
[13:23:34.715] Searching for globals ... DONE
[13:23:34.715] Resolving globals: TRUE
[13:23:34.715] Resolving any globals that are futures ...
[13:23:34.715] - globals: [3] ‘{’, ‘<-’, ‘*’
[13:23:34.715] Resolving any globals that are futures ... DONE
[13:23:34.716] 
[13:23:34.716] 
[13:23:34.716] getGlobalsAndPackages() ... DONE
[13:23:34.716] run() for ‘Future’ ...
[13:23:34.716] - state: ‘created’
[13:23:34.716] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:34.731] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:34.732] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:34.732]   - Field: ‘node’
[13:23:34.732]   - Field: ‘label’
[13:23:34.732]   - Field: ‘local’
[13:23:34.732]   - Field: ‘owner’
[13:23:34.732]   - Field: ‘envir’
[13:23:34.732]   - Field: ‘workers’
[13:23:34.732]   - Field: ‘packages’
[13:23:34.733]   - Field: ‘gc’
[13:23:34.733]   - Field: ‘conditions’
[13:23:34.733]   - Field: ‘persistent’
[13:23:34.733]   - Field: ‘expr’
[13:23:34.733]   - Field: ‘uuid’
[13:23:34.733]   - Field: ‘seed’
[13:23:34.733]   - Field: ‘version’
[13:23:34.733]   - Field: ‘result’
[13:23:34.733]   - Field: ‘asynchronous’
[13:23:34.734]   - Field: ‘calls’
[13:23:34.734]   - Field: ‘globals’
[13:23:34.734]   - Field: ‘stdout’
[13:23:34.734]   - Field: ‘earlySignal’
[13:23:34.734]   - Field: ‘lazy’
[13:23:34.734]   - Field: ‘state’
[13:23:34.734] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:34.734] - Launch lazy future ...
[13:23:34.735] Packages needed by the future expression (n = 0): <none>
[13:23:34.735] Packages needed by future strategies (n = 0): <none>
[13:23:34.735] {
[13:23:34.735]     {
[13:23:34.735]         {
[13:23:34.735]             ...future.startTime <- base::Sys.time()
[13:23:34.735]             {
[13:23:34.735]                 {
[13:23:34.735]                   {
[13:23:34.735]                     {
[13:23:34.735]                       base::local({
[13:23:34.735]                         has_future <- base::requireNamespace("future", 
[13:23:34.735]                           quietly = TRUE)
[13:23:34.735]                         if (has_future) {
[13:23:34.735]                           ns <- base::getNamespace("future")
[13:23:34.735]                           version <- ns[[".package"]][["version"]]
[13:23:34.735]                           if (is.null(version)) 
[13:23:34.735]                             version <- utils::packageVersion("future")
[13:23:34.735]                         }
[13:23:34.735]                         else {
[13:23:34.735]                           version <- NULL
[13:23:34.735]                         }
[13:23:34.735]                         if (!has_future || version < "1.8.0") {
[13:23:34.735]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:34.735]                             "", base::R.version$version.string), 
[13:23:34.735]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:34.735]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:34.735]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:34.735]                               "release", "version")], collapse = " "), 
[13:23:34.735]                             hostname = base::Sys.info()[["nodename"]])
[13:23:34.735]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:34.735]                             info)
[13:23:34.735]                           info <- base::paste(info, collapse = "; ")
[13:23:34.735]                           if (!has_future) {
[13:23:34.735]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:34.735]                               info)
[13:23:34.735]                           }
[13:23:34.735]                           else {
[13:23:34.735]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:34.735]                               info, version)
[13:23:34.735]                           }
[13:23:34.735]                           base::stop(msg)
[13:23:34.735]                         }
[13:23:34.735]                       })
[13:23:34.735]                     }
[13:23:34.735]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:34.735]                     base::options(mc.cores = 1L)
[13:23:34.735]                   }
[13:23:34.735]                   options(future.plan = NULL)
[13:23:34.735]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:34.735]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:34.735]                 }
[13:23:34.735]                 ...future.workdir <- getwd()
[13:23:34.735]             }
[13:23:34.735]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:34.735]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:34.735]         }
[13:23:34.735]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:34.735]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:34.735]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:34.735]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:34.735]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:34.735]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:34.735]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:34.735]             base::names(...future.oldOptions))
[13:23:34.735]     }
[13:23:34.735]     if (FALSE) {
[13:23:34.735]     }
[13:23:34.735]     else {
[13:23:34.735]         if (TRUE) {
[13:23:34.735]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:34.735]                 open = "w")
[13:23:34.735]         }
[13:23:34.735]         else {
[13:23:34.735]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:34.735]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:34.735]         }
[13:23:34.735]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:34.735]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:34.735]             base::sink(type = "output", split = FALSE)
[13:23:34.735]             base::close(...future.stdout)
[13:23:34.735]         }, add = TRUE)
[13:23:34.735]     }
[13:23:34.735]     ...future.frame <- base::sys.nframe()
[13:23:34.735]     ...future.conditions <- base::list()
[13:23:34.735]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:34.735]     if (FALSE) {
[13:23:34.735]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:34.735]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:34.735]     }
[13:23:34.735]     ...future.result <- base::tryCatch({
[13:23:34.735]         base::withCallingHandlers({
[13:23:34.735]             ...future.value <- base::withVisible(base::local({
[13:23:34.735]                 ...future.makeSendCondition <- base::local({
[13:23:34.735]                   sendCondition <- NULL
[13:23:34.735]                   function(frame = 1L) {
[13:23:34.735]                     if (is.function(sendCondition)) 
[13:23:34.735]                       return(sendCondition)
[13:23:34.735]                     ns <- getNamespace("parallel")
[13:23:34.735]                     if (exists("sendData", mode = "function", 
[13:23:34.735]                       envir = ns)) {
[13:23:34.735]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:34.735]                         envir = ns)
[13:23:34.735]                       envir <- sys.frame(frame)
[13:23:34.735]                       master <- NULL
[13:23:34.735]                       while (!identical(envir, .GlobalEnv) && 
[13:23:34.735]                         !identical(envir, emptyenv())) {
[13:23:34.735]                         if (exists("master", mode = "list", envir = envir, 
[13:23:34.735]                           inherits = FALSE)) {
[13:23:34.735]                           master <- get("master", mode = "list", 
[13:23:34.735]                             envir = envir, inherits = FALSE)
[13:23:34.735]                           if (inherits(master, c("SOCKnode", 
[13:23:34.735]                             "SOCK0node"))) {
[13:23:34.735]                             sendCondition <<- function(cond) {
[13:23:34.735]                               data <- list(type = "VALUE", value = cond, 
[13:23:34.735]                                 success = TRUE)
[13:23:34.735]                               parallel_sendData(master, data)
[13:23:34.735]                             }
[13:23:34.735]                             return(sendCondition)
[13:23:34.735]                           }
[13:23:34.735]                         }
[13:23:34.735]                         frame <- frame + 1L
[13:23:34.735]                         envir <- sys.frame(frame)
[13:23:34.735]                       }
[13:23:34.735]                     }
[13:23:34.735]                     sendCondition <<- function(cond) NULL
[13:23:34.735]                   }
[13:23:34.735]                 })
[13:23:34.735]                 withCallingHandlers({
[13:23:34.735]                   {
[13:23:34.735]                     b <- a
[13:23:34.735]                     a <- 2
[13:23:34.735]                     a * b
[13:23:34.735]                   }
[13:23:34.735]                 }, immediateCondition = function(cond) {
[13:23:34.735]                   sendCondition <- ...future.makeSendCondition()
[13:23:34.735]                   sendCondition(cond)
[13:23:34.735]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:34.735]                   {
[13:23:34.735]                     inherits <- base::inherits
[13:23:34.735]                     invokeRestart <- base::invokeRestart
[13:23:34.735]                     is.null <- base::is.null
[13:23:34.735]                     muffled <- FALSE
[13:23:34.735]                     if (inherits(cond, "message")) {
[13:23:34.735]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:34.735]                       if (muffled) 
[13:23:34.735]                         invokeRestart("muffleMessage")
[13:23:34.735]                     }
[13:23:34.735]                     else if (inherits(cond, "warning")) {
[13:23:34.735]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:34.735]                       if (muffled) 
[13:23:34.735]                         invokeRestart("muffleWarning")
[13:23:34.735]                     }
[13:23:34.735]                     else if (inherits(cond, "condition")) {
[13:23:34.735]                       if (!is.null(pattern)) {
[13:23:34.735]                         computeRestarts <- base::computeRestarts
[13:23:34.735]                         grepl <- base::grepl
[13:23:34.735]                         restarts <- computeRestarts(cond)
[13:23:34.735]                         for (restart in restarts) {
[13:23:34.735]                           name <- restart$name
[13:23:34.735]                           if (is.null(name)) 
[13:23:34.735]                             next
[13:23:34.735]                           if (!grepl(pattern, name)) 
[13:23:34.735]                             next
[13:23:34.735]                           invokeRestart(restart)
[13:23:34.735]                           muffled <- TRUE
[13:23:34.735]                           break
[13:23:34.735]                         }
[13:23:34.735]                       }
[13:23:34.735]                     }
[13:23:34.735]                     invisible(muffled)
[13:23:34.735]                   }
[13:23:34.735]                   muffleCondition(cond)
[13:23:34.735]                 })
[13:23:34.735]             }))
[13:23:34.735]             future::FutureResult(value = ...future.value$value, 
[13:23:34.735]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:34.735]                   ...future.rng), globalenv = if (FALSE) 
[13:23:34.735]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:34.735]                     ...future.globalenv.names))
[13:23:34.735]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:34.735]         }, condition = base::local({
[13:23:34.735]             c <- base::c
[13:23:34.735]             inherits <- base::inherits
[13:23:34.735]             invokeRestart <- base::invokeRestart
[13:23:34.735]             length <- base::length
[13:23:34.735]             list <- base::list
[13:23:34.735]             seq.int <- base::seq.int
[13:23:34.735]             signalCondition <- base::signalCondition
[13:23:34.735]             sys.calls <- base::sys.calls
[13:23:34.735]             `[[` <- base::`[[`
[13:23:34.735]             `+` <- base::`+`
[13:23:34.735]             `<<-` <- base::`<<-`
[13:23:34.735]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:34.735]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:34.735]                   3L)]
[13:23:34.735]             }
[13:23:34.735]             function(cond) {
[13:23:34.735]                 is_error <- inherits(cond, "error")
[13:23:34.735]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:34.735]                   NULL)
[13:23:34.735]                 if (is_error) {
[13:23:34.735]                   sessionInformation <- function() {
[13:23:34.735]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:34.735]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:34.735]                       search = base::search(), system = base::Sys.info())
[13:23:34.735]                   }
[13:23:34.735]                   ...future.conditions[[length(...future.conditions) + 
[13:23:34.735]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:34.735]                     cond$call), session = sessionInformation(), 
[13:23:34.735]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:34.735]                   signalCondition(cond)
[13:23:34.735]                 }
[13:23:34.735]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:34.735]                 "immediateCondition"))) {
[13:23:34.735]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:34.735]                   ...future.conditions[[length(...future.conditions) + 
[13:23:34.735]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:34.735]                   if (TRUE && !signal) {
[13:23:34.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:34.735]                     {
[13:23:34.735]                       inherits <- base::inherits
[13:23:34.735]                       invokeRestart <- base::invokeRestart
[13:23:34.735]                       is.null <- base::is.null
[13:23:34.735]                       muffled <- FALSE
[13:23:34.735]                       if (inherits(cond, "message")) {
[13:23:34.735]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:34.735]                         if (muffled) 
[13:23:34.735]                           invokeRestart("muffleMessage")
[13:23:34.735]                       }
[13:23:34.735]                       else if (inherits(cond, "warning")) {
[13:23:34.735]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:34.735]                         if (muffled) 
[13:23:34.735]                           invokeRestart("muffleWarning")
[13:23:34.735]                       }
[13:23:34.735]                       else if (inherits(cond, "condition")) {
[13:23:34.735]                         if (!is.null(pattern)) {
[13:23:34.735]                           computeRestarts <- base::computeRestarts
[13:23:34.735]                           grepl <- base::grepl
[13:23:34.735]                           restarts <- computeRestarts(cond)
[13:23:34.735]                           for (restart in restarts) {
[13:23:34.735]                             name <- restart$name
[13:23:34.735]                             if (is.null(name)) 
[13:23:34.735]                               next
[13:23:34.735]                             if (!grepl(pattern, name)) 
[13:23:34.735]                               next
[13:23:34.735]                             invokeRestart(restart)
[13:23:34.735]                             muffled <- TRUE
[13:23:34.735]                             break
[13:23:34.735]                           }
[13:23:34.735]                         }
[13:23:34.735]                       }
[13:23:34.735]                       invisible(muffled)
[13:23:34.735]                     }
[13:23:34.735]                     muffleCondition(cond, pattern = "^muffle")
[13:23:34.735]                   }
[13:23:34.735]                 }
[13:23:34.735]                 else {
[13:23:34.735]                   if (TRUE) {
[13:23:34.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:34.735]                     {
[13:23:34.735]                       inherits <- base::inherits
[13:23:34.735]                       invokeRestart <- base::invokeRestart
[13:23:34.735]                       is.null <- base::is.null
[13:23:34.735]                       muffled <- FALSE
[13:23:34.735]                       if (inherits(cond, "message")) {
[13:23:34.735]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:34.735]                         if (muffled) 
[13:23:34.735]                           invokeRestart("muffleMessage")
[13:23:34.735]                       }
[13:23:34.735]                       else if (inherits(cond, "warning")) {
[13:23:34.735]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:34.735]                         if (muffled) 
[13:23:34.735]                           invokeRestart("muffleWarning")
[13:23:34.735]                       }
[13:23:34.735]                       else if (inherits(cond, "condition")) {
[13:23:34.735]                         if (!is.null(pattern)) {
[13:23:34.735]                           computeRestarts <- base::computeRestarts
[13:23:34.735]                           grepl <- base::grepl
[13:23:34.735]                           restarts <- computeRestarts(cond)
[13:23:34.735]                           for (restart in restarts) {
[13:23:34.735]                             name <- restart$name
[13:23:34.735]                             if (is.null(name)) 
[13:23:34.735]                               next
[13:23:34.735]                             if (!grepl(pattern, name)) 
[13:23:34.735]                               next
[13:23:34.735]                             invokeRestart(restart)
[13:23:34.735]                             muffled <- TRUE
[13:23:34.735]                             break
[13:23:34.735]                           }
[13:23:34.735]                         }
[13:23:34.735]                       }
[13:23:34.735]                       invisible(muffled)
[13:23:34.735]                     }
[13:23:34.735]                     muffleCondition(cond, pattern = "^muffle")
[13:23:34.735]                   }
[13:23:34.735]                 }
[13:23:34.735]             }
[13:23:34.735]         }))
[13:23:34.735]     }, error = function(ex) {
[13:23:34.735]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:34.735]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:34.735]                 ...future.rng), started = ...future.startTime, 
[13:23:34.735]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:34.735]             version = "1.8"), class = "FutureResult")
[13:23:34.735]     }, finally = {
[13:23:34.735]         if (!identical(...future.workdir, getwd())) 
[13:23:34.735]             setwd(...future.workdir)
[13:23:34.735]         {
[13:23:34.735]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:34.735]                 ...future.oldOptions$nwarnings <- NULL
[13:23:34.735]             }
[13:23:34.735]             base::options(...future.oldOptions)
[13:23:34.735]             if (.Platform$OS.type == "windows") {
[13:23:34.735]                 old_names <- names(...future.oldEnvVars)
[13:23:34.735]                 envs <- base::Sys.getenv()
[13:23:34.735]                 names <- names(envs)
[13:23:34.735]                 common <- intersect(names, old_names)
[13:23:34.735]                 added <- setdiff(names, old_names)
[13:23:34.735]                 removed <- setdiff(old_names, names)
[13:23:34.735]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:34.735]                   envs[common]]
[13:23:34.735]                 NAMES <- toupper(changed)
[13:23:34.735]                 args <- list()
[13:23:34.735]                 for (kk in seq_along(NAMES)) {
[13:23:34.735]                   name <- changed[[kk]]
[13:23:34.735]                   NAME <- NAMES[[kk]]
[13:23:34.735]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:34.735]                     next
[13:23:34.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:34.735]                 }
[13:23:34.735]                 NAMES <- toupper(added)
[13:23:34.735]                 for (kk in seq_along(NAMES)) {
[13:23:34.735]                   name <- added[[kk]]
[13:23:34.735]                   NAME <- NAMES[[kk]]
[13:23:34.735]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:34.735]                     next
[13:23:34.735]                   args[[name]] <- ""
[13:23:34.735]                 }
[13:23:34.735]                 NAMES <- toupper(removed)
[13:23:34.735]                 for (kk in seq_along(NAMES)) {
[13:23:34.735]                   name <- removed[[kk]]
[13:23:34.735]                   NAME <- NAMES[[kk]]
[13:23:34.735]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:34.735]                     next
[13:23:34.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:34.735]                 }
[13:23:34.735]                 if (length(args) > 0) 
[13:23:34.735]                   base::do.call(base::Sys.setenv, args = args)
[13:23:34.735]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:34.735]             }
[13:23:34.735]             else {
[13:23:34.735]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:34.735]             }
[13:23:34.735]             {
[13:23:34.735]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:34.735]                   0L) {
[13:23:34.735]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:34.735]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:34.735]                   base::options(opts)
[13:23:34.735]                 }
[13:23:34.735]                 {
[13:23:34.735]                   {
[13:23:34.735]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:34.735]                     NULL
[13:23:34.735]                   }
[13:23:34.735]                   options(future.plan = NULL)
[13:23:34.735]                   if (is.na(NA_character_)) 
[13:23:34.735]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:34.735]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:34.735]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:34.735]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:34.735]                     envir = parent.frame()) 
[13:23:34.735]                   {
[13:23:34.735]                     if (is.function(workers)) 
[13:23:34.735]                       workers <- workers()
[13:23:34.735]                     workers <- structure(as.integer(workers), 
[13:23:34.735]                       class = class(workers))
[13:23:34.735]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:34.735]                       workers >= 1)
[13:23:34.735]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:34.735]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:34.735]                     }
[13:23:34.735]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:34.735]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:34.735]                       envir = envir)
[13:23:34.735]                     if (!future$lazy) 
[13:23:34.735]                       future <- run(future)
[13:23:34.735]                     invisible(future)
[13:23:34.735]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:34.735]                 }
[13:23:34.735]             }
[13:23:34.735]         }
[13:23:34.735]     })
[13:23:34.735]     if (TRUE) {
[13:23:34.735]         base::sink(type = "output", split = FALSE)
[13:23:34.735]         if (TRUE) {
[13:23:34.735]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:34.735]         }
[13:23:34.735]         else {
[13:23:34.735]             ...future.result["stdout"] <- base::list(NULL)
[13:23:34.735]         }
[13:23:34.735]         base::close(...future.stdout)
[13:23:34.735]         ...future.stdout <- NULL
[13:23:34.735]     }
[13:23:34.735]     ...future.result$conditions <- ...future.conditions
[13:23:34.735]     ...future.result$finished <- base::Sys.time()
[13:23:34.735]     ...future.result
[13:23:34.735] }
[13:23:34.739] MultisessionFuture started
[13:23:34.739] - Launch lazy future ... done
[13:23:34.739] run() for ‘MultisessionFuture’ ... done
[13:23:34.740] result() for ClusterFuture ...
[13:23:34.740] receiveMessageFromWorker() for ClusterFuture ...
[13:23:34.740] - Validating connection of MultisessionFuture
[13:23:34.786] - received message: FutureResult
[13:23:34.786] - Received FutureResult
[13:23:34.786] - Erased future from FutureRegistry
[13:23:34.787] result() for ClusterFuture ...
[13:23:34.787] - result already collected: FutureResult
[13:23:34.787] result() for ClusterFuture ... done
[13:23:34.787] signalConditions() ...
[13:23:34.787]  - include = ‘immediateCondition’
[13:23:34.787]  - exclude = 
[13:23:34.787]  - resignal = FALSE
[13:23:34.787]  - Number of conditions: 1
[13:23:34.788] signalConditions() ... done
[13:23:34.788] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:34.788] result() for ClusterFuture ... done
[13:23:34.788] result() for ClusterFuture ...
[13:23:34.788] - result already collected: FutureResult
[13:23:34.788] result() for ClusterFuture ... done
[13:23:34.788] signalConditions() ...
[13:23:34.788]  - include = ‘immediateCondition’
[13:23:34.788]  - exclude = 
[13:23:34.789]  - resignal = FALSE
[13:23:34.789]  - Number of conditions: 1
[13:23:34.789] signalConditions() ... done
[13:23:34.789] Future state: ‘finished’
[13:23:34.789] result() for ClusterFuture ...
[13:23:34.789] - result already collected: FutureResult
[13:23:34.789] result() for ClusterFuture ... done
[13:23:34.789] signalConditions() ...
[13:23:34.790]  - include = ‘condition’
[13:23:34.790]  - exclude = ‘immediateCondition’
[13:23:34.790]  - resignal = TRUE
[13:23:34.790]  - Number of conditions: 1
[13:23:34.790]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:23:34.790] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "47b98e4ec3a9" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:23:34"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:34.807] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:34.807] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:34.809] - globals found: [3] ‘{’, ‘<-’, ‘*’
[13:23:34.809] Searching for globals ... DONE
[13:23:34.809] Resolving globals: TRUE
[13:23:34.809] Resolving any globals that are futures ...
[13:23:34.810] - globals: [3] ‘{’, ‘<-’, ‘*’
[13:23:34.810] Resolving any globals that are futures ... DONE
[13:23:34.810] 
[13:23:34.810] 
[13:23:34.810] getGlobalsAndPackages() ... DONE
[13:23:34.811] run() for ‘Future’ ...
[13:23:34.811] - state: ‘created’
[13:23:34.811] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:34.826] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:34.826] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:34.826]   - Field: ‘node’
[13:23:34.827]   - Field: ‘label’
[13:23:34.827]   - Field: ‘local’
[13:23:34.827]   - Field: ‘owner’
[13:23:34.827]   - Field: ‘envir’
[13:23:34.827]   - Field: ‘workers’
[13:23:34.827]   - Field: ‘packages’
[13:23:34.827]   - Field: ‘gc’
[13:23:34.827]   - Field: ‘conditions’
[13:23:34.827]   - Field: ‘persistent’
[13:23:34.828]   - Field: ‘expr’
[13:23:34.828]   - Field: ‘uuid’
[13:23:34.828]   - Field: ‘seed’
[13:23:34.828]   - Field: ‘version’
[13:23:34.828]   - Field: ‘result’
[13:23:34.828]   - Field: ‘asynchronous’
[13:23:34.828]   - Field: ‘calls’
[13:23:34.828]   - Field: ‘globals’
[13:23:34.829]   - Field: ‘stdout’
[13:23:34.829]   - Field: ‘earlySignal’
[13:23:34.829]   - Field: ‘lazy’
[13:23:34.829]   - Field: ‘state’
[13:23:34.829] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:34.829] - Launch lazy future ...
[13:23:34.830] Packages needed by the future expression (n = 0): <none>
[13:23:34.830] Packages needed by future strategies (n = 0): <none>
[13:23:34.830] {
[13:23:34.830]     {
[13:23:34.830]         {
[13:23:34.830]             ...future.startTime <- base::Sys.time()
[13:23:34.830]             {
[13:23:34.830]                 {
[13:23:34.830]                   {
[13:23:34.830]                     {
[13:23:34.830]                       base::local({
[13:23:34.830]                         has_future <- base::requireNamespace("future", 
[13:23:34.830]                           quietly = TRUE)
[13:23:34.830]                         if (has_future) {
[13:23:34.830]                           ns <- base::getNamespace("future")
[13:23:34.830]                           version <- ns[[".package"]][["version"]]
[13:23:34.830]                           if (is.null(version)) 
[13:23:34.830]                             version <- utils::packageVersion("future")
[13:23:34.830]                         }
[13:23:34.830]                         else {
[13:23:34.830]                           version <- NULL
[13:23:34.830]                         }
[13:23:34.830]                         if (!has_future || version < "1.8.0") {
[13:23:34.830]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:34.830]                             "", base::R.version$version.string), 
[13:23:34.830]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:34.830]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:34.830]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:34.830]                               "release", "version")], collapse = " "), 
[13:23:34.830]                             hostname = base::Sys.info()[["nodename"]])
[13:23:34.830]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:34.830]                             info)
[13:23:34.830]                           info <- base::paste(info, collapse = "; ")
[13:23:34.830]                           if (!has_future) {
[13:23:34.830]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:34.830]                               info)
[13:23:34.830]                           }
[13:23:34.830]                           else {
[13:23:34.830]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:34.830]                               info, version)
[13:23:34.830]                           }
[13:23:34.830]                           base::stop(msg)
[13:23:34.830]                         }
[13:23:34.830]                       })
[13:23:34.830]                     }
[13:23:34.830]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:34.830]                     base::options(mc.cores = 1L)
[13:23:34.830]                   }
[13:23:34.830]                   options(future.plan = NULL)
[13:23:34.830]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:34.830]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:34.830]                 }
[13:23:34.830]                 ...future.workdir <- getwd()
[13:23:34.830]             }
[13:23:34.830]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:34.830]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:34.830]         }
[13:23:34.830]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:34.830]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:34.830]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:34.830]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:34.830]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:34.830]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:34.830]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:34.830]             base::names(...future.oldOptions))
[13:23:34.830]     }
[13:23:34.830]     if (FALSE) {
[13:23:34.830]     }
[13:23:34.830]     else {
[13:23:34.830]         if (TRUE) {
[13:23:34.830]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:34.830]                 open = "w")
[13:23:34.830]         }
[13:23:34.830]         else {
[13:23:34.830]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:34.830]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:34.830]         }
[13:23:34.830]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:34.830]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:34.830]             base::sink(type = "output", split = FALSE)
[13:23:34.830]             base::close(...future.stdout)
[13:23:34.830]         }, add = TRUE)
[13:23:34.830]     }
[13:23:34.830]     ...future.frame <- base::sys.nframe()
[13:23:34.830]     ...future.conditions <- base::list()
[13:23:34.830]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:34.830]     if (FALSE) {
[13:23:34.830]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:34.830]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:34.830]     }
[13:23:34.830]     ...future.result <- base::tryCatch({
[13:23:34.830]         base::withCallingHandlers({
[13:23:34.830]             ...future.value <- base::withVisible(base::local({
[13:23:34.830]                 ...future.makeSendCondition <- base::local({
[13:23:34.830]                   sendCondition <- NULL
[13:23:34.830]                   function(frame = 1L) {
[13:23:34.830]                     if (is.function(sendCondition)) 
[13:23:34.830]                       return(sendCondition)
[13:23:34.830]                     ns <- getNamespace("parallel")
[13:23:34.830]                     if (exists("sendData", mode = "function", 
[13:23:34.830]                       envir = ns)) {
[13:23:34.830]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:34.830]                         envir = ns)
[13:23:34.830]                       envir <- sys.frame(frame)
[13:23:34.830]                       master <- NULL
[13:23:34.830]                       while (!identical(envir, .GlobalEnv) && 
[13:23:34.830]                         !identical(envir, emptyenv())) {
[13:23:34.830]                         if (exists("master", mode = "list", envir = envir, 
[13:23:34.830]                           inherits = FALSE)) {
[13:23:34.830]                           master <- get("master", mode = "list", 
[13:23:34.830]                             envir = envir, inherits = FALSE)
[13:23:34.830]                           if (inherits(master, c("SOCKnode", 
[13:23:34.830]                             "SOCK0node"))) {
[13:23:34.830]                             sendCondition <<- function(cond) {
[13:23:34.830]                               data <- list(type = "VALUE", value = cond, 
[13:23:34.830]                                 success = TRUE)
[13:23:34.830]                               parallel_sendData(master, data)
[13:23:34.830]                             }
[13:23:34.830]                             return(sendCondition)
[13:23:34.830]                           }
[13:23:34.830]                         }
[13:23:34.830]                         frame <- frame + 1L
[13:23:34.830]                         envir <- sys.frame(frame)
[13:23:34.830]                       }
[13:23:34.830]                     }
[13:23:34.830]                     sendCondition <<- function(cond) NULL
[13:23:34.830]                   }
[13:23:34.830]                 })
[13:23:34.830]                 withCallingHandlers({
[13:23:34.830]                   {
[13:23:34.830]                     b <- a
[13:23:34.830]                     a <- 2
[13:23:34.830]                     a * b
[13:23:34.830]                   }
[13:23:34.830]                 }, immediateCondition = function(cond) {
[13:23:34.830]                   sendCondition <- ...future.makeSendCondition()
[13:23:34.830]                   sendCondition(cond)
[13:23:34.830]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:34.830]                   {
[13:23:34.830]                     inherits <- base::inherits
[13:23:34.830]                     invokeRestart <- base::invokeRestart
[13:23:34.830]                     is.null <- base::is.null
[13:23:34.830]                     muffled <- FALSE
[13:23:34.830]                     if (inherits(cond, "message")) {
[13:23:34.830]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:34.830]                       if (muffled) 
[13:23:34.830]                         invokeRestart("muffleMessage")
[13:23:34.830]                     }
[13:23:34.830]                     else if (inherits(cond, "warning")) {
[13:23:34.830]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:34.830]                       if (muffled) 
[13:23:34.830]                         invokeRestart("muffleWarning")
[13:23:34.830]                     }
[13:23:34.830]                     else if (inherits(cond, "condition")) {
[13:23:34.830]                       if (!is.null(pattern)) {
[13:23:34.830]                         computeRestarts <- base::computeRestarts
[13:23:34.830]                         grepl <- base::grepl
[13:23:34.830]                         restarts <- computeRestarts(cond)
[13:23:34.830]                         for (restart in restarts) {
[13:23:34.830]                           name <- restart$name
[13:23:34.830]                           if (is.null(name)) 
[13:23:34.830]                             next
[13:23:34.830]                           if (!grepl(pattern, name)) 
[13:23:34.830]                             next
[13:23:34.830]                           invokeRestart(restart)
[13:23:34.830]                           muffled <- TRUE
[13:23:34.830]                           break
[13:23:34.830]                         }
[13:23:34.830]                       }
[13:23:34.830]                     }
[13:23:34.830]                     invisible(muffled)
[13:23:34.830]                   }
[13:23:34.830]                   muffleCondition(cond)
[13:23:34.830]                 })
[13:23:34.830]             }))
[13:23:34.830]             future::FutureResult(value = ...future.value$value, 
[13:23:34.830]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:34.830]                   ...future.rng), globalenv = if (FALSE) 
[13:23:34.830]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:34.830]                     ...future.globalenv.names))
[13:23:34.830]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:34.830]         }, condition = base::local({
[13:23:34.830]             c <- base::c
[13:23:34.830]             inherits <- base::inherits
[13:23:34.830]             invokeRestart <- base::invokeRestart
[13:23:34.830]             length <- base::length
[13:23:34.830]             list <- base::list
[13:23:34.830]             seq.int <- base::seq.int
[13:23:34.830]             signalCondition <- base::signalCondition
[13:23:34.830]             sys.calls <- base::sys.calls
[13:23:34.830]             `[[` <- base::`[[`
[13:23:34.830]             `+` <- base::`+`
[13:23:34.830]             `<<-` <- base::`<<-`
[13:23:34.830]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:34.830]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:34.830]                   3L)]
[13:23:34.830]             }
[13:23:34.830]             function(cond) {
[13:23:34.830]                 is_error <- inherits(cond, "error")
[13:23:34.830]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:34.830]                   NULL)
[13:23:34.830]                 if (is_error) {
[13:23:34.830]                   sessionInformation <- function() {
[13:23:34.830]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:34.830]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:34.830]                       search = base::search(), system = base::Sys.info())
[13:23:34.830]                   }
[13:23:34.830]                   ...future.conditions[[length(...future.conditions) + 
[13:23:34.830]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:34.830]                     cond$call), session = sessionInformation(), 
[13:23:34.830]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:34.830]                   signalCondition(cond)
[13:23:34.830]                 }
[13:23:34.830]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:34.830]                 "immediateCondition"))) {
[13:23:34.830]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:34.830]                   ...future.conditions[[length(...future.conditions) + 
[13:23:34.830]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:34.830]                   if (TRUE && !signal) {
[13:23:34.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:34.830]                     {
[13:23:34.830]                       inherits <- base::inherits
[13:23:34.830]                       invokeRestart <- base::invokeRestart
[13:23:34.830]                       is.null <- base::is.null
[13:23:34.830]                       muffled <- FALSE
[13:23:34.830]                       if (inherits(cond, "message")) {
[13:23:34.830]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:34.830]                         if (muffled) 
[13:23:34.830]                           invokeRestart("muffleMessage")
[13:23:34.830]                       }
[13:23:34.830]                       else if (inherits(cond, "warning")) {
[13:23:34.830]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:34.830]                         if (muffled) 
[13:23:34.830]                           invokeRestart("muffleWarning")
[13:23:34.830]                       }
[13:23:34.830]                       else if (inherits(cond, "condition")) {
[13:23:34.830]                         if (!is.null(pattern)) {
[13:23:34.830]                           computeRestarts <- base::computeRestarts
[13:23:34.830]                           grepl <- base::grepl
[13:23:34.830]                           restarts <- computeRestarts(cond)
[13:23:34.830]                           for (restart in restarts) {
[13:23:34.830]                             name <- restart$name
[13:23:34.830]                             if (is.null(name)) 
[13:23:34.830]                               next
[13:23:34.830]                             if (!grepl(pattern, name)) 
[13:23:34.830]                               next
[13:23:34.830]                             invokeRestart(restart)
[13:23:34.830]                             muffled <- TRUE
[13:23:34.830]                             break
[13:23:34.830]                           }
[13:23:34.830]                         }
[13:23:34.830]                       }
[13:23:34.830]                       invisible(muffled)
[13:23:34.830]                     }
[13:23:34.830]                     muffleCondition(cond, pattern = "^muffle")
[13:23:34.830]                   }
[13:23:34.830]                 }
[13:23:34.830]                 else {
[13:23:34.830]                   if (TRUE) {
[13:23:34.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:34.830]                     {
[13:23:34.830]                       inherits <- base::inherits
[13:23:34.830]                       invokeRestart <- base::invokeRestart
[13:23:34.830]                       is.null <- base::is.null
[13:23:34.830]                       muffled <- FALSE
[13:23:34.830]                       if (inherits(cond, "message")) {
[13:23:34.830]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:34.830]                         if (muffled) 
[13:23:34.830]                           invokeRestart("muffleMessage")
[13:23:34.830]                       }
[13:23:34.830]                       else if (inherits(cond, "warning")) {
[13:23:34.830]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:34.830]                         if (muffled) 
[13:23:34.830]                           invokeRestart("muffleWarning")
[13:23:34.830]                       }
[13:23:34.830]                       else if (inherits(cond, "condition")) {
[13:23:34.830]                         if (!is.null(pattern)) {
[13:23:34.830]                           computeRestarts <- base::computeRestarts
[13:23:34.830]                           grepl <- base::grepl
[13:23:34.830]                           restarts <- computeRestarts(cond)
[13:23:34.830]                           for (restart in restarts) {
[13:23:34.830]                             name <- restart$name
[13:23:34.830]                             if (is.null(name)) 
[13:23:34.830]                               next
[13:23:34.830]                             if (!grepl(pattern, name)) 
[13:23:34.830]                               next
[13:23:34.830]                             invokeRestart(restart)
[13:23:34.830]                             muffled <- TRUE
[13:23:34.830]                             break
[13:23:34.830]                           }
[13:23:34.830]                         }
[13:23:34.830]                       }
[13:23:34.830]                       invisible(muffled)
[13:23:34.830]                     }
[13:23:34.830]                     muffleCondition(cond, pattern = "^muffle")
[13:23:34.830]                   }
[13:23:34.830]                 }
[13:23:34.830]             }
[13:23:34.830]         }))
[13:23:34.830]     }, error = function(ex) {
[13:23:34.830]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:34.830]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:34.830]                 ...future.rng), started = ...future.startTime, 
[13:23:34.830]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:34.830]             version = "1.8"), class = "FutureResult")
[13:23:34.830]     }, finally = {
[13:23:34.830]         if (!identical(...future.workdir, getwd())) 
[13:23:34.830]             setwd(...future.workdir)
[13:23:34.830]         {
[13:23:34.830]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:34.830]                 ...future.oldOptions$nwarnings <- NULL
[13:23:34.830]             }
[13:23:34.830]             base::options(...future.oldOptions)
[13:23:34.830]             if (.Platform$OS.type == "windows") {
[13:23:34.830]                 old_names <- names(...future.oldEnvVars)
[13:23:34.830]                 envs <- base::Sys.getenv()
[13:23:34.830]                 names <- names(envs)
[13:23:34.830]                 common <- intersect(names, old_names)
[13:23:34.830]                 added <- setdiff(names, old_names)
[13:23:34.830]                 removed <- setdiff(old_names, names)
[13:23:34.830]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:34.830]                   envs[common]]
[13:23:34.830]                 NAMES <- toupper(changed)
[13:23:34.830]                 args <- list()
[13:23:34.830]                 for (kk in seq_along(NAMES)) {
[13:23:34.830]                   name <- changed[[kk]]
[13:23:34.830]                   NAME <- NAMES[[kk]]
[13:23:34.830]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:34.830]                     next
[13:23:34.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:34.830]                 }
[13:23:34.830]                 NAMES <- toupper(added)
[13:23:34.830]                 for (kk in seq_along(NAMES)) {
[13:23:34.830]                   name <- added[[kk]]
[13:23:34.830]                   NAME <- NAMES[[kk]]
[13:23:34.830]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:34.830]                     next
[13:23:34.830]                   args[[name]] <- ""
[13:23:34.830]                 }
[13:23:34.830]                 NAMES <- toupper(removed)
[13:23:34.830]                 for (kk in seq_along(NAMES)) {
[13:23:34.830]                   name <- removed[[kk]]
[13:23:34.830]                   NAME <- NAMES[[kk]]
[13:23:34.830]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:34.830]                     next
[13:23:34.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:34.830]                 }
[13:23:34.830]                 if (length(args) > 0) 
[13:23:34.830]                   base::do.call(base::Sys.setenv, args = args)
[13:23:34.830]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:34.830]             }
[13:23:34.830]             else {
[13:23:34.830]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:34.830]             }
[13:23:34.830]             {
[13:23:34.830]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:34.830]                   0L) {
[13:23:34.830]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:34.830]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:34.830]                   base::options(opts)
[13:23:34.830]                 }
[13:23:34.830]                 {
[13:23:34.830]                   {
[13:23:34.830]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:34.830]                     NULL
[13:23:34.830]                   }
[13:23:34.830]                   options(future.plan = NULL)
[13:23:34.830]                   if (is.na(NA_character_)) 
[13:23:34.830]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:34.830]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:34.830]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:34.830]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:34.830]                     envir = parent.frame()) 
[13:23:34.830]                   {
[13:23:34.830]                     if (is.function(workers)) 
[13:23:34.830]                       workers <- workers()
[13:23:34.830]                     workers <- structure(as.integer(workers), 
[13:23:34.830]                       class = class(workers))
[13:23:34.830]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:34.830]                       workers >= 1)
[13:23:34.830]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:34.830]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:34.830]                     }
[13:23:34.830]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:34.830]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:34.830]                       envir = envir)
[13:23:34.830]                     if (!future$lazy) 
[13:23:34.830]                       future <- run(future)
[13:23:34.830]                     invisible(future)
[13:23:34.830]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:34.830]                 }
[13:23:34.830]             }
[13:23:34.830]         }
[13:23:34.830]     })
[13:23:34.830]     if (TRUE) {
[13:23:34.830]         base::sink(type = "output", split = FALSE)
[13:23:34.830]         if (TRUE) {
[13:23:34.830]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:34.830]         }
[13:23:34.830]         else {
[13:23:34.830]             ...future.result["stdout"] <- base::list(NULL)
[13:23:34.830]         }
[13:23:34.830]         base::close(...future.stdout)
[13:23:34.830]         ...future.stdout <- NULL
[13:23:34.830]     }
[13:23:34.830]     ...future.result$conditions <- ...future.conditions
[13:23:34.830]     ...future.result$finished <- base::Sys.time()
[13:23:34.830]     ...future.result
[13:23:34.830] }
[13:23:34.837] MultisessionFuture started
[13:23:34.837] - Launch lazy future ... done
[13:23:34.837] run() for ‘MultisessionFuture’ ... done
[13:23:34.837] result() for ClusterFuture ...
[13:23:34.837] receiveMessageFromWorker() for ClusterFuture ...
[13:23:34.837] - Validating connection of MultisessionFuture
[13:23:34.886] - received message: FutureResult
[13:23:34.886] - Received FutureResult
[13:23:34.886] - Erased future from FutureRegistry
[13:23:34.886] result() for ClusterFuture ...
[13:23:34.886] - result already collected: FutureResult
[13:23:34.887] result() for ClusterFuture ... done
[13:23:34.887] signalConditions() ...
[13:23:34.887]  - include = ‘immediateCondition’
[13:23:34.887]  - exclude = 
[13:23:34.887]  - resignal = FALSE
[13:23:34.887]  - Number of conditions: 1
[13:23:34.887] signalConditions() ... done
[13:23:34.887] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:34.887] result() for ClusterFuture ... done
[13:23:34.887] result() for ClusterFuture ...
[13:23:34.887] - result already collected: FutureResult
[13:23:34.887] result() for ClusterFuture ... done
[13:23:34.888] signalConditions() ...
[13:23:34.888]  - include = ‘immediateCondition’
[13:23:34.888]  - exclude = 
[13:23:34.888]  - resignal = FALSE
[13:23:34.888]  - Number of conditions: 1
[13:23:34.888] signalConditions() ... done
[13:23:34.888] Future state: ‘finished’
[13:23:34.888] result() for ClusterFuture ...
[13:23:34.888] - result already collected: FutureResult
[13:23:34.888] result() for ClusterFuture ... done
[13:23:34.889] signalConditions() ...
[13:23:34.889]  - include = ‘condition’
[13:23:34.889]  - exclude = ‘immediateCondition’
[13:23:34.889]  - resignal = TRUE
[13:23:34.889]  - Number of conditions: 1
[13:23:34.889]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:23:34.889] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "47b98e4ec3a9" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:23:34"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:34.904] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:34.904] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:34.905] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:34.906] Searching for globals ... DONE
[13:23:34.906] Resolving globals: TRUE
[13:23:34.906] Resolving any globals that are futures ...
[13:23:34.906] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:34.906] Resolving any globals that are futures ... DONE
[13:23:34.906] Resolving futures part of globals (recursively) ...
[13:23:34.907] resolve() on list ...
[13:23:34.907]  recursive: 99
[13:23:34.907]  length: 1
[13:23:34.907]  elements: ‘ii’
[13:23:34.907]  length: 0 (resolved future 1)
[13:23:34.907] resolve() on list ... DONE
[13:23:34.907] - globals: [1] ‘ii’
[13:23:34.907] Resolving futures part of globals (recursively) ... DONE
[13:23:34.907] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:34.908] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:34.908] - globals: [1] ‘ii’
[13:23:34.908] 
[13:23:34.908] getGlobalsAndPackages() ... DONE
[13:23:34.908] run() for ‘Future’ ...
[13:23:34.908] - state: ‘created’
[13:23:34.909] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:34.923] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:34.923] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:34.923]   - Field: ‘node’
[13:23:34.923]   - Field: ‘label’
[13:23:34.924]   - Field: ‘local’
[13:23:34.924]   - Field: ‘owner’
[13:23:34.924]   - Field: ‘envir’
[13:23:34.924]   - Field: ‘workers’
[13:23:34.924]   - Field: ‘packages’
[13:23:34.924]   - Field: ‘gc’
[13:23:34.924]   - Field: ‘conditions’
[13:23:34.924]   - Field: ‘persistent’
[13:23:34.924]   - Field: ‘expr’
[13:23:34.924]   - Field: ‘uuid’
[13:23:34.925]   - Field: ‘seed’
[13:23:34.925]   - Field: ‘version’
[13:23:34.925]   - Field: ‘result’
[13:23:34.925]   - Field: ‘asynchronous’
[13:23:34.925]   - Field: ‘calls’
[13:23:34.925]   - Field: ‘globals’
[13:23:34.925]   - Field: ‘stdout’
[13:23:34.925]   - Field: ‘earlySignal’
[13:23:34.925]   - Field: ‘lazy’
[13:23:34.925]   - Field: ‘state’
[13:23:34.925] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:34.925] - Launch lazy future ...
[13:23:34.926] Packages needed by the future expression (n = 0): <none>
[13:23:34.926] Packages needed by future strategies (n = 0): <none>
[13:23:34.926] {
[13:23:34.926]     {
[13:23:34.926]         {
[13:23:34.926]             ...future.startTime <- base::Sys.time()
[13:23:34.926]             {
[13:23:34.926]                 {
[13:23:34.926]                   {
[13:23:34.926]                     {
[13:23:34.926]                       base::local({
[13:23:34.926]                         has_future <- base::requireNamespace("future", 
[13:23:34.926]                           quietly = TRUE)
[13:23:34.926]                         if (has_future) {
[13:23:34.926]                           ns <- base::getNamespace("future")
[13:23:34.926]                           version <- ns[[".package"]][["version"]]
[13:23:34.926]                           if (is.null(version)) 
[13:23:34.926]                             version <- utils::packageVersion("future")
[13:23:34.926]                         }
[13:23:34.926]                         else {
[13:23:34.926]                           version <- NULL
[13:23:34.926]                         }
[13:23:34.926]                         if (!has_future || version < "1.8.0") {
[13:23:34.926]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:34.926]                             "", base::R.version$version.string), 
[13:23:34.926]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:34.926]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:34.926]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:34.926]                               "release", "version")], collapse = " "), 
[13:23:34.926]                             hostname = base::Sys.info()[["nodename"]])
[13:23:34.926]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:34.926]                             info)
[13:23:34.926]                           info <- base::paste(info, collapse = "; ")
[13:23:34.926]                           if (!has_future) {
[13:23:34.926]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:34.926]                               info)
[13:23:34.926]                           }
[13:23:34.926]                           else {
[13:23:34.926]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:34.926]                               info, version)
[13:23:34.926]                           }
[13:23:34.926]                           base::stop(msg)
[13:23:34.926]                         }
[13:23:34.926]                       })
[13:23:34.926]                     }
[13:23:34.926]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:34.926]                     base::options(mc.cores = 1L)
[13:23:34.926]                   }
[13:23:34.926]                   options(future.plan = NULL)
[13:23:34.926]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:34.926]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:34.926]                 }
[13:23:34.926]                 ...future.workdir <- getwd()
[13:23:34.926]             }
[13:23:34.926]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:34.926]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:34.926]         }
[13:23:34.926]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:34.926]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:34.926]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:34.926]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:34.926]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:34.926]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:34.926]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:34.926]             base::names(...future.oldOptions))
[13:23:34.926]     }
[13:23:34.926]     if (FALSE) {
[13:23:34.926]     }
[13:23:34.926]     else {
[13:23:34.926]         if (TRUE) {
[13:23:34.926]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:34.926]                 open = "w")
[13:23:34.926]         }
[13:23:34.926]         else {
[13:23:34.926]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:34.926]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:34.926]         }
[13:23:34.926]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:34.926]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:34.926]             base::sink(type = "output", split = FALSE)
[13:23:34.926]             base::close(...future.stdout)
[13:23:34.926]         }, add = TRUE)
[13:23:34.926]     }
[13:23:34.926]     ...future.frame <- base::sys.nframe()
[13:23:34.926]     ...future.conditions <- base::list()
[13:23:34.926]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:34.926]     if (FALSE) {
[13:23:34.926]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:34.926]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:34.926]     }
[13:23:34.926]     ...future.result <- base::tryCatch({
[13:23:34.926]         base::withCallingHandlers({
[13:23:34.926]             ...future.value <- base::withVisible(base::local({
[13:23:34.926]                 ...future.makeSendCondition <- base::local({
[13:23:34.926]                   sendCondition <- NULL
[13:23:34.926]                   function(frame = 1L) {
[13:23:34.926]                     if (is.function(sendCondition)) 
[13:23:34.926]                       return(sendCondition)
[13:23:34.926]                     ns <- getNamespace("parallel")
[13:23:34.926]                     if (exists("sendData", mode = "function", 
[13:23:34.926]                       envir = ns)) {
[13:23:34.926]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:34.926]                         envir = ns)
[13:23:34.926]                       envir <- sys.frame(frame)
[13:23:34.926]                       master <- NULL
[13:23:34.926]                       while (!identical(envir, .GlobalEnv) && 
[13:23:34.926]                         !identical(envir, emptyenv())) {
[13:23:34.926]                         if (exists("master", mode = "list", envir = envir, 
[13:23:34.926]                           inherits = FALSE)) {
[13:23:34.926]                           master <- get("master", mode = "list", 
[13:23:34.926]                             envir = envir, inherits = FALSE)
[13:23:34.926]                           if (inherits(master, c("SOCKnode", 
[13:23:34.926]                             "SOCK0node"))) {
[13:23:34.926]                             sendCondition <<- function(cond) {
[13:23:34.926]                               data <- list(type = "VALUE", value = cond, 
[13:23:34.926]                                 success = TRUE)
[13:23:34.926]                               parallel_sendData(master, data)
[13:23:34.926]                             }
[13:23:34.926]                             return(sendCondition)
[13:23:34.926]                           }
[13:23:34.926]                         }
[13:23:34.926]                         frame <- frame + 1L
[13:23:34.926]                         envir <- sys.frame(frame)
[13:23:34.926]                       }
[13:23:34.926]                     }
[13:23:34.926]                     sendCondition <<- function(cond) NULL
[13:23:34.926]                   }
[13:23:34.926]                 })
[13:23:34.926]                 withCallingHandlers({
[13:23:34.926]                   {
[13:23:34.926]                     b <- a * ii
[13:23:34.926]                     a <- 0
[13:23:34.926]                     b
[13:23:34.926]                   }
[13:23:34.926]                 }, immediateCondition = function(cond) {
[13:23:34.926]                   sendCondition <- ...future.makeSendCondition()
[13:23:34.926]                   sendCondition(cond)
[13:23:34.926]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:34.926]                   {
[13:23:34.926]                     inherits <- base::inherits
[13:23:34.926]                     invokeRestart <- base::invokeRestart
[13:23:34.926]                     is.null <- base::is.null
[13:23:34.926]                     muffled <- FALSE
[13:23:34.926]                     if (inherits(cond, "message")) {
[13:23:34.926]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:34.926]                       if (muffled) 
[13:23:34.926]                         invokeRestart("muffleMessage")
[13:23:34.926]                     }
[13:23:34.926]                     else if (inherits(cond, "warning")) {
[13:23:34.926]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:34.926]                       if (muffled) 
[13:23:34.926]                         invokeRestart("muffleWarning")
[13:23:34.926]                     }
[13:23:34.926]                     else if (inherits(cond, "condition")) {
[13:23:34.926]                       if (!is.null(pattern)) {
[13:23:34.926]                         computeRestarts <- base::computeRestarts
[13:23:34.926]                         grepl <- base::grepl
[13:23:34.926]                         restarts <- computeRestarts(cond)
[13:23:34.926]                         for (restart in restarts) {
[13:23:34.926]                           name <- restart$name
[13:23:34.926]                           if (is.null(name)) 
[13:23:34.926]                             next
[13:23:34.926]                           if (!grepl(pattern, name)) 
[13:23:34.926]                             next
[13:23:34.926]                           invokeRestart(restart)
[13:23:34.926]                           muffled <- TRUE
[13:23:34.926]                           break
[13:23:34.926]                         }
[13:23:34.926]                       }
[13:23:34.926]                     }
[13:23:34.926]                     invisible(muffled)
[13:23:34.926]                   }
[13:23:34.926]                   muffleCondition(cond)
[13:23:34.926]                 })
[13:23:34.926]             }))
[13:23:34.926]             future::FutureResult(value = ...future.value$value, 
[13:23:34.926]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:34.926]                   ...future.rng), globalenv = if (FALSE) 
[13:23:34.926]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:34.926]                     ...future.globalenv.names))
[13:23:34.926]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:34.926]         }, condition = base::local({
[13:23:34.926]             c <- base::c
[13:23:34.926]             inherits <- base::inherits
[13:23:34.926]             invokeRestart <- base::invokeRestart
[13:23:34.926]             length <- base::length
[13:23:34.926]             list <- base::list
[13:23:34.926]             seq.int <- base::seq.int
[13:23:34.926]             signalCondition <- base::signalCondition
[13:23:34.926]             sys.calls <- base::sys.calls
[13:23:34.926]             `[[` <- base::`[[`
[13:23:34.926]             `+` <- base::`+`
[13:23:34.926]             `<<-` <- base::`<<-`
[13:23:34.926]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:34.926]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:34.926]                   3L)]
[13:23:34.926]             }
[13:23:34.926]             function(cond) {
[13:23:34.926]                 is_error <- inherits(cond, "error")
[13:23:34.926]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:34.926]                   NULL)
[13:23:34.926]                 if (is_error) {
[13:23:34.926]                   sessionInformation <- function() {
[13:23:34.926]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:34.926]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:34.926]                       search = base::search(), system = base::Sys.info())
[13:23:34.926]                   }
[13:23:34.926]                   ...future.conditions[[length(...future.conditions) + 
[13:23:34.926]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:34.926]                     cond$call), session = sessionInformation(), 
[13:23:34.926]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:34.926]                   signalCondition(cond)
[13:23:34.926]                 }
[13:23:34.926]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:34.926]                 "immediateCondition"))) {
[13:23:34.926]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:34.926]                   ...future.conditions[[length(...future.conditions) + 
[13:23:34.926]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:34.926]                   if (TRUE && !signal) {
[13:23:34.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:34.926]                     {
[13:23:34.926]                       inherits <- base::inherits
[13:23:34.926]                       invokeRestart <- base::invokeRestart
[13:23:34.926]                       is.null <- base::is.null
[13:23:34.926]                       muffled <- FALSE
[13:23:34.926]                       if (inherits(cond, "message")) {
[13:23:34.926]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:34.926]                         if (muffled) 
[13:23:34.926]                           invokeRestart("muffleMessage")
[13:23:34.926]                       }
[13:23:34.926]                       else if (inherits(cond, "warning")) {
[13:23:34.926]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:34.926]                         if (muffled) 
[13:23:34.926]                           invokeRestart("muffleWarning")
[13:23:34.926]                       }
[13:23:34.926]                       else if (inherits(cond, "condition")) {
[13:23:34.926]                         if (!is.null(pattern)) {
[13:23:34.926]                           computeRestarts <- base::computeRestarts
[13:23:34.926]                           grepl <- base::grepl
[13:23:34.926]                           restarts <- computeRestarts(cond)
[13:23:34.926]                           for (restart in restarts) {
[13:23:34.926]                             name <- restart$name
[13:23:34.926]                             if (is.null(name)) 
[13:23:34.926]                               next
[13:23:34.926]                             if (!grepl(pattern, name)) 
[13:23:34.926]                               next
[13:23:34.926]                             invokeRestart(restart)
[13:23:34.926]                             muffled <- TRUE
[13:23:34.926]                             break
[13:23:34.926]                           }
[13:23:34.926]                         }
[13:23:34.926]                       }
[13:23:34.926]                       invisible(muffled)
[13:23:34.926]                     }
[13:23:34.926]                     muffleCondition(cond, pattern = "^muffle")
[13:23:34.926]                   }
[13:23:34.926]                 }
[13:23:34.926]                 else {
[13:23:34.926]                   if (TRUE) {
[13:23:34.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:34.926]                     {
[13:23:34.926]                       inherits <- base::inherits
[13:23:34.926]                       invokeRestart <- base::invokeRestart
[13:23:34.926]                       is.null <- base::is.null
[13:23:34.926]                       muffled <- FALSE
[13:23:34.926]                       if (inherits(cond, "message")) {
[13:23:34.926]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:34.926]                         if (muffled) 
[13:23:34.926]                           invokeRestart("muffleMessage")
[13:23:34.926]                       }
[13:23:34.926]                       else if (inherits(cond, "warning")) {
[13:23:34.926]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:34.926]                         if (muffled) 
[13:23:34.926]                           invokeRestart("muffleWarning")
[13:23:34.926]                       }
[13:23:34.926]                       else if (inherits(cond, "condition")) {
[13:23:34.926]                         if (!is.null(pattern)) {
[13:23:34.926]                           computeRestarts <- base::computeRestarts
[13:23:34.926]                           grepl <- base::grepl
[13:23:34.926]                           restarts <- computeRestarts(cond)
[13:23:34.926]                           for (restart in restarts) {
[13:23:34.926]                             name <- restart$name
[13:23:34.926]                             if (is.null(name)) 
[13:23:34.926]                               next
[13:23:34.926]                             if (!grepl(pattern, name)) 
[13:23:34.926]                               next
[13:23:34.926]                             invokeRestart(restart)
[13:23:34.926]                             muffled <- TRUE
[13:23:34.926]                             break
[13:23:34.926]                           }
[13:23:34.926]                         }
[13:23:34.926]                       }
[13:23:34.926]                       invisible(muffled)
[13:23:34.926]                     }
[13:23:34.926]                     muffleCondition(cond, pattern = "^muffle")
[13:23:34.926]                   }
[13:23:34.926]                 }
[13:23:34.926]             }
[13:23:34.926]         }))
[13:23:34.926]     }, error = function(ex) {
[13:23:34.926]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:34.926]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:34.926]                 ...future.rng), started = ...future.startTime, 
[13:23:34.926]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:34.926]             version = "1.8"), class = "FutureResult")
[13:23:34.926]     }, finally = {
[13:23:34.926]         if (!identical(...future.workdir, getwd())) 
[13:23:34.926]             setwd(...future.workdir)
[13:23:34.926]         {
[13:23:34.926]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:34.926]                 ...future.oldOptions$nwarnings <- NULL
[13:23:34.926]             }
[13:23:34.926]             base::options(...future.oldOptions)
[13:23:34.926]             if (.Platform$OS.type == "windows") {
[13:23:34.926]                 old_names <- names(...future.oldEnvVars)
[13:23:34.926]                 envs <- base::Sys.getenv()
[13:23:34.926]                 names <- names(envs)
[13:23:34.926]                 common <- intersect(names, old_names)
[13:23:34.926]                 added <- setdiff(names, old_names)
[13:23:34.926]                 removed <- setdiff(old_names, names)
[13:23:34.926]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:34.926]                   envs[common]]
[13:23:34.926]                 NAMES <- toupper(changed)
[13:23:34.926]                 args <- list()
[13:23:34.926]                 for (kk in seq_along(NAMES)) {
[13:23:34.926]                   name <- changed[[kk]]
[13:23:34.926]                   NAME <- NAMES[[kk]]
[13:23:34.926]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:34.926]                     next
[13:23:34.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:34.926]                 }
[13:23:34.926]                 NAMES <- toupper(added)
[13:23:34.926]                 for (kk in seq_along(NAMES)) {
[13:23:34.926]                   name <- added[[kk]]
[13:23:34.926]                   NAME <- NAMES[[kk]]
[13:23:34.926]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:34.926]                     next
[13:23:34.926]                   args[[name]] <- ""
[13:23:34.926]                 }
[13:23:34.926]                 NAMES <- toupper(removed)
[13:23:34.926]                 for (kk in seq_along(NAMES)) {
[13:23:34.926]                   name <- removed[[kk]]
[13:23:34.926]                   NAME <- NAMES[[kk]]
[13:23:34.926]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:34.926]                     next
[13:23:34.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:34.926]                 }
[13:23:34.926]                 if (length(args) > 0) 
[13:23:34.926]                   base::do.call(base::Sys.setenv, args = args)
[13:23:34.926]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:34.926]             }
[13:23:34.926]             else {
[13:23:34.926]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:34.926]             }
[13:23:34.926]             {
[13:23:34.926]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:34.926]                   0L) {
[13:23:34.926]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:34.926]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:34.926]                   base::options(opts)
[13:23:34.926]                 }
[13:23:34.926]                 {
[13:23:34.926]                   {
[13:23:34.926]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:34.926]                     NULL
[13:23:34.926]                   }
[13:23:34.926]                   options(future.plan = NULL)
[13:23:34.926]                   if (is.na(NA_character_)) 
[13:23:34.926]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:34.926]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:34.926]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:34.926]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:34.926]                     envir = parent.frame()) 
[13:23:34.926]                   {
[13:23:34.926]                     if (is.function(workers)) 
[13:23:34.926]                       workers <- workers()
[13:23:34.926]                     workers <- structure(as.integer(workers), 
[13:23:34.926]                       class = class(workers))
[13:23:34.926]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:34.926]                       workers >= 1)
[13:23:34.926]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:34.926]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:34.926]                     }
[13:23:34.926]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:34.926]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:34.926]                       envir = envir)
[13:23:34.926]                     if (!future$lazy) 
[13:23:34.926]                       future <- run(future)
[13:23:34.926]                     invisible(future)
[13:23:34.926]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:34.926]                 }
[13:23:34.926]             }
[13:23:34.926]         }
[13:23:34.926]     })
[13:23:34.926]     if (TRUE) {
[13:23:34.926]         base::sink(type = "output", split = FALSE)
[13:23:34.926]         if (TRUE) {
[13:23:34.926]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:34.926]         }
[13:23:34.926]         else {
[13:23:34.926]             ...future.result["stdout"] <- base::list(NULL)
[13:23:34.926]         }
[13:23:34.926]         base::close(...future.stdout)
[13:23:34.926]         ...future.stdout <- NULL
[13:23:34.926]     }
[13:23:34.926]     ...future.result$conditions <- ...future.conditions
[13:23:34.926]     ...future.result$finished <- base::Sys.time()
[13:23:34.926]     ...future.result
[13:23:34.926] }
[13:23:34.929] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:23:34.929] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:23:34.930] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:23:34.930] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:23:34.930] MultisessionFuture started
[13:23:34.930] - Launch lazy future ... done
[13:23:34.931] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:34.931] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:34.931] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:34.933] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:34.933] Searching for globals ... DONE
[13:23:34.933] Resolving globals: TRUE
[13:23:34.933] Resolving any globals that are futures ...
[13:23:34.933] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:34.933] Resolving any globals that are futures ... DONE
[13:23:34.934] Resolving futures part of globals (recursively) ...
[13:23:34.934] resolve() on list ...
[13:23:34.934]  recursive: 99
[13:23:34.934]  length: 1
[13:23:34.934]  elements: ‘ii’
[13:23:34.934]  length: 0 (resolved future 1)
[13:23:34.934] resolve() on list ... DONE
[13:23:34.934] - globals: [1] ‘ii’
[13:23:34.934] Resolving futures part of globals (recursively) ... DONE
[13:23:34.935] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:34.935] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:34.935] - globals: [1] ‘ii’
[13:23:34.935] 
[13:23:34.935] getGlobalsAndPackages() ... DONE
[13:23:34.936] run() for ‘Future’ ...
[13:23:34.936] - state: ‘created’
[13:23:34.936] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:34.950] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:34.950] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:34.950]   - Field: ‘node’
[13:23:34.950]   - Field: ‘label’
[13:23:34.950]   - Field: ‘local’
[13:23:34.950]   - Field: ‘owner’
[13:23:34.950]   - Field: ‘envir’
[13:23:34.951]   - Field: ‘workers’
[13:23:34.951]   - Field: ‘packages’
[13:23:34.951]   - Field: ‘gc’
[13:23:34.951]   - Field: ‘conditions’
[13:23:34.951]   - Field: ‘persistent’
[13:23:34.951]   - Field: ‘expr’
[13:23:34.951]   - Field: ‘uuid’
[13:23:34.951]   - Field: ‘seed’
[13:23:34.951]   - Field: ‘version’
[13:23:34.951]   - Field: ‘result’
[13:23:34.951]   - Field: ‘asynchronous’
[13:23:34.952]   - Field: ‘calls’
[13:23:34.952]   - Field: ‘globals’
[13:23:34.952]   - Field: ‘stdout’
[13:23:34.952]   - Field: ‘earlySignal’
[13:23:34.952]   - Field: ‘lazy’
[13:23:34.952]   - Field: ‘state’
[13:23:34.952] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:34.952] - Launch lazy future ...
[13:23:34.953] Packages needed by the future expression (n = 0): <none>
[13:23:34.953] Packages needed by future strategies (n = 0): <none>
[13:23:34.953] {
[13:23:34.953]     {
[13:23:34.953]         {
[13:23:34.953]             ...future.startTime <- base::Sys.time()
[13:23:34.953]             {
[13:23:34.953]                 {
[13:23:34.953]                   {
[13:23:34.953]                     {
[13:23:34.953]                       base::local({
[13:23:34.953]                         has_future <- base::requireNamespace("future", 
[13:23:34.953]                           quietly = TRUE)
[13:23:34.953]                         if (has_future) {
[13:23:34.953]                           ns <- base::getNamespace("future")
[13:23:34.953]                           version <- ns[[".package"]][["version"]]
[13:23:34.953]                           if (is.null(version)) 
[13:23:34.953]                             version <- utils::packageVersion("future")
[13:23:34.953]                         }
[13:23:34.953]                         else {
[13:23:34.953]                           version <- NULL
[13:23:34.953]                         }
[13:23:34.953]                         if (!has_future || version < "1.8.0") {
[13:23:34.953]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:34.953]                             "", base::R.version$version.string), 
[13:23:34.953]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:34.953]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:34.953]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:34.953]                               "release", "version")], collapse = " "), 
[13:23:34.953]                             hostname = base::Sys.info()[["nodename"]])
[13:23:34.953]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:34.953]                             info)
[13:23:34.953]                           info <- base::paste(info, collapse = "; ")
[13:23:34.953]                           if (!has_future) {
[13:23:34.953]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:34.953]                               info)
[13:23:34.953]                           }
[13:23:34.953]                           else {
[13:23:34.953]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:34.953]                               info, version)
[13:23:34.953]                           }
[13:23:34.953]                           base::stop(msg)
[13:23:34.953]                         }
[13:23:34.953]                       })
[13:23:34.953]                     }
[13:23:34.953]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:34.953]                     base::options(mc.cores = 1L)
[13:23:34.953]                   }
[13:23:34.953]                   options(future.plan = NULL)
[13:23:34.953]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:34.953]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:34.953]                 }
[13:23:34.953]                 ...future.workdir <- getwd()
[13:23:34.953]             }
[13:23:34.953]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:34.953]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:34.953]         }
[13:23:34.953]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:34.953]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:34.953]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:34.953]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:34.953]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:34.953]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:34.953]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:34.953]             base::names(...future.oldOptions))
[13:23:34.953]     }
[13:23:34.953]     if (FALSE) {
[13:23:34.953]     }
[13:23:34.953]     else {
[13:23:34.953]         if (TRUE) {
[13:23:34.953]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:34.953]                 open = "w")
[13:23:34.953]         }
[13:23:34.953]         else {
[13:23:34.953]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:34.953]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:34.953]         }
[13:23:34.953]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:34.953]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:34.953]             base::sink(type = "output", split = FALSE)
[13:23:34.953]             base::close(...future.stdout)
[13:23:34.953]         }, add = TRUE)
[13:23:34.953]     }
[13:23:34.953]     ...future.frame <- base::sys.nframe()
[13:23:34.953]     ...future.conditions <- base::list()
[13:23:34.953]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:34.953]     if (FALSE) {
[13:23:34.953]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:34.953]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:34.953]     }
[13:23:34.953]     ...future.result <- base::tryCatch({
[13:23:34.953]         base::withCallingHandlers({
[13:23:34.953]             ...future.value <- base::withVisible(base::local({
[13:23:34.953]                 ...future.makeSendCondition <- base::local({
[13:23:34.953]                   sendCondition <- NULL
[13:23:34.953]                   function(frame = 1L) {
[13:23:34.953]                     if (is.function(sendCondition)) 
[13:23:34.953]                       return(sendCondition)
[13:23:34.953]                     ns <- getNamespace("parallel")
[13:23:34.953]                     if (exists("sendData", mode = "function", 
[13:23:34.953]                       envir = ns)) {
[13:23:34.953]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:34.953]                         envir = ns)
[13:23:34.953]                       envir <- sys.frame(frame)
[13:23:34.953]                       master <- NULL
[13:23:34.953]                       while (!identical(envir, .GlobalEnv) && 
[13:23:34.953]                         !identical(envir, emptyenv())) {
[13:23:34.953]                         if (exists("master", mode = "list", envir = envir, 
[13:23:34.953]                           inherits = FALSE)) {
[13:23:34.953]                           master <- get("master", mode = "list", 
[13:23:34.953]                             envir = envir, inherits = FALSE)
[13:23:34.953]                           if (inherits(master, c("SOCKnode", 
[13:23:34.953]                             "SOCK0node"))) {
[13:23:34.953]                             sendCondition <<- function(cond) {
[13:23:34.953]                               data <- list(type = "VALUE", value = cond, 
[13:23:34.953]                                 success = TRUE)
[13:23:34.953]                               parallel_sendData(master, data)
[13:23:34.953]                             }
[13:23:34.953]                             return(sendCondition)
[13:23:34.953]                           }
[13:23:34.953]                         }
[13:23:34.953]                         frame <- frame + 1L
[13:23:34.953]                         envir <- sys.frame(frame)
[13:23:34.953]                       }
[13:23:34.953]                     }
[13:23:34.953]                     sendCondition <<- function(cond) NULL
[13:23:34.953]                   }
[13:23:34.953]                 })
[13:23:34.953]                 withCallingHandlers({
[13:23:34.953]                   {
[13:23:34.953]                     b <- a * ii
[13:23:34.953]                     a <- 0
[13:23:34.953]                     b
[13:23:34.953]                   }
[13:23:34.953]                 }, immediateCondition = function(cond) {
[13:23:34.953]                   sendCondition <- ...future.makeSendCondition()
[13:23:34.953]                   sendCondition(cond)
[13:23:34.953]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:34.953]                   {
[13:23:34.953]                     inherits <- base::inherits
[13:23:34.953]                     invokeRestart <- base::invokeRestart
[13:23:34.953]                     is.null <- base::is.null
[13:23:34.953]                     muffled <- FALSE
[13:23:34.953]                     if (inherits(cond, "message")) {
[13:23:34.953]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:34.953]                       if (muffled) 
[13:23:34.953]                         invokeRestart("muffleMessage")
[13:23:34.953]                     }
[13:23:34.953]                     else if (inherits(cond, "warning")) {
[13:23:34.953]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:34.953]                       if (muffled) 
[13:23:34.953]                         invokeRestart("muffleWarning")
[13:23:34.953]                     }
[13:23:34.953]                     else if (inherits(cond, "condition")) {
[13:23:34.953]                       if (!is.null(pattern)) {
[13:23:34.953]                         computeRestarts <- base::computeRestarts
[13:23:34.953]                         grepl <- base::grepl
[13:23:34.953]                         restarts <- computeRestarts(cond)
[13:23:34.953]                         for (restart in restarts) {
[13:23:34.953]                           name <- restart$name
[13:23:34.953]                           if (is.null(name)) 
[13:23:34.953]                             next
[13:23:34.953]                           if (!grepl(pattern, name)) 
[13:23:34.953]                             next
[13:23:34.953]                           invokeRestart(restart)
[13:23:34.953]                           muffled <- TRUE
[13:23:34.953]                           break
[13:23:34.953]                         }
[13:23:34.953]                       }
[13:23:34.953]                     }
[13:23:34.953]                     invisible(muffled)
[13:23:34.953]                   }
[13:23:34.953]                   muffleCondition(cond)
[13:23:34.953]                 })
[13:23:34.953]             }))
[13:23:34.953]             future::FutureResult(value = ...future.value$value, 
[13:23:34.953]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:34.953]                   ...future.rng), globalenv = if (FALSE) 
[13:23:34.953]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:34.953]                     ...future.globalenv.names))
[13:23:34.953]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:34.953]         }, condition = base::local({
[13:23:34.953]             c <- base::c
[13:23:34.953]             inherits <- base::inherits
[13:23:34.953]             invokeRestart <- base::invokeRestart
[13:23:34.953]             length <- base::length
[13:23:34.953]             list <- base::list
[13:23:34.953]             seq.int <- base::seq.int
[13:23:34.953]             signalCondition <- base::signalCondition
[13:23:34.953]             sys.calls <- base::sys.calls
[13:23:34.953]             `[[` <- base::`[[`
[13:23:34.953]             `+` <- base::`+`
[13:23:34.953]             `<<-` <- base::`<<-`
[13:23:34.953]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:34.953]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:34.953]                   3L)]
[13:23:34.953]             }
[13:23:34.953]             function(cond) {
[13:23:34.953]                 is_error <- inherits(cond, "error")
[13:23:34.953]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:34.953]                   NULL)
[13:23:34.953]                 if (is_error) {
[13:23:34.953]                   sessionInformation <- function() {
[13:23:34.953]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:34.953]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:34.953]                       search = base::search(), system = base::Sys.info())
[13:23:34.953]                   }
[13:23:34.953]                   ...future.conditions[[length(...future.conditions) + 
[13:23:34.953]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:34.953]                     cond$call), session = sessionInformation(), 
[13:23:34.953]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:34.953]                   signalCondition(cond)
[13:23:34.953]                 }
[13:23:34.953]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:34.953]                 "immediateCondition"))) {
[13:23:34.953]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:34.953]                   ...future.conditions[[length(...future.conditions) + 
[13:23:34.953]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:34.953]                   if (TRUE && !signal) {
[13:23:34.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:34.953]                     {
[13:23:34.953]                       inherits <- base::inherits
[13:23:34.953]                       invokeRestart <- base::invokeRestart
[13:23:34.953]                       is.null <- base::is.null
[13:23:34.953]                       muffled <- FALSE
[13:23:34.953]                       if (inherits(cond, "message")) {
[13:23:34.953]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:34.953]                         if (muffled) 
[13:23:34.953]                           invokeRestart("muffleMessage")
[13:23:34.953]                       }
[13:23:34.953]                       else if (inherits(cond, "warning")) {
[13:23:34.953]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:34.953]                         if (muffled) 
[13:23:34.953]                           invokeRestart("muffleWarning")
[13:23:34.953]                       }
[13:23:34.953]                       else if (inherits(cond, "condition")) {
[13:23:34.953]                         if (!is.null(pattern)) {
[13:23:34.953]                           computeRestarts <- base::computeRestarts
[13:23:34.953]                           grepl <- base::grepl
[13:23:34.953]                           restarts <- computeRestarts(cond)
[13:23:34.953]                           for (restart in restarts) {
[13:23:34.953]                             name <- restart$name
[13:23:34.953]                             if (is.null(name)) 
[13:23:34.953]                               next
[13:23:34.953]                             if (!grepl(pattern, name)) 
[13:23:34.953]                               next
[13:23:34.953]                             invokeRestart(restart)
[13:23:34.953]                             muffled <- TRUE
[13:23:34.953]                             break
[13:23:34.953]                           }
[13:23:34.953]                         }
[13:23:34.953]                       }
[13:23:34.953]                       invisible(muffled)
[13:23:34.953]                     }
[13:23:34.953]                     muffleCondition(cond, pattern = "^muffle")
[13:23:34.953]                   }
[13:23:34.953]                 }
[13:23:34.953]                 else {
[13:23:34.953]                   if (TRUE) {
[13:23:34.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:34.953]                     {
[13:23:34.953]                       inherits <- base::inherits
[13:23:34.953]                       invokeRestart <- base::invokeRestart
[13:23:34.953]                       is.null <- base::is.null
[13:23:34.953]                       muffled <- FALSE
[13:23:34.953]                       if (inherits(cond, "message")) {
[13:23:34.953]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:34.953]                         if (muffled) 
[13:23:34.953]                           invokeRestart("muffleMessage")
[13:23:34.953]                       }
[13:23:34.953]                       else if (inherits(cond, "warning")) {
[13:23:34.953]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:34.953]                         if (muffled) 
[13:23:34.953]                           invokeRestart("muffleWarning")
[13:23:34.953]                       }
[13:23:34.953]                       else if (inherits(cond, "condition")) {
[13:23:34.953]                         if (!is.null(pattern)) {
[13:23:34.953]                           computeRestarts <- base::computeRestarts
[13:23:34.953]                           grepl <- base::grepl
[13:23:34.953]                           restarts <- computeRestarts(cond)
[13:23:34.953]                           for (restart in restarts) {
[13:23:34.953]                             name <- restart$name
[13:23:34.953]                             if (is.null(name)) 
[13:23:34.953]                               next
[13:23:34.953]                             if (!grepl(pattern, name)) 
[13:23:34.953]                               next
[13:23:34.953]                             invokeRestart(restart)
[13:23:34.953]                             muffled <- TRUE
[13:23:34.953]                             break
[13:23:34.953]                           }
[13:23:34.953]                         }
[13:23:34.953]                       }
[13:23:34.953]                       invisible(muffled)
[13:23:34.953]                     }
[13:23:34.953]                     muffleCondition(cond, pattern = "^muffle")
[13:23:34.953]                   }
[13:23:34.953]                 }
[13:23:34.953]             }
[13:23:34.953]         }))
[13:23:34.953]     }, error = function(ex) {
[13:23:34.953]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:34.953]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:34.953]                 ...future.rng), started = ...future.startTime, 
[13:23:34.953]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:34.953]             version = "1.8"), class = "FutureResult")
[13:23:34.953]     }, finally = {
[13:23:34.953]         if (!identical(...future.workdir, getwd())) 
[13:23:34.953]             setwd(...future.workdir)
[13:23:34.953]         {
[13:23:34.953]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:34.953]                 ...future.oldOptions$nwarnings <- NULL
[13:23:34.953]             }
[13:23:34.953]             base::options(...future.oldOptions)
[13:23:34.953]             if (.Platform$OS.type == "windows") {
[13:23:34.953]                 old_names <- names(...future.oldEnvVars)
[13:23:34.953]                 envs <- base::Sys.getenv()
[13:23:34.953]                 names <- names(envs)
[13:23:34.953]                 common <- intersect(names, old_names)
[13:23:34.953]                 added <- setdiff(names, old_names)
[13:23:34.953]                 removed <- setdiff(old_names, names)
[13:23:34.953]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:34.953]                   envs[common]]
[13:23:34.953]                 NAMES <- toupper(changed)
[13:23:34.953]                 args <- list()
[13:23:34.953]                 for (kk in seq_along(NAMES)) {
[13:23:34.953]                   name <- changed[[kk]]
[13:23:34.953]                   NAME <- NAMES[[kk]]
[13:23:34.953]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:34.953]                     next
[13:23:34.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:34.953]                 }
[13:23:34.953]                 NAMES <- toupper(added)
[13:23:34.953]                 for (kk in seq_along(NAMES)) {
[13:23:34.953]                   name <- added[[kk]]
[13:23:34.953]                   NAME <- NAMES[[kk]]
[13:23:34.953]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:34.953]                     next
[13:23:34.953]                   args[[name]] <- ""
[13:23:34.953]                 }
[13:23:34.953]                 NAMES <- toupper(removed)
[13:23:34.953]                 for (kk in seq_along(NAMES)) {
[13:23:34.953]                   name <- removed[[kk]]
[13:23:34.953]                   NAME <- NAMES[[kk]]
[13:23:34.953]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:34.953]                     next
[13:23:34.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:34.953]                 }
[13:23:34.953]                 if (length(args) > 0) 
[13:23:34.953]                   base::do.call(base::Sys.setenv, args = args)
[13:23:34.953]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:34.953]             }
[13:23:34.953]             else {
[13:23:34.953]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:34.953]             }
[13:23:34.953]             {
[13:23:34.953]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:34.953]                   0L) {
[13:23:34.953]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:34.953]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:34.953]                   base::options(opts)
[13:23:34.953]                 }
[13:23:34.953]                 {
[13:23:34.953]                   {
[13:23:34.953]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:34.953]                     NULL
[13:23:34.953]                   }
[13:23:34.953]                   options(future.plan = NULL)
[13:23:34.953]                   if (is.na(NA_character_)) 
[13:23:34.953]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:34.953]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:34.953]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:34.953]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:34.953]                     envir = parent.frame()) 
[13:23:34.953]                   {
[13:23:34.953]                     if (is.function(workers)) 
[13:23:34.953]                       workers <- workers()
[13:23:34.953]                     workers <- structure(as.integer(workers), 
[13:23:34.953]                       class = class(workers))
[13:23:34.953]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:34.953]                       workers >= 1)
[13:23:34.953]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:34.953]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:34.953]                     }
[13:23:34.953]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:34.953]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:34.953]                       envir = envir)
[13:23:34.953]                     if (!future$lazy) 
[13:23:34.953]                       future <- run(future)
[13:23:34.953]                     invisible(future)
[13:23:34.953]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:34.953]                 }
[13:23:34.953]             }
[13:23:34.953]         }
[13:23:34.953]     })
[13:23:34.953]     if (TRUE) {
[13:23:34.953]         base::sink(type = "output", split = FALSE)
[13:23:34.953]         if (TRUE) {
[13:23:34.953]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:34.953]         }
[13:23:34.953]         else {
[13:23:34.953]             ...future.result["stdout"] <- base::list(NULL)
[13:23:34.953]         }
[13:23:34.953]         base::close(...future.stdout)
[13:23:34.953]         ...future.stdout <- NULL
[13:23:34.953]     }
[13:23:34.953]     ...future.result$conditions <- ...future.conditions
[13:23:34.953]     ...future.result$finished <- base::Sys.time()
[13:23:34.953]     ...future.result
[13:23:34.953] }
[13:23:35.010] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[13:23:35.010] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[13:23:35.011] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[13:23:35.011] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[13:23:35.012] MultisessionFuture started
[13:23:35.012] - Launch lazy future ... done
[13:23:35.012] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:35.012] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:35.013] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:35.014] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:35.014] Searching for globals ... DONE
[13:23:35.014] Resolving globals: TRUE
[13:23:35.014] Resolving any globals that are futures ...
[13:23:35.015] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:35.015] Resolving any globals that are futures ... DONE
[13:23:35.015] Resolving futures part of globals (recursively) ...
[13:23:35.015] resolve() on list ...
[13:23:35.015]  recursive: 99
[13:23:35.015]  length: 1
[13:23:35.015]  elements: ‘ii’
[13:23:35.016]  length: 0 (resolved future 1)
[13:23:35.016] resolve() on list ... DONE
[13:23:35.016] - globals: [1] ‘ii’
[13:23:35.016] Resolving futures part of globals (recursively) ... DONE
[13:23:35.016] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:35.016] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:35.017] - globals: [1] ‘ii’
[13:23:35.017] 
[13:23:35.017] getGlobalsAndPackages() ... DONE
[13:23:35.017] run() for ‘Future’ ...
[13:23:35.017] - state: ‘created’
[13:23:35.017] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:35.031] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:35.032] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:35.032]   - Field: ‘node’
[13:23:35.032]   - Field: ‘label’
[13:23:35.032]   - Field: ‘local’
[13:23:35.032]   - Field: ‘owner’
[13:23:35.032]   - Field: ‘envir’
[13:23:35.032]   - Field: ‘workers’
[13:23:35.032]   - Field: ‘packages’
[13:23:35.033]   - Field: ‘gc’
[13:23:35.033]   - Field: ‘conditions’
[13:23:35.033]   - Field: ‘persistent’
[13:23:35.033]   - Field: ‘expr’
[13:23:35.033]   - Field: ‘uuid’
[13:23:35.033]   - Field: ‘seed’
[13:23:35.033]   - Field: ‘version’
[13:23:35.033]   - Field: ‘result’
[13:23:35.033]   - Field: ‘asynchronous’
[13:23:35.033]   - Field: ‘calls’
[13:23:35.034]   - Field: ‘globals’
[13:23:35.034]   - Field: ‘stdout’
[13:23:35.034]   - Field: ‘earlySignal’
[13:23:35.034]   - Field: ‘lazy’
[13:23:35.034]   - Field: ‘state’
[13:23:35.034] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:35.034] - Launch lazy future ...
[13:23:35.034] Packages needed by the future expression (n = 0): <none>
[13:23:35.035] Packages needed by future strategies (n = 0): <none>
[13:23:35.035] {
[13:23:35.035]     {
[13:23:35.035]         {
[13:23:35.035]             ...future.startTime <- base::Sys.time()
[13:23:35.035]             {
[13:23:35.035]                 {
[13:23:35.035]                   {
[13:23:35.035]                     {
[13:23:35.035]                       base::local({
[13:23:35.035]                         has_future <- base::requireNamespace("future", 
[13:23:35.035]                           quietly = TRUE)
[13:23:35.035]                         if (has_future) {
[13:23:35.035]                           ns <- base::getNamespace("future")
[13:23:35.035]                           version <- ns[[".package"]][["version"]]
[13:23:35.035]                           if (is.null(version)) 
[13:23:35.035]                             version <- utils::packageVersion("future")
[13:23:35.035]                         }
[13:23:35.035]                         else {
[13:23:35.035]                           version <- NULL
[13:23:35.035]                         }
[13:23:35.035]                         if (!has_future || version < "1.8.0") {
[13:23:35.035]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:35.035]                             "", base::R.version$version.string), 
[13:23:35.035]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:35.035]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:35.035]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:35.035]                               "release", "version")], collapse = " "), 
[13:23:35.035]                             hostname = base::Sys.info()[["nodename"]])
[13:23:35.035]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:35.035]                             info)
[13:23:35.035]                           info <- base::paste(info, collapse = "; ")
[13:23:35.035]                           if (!has_future) {
[13:23:35.035]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:35.035]                               info)
[13:23:35.035]                           }
[13:23:35.035]                           else {
[13:23:35.035]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:35.035]                               info, version)
[13:23:35.035]                           }
[13:23:35.035]                           base::stop(msg)
[13:23:35.035]                         }
[13:23:35.035]                       })
[13:23:35.035]                     }
[13:23:35.035]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:35.035]                     base::options(mc.cores = 1L)
[13:23:35.035]                   }
[13:23:35.035]                   options(future.plan = NULL)
[13:23:35.035]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:35.035]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:35.035]                 }
[13:23:35.035]                 ...future.workdir <- getwd()
[13:23:35.035]             }
[13:23:35.035]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:35.035]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:35.035]         }
[13:23:35.035]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:35.035]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:35.035]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:35.035]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:35.035]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:35.035]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:35.035]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:35.035]             base::names(...future.oldOptions))
[13:23:35.035]     }
[13:23:35.035]     if (FALSE) {
[13:23:35.035]     }
[13:23:35.035]     else {
[13:23:35.035]         if (TRUE) {
[13:23:35.035]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:35.035]                 open = "w")
[13:23:35.035]         }
[13:23:35.035]         else {
[13:23:35.035]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:35.035]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:35.035]         }
[13:23:35.035]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:35.035]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:35.035]             base::sink(type = "output", split = FALSE)
[13:23:35.035]             base::close(...future.stdout)
[13:23:35.035]         }, add = TRUE)
[13:23:35.035]     }
[13:23:35.035]     ...future.frame <- base::sys.nframe()
[13:23:35.035]     ...future.conditions <- base::list()
[13:23:35.035]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:35.035]     if (FALSE) {
[13:23:35.035]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:35.035]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:35.035]     }
[13:23:35.035]     ...future.result <- base::tryCatch({
[13:23:35.035]         base::withCallingHandlers({
[13:23:35.035]             ...future.value <- base::withVisible(base::local({
[13:23:35.035]                 ...future.makeSendCondition <- base::local({
[13:23:35.035]                   sendCondition <- NULL
[13:23:35.035]                   function(frame = 1L) {
[13:23:35.035]                     if (is.function(sendCondition)) 
[13:23:35.035]                       return(sendCondition)
[13:23:35.035]                     ns <- getNamespace("parallel")
[13:23:35.035]                     if (exists("sendData", mode = "function", 
[13:23:35.035]                       envir = ns)) {
[13:23:35.035]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:35.035]                         envir = ns)
[13:23:35.035]                       envir <- sys.frame(frame)
[13:23:35.035]                       master <- NULL
[13:23:35.035]                       while (!identical(envir, .GlobalEnv) && 
[13:23:35.035]                         !identical(envir, emptyenv())) {
[13:23:35.035]                         if (exists("master", mode = "list", envir = envir, 
[13:23:35.035]                           inherits = FALSE)) {
[13:23:35.035]                           master <- get("master", mode = "list", 
[13:23:35.035]                             envir = envir, inherits = FALSE)
[13:23:35.035]                           if (inherits(master, c("SOCKnode", 
[13:23:35.035]                             "SOCK0node"))) {
[13:23:35.035]                             sendCondition <<- function(cond) {
[13:23:35.035]                               data <- list(type = "VALUE", value = cond, 
[13:23:35.035]                                 success = TRUE)
[13:23:35.035]                               parallel_sendData(master, data)
[13:23:35.035]                             }
[13:23:35.035]                             return(sendCondition)
[13:23:35.035]                           }
[13:23:35.035]                         }
[13:23:35.035]                         frame <- frame + 1L
[13:23:35.035]                         envir <- sys.frame(frame)
[13:23:35.035]                       }
[13:23:35.035]                     }
[13:23:35.035]                     sendCondition <<- function(cond) NULL
[13:23:35.035]                   }
[13:23:35.035]                 })
[13:23:35.035]                 withCallingHandlers({
[13:23:35.035]                   {
[13:23:35.035]                     b <- a * ii
[13:23:35.035]                     a <- 0
[13:23:35.035]                     b
[13:23:35.035]                   }
[13:23:35.035]                 }, immediateCondition = function(cond) {
[13:23:35.035]                   sendCondition <- ...future.makeSendCondition()
[13:23:35.035]                   sendCondition(cond)
[13:23:35.035]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.035]                   {
[13:23:35.035]                     inherits <- base::inherits
[13:23:35.035]                     invokeRestart <- base::invokeRestart
[13:23:35.035]                     is.null <- base::is.null
[13:23:35.035]                     muffled <- FALSE
[13:23:35.035]                     if (inherits(cond, "message")) {
[13:23:35.035]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:35.035]                       if (muffled) 
[13:23:35.035]                         invokeRestart("muffleMessage")
[13:23:35.035]                     }
[13:23:35.035]                     else if (inherits(cond, "warning")) {
[13:23:35.035]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:35.035]                       if (muffled) 
[13:23:35.035]                         invokeRestart("muffleWarning")
[13:23:35.035]                     }
[13:23:35.035]                     else if (inherits(cond, "condition")) {
[13:23:35.035]                       if (!is.null(pattern)) {
[13:23:35.035]                         computeRestarts <- base::computeRestarts
[13:23:35.035]                         grepl <- base::grepl
[13:23:35.035]                         restarts <- computeRestarts(cond)
[13:23:35.035]                         for (restart in restarts) {
[13:23:35.035]                           name <- restart$name
[13:23:35.035]                           if (is.null(name)) 
[13:23:35.035]                             next
[13:23:35.035]                           if (!grepl(pattern, name)) 
[13:23:35.035]                             next
[13:23:35.035]                           invokeRestart(restart)
[13:23:35.035]                           muffled <- TRUE
[13:23:35.035]                           break
[13:23:35.035]                         }
[13:23:35.035]                       }
[13:23:35.035]                     }
[13:23:35.035]                     invisible(muffled)
[13:23:35.035]                   }
[13:23:35.035]                   muffleCondition(cond)
[13:23:35.035]                 })
[13:23:35.035]             }))
[13:23:35.035]             future::FutureResult(value = ...future.value$value, 
[13:23:35.035]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:35.035]                   ...future.rng), globalenv = if (FALSE) 
[13:23:35.035]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:35.035]                     ...future.globalenv.names))
[13:23:35.035]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:35.035]         }, condition = base::local({
[13:23:35.035]             c <- base::c
[13:23:35.035]             inherits <- base::inherits
[13:23:35.035]             invokeRestart <- base::invokeRestart
[13:23:35.035]             length <- base::length
[13:23:35.035]             list <- base::list
[13:23:35.035]             seq.int <- base::seq.int
[13:23:35.035]             signalCondition <- base::signalCondition
[13:23:35.035]             sys.calls <- base::sys.calls
[13:23:35.035]             `[[` <- base::`[[`
[13:23:35.035]             `+` <- base::`+`
[13:23:35.035]             `<<-` <- base::`<<-`
[13:23:35.035]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:35.035]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:35.035]                   3L)]
[13:23:35.035]             }
[13:23:35.035]             function(cond) {
[13:23:35.035]                 is_error <- inherits(cond, "error")
[13:23:35.035]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:35.035]                   NULL)
[13:23:35.035]                 if (is_error) {
[13:23:35.035]                   sessionInformation <- function() {
[13:23:35.035]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:35.035]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:35.035]                       search = base::search(), system = base::Sys.info())
[13:23:35.035]                   }
[13:23:35.035]                   ...future.conditions[[length(...future.conditions) + 
[13:23:35.035]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:35.035]                     cond$call), session = sessionInformation(), 
[13:23:35.035]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:35.035]                   signalCondition(cond)
[13:23:35.035]                 }
[13:23:35.035]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:35.035]                 "immediateCondition"))) {
[13:23:35.035]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:35.035]                   ...future.conditions[[length(...future.conditions) + 
[13:23:35.035]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:35.035]                   if (TRUE && !signal) {
[13:23:35.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.035]                     {
[13:23:35.035]                       inherits <- base::inherits
[13:23:35.035]                       invokeRestart <- base::invokeRestart
[13:23:35.035]                       is.null <- base::is.null
[13:23:35.035]                       muffled <- FALSE
[13:23:35.035]                       if (inherits(cond, "message")) {
[13:23:35.035]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:35.035]                         if (muffled) 
[13:23:35.035]                           invokeRestart("muffleMessage")
[13:23:35.035]                       }
[13:23:35.035]                       else if (inherits(cond, "warning")) {
[13:23:35.035]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:35.035]                         if (muffled) 
[13:23:35.035]                           invokeRestart("muffleWarning")
[13:23:35.035]                       }
[13:23:35.035]                       else if (inherits(cond, "condition")) {
[13:23:35.035]                         if (!is.null(pattern)) {
[13:23:35.035]                           computeRestarts <- base::computeRestarts
[13:23:35.035]                           grepl <- base::grepl
[13:23:35.035]                           restarts <- computeRestarts(cond)
[13:23:35.035]                           for (restart in restarts) {
[13:23:35.035]                             name <- restart$name
[13:23:35.035]                             if (is.null(name)) 
[13:23:35.035]                               next
[13:23:35.035]                             if (!grepl(pattern, name)) 
[13:23:35.035]                               next
[13:23:35.035]                             invokeRestart(restart)
[13:23:35.035]                             muffled <- TRUE
[13:23:35.035]                             break
[13:23:35.035]                           }
[13:23:35.035]                         }
[13:23:35.035]                       }
[13:23:35.035]                       invisible(muffled)
[13:23:35.035]                     }
[13:23:35.035]                     muffleCondition(cond, pattern = "^muffle")
[13:23:35.035]                   }
[13:23:35.035]                 }
[13:23:35.035]                 else {
[13:23:35.035]                   if (TRUE) {
[13:23:35.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.035]                     {
[13:23:35.035]                       inherits <- base::inherits
[13:23:35.035]                       invokeRestart <- base::invokeRestart
[13:23:35.035]                       is.null <- base::is.null
[13:23:35.035]                       muffled <- FALSE
[13:23:35.035]                       if (inherits(cond, "message")) {
[13:23:35.035]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:35.035]                         if (muffled) 
[13:23:35.035]                           invokeRestart("muffleMessage")
[13:23:35.035]                       }
[13:23:35.035]                       else if (inherits(cond, "warning")) {
[13:23:35.035]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:35.035]                         if (muffled) 
[13:23:35.035]                           invokeRestart("muffleWarning")
[13:23:35.035]                       }
[13:23:35.035]                       else if (inherits(cond, "condition")) {
[13:23:35.035]                         if (!is.null(pattern)) {
[13:23:35.035]                           computeRestarts <- base::computeRestarts
[13:23:35.035]                           grepl <- base::grepl
[13:23:35.035]                           restarts <- computeRestarts(cond)
[13:23:35.035]                           for (restart in restarts) {
[13:23:35.035]                             name <- restart$name
[13:23:35.035]                             if (is.null(name)) 
[13:23:35.035]                               next
[13:23:35.035]                             if (!grepl(pattern, name)) 
[13:23:35.035]                               next
[13:23:35.035]                             invokeRestart(restart)
[13:23:35.035]                             muffled <- TRUE
[13:23:35.035]                             break
[13:23:35.035]                           }
[13:23:35.035]                         }
[13:23:35.035]                       }
[13:23:35.035]                       invisible(muffled)
[13:23:35.035]                     }
[13:23:35.035]                     muffleCondition(cond, pattern = "^muffle")
[13:23:35.035]                   }
[13:23:35.035]                 }
[13:23:35.035]             }
[13:23:35.035]         }))
[13:23:35.035]     }, error = function(ex) {
[13:23:35.035]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:35.035]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:35.035]                 ...future.rng), started = ...future.startTime, 
[13:23:35.035]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:35.035]             version = "1.8"), class = "FutureResult")
[13:23:35.035]     }, finally = {
[13:23:35.035]         if (!identical(...future.workdir, getwd())) 
[13:23:35.035]             setwd(...future.workdir)
[13:23:35.035]         {
[13:23:35.035]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:35.035]                 ...future.oldOptions$nwarnings <- NULL
[13:23:35.035]             }
[13:23:35.035]             base::options(...future.oldOptions)
[13:23:35.035]             if (.Platform$OS.type == "windows") {
[13:23:35.035]                 old_names <- names(...future.oldEnvVars)
[13:23:35.035]                 envs <- base::Sys.getenv()
[13:23:35.035]                 names <- names(envs)
[13:23:35.035]                 common <- intersect(names, old_names)
[13:23:35.035]                 added <- setdiff(names, old_names)
[13:23:35.035]                 removed <- setdiff(old_names, names)
[13:23:35.035]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:35.035]                   envs[common]]
[13:23:35.035]                 NAMES <- toupper(changed)
[13:23:35.035]                 args <- list()
[13:23:35.035]                 for (kk in seq_along(NAMES)) {
[13:23:35.035]                   name <- changed[[kk]]
[13:23:35.035]                   NAME <- NAMES[[kk]]
[13:23:35.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.035]                     next
[13:23:35.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:35.035]                 }
[13:23:35.035]                 NAMES <- toupper(added)
[13:23:35.035]                 for (kk in seq_along(NAMES)) {
[13:23:35.035]                   name <- added[[kk]]
[13:23:35.035]                   NAME <- NAMES[[kk]]
[13:23:35.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.035]                     next
[13:23:35.035]                   args[[name]] <- ""
[13:23:35.035]                 }
[13:23:35.035]                 NAMES <- toupper(removed)
[13:23:35.035]                 for (kk in seq_along(NAMES)) {
[13:23:35.035]                   name <- removed[[kk]]
[13:23:35.035]                   NAME <- NAMES[[kk]]
[13:23:35.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.035]                     next
[13:23:35.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:35.035]                 }
[13:23:35.035]                 if (length(args) > 0) 
[13:23:35.035]                   base::do.call(base::Sys.setenv, args = args)
[13:23:35.035]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:35.035]             }
[13:23:35.035]             else {
[13:23:35.035]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:35.035]             }
[13:23:35.035]             {
[13:23:35.035]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:35.035]                   0L) {
[13:23:35.035]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:35.035]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:35.035]                   base::options(opts)
[13:23:35.035]                 }
[13:23:35.035]                 {
[13:23:35.035]                   {
[13:23:35.035]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:35.035]                     NULL
[13:23:35.035]                   }
[13:23:35.035]                   options(future.plan = NULL)
[13:23:35.035]                   if (is.na(NA_character_)) 
[13:23:35.035]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:35.035]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:35.035]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:35.035]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:35.035]                     envir = parent.frame()) 
[13:23:35.035]                   {
[13:23:35.035]                     if (is.function(workers)) 
[13:23:35.035]                       workers <- workers()
[13:23:35.035]                     workers <- structure(as.integer(workers), 
[13:23:35.035]                       class = class(workers))
[13:23:35.035]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:35.035]                       workers >= 1)
[13:23:35.035]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:35.035]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:35.035]                     }
[13:23:35.035]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:35.035]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:35.035]                       envir = envir)
[13:23:35.035]                     if (!future$lazy) 
[13:23:35.035]                       future <- run(future)
[13:23:35.035]                     invisible(future)
[13:23:35.035]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:35.035]                 }
[13:23:35.035]             }
[13:23:35.035]         }
[13:23:35.035]     })
[13:23:35.035]     if (TRUE) {
[13:23:35.035]         base::sink(type = "output", split = FALSE)
[13:23:35.035]         if (TRUE) {
[13:23:35.035]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:35.035]         }
[13:23:35.035]         else {
[13:23:35.035]             ...future.result["stdout"] <- base::list(NULL)
[13:23:35.035]         }
[13:23:35.035]         base::close(...future.stdout)
[13:23:35.035]         ...future.stdout <- NULL
[13:23:35.035]     }
[13:23:35.035]     ...future.result$conditions <- ...future.conditions
[13:23:35.035]     ...future.result$finished <- base::Sys.time()
[13:23:35.035]     ...future.result
[13:23:35.035] }
[13:23:35.037] Poll #1 (0): usedNodes() = 2, workers = 2
[13:23:35.049] receiveMessageFromWorker() for ClusterFuture ...
[13:23:35.049] - Validating connection of MultisessionFuture
[13:23:35.049] - received message: FutureResult
[13:23:35.049] - Received FutureResult
[13:23:35.049] - Erased future from FutureRegistry
[13:23:35.050] result() for ClusterFuture ...
[13:23:35.050] - result already collected: FutureResult
[13:23:35.050] result() for ClusterFuture ... done
[13:23:35.050] signalConditions() ...
[13:23:35.050]  - include = ‘immediateCondition’
[13:23:35.050]  - exclude = 
[13:23:35.050]  - resignal = FALSE
[13:23:35.050]  - Number of conditions: 1
[13:23:35.050] signalConditions() ... done
[13:23:35.050] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:35.050] result() for ClusterFuture ...
[13:23:35.051] - result already collected: FutureResult
[13:23:35.051] result() for ClusterFuture ... done
[13:23:35.051] result() for ClusterFuture ...
[13:23:35.051] - result already collected: FutureResult
[13:23:35.051] result() for ClusterFuture ... done
[13:23:35.051] signalConditions() ...
[13:23:35.051]  - include = ‘immediateCondition’
[13:23:35.051]  - exclude = 
[13:23:35.051]  - resignal = FALSE
[13:23:35.051]  - Number of conditions: 1
[13:23:35.051] signalConditions() ... done
[13:23:35.052] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:23:35.053] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:23:35.053] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:23:35.053] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:23:35.054] MultisessionFuture started
[13:23:35.054] - Launch lazy future ... done
[13:23:35.054] run() for ‘MultisessionFuture’ ... done
[13:23:35.055] result() for ClusterFuture ...
[13:23:35.055] - result already collected: FutureResult
[13:23:35.055] result() for ClusterFuture ... done
[13:23:35.055] result() for ClusterFuture ...
[13:23:35.055] - result already collected: FutureResult
[13:23:35.055] result() for ClusterFuture ... done
[13:23:35.056] signalConditions() ...
[13:23:35.056]  - include = ‘immediateCondition’
[13:23:35.056]  - exclude = 
[13:23:35.056]  - resignal = FALSE
[13:23:35.056]  - Number of conditions: 1
[13:23:35.056] signalConditions() ... done
[13:23:35.057] Future state: ‘finished’
[13:23:35.057] result() for ClusterFuture ...
[13:23:35.057] - result already collected: FutureResult
[13:23:35.057] result() for ClusterFuture ... done
[13:23:35.057] signalConditions() ...
[13:23:35.057]  - include = ‘condition’
[13:23:35.057]  - exclude = ‘immediateCondition’
[13:23:35.058]  - resignal = TRUE
[13:23:35.058]  - Number of conditions: 1
[13:23:35.058]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:23:35.058] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "47b98e4ec3a9" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:23:34"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:35.078] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:35.078] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:35.080] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:35.080] Searching for globals ... DONE
[13:23:35.080] Resolving globals: TRUE
[13:23:35.080] Resolving any globals that are futures ...
[13:23:35.080] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:35.080] Resolving any globals that are futures ... DONE
[13:23:35.081] Resolving futures part of globals (recursively) ...
[13:23:35.081] resolve() on list ...
[13:23:35.081]  recursive: 99
[13:23:35.081]  length: 1
[13:23:35.081]  elements: ‘ii’
[13:23:35.081]  length: 0 (resolved future 1)
[13:23:35.081] resolve() on list ... DONE
[13:23:35.081] - globals: [1] ‘ii’
[13:23:35.082] Resolving futures part of globals (recursively) ... DONE
[13:23:35.082] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:35.082] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:35.082] - globals: [1] ‘ii’
[13:23:35.082] 
[13:23:35.082] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:35.083] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:35.083] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:35.084] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:35.085] Searching for globals ... DONE
[13:23:35.085] Resolving globals: TRUE
[13:23:35.085] Resolving any globals that are futures ...
[13:23:35.085] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:35.085] Resolving any globals that are futures ... DONE
[13:23:35.085] Resolving futures part of globals (recursively) ...
[13:23:35.086] resolve() on list ...
[13:23:35.086]  recursive: 99
[13:23:35.086]  length: 1
[13:23:35.086]  elements: ‘ii’
[13:23:35.086]  length: 0 (resolved future 1)
[13:23:35.086] resolve() on list ... DONE
[13:23:35.086] - globals: [1] ‘ii’
[13:23:35.086] Resolving futures part of globals (recursively) ... DONE
[13:23:35.086] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:35.087] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:35.087] - globals: [1] ‘ii’
[13:23:35.087] 
[13:23:35.087] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:35.088] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:35.088] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:35.089] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:35.089] Searching for globals ... DONE
[13:23:35.089] Resolving globals: TRUE
[13:23:35.089] Resolving any globals that are futures ...
[13:23:35.090] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:23:35.090] Resolving any globals that are futures ... DONE
[13:23:35.090] Resolving futures part of globals (recursively) ...
[13:23:35.090] resolve() on list ...
[13:23:35.090]  recursive: 99
[13:23:35.090]  length: 1
[13:23:35.090]  elements: ‘ii’
[13:23:35.091]  length: 0 (resolved future 1)
[13:23:35.091] resolve() on list ... DONE
[13:23:35.091] - globals: [1] ‘ii’
[13:23:35.091] Resolving futures part of globals (recursively) ... DONE
[13:23:35.091] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:35.091] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:35.091] - globals: [1] ‘ii’
[13:23:35.091] 
[13:23:35.092] getGlobalsAndPackages() ... DONE
[13:23:35.092] run() for ‘Future’ ...
[13:23:35.092] - state: ‘created’
[13:23:35.092] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:35.109] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:35.110] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:35.110]   - Field: ‘node’
[13:23:35.110]   - Field: ‘label’
[13:23:35.110]   - Field: ‘local’
[13:23:35.110]   - Field: ‘owner’
[13:23:35.110]   - Field: ‘envir’
[13:23:35.110]   - Field: ‘workers’
[13:23:35.110]   - Field: ‘packages’
[13:23:35.110]   - Field: ‘gc’
[13:23:35.110]   - Field: ‘conditions’
[13:23:35.111]   - Field: ‘persistent’
[13:23:35.111]   - Field: ‘expr’
[13:23:35.111]   - Field: ‘uuid’
[13:23:35.111]   - Field: ‘seed’
[13:23:35.111]   - Field: ‘version’
[13:23:35.111]   - Field: ‘result’
[13:23:35.111]   - Field: ‘asynchronous’
[13:23:35.111]   - Field: ‘calls’
[13:23:35.111]   - Field: ‘globals’
[13:23:35.111]   - Field: ‘stdout’
[13:23:35.112]   - Field: ‘earlySignal’
[13:23:35.112]   - Field: ‘lazy’
[13:23:35.112]   - Field: ‘state’
[13:23:35.112] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:35.112] - Launch lazy future ...
[13:23:35.112] Packages needed by the future expression (n = 0): <none>
[13:23:35.112] Packages needed by future strategies (n = 0): <none>
[13:23:35.113] {
[13:23:35.113]     {
[13:23:35.113]         {
[13:23:35.113]             ...future.startTime <- base::Sys.time()
[13:23:35.113]             {
[13:23:35.113]                 {
[13:23:35.113]                   {
[13:23:35.113]                     {
[13:23:35.113]                       base::local({
[13:23:35.113]                         has_future <- base::requireNamespace("future", 
[13:23:35.113]                           quietly = TRUE)
[13:23:35.113]                         if (has_future) {
[13:23:35.113]                           ns <- base::getNamespace("future")
[13:23:35.113]                           version <- ns[[".package"]][["version"]]
[13:23:35.113]                           if (is.null(version)) 
[13:23:35.113]                             version <- utils::packageVersion("future")
[13:23:35.113]                         }
[13:23:35.113]                         else {
[13:23:35.113]                           version <- NULL
[13:23:35.113]                         }
[13:23:35.113]                         if (!has_future || version < "1.8.0") {
[13:23:35.113]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:35.113]                             "", base::R.version$version.string), 
[13:23:35.113]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:35.113]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:35.113]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:35.113]                               "release", "version")], collapse = " "), 
[13:23:35.113]                             hostname = base::Sys.info()[["nodename"]])
[13:23:35.113]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:35.113]                             info)
[13:23:35.113]                           info <- base::paste(info, collapse = "; ")
[13:23:35.113]                           if (!has_future) {
[13:23:35.113]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:35.113]                               info)
[13:23:35.113]                           }
[13:23:35.113]                           else {
[13:23:35.113]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:35.113]                               info, version)
[13:23:35.113]                           }
[13:23:35.113]                           base::stop(msg)
[13:23:35.113]                         }
[13:23:35.113]                       })
[13:23:35.113]                     }
[13:23:35.113]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:35.113]                     base::options(mc.cores = 1L)
[13:23:35.113]                   }
[13:23:35.113]                   options(future.plan = NULL)
[13:23:35.113]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:35.113]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:35.113]                 }
[13:23:35.113]                 ...future.workdir <- getwd()
[13:23:35.113]             }
[13:23:35.113]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:35.113]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:35.113]         }
[13:23:35.113]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:35.113]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:35.113]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:35.113]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:35.113]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:35.113]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:35.113]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:35.113]             base::names(...future.oldOptions))
[13:23:35.113]     }
[13:23:35.113]     if (FALSE) {
[13:23:35.113]     }
[13:23:35.113]     else {
[13:23:35.113]         if (TRUE) {
[13:23:35.113]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:35.113]                 open = "w")
[13:23:35.113]         }
[13:23:35.113]         else {
[13:23:35.113]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:35.113]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:35.113]         }
[13:23:35.113]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:35.113]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:35.113]             base::sink(type = "output", split = FALSE)
[13:23:35.113]             base::close(...future.stdout)
[13:23:35.113]         }, add = TRUE)
[13:23:35.113]     }
[13:23:35.113]     ...future.frame <- base::sys.nframe()
[13:23:35.113]     ...future.conditions <- base::list()
[13:23:35.113]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:35.113]     if (FALSE) {
[13:23:35.113]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:35.113]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:35.113]     }
[13:23:35.113]     ...future.result <- base::tryCatch({
[13:23:35.113]         base::withCallingHandlers({
[13:23:35.113]             ...future.value <- base::withVisible(base::local({
[13:23:35.113]                 ...future.makeSendCondition <- base::local({
[13:23:35.113]                   sendCondition <- NULL
[13:23:35.113]                   function(frame = 1L) {
[13:23:35.113]                     if (is.function(sendCondition)) 
[13:23:35.113]                       return(sendCondition)
[13:23:35.113]                     ns <- getNamespace("parallel")
[13:23:35.113]                     if (exists("sendData", mode = "function", 
[13:23:35.113]                       envir = ns)) {
[13:23:35.113]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:35.113]                         envir = ns)
[13:23:35.113]                       envir <- sys.frame(frame)
[13:23:35.113]                       master <- NULL
[13:23:35.113]                       while (!identical(envir, .GlobalEnv) && 
[13:23:35.113]                         !identical(envir, emptyenv())) {
[13:23:35.113]                         if (exists("master", mode = "list", envir = envir, 
[13:23:35.113]                           inherits = FALSE)) {
[13:23:35.113]                           master <- get("master", mode = "list", 
[13:23:35.113]                             envir = envir, inherits = FALSE)
[13:23:35.113]                           if (inherits(master, c("SOCKnode", 
[13:23:35.113]                             "SOCK0node"))) {
[13:23:35.113]                             sendCondition <<- function(cond) {
[13:23:35.113]                               data <- list(type = "VALUE", value = cond, 
[13:23:35.113]                                 success = TRUE)
[13:23:35.113]                               parallel_sendData(master, data)
[13:23:35.113]                             }
[13:23:35.113]                             return(sendCondition)
[13:23:35.113]                           }
[13:23:35.113]                         }
[13:23:35.113]                         frame <- frame + 1L
[13:23:35.113]                         envir <- sys.frame(frame)
[13:23:35.113]                       }
[13:23:35.113]                     }
[13:23:35.113]                     sendCondition <<- function(cond) NULL
[13:23:35.113]                   }
[13:23:35.113]                 })
[13:23:35.113]                 withCallingHandlers({
[13:23:35.113]                   {
[13:23:35.113]                     b <- a * ii
[13:23:35.113]                     a <- 0
[13:23:35.113]                     b
[13:23:35.113]                   }
[13:23:35.113]                 }, immediateCondition = function(cond) {
[13:23:35.113]                   sendCondition <- ...future.makeSendCondition()
[13:23:35.113]                   sendCondition(cond)
[13:23:35.113]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.113]                   {
[13:23:35.113]                     inherits <- base::inherits
[13:23:35.113]                     invokeRestart <- base::invokeRestart
[13:23:35.113]                     is.null <- base::is.null
[13:23:35.113]                     muffled <- FALSE
[13:23:35.113]                     if (inherits(cond, "message")) {
[13:23:35.113]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:35.113]                       if (muffled) 
[13:23:35.113]                         invokeRestart("muffleMessage")
[13:23:35.113]                     }
[13:23:35.113]                     else if (inherits(cond, "warning")) {
[13:23:35.113]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:35.113]                       if (muffled) 
[13:23:35.113]                         invokeRestart("muffleWarning")
[13:23:35.113]                     }
[13:23:35.113]                     else if (inherits(cond, "condition")) {
[13:23:35.113]                       if (!is.null(pattern)) {
[13:23:35.113]                         computeRestarts <- base::computeRestarts
[13:23:35.113]                         grepl <- base::grepl
[13:23:35.113]                         restarts <- computeRestarts(cond)
[13:23:35.113]                         for (restart in restarts) {
[13:23:35.113]                           name <- restart$name
[13:23:35.113]                           if (is.null(name)) 
[13:23:35.113]                             next
[13:23:35.113]                           if (!grepl(pattern, name)) 
[13:23:35.113]                             next
[13:23:35.113]                           invokeRestart(restart)
[13:23:35.113]                           muffled <- TRUE
[13:23:35.113]                           break
[13:23:35.113]                         }
[13:23:35.113]                       }
[13:23:35.113]                     }
[13:23:35.113]                     invisible(muffled)
[13:23:35.113]                   }
[13:23:35.113]                   muffleCondition(cond)
[13:23:35.113]                 })
[13:23:35.113]             }))
[13:23:35.113]             future::FutureResult(value = ...future.value$value, 
[13:23:35.113]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:35.113]                   ...future.rng), globalenv = if (FALSE) 
[13:23:35.113]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:35.113]                     ...future.globalenv.names))
[13:23:35.113]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:35.113]         }, condition = base::local({
[13:23:35.113]             c <- base::c
[13:23:35.113]             inherits <- base::inherits
[13:23:35.113]             invokeRestart <- base::invokeRestart
[13:23:35.113]             length <- base::length
[13:23:35.113]             list <- base::list
[13:23:35.113]             seq.int <- base::seq.int
[13:23:35.113]             signalCondition <- base::signalCondition
[13:23:35.113]             sys.calls <- base::sys.calls
[13:23:35.113]             `[[` <- base::`[[`
[13:23:35.113]             `+` <- base::`+`
[13:23:35.113]             `<<-` <- base::`<<-`
[13:23:35.113]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:35.113]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:35.113]                   3L)]
[13:23:35.113]             }
[13:23:35.113]             function(cond) {
[13:23:35.113]                 is_error <- inherits(cond, "error")
[13:23:35.113]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:35.113]                   NULL)
[13:23:35.113]                 if (is_error) {
[13:23:35.113]                   sessionInformation <- function() {
[13:23:35.113]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:35.113]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:35.113]                       search = base::search(), system = base::Sys.info())
[13:23:35.113]                   }
[13:23:35.113]                   ...future.conditions[[length(...future.conditions) + 
[13:23:35.113]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:35.113]                     cond$call), session = sessionInformation(), 
[13:23:35.113]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:35.113]                   signalCondition(cond)
[13:23:35.113]                 }
[13:23:35.113]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:35.113]                 "immediateCondition"))) {
[13:23:35.113]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:35.113]                   ...future.conditions[[length(...future.conditions) + 
[13:23:35.113]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:35.113]                   if (TRUE && !signal) {
[13:23:35.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.113]                     {
[13:23:35.113]                       inherits <- base::inherits
[13:23:35.113]                       invokeRestart <- base::invokeRestart
[13:23:35.113]                       is.null <- base::is.null
[13:23:35.113]                       muffled <- FALSE
[13:23:35.113]                       if (inherits(cond, "message")) {
[13:23:35.113]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:35.113]                         if (muffled) 
[13:23:35.113]                           invokeRestart("muffleMessage")
[13:23:35.113]                       }
[13:23:35.113]                       else if (inherits(cond, "warning")) {
[13:23:35.113]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:35.113]                         if (muffled) 
[13:23:35.113]                           invokeRestart("muffleWarning")
[13:23:35.113]                       }
[13:23:35.113]                       else if (inherits(cond, "condition")) {
[13:23:35.113]                         if (!is.null(pattern)) {
[13:23:35.113]                           computeRestarts <- base::computeRestarts
[13:23:35.113]                           grepl <- base::grepl
[13:23:35.113]                           restarts <- computeRestarts(cond)
[13:23:35.113]                           for (restart in restarts) {
[13:23:35.113]                             name <- restart$name
[13:23:35.113]                             if (is.null(name)) 
[13:23:35.113]                               next
[13:23:35.113]                             if (!grepl(pattern, name)) 
[13:23:35.113]                               next
[13:23:35.113]                             invokeRestart(restart)
[13:23:35.113]                             muffled <- TRUE
[13:23:35.113]                             break
[13:23:35.113]                           }
[13:23:35.113]                         }
[13:23:35.113]                       }
[13:23:35.113]                       invisible(muffled)
[13:23:35.113]                     }
[13:23:35.113]                     muffleCondition(cond, pattern = "^muffle")
[13:23:35.113]                   }
[13:23:35.113]                 }
[13:23:35.113]                 else {
[13:23:35.113]                   if (TRUE) {
[13:23:35.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.113]                     {
[13:23:35.113]                       inherits <- base::inherits
[13:23:35.113]                       invokeRestart <- base::invokeRestart
[13:23:35.113]                       is.null <- base::is.null
[13:23:35.113]                       muffled <- FALSE
[13:23:35.113]                       if (inherits(cond, "message")) {
[13:23:35.113]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:35.113]                         if (muffled) 
[13:23:35.113]                           invokeRestart("muffleMessage")
[13:23:35.113]                       }
[13:23:35.113]                       else if (inherits(cond, "warning")) {
[13:23:35.113]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:35.113]                         if (muffled) 
[13:23:35.113]                           invokeRestart("muffleWarning")
[13:23:35.113]                       }
[13:23:35.113]                       else if (inherits(cond, "condition")) {
[13:23:35.113]                         if (!is.null(pattern)) {
[13:23:35.113]                           computeRestarts <- base::computeRestarts
[13:23:35.113]                           grepl <- base::grepl
[13:23:35.113]                           restarts <- computeRestarts(cond)
[13:23:35.113]                           for (restart in restarts) {
[13:23:35.113]                             name <- restart$name
[13:23:35.113]                             if (is.null(name)) 
[13:23:35.113]                               next
[13:23:35.113]                             if (!grepl(pattern, name)) 
[13:23:35.113]                               next
[13:23:35.113]                             invokeRestart(restart)
[13:23:35.113]                             muffled <- TRUE
[13:23:35.113]                             break
[13:23:35.113]                           }
[13:23:35.113]                         }
[13:23:35.113]                       }
[13:23:35.113]                       invisible(muffled)
[13:23:35.113]                     }
[13:23:35.113]                     muffleCondition(cond, pattern = "^muffle")
[13:23:35.113]                   }
[13:23:35.113]                 }
[13:23:35.113]             }
[13:23:35.113]         }))
[13:23:35.113]     }, error = function(ex) {
[13:23:35.113]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:35.113]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:35.113]                 ...future.rng), started = ...future.startTime, 
[13:23:35.113]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:35.113]             version = "1.8"), class = "FutureResult")
[13:23:35.113]     }, finally = {
[13:23:35.113]         if (!identical(...future.workdir, getwd())) 
[13:23:35.113]             setwd(...future.workdir)
[13:23:35.113]         {
[13:23:35.113]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:35.113]                 ...future.oldOptions$nwarnings <- NULL
[13:23:35.113]             }
[13:23:35.113]             base::options(...future.oldOptions)
[13:23:35.113]             if (.Platform$OS.type == "windows") {
[13:23:35.113]                 old_names <- names(...future.oldEnvVars)
[13:23:35.113]                 envs <- base::Sys.getenv()
[13:23:35.113]                 names <- names(envs)
[13:23:35.113]                 common <- intersect(names, old_names)
[13:23:35.113]                 added <- setdiff(names, old_names)
[13:23:35.113]                 removed <- setdiff(old_names, names)
[13:23:35.113]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:35.113]                   envs[common]]
[13:23:35.113]                 NAMES <- toupper(changed)
[13:23:35.113]                 args <- list()
[13:23:35.113]                 for (kk in seq_along(NAMES)) {
[13:23:35.113]                   name <- changed[[kk]]
[13:23:35.113]                   NAME <- NAMES[[kk]]
[13:23:35.113]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.113]                     next
[13:23:35.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:35.113]                 }
[13:23:35.113]                 NAMES <- toupper(added)
[13:23:35.113]                 for (kk in seq_along(NAMES)) {
[13:23:35.113]                   name <- added[[kk]]
[13:23:35.113]                   NAME <- NAMES[[kk]]
[13:23:35.113]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.113]                     next
[13:23:35.113]                   args[[name]] <- ""
[13:23:35.113]                 }
[13:23:35.113]                 NAMES <- toupper(removed)
[13:23:35.113]                 for (kk in seq_along(NAMES)) {
[13:23:35.113]                   name <- removed[[kk]]
[13:23:35.113]                   NAME <- NAMES[[kk]]
[13:23:35.113]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.113]                     next
[13:23:35.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:35.113]                 }
[13:23:35.113]                 if (length(args) > 0) 
[13:23:35.113]                   base::do.call(base::Sys.setenv, args = args)
[13:23:35.113]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:35.113]             }
[13:23:35.113]             else {
[13:23:35.113]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:35.113]             }
[13:23:35.113]             {
[13:23:35.113]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:35.113]                   0L) {
[13:23:35.113]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:35.113]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:35.113]                   base::options(opts)
[13:23:35.113]                 }
[13:23:35.113]                 {
[13:23:35.113]                   {
[13:23:35.113]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:35.113]                     NULL
[13:23:35.113]                   }
[13:23:35.113]                   options(future.plan = NULL)
[13:23:35.113]                   if (is.na(NA_character_)) 
[13:23:35.113]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:35.113]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:35.113]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:35.113]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:35.113]                     envir = parent.frame()) 
[13:23:35.113]                   {
[13:23:35.113]                     if (is.function(workers)) 
[13:23:35.113]                       workers <- workers()
[13:23:35.113]                     workers <- structure(as.integer(workers), 
[13:23:35.113]                       class = class(workers))
[13:23:35.113]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:35.113]                       workers >= 1)
[13:23:35.113]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:35.113]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:35.113]                     }
[13:23:35.113]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:35.113]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:35.113]                       envir = envir)
[13:23:35.113]                     if (!future$lazy) 
[13:23:35.113]                       future <- run(future)
[13:23:35.113]                     invisible(future)
[13:23:35.113]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:35.113]                 }
[13:23:35.113]             }
[13:23:35.113]         }
[13:23:35.113]     })
[13:23:35.113]     if (TRUE) {
[13:23:35.113]         base::sink(type = "output", split = FALSE)
[13:23:35.113]         if (TRUE) {
[13:23:35.113]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:35.113]         }
[13:23:35.113]         else {
[13:23:35.113]             ...future.result["stdout"] <- base::list(NULL)
[13:23:35.113]         }
[13:23:35.113]         base::close(...future.stdout)
[13:23:35.113]         ...future.stdout <- NULL
[13:23:35.113]     }
[13:23:35.113]     ...future.result$conditions <- ...future.conditions
[13:23:35.113]     ...future.result$finished <- base::Sys.time()
[13:23:35.113]     ...future.result
[13:23:35.113] }
[13:23:35.115] Poll #1 (0): usedNodes() = 2, workers = 2
[13:23:35.126] receiveMessageFromWorker() for ClusterFuture ...
[13:23:35.126] - Validating connection of MultisessionFuture
[13:23:35.126] - received message: FutureResult
[13:23:35.127] - Received FutureResult
[13:23:35.127] - Erased future from FutureRegistry
[13:23:35.127] result() for ClusterFuture ...
[13:23:35.127] - result already collected: FutureResult
[13:23:35.127] result() for ClusterFuture ... done
[13:23:35.127] signalConditions() ...
[13:23:35.127]  - include = ‘immediateCondition’
[13:23:35.127]  - exclude = 
[13:23:35.127]  - resignal = FALSE
[13:23:35.127]  - Number of conditions: 1
[13:23:35.128] signalConditions() ... done
[13:23:35.128] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:35.128] result() for ClusterFuture ...
[13:23:35.128] - result already collected: FutureResult
[13:23:35.128] result() for ClusterFuture ... done
[13:23:35.128] result() for ClusterFuture ...
[13:23:35.128] - result already collected: FutureResult
[13:23:35.128] result() for ClusterFuture ... done
[13:23:35.128] signalConditions() ...
[13:23:35.128]  - include = ‘immediateCondition’
[13:23:35.128]  - exclude = 
[13:23:35.129]  - resignal = FALSE
[13:23:35.129]  - Number of conditions: 1
[13:23:35.129] signalConditions() ... done
[13:23:35.129] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[13:23:35.130] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[13:23:35.130] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[13:23:35.130] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[13:23:35.131] MultisessionFuture started
[13:23:35.131] - Launch lazy future ... done
[13:23:35.131] run() for ‘MultisessionFuture’ ... done
[13:23:35.131] result() for ClusterFuture ...
[13:23:35.131] receiveMessageFromWorker() for ClusterFuture ...
[13:23:35.131] - Validating connection of MultisessionFuture
[13:23:35.178] - received message: FutureResult
[13:23:35.178] - Received FutureResult
[13:23:35.178] - Erased future from FutureRegistry
[13:23:35.178] result() for ClusterFuture ...
[13:23:35.178] - result already collected: FutureResult
[13:23:35.179] result() for ClusterFuture ... done
[13:23:35.179] signalConditions() ...
[13:23:35.179]  - include = ‘immediateCondition’
[13:23:35.179]  - exclude = 
[13:23:35.179]  - resignal = FALSE
[13:23:35.179]  - Number of conditions: 1
[13:23:35.179] signalConditions() ... done
[13:23:35.179] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:35.179] result() for ClusterFuture ... done
[13:23:35.179] result() for ClusterFuture ...
[13:23:35.179] - result already collected: FutureResult
[13:23:35.180] result() for ClusterFuture ... done
[13:23:35.180] signalConditions() ...
[13:23:35.180]  - include = ‘immediateCondition’
[13:23:35.180]  - exclude = 
[13:23:35.180]  - resignal = FALSE
[13:23:35.180]  - Number of conditions: 1
[13:23:35.180] signalConditions() ... done
[13:23:35.180] Future state: ‘finished’
[13:23:35.180] result() for ClusterFuture ...
[13:23:35.180] - result already collected: FutureResult
[13:23:35.181] result() for ClusterFuture ... done
[13:23:35.181] signalConditions() ...
[13:23:35.181]  - include = ‘condition’
[13:23:35.181]  - exclude = ‘immediateCondition’
[13:23:35.181]  - resignal = TRUE
[13:23:35.181]  - Number of conditions: 1
[13:23:35.181]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:23:35.181] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "47b98e4ec3a9" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:23:35"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:35.196] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:35.196] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:35.196] 
[13:23:35.197] Searching for globals ... DONE
[13:23:35.197] - globals: [0] <none>
[13:23:35.197] getGlobalsAndPackages() ... DONE
[13:23:35.197] run() for ‘Future’ ...
[13:23:35.197] - state: ‘created’
[13:23:35.197] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:35.212] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:35.212] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:35.212]   - Field: ‘node’
[13:23:35.212]   - Field: ‘label’
[13:23:35.212]   - Field: ‘local’
[13:23:35.212]   - Field: ‘owner’
[13:23:35.212]   - Field: ‘envir’
[13:23:35.212]   - Field: ‘workers’
[13:23:35.213]   - Field: ‘packages’
[13:23:35.213]   - Field: ‘gc’
[13:23:35.213]   - Field: ‘conditions’
[13:23:35.213]   - Field: ‘persistent’
[13:23:35.213]   - Field: ‘expr’
[13:23:35.213]   - Field: ‘uuid’
[13:23:35.213]   - Field: ‘seed’
[13:23:35.213]   - Field: ‘version’
[13:23:35.213]   - Field: ‘result’
[13:23:35.213]   - Field: ‘asynchronous’
[13:23:35.213]   - Field: ‘calls’
[13:23:35.214]   - Field: ‘globals’
[13:23:35.214]   - Field: ‘stdout’
[13:23:35.214]   - Field: ‘earlySignal’
[13:23:35.214]   - Field: ‘lazy’
[13:23:35.214]   - Field: ‘state’
[13:23:35.214] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:35.214] - Launch lazy future ...
[13:23:35.214] Packages needed by the future expression (n = 0): <none>
[13:23:35.215] Packages needed by future strategies (n = 0): <none>
[13:23:35.215] {
[13:23:35.215]     {
[13:23:35.215]         {
[13:23:35.215]             ...future.startTime <- base::Sys.time()
[13:23:35.215]             {
[13:23:35.215]                 {
[13:23:35.215]                   {
[13:23:35.215]                     {
[13:23:35.215]                       base::local({
[13:23:35.215]                         has_future <- base::requireNamespace("future", 
[13:23:35.215]                           quietly = TRUE)
[13:23:35.215]                         if (has_future) {
[13:23:35.215]                           ns <- base::getNamespace("future")
[13:23:35.215]                           version <- ns[[".package"]][["version"]]
[13:23:35.215]                           if (is.null(version)) 
[13:23:35.215]                             version <- utils::packageVersion("future")
[13:23:35.215]                         }
[13:23:35.215]                         else {
[13:23:35.215]                           version <- NULL
[13:23:35.215]                         }
[13:23:35.215]                         if (!has_future || version < "1.8.0") {
[13:23:35.215]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:35.215]                             "", base::R.version$version.string), 
[13:23:35.215]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:35.215]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:35.215]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:35.215]                               "release", "version")], collapse = " "), 
[13:23:35.215]                             hostname = base::Sys.info()[["nodename"]])
[13:23:35.215]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:35.215]                             info)
[13:23:35.215]                           info <- base::paste(info, collapse = "; ")
[13:23:35.215]                           if (!has_future) {
[13:23:35.215]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:35.215]                               info)
[13:23:35.215]                           }
[13:23:35.215]                           else {
[13:23:35.215]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:35.215]                               info, version)
[13:23:35.215]                           }
[13:23:35.215]                           base::stop(msg)
[13:23:35.215]                         }
[13:23:35.215]                       })
[13:23:35.215]                     }
[13:23:35.215]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:35.215]                     base::options(mc.cores = 1L)
[13:23:35.215]                   }
[13:23:35.215]                   options(future.plan = NULL)
[13:23:35.215]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:35.215]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:35.215]                 }
[13:23:35.215]                 ...future.workdir <- getwd()
[13:23:35.215]             }
[13:23:35.215]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:35.215]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:35.215]         }
[13:23:35.215]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:35.215]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:35.215]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:35.215]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:35.215]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:35.215]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:35.215]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:35.215]             base::names(...future.oldOptions))
[13:23:35.215]     }
[13:23:35.215]     if (FALSE) {
[13:23:35.215]     }
[13:23:35.215]     else {
[13:23:35.215]         if (TRUE) {
[13:23:35.215]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:35.215]                 open = "w")
[13:23:35.215]         }
[13:23:35.215]         else {
[13:23:35.215]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:35.215]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:35.215]         }
[13:23:35.215]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:35.215]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:35.215]             base::sink(type = "output", split = FALSE)
[13:23:35.215]             base::close(...future.stdout)
[13:23:35.215]         }, add = TRUE)
[13:23:35.215]     }
[13:23:35.215]     ...future.frame <- base::sys.nframe()
[13:23:35.215]     ...future.conditions <- base::list()
[13:23:35.215]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:35.215]     if (FALSE) {
[13:23:35.215]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:35.215]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:35.215]     }
[13:23:35.215]     ...future.result <- base::tryCatch({
[13:23:35.215]         base::withCallingHandlers({
[13:23:35.215]             ...future.value <- base::withVisible(base::local({
[13:23:35.215]                 ...future.makeSendCondition <- base::local({
[13:23:35.215]                   sendCondition <- NULL
[13:23:35.215]                   function(frame = 1L) {
[13:23:35.215]                     if (is.function(sendCondition)) 
[13:23:35.215]                       return(sendCondition)
[13:23:35.215]                     ns <- getNamespace("parallel")
[13:23:35.215]                     if (exists("sendData", mode = "function", 
[13:23:35.215]                       envir = ns)) {
[13:23:35.215]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:35.215]                         envir = ns)
[13:23:35.215]                       envir <- sys.frame(frame)
[13:23:35.215]                       master <- NULL
[13:23:35.215]                       while (!identical(envir, .GlobalEnv) && 
[13:23:35.215]                         !identical(envir, emptyenv())) {
[13:23:35.215]                         if (exists("master", mode = "list", envir = envir, 
[13:23:35.215]                           inherits = FALSE)) {
[13:23:35.215]                           master <- get("master", mode = "list", 
[13:23:35.215]                             envir = envir, inherits = FALSE)
[13:23:35.215]                           if (inherits(master, c("SOCKnode", 
[13:23:35.215]                             "SOCK0node"))) {
[13:23:35.215]                             sendCondition <<- function(cond) {
[13:23:35.215]                               data <- list(type = "VALUE", value = cond, 
[13:23:35.215]                                 success = TRUE)
[13:23:35.215]                               parallel_sendData(master, data)
[13:23:35.215]                             }
[13:23:35.215]                             return(sendCondition)
[13:23:35.215]                           }
[13:23:35.215]                         }
[13:23:35.215]                         frame <- frame + 1L
[13:23:35.215]                         envir <- sys.frame(frame)
[13:23:35.215]                       }
[13:23:35.215]                     }
[13:23:35.215]                     sendCondition <<- function(cond) NULL
[13:23:35.215]                   }
[13:23:35.215]                 })
[13:23:35.215]                 withCallingHandlers({
[13:23:35.215]                   1
[13:23:35.215]                 }, immediateCondition = function(cond) {
[13:23:35.215]                   sendCondition <- ...future.makeSendCondition()
[13:23:35.215]                   sendCondition(cond)
[13:23:35.215]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.215]                   {
[13:23:35.215]                     inherits <- base::inherits
[13:23:35.215]                     invokeRestart <- base::invokeRestart
[13:23:35.215]                     is.null <- base::is.null
[13:23:35.215]                     muffled <- FALSE
[13:23:35.215]                     if (inherits(cond, "message")) {
[13:23:35.215]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:35.215]                       if (muffled) 
[13:23:35.215]                         invokeRestart("muffleMessage")
[13:23:35.215]                     }
[13:23:35.215]                     else if (inherits(cond, "warning")) {
[13:23:35.215]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:35.215]                       if (muffled) 
[13:23:35.215]                         invokeRestart("muffleWarning")
[13:23:35.215]                     }
[13:23:35.215]                     else if (inherits(cond, "condition")) {
[13:23:35.215]                       if (!is.null(pattern)) {
[13:23:35.215]                         computeRestarts <- base::computeRestarts
[13:23:35.215]                         grepl <- base::grepl
[13:23:35.215]                         restarts <- computeRestarts(cond)
[13:23:35.215]                         for (restart in restarts) {
[13:23:35.215]                           name <- restart$name
[13:23:35.215]                           if (is.null(name)) 
[13:23:35.215]                             next
[13:23:35.215]                           if (!grepl(pattern, name)) 
[13:23:35.215]                             next
[13:23:35.215]                           invokeRestart(restart)
[13:23:35.215]                           muffled <- TRUE
[13:23:35.215]                           break
[13:23:35.215]                         }
[13:23:35.215]                       }
[13:23:35.215]                     }
[13:23:35.215]                     invisible(muffled)
[13:23:35.215]                   }
[13:23:35.215]                   muffleCondition(cond)
[13:23:35.215]                 })
[13:23:35.215]             }))
[13:23:35.215]             future::FutureResult(value = ...future.value$value, 
[13:23:35.215]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:35.215]                   ...future.rng), globalenv = if (FALSE) 
[13:23:35.215]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:35.215]                     ...future.globalenv.names))
[13:23:35.215]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:35.215]         }, condition = base::local({
[13:23:35.215]             c <- base::c
[13:23:35.215]             inherits <- base::inherits
[13:23:35.215]             invokeRestart <- base::invokeRestart
[13:23:35.215]             length <- base::length
[13:23:35.215]             list <- base::list
[13:23:35.215]             seq.int <- base::seq.int
[13:23:35.215]             signalCondition <- base::signalCondition
[13:23:35.215]             sys.calls <- base::sys.calls
[13:23:35.215]             `[[` <- base::`[[`
[13:23:35.215]             `+` <- base::`+`
[13:23:35.215]             `<<-` <- base::`<<-`
[13:23:35.215]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:35.215]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:35.215]                   3L)]
[13:23:35.215]             }
[13:23:35.215]             function(cond) {
[13:23:35.215]                 is_error <- inherits(cond, "error")
[13:23:35.215]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:35.215]                   NULL)
[13:23:35.215]                 if (is_error) {
[13:23:35.215]                   sessionInformation <- function() {
[13:23:35.215]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:35.215]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:35.215]                       search = base::search(), system = base::Sys.info())
[13:23:35.215]                   }
[13:23:35.215]                   ...future.conditions[[length(...future.conditions) + 
[13:23:35.215]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:35.215]                     cond$call), session = sessionInformation(), 
[13:23:35.215]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:35.215]                   signalCondition(cond)
[13:23:35.215]                 }
[13:23:35.215]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:35.215]                 "immediateCondition"))) {
[13:23:35.215]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:35.215]                   ...future.conditions[[length(...future.conditions) + 
[13:23:35.215]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:35.215]                   if (TRUE && !signal) {
[13:23:35.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.215]                     {
[13:23:35.215]                       inherits <- base::inherits
[13:23:35.215]                       invokeRestart <- base::invokeRestart
[13:23:35.215]                       is.null <- base::is.null
[13:23:35.215]                       muffled <- FALSE
[13:23:35.215]                       if (inherits(cond, "message")) {
[13:23:35.215]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:35.215]                         if (muffled) 
[13:23:35.215]                           invokeRestart("muffleMessage")
[13:23:35.215]                       }
[13:23:35.215]                       else if (inherits(cond, "warning")) {
[13:23:35.215]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:35.215]                         if (muffled) 
[13:23:35.215]                           invokeRestart("muffleWarning")
[13:23:35.215]                       }
[13:23:35.215]                       else if (inherits(cond, "condition")) {
[13:23:35.215]                         if (!is.null(pattern)) {
[13:23:35.215]                           computeRestarts <- base::computeRestarts
[13:23:35.215]                           grepl <- base::grepl
[13:23:35.215]                           restarts <- computeRestarts(cond)
[13:23:35.215]                           for (restart in restarts) {
[13:23:35.215]                             name <- restart$name
[13:23:35.215]                             if (is.null(name)) 
[13:23:35.215]                               next
[13:23:35.215]                             if (!grepl(pattern, name)) 
[13:23:35.215]                               next
[13:23:35.215]                             invokeRestart(restart)
[13:23:35.215]                             muffled <- TRUE
[13:23:35.215]                             break
[13:23:35.215]                           }
[13:23:35.215]                         }
[13:23:35.215]                       }
[13:23:35.215]                       invisible(muffled)
[13:23:35.215]                     }
[13:23:35.215]                     muffleCondition(cond, pattern = "^muffle")
[13:23:35.215]                   }
[13:23:35.215]                 }
[13:23:35.215]                 else {
[13:23:35.215]                   if (TRUE) {
[13:23:35.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.215]                     {
[13:23:35.215]                       inherits <- base::inherits
[13:23:35.215]                       invokeRestart <- base::invokeRestart
[13:23:35.215]                       is.null <- base::is.null
[13:23:35.215]                       muffled <- FALSE
[13:23:35.215]                       if (inherits(cond, "message")) {
[13:23:35.215]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:35.215]                         if (muffled) 
[13:23:35.215]                           invokeRestart("muffleMessage")
[13:23:35.215]                       }
[13:23:35.215]                       else if (inherits(cond, "warning")) {
[13:23:35.215]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:35.215]                         if (muffled) 
[13:23:35.215]                           invokeRestart("muffleWarning")
[13:23:35.215]                       }
[13:23:35.215]                       else if (inherits(cond, "condition")) {
[13:23:35.215]                         if (!is.null(pattern)) {
[13:23:35.215]                           computeRestarts <- base::computeRestarts
[13:23:35.215]                           grepl <- base::grepl
[13:23:35.215]                           restarts <- computeRestarts(cond)
[13:23:35.215]                           for (restart in restarts) {
[13:23:35.215]                             name <- restart$name
[13:23:35.215]                             if (is.null(name)) 
[13:23:35.215]                               next
[13:23:35.215]                             if (!grepl(pattern, name)) 
[13:23:35.215]                               next
[13:23:35.215]                             invokeRestart(restart)
[13:23:35.215]                             muffled <- TRUE
[13:23:35.215]                             break
[13:23:35.215]                           }
[13:23:35.215]                         }
[13:23:35.215]                       }
[13:23:35.215]                       invisible(muffled)
[13:23:35.215]                     }
[13:23:35.215]                     muffleCondition(cond, pattern = "^muffle")
[13:23:35.215]                   }
[13:23:35.215]                 }
[13:23:35.215]             }
[13:23:35.215]         }))
[13:23:35.215]     }, error = function(ex) {
[13:23:35.215]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:35.215]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:35.215]                 ...future.rng), started = ...future.startTime, 
[13:23:35.215]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:35.215]             version = "1.8"), class = "FutureResult")
[13:23:35.215]     }, finally = {
[13:23:35.215]         if (!identical(...future.workdir, getwd())) 
[13:23:35.215]             setwd(...future.workdir)
[13:23:35.215]         {
[13:23:35.215]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:35.215]                 ...future.oldOptions$nwarnings <- NULL
[13:23:35.215]             }
[13:23:35.215]             base::options(...future.oldOptions)
[13:23:35.215]             if (.Platform$OS.type == "windows") {
[13:23:35.215]                 old_names <- names(...future.oldEnvVars)
[13:23:35.215]                 envs <- base::Sys.getenv()
[13:23:35.215]                 names <- names(envs)
[13:23:35.215]                 common <- intersect(names, old_names)
[13:23:35.215]                 added <- setdiff(names, old_names)
[13:23:35.215]                 removed <- setdiff(old_names, names)
[13:23:35.215]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:35.215]                   envs[common]]
[13:23:35.215]                 NAMES <- toupper(changed)
[13:23:35.215]                 args <- list()
[13:23:35.215]                 for (kk in seq_along(NAMES)) {
[13:23:35.215]                   name <- changed[[kk]]
[13:23:35.215]                   NAME <- NAMES[[kk]]
[13:23:35.215]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.215]                     next
[13:23:35.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:35.215]                 }
[13:23:35.215]                 NAMES <- toupper(added)
[13:23:35.215]                 for (kk in seq_along(NAMES)) {
[13:23:35.215]                   name <- added[[kk]]
[13:23:35.215]                   NAME <- NAMES[[kk]]
[13:23:35.215]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.215]                     next
[13:23:35.215]                   args[[name]] <- ""
[13:23:35.215]                 }
[13:23:35.215]                 NAMES <- toupper(removed)
[13:23:35.215]                 for (kk in seq_along(NAMES)) {
[13:23:35.215]                   name <- removed[[kk]]
[13:23:35.215]                   NAME <- NAMES[[kk]]
[13:23:35.215]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.215]                     next
[13:23:35.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:35.215]                 }
[13:23:35.215]                 if (length(args) > 0) 
[13:23:35.215]                   base::do.call(base::Sys.setenv, args = args)
[13:23:35.215]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:35.215]             }
[13:23:35.215]             else {
[13:23:35.215]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:35.215]             }
[13:23:35.215]             {
[13:23:35.215]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:35.215]                   0L) {
[13:23:35.215]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:35.215]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:35.215]                   base::options(opts)
[13:23:35.215]                 }
[13:23:35.215]                 {
[13:23:35.215]                   {
[13:23:35.215]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:35.215]                     NULL
[13:23:35.215]                   }
[13:23:35.215]                   options(future.plan = NULL)
[13:23:35.215]                   if (is.na(NA_character_)) 
[13:23:35.215]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:35.215]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:35.215]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:35.215]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:35.215]                     envir = parent.frame()) 
[13:23:35.215]                   {
[13:23:35.215]                     if (is.function(workers)) 
[13:23:35.215]                       workers <- workers()
[13:23:35.215]                     workers <- structure(as.integer(workers), 
[13:23:35.215]                       class = class(workers))
[13:23:35.215]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:35.215]                       workers >= 1)
[13:23:35.215]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:35.215]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:35.215]                     }
[13:23:35.215]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:35.215]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:35.215]                       envir = envir)
[13:23:35.215]                     if (!future$lazy) 
[13:23:35.215]                       future <- run(future)
[13:23:35.215]                     invisible(future)
[13:23:35.215]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:35.215]                 }
[13:23:35.215]             }
[13:23:35.215]         }
[13:23:35.215]     })
[13:23:35.215]     if (TRUE) {
[13:23:35.215]         base::sink(type = "output", split = FALSE)
[13:23:35.215]         if (TRUE) {
[13:23:35.215]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:35.215]         }
[13:23:35.215]         else {
[13:23:35.215]             ...future.result["stdout"] <- base::list(NULL)
[13:23:35.215]         }
[13:23:35.215]         base::close(...future.stdout)
[13:23:35.215]         ...future.stdout <- NULL
[13:23:35.215]     }
[13:23:35.215]     ...future.result$conditions <- ...future.conditions
[13:23:35.215]     ...future.result$finished <- base::Sys.time()
[13:23:35.215]     ...future.result
[13:23:35.215] }
[13:23:35.218] MultisessionFuture started
[13:23:35.218] - Launch lazy future ... done
[13:23:35.218] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:35.219] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:35.219] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:35.220] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:35.220] Searching for globals ... DONE
[13:23:35.220] Resolving globals: TRUE
[13:23:35.220] Resolving any globals that are futures ...
[13:23:35.220] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:35.220] Resolving any globals that are futures ... DONE
[13:23:35.221] Resolving futures part of globals (recursively) ...
[13:23:35.221] resolve() on list ...
[13:23:35.221]  recursive: 99
[13:23:35.221]  length: 1
[13:23:35.221]  elements: ‘a’
[13:23:35.265] receiveMessageFromWorker() for ClusterFuture ...
[13:23:35.266] - Validating connection of MultisessionFuture
[13:23:35.266] - received message: FutureResult
[13:23:35.266] - Received FutureResult
[13:23:35.266] - Erased future from FutureRegistry
[13:23:35.266] result() for ClusterFuture ...
[13:23:35.266] - result already collected: FutureResult
[13:23:35.266] result() for ClusterFuture ... done
[13:23:35.266] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:35.267] Future #1
[13:23:35.267] result() for ClusterFuture ...
[13:23:35.267] - result already collected: FutureResult
[13:23:35.267] result() for ClusterFuture ... done
[13:23:35.267] result() for ClusterFuture ...
[13:23:35.267] - result already collected: FutureResult
[13:23:35.267] result() for ClusterFuture ... done
[13:23:35.267] A MultisessionFuture was resolved
[13:23:35.267]  length: 0 (resolved future 1)
[13:23:35.267] resolve() on list ... DONE
[13:23:35.268] - globals: [1] ‘a’
[13:23:35.268] Resolving futures part of globals (recursively) ... DONE
[13:23:35.269] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[13:23:35.269] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[13:23:35.269] - globals: [1] ‘a’
[13:23:35.269] - packages: [1] ‘future’
[13:23:35.269] getGlobalsAndPackages() ... DONE
[13:23:35.270] run() for ‘Future’ ...
[13:23:35.270] - state: ‘created’
[13:23:35.270] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:35.284] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:35.284] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:35.285]   - Field: ‘node’
[13:23:35.285]   - Field: ‘label’
[13:23:35.285]   - Field: ‘local’
[13:23:35.285]   - Field: ‘owner’
[13:23:35.287]   - Field: ‘envir’
[13:23:35.287]   - Field: ‘workers’
[13:23:35.287]   - Field: ‘packages’
[13:23:35.287]   - Field: ‘gc’
[13:23:35.287]   - Field: ‘conditions’
[13:23:35.288]   - Field: ‘persistent’
[13:23:35.288]   - Field: ‘expr’
[13:23:35.288]   - Field: ‘uuid’
[13:23:35.288]   - Field: ‘seed’
[13:23:35.288]   - Field: ‘version’
[13:23:35.288]   - Field: ‘result’
[13:23:35.288]   - Field: ‘asynchronous’
[13:23:35.288]   - Field: ‘calls’
[13:23:35.288]   - Field: ‘globals’
[13:23:35.288]   - Field: ‘stdout’
[13:23:35.289]   - Field: ‘earlySignal’
[13:23:35.289]   - Field: ‘lazy’
[13:23:35.289]   - Field: ‘state’
[13:23:35.289] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:35.289] - Launch lazy future ...
[13:23:35.289] Packages needed by the future expression (n = 1): ‘future’
[13:23:35.289] Packages needed by future strategies (n = 0): <none>
[13:23:35.290] {
[13:23:35.290]     {
[13:23:35.290]         {
[13:23:35.290]             ...future.startTime <- base::Sys.time()
[13:23:35.290]             {
[13:23:35.290]                 {
[13:23:35.290]                   {
[13:23:35.290]                     {
[13:23:35.290]                       {
[13:23:35.290]                         base::local({
[13:23:35.290]                           has_future <- base::requireNamespace("future", 
[13:23:35.290]                             quietly = TRUE)
[13:23:35.290]                           if (has_future) {
[13:23:35.290]                             ns <- base::getNamespace("future")
[13:23:35.290]                             version <- ns[[".package"]][["version"]]
[13:23:35.290]                             if (is.null(version)) 
[13:23:35.290]                               version <- utils::packageVersion("future")
[13:23:35.290]                           }
[13:23:35.290]                           else {
[13:23:35.290]                             version <- NULL
[13:23:35.290]                           }
[13:23:35.290]                           if (!has_future || version < "1.8.0") {
[13:23:35.290]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:35.290]                               "", base::R.version$version.string), 
[13:23:35.290]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:35.290]                                 base::R.version$platform, 8 * 
[13:23:35.290]                                   base::.Machine$sizeof.pointer), 
[13:23:35.290]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:35.290]                                 "release", "version")], collapse = " "), 
[13:23:35.290]                               hostname = base::Sys.info()[["nodename"]])
[13:23:35.290]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:35.290]                               info)
[13:23:35.290]                             info <- base::paste(info, collapse = "; ")
[13:23:35.290]                             if (!has_future) {
[13:23:35.290]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:35.290]                                 info)
[13:23:35.290]                             }
[13:23:35.290]                             else {
[13:23:35.290]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:35.290]                                 info, version)
[13:23:35.290]                             }
[13:23:35.290]                             base::stop(msg)
[13:23:35.290]                           }
[13:23:35.290]                         })
[13:23:35.290]                       }
[13:23:35.290]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:35.290]                       base::options(mc.cores = 1L)
[13:23:35.290]                     }
[13:23:35.290]                     base::local({
[13:23:35.290]                       for (pkg in "future") {
[13:23:35.290]                         base::loadNamespace(pkg)
[13:23:35.290]                         base::library(pkg, character.only = TRUE)
[13:23:35.290]                       }
[13:23:35.290]                     })
[13:23:35.290]                   }
[13:23:35.290]                   options(future.plan = NULL)
[13:23:35.290]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:35.290]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:35.290]                 }
[13:23:35.290]                 ...future.workdir <- getwd()
[13:23:35.290]             }
[13:23:35.290]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:35.290]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:35.290]         }
[13:23:35.290]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:35.290]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:35.290]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:35.290]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:35.290]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:35.290]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:35.290]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:35.290]             base::names(...future.oldOptions))
[13:23:35.290]     }
[13:23:35.290]     if (FALSE) {
[13:23:35.290]     }
[13:23:35.290]     else {
[13:23:35.290]         if (TRUE) {
[13:23:35.290]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:35.290]                 open = "w")
[13:23:35.290]         }
[13:23:35.290]         else {
[13:23:35.290]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:35.290]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:35.290]         }
[13:23:35.290]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:35.290]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:35.290]             base::sink(type = "output", split = FALSE)
[13:23:35.290]             base::close(...future.stdout)
[13:23:35.290]         }, add = TRUE)
[13:23:35.290]     }
[13:23:35.290]     ...future.frame <- base::sys.nframe()
[13:23:35.290]     ...future.conditions <- base::list()
[13:23:35.290]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:35.290]     if (FALSE) {
[13:23:35.290]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:35.290]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:35.290]     }
[13:23:35.290]     ...future.result <- base::tryCatch({
[13:23:35.290]         base::withCallingHandlers({
[13:23:35.290]             ...future.value <- base::withVisible(base::local({
[13:23:35.290]                 ...future.makeSendCondition <- base::local({
[13:23:35.290]                   sendCondition <- NULL
[13:23:35.290]                   function(frame = 1L) {
[13:23:35.290]                     if (is.function(sendCondition)) 
[13:23:35.290]                       return(sendCondition)
[13:23:35.290]                     ns <- getNamespace("parallel")
[13:23:35.290]                     if (exists("sendData", mode = "function", 
[13:23:35.290]                       envir = ns)) {
[13:23:35.290]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:35.290]                         envir = ns)
[13:23:35.290]                       envir <- sys.frame(frame)
[13:23:35.290]                       master <- NULL
[13:23:35.290]                       while (!identical(envir, .GlobalEnv) && 
[13:23:35.290]                         !identical(envir, emptyenv())) {
[13:23:35.290]                         if (exists("master", mode = "list", envir = envir, 
[13:23:35.290]                           inherits = FALSE)) {
[13:23:35.290]                           master <- get("master", mode = "list", 
[13:23:35.290]                             envir = envir, inherits = FALSE)
[13:23:35.290]                           if (inherits(master, c("SOCKnode", 
[13:23:35.290]                             "SOCK0node"))) {
[13:23:35.290]                             sendCondition <<- function(cond) {
[13:23:35.290]                               data <- list(type = "VALUE", value = cond, 
[13:23:35.290]                                 success = TRUE)
[13:23:35.290]                               parallel_sendData(master, data)
[13:23:35.290]                             }
[13:23:35.290]                             return(sendCondition)
[13:23:35.290]                           }
[13:23:35.290]                         }
[13:23:35.290]                         frame <- frame + 1L
[13:23:35.290]                         envir <- sys.frame(frame)
[13:23:35.290]                       }
[13:23:35.290]                     }
[13:23:35.290]                     sendCondition <<- function(cond) NULL
[13:23:35.290]                   }
[13:23:35.290]                 })
[13:23:35.290]                 withCallingHandlers({
[13:23:35.290]                   value(a) + 1
[13:23:35.290]                 }, immediateCondition = function(cond) {
[13:23:35.290]                   sendCondition <- ...future.makeSendCondition()
[13:23:35.290]                   sendCondition(cond)
[13:23:35.290]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.290]                   {
[13:23:35.290]                     inherits <- base::inherits
[13:23:35.290]                     invokeRestart <- base::invokeRestart
[13:23:35.290]                     is.null <- base::is.null
[13:23:35.290]                     muffled <- FALSE
[13:23:35.290]                     if (inherits(cond, "message")) {
[13:23:35.290]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:35.290]                       if (muffled) 
[13:23:35.290]                         invokeRestart("muffleMessage")
[13:23:35.290]                     }
[13:23:35.290]                     else if (inherits(cond, "warning")) {
[13:23:35.290]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:35.290]                       if (muffled) 
[13:23:35.290]                         invokeRestart("muffleWarning")
[13:23:35.290]                     }
[13:23:35.290]                     else if (inherits(cond, "condition")) {
[13:23:35.290]                       if (!is.null(pattern)) {
[13:23:35.290]                         computeRestarts <- base::computeRestarts
[13:23:35.290]                         grepl <- base::grepl
[13:23:35.290]                         restarts <- computeRestarts(cond)
[13:23:35.290]                         for (restart in restarts) {
[13:23:35.290]                           name <- restart$name
[13:23:35.290]                           if (is.null(name)) 
[13:23:35.290]                             next
[13:23:35.290]                           if (!grepl(pattern, name)) 
[13:23:35.290]                             next
[13:23:35.290]                           invokeRestart(restart)
[13:23:35.290]                           muffled <- TRUE
[13:23:35.290]                           break
[13:23:35.290]                         }
[13:23:35.290]                       }
[13:23:35.290]                     }
[13:23:35.290]                     invisible(muffled)
[13:23:35.290]                   }
[13:23:35.290]                   muffleCondition(cond)
[13:23:35.290]                 })
[13:23:35.290]             }))
[13:23:35.290]             future::FutureResult(value = ...future.value$value, 
[13:23:35.290]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:35.290]                   ...future.rng), globalenv = if (FALSE) 
[13:23:35.290]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:35.290]                     ...future.globalenv.names))
[13:23:35.290]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:35.290]         }, condition = base::local({
[13:23:35.290]             c <- base::c
[13:23:35.290]             inherits <- base::inherits
[13:23:35.290]             invokeRestart <- base::invokeRestart
[13:23:35.290]             length <- base::length
[13:23:35.290]             list <- base::list
[13:23:35.290]             seq.int <- base::seq.int
[13:23:35.290]             signalCondition <- base::signalCondition
[13:23:35.290]             sys.calls <- base::sys.calls
[13:23:35.290]             `[[` <- base::`[[`
[13:23:35.290]             `+` <- base::`+`
[13:23:35.290]             `<<-` <- base::`<<-`
[13:23:35.290]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:35.290]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:35.290]                   3L)]
[13:23:35.290]             }
[13:23:35.290]             function(cond) {
[13:23:35.290]                 is_error <- inherits(cond, "error")
[13:23:35.290]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:35.290]                   NULL)
[13:23:35.290]                 if (is_error) {
[13:23:35.290]                   sessionInformation <- function() {
[13:23:35.290]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:35.290]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:35.290]                       search = base::search(), system = base::Sys.info())
[13:23:35.290]                   }
[13:23:35.290]                   ...future.conditions[[length(...future.conditions) + 
[13:23:35.290]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:35.290]                     cond$call), session = sessionInformation(), 
[13:23:35.290]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:35.290]                   signalCondition(cond)
[13:23:35.290]                 }
[13:23:35.290]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:35.290]                 "immediateCondition"))) {
[13:23:35.290]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:35.290]                   ...future.conditions[[length(...future.conditions) + 
[13:23:35.290]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:35.290]                   if (TRUE && !signal) {
[13:23:35.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.290]                     {
[13:23:35.290]                       inherits <- base::inherits
[13:23:35.290]                       invokeRestart <- base::invokeRestart
[13:23:35.290]                       is.null <- base::is.null
[13:23:35.290]                       muffled <- FALSE
[13:23:35.290]                       if (inherits(cond, "message")) {
[13:23:35.290]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:35.290]                         if (muffled) 
[13:23:35.290]                           invokeRestart("muffleMessage")
[13:23:35.290]                       }
[13:23:35.290]                       else if (inherits(cond, "warning")) {
[13:23:35.290]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:35.290]                         if (muffled) 
[13:23:35.290]                           invokeRestart("muffleWarning")
[13:23:35.290]                       }
[13:23:35.290]                       else if (inherits(cond, "condition")) {
[13:23:35.290]                         if (!is.null(pattern)) {
[13:23:35.290]                           computeRestarts <- base::computeRestarts
[13:23:35.290]                           grepl <- base::grepl
[13:23:35.290]                           restarts <- computeRestarts(cond)
[13:23:35.290]                           for (restart in restarts) {
[13:23:35.290]                             name <- restart$name
[13:23:35.290]                             if (is.null(name)) 
[13:23:35.290]                               next
[13:23:35.290]                             if (!grepl(pattern, name)) 
[13:23:35.290]                               next
[13:23:35.290]                             invokeRestart(restart)
[13:23:35.290]                             muffled <- TRUE
[13:23:35.290]                             break
[13:23:35.290]                           }
[13:23:35.290]                         }
[13:23:35.290]                       }
[13:23:35.290]                       invisible(muffled)
[13:23:35.290]                     }
[13:23:35.290]                     muffleCondition(cond, pattern = "^muffle")
[13:23:35.290]                   }
[13:23:35.290]                 }
[13:23:35.290]                 else {
[13:23:35.290]                   if (TRUE) {
[13:23:35.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.290]                     {
[13:23:35.290]                       inherits <- base::inherits
[13:23:35.290]                       invokeRestart <- base::invokeRestart
[13:23:35.290]                       is.null <- base::is.null
[13:23:35.290]                       muffled <- FALSE
[13:23:35.290]                       if (inherits(cond, "message")) {
[13:23:35.290]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:35.290]                         if (muffled) 
[13:23:35.290]                           invokeRestart("muffleMessage")
[13:23:35.290]                       }
[13:23:35.290]                       else if (inherits(cond, "warning")) {
[13:23:35.290]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:35.290]                         if (muffled) 
[13:23:35.290]                           invokeRestart("muffleWarning")
[13:23:35.290]                       }
[13:23:35.290]                       else if (inherits(cond, "condition")) {
[13:23:35.290]                         if (!is.null(pattern)) {
[13:23:35.290]                           computeRestarts <- base::computeRestarts
[13:23:35.290]                           grepl <- base::grepl
[13:23:35.290]                           restarts <- computeRestarts(cond)
[13:23:35.290]                           for (restart in restarts) {
[13:23:35.290]                             name <- restart$name
[13:23:35.290]                             if (is.null(name)) 
[13:23:35.290]                               next
[13:23:35.290]                             if (!grepl(pattern, name)) 
[13:23:35.290]                               next
[13:23:35.290]                             invokeRestart(restart)
[13:23:35.290]                             muffled <- TRUE
[13:23:35.290]                             break
[13:23:35.290]                           }
[13:23:35.290]                         }
[13:23:35.290]                       }
[13:23:35.290]                       invisible(muffled)
[13:23:35.290]                     }
[13:23:35.290]                     muffleCondition(cond, pattern = "^muffle")
[13:23:35.290]                   }
[13:23:35.290]                 }
[13:23:35.290]             }
[13:23:35.290]         }))
[13:23:35.290]     }, error = function(ex) {
[13:23:35.290]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:35.290]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:35.290]                 ...future.rng), started = ...future.startTime, 
[13:23:35.290]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:35.290]             version = "1.8"), class = "FutureResult")
[13:23:35.290]     }, finally = {
[13:23:35.290]         if (!identical(...future.workdir, getwd())) 
[13:23:35.290]             setwd(...future.workdir)
[13:23:35.290]         {
[13:23:35.290]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:35.290]                 ...future.oldOptions$nwarnings <- NULL
[13:23:35.290]             }
[13:23:35.290]             base::options(...future.oldOptions)
[13:23:35.290]             if (.Platform$OS.type == "windows") {
[13:23:35.290]                 old_names <- names(...future.oldEnvVars)
[13:23:35.290]                 envs <- base::Sys.getenv()
[13:23:35.290]                 names <- names(envs)
[13:23:35.290]                 common <- intersect(names, old_names)
[13:23:35.290]                 added <- setdiff(names, old_names)
[13:23:35.290]                 removed <- setdiff(old_names, names)
[13:23:35.290]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:35.290]                   envs[common]]
[13:23:35.290]                 NAMES <- toupper(changed)
[13:23:35.290]                 args <- list()
[13:23:35.290]                 for (kk in seq_along(NAMES)) {
[13:23:35.290]                   name <- changed[[kk]]
[13:23:35.290]                   NAME <- NAMES[[kk]]
[13:23:35.290]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.290]                     next
[13:23:35.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:35.290]                 }
[13:23:35.290]                 NAMES <- toupper(added)
[13:23:35.290]                 for (kk in seq_along(NAMES)) {
[13:23:35.290]                   name <- added[[kk]]
[13:23:35.290]                   NAME <- NAMES[[kk]]
[13:23:35.290]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.290]                     next
[13:23:35.290]                   args[[name]] <- ""
[13:23:35.290]                 }
[13:23:35.290]                 NAMES <- toupper(removed)
[13:23:35.290]                 for (kk in seq_along(NAMES)) {
[13:23:35.290]                   name <- removed[[kk]]
[13:23:35.290]                   NAME <- NAMES[[kk]]
[13:23:35.290]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.290]                     next
[13:23:35.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:35.290]                 }
[13:23:35.290]                 if (length(args) > 0) 
[13:23:35.290]                   base::do.call(base::Sys.setenv, args = args)
[13:23:35.290]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:35.290]             }
[13:23:35.290]             else {
[13:23:35.290]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:35.290]             }
[13:23:35.290]             {
[13:23:35.290]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:35.290]                   0L) {
[13:23:35.290]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:35.290]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:35.290]                   base::options(opts)
[13:23:35.290]                 }
[13:23:35.290]                 {
[13:23:35.290]                   {
[13:23:35.290]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:35.290]                     NULL
[13:23:35.290]                   }
[13:23:35.290]                   options(future.plan = NULL)
[13:23:35.290]                   if (is.na(NA_character_)) 
[13:23:35.290]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:35.290]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:35.290]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:35.290]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:35.290]                     envir = parent.frame()) 
[13:23:35.290]                   {
[13:23:35.290]                     if (is.function(workers)) 
[13:23:35.290]                       workers <- workers()
[13:23:35.290]                     workers <- structure(as.integer(workers), 
[13:23:35.290]                       class = class(workers))
[13:23:35.290]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:35.290]                       workers >= 1)
[13:23:35.290]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:35.290]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:35.290]                     }
[13:23:35.290]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:35.290]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:35.290]                       envir = envir)
[13:23:35.290]                     if (!future$lazy) 
[13:23:35.290]                       future <- run(future)
[13:23:35.290]                     invisible(future)
[13:23:35.290]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:35.290]                 }
[13:23:35.290]             }
[13:23:35.290]         }
[13:23:35.290]     })
[13:23:35.290]     if (TRUE) {
[13:23:35.290]         base::sink(type = "output", split = FALSE)
[13:23:35.290]         if (TRUE) {
[13:23:35.290]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:35.290]         }
[13:23:35.290]         else {
[13:23:35.290]             ...future.result["stdout"] <- base::list(NULL)
[13:23:35.290]         }
[13:23:35.290]         base::close(...future.stdout)
[13:23:35.290]         ...future.stdout <- NULL
[13:23:35.290]     }
[13:23:35.290]     ...future.result$conditions <- ...future.conditions
[13:23:35.290]     ...future.result$finished <- base::Sys.time()
[13:23:35.290]     ...future.result
[13:23:35.290] }
[13:23:35.293] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[13:23:35.294] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[13:23:35.344] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[13:23:35.345] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[13:23:35.345] MultisessionFuture started
[13:23:35.345] - Launch lazy future ... done
[13:23:35.345] run() for ‘MultisessionFuture’ ... done
[13:23:35.346] result() for ClusterFuture ...
[13:23:35.346] receiveMessageFromWorker() for ClusterFuture ...
[13:23:35.346] - Validating connection of MultisessionFuture
[13:23:35.398] - received message: FutureResult
[13:23:35.398] - Received FutureResult
[13:23:35.398] - Erased future from FutureRegistry
[13:23:35.398] result() for ClusterFuture ...
[13:23:35.398] - result already collected: FutureResult
[13:23:35.398] result() for ClusterFuture ... done
[13:23:35.398] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:35.398] result() for ClusterFuture ... done
[13:23:35.399] result() for ClusterFuture ...
[13:23:35.399] - result already collected: FutureResult
[13:23:35.399] result() for ClusterFuture ... done
value(b) = 2
[13:23:35.399] result() for ClusterFuture ...
[13:23:35.399] - result already collected: FutureResult
[13:23:35.399] result() for ClusterFuture ... done
[13:23:35.399] result() for ClusterFuture ...
[13:23:35.399] - result already collected: FutureResult
[13:23:35.399] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:35.400] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:35.400] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:35.400] 
[13:23:35.401] Searching for globals ... DONE
[13:23:35.401] - globals: [0] <none>
[13:23:35.401] getGlobalsAndPackages() ... DONE
[13:23:35.401] run() for ‘Future’ ...
[13:23:35.401] - state: ‘created’
[13:23:35.401] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:35.416] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:35.416] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:35.416]   - Field: ‘node’
[13:23:35.416]   - Field: ‘label’
[13:23:35.416]   - Field: ‘local’
[13:23:35.417]   - Field: ‘owner’
[13:23:35.417]   - Field: ‘envir’
[13:23:35.417]   - Field: ‘workers’
[13:23:35.417]   - Field: ‘packages’
[13:23:35.417]   - Field: ‘gc’
[13:23:35.417]   - Field: ‘conditions’
[13:23:35.417]   - Field: ‘persistent’
[13:23:35.417]   - Field: ‘expr’
[13:23:35.417]   - Field: ‘uuid’
[13:23:35.417]   - Field: ‘seed’
[13:23:35.417]   - Field: ‘version’
[13:23:35.418]   - Field: ‘result’
[13:23:35.418]   - Field: ‘asynchronous’
[13:23:35.418]   - Field: ‘calls’
[13:23:35.418]   - Field: ‘globals’
[13:23:35.418]   - Field: ‘stdout’
[13:23:35.418]   - Field: ‘earlySignal’
[13:23:35.418]   - Field: ‘lazy’
[13:23:35.418]   - Field: ‘state’
[13:23:35.418] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:35.418] - Launch lazy future ...
[13:23:35.419] Packages needed by the future expression (n = 0): <none>
[13:23:35.419] Packages needed by future strategies (n = 0): <none>
[13:23:35.419] {
[13:23:35.419]     {
[13:23:35.419]         {
[13:23:35.419]             ...future.startTime <- base::Sys.time()
[13:23:35.419]             {
[13:23:35.419]                 {
[13:23:35.419]                   {
[13:23:35.419]                     {
[13:23:35.419]                       base::local({
[13:23:35.419]                         has_future <- base::requireNamespace("future", 
[13:23:35.419]                           quietly = TRUE)
[13:23:35.419]                         if (has_future) {
[13:23:35.419]                           ns <- base::getNamespace("future")
[13:23:35.419]                           version <- ns[[".package"]][["version"]]
[13:23:35.419]                           if (is.null(version)) 
[13:23:35.419]                             version <- utils::packageVersion("future")
[13:23:35.419]                         }
[13:23:35.419]                         else {
[13:23:35.419]                           version <- NULL
[13:23:35.419]                         }
[13:23:35.419]                         if (!has_future || version < "1.8.0") {
[13:23:35.419]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:35.419]                             "", base::R.version$version.string), 
[13:23:35.419]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:35.419]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:35.419]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:35.419]                               "release", "version")], collapse = " "), 
[13:23:35.419]                             hostname = base::Sys.info()[["nodename"]])
[13:23:35.419]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:35.419]                             info)
[13:23:35.419]                           info <- base::paste(info, collapse = "; ")
[13:23:35.419]                           if (!has_future) {
[13:23:35.419]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:35.419]                               info)
[13:23:35.419]                           }
[13:23:35.419]                           else {
[13:23:35.419]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:35.419]                               info, version)
[13:23:35.419]                           }
[13:23:35.419]                           base::stop(msg)
[13:23:35.419]                         }
[13:23:35.419]                       })
[13:23:35.419]                     }
[13:23:35.419]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:35.419]                     base::options(mc.cores = 1L)
[13:23:35.419]                   }
[13:23:35.419]                   options(future.plan = NULL)
[13:23:35.419]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:35.419]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:35.419]                 }
[13:23:35.419]                 ...future.workdir <- getwd()
[13:23:35.419]             }
[13:23:35.419]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:35.419]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:35.419]         }
[13:23:35.419]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:35.419]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:35.419]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:35.419]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:35.419]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:35.419]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:35.419]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:35.419]             base::names(...future.oldOptions))
[13:23:35.419]     }
[13:23:35.419]     if (FALSE) {
[13:23:35.419]     }
[13:23:35.419]     else {
[13:23:35.419]         if (TRUE) {
[13:23:35.419]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:35.419]                 open = "w")
[13:23:35.419]         }
[13:23:35.419]         else {
[13:23:35.419]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:35.419]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:35.419]         }
[13:23:35.419]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:35.419]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:35.419]             base::sink(type = "output", split = FALSE)
[13:23:35.419]             base::close(...future.stdout)
[13:23:35.419]         }, add = TRUE)
[13:23:35.419]     }
[13:23:35.419]     ...future.frame <- base::sys.nframe()
[13:23:35.419]     ...future.conditions <- base::list()
[13:23:35.419]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:35.419]     if (FALSE) {
[13:23:35.419]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:35.419]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:35.419]     }
[13:23:35.419]     ...future.result <- base::tryCatch({
[13:23:35.419]         base::withCallingHandlers({
[13:23:35.419]             ...future.value <- base::withVisible(base::local({
[13:23:35.419]                 ...future.makeSendCondition <- base::local({
[13:23:35.419]                   sendCondition <- NULL
[13:23:35.419]                   function(frame = 1L) {
[13:23:35.419]                     if (is.function(sendCondition)) 
[13:23:35.419]                       return(sendCondition)
[13:23:35.419]                     ns <- getNamespace("parallel")
[13:23:35.419]                     if (exists("sendData", mode = "function", 
[13:23:35.419]                       envir = ns)) {
[13:23:35.419]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:35.419]                         envir = ns)
[13:23:35.419]                       envir <- sys.frame(frame)
[13:23:35.419]                       master <- NULL
[13:23:35.419]                       while (!identical(envir, .GlobalEnv) && 
[13:23:35.419]                         !identical(envir, emptyenv())) {
[13:23:35.419]                         if (exists("master", mode = "list", envir = envir, 
[13:23:35.419]                           inherits = FALSE)) {
[13:23:35.419]                           master <- get("master", mode = "list", 
[13:23:35.419]                             envir = envir, inherits = FALSE)
[13:23:35.419]                           if (inherits(master, c("SOCKnode", 
[13:23:35.419]                             "SOCK0node"))) {
[13:23:35.419]                             sendCondition <<- function(cond) {
[13:23:35.419]                               data <- list(type = "VALUE", value = cond, 
[13:23:35.419]                                 success = TRUE)
[13:23:35.419]                               parallel_sendData(master, data)
[13:23:35.419]                             }
[13:23:35.419]                             return(sendCondition)
[13:23:35.419]                           }
[13:23:35.419]                         }
[13:23:35.419]                         frame <- frame + 1L
[13:23:35.419]                         envir <- sys.frame(frame)
[13:23:35.419]                       }
[13:23:35.419]                     }
[13:23:35.419]                     sendCondition <<- function(cond) NULL
[13:23:35.419]                   }
[13:23:35.419]                 })
[13:23:35.419]                 withCallingHandlers({
[13:23:35.419]                   1
[13:23:35.419]                 }, immediateCondition = function(cond) {
[13:23:35.419]                   sendCondition <- ...future.makeSendCondition()
[13:23:35.419]                   sendCondition(cond)
[13:23:35.419]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.419]                   {
[13:23:35.419]                     inherits <- base::inherits
[13:23:35.419]                     invokeRestart <- base::invokeRestart
[13:23:35.419]                     is.null <- base::is.null
[13:23:35.419]                     muffled <- FALSE
[13:23:35.419]                     if (inherits(cond, "message")) {
[13:23:35.419]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:35.419]                       if (muffled) 
[13:23:35.419]                         invokeRestart("muffleMessage")
[13:23:35.419]                     }
[13:23:35.419]                     else if (inherits(cond, "warning")) {
[13:23:35.419]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:35.419]                       if (muffled) 
[13:23:35.419]                         invokeRestart("muffleWarning")
[13:23:35.419]                     }
[13:23:35.419]                     else if (inherits(cond, "condition")) {
[13:23:35.419]                       if (!is.null(pattern)) {
[13:23:35.419]                         computeRestarts <- base::computeRestarts
[13:23:35.419]                         grepl <- base::grepl
[13:23:35.419]                         restarts <- computeRestarts(cond)
[13:23:35.419]                         for (restart in restarts) {
[13:23:35.419]                           name <- restart$name
[13:23:35.419]                           if (is.null(name)) 
[13:23:35.419]                             next
[13:23:35.419]                           if (!grepl(pattern, name)) 
[13:23:35.419]                             next
[13:23:35.419]                           invokeRestart(restart)
[13:23:35.419]                           muffled <- TRUE
[13:23:35.419]                           break
[13:23:35.419]                         }
[13:23:35.419]                       }
[13:23:35.419]                     }
[13:23:35.419]                     invisible(muffled)
[13:23:35.419]                   }
[13:23:35.419]                   muffleCondition(cond)
[13:23:35.419]                 })
[13:23:35.419]             }))
[13:23:35.419]             future::FutureResult(value = ...future.value$value, 
[13:23:35.419]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:35.419]                   ...future.rng), globalenv = if (FALSE) 
[13:23:35.419]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:35.419]                     ...future.globalenv.names))
[13:23:35.419]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:35.419]         }, condition = base::local({
[13:23:35.419]             c <- base::c
[13:23:35.419]             inherits <- base::inherits
[13:23:35.419]             invokeRestart <- base::invokeRestart
[13:23:35.419]             length <- base::length
[13:23:35.419]             list <- base::list
[13:23:35.419]             seq.int <- base::seq.int
[13:23:35.419]             signalCondition <- base::signalCondition
[13:23:35.419]             sys.calls <- base::sys.calls
[13:23:35.419]             `[[` <- base::`[[`
[13:23:35.419]             `+` <- base::`+`
[13:23:35.419]             `<<-` <- base::`<<-`
[13:23:35.419]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:35.419]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:35.419]                   3L)]
[13:23:35.419]             }
[13:23:35.419]             function(cond) {
[13:23:35.419]                 is_error <- inherits(cond, "error")
[13:23:35.419]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:35.419]                   NULL)
[13:23:35.419]                 if (is_error) {
[13:23:35.419]                   sessionInformation <- function() {
[13:23:35.419]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:35.419]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:35.419]                       search = base::search(), system = base::Sys.info())
[13:23:35.419]                   }
[13:23:35.419]                   ...future.conditions[[length(...future.conditions) + 
[13:23:35.419]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:35.419]                     cond$call), session = sessionInformation(), 
[13:23:35.419]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:35.419]                   signalCondition(cond)
[13:23:35.419]                 }
[13:23:35.419]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:35.419]                 "immediateCondition"))) {
[13:23:35.419]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:35.419]                   ...future.conditions[[length(...future.conditions) + 
[13:23:35.419]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:35.419]                   if (TRUE && !signal) {
[13:23:35.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.419]                     {
[13:23:35.419]                       inherits <- base::inherits
[13:23:35.419]                       invokeRestart <- base::invokeRestart
[13:23:35.419]                       is.null <- base::is.null
[13:23:35.419]                       muffled <- FALSE
[13:23:35.419]                       if (inherits(cond, "message")) {
[13:23:35.419]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:35.419]                         if (muffled) 
[13:23:35.419]                           invokeRestart("muffleMessage")
[13:23:35.419]                       }
[13:23:35.419]                       else if (inherits(cond, "warning")) {
[13:23:35.419]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:35.419]                         if (muffled) 
[13:23:35.419]                           invokeRestart("muffleWarning")
[13:23:35.419]                       }
[13:23:35.419]                       else if (inherits(cond, "condition")) {
[13:23:35.419]                         if (!is.null(pattern)) {
[13:23:35.419]                           computeRestarts <- base::computeRestarts
[13:23:35.419]                           grepl <- base::grepl
[13:23:35.419]                           restarts <- computeRestarts(cond)
[13:23:35.419]                           for (restart in restarts) {
[13:23:35.419]                             name <- restart$name
[13:23:35.419]                             if (is.null(name)) 
[13:23:35.419]                               next
[13:23:35.419]                             if (!grepl(pattern, name)) 
[13:23:35.419]                               next
[13:23:35.419]                             invokeRestart(restart)
[13:23:35.419]                             muffled <- TRUE
[13:23:35.419]                             break
[13:23:35.419]                           }
[13:23:35.419]                         }
[13:23:35.419]                       }
[13:23:35.419]                       invisible(muffled)
[13:23:35.419]                     }
[13:23:35.419]                     muffleCondition(cond, pattern = "^muffle")
[13:23:35.419]                   }
[13:23:35.419]                 }
[13:23:35.419]                 else {
[13:23:35.419]                   if (TRUE) {
[13:23:35.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.419]                     {
[13:23:35.419]                       inherits <- base::inherits
[13:23:35.419]                       invokeRestart <- base::invokeRestart
[13:23:35.419]                       is.null <- base::is.null
[13:23:35.419]                       muffled <- FALSE
[13:23:35.419]                       if (inherits(cond, "message")) {
[13:23:35.419]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:35.419]                         if (muffled) 
[13:23:35.419]                           invokeRestart("muffleMessage")
[13:23:35.419]                       }
[13:23:35.419]                       else if (inherits(cond, "warning")) {
[13:23:35.419]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:35.419]                         if (muffled) 
[13:23:35.419]                           invokeRestart("muffleWarning")
[13:23:35.419]                       }
[13:23:35.419]                       else if (inherits(cond, "condition")) {
[13:23:35.419]                         if (!is.null(pattern)) {
[13:23:35.419]                           computeRestarts <- base::computeRestarts
[13:23:35.419]                           grepl <- base::grepl
[13:23:35.419]                           restarts <- computeRestarts(cond)
[13:23:35.419]                           for (restart in restarts) {
[13:23:35.419]                             name <- restart$name
[13:23:35.419]                             if (is.null(name)) 
[13:23:35.419]                               next
[13:23:35.419]                             if (!grepl(pattern, name)) 
[13:23:35.419]                               next
[13:23:35.419]                             invokeRestart(restart)
[13:23:35.419]                             muffled <- TRUE
[13:23:35.419]                             break
[13:23:35.419]                           }
[13:23:35.419]                         }
[13:23:35.419]                       }
[13:23:35.419]                       invisible(muffled)
[13:23:35.419]                     }
[13:23:35.419]                     muffleCondition(cond, pattern = "^muffle")
[13:23:35.419]                   }
[13:23:35.419]                 }
[13:23:35.419]             }
[13:23:35.419]         }))
[13:23:35.419]     }, error = function(ex) {
[13:23:35.419]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:35.419]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:35.419]                 ...future.rng), started = ...future.startTime, 
[13:23:35.419]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:35.419]             version = "1.8"), class = "FutureResult")
[13:23:35.419]     }, finally = {
[13:23:35.419]         if (!identical(...future.workdir, getwd())) 
[13:23:35.419]             setwd(...future.workdir)
[13:23:35.419]         {
[13:23:35.419]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:35.419]                 ...future.oldOptions$nwarnings <- NULL
[13:23:35.419]             }
[13:23:35.419]             base::options(...future.oldOptions)
[13:23:35.419]             if (.Platform$OS.type == "windows") {
[13:23:35.419]                 old_names <- names(...future.oldEnvVars)
[13:23:35.419]                 envs <- base::Sys.getenv()
[13:23:35.419]                 names <- names(envs)
[13:23:35.419]                 common <- intersect(names, old_names)
[13:23:35.419]                 added <- setdiff(names, old_names)
[13:23:35.419]                 removed <- setdiff(old_names, names)
[13:23:35.419]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:35.419]                   envs[common]]
[13:23:35.419]                 NAMES <- toupper(changed)
[13:23:35.419]                 args <- list()
[13:23:35.419]                 for (kk in seq_along(NAMES)) {
[13:23:35.419]                   name <- changed[[kk]]
[13:23:35.419]                   NAME <- NAMES[[kk]]
[13:23:35.419]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.419]                     next
[13:23:35.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:35.419]                 }
[13:23:35.419]                 NAMES <- toupper(added)
[13:23:35.419]                 for (kk in seq_along(NAMES)) {
[13:23:35.419]                   name <- added[[kk]]
[13:23:35.419]                   NAME <- NAMES[[kk]]
[13:23:35.419]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.419]                     next
[13:23:35.419]                   args[[name]] <- ""
[13:23:35.419]                 }
[13:23:35.419]                 NAMES <- toupper(removed)
[13:23:35.419]                 for (kk in seq_along(NAMES)) {
[13:23:35.419]                   name <- removed[[kk]]
[13:23:35.419]                   NAME <- NAMES[[kk]]
[13:23:35.419]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.419]                     next
[13:23:35.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:35.419]                 }
[13:23:35.419]                 if (length(args) > 0) 
[13:23:35.419]                   base::do.call(base::Sys.setenv, args = args)
[13:23:35.419]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:35.419]             }
[13:23:35.419]             else {
[13:23:35.419]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:35.419]             }
[13:23:35.419]             {
[13:23:35.419]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:35.419]                   0L) {
[13:23:35.419]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:35.419]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:35.419]                   base::options(opts)
[13:23:35.419]                 }
[13:23:35.419]                 {
[13:23:35.419]                   {
[13:23:35.419]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:35.419]                     NULL
[13:23:35.419]                   }
[13:23:35.419]                   options(future.plan = NULL)
[13:23:35.419]                   if (is.na(NA_character_)) 
[13:23:35.419]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:35.419]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:35.419]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:35.419]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:35.419]                     envir = parent.frame()) 
[13:23:35.419]                   {
[13:23:35.419]                     if (is.function(workers)) 
[13:23:35.419]                       workers <- workers()
[13:23:35.419]                     workers <- structure(as.integer(workers), 
[13:23:35.419]                       class = class(workers))
[13:23:35.419]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:35.419]                       workers >= 1)
[13:23:35.419]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:35.419]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:35.419]                     }
[13:23:35.419]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:35.419]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:35.419]                       envir = envir)
[13:23:35.419]                     if (!future$lazy) 
[13:23:35.419]                       future <- run(future)
[13:23:35.419]                     invisible(future)
[13:23:35.419]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:35.419]                 }
[13:23:35.419]             }
[13:23:35.419]         }
[13:23:35.419]     })
[13:23:35.419]     if (TRUE) {
[13:23:35.419]         base::sink(type = "output", split = FALSE)
[13:23:35.419]         if (TRUE) {
[13:23:35.419]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:35.419]         }
[13:23:35.419]         else {
[13:23:35.419]             ...future.result["stdout"] <- base::list(NULL)
[13:23:35.419]         }
[13:23:35.419]         base::close(...future.stdout)
[13:23:35.419]         ...future.stdout <- NULL
[13:23:35.419]     }
[13:23:35.419]     ...future.result$conditions <- ...future.conditions
[13:23:35.419]     ...future.result$finished <- base::Sys.time()
[13:23:35.419]     ...future.result
[13:23:35.419] }
[13:23:35.422] MultisessionFuture started
[13:23:35.423] - Launch lazy future ... done
[13:23:35.423] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:35.423] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:35.423] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:35.424] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:35.424] Searching for globals ... DONE
[13:23:35.424] Resolving globals: TRUE
[13:23:35.424] Resolving any globals that are futures ...
[13:23:35.425] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:35.425] Resolving any globals that are futures ... DONE
[13:23:35.425] Resolving futures part of globals (recursively) ...
[13:23:35.425] resolve() on list ...
[13:23:35.425]  recursive: 99
[13:23:35.425]  length: 1
[13:23:35.425]  elements: ‘a’
[13:23:35.470] receiveMessageFromWorker() for ClusterFuture ...
[13:23:35.470] - Validating connection of MultisessionFuture
[13:23:35.470] - received message: FutureResult
[13:23:35.470] - Received FutureResult
[13:23:35.471] - Erased future from FutureRegistry
[13:23:35.471] result() for ClusterFuture ...
[13:23:35.471] - result already collected: FutureResult
[13:23:35.471] result() for ClusterFuture ... done
[13:23:35.471] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:35.471] Future #1
[13:23:35.471] result() for ClusterFuture ...
[13:23:35.471] - result already collected: FutureResult
[13:23:35.471] result() for ClusterFuture ... done
[13:23:35.471] result() for ClusterFuture ...
[13:23:35.472] - result already collected: FutureResult
[13:23:35.472] result() for ClusterFuture ... done
[13:23:35.472] A MultisessionFuture was resolved
[13:23:35.472]  length: 0 (resolved future 1)
[13:23:35.472] resolve() on list ... DONE
[13:23:35.472] - globals: [1] ‘a’
[13:23:35.472] Resolving futures part of globals (recursively) ... DONE
[13:23:35.474] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[13:23:35.474] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[13:23:35.475] - globals: [1] ‘a’
[13:23:35.475] - packages: [1] ‘future’
[13:23:35.475] getGlobalsAndPackages() ... DONE
[13:23:35.475] run() for ‘Future’ ...
[13:23:35.475] - state: ‘created’
[13:23:35.476] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:35.490] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:35.490] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:35.490]   - Field: ‘node’
[13:23:35.490]   - Field: ‘label’
[13:23:35.490]   - Field: ‘local’
[13:23:35.490]   - Field: ‘owner’
[13:23:35.491]   - Field: ‘envir’
[13:23:35.491]   - Field: ‘workers’
[13:23:35.491]   - Field: ‘packages’
[13:23:35.491]   - Field: ‘gc’
[13:23:35.491]   - Field: ‘conditions’
[13:23:35.491]   - Field: ‘persistent’
[13:23:35.491]   - Field: ‘expr’
[13:23:35.491]   - Field: ‘uuid’
[13:23:35.491]   - Field: ‘seed’
[13:23:35.491]   - Field: ‘version’
[13:23:35.491]   - Field: ‘result’
[13:23:35.492]   - Field: ‘asynchronous’
[13:23:35.492]   - Field: ‘calls’
[13:23:35.492]   - Field: ‘globals’
[13:23:35.492]   - Field: ‘stdout’
[13:23:35.492]   - Field: ‘earlySignal’
[13:23:35.492]   - Field: ‘lazy’
[13:23:35.492]   - Field: ‘state’
[13:23:35.492] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:35.492] - Launch lazy future ...
[13:23:35.493] Packages needed by the future expression (n = 1): ‘future’
[13:23:35.493] Packages needed by future strategies (n = 0): <none>
[13:23:35.493] {
[13:23:35.493]     {
[13:23:35.493]         {
[13:23:35.493]             ...future.startTime <- base::Sys.time()
[13:23:35.493]             {
[13:23:35.493]                 {
[13:23:35.493]                   {
[13:23:35.493]                     {
[13:23:35.493]                       {
[13:23:35.493]                         base::local({
[13:23:35.493]                           has_future <- base::requireNamespace("future", 
[13:23:35.493]                             quietly = TRUE)
[13:23:35.493]                           if (has_future) {
[13:23:35.493]                             ns <- base::getNamespace("future")
[13:23:35.493]                             version <- ns[[".package"]][["version"]]
[13:23:35.493]                             if (is.null(version)) 
[13:23:35.493]                               version <- utils::packageVersion("future")
[13:23:35.493]                           }
[13:23:35.493]                           else {
[13:23:35.493]                             version <- NULL
[13:23:35.493]                           }
[13:23:35.493]                           if (!has_future || version < "1.8.0") {
[13:23:35.493]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:35.493]                               "", base::R.version$version.string), 
[13:23:35.493]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:35.493]                                 base::R.version$platform, 8 * 
[13:23:35.493]                                   base::.Machine$sizeof.pointer), 
[13:23:35.493]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:35.493]                                 "release", "version")], collapse = " "), 
[13:23:35.493]                               hostname = base::Sys.info()[["nodename"]])
[13:23:35.493]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:35.493]                               info)
[13:23:35.493]                             info <- base::paste(info, collapse = "; ")
[13:23:35.493]                             if (!has_future) {
[13:23:35.493]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:35.493]                                 info)
[13:23:35.493]                             }
[13:23:35.493]                             else {
[13:23:35.493]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:35.493]                                 info, version)
[13:23:35.493]                             }
[13:23:35.493]                             base::stop(msg)
[13:23:35.493]                           }
[13:23:35.493]                         })
[13:23:35.493]                       }
[13:23:35.493]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:35.493]                       base::options(mc.cores = 1L)
[13:23:35.493]                     }
[13:23:35.493]                     base::local({
[13:23:35.493]                       for (pkg in "future") {
[13:23:35.493]                         base::loadNamespace(pkg)
[13:23:35.493]                         base::library(pkg, character.only = TRUE)
[13:23:35.493]                       }
[13:23:35.493]                     })
[13:23:35.493]                   }
[13:23:35.493]                   options(future.plan = NULL)
[13:23:35.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:35.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:35.493]                 }
[13:23:35.493]                 ...future.workdir <- getwd()
[13:23:35.493]             }
[13:23:35.493]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:35.493]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:35.493]         }
[13:23:35.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:35.493]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:35.493]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:35.493]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:35.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:35.493]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:35.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:35.493]             base::names(...future.oldOptions))
[13:23:35.493]     }
[13:23:35.493]     if (FALSE) {
[13:23:35.493]     }
[13:23:35.493]     else {
[13:23:35.493]         if (TRUE) {
[13:23:35.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:35.493]                 open = "w")
[13:23:35.493]         }
[13:23:35.493]         else {
[13:23:35.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:35.493]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:35.493]         }
[13:23:35.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:35.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:35.493]             base::sink(type = "output", split = FALSE)
[13:23:35.493]             base::close(...future.stdout)
[13:23:35.493]         }, add = TRUE)
[13:23:35.493]     }
[13:23:35.493]     ...future.frame <- base::sys.nframe()
[13:23:35.493]     ...future.conditions <- base::list()
[13:23:35.493]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:35.493]     if (FALSE) {
[13:23:35.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:35.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:35.493]     }
[13:23:35.493]     ...future.result <- base::tryCatch({
[13:23:35.493]         base::withCallingHandlers({
[13:23:35.493]             ...future.value <- base::withVisible(base::local({
[13:23:35.493]                 ...future.makeSendCondition <- base::local({
[13:23:35.493]                   sendCondition <- NULL
[13:23:35.493]                   function(frame = 1L) {
[13:23:35.493]                     if (is.function(sendCondition)) 
[13:23:35.493]                       return(sendCondition)
[13:23:35.493]                     ns <- getNamespace("parallel")
[13:23:35.493]                     if (exists("sendData", mode = "function", 
[13:23:35.493]                       envir = ns)) {
[13:23:35.493]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:35.493]                         envir = ns)
[13:23:35.493]                       envir <- sys.frame(frame)
[13:23:35.493]                       master <- NULL
[13:23:35.493]                       while (!identical(envir, .GlobalEnv) && 
[13:23:35.493]                         !identical(envir, emptyenv())) {
[13:23:35.493]                         if (exists("master", mode = "list", envir = envir, 
[13:23:35.493]                           inherits = FALSE)) {
[13:23:35.493]                           master <- get("master", mode = "list", 
[13:23:35.493]                             envir = envir, inherits = FALSE)
[13:23:35.493]                           if (inherits(master, c("SOCKnode", 
[13:23:35.493]                             "SOCK0node"))) {
[13:23:35.493]                             sendCondition <<- function(cond) {
[13:23:35.493]                               data <- list(type = "VALUE", value = cond, 
[13:23:35.493]                                 success = TRUE)
[13:23:35.493]                               parallel_sendData(master, data)
[13:23:35.493]                             }
[13:23:35.493]                             return(sendCondition)
[13:23:35.493]                           }
[13:23:35.493]                         }
[13:23:35.493]                         frame <- frame + 1L
[13:23:35.493]                         envir <- sys.frame(frame)
[13:23:35.493]                       }
[13:23:35.493]                     }
[13:23:35.493]                     sendCondition <<- function(cond) NULL
[13:23:35.493]                   }
[13:23:35.493]                 })
[13:23:35.493]                 withCallingHandlers({
[13:23:35.493]                   value(a) + 1
[13:23:35.493]                 }, immediateCondition = function(cond) {
[13:23:35.493]                   sendCondition <- ...future.makeSendCondition()
[13:23:35.493]                   sendCondition(cond)
[13:23:35.493]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.493]                   {
[13:23:35.493]                     inherits <- base::inherits
[13:23:35.493]                     invokeRestart <- base::invokeRestart
[13:23:35.493]                     is.null <- base::is.null
[13:23:35.493]                     muffled <- FALSE
[13:23:35.493]                     if (inherits(cond, "message")) {
[13:23:35.493]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:35.493]                       if (muffled) 
[13:23:35.493]                         invokeRestart("muffleMessage")
[13:23:35.493]                     }
[13:23:35.493]                     else if (inherits(cond, "warning")) {
[13:23:35.493]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:35.493]                       if (muffled) 
[13:23:35.493]                         invokeRestart("muffleWarning")
[13:23:35.493]                     }
[13:23:35.493]                     else if (inherits(cond, "condition")) {
[13:23:35.493]                       if (!is.null(pattern)) {
[13:23:35.493]                         computeRestarts <- base::computeRestarts
[13:23:35.493]                         grepl <- base::grepl
[13:23:35.493]                         restarts <- computeRestarts(cond)
[13:23:35.493]                         for (restart in restarts) {
[13:23:35.493]                           name <- restart$name
[13:23:35.493]                           if (is.null(name)) 
[13:23:35.493]                             next
[13:23:35.493]                           if (!grepl(pattern, name)) 
[13:23:35.493]                             next
[13:23:35.493]                           invokeRestart(restart)
[13:23:35.493]                           muffled <- TRUE
[13:23:35.493]                           break
[13:23:35.493]                         }
[13:23:35.493]                       }
[13:23:35.493]                     }
[13:23:35.493]                     invisible(muffled)
[13:23:35.493]                   }
[13:23:35.493]                   muffleCondition(cond)
[13:23:35.493]                 })
[13:23:35.493]             }))
[13:23:35.493]             future::FutureResult(value = ...future.value$value, 
[13:23:35.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:35.493]                   ...future.rng), globalenv = if (FALSE) 
[13:23:35.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:35.493]                     ...future.globalenv.names))
[13:23:35.493]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:35.493]         }, condition = base::local({
[13:23:35.493]             c <- base::c
[13:23:35.493]             inherits <- base::inherits
[13:23:35.493]             invokeRestart <- base::invokeRestart
[13:23:35.493]             length <- base::length
[13:23:35.493]             list <- base::list
[13:23:35.493]             seq.int <- base::seq.int
[13:23:35.493]             signalCondition <- base::signalCondition
[13:23:35.493]             sys.calls <- base::sys.calls
[13:23:35.493]             `[[` <- base::`[[`
[13:23:35.493]             `+` <- base::`+`
[13:23:35.493]             `<<-` <- base::`<<-`
[13:23:35.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:35.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:35.493]                   3L)]
[13:23:35.493]             }
[13:23:35.493]             function(cond) {
[13:23:35.493]                 is_error <- inherits(cond, "error")
[13:23:35.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:35.493]                   NULL)
[13:23:35.493]                 if (is_error) {
[13:23:35.493]                   sessionInformation <- function() {
[13:23:35.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:35.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:35.493]                       search = base::search(), system = base::Sys.info())
[13:23:35.493]                   }
[13:23:35.493]                   ...future.conditions[[length(...future.conditions) + 
[13:23:35.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:35.493]                     cond$call), session = sessionInformation(), 
[13:23:35.493]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:35.493]                   signalCondition(cond)
[13:23:35.493]                 }
[13:23:35.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:35.493]                 "immediateCondition"))) {
[13:23:35.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:35.493]                   ...future.conditions[[length(...future.conditions) + 
[13:23:35.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:35.493]                   if (TRUE && !signal) {
[13:23:35.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.493]                     {
[13:23:35.493]                       inherits <- base::inherits
[13:23:35.493]                       invokeRestart <- base::invokeRestart
[13:23:35.493]                       is.null <- base::is.null
[13:23:35.493]                       muffled <- FALSE
[13:23:35.493]                       if (inherits(cond, "message")) {
[13:23:35.493]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:35.493]                         if (muffled) 
[13:23:35.493]                           invokeRestart("muffleMessage")
[13:23:35.493]                       }
[13:23:35.493]                       else if (inherits(cond, "warning")) {
[13:23:35.493]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:35.493]                         if (muffled) 
[13:23:35.493]                           invokeRestart("muffleWarning")
[13:23:35.493]                       }
[13:23:35.493]                       else if (inherits(cond, "condition")) {
[13:23:35.493]                         if (!is.null(pattern)) {
[13:23:35.493]                           computeRestarts <- base::computeRestarts
[13:23:35.493]                           grepl <- base::grepl
[13:23:35.493]                           restarts <- computeRestarts(cond)
[13:23:35.493]                           for (restart in restarts) {
[13:23:35.493]                             name <- restart$name
[13:23:35.493]                             if (is.null(name)) 
[13:23:35.493]                               next
[13:23:35.493]                             if (!grepl(pattern, name)) 
[13:23:35.493]                               next
[13:23:35.493]                             invokeRestart(restart)
[13:23:35.493]                             muffled <- TRUE
[13:23:35.493]                             break
[13:23:35.493]                           }
[13:23:35.493]                         }
[13:23:35.493]                       }
[13:23:35.493]                       invisible(muffled)
[13:23:35.493]                     }
[13:23:35.493]                     muffleCondition(cond, pattern = "^muffle")
[13:23:35.493]                   }
[13:23:35.493]                 }
[13:23:35.493]                 else {
[13:23:35.493]                   if (TRUE) {
[13:23:35.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.493]                     {
[13:23:35.493]                       inherits <- base::inherits
[13:23:35.493]                       invokeRestart <- base::invokeRestart
[13:23:35.493]                       is.null <- base::is.null
[13:23:35.493]                       muffled <- FALSE
[13:23:35.493]                       if (inherits(cond, "message")) {
[13:23:35.493]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:35.493]                         if (muffled) 
[13:23:35.493]                           invokeRestart("muffleMessage")
[13:23:35.493]                       }
[13:23:35.493]                       else if (inherits(cond, "warning")) {
[13:23:35.493]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:35.493]                         if (muffled) 
[13:23:35.493]                           invokeRestart("muffleWarning")
[13:23:35.493]                       }
[13:23:35.493]                       else if (inherits(cond, "condition")) {
[13:23:35.493]                         if (!is.null(pattern)) {
[13:23:35.493]                           computeRestarts <- base::computeRestarts
[13:23:35.493]                           grepl <- base::grepl
[13:23:35.493]                           restarts <- computeRestarts(cond)
[13:23:35.493]                           for (restart in restarts) {
[13:23:35.493]                             name <- restart$name
[13:23:35.493]                             if (is.null(name)) 
[13:23:35.493]                               next
[13:23:35.493]                             if (!grepl(pattern, name)) 
[13:23:35.493]                               next
[13:23:35.493]                             invokeRestart(restart)
[13:23:35.493]                             muffled <- TRUE
[13:23:35.493]                             break
[13:23:35.493]                           }
[13:23:35.493]                         }
[13:23:35.493]                       }
[13:23:35.493]                       invisible(muffled)
[13:23:35.493]                     }
[13:23:35.493]                     muffleCondition(cond, pattern = "^muffle")
[13:23:35.493]                   }
[13:23:35.493]                 }
[13:23:35.493]             }
[13:23:35.493]         }))
[13:23:35.493]     }, error = function(ex) {
[13:23:35.493]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:35.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:35.493]                 ...future.rng), started = ...future.startTime, 
[13:23:35.493]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:35.493]             version = "1.8"), class = "FutureResult")
[13:23:35.493]     }, finally = {
[13:23:35.493]         if (!identical(...future.workdir, getwd())) 
[13:23:35.493]             setwd(...future.workdir)
[13:23:35.493]         {
[13:23:35.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:35.493]                 ...future.oldOptions$nwarnings <- NULL
[13:23:35.493]             }
[13:23:35.493]             base::options(...future.oldOptions)
[13:23:35.493]             if (.Platform$OS.type == "windows") {
[13:23:35.493]                 old_names <- names(...future.oldEnvVars)
[13:23:35.493]                 envs <- base::Sys.getenv()
[13:23:35.493]                 names <- names(envs)
[13:23:35.493]                 common <- intersect(names, old_names)
[13:23:35.493]                 added <- setdiff(names, old_names)
[13:23:35.493]                 removed <- setdiff(old_names, names)
[13:23:35.493]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:35.493]                   envs[common]]
[13:23:35.493]                 NAMES <- toupper(changed)
[13:23:35.493]                 args <- list()
[13:23:35.493]                 for (kk in seq_along(NAMES)) {
[13:23:35.493]                   name <- changed[[kk]]
[13:23:35.493]                   NAME <- NAMES[[kk]]
[13:23:35.493]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.493]                     next
[13:23:35.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:35.493]                 }
[13:23:35.493]                 NAMES <- toupper(added)
[13:23:35.493]                 for (kk in seq_along(NAMES)) {
[13:23:35.493]                   name <- added[[kk]]
[13:23:35.493]                   NAME <- NAMES[[kk]]
[13:23:35.493]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.493]                     next
[13:23:35.493]                   args[[name]] <- ""
[13:23:35.493]                 }
[13:23:35.493]                 NAMES <- toupper(removed)
[13:23:35.493]                 for (kk in seq_along(NAMES)) {
[13:23:35.493]                   name <- removed[[kk]]
[13:23:35.493]                   NAME <- NAMES[[kk]]
[13:23:35.493]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.493]                     next
[13:23:35.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:35.493]                 }
[13:23:35.493]                 if (length(args) > 0) 
[13:23:35.493]                   base::do.call(base::Sys.setenv, args = args)
[13:23:35.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:35.493]             }
[13:23:35.493]             else {
[13:23:35.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:35.493]             }
[13:23:35.493]             {
[13:23:35.493]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:35.493]                   0L) {
[13:23:35.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:35.493]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:35.493]                   base::options(opts)
[13:23:35.493]                 }
[13:23:35.493]                 {
[13:23:35.493]                   {
[13:23:35.493]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:35.493]                     NULL
[13:23:35.493]                   }
[13:23:35.493]                   options(future.plan = NULL)
[13:23:35.493]                   if (is.na(NA_character_)) 
[13:23:35.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:35.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:35.493]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:35.493]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:35.493]                     envir = parent.frame()) 
[13:23:35.493]                   {
[13:23:35.493]                     if (is.function(workers)) 
[13:23:35.493]                       workers <- workers()
[13:23:35.493]                     workers <- structure(as.integer(workers), 
[13:23:35.493]                       class = class(workers))
[13:23:35.493]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:35.493]                       workers >= 1)
[13:23:35.493]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:35.493]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:35.493]                     }
[13:23:35.493]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:35.493]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:35.493]                       envir = envir)
[13:23:35.493]                     if (!future$lazy) 
[13:23:35.493]                       future <- run(future)
[13:23:35.493]                     invisible(future)
[13:23:35.493]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:35.493]                 }
[13:23:35.493]             }
[13:23:35.493]         }
[13:23:35.493]     })
[13:23:35.493]     if (TRUE) {
[13:23:35.493]         base::sink(type = "output", split = FALSE)
[13:23:35.493]         if (TRUE) {
[13:23:35.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:35.493]         }
[13:23:35.493]         else {
[13:23:35.493]             ...future.result["stdout"] <- base::list(NULL)
[13:23:35.493]         }
[13:23:35.493]         base::close(...future.stdout)
[13:23:35.493]         ...future.stdout <- NULL
[13:23:35.493]     }
[13:23:35.493]     ...future.result$conditions <- ...future.conditions
[13:23:35.493]     ...future.result$finished <- base::Sys.time()
[13:23:35.493]     ...future.result
[13:23:35.493] }
[13:23:35.496] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[13:23:35.497] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[13:23:35.548] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[13:23:35.549] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[13:23:35.549] MultisessionFuture started
[13:23:35.549] - Launch lazy future ... done
[13:23:35.550] run() for ‘MultisessionFuture’ ... done
[13:23:35.550] result() for ClusterFuture ...
[13:23:35.550] receiveMessageFromWorker() for ClusterFuture ...
[13:23:35.550] - Validating connection of MultisessionFuture
[13:23:35.598] - received message: FutureResult
[13:23:35.598] - Received FutureResult
[13:23:35.598] - Erased future from FutureRegistry
[13:23:35.598] result() for ClusterFuture ...
[13:23:35.599] - result already collected: FutureResult
[13:23:35.599] result() for ClusterFuture ... done
[13:23:35.599] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:35.599] result() for ClusterFuture ... done
[13:23:35.599] result() for ClusterFuture ...
[13:23:35.599] - result already collected: FutureResult
[13:23:35.599] result() for ClusterFuture ... done
value(b) = 2
[13:23:35.600] result() for ClusterFuture ...
[13:23:35.600] - result already collected: FutureResult
[13:23:35.600] result() for ClusterFuture ... done
[13:23:35.600] result() for ClusterFuture ...
[13:23:35.600] - result already collected: FutureResult
[13:23:35.600] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:35.600] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:35.601] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:35.601] 
[13:23:35.601] Searching for globals ... DONE
[13:23:35.601] - globals: [0] <none>
[13:23:35.601] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:35.602] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:35.602] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:35.603] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:35.603] Searching for globals ... DONE
[13:23:35.603] Resolving globals: TRUE
[13:23:35.603] Resolving any globals that are futures ...
[13:23:35.603] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:35.603] Resolving any globals that are futures ... DONE
[13:23:35.604] Resolving futures part of globals (recursively) ...
[13:23:35.604] resolve() on list ...
[13:23:35.604]  recursive: 99
[13:23:35.604]  length: 1
[13:23:35.604]  elements: ‘a’
[13:23:35.604] run() for ‘Future’ ...
[13:23:35.605] - state: ‘created’
[13:23:35.605] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:35.619] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:35.619] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:35.619]   - Field: ‘node’
[13:23:35.619]   - Field: ‘label’
[13:23:35.620]   - Field: ‘local’
[13:23:35.620]   - Field: ‘owner’
[13:23:35.620]   - Field: ‘envir’
[13:23:35.620]   - Field: ‘workers’
[13:23:35.620]   - Field: ‘packages’
[13:23:35.620]   - Field: ‘gc’
[13:23:35.620]   - Field: ‘conditions’
[13:23:35.620]   - Field: ‘persistent’
[13:23:35.620]   - Field: ‘expr’
[13:23:35.620]   - Field: ‘uuid’
[13:23:35.621]   - Field: ‘seed’
[13:23:35.621]   - Field: ‘version’
[13:23:35.621]   - Field: ‘result’
[13:23:35.621]   - Field: ‘asynchronous’
[13:23:35.621]   - Field: ‘calls’
[13:23:35.621]   - Field: ‘globals’
[13:23:35.621]   - Field: ‘stdout’
[13:23:35.621]   - Field: ‘earlySignal’
[13:23:35.621]   - Field: ‘lazy’
[13:23:35.621]   - Field: ‘state’
[13:23:35.621] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:35.622] - Launch lazy future ...
[13:23:35.622] Packages needed by the future expression (n = 0): <none>
[13:23:35.622] Packages needed by future strategies (n = 0): <none>
[13:23:35.622] {
[13:23:35.622]     {
[13:23:35.622]         {
[13:23:35.622]             ...future.startTime <- base::Sys.time()
[13:23:35.622]             {
[13:23:35.622]                 {
[13:23:35.622]                   {
[13:23:35.622]                     {
[13:23:35.622]                       base::local({
[13:23:35.622]                         has_future <- base::requireNamespace("future", 
[13:23:35.622]                           quietly = TRUE)
[13:23:35.622]                         if (has_future) {
[13:23:35.622]                           ns <- base::getNamespace("future")
[13:23:35.622]                           version <- ns[[".package"]][["version"]]
[13:23:35.622]                           if (is.null(version)) 
[13:23:35.622]                             version <- utils::packageVersion("future")
[13:23:35.622]                         }
[13:23:35.622]                         else {
[13:23:35.622]                           version <- NULL
[13:23:35.622]                         }
[13:23:35.622]                         if (!has_future || version < "1.8.0") {
[13:23:35.622]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:35.622]                             "", base::R.version$version.string), 
[13:23:35.622]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:35.622]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:35.622]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:35.622]                               "release", "version")], collapse = " "), 
[13:23:35.622]                             hostname = base::Sys.info()[["nodename"]])
[13:23:35.622]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:35.622]                             info)
[13:23:35.622]                           info <- base::paste(info, collapse = "; ")
[13:23:35.622]                           if (!has_future) {
[13:23:35.622]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:35.622]                               info)
[13:23:35.622]                           }
[13:23:35.622]                           else {
[13:23:35.622]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:35.622]                               info, version)
[13:23:35.622]                           }
[13:23:35.622]                           base::stop(msg)
[13:23:35.622]                         }
[13:23:35.622]                       })
[13:23:35.622]                     }
[13:23:35.622]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:35.622]                     base::options(mc.cores = 1L)
[13:23:35.622]                   }
[13:23:35.622]                   options(future.plan = NULL)
[13:23:35.622]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:35.622]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:35.622]                 }
[13:23:35.622]                 ...future.workdir <- getwd()
[13:23:35.622]             }
[13:23:35.622]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:35.622]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:35.622]         }
[13:23:35.622]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:35.622]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:35.622]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:35.622]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:35.622]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:35.622]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:35.622]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:35.622]             base::names(...future.oldOptions))
[13:23:35.622]     }
[13:23:35.622]     if (FALSE) {
[13:23:35.622]     }
[13:23:35.622]     else {
[13:23:35.622]         if (TRUE) {
[13:23:35.622]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:35.622]                 open = "w")
[13:23:35.622]         }
[13:23:35.622]         else {
[13:23:35.622]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:35.622]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:35.622]         }
[13:23:35.622]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:35.622]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:35.622]             base::sink(type = "output", split = FALSE)
[13:23:35.622]             base::close(...future.stdout)
[13:23:35.622]         }, add = TRUE)
[13:23:35.622]     }
[13:23:35.622]     ...future.frame <- base::sys.nframe()
[13:23:35.622]     ...future.conditions <- base::list()
[13:23:35.622]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:35.622]     if (FALSE) {
[13:23:35.622]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:35.622]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:35.622]     }
[13:23:35.622]     ...future.result <- base::tryCatch({
[13:23:35.622]         base::withCallingHandlers({
[13:23:35.622]             ...future.value <- base::withVisible(base::local({
[13:23:35.622]                 ...future.makeSendCondition <- base::local({
[13:23:35.622]                   sendCondition <- NULL
[13:23:35.622]                   function(frame = 1L) {
[13:23:35.622]                     if (is.function(sendCondition)) 
[13:23:35.622]                       return(sendCondition)
[13:23:35.622]                     ns <- getNamespace("parallel")
[13:23:35.622]                     if (exists("sendData", mode = "function", 
[13:23:35.622]                       envir = ns)) {
[13:23:35.622]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:35.622]                         envir = ns)
[13:23:35.622]                       envir <- sys.frame(frame)
[13:23:35.622]                       master <- NULL
[13:23:35.622]                       while (!identical(envir, .GlobalEnv) && 
[13:23:35.622]                         !identical(envir, emptyenv())) {
[13:23:35.622]                         if (exists("master", mode = "list", envir = envir, 
[13:23:35.622]                           inherits = FALSE)) {
[13:23:35.622]                           master <- get("master", mode = "list", 
[13:23:35.622]                             envir = envir, inherits = FALSE)
[13:23:35.622]                           if (inherits(master, c("SOCKnode", 
[13:23:35.622]                             "SOCK0node"))) {
[13:23:35.622]                             sendCondition <<- function(cond) {
[13:23:35.622]                               data <- list(type = "VALUE", value = cond, 
[13:23:35.622]                                 success = TRUE)
[13:23:35.622]                               parallel_sendData(master, data)
[13:23:35.622]                             }
[13:23:35.622]                             return(sendCondition)
[13:23:35.622]                           }
[13:23:35.622]                         }
[13:23:35.622]                         frame <- frame + 1L
[13:23:35.622]                         envir <- sys.frame(frame)
[13:23:35.622]                       }
[13:23:35.622]                     }
[13:23:35.622]                     sendCondition <<- function(cond) NULL
[13:23:35.622]                   }
[13:23:35.622]                 })
[13:23:35.622]                 withCallingHandlers({
[13:23:35.622]                   1
[13:23:35.622]                 }, immediateCondition = function(cond) {
[13:23:35.622]                   sendCondition <- ...future.makeSendCondition()
[13:23:35.622]                   sendCondition(cond)
[13:23:35.622]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.622]                   {
[13:23:35.622]                     inherits <- base::inherits
[13:23:35.622]                     invokeRestart <- base::invokeRestart
[13:23:35.622]                     is.null <- base::is.null
[13:23:35.622]                     muffled <- FALSE
[13:23:35.622]                     if (inherits(cond, "message")) {
[13:23:35.622]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:35.622]                       if (muffled) 
[13:23:35.622]                         invokeRestart("muffleMessage")
[13:23:35.622]                     }
[13:23:35.622]                     else if (inherits(cond, "warning")) {
[13:23:35.622]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:35.622]                       if (muffled) 
[13:23:35.622]                         invokeRestart("muffleWarning")
[13:23:35.622]                     }
[13:23:35.622]                     else if (inherits(cond, "condition")) {
[13:23:35.622]                       if (!is.null(pattern)) {
[13:23:35.622]                         computeRestarts <- base::computeRestarts
[13:23:35.622]                         grepl <- base::grepl
[13:23:35.622]                         restarts <- computeRestarts(cond)
[13:23:35.622]                         for (restart in restarts) {
[13:23:35.622]                           name <- restart$name
[13:23:35.622]                           if (is.null(name)) 
[13:23:35.622]                             next
[13:23:35.622]                           if (!grepl(pattern, name)) 
[13:23:35.622]                             next
[13:23:35.622]                           invokeRestart(restart)
[13:23:35.622]                           muffled <- TRUE
[13:23:35.622]                           break
[13:23:35.622]                         }
[13:23:35.622]                       }
[13:23:35.622]                     }
[13:23:35.622]                     invisible(muffled)
[13:23:35.622]                   }
[13:23:35.622]                   muffleCondition(cond)
[13:23:35.622]                 })
[13:23:35.622]             }))
[13:23:35.622]             future::FutureResult(value = ...future.value$value, 
[13:23:35.622]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:35.622]                   ...future.rng), globalenv = if (FALSE) 
[13:23:35.622]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:35.622]                     ...future.globalenv.names))
[13:23:35.622]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:35.622]         }, condition = base::local({
[13:23:35.622]             c <- base::c
[13:23:35.622]             inherits <- base::inherits
[13:23:35.622]             invokeRestart <- base::invokeRestart
[13:23:35.622]             length <- base::length
[13:23:35.622]             list <- base::list
[13:23:35.622]             seq.int <- base::seq.int
[13:23:35.622]             signalCondition <- base::signalCondition
[13:23:35.622]             sys.calls <- base::sys.calls
[13:23:35.622]             `[[` <- base::`[[`
[13:23:35.622]             `+` <- base::`+`
[13:23:35.622]             `<<-` <- base::`<<-`
[13:23:35.622]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:35.622]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:35.622]                   3L)]
[13:23:35.622]             }
[13:23:35.622]             function(cond) {
[13:23:35.622]                 is_error <- inherits(cond, "error")
[13:23:35.622]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:35.622]                   NULL)
[13:23:35.622]                 if (is_error) {
[13:23:35.622]                   sessionInformation <- function() {
[13:23:35.622]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:35.622]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:35.622]                       search = base::search(), system = base::Sys.info())
[13:23:35.622]                   }
[13:23:35.622]                   ...future.conditions[[length(...future.conditions) + 
[13:23:35.622]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:35.622]                     cond$call), session = sessionInformation(), 
[13:23:35.622]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:35.622]                   signalCondition(cond)
[13:23:35.622]                 }
[13:23:35.622]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:35.622]                 "immediateCondition"))) {
[13:23:35.622]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:35.622]                   ...future.conditions[[length(...future.conditions) + 
[13:23:35.622]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:35.622]                   if (TRUE && !signal) {
[13:23:35.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.622]                     {
[13:23:35.622]                       inherits <- base::inherits
[13:23:35.622]                       invokeRestart <- base::invokeRestart
[13:23:35.622]                       is.null <- base::is.null
[13:23:35.622]                       muffled <- FALSE
[13:23:35.622]                       if (inherits(cond, "message")) {
[13:23:35.622]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:35.622]                         if (muffled) 
[13:23:35.622]                           invokeRestart("muffleMessage")
[13:23:35.622]                       }
[13:23:35.622]                       else if (inherits(cond, "warning")) {
[13:23:35.622]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:35.622]                         if (muffled) 
[13:23:35.622]                           invokeRestart("muffleWarning")
[13:23:35.622]                       }
[13:23:35.622]                       else if (inherits(cond, "condition")) {
[13:23:35.622]                         if (!is.null(pattern)) {
[13:23:35.622]                           computeRestarts <- base::computeRestarts
[13:23:35.622]                           grepl <- base::grepl
[13:23:35.622]                           restarts <- computeRestarts(cond)
[13:23:35.622]                           for (restart in restarts) {
[13:23:35.622]                             name <- restart$name
[13:23:35.622]                             if (is.null(name)) 
[13:23:35.622]                               next
[13:23:35.622]                             if (!grepl(pattern, name)) 
[13:23:35.622]                               next
[13:23:35.622]                             invokeRestart(restart)
[13:23:35.622]                             muffled <- TRUE
[13:23:35.622]                             break
[13:23:35.622]                           }
[13:23:35.622]                         }
[13:23:35.622]                       }
[13:23:35.622]                       invisible(muffled)
[13:23:35.622]                     }
[13:23:35.622]                     muffleCondition(cond, pattern = "^muffle")
[13:23:35.622]                   }
[13:23:35.622]                 }
[13:23:35.622]                 else {
[13:23:35.622]                   if (TRUE) {
[13:23:35.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.622]                     {
[13:23:35.622]                       inherits <- base::inherits
[13:23:35.622]                       invokeRestart <- base::invokeRestart
[13:23:35.622]                       is.null <- base::is.null
[13:23:35.622]                       muffled <- FALSE
[13:23:35.622]                       if (inherits(cond, "message")) {
[13:23:35.622]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:35.622]                         if (muffled) 
[13:23:35.622]                           invokeRestart("muffleMessage")
[13:23:35.622]                       }
[13:23:35.622]                       else if (inherits(cond, "warning")) {
[13:23:35.622]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:35.622]                         if (muffled) 
[13:23:35.622]                           invokeRestart("muffleWarning")
[13:23:35.622]                       }
[13:23:35.622]                       else if (inherits(cond, "condition")) {
[13:23:35.622]                         if (!is.null(pattern)) {
[13:23:35.622]                           computeRestarts <- base::computeRestarts
[13:23:35.622]                           grepl <- base::grepl
[13:23:35.622]                           restarts <- computeRestarts(cond)
[13:23:35.622]                           for (restart in restarts) {
[13:23:35.622]                             name <- restart$name
[13:23:35.622]                             if (is.null(name)) 
[13:23:35.622]                               next
[13:23:35.622]                             if (!grepl(pattern, name)) 
[13:23:35.622]                               next
[13:23:35.622]                             invokeRestart(restart)
[13:23:35.622]                             muffled <- TRUE
[13:23:35.622]                             break
[13:23:35.622]                           }
[13:23:35.622]                         }
[13:23:35.622]                       }
[13:23:35.622]                       invisible(muffled)
[13:23:35.622]                     }
[13:23:35.622]                     muffleCondition(cond, pattern = "^muffle")
[13:23:35.622]                   }
[13:23:35.622]                 }
[13:23:35.622]             }
[13:23:35.622]         }))
[13:23:35.622]     }, error = function(ex) {
[13:23:35.622]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:35.622]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:35.622]                 ...future.rng), started = ...future.startTime, 
[13:23:35.622]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:35.622]             version = "1.8"), class = "FutureResult")
[13:23:35.622]     }, finally = {
[13:23:35.622]         if (!identical(...future.workdir, getwd())) 
[13:23:35.622]             setwd(...future.workdir)
[13:23:35.622]         {
[13:23:35.622]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:35.622]                 ...future.oldOptions$nwarnings <- NULL
[13:23:35.622]             }
[13:23:35.622]             base::options(...future.oldOptions)
[13:23:35.622]             if (.Platform$OS.type == "windows") {
[13:23:35.622]                 old_names <- names(...future.oldEnvVars)
[13:23:35.622]                 envs <- base::Sys.getenv()
[13:23:35.622]                 names <- names(envs)
[13:23:35.622]                 common <- intersect(names, old_names)
[13:23:35.622]                 added <- setdiff(names, old_names)
[13:23:35.622]                 removed <- setdiff(old_names, names)
[13:23:35.622]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:35.622]                   envs[common]]
[13:23:35.622]                 NAMES <- toupper(changed)
[13:23:35.622]                 args <- list()
[13:23:35.622]                 for (kk in seq_along(NAMES)) {
[13:23:35.622]                   name <- changed[[kk]]
[13:23:35.622]                   NAME <- NAMES[[kk]]
[13:23:35.622]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.622]                     next
[13:23:35.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:35.622]                 }
[13:23:35.622]                 NAMES <- toupper(added)
[13:23:35.622]                 for (kk in seq_along(NAMES)) {
[13:23:35.622]                   name <- added[[kk]]
[13:23:35.622]                   NAME <- NAMES[[kk]]
[13:23:35.622]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.622]                     next
[13:23:35.622]                   args[[name]] <- ""
[13:23:35.622]                 }
[13:23:35.622]                 NAMES <- toupper(removed)
[13:23:35.622]                 for (kk in seq_along(NAMES)) {
[13:23:35.622]                   name <- removed[[kk]]
[13:23:35.622]                   NAME <- NAMES[[kk]]
[13:23:35.622]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.622]                     next
[13:23:35.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:35.622]                 }
[13:23:35.622]                 if (length(args) > 0) 
[13:23:35.622]                   base::do.call(base::Sys.setenv, args = args)
[13:23:35.622]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:35.622]             }
[13:23:35.622]             else {
[13:23:35.622]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:35.622]             }
[13:23:35.622]             {
[13:23:35.622]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:35.622]                   0L) {
[13:23:35.622]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:35.622]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:35.622]                   base::options(opts)
[13:23:35.622]                 }
[13:23:35.622]                 {
[13:23:35.622]                   {
[13:23:35.622]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:35.622]                     NULL
[13:23:35.622]                   }
[13:23:35.622]                   options(future.plan = NULL)
[13:23:35.622]                   if (is.na(NA_character_)) 
[13:23:35.622]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:35.622]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:35.622]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:35.622]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:35.622]                     envir = parent.frame()) 
[13:23:35.622]                   {
[13:23:35.622]                     if (is.function(workers)) 
[13:23:35.622]                       workers <- workers()
[13:23:35.622]                     workers <- structure(as.integer(workers), 
[13:23:35.622]                       class = class(workers))
[13:23:35.622]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:35.622]                       workers >= 1)
[13:23:35.622]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:35.622]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:35.622]                     }
[13:23:35.622]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:35.622]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:35.622]                       envir = envir)
[13:23:35.622]                     if (!future$lazy) 
[13:23:35.622]                       future <- run(future)
[13:23:35.622]                     invisible(future)
[13:23:35.622]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:35.622]                 }
[13:23:35.622]             }
[13:23:35.622]         }
[13:23:35.622]     })
[13:23:35.622]     if (TRUE) {
[13:23:35.622]         base::sink(type = "output", split = FALSE)
[13:23:35.622]         if (TRUE) {
[13:23:35.622]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:35.622]         }
[13:23:35.622]         else {
[13:23:35.622]             ...future.result["stdout"] <- base::list(NULL)
[13:23:35.622]         }
[13:23:35.622]         base::close(...future.stdout)
[13:23:35.622]         ...future.stdout <- NULL
[13:23:35.622]     }
[13:23:35.622]     ...future.result$conditions <- ...future.conditions
[13:23:35.622]     ...future.result$finished <- base::Sys.time()
[13:23:35.622]     ...future.result
[13:23:35.622] }
[13:23:35.626] MultisessionFuture started
[13:23:35.626] - Launch lazy future ... done
[13:23:35.626] run() for ‘MultisessionFuture’ ... done
[13:23:35.673] receiveMessageFromWorker() for ClusterFuture ...
[13:23:35.673] - Validating connection of MultisessionFuture
[13:23:35.674] - received message: FutureResult
[13:23:35.674] - Received FutureResult
[13:23:35.674] - Erased future from FutureRegistry
[13:23:35.674] result() for ClusterFuture ...
[13:23:35.674] - result already collected: FutureResult
[13:23:35.674] result() for ClusterFuture ... done
[13:23:35.674] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:35.674] Future #1
[13:23:35.675] result() for ClusterFuture ...
[13:23:35.675] - result already collected: FutureResult
[13:23:35.675] result() for ClusterFuture ... done
[13:23:35.675] result() for ClusterFuture ...
[13:23:35.675] - result already collected: FutureResult
[13:23:35.675] result() for ClusterFuture ... done
[13:23:35.675] A MultisessionFuture was resolved
[13:23:35.675]  length: 0 (resolved future 1)
[13:23:35.675] resolve() on list ... DONE
[13:23:35.675] - globals: [1] ‘a’
[13:23:35.676] Resolving futures part of globals (recursively) ... DONE
[13:23:35.677] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[13:23:35.677] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[13:23:35.677] - globals: [1] ‘a’
[13:23:35.677] - packages: [1] ‘future’
[13:23:35.677] getGlobalsAndPackages() ... DONE
[13:23:35.678] run() for ‘Future’ ...
[13:23:35.678] - state: ‘created’
[13:23:35.678] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:35.692] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:35.692] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:35.692]   - Field: ‘node’
[13:23:35.693]   - Field: ‘label’
[13:23:35.693]   - Field: ‘local’
[13:23:35.693]   - Field: ‘owner’
[13:23:35.693]   - Field: ‘envir’
[13:23:35.693]   - Field: ‘workers’
[13:23:35.693]   - Field: ‘packages’
[13:23:35.693]   - Field: ‘gc’
[13:23:35.693]   - Field: ‘conditions’
[13:23:35.693]   - Field: ‘persistent’
[13:23:35.693]   - Field: ‘expr’
[13:23:35.693]   - Field: ‘uuid’
[13:23:35.694]   - Field: ‘seed’
[13:23:35.694]   - Field: ‘version’
[13:23:35.694]   - Field: ‘result’
[13:23:35.694]   - Field: ‘asynchronous’
[13:23:35.694]   - Field: ‘calls’
[13:23:35.694]   - Field: ‘globals’
[13:23:35.694]   - Field: ‘stdout’
[13:23:35.694]   - Field: ‘earlySignal’
[13:23:35.694]   - Field: ‘lazy’
[13:23:35.694]   - Field: ‘state’
[13:23:35.694] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:35.695] - Launch lazy future ...
[13:23:35.695] Packages needed by the future expression (n = 1): ‘future’
[13:23:35.695] Packages needed by future strategies (n = 0): <none>
[13:23:35.696] {
[13:23:35.696]     {
[13:23:35.696]         {
[13:23:35.696]             ...future.startTime <- base::Sys.time()
[13:23:35.696]             {
[13:23:35.696]                 {
[13:23:35.696]                   {
[13:23:35.696]                     {
[13:23:35.696]                       {
[13:23:35.696]                         base::local({
[13:23:35.696]                           has_future <- base::requireNamespace("future", 
[13:23:35.696]                             quietly = TRUE)
[13:23:35.696]                           if (has_future) {
[13:23:35.696]                             ns <- base::getNamespace("future")
[13:23:35.696]                             version <- ns[[".package"]][["version"]]
[13:23:35.696]                             if (is.null(version)) 
[13:23:35.696]                               version <- utils::packageVersion("future")
[13:23:35.696]                           }
[13:23:35.696]                           else {
[13:23:35.696]                             version <- NULL
[13:23:35.696]                           }
[13:23:35.696]                           if (!has_future || version < "1.8.0") {
[13:23:35.696]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:35.696]                               "", base::R.version$version.string), 
[13:23:35.696]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:35.696]                                 base::R.version$platform, 8 * 
[13:23:35.696]                                   base::.Machine$sizeof.pointer), 
[13:23:35.696]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:35.696]                                 "release", "version")], collapse = " "), 
[13:23:35.696]                               hostname = base::Sys.info()[["nodename"]])
[13:23:35.696]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:35.696]                               info)
[13:23:35.696]                             info <- base::paste(info, collapse = "; ")
[13:23:35.696]                             if (!has_future) {
[13:23:35.696]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:35.696]                                 info)
[13:23:35.696]                             }
[13:23:35.696]                             else {
[13:23:35.696]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:35.696]                                 info, version)
[13:23:35.696]                             }
[13:23:35.696]                             base::stop(msg)
[13:23:35.696]                           }
[13:23:35.696]                         })
[13:23:35.696]                       }
[13:23:35.696]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:35.696]                       base::options(mc.cores = 1L)
[13:23:35.696]                     }
[13:23:35.696]                     base::local({
[13:23:35.696]                       for (pkg in "future") {
[13:23:35.696]                         base::loadNamespace(pkg)
[13:23:35.696]                         base::library(pkg, character.only = TRUE)
[13:23:35.696]                       }
[13:23:35.696]                     })
[13:23:35.696]                   }
[13:23:35.696]                   options(future.plan = NULL)
[13:23:35.696]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:35.696]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:35.696]                 }
[13:23:35.696]                 ...future.workdir <- getwd()
[13:23:35.696]             }
[13:23:35.696]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:35.696]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:35.696]         }
[13:23:35.696]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:35.696]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:35.696]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:35.696]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:35.696]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:35.696]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:35.696]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:35.696]             base::names(...future.oldOptions))
[13:23:35.696]     }
[13:23:35.696]     if (FALSE) {
[13:23:35.696]     }
[13:23:35.696]     else {
[13:23:35.696]         if (TRUE) {
[13:23:35.696]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:35.696]                 open = "w")
[13:23:35.696]         }
[13:23:35.696]         else {
[13:23:35.696]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:35.696]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:35.696]         }
[13:23:35.696]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:35.696]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:35.696]             base::sink(type = "output", split = FALSE)
[13:23:35.696]             base::close(...future.stdout)
[13:23:35.696]         }, add = TRUE)
[13:23:35.696]     }
[13:23:35.696]     ...future.frame <- base::sys.nframe()
[13:23:35.696]     ...future.conditions <- base::list()
[13:23:35.696]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:35.696]     if (FALSE) {
[13:23:35.696]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:35.696]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:35.696]     }
[13:23:35.696]     ...future.result <- base::tryCatch({
[13:23:35.696]         base::withCallingHandlers({
[13:23:35.696]             ...future.value <- base::withVisible(base::local({
[13:23:35.696]                 ...future.makeSendCondition <- base::local({
[13:23:35.696]                   sendCondition <- NULL
[13:23:35.696]                   function(frame = 1L) {
[13:23:35.696]                     if (is.function(sendCondition)) 
[13:23:35.696]                       return(sendCondition)
[13:23:35.696]                     ns <- getNamespace("parallel")
[13:23:35.696]                     if (exists("sendData", mode = "function", 
[13:23:35.696]                       envir = ns)) {
[13:23:35.696]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:35.696]                         envir = ns)
[13:23:35.696]                       envir <- sys.frame(frame)
[13:23:35.696]                       master <- NULL
[13:23:35.696]                       while (!identical(envir, .GlobalEnv) && 
[13:23:35.696]                         !identical(envir, emptyenv())) {
[13:23:35.696]                         if (exists("master", mode = "list", envir = envir, 
[13:23:35.696]                           inherits = FALSE)) {
[13:23:35.696]                           master <- get("master", mode = "list", 
[13:23:35.696]                             envir = envir, inherits = FALSE)
[13:23:35.696]                           if (inherits(master, c("SOCKnode", 
[13:23:35.696]                             "SOCK0node"))) {
[13:23:35.696]                             sendCondition <<- function(cond) {
[13:23:35.696]                               data <- list(type = "VALUE", value = cond, 
[13:23:35.696]                                 success = TRUE)
[13:23:35.696]                               parallel_sendData(master, data)
[13:23:35.696]                             }
[13:23:35.696]                             return(sendCondition)
[13:23:35.696]                           }
[13:23:35.696]                         }
[13:23:35.696]                         frame <- frame + 1L
[13:23:35.696]                         envir <- sys.frame(frame)
[13:23:35.696]                       }
[13:23:35.696]                     }
[13:23:35.696]                     sendCondition <<- function(cond) NULL
[13:23:35.696]                   }
[13:23:35.696]                 })
[13:23:35.696]                 withCallingHandlers({
[13:23:35.696]                   value(a) + 1
[13:23:35.696]                 }, immediateCondition = function(cond) {
[13:23:35.696]                   sendCondition <- ...future.makeSendCondition()
[13:23:35.696]                   sendCondition(cond)
[13:23:35.696]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.696]                   {
[13:23:35.696]                     inherits <- base::inherits
[13:23:35.696]                     invokeRestart <- base::invokeRestart
[13:23:35.696]                     is.null <- base::is.null
[13:23:35.696]                     muffled <- FALSE
[13:23:35.696]                     if (inherits(cond, "message")) {
[13:23:35.696]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:35.696]                       if (muffled) 
[13:23:35.696]                         invokeRestart("muffleMessage")
[13:23:35.696]                     }
[13:23:35.696]                     else if (inherits(cond, "warning")) {
[13:23:35.696]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:35.696]                       if (muffled) 
[13:23:35.696]                         invokeRestart("muffleWarning")
[13:23:35.696]                     }
[13:23:35.696]                     else if (inherits(cond, "condition")) {
[13:23:35.696]                       if (!is.null(pattern)) {
[13:23:35.696]                         computeRestarts <- base::computeRestarts
[13:23:35.696]                         grepl <- base::grepl
[13:23:35.696]                         restarts <- computeRestarts(cond)
[13:23:35.696]                         for (restart in restarts) {
[13:23:35.696]                           name <- restart$name
[13:23:35.696]                           if (is.null(name)) 
[13:23:35.696]                             next
[13:23:35.696]                           if (!grepl(pattern, name)) 
[13:23:35.696]                             next
[13:23:35.696]                           invokeRestart(restart)
[13:23:35.696]                           muffled <- TRUE
[13:23:35.696]                           break
[13:23:35.696]                         }
[13:23:35.696]                       }
[13:23:35.696]                     }
[13:23:35.696]                     invisible(muffled)
[13:23:35.696]                   }
[13:23:35.696]                   muffleCondition(cond)
[13:23:35.696]                 })
[13:23:35.696]             }))
[13:23:35.696]             future::FutureResult(value = ...future.value$value, 
[13:23:35.696]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:35.696]                   ...future.rng), globalenv = if (FALSE) 
[13:23:35.696]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:35.696]                     ...future.globalenv.names))
[13:23:35.696]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:35.696]         }, condition = base::local({
[13:23:35.696]             c <- base::c
[13:23:35.696]             inherits <- base::inherits
[13:23:35.696]             invokeRestart <- base::invokeRestart
[13:23:35.696]             length <- base::length
[13:23:35.696]             list <- base::list
[13:23:35.696]             seq.int <- base::seq.int
[13:23:35.696]             signalCondition <- base::signalCondition
[13:23:35.696]             sys.calls <- base::sys.calls
[13:23:35.696]             `[[` <- base::`[[`
[13:23:35.696]             `+` <- base::`+`
[13:23:35.696]             `<<-` <- base::`<<-`
[13:23:35.696]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:35.696]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:35.696]                   3L)]
[13:23:35.696]             }
[13:23:35.696]             function(cond) {
[13:23:35.696]                 is_error <- inherits(cond, "error")
[13:23:35.696]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:35.696]                   NULL)
[13:23:35.696]                 if (is_error) {
[13:23:35.696]                   sessionInformation <- function() {
[13:23:35.696]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:35.696]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:35.696]                       search = base::search(), system = base::Sys.info())
[13:23:35.696]                   }
[13:23:35.696]                   ...future.conditions[[length(...future.conditions) + 
[13:23:35.696]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:35.696]                     cond$call), session = sessionInformation(), 
[13:23:35.696]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:35.696]                   signalCondition(cond)
[13:23:35.696]                 }
[13:23:35.696]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:35.696]                 "immediateCondition"))) {
[13:23:35.696]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:35.696]                   ...future.conditions[[length(...future.conditions) + 
[13:23:35.696]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:35.696]                   if (TRUE && !signal) {
[13:23:35.696]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.696]                     {
[13:23:35.696]                       inherits <- base::inherits
[13:23:35.696]                       invokeRestart <- base::invokeRestart
[13:23:35.696]                       is.null <- base::is.null
[13:23:35.696]                       muffled <- FALSE
[13:23:35.696]                       if (inherits(cond, "message")) {
[13:23:35.696]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:35.696]                         if (muffled) 
[13:23:35.696]                           invokeRestart("muffleMessage")
[13:23:35.696]                       }
[13:23:35.696]                       else if (inherits(cond, "warning")) {
[13:23:35.696]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:35.696]                         if (muffled) 
[13:23:35.696]                           invokeRestart("muffleWarning")
[13:23:35.696]                       }
[13:23:35.696]                       else if (inherits(cond, "condition")) {
[13:23:35.696]                         if (!is.null(pattern)) {
[13:23:35.696]                           computeRestarts <- base::computeRestarts
[13:23:35.696]                           grepl <- base::grepl
[13:23:35.696]                           restarts <- computeRestarts(cond)
[13:23:35.696]                           for (restart in restarts) {
[13:23:35.696]                             name <- restart$name
[13:23:35.696]                             if (is.null(name)) 
[13:23:35.696]                               next
[13:23:35.696]                             if (!grepl(pattern, name)) 
[13:23:35.696]                               next
[13:23:35.696]                             invokeRestart(restart)
[13:23:35.696]                             muffled <- TRUE
[13:23:35.696]                             break
[13:23:35.696]                           }
[13:23:35.696]                         }
[13:23:35.696]                       }
[13:23:35.696]                       invisible(muffled)
[13:23:35.696]                     }
[13:23:35.696]                     muffleCondition(cond, pattern = "^muffle")
[13:23:35.696]                   }
[13:23:35.696]                 }
[13:23:35.696]                 else {
[13:23:35.696]                   if (TRUE) {
[13:23:35.696]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.696]                     {
[13:23:35.696]                       inherits <- base::inherits
[13:23:35.696]                       invokeRestart <- base::invokeRestart
[13:23:35.696]                       is.null <- base::is.null
[13:23:35.696]                       muffled <- FALSE
[13:23:35.696]                       if (inherits(cond, "message")) {
[13:23:35.696]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:35.696]                         if (muffled) 
[13:23:35.696]                           invokeRestart("muffleMessage")
[13:23:35.696]                       }
[13:23:35.696]                       else if (inherits(cond, "warning")) {
[13:23:35.696]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:35.696]                         if (muffled) 
[13:23:35.696]                           invokeRestart("muffleWarning")
[13:23:35.696]                       }
[13:23:35.696]                       else if (inherits(cond, "condition")) {
[13:23:35.696]                         if (!is.null(pattern)) {
[13:23:35.696]                           computeRestarts <- base::computeRestarts
[13:23:35.696]                           grepl <- base::grepl
[13:23:35.696]                           restarts <- computeRestarts(cond)
[13:23:35.696]                           for (restart in restarts) {
[13:23:35.696]                             name <- restart$name
[13:23:35.696]                             if (is.null(name)) 
[13:23:35.696]                               next
[13:23:35.696]                             if (!grepl(pattern, name)) 
[13:23:35.696]                               next
[13:23:35.696]                             invokeRestart(restart)
[13:23:35.696]                             muffled <- TRUE
[13:23:35.696]                             break
[13:23:35.696]                           }
[13:23:35.696]                         }
[13:23:35.696]                       }
[13:23:35.696]                       invisible(muffled)
[13:23:35.696]                     }
[13:23:35.696]                     muffleCondition(cond, pattern = "^muffle")
[13:23:35.696]                   }
[13:23:35.696]                 }
[13:23:35.696]             }
[13:23:35.696]         }))
[13:23:35.696]     }, error = function(ex) {
[13:23:35.696]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:35.696]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:35.696]                 ...future.rng), started = ...future.startTime, 
[13:23:35.696]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:35.696]             version = "1.8"), class = "FutureResult")
[13:23:35.696]     }, finally = {
[13:23:35.696]         if (!identical(...future.workdir, getwd())) 
[13:23:35.696]             setwd(...future.workdir)
[13:23:35.696]         {
[13:23:35.696]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:35.696]                 ...future.oldOptions$nwarnings <- NULL
[13:23:35.696]             }
[13:23:35.696]             base::options(...future.oldOptions)
[13:23:35.696]             if (.Platform$OS.type == "windows") {
[13:23:35.696]                 old_names <- names(...future.oldEnvVars)
[13:23:35.696]                 envs <- base::Sys.getenv()
[13:23:35.696]                 names <- names(envs)
[13:23:35.696]                 common <- intersect(names, old_names)
[13:23:35.696]                 added <- setdiff(names, old_names)
[13:23:35.696]                 removed <- setdiff(old_names, names)
[13:23:35.696]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:35.696]                   envs[common]]
[13:23:35.696]                 NAMES <- toupper(changed)
[13:23:35.696]                 args <- list()
[13:23:35.696]                 for (kk in seq_along(NAMES)) {
[13:23:35.696]                   name <- changed[[kk]]
[13:23:35.696]                   NAME <- NAMES[[kk]]
[13:23:35.696]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.696]                     next
[13:23:35.696]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:35.696]                 }
[13:23:35.696]                 NAMES <- toupper(added)
[13:23:35.696]                 for (kk in seq_along(NAMES)) {
[13:23:35.696]                   name <- added[[kk]]
[13:23:35.696]                   NAME <- NAMES[[kk]]
[13:23:35.696]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.696]                     next
[13:23:35.696]                   args[[name]] <- ""
[13:23:35.696]                 }
[13:23:35.696]                 NAMES <- toupper(removed)
[13:23:35.696]                 for (kk in seq_along(NAMES)) {
[13:23:35.696]                   name <- removed[[kk]]
[13:23:35.696]                   NAME <- NAMES[[kk]]
[13:23:35.696]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.696]                     next
[13:23:35.696]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:35.696]                 }
[13:23:35.696]                 if (length(args) > 0) 
[13:23:35.696]                   base::do.call(base::Sys.setenv, args = args)
[13:23:35.696]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:35.696]             }
[13:23:35.696]             else {
[13:23:35.696]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:35.696]             }
[13:23:35.696]             {
[13:23:35.696]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:35.696]                   0L) {
[13:23:35.696]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:35.696]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:35.696]                   base::options(opts)
[13:23:35.696]                 }
[13:23:35.696]                 {
[13:23:35.696]                   {
[13:23:35.696]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:35.696]                     NULL
[13:23:35.696]                   }
[13:23:35.696]                   options(future.plan = NULL)
[13:23:35.696]                   if (is.na(NA_character_)) 
[13:23:35.696]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:35.696]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:35.696]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:35.696]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:35.696]                     envir = parent.frame()) 
[13:23:35.696]                   {
[13:23:35.696]                     if (is.function(workers)) 
[13:23:35.696]                       workers <- workers()
[13:23:35.696]                     workers <- structure(as.integer(workers), 
[13:23:35.696]                       class = class(workers))
[13:23:35.696]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:35.696]                       workers >= 1)
[13:23:35.696]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:35.696]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:35.696]                     }
[13:23:35.696]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:35.696]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:35.696]                       envir = envir)
[13:23:35.696]                     if (!future$lazy) 
[13:23:35.696]                       future <- run(future)
[13:23:35.696]                     invisible(future)
[13:23:35.696]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:35.696]                 }
[13:23:35.696]             }
[13:23:35.696]         }
[13:23:35.696]     })
[13:23:35.696]     if (TRUE) {
[13:23:35.696]         base::sink(type = "output", split = FALSE)
[13:23:35.696]         if (TRUE) {
[13:23:35.696]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:35.696]         }
[13:23:35.696]         else {
[13:23:35.696]             ...future.result["stdout"] <- base::list(NULL)
[13:23:35.696]         }
[13:23:35.696]         base::close(...future.stdout)
[13:23:35.696]         ...future.stdout <- NULL
[13:23:35.696]     }
[13:23:35.696]     ...future.result$conditions <- ...future.conditions
[13:23:35.696]     ...future.result$finished <- base::Sys.time()
[13:23:35.696]     ...future.result
[13:23:35.696] }
[13:23:35.699] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[13:23:35.700] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[13:23:35.752] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[13:23:35.753] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[13:23:35.753] MultisessionFuture started
[13:23:35.754] - Launch lazy future ... done
[13:23:35.754] run() for ‘MultisessionFuture’ ... done
[13:23:35.754] result() for ClusterFuture ...
[13:23:35.754] receiveMessageFromWorker() for ClusterFuture ...
[13:23:35.754] - Validating connection of MultisessionFuture
[13:23:35.802] - received message: FutureResult
[13:23:35.802] - Received FutureResult
[13:23:35.802] - Erased future from FutureRegistry
[13:23:35.802] result() for ClusterFuture ...
[13:23:35.802] - result already collected: FutureResult
[13:23:35.802] result() for ClusterFuture ... done
[13:23:35.802] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:35.803] result() for ClusterFuture ... done
[13:23:35.803] result() for ClusterFuture ...
[13:23:35.803] - result already collected: FutureResult
[13:23:35.803] result() for ClusterFuture ... done
value(b) = 2
[13:23:35.803] result() for ClusterFuture ...
[13:23:35.803] - result already collected: FutureResult
[13:23:35.803] result() for ClusterFuture ... done
[13:23:35.803] result() for ClusterFuture ...
[13:23:35.803] - result already collected: FutureResult
[13:23:35.804] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:35.804] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:35.804] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:35.805] 
[13:23:35.805] Searching for globals ... DONE
[13:23:35.805] - globals: [0] <none>
[13:23:35.805] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:35.805] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:35.806] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:35.806] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:35.807] Searching for globals ... DONE
[13:23:35.807] Resolving globals: TRUE
[13:23:35.807] Resolving any globals that are futures ...
[13:23:35.807] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:35.807] Resolving any globals that are futures ... DONE
[13:23:35.807] Resolving futures part of globals (recursively) ...
[13:23:35.808] resolve() on list ...
[13:23:35.808]  recursive: 99
[13:23:35.808]  length: 1
[13:23:35.808]  elements: ‘a’
[13:23:35.808] run() for ‘Future’ ...
[13:23:35.808] - state: ‘created’
[13:23:35.811] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:35.826] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:35.826] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:35.826]   - Field: ‘node’
[13:23:35.826]   - Field: ‘label’
[13:23:35.826]   - Field: ‘local’
[13:23:35.826]   - Field: ‘owner’
[13:23:35.826]   - Field: ‘envir’
[13:23:35.827]   - Field: ‘workers’
[13:23:35.827]   - Field: ‘packages’
[13:23:35.827]   - Field: ‘gc’
[13:23:35.827]   - Field: ‘conditions’
[13:23:35.827]   - Field: ‘persistent’
[13:23:35.827]   - Field: ‘expr’
[13:23:35.827]   - Field: ‘uuid’
[13:23:35.827]   - Field: ‘seed’
[13:23:35.827]   - Field: ‘version’
[13:23:35.827]   - Field: ‘result’
[13:23:35.827]   - Field: ‘asynchronous’
[13:23:35.828]   - Field: ‘calls’
[13:23:35.828]   - Field: ‘globals’
[13:23:35.828]   - Field: ‘stdout’
[13:23:35.828]   - Field: ‘earlySignal’
[13:23:35.828]   - Field: ‘lazy’
[13:23:35.828]   - Field: ‘state’
[13:23:35.828] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:35.828] - Launch lazy future ...
[13:23:35.829] Packages needed by the future expression (n = 0): <none>
[13:23:35.829] Packages needed by future strategies (n = 0): <none>
[13:23:35.829] {
[13:23:35.829]     {
[13:23:35.829]         {
[13:23:35.829]             ...future.startTime <- base::Sys.time()
[13:23:35.829]             {
[13:23:35.829]                 {
[13:23:35.829]                   {
[13:23:35.829]                     {
[13:23:35.829]                       base::local({
[13:23:35.829]                         has_future <- base::requireNamespace("future", 
[13:23:35.829]                           quietly = TRUE)
[13:23:35.829]                         if (has_future) {
[13:23:35.829]                           ns <- base::getNamespace("future")
[13:23:35.829]                           version <- ns[[".package"]][["version"]]
[13:23:35.829]                           if (is.null(version)) 
[13:23:35.829]                             version <- utils::packageVersion("future")
[13:23:35.829]                         }
[13:23:35.829]                         else {
[13:23:35.829]                           version <- NULL
[13:23:35.829]                         }
[13:23:35.829]                         if (!has_future || version < "1.8.0") {
[13:23:35.829]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:35.829]                             "", base::R.version$version.string), 
[13:23:35.829]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:35.829]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:35.829]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:35.829]                               "release", "version")], collapse = " "), 
[13:23:35.829]                             hostname = base::Sys.info()[["nodename"]])
[13:23:35.829]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:35.829]                             info)
[13:23:35.829]                           info <- base::paste(info, collapse = "; ")
[13:23:35.829]                           if (!has_future) {
[13:23:35.829]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:35.829]                               info)
[13:23:35.829]                           }
[13:23:35.829]                           else {
[13:23:35.829]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:35.829]                               info, version)
[13:23:35.829]                           }
[13:23:35.829]                           base::stop(msg)
[13:23:35.829]                         }
[13:23:35.829]                       })
[13:23:35.829]                     }
[13:23:35.829]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:35.829]                     base::options(mc.cores = 1L)
[13:23:35.829]                   }
[13:23:35.829]                   options(future.plan = NULL)
[13:23:35.829]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:35.829]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:35.829]                 }
[13:23:35.829]                 ...future.workdir <- getwd()
[13:23:35.829]             }
[13:23:35.829]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:35.829]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:35.829]         }
[13:23:35.829]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:35.829]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:35.829]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:35.829]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:35.829]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:35.829]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:35.829]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:35.829]             base::names(...future.oldOptions))
[13:23:35.829]     }
[13:23:35.829]     if (FALSE) {
[13:23:35.829]     }
[13:23:35.829]     else {
[13:23:35.829]         if (TRUE) {
[13:23:35.829]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:35.829]                 open = "w")
[13:23:35.829]         }
[13:23:35.829]         else {
[13:23:35.829]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:35.829]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:35.829]         }
[13:23:35.829]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:35.829]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:35.829]             base::sink(type = "output", split = FALSE)
[13:23:35.829]             base::close(...future.stdout)
[13:23:35.829]         }, add = TRUE)
[13:23:35.829]     }
[13:23:35.829]     ...future.frame <- base::sys.nframe()
[13:23:35.829]     ...future.conditions <- base::list()
[13:23:35.829]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:35.829]     if (FALSE) {
[13:23:35.829]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:35.829]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:35.829]     }
[13:23:35.829]     ...future.result <- base::tryCatch({
[13:23:35.829]         base::withCallingHandlers({
[13:23:35.829]             ...future.value <- base::withVisible(base::local({
[13:23:35.829]                 ...future.makeSendCondition <- base::local({
[13:23:35.829]                   sendCondition <- NULL
[13:23:35.829]                   function(frame = 1L) {
[13:23:35.829]                     if (is.function(sendCondition)) 
[13:23:35.829]                       return(sendCondition)
[13:23:35.829]                     ns <- getNamespace("parallel")
[13:23:35.829]                     if (exists("sendData", mode = "function", 
[13:23:35.829]                       envir = ns)) {
[13:23:35.829]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:35.829]                         envir = ns)
[13:23:35.829]                       envir <- sys.frame(frame)
[13:23:35.829]                       master <- NULL
[13:23:35.829]                       while (!identical(envir, .GlobalEnv) && 
[13:23:35.829]                         !identical(envir, emptyenv())) {
[13:23:35.829]                         if (exists("master", mode = "list", envir = envir, 
[13:23:35.829]                           inherits = FALSE)) {
[13:23:35.829]                           master <- get("master", mode = "list", 
[13:23:35.829]                             envir = envir, inherits = FALSE)
[13:23:35.829]                           if (inherits(master, c("SOCKnode", 
[13:23:35.829]                             "SOCK0node"))) {
[13:23:35.829]                             sendCondition <<- function(cond) {
[13:23:35.829]                               data <- list(type = "VALUE", value = cond, 
[13:23:35.829]                                 success = TRUE)
[13:23:35.829]                               parallel_sendData(master, data)
[13:23:35.829]                             }
[13:23:35.829]                             return(sendCondition)
[13:23:35.829]                           }
[13:23:35.829]                         }
[13:23:35.829]                         frame <- frame + 1L
[13:23:35.829]                         envir <- sys.frame(frame)
[13:23:35.829]                       }
[13:23:35.829]                     }
[13:23:35.829]                     sendCondition <<- function(cond) NULL
[13:23:35.829]                   }
[13:23:35.829]                 })
[13:23:35.829]                 withCallingHandlers({
[13:23:35.829]                   1
[13:23:35.829]                 }, immediateCondition = function(cond) {
[13:23:35.829]                   sendCondition <- ...future.makeSendCondition()
[13:23:35.829]                   sendCondition(cond)
[13:23:35.829]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.829]                   {
[13:23:35.829]                     inherits <- base::inherits
[13:23:35.829]                     invokeRestart <- base::invokeRestart
[13:23:35.829]                     is.null <- base::is.null
[13:23:35.829]                     muffled <- FALSE
[13:23:35.829]                     if (inherits(cond, "message")) {
[13:23:35.829]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:35.829]                       if (muffled) 
[13:23:35.829]                         invokeRestart("muffleMessage")
[13:23:35.829]                     }
[13:23:35.829]                     else if (inherits(cond, "warning")) {
[13:23:35.829]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:35.829]                       if (muffled) 
[13:23:35.829]                         invokeRestart("muffleWarning")
[13:23:35.829]                     }
[13:23:35.829]                     else if (inherits(cond, "condition")) {
[13:23:35.829]                       if (!is.null(pattern)) {
[13:23:35.829]                         computeRestarts <- base::computeRestarts
[13:23:35.829]                         grepl <- base::grepl
[13:23:35.829]                         restarts <- computeRestarts(cond)
[13:23:35.829]                         for (restart in restarts) {
[13:23:35.829]                           name <- restart$name
[13:23:35.829]                           if (is.null(name)) 
[13:23:35.829]                             next
[13:23:35.829]                           if (!grepl(pattern, name)) 
[13:23:35.829]                             next
[13:23:35.829]                           invokeRestart(restart)
[13:23:35.829]                           muffled <- TRUE
[13:23:35.829]                           break
[13:23:35.829]                         }
[13:23:35.829]                       }
[13:23:35.829]                     }
[13:23:35.829]                     invisible(muffled)
[13:23:35.829]                   }
[13:23:35.829]                   muffleCondition(cond)
[13:23:35.829]                 })
[13:23:35.829]             }))
[13:23:35.829]             future::FutureResult(value = ...future.value$value, 
[13:23:35.829]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:35.829]                   ...future.rng), globalenv = if (FALSE) 
[13:23:35.829]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:35.829]                     ...future.globalenv.names))
[13:23:35.829]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:35.829]         }, condition = base::local({
[13:23:35.829]             c <- base::c
[13:23:35.829]             inherits <- base::inherits
[13:23:35.829]             invokeRestart <- base::invokeRestart
[13:23:35.829]             length <- base::length
[13:23:35.829]             list <- base::list
[13:23:35.829]             seq.int <- base::seq.int
[13:23:35.829]             signalCondition <- base::signalCondition
[13:23:35.829]             sys.calls <- base::sys.calls
[13:23:35.829]             `[[` <- base::`[[`
[13:23:35.829]             `+` <- base::`+`
[13:23:35.829]             `<<-` <- base::`<<-`
[13:23:35.829]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:35.829]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:35.829]                   3L)]
[13:23:35.829]             }
[13:23:35.829]             function(cond) {
[13:23:35.829]                 is_error <- inherits(cond, "error")
[13:23:35.829]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:35.829]                   NULL)
[13:23:35.829]                 if (is_error) {
[13:23:35.829]                   sessionInformation <- function() {
[13:23:35.829]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:35.829]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:35.829]                       search = base::search(), system = base::Sys.info())
[13:23:35.829]                   }
[13:23:35.829]                   ...future.conditions[[length(...future.conditions) + 
[13:23:35.829]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:35.829]                     cond$call), session = sessionInformation(), 
[13:23:35.829]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:35.829]                   signalCondition(cond)
[13:23:35.829]                 }
[13:23:35.829]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:35.829]                 "immediateCondition"))) {
[13:23:35.829]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:35.829]                   ...future.conditions[[length(...future.conditions) + 
[13:23:35.829]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:35.829]                   if (TRUE && !signal) {
[13:23:35.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.829]                     {
[13:23:35.829]                       inherits <- base::inherits
[13:23:35.829]                       invokeRestart <- base::invokeRestart
[13:23:35.829]                       is.null <- base::is.null
[13:23:35.829]                       muffled <- FALSE
[13:23:35.829]                       if (inherits(cond, "message")) {
[13:23:35.829]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:35.829]                         if (muffled) 
[13:23:35.829]                           invokeRestart("muffleMessage")
[13:23:35.829]                       }
[13:23:35.829]                       else if (inherits(cond, "warning")) {
[13:23:35.829]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:35.829]                         if (muffled) 
[13:23:35.829]                           invokeRestart("muffleWarning")
[13:23:35.829]                       }
[13:23:35.829]                       else if (inherits(cond, "condition")) {
[13:23:35.829]                         if (!is.null(pattern)) {
[13:23:35.829]                           computeRestarts <- base::computeRestarts
[13:23:35.829]                           grepl <- base::grepl
[13:23:35.829]                           restarts <- computeRestarts(cond)
[13:23:35.829]                           for (restart in restarts) {
[13:23:35.829]                             name <- restart$name
[13:23:35.829]                             if (is.null(name)) 
[13:23:35.829]                               next
[13:23:35.829]                             if (!grepl(pattern, name)) 
[13:23:35.829]                               next
[13:23:35.829]                             invokeRestart(restart)
[13:23:35.829]                             muffled <- TRUE
[13:23:35.829]                             break
[13:23:35.829]                           }
[13:23:35.829]                         }
[13:23:35.829]                       }
[13:23:35.829]                       invisible(muffled)
[13:23:35.829]                     }
[13:23:35.829]                     muffleCondition(cond, pattern = "^muffle")
[13:23:35.829]                   }
[13:23:35.829]                 }
[13:23:35.829]                 else {
[13:23:35.829]                   if (TRUE) {
[13:23:35.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.829]                     {
[13:23:35.829]                       inherits <- base::inherits
[13:23:35.829]                       invokeRestart <- base::invokeRestart
[13:23:35.829]                       is.null <- base::is.null
[13:23:35.829]                       muffled <- FALSE
[13:23:35.829]                       if (inherits(cond, "message")) {
[13:23:35.829]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:35.829]                         if (muffled) 
[13:23:35.829]                           invokeRestart("muffleMessage")
[13:23:35.829]                       }
[13:23:35.829]                       else if (inherits(cond, "warning")) {
[13:23:35.829]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:35.829]                         if (muffled) 
[13:23:35.829]                           invokeRestart("muffleWarning")
[13:23:35.829]                       }
[13:23:35.829]                       else if (inherits(cond, "condition")) {
[13:23:35.829]                         if (!is.null(pattern)) {
[13:23:35.829]                           computeRestarts <- base::computeRestarts
[13:23:35.829]                           grepl <- base::grepl
[13:23:35.829]                           restarts <- computeRestarts(cond)
[13:23:35.829]                           for (restart in restarts) {
[13:23:35.829]                             name <- restart$name
[13:23:35.829]                             if (is.null(name)) 
[13:23:35.829]                               next
[13:23:35.829]                             if (!grepl(pattern, name)) 
[13:23:35.829]                               next
[13:23:35.829]                             invokeRestart(restart)
[13:23:35.829]                             muffled <- TRUE
[13:23:35.829]                             break
[13:23:35.829]                           }
[13:23:35.829]                         }
[13:23:35.829]                       }
[13:23:35.829]                       invisible(muffled)
[13:23:35.829]                     }
[13:23:35.829]                     muffleCondition(cond, pattern = "^muffle")
[13:23:35.829]                   }
[13:23:35.829]                 }
[13:23:35.829]             }
[13:23:35.829]         }))
[13:23:35.829]     }, error = function(ex) {
[13:23:35.829]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:35.829]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:35.829]                 ...future.rng), started = ...future.startTime, 
[13:23:35.829]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:35.829]             version = "1.8"), class = "FutureResult")
[13:23:35.829]     }, finally = {
[13:23:35.829]         if (!identical(...future.workdir, getwd())) 
[13:23:35.829]             setwd(...future.workdir)
[13:23:35.829]         {
[13:23:35.829]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:35.829]                 ...future.oldOptions$nwarnings <- NULL
[13:23:35.829]             }
[13:23:35.829]             base::options(...future.oldOptions)
[13:23:35.829]             if (.Platform$OS.type == "windows") {
[13:23:35.829]                 old_names <- names(...future.oldEnvVars)
[13:23:35.829]                 envs <- base::Sys.getenv()
[13:23:35.829]                 names <- names(envs)
[13:23:35.829]                 common <- intersect(names, old_names)
[13:23:35.829]                 added <- setdiff(names, old_names)
[13:23:35.829]                 removed <- setdiff(old_names, names)
[13:23:35.829]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:35.829]                   envs[common]]
[13:23:35.829]                 NAMES <- toupper(changed)
[13:23:35.829]                 args <- list()
[13:23:35.829]                 for (kk in seq_along(NAMES)) {
[13:23:35.829]                   name <- changed[[kk]]
[13:23:35.829]                   NAME <- NAMES[[kk]]
[13:23:35.829]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.829]                     next
[13:23:35.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:35.829]                 }
[13:23:35.829]                 NAMES <- toupper(added)
[13:23:35.829]                 for (kk in seq_along(NAMES)) {
[13:23:35.829]                   name <- added[[kk]]
[13:23:35.829]                   NAME <- NAMES[[kk]]
[13:23:35.829]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.829]                     next
[13:23:35.829]                   args[[name]] <- ""
[13:23:35.829]                 }
[13:23:35.829]                 NAMES <- toupper(removed)
[13:23:35.829]                 for (kk in seq_along(NAMES)) {
[13:23:35.829]                   name <- removed[[kk]]
[13:23:35.829]                   NAME <- NAMES[[kk]]
[13:23:35.829]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.829]                     next
[13:23:35.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:35.829]                 }
[13:23:35.829]                 if (length(args) > 0) 
[13:23:35.829]                   base::do.call(base::Sys.setenv, args = args)
[13:23:35.829]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:35.829]             }
[13:23:35.829]             else {
[13:23:35.829]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:35.829]             }
[13:23:35.829]             {
[13:23:35.829]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:35.829]                   0L) {
[13:23:35.829]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:35.829]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:35.829]                   base::options(opts)
[13:23:35.829]                 }
[13:23:35.829]                 {
[13:23:35.829]                   {
[13:23:35.829]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:35.829]                     NULL
[13:23:35.829]                   }
[13:23:35.829]                   options(future.plan = NULL)
[13:23:35.829]                   if (is.na(NA_character_)) 
[13:23:35.829]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:35.829]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:35.829]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:35.829]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:35.829]                     envir = parent.frame()) 
[13:23:35.829]                   {
[13:23:35.829]                     if (is.function(workers)) 
[13:23:35.829]                       workers <- workers()
[13:23:35.829]                     workers <- structure(as.integer(workers), 
[13:23:35.829]                       class = class(workers))
[13:23:35.829]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:35.829]                       workers >= 1)
[13:23:35.829]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:35.829]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:35.829]                     }
[13:23:35.829]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:35.829]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:35.829]                       envir = envir)
[13:23:35.829]                     if (!future$lazy) 
[13:23:35.829]                       future <- run(future)
[13:23:35.829]                     invisible(future)
[13:23:35.829]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:35.829]                 }
[13:23:35.829]             }
[13:23:35.829]         }
[13:23:35.829]     })
[13:23:35.829]     if (TRUE) {
[13:23:35.829]         base::sink(type = "output", split = FALSE)
[13:23:35.829]         if (TRUE) {
[13:23:35.829]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:35.829]         }
[13:23:35.829]         else {
[13:23:35.829]             ...future.result["stdout"] <- base::list(NULL)
[13:23:35.829]         }
[13:23:35.829]         base::close(...future.stdout)
[13:23:35.829]         ...future.stdout <- NULL
[13:23:35.829]     }
[13:23:35.829]     ...future.result$conditions <- ...future.conditions
[13:23:35.829]     ...future.result$finished <- base::Sys.time()
[13:23:35.829]     ...future.result
[13:23:35.829] }
[13:23:35.832] MultisessionFuture started
[13:23:35.833] - Launch lazy future ... done
[13:23:35.833] run() for ‘MultisessionFuture’ ... done
[13:23:35.881] receiveMessageFromWorker() for ClusterFuture ...
[13:23:35.881] - Validating connection of MultisessionFuture
[13:23:35.882] - received message: FutureResult
[13:23:35.882] - Received FutureResult
[13:23:35.882] - Erased future from FutureRegistry
[13:23:35.882] result() for ClusterFuture ...
[13:23:35.882] - result already collected: FutureResult
[13:23:35.882] result() for ClusterFuture ... done
[13:23:35.882] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:35.882] Future #1
[13:23:35.883] result() for ClusterFuture ...
[13:23:35.883] - result already collected: FutureResult
[13:23:35.883] result() for ClusterFuture ... done
[13:23:35.883] result() for ClusterFuture ...
[13:23:35.883] - result already collected: FutureResult
[13:23:35.883] result() for ClusterFuture ... done
[13:23:35.883] A MultisessionFuture was resolved
[13:23:35.883]  length: 0 (resolved future 1)
[13:23:35.883] resolve() on list ... DONE
[13:23:35.883] - globals: [1] ‘a’
[13:23:35.884] Resolving futures part of globals (recursively) ... DONE
[13:23:35.885] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[13:23:35.885] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[13:23:35.885] - globals: [1] ‘a’
[13:23:35.885] - packages: [1] ‘future’
[13:23:35.885] getGlobalsAndPackages() ... DONE
[13:23:35.886] run() for ‘Future’ ...
[13:23:35.886] - state: ‘created’
[13:23:35.886] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:35.900] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:35.901] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:35.901]   - Field: ‘node’
[13:23:35.901]   - Field: ‘label’
[13:23:35.901]   - Field: ‘local’
[13:23:35.901]   - Field: ‘owner’
[13:23:35.901]   - Field: ‘envir’
[13:23:35.901]   - Field: ‘workers’
[13:23:35.901]   - Field: ‘packages’
[13:23:35.901]   - Field: ‘gc’
[13:23:35.901]   - Field: ‘conditions’
[13:23:35.902]   - Field: ‘persistent’
[13:23:35.902]   - Field: ‘expr’
[13:23:35.902]   - Field: ‘uuid’
[13:23:35.902]   - Field: ‘seed’
[13:23:35.902]   - Field: ‘version’
[13:23:35.902]   - Field: ‘result’
[13:23:35.902]   - Field: ‘asynchronous’
[13:23:35.902]   - Field: ‘calls’
[13:23:35.902]   - Field: ‘globals’
[13:23:35.902]   - Field: ‘stdout’
[13:23:35.902]   - Field: ‘earlySignal’
[13:23:35.903]   - Field: ‘lazy’
[13:23:35.903]   - Field: ‘state’
[13:23:35.903] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:35.903] - Launch lazy future ...
[13:23:35.903] Packages needed by the future expression (n = 1): ‘future’
[13:23:35.903] Packages needed by future strategies (n = 0): <none>
[13:23:35.904] {
[13:23:35.904]     {
[13:23:35.904]         {
[13:23:35.904]             ...future.startTime <- base::Sys.time()
[13:23:35.904]             {
[13:23:35.904]                 {
[13:23:35.904]                   {
[13:23:35.904]                     {
[13:23:35.904]                       {
[13:23:35.904]                         base::local({
[13:23:35.904]                           has_future <- base::requireNamespace("future", 
[13:23:35.904]                             quietly = TRUE)
[13:23:35.904]                           if (has_future) {
[13:23:35.904]                             ns <- base::getNamespace("future")
[13:23:35.904]                             version <- ns[[".package"]][["version"]]
[13:23:35.904]                             if (is.null(version)) 
[13:23:35.904]                               version <- utils::packageVersion("future")
[13:23:35.904]                           }
[13:23:35.904]                           else {
[13:23:35.904]                             version <- NULL
[13:23:35.904]                           }
[13:23:35.904]                           if (!has_future || version < "1.8.0") {
[13:23:35.904]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:35.904]                               "", base::R.version$version.string), 
[13:23:35.904]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:35.904]                                 base::R.version$platform, 8 * 
[13:23:35.904]                                   base::.Machine$sizeof.pointer), 
[13:23:35.904]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:35.904]                                 "release", "version")], collapse = " "), 
[13:23:35.904]                               hostname = base::Sys.info()[["nodename"]])
[13:23:35.904]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:35.904]                               info)
[13:23:35.904]                             info <- base::paste(info, collapse = "; ")
[13:23:35.904]                             if (!has_future) {
[13:23:35.904]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:35.904]                                 info)
[13:23:35.904]                             }
[13:23:35.904]                             else {
[13:23:35.904]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:35.904]                                 info, version)
[13:23:35.904]                             }
[13:23:35.904]                             base::stop(msg)
[13:23:35.904]                           }
[13:23:35.904]                         })
[13:23:35.904]                       }
[13:23:35.904]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:35.904]                       base::options(mc.cores = 1L)
[13:23:35.904]                     }
[13:23:35.904]                     base::local({
[13:23:35.904]                       for (pkg in "future") {
[13:23:35.904]                         base::loadNamespace(pkg)
[13:23:35.904]                         base::library(pkg, character.only = TRUE)
[13:23:35.904]                       }
[13:23:35.904]                     })
[13:23:35.904]                   }
[13:23:35.904]                   options(future.plan = NULL)
[13:23:35.904]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:35.904]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:35.904]                 }
[13:23:35.904]                 ...future.workdir <- getwd()
[13:23:35.904]             }
[13:23:35.904]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:35.904]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:35.904]         }
[13:23:35.904]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:35.904]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:35.904]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:35.904]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:35.904]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:35.904]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:35.904]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:35.904]             base::names(...future.oldOptions))
[13:23:35.904]     }
[13:23:35.904]     if (FALSE) {
[13:23:35.904]     }
[13:23:35.904]     else {
[13:23:35.904]         if (TRUE) {
[13:23:35.904]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:35.904]                 open = "w")
[13:23:35.904]         }
[13:23:35.904]         else {
[13:23:35.904]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:35.904]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:35.904]         }
[13:23:35.904]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:35.904]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:35.904]             base::sink(type = "output", split = FALSE)
[13:23:35.904]             base::close(...future.stdout)
[13:23:35.904]         }, add = TRUE)
[13:23:35.904]     }
[13:23:35.904]     ...future.frame <- base::sys.nframe()
[13:23:35.904]     ...future.conditions <- base::list()
[13:23:35.904]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:35.904]     if (FALSE) {
[13:23:35.904]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:35.904]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:35.904]     }
[13:23:35.904]     ...future.result <- base::tryCatch({
[13:23:35.904]         base::withCallingHandlers({
[13:23:35.904]             ...future.value <- base::withVisible(base::local({
[13:23:35.904]                 ...future.makeSendCondition <- base::local({
[13:23:35.904]                   sendCondition <- NULL
[13:23:35.904]                   function(frame = 1L) {
[13:23:35.904]                     if (is.function(sendCondition)) 
[13:23:35.904]                       return(sendCondition)
[13:23:35.904]                     ns <- getNamespace("parallel")
[13:23:35.904]                     if (exists("sendData", mode = "function", 
[13:23:35.904]                       envir = ns)) {
[13:23:35.904]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:35.904]                         envir = ns)
[13:23:35.904]                       envir <- sys.frame(frame)
[13:23:35.904]                       master <- NULL
[13:23:35.904]                       while (!identical(envir, .GlobalEnv) && 
[13:23:35.904]                         !identical(envir, emptyenv())) {
[13:23:35.904]                         if (exists("master", mode = "list", envir = envir, 
[13:23:35.904]                           inherits = FALSE)) {
[13:23:35.904]                           master <- get("master", mode = "list", 
[13:23:35.904]                             envir = envir, inherits = FALSE)
[13:23:35.904]                           if (inherits(master, c("SOCKnode", 
[13:23:35.904]                             "SOCK0node"))) {
[13:23:35.904]                             sendCondition <<- function(cond) {
[13:23:35.904]                               data <- list(type = "VALUE", value = cond, 
[13:23:35.904]                                 success = TRUE)
[13:23:35.904]                               parallel_sendData(master, data)
[13:23:35.904]                             }
[13:23:35.904]                             return(sendCondition)
[13:23:35.904]                           }
[13:23:35.904]                         }
[13:23:35.904]                         frame <- frame + 1L
[13:23:35.904]                         envir <- sys.frame(frame)
[13:23:35.904]                       }
[13:23:35.904]                     }
[13:23:35.904]                     sendCondition <<- function(cond) NULL
[13:23:35.904]                   }
[13:23:35.904]                 })
[13:23:35.904]                 withCallingHandlers({
[13:23:35.904]                   value(a) + 1
[13:23:35.904]                 }, immediateCondition = function(cond) {
[13:23:35.904]                   sendCondition <- ...future.makeSendCondition()
[13:23:35.904]                   sendCondition(cond)
[13:23:35.904]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.904]                   {
[13:23:35.904]                     inherits <- base::inherits
[13:23:35.904]                     invokeRestart <- base::invokeRestart
[13:23:35.904]                     is.null <- base::is.null
[13:23:35.904]                     muffled <- FALSE
[13:23:35.904]                     if (inherits(cond, "message")) {
[13:23:35.904]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:35.904]                       if (muffled) 
[13:23:35.904]                         invokeRestart("muffleMessage")
[13:23:35.904]                     }
[13:23:35.904]                     else if (inherits(cond, "warning")) {
[13:23:35.904]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:35.904]                       if (muffled) 
[13:23:35.904]                         invokeRestart("muffleWarning")
[13:23:35.904]                     }
[13:23:35.904]                     else if (inherits(cond, "condition")) {
[13:23:35.904]                       if (!is.null(pattern)) {
[13:23:35.904]                         computeRestarts <- base::computeRestarts
[13:23:35.904]                         grepl <- base::grepl
[13:23:35.904]                         restarts <- computeRestarts(cond)
[13:23:35.904]                         for (restart in restarts) {
[13:23:35.904]                           name <- restart$name
[13:23:35.904]                           if (is.null(name)) 
[13:23:35.904]                             next
[13:23:35.904]                           if (!grepl(pattern, name)) 
[13:23:35.904]                             next
[13:23:35.904]                           invokeRestart(restart)
[13:23:35.904]                           muffled <- TRUE
[13:23:35.904]                           break
[13:23:35.904]                         }
[13:23:35.904]                       }
[13:23:35.904]                     }
[13:23:35.904]                     invisible(muffled)
[13:23:35.904]                   }
[13:23:35.904]                   muffleCondition(cond)
[13:23:35.904]                 })
[13:23:35.904]             }))
[13:23:35.904]             future::FutureResult(value = ...future.value$value, 
[13:23:35.904]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:35.904]                   ...future.rng), globalenv = if (FALSE) 
[13:23:35.904]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:35.904]                     ...future.globalenv.names))
[13:23:35.904]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:35.904]         }, condition = base::local({
[13:23:35.904]             c <- base::c
[13:23:35.904]             inherits <- base::inherits
[13:23:35.904]             invokeRestart <- base::invokeRestart
[13:23:35.904]             length <- base::length
[13:23:35.904]             list <- base::list
[13:23:35.904]             seq.int <- base::seq.int
[13:23:35.904]             signalCondition <- base::signalCondition
[13:23:35.904]             sys.calls <- base::sys.calls
[13:23:35.904]             `[[` <- base::`[[`
[13:23:35.904]             `+` <- base::`+`
[13:23:35.904]             `<<-` <- base::`<<-`
[13:23:35.904]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:35.904]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:35.904]                   3L)]
[13:23:35.904]             }
[13:23:35.904]             function(cond) {
[13:23:35.904]                 is_error <- inherits(cond, "error")
[13:23:35.904]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:35.904]                   NULL)
[13:23:35.904]                 if (is_error) {
[13:23:35.904]                   sessionInformation <- function() {
[13:23:35.904]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:35.904]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:35.904]                       search = base::search(), system = base::Sys.info())
[13:23:35.904]                   }
[13:23:35.904]                   ...future.conditions[[length(...future.conditions) + 
[13:23:35.904]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:35.904]                     cond$call), session = sessionInformation(), 
[13:23:35.904]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:35.904]                   signalCondition(cond)
[13:23:35.904]                 }
[13:23:35.904]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:35.904]                 "immediateCondition"))) {
[13:23:35.904]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:35.904]                   ...future.conditions[[length(...future.conditions) + 
[13:23:35.904]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:35.904]                   if (TRUE && !signal) {
[13:23:35.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.904]                     {
[13:23:35.904]                       inherits <- base::inherits
[13:23:35.904]                       invokeRestart <- base::invokeRestart
[13:23:35.904]                       is.null <- base::is.null
[13:23:35.904]                       muffled <- FALSE
[13:23:35.904]                       if (inherits(cond, "message")) {
[13:23:35.904]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:35.904]                         if (muffled) 
[13:23:35.904]                           invokeRestart("muffleMessage")
[13:23:35.904]                       }
[13:23:35.904]                       else if (inherits(cond, "warning")) {
[13:23:35.904]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:35.904]                         if (muffled) 
[13:23:35.904]                           invokeRestart("muffleWarning")
[13:23:35.904]                       }
[13:23:35.904]                       else if (inherits(cond, "condition")) {
[13:23:35.904]                         if (!is.null(pattern)) {
[13:23:35.904]                           computeRestarts <- base::computeRestarts
[13:23:35.904]                           grepl <- base::grepl
[13:23:35.904]                           restarts <- computeRestarts(cond)
[13:23:35.904]                           for (restart in restarts) {
[13:23:35.904]                             name <- restart$name
[13:23:35.904]                             if (is.null(name)) 
[13:23:35.904]                               next
[13:23:35.904]                             if (!grepl(pattern, name)) 
[13:23:35.904]                               next
[13:23:35.904]                             invokeRestart(restart)
[13:23:35.904]                             muffled <- TRUE
[13:23:35.904]                             break
[13:23:35.904]                           }
[13:23:35.904]                         }
[13:23:35.904]                       }
[13:23:35.904]                       invisible(muffled)
[13:23:35.904]                     }
[13:23:35.904]                     muffleCondition(cond, pattern = "^muffle")
[13:23:35.904]                   }
[13:23:35.904]                 }
[13:23:35.904]                 else {
[13:23:35.904]                   if (TRUE) {
[13:23:35.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:35.904]                     {
[13:23:35.904]                       inherits <- base::inherits
[13:23:35.904]                       invokeRestart <- base::invokeRestart
[13:23:35.904]                       is.null <- base::is.null
[13:23:35.904]                       muffled <- FALSE
[13:23:35.904]                       if (inherits(cond, "message")) {
[13:23:35.904]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:35.904]                         if (muffled) 
[13:23:35.904]                           invokeRestart("muffleMessage")
[13:23:35.904]                       }
[13:23:35.904]                       else if (inherits(cond, "warning")) {
[13:23:35.904]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:35.904]                         if (muffled) 
[13:23:35.904]                           invokeRestart("muffleWarning")
[13:23:35.904]                       }
[13:23:35.904]                       else if (inherits(cond, "condition")) {
[13:23:35.904]                         if (!is.null(pattern)) {
[13:23:35.904]                           computeRestarts <- base::computeRestarts
[13:23:35.904]                           grepl <- base::grepl
[13:23:35.904]                           restarts <- computeRestarts(cond)
[13:23:35.904]                           for (restart in restarts) {
[13:23:35.904]                             name <- restart$name
[13:23:35.904]                             if (is.null(name)) 
[13:23:35.904]                               next
[13:23:35.904]                             if (!grepl(pattern, name)) 
[13:23:35.904]                               next
[13:23:35.904]                             invokeRestart(restart)
[13:23:35.904]                             muffled <- TRUE
[13:23:35.904]                             break
[13:23:35.904]                           }
[13:23:35.904]                         }
[13:23:35.904]                       }
[13:23:35.904]                       invisible(muffled)
[13:23:35.904]                     }
[13:23:35.904]                     muffleCondition(cond, pattern = "^muffle")
[13:23:35.904]                   }
[13:23:35.904]                 }
[13:23:35.904]             }
[13:23:35.904]         }))
[13:23:35.904]     }, error = function(ex) {
[13:23:35.904]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:35.904]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:35.904]                 ...future.rng), started = ...future.startTime, 
[13:23:35.904]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:35.904]             version = "1.8"), class = "FutureResult")
[13:23:35.904]     }, finally = {
[13:23:35.904]         if (!identical(...future.workdir, getwd())) 
[13:23:35.904]             setwd(...future.workdir)
[13:23:35.904]         {
[13:23:35.904]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:35.904]                 ...future.oldOptions$nwarnings <- NULL
[13:23:35.904]             }
[13:23:35.904]             base::options(...future.oldOptions)
[13:23:35.904]             if (.Platform$OS.type == "windows") {
[13:23:35.904]                 old_names <- names(...future.oldEnvVars)
[13:23:35.904]                 envs <- base::Sys.getenv()
[13:23:35.904]                 names <- names(envs)
[13:23:35.904]                 common <- intersect(names, old_names)
[13:23:35.904]                 added <- setdiff(names, old_names)
[13:23:35.904]                 removed <- setdiff(old_names, names)
[13:23:35.904]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:35.904]                   envs[common]]
[13:23:35.904]                 NAMES <- toupper(changed)
[13:23:35.904]                 args <- list()
[13:23:35.904]                 for (kk in seq_along(NAMES)) {
[13:23:35.904]                   name <- changed[[kk]]
[13:23:35.904]                   NAME <- NAMES[[kk]]
[13:23:35.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.904]                     next
[13:23:35.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:35.904]                 }
[13:23:35.904]                 NAMES <- toupper(added)
[13:23:35.904]                 for (kk in seq_along(NAMES)) {
[13:23:35.904]                   name <- added[[kk]]
[13:23:35.904]                   NAME <- NAMES[[kk]]
[13:23:35.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.904]                     next
[13:23:35.904]                   args[[name]] <- ""
[13:23:35.904]                 }
[13:23:35.904]                 NAMES <- toupper(removed)
[13:23:35.904]                 for (kk in seq_along(NAMES)) {
[13:23:35.904]                   name <- removed[[kk]]
[13:23:35.904]                   NAME <- NAMES[[kk]]
[13:23:35.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:35.904]                     next
[13:23:35.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:35.904]                 }
[13:23:35.904]                 if (length(args) > 0) 
[13:23:35.904]                   base::do.call(base::Sys.setenv, args = args)
[13:23:35.904]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:35.904]             }
[13:23:35.904]             else {
[13:23:35.904]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:35.904]             }
[13:23:35.904]             {
[13:23:35.904]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:35.904]                   0L) {
[13:23:35.904]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:35.904]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:35.904]                   base::options(opts)
[13:23:35.904]                 }
[13:23:35.904]                 {
[13:23:35.904]                   {
[13:23:35.904]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:35.904]                     NULL
[13:23:35.904]                   }
[13:23:35.904]                   options(future.plan = NULL)
[13:23:35.904]                   if (is.na(NA_character_)) 
[13:23:35.904]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:35.904]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:35.904]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:35.904]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:35.904]                     envir = parent.frame()) 
[13:23:35.904]                   {
[13:23:35.904]                     if (is.function(workers)) 
[13:23:35.904]                       workers <- workers()
[13:23:35.904]                     workers <- structure(as.integer(workers), 
[13:23:35.904]                       class = class(workers))
[13:23:35.904]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:35.904]                       workers >= 1)
[13:23:35.904]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:35.904]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:35.904]                     }
[13:23:35.904]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:35.904]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:35.904]                       envir = envir)
[13:23:35.904]                     if (!future$lazy) 
[13:23:35.904]                       future <- run(future)
[13:23:35.904]                     invisible(future)
[13:23:35.904]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:35.904]                 }
[13:23:35.904]             }
[13:23:35.904]         }
[13:23:35.904]     })
[13:23:35.904]     if (TRUE) {
[13:23:35.904]         base::sink(type = "output", split = FALSE)
[13:23:35.904]         if (TRUE) {
[13:23:35.904]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:35.904]         }
[13:23:35.904]         else {
[13:23:35.904]             ...future.result["stdout"] <- base::list(NULL)
[13:23:35.904]         }
[13:23:35.904]         base::close(...future.stdout)
[13:23:35.904]         ...future.stdout <- NULL
[13:23:35.904]     }
[13:23:35.904]     ...future.result$conditions <- ...future.conditions
[13:23:35.904]     ...future.result$finished <- base::Sys.time()
[13:23:35.904]     ...future.result
[13:23:35.904] }
[13:23:35.907] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[13:23:35.908] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[13:23:35.960] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[13:23:35.961] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[13:23:35.961] MultisessionFuture started
[13:23:35.961] - Launch lazy future ... done
[13:23:35.961] run() for ‘MultisessionFuture’ ... done
[13:23:35.962] result() for ClusterFuture ...
[13:23:35.962] receiveMessageFromWorker() for ClusterFuture ...
[13:23:35.962] - Validating connection of MultisessionFuture
[13:23:36.010] - received message: FutureResult
[13:23:36.010] - Received FutureResult
[13:23:36.010] - Erased future from FutureRegistry
[13:23:36.010] result() for ClusterFuture ...
[13:23:36.010] - result already collected: FutureResult
[13:23:36.010] result() for ClusterFuture ... done
[13:23:36.011] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:36.011] result() for ClusterFuture ... done
[13:23:36.011] result() for ClusterFuture ...
[13:23:36.011] - result already collected: FutureResult
[13:23:36.011] result() for ClusterFuture ... done
value(b) = 2
[13:23:36.011] result() for ClusterFuture ...
[13:23:36.011] - result already collected: FutureResult
[13:23:36.011] result() for ClusterFuture ... done
[13:23:36.011] result() for ClusterFuture ...
[13:23:36.011] - result already collected: FutureResult
[13:23:36.012] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:36.012] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:36.012] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:23:36.013] - globals found: [2] ‘{’, ‘pkg’
[13:23:36.013] Searching for globals ... DONE
[13:23:36.013] Resolving globals: TRUE
[13:23:36.013] Resolving any globals that are futures ...
[13:23:36.013] - globals: [2] ‘{’, ‘pkg’
[13:23:36.013] Resolving any globals that are futures ... DONE
[13:23:36.014] Resolving futures part of globals (recursively) ...
[13:23:36.014] resolve() on list ...
[13:23:36.014]  recursive: 99
[13:23:36.014]  length: 1
[13:23:36.014]  elements: ‘pkg’
[13:23:36.014]  length: 0 (resolved future 1)
[13:23:36.015] resolve() on list ... DONE
[13:23:36.015] - globals: [1] ‘pkg’
[13:23:36.015] Resolving futures part of globals (recursively) ... DONE
[13:23:36.015] The total size of the 1 globals is 112 bytes (112 bytes)
[13:23:36.015] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[13:23:36.015] - globals: [1] ‘pkg’
[13:23:36.015] 
[13:23:36.016] getGlobalsAndPackages() ... DONE
[13:23:36.016] Packages needed by the future expression (n = 0): <none>
[13:23:36.016] Packages needed by future strategies (n = 0): <none>
[13:23:36.016] {
[13:23:36.016]     {
[13:23:36.016]         {
[13:23:36.016]             ...future.startTime <- base::Sys.time()
[13:23:36.016]             {
[13:23:36.016]                 {
[13:23:36.016]                   {
[13:23:36.016]                     base::local({
[13:23:36.016]                       has_future <- base::requireNamespace("future", 
[13:23:36.016]                         quietly = TRUE)
[13:23:36.016]                       if (has_future) {
[13:23:36.016]                         ns <- base::getNamespace("future")
[13:23:36.016]                         version <- ns[[".package"]][["version"]]
[13:23:36.016]                         if (is.null(version)) 
[13:23:36.016]                           version <- utils::packageVersion("future")
[13:23:36.016]                       }
[13:23:36.016]                       else {
[13:23:36.016]                         version <- NULL
[13:23:36.016]                       }
[13:23:36.016]                       if (!has_future || version < "1.8.0") {
[13:23:36.016]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:36.016]                           "", base::R.version$version.string), 
[13:23:36.016]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:36.016]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:36.016]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:36.016]                             "release", "version")], collapse = " "), 
[13:23:36.016]                           hostname = base::Sys.info()[["nodename"]])
[13:23:36.016]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:36.016]                           info)
[13:23:36.016]                         info <- base::paste(info, collapse = "; ")
[13:23:36.016]                         if (!has_future) {
[13:23:36.016]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:36.016]                             info)
[13:23:36.016]                         }
[13:23:36.016]                         else {
[13:23:36.016]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:36.016]                             info, version)
[13:23:36.016]                         }
[13:23:36.016]                         base::stop(msg)
[13:23:36.016]                       }
[13:23:36.016]                     })
[13:23:36.016]                   }
[13:23:36.016]                   options(future.plan = NULL)
[13:23:36.016]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.016]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:36.016]                 }
[13:23:36.016]                 ...future.workdir <- getwd()
[13:23:36.016]             }
[13:23:36.016]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:36.016]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:36.016]         }
[13:23:36.016]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:36.016]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:23:36.016]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:36.016]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:36.016]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:36.016]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:36.016]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:36.016]             base::names(...future.oldOptions))
[13:23:36.016]     }
[13:23:36.016]     if (FALSE) {
[13:23:36.016]     }
[13:23:36.016]     else {
[13:23:36.016]         if (TRUE) {
[13:23:36.016]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:36.016]                 open = "w")
[13:23:36.016]         }
[13:23:36.016]         else {
[13:23:36.016]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:36.016]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:36.016]         }
[13:23:36.016]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:36.016]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:36.016]             base::sink(type = "output", split = FALSE)
[13:23:36.016]             base::close(...future.stdout)
[13:23:36.016]         }, add = TRUE)
[13:23:36.016]     }
[13:23:36.016]     ...future.frame <- base::sys.nframe()
[13:23:36.016]     ...future.conditions <- base::list()
[13:23:36.016]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:36.016]     if (FALSE) {
[13:23:36.016]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:36.016]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:36.016]     }
[13:23:36.016]     ...future.result <- base::tryCatch({
[13:23:36.016]         base::withCallingHandlers({
[13:23:36.016]             ...future.value <- base::withVisible(base::local({
[13:23:36.016]                 pkg
[13:23:36.016]             }))
[13:23:36.016]             future::FutureResult(value = ...future.value$value, 
[13:23:36.016]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.016]                   ...future.rng), globalenv = if (FALSE) 
[13:23:36.016]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:36.016]                     ...future.globalenv.names))
[13:23:36.016]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:36.016]         }, condition = base::local({
[13:23:36.016]             c <- base::c
[13:23:36.016]             inherits <- base::inherits
[13:23:36.016]             invokeRestart <- base::invokeRestart
[13:23:36.016]             length <- base::length
[13:23:36.016]             list <- base::list
[13:23:36.016]             seq.int <- base::seq.int
[13:23:36.016]             signalCondition <- base::signalCondition
[13:23:36.016]             sys.calls <- base::sys.calls
[13:23:36.016]             `[[` <- base::`[[`
[13:23:36.016]             `+` <- base::`+`
[13:23:36.016]             `<<-` <- base::`<<-`
[13:23:36.016]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:36.016]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:36.016]                   3L)]
[13:23:36.016]             }
[13:23:36.016]             function(cond) {
[13:23:36.016]                 is_error <- inherits(cond, "error")
[13:23:36.016]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:36.016]                   NULL)
[13:23:36.016]                 if (is_error) {
[13:23:36.016]                   sessionInformation <- function() {
[13:23:36.016]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:36.016]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:36.016]                       search = base::search(), system = base::Sys.info())
[13:23:36.016]                   }
[13:23:36.016]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.016]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:36.016]                     cond$call), session = sessionInformation(), 
[13:23:36.016]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:36.016]                   signalCondition(cond)
[13:23:36.016]                 }
[13:23:36.016]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:36.016]                 "immediateCondition"))) {
[13:23:36.016]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:36.016]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.016]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:36.016]                   if (TRUE && !signal) {
[13:23:36.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.016]                     {
[13:23:36.016]                       inherits <- base::inherits
[13:23:36.016]                       invokeRestart <- base::invokeRestart
[13:23:36.016]                       is.null <- base::is.null
[13:23:36.016]                       muffled <- FALSE
[13:23:36.016]                       if (inherits(cond, "message")) {
[13:23:36.016]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.016]                         if (muffled) 
[13:23:36.016]                           invokeRestart("muffleMessage")
[13:23:36.016]                       }
[13:23:36.016]                       else if (inherits(cond, "warning")) {
[13:23:36.016]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.016]                         if (muffled) 
[13:23:36.016]                           invokeRestart("muffleWarning")
[13:23:36.016]                       }
[13:23:36.016]                       else if (inherits(cond, "condition")) {
[13:23:36.016]                         if (!is.null(pattern)) {
[13:23:36.016]                           computeRestarts <- base::computeRestarts
[13:23:36.016]                           grepl <- base::grepl
[13:23:36.016]                           restarts <- computeRestarts(cond)
[13:23:36.016]                           for (restart in restarts) {
[13:23:36.016]                             name <- restart$name
[13:23:36.016]                             if (is.null(name)) 
[13:23:36.016]                               next
[13:23:36.016]                             if (!grepl(pattern, name)) 
[13:23:36.016]                               next
[13:23:36.016]                             invokeRestart(restart)
[13:23:36.016]                             muffled <- TRUE
[13:23:36.016]                             break
[13:23:36.016]                           }
[13:23:36.016]                         }
[13:23:36.016]                       }
[13:23:36.016]                       invisible(muffled)
[13:23:36.016]                     }
[13:23:36.016]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.016]                   }
[13:23:36.016]                 }
[13:23:36.016]                 else {
[13:23:36.016]                   if (TRUE) {
[13:23:36.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.016]                     {
[13:23:36.016]                       inherits <- base::inherits
[13:23:36.016]                       invokeRestart <- base::invokeRestart
[13:23:36.016]                       is.null <- base::is.null
[13:23:36.016]                       muffled <- FALSE
[13:23:36.016]                       if (inherits(cond, "message")) {
[13:23:36.016]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.016]                         if (muffled) 
[13:23:36.016]                           invokeRestart("muffleMessage")
[13:23:36.016]                       }
[13:23:36.016]                       else if (inherits(cond, "warning")) {
[13:23:36.016]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.016]                         if (muffled) 
[13:23:36.016]                           invokeRestart("muffleWarning")
[13:23:36.016]                       }
[13:23:36.016]                       else if (inherits(cond, "condition")) {
[13:23:36.016]                         if (!is.null(pattern)) {
[13:23:36.016]                           computeRestarts <- base::computeRestarts
[13:23:36.016]                           grepl <- base::grepl
[13:23:36.016]                           restarts <- computeRestarts(cond)
[13:23:36.016]                           for (restart in restarts) {
[13:23:36.016]                             name <- restart$name
[13:23:36.016]                             if (is.null(name)) 
[13:23:36.016]                               next
[13:23:36.016]                             if (!grepl(pattern, name)) 
[13:23:36.016]                               next
[13:23:36.016]                             invokeRestart(restart)
[13:23:36.016]                             muffled <- TRUE
[13:23:36.016]                             break
[13:23:36.016]                           }
[13:23:36.016]                         }
[13:23:36.016]                       }
[13:23:36.016]                       invisible(muffled)
[13:23:36.016]                     }
[13:23:36.016]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.016]                   }
[13:23:36.016]                 }
[13:23:36.016]             }
[13:23:36.016]         }))
[13:23:36.016]     }, error = function(ex) {
[13:23:36.016]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:36.016]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.016]                 ...future.rng), started = ...future.startTime, 
[13:23:36.016]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:36.016]             version = "1.8"), class = "FutureResult")
[13:23:36.016]     }, finally = {
[13:23:36.016]         if (!identical(...future.workdir, getwd())) 
[13:23:36.016]             setwd(...future.workdir)
[13:23:36.016]         {
[13:23:36.016]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:36.016]                 ...future.oldOptions$nwarnings <- NULL
[13:23:36.016]             }
[13:23:36.016]             base::options(...future.oldOptions)
[13:23:36.016]             if (.Platform$OS.type == "windows") {
[13:23:36.016]                 old_names <- names(...future.oldEnvVars)
[13:23:36.016]                 envs <- base::Sys.getenv()
[13:23:36.016]                 names <- names(envs)
[13:23:36.016]                 common <- intersect(names, old_names)
[13:23:36.016]                 added <- setdiff(names, old_names)
[13:23:36.016]                 removed <- setdiff(old_names, names)
[13:23:36.016]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:36.016]                   envs[common]]
[13:23:36.016]                 NAMES <- toupper(changed)
[13:23:36.016]                 args <- list()
[13:23:36.016]                 for (kk in seq_along(NAMES)) {
[13:23:36.016]                   name <- changed[[kk]]
[13:23:36.016]                   NAME <- NAMES[[kk]]
[13:23:36.016]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.016]                     next
[13:23:36.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.016]                 }
[13:23:36.016]                 NAMES <- toupper(added)
[13:23:36.016]                 for (kk in seq_along(NAMES)) {
[13:23:36.016]                   name <- added[[kk]]
[13:23:36.016]                   NAME <- NAMES[[kk]]
[13:23:36.016]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.016]                     next
[13:23:36.016]                   args[[name]] <- ""
[13:23:36.016]                 }
[13:23:36.016]                 NAMES <- toupper(removed)
[13:23:36.016]                 for (kk in seq_along(NAMES)) {
[13:23:36.016]                   name <- removed[[kk]]
[13:23:36.016]                   NAME <- NAMES[[kk]]
[13:23:36.016]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.016]                     next
[13:23:36.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.016]                 }
[13:23:36.016]                 if (length(args) > 0) 
[13:23:36.016]                   base::do.call(base::Sys.setenv, args = args)
[13:23:36.016]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:36.016]             }
[13:23:36.016]             else {
[13:23:36.016]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:36.016]             }
[13:23:36.016]             {
[13:23:36.016]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:36.016]                   0L) {
[13:23:36.016]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:36.016]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:36.016]                   base::options(opts)
[13:23:36.016]                 }
[13:23:36.016]                 {
[13:23:36.016]                   {
[13:23:36.016]                     NULL
[13:23:36.016]                     RNGkind("Mersenne-Twister")
[13:23:36.016]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:36.016]                       inherits = FALSE)
[13:23:36.016]                   }
[13:23:36.016]                   options(future.plan = NULL)
[13:23:36.016]                   if (is.na(NA_character_)) 
[13:23:36.016]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.016]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:36.016]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:36.016]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:36.016]                     envir = parent.frame()) 
[13:23:36.016]                   {
[13:23:36.016]                     if (is.function(workers)) 
[13:23:36.016]                       workers <- workers()
[13:23:36.016]                     workers <- structure(as.integer(workers), 
[13:23:36.016]                       class = class(workers))
[13:23:36.016]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:36.016]                       workers >= 1)
[13:23:36.016]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:36.016]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:36.016]                     }
[13:23:36.016]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:36.016]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:36.016]                       envir = envir)
[13:23:36.016]                     if (!future$lazy) 
[13:23:36.016]                       future <- run(future)
[13:23:36.016]                     invisible(future)
[13:23:36.016]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:36.016]                 }
[13:23:36.016]             }
[13:23:36.016]         }
[13:23:36.016]     })
[13:23:36.016]     if (TRUE) {
[13:23:36.016]         base::sink(type = "output", split = FALSE)
[13:23:36.016]         if (TRUE) {
[13:23:36.016]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:36.016]         }
[13:23:36.016]         else {
[13:23:36.016]             ...future.result["stdout"] <- base::list(NULL)
[13:23:36.016]         }
[13:23:36.016]         base::close(...future.stdout)
[13:23:36.016]         ...future.stdout <- NULL
[13:23:36.016]     }
[13:23:36.016]     ...future.result$conditions <- ...future.conditions
[13:23:36.016]     ...future.result$finished <- base::Sys.time()
[13:23:36.016]     ...future.result
[13:23:36.016] }
[13:23:36.018] assign_globals() ...
[13:23:36.018] List of 1
[13:23:36.018]  $ pkg: chr "foo"
[13:23:36.018]  - attr(*, "where")=List of 1
[13:23:36.018]   ..$ pkg:<environment: R_EmptyEnv> 
[13:23:36.018]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:36.018]  - attr(*, "resolved")= logi TRUE
[13:23:36.018]  - attr(*, "total_size")= num 112
[13:23:36.021] - copied ‘pkg’ to environment
[13:23:36.021] assign_globals() ... done
[13:23:36.021] plan(): Setting new future strategy stack:
[13:23:36.021] List of future strategies:
[13:23:36.021] 1. sequential:
[13:23:36.021]    - args: function (..., envir = parent.frame())
[13:23:36.021]    - tweaked: FALSE
[13:23:36.021]    - call: NULL
[13:23:36.021] plan(): nbrOfWorkers() = 1
[13:23:36.022] plan(): Setting new future strategy stack:
[13:23:36.022] List of future strategies:
[13:23:36.022] 1. multisession:
[13:23:36.022]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:23:36.022]    - tweaked: FALSE
[13:23:36.022]    - call: plan(strategy)
[13:23:36.026] plan(): nbrOfWorkers() = 2
[13:23:36.026] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:36.027] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:36.027] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:36.029] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:23:36.029] Searching for globals ... DONE
[13:23:36.030] Resolving globals: TRUE
[13:23:36.030] Resolving any globals that are futures ...
[13:23:36.030] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:23:36.030] Resolving any globals that are futures ... DONE
[13:23:36.030] Resolving futures part of globals (recursively) ...
[13:23:36.030] resolve() on list ...
[13:23:36.031]  recursive: 99
[13:23:36.031]  length: 1
[13:23:36.031]  elements: ‘a’
[13:23:36.031]  length: 0 (resolved future 1)
[13:23:36.031] resolve() on list ... DONE
[13:23:36.031] - globals: [1] ‘a’
[13:23:36.031] Resolving futures part of globals (recursively) ... DONE
[13:23:36.031] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:36.032] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:23:36.032] - globals: [1] ‘a’
[13:23:36.032] 
[13:23:36.032] getGlobalsAndPackages() ... DONE
[13:23:36.032] run() for ‘Future’ ...
[13:23:36.032] - state: ‘created’
[13:23:36.033] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:36.047] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:36.047] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:36.047]   - Field: ‘node’
[13:23:36.047]   - Field: ‘label’
[13:23:36.048]   - Field: ‘local’
[13:23:36.048]   - Field: ‘owner’
[13:23:36.048]   - Field: ‘envir’
[13:23:36.048]   - Field: ‘workers’
[13:23:36.048]   - Field: ‘packages’
[13:23:36.048]   - Field: ‘gc’
[13:23:36.048]   - Field: ‘conditions’
[13:23:36.048]   - Field: ‘persistent’
[13:23:36.048]   - Field: ‘expr’
[13:23:36.048]   - Field: ‘uuid’
[13:23:36.048]   - Field: ‘seed’
[13:23:36.049]   - Field: ‘version’
[13:23:36.049]   - Field: ‘result’
[13:23:36.049]   - Field: ‘asynchronous’
[13:23:36.049]   - Field: ‘calls’
[13:23:36.049]   - Field: ‘globals’
[13:23:36.049]   - Field: ‘stdout’
[13:23:36.049]   - Field: ‘earlySignal’
[13:23:36.049]   - Field: ‘lazy’
[13:23:36.049]   - Field: ‘state’
[13:23:36.049] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:36.050] - Launch lazy future ...
[13:23:36.050] Packages needed by the future expression (n = 0): <none>
[13:23:36.050] Packages needed by future strategies (n = 0): <none>
[13:23:36.050] {
[13:23:36.050]     {
[13:23:36.050]         {
[13:23:36.050]             ...future.startTime <- base::Sys.time()
[13:23:36.050]             {
[13:23:36.050]                 {
[13:23:36.050]                   {
[13:23:36.050]                     {
[13:23:36.050]                       base::local({
[13:23:36.050]                         has_future <- base::requireNamespace("future", 
[13:23:36.050]                           quietly = TRUE)
[13:23:36.050]                         if (has_future) {
[13:23:36.050]                           ns <- base::getNamespace("future")
[13:23:36.050]                           version <- ns[[".package"]][["version"]]
[13:23:36.050]                           if (is.null(version)) 
[13:23:36.050]                             version <- utils::packageVersion("future")
[13:23:36.050]                         }
[13:23:36.050]                         else {
[13:23:36.050]                           version <- NULL
[13:23:36.050]                         }
[13:23:36.050]                         if (!has_future || version < "1.8.0") {
[13:23:36.050]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:36.050]                             "", base::R.version$version.string), 
[13:23:36.050]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:36.050]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:36.050]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:36.050]                               "release", "version")], collapse = " "), 
[13:23:36.050]                             hostname = base::Sys.info()[["nodename"]])
[13:23:36.050]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:36.050]                             info)
[13:23:36.050]                           info <- base::paste(info, collapse = "; ")
[13:23:36.050]                           if (!has_future) {
[13:23:36.050]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:36.050]                               info)
[13:23:36.050]                           }
[13:23:36.050]                           else {
[13:23:36.050]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:36.050]                               info, version)
[13:23:36.050]                           }
[13:23:36.050]                           base::stop(msg)
[13:23:36.050]                         }
[13:23:36.050]                       })
[13:23:36.050]                     }
[13:23:36.050]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:36.050]                     base::options(mc.cores = 1L)
[13:23:36.050]                   }
[13:23:36.050]                   options(future.plan = NULL)
[13:23:36.050]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.050]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:36.050]                 }
[13:23:36.050]                 ...future.workdir <- getwd()
[13:23:36.050]             }
[13:23:36.050]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:36.050]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:36.050]         }
[13:23:36.050]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:36.050]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:36.050]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:36.050]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:36.050]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:36.050]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:36.050]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:36.050]             base::names(...future.oldOptions))
[13:23:36.050]     }
[13:23:36.050]     if (FALSE) {
[13:23:36.050]     }
[13:23:36.050]     else {
[13:23:36.050]         if (TRUE) {
[13:23:36.050]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:36.050]                 open = "w")
[13:23:36.050]         }
[13:23:36.050]         else {
[13:23:36.050]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:36.050]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:36.050]         }
[13:23:36.050]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:36.050]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:36.050]             base::sink(type = "output", split = FALSE)
[13:23:36.050]             base::close(...future.stdout)
[13:23:36.050]         }, add = TRUE)
[13:23:36.050]     }
[13:23:36.050]     ...future.frame <- base::sys.nframe()
[13:23:36.050]     ...future.conditions <- base::list()
[13:23:36.050]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:36.050]     if (FALSE) {
[13:23:36.050]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:36.050]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:36.050]     }
[13:23:36.050]     ...future.result <- base::tryCatch({
[13:23:36.050]         base::withCallingHandlers({
[13:23:36.050]             ...future.value <- base::withVisible(base::local({
[13:23:36.050]                 ...future.makeSendCondition <- base::local({
[13:23:36.050]                   sendCondition <- NULL
[13:23:36.050]                   function(frame = 1L) {
[13:23:36.050]                     if (is.function(sendCondition)) 
[13:23:36.050]                       return(sendCondition)
[13:23:36.050]                     ns <- getNamespace("parallel")
[13:23:36.050]                     if (exists("sendData", mode = "function", 
[13:23:36.050]                       envir = ns)) {
[13:23:36.050]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:36.050]                         envir = ns)
[13:23:36.050]                       envir <- sys.frame(frame)
[13:23:36.050]                       master <- NULL
[13:23:36.050]                       while (!identical(envir, .GlobalEnv) && 
[13:23:36.050]                         !identical(envir, emptyenv())) {
[13:23:36.050]                         if (exists("master", mode = "list", envir = envir, 
[13:23:36.050]                           inherits = FALSE)) {
[13:23:36.050]                           master <- get("master", mode = "list", 
[13:23:36.050]                             envir = envir, inherits = FALSE)
[13:23:36.050]                           if (inherits(master, c("SOCKnode", 
[13:23:36.050]                             "SOCK0node"))) {
[13:23:36.050]                             sendCondition <<- function(cond) {
[13:23:36.050]                               data <- list(type = "VALUE", value = cond, 
[13:23:36.050]                                 success = TRUE)
[13:23:36.050]                               parallel_sendData(master, data)
[13:23:36.050]                             }
[13:23:36.050]                             return(sendCondition)
[13:23:36.050]                           }
[13:23:36.050]                         }
[13:23:36.050]                         frame <- frame + 1L
[13:23:36.050]                         envir <- sys.frame(frame)
[13:23:36.050]                       }
[13:23:36.050]                     }
[13:23:36.050]                     sendCondition <<- function(cond) NULL
[13:23:36.050]                   }
[13:23:36.050]                 })
[13:23:36.050]                 withCallingHandlers({
[13:23:36.050]                   {
[13:23:36.050]                     b <- a
[13:23:36.050]                     a <- 2
[13:23:36.050]                     a * b
[13:23:36.050]                   }
[13:23:36.050]                 }, immediateCondition = function(cond) {
[13:23:36.050]                   sendCondition <- ...future.makeSendCondition()
[13:23:36.050]                   sendCondition(cond)
[13:23:36.050]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.050]                   {
[13:23:36.050]                     inherits <- base::inherits
[13:23:36.050]                     invokeRestart <- base::invokeRestart
[13:23:36.050]                     is.null <- base::is.null
[13:23:36.050]                     muffled <- FALSE
[13:23:36.050]                     if (inherits(cond, "message")) {
[13:23:36.050]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:36.050]                       if (muffled) 
[13:23:36.050]                         invokeRestart("muffleMessage")
[13:23:36.050]                     }
[13:23:36.050]                     else if (inherits(cond, "warning")) {
[13:23:36.050]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:36.050]                       if (muffled) 
[13:23:36.050]                         invokeRestart("muffleWarning")
[13:23:36.050]                     }
[13:23:36.050]                     else if (inherits(cond, "condition")) {
[13:23:36.050]                       if (!is.null(pattern)) {
[13:23:36.050]                         computeRestarts <- base::computeRestarts
[13:23:36.050]                         grepl <- base::grepl
[13:23:36.050]                         restarts <- computeRestarts(cond)
[13:23:36.050]                         for (restart in restarts) {
[13:23:36.050]                           name <- restart$name
[13:23:36.050]                           if (is.null(name)) 
[13:23:36.050]                             next
[13:23:36.050]                           if (!grepl(pattern, name)) 
[13:23:36.050]                             next
[13:23:36.050]                           invokeRestart(restart)
[13:23:36.050]                           muffled <- TRUE
[13:23:36.050]                           break
[13:23:36.050]                         }
[13:23:36.050]                       }
[13:23:36.050]                     }
[13:23:36.050]                     invisible(muffled)
[13:23:36.050]                   }
[13:23:36.050]                   muffleCondition(cond)
[13:23:36.050]                 })
[13:23:36.050]             }))
[13:23:36.050]             future::FutureResult(value = ...future.value$value, 
[13:23:36.050]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.050]                   ...future.rng), globalenv = if (FALSE) 
[13:23:36.050]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:36.050]                     ...future.globalenv.names))
[13:23:36.050]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:36.050]         }, condition = base::local({
[13:23:36.050]             c <- base::c
[13:23:36.050]             inherits <- base::inherits
[13:23:36.050]             invokeRestart <- base::invokeRestart
[13:23:36.050]             length <- base::length
[13:23:36.050]             list <- base::list
[13:23:36.050]             seq.int <- base::seq.int
[13:23:36.050]             signalCondition <- base::signalCondition
[13:23:36.050]             sys.calls <- base::sys.calls
[13:23:36.050]             `[[` <- base::`[[`
[13:23:36.050]             `+` <- base::`+`
[13:23:36.050]             `<<-` <- base::`<<-`
[13:23:36.050]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:36.050]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:36.050]                   3L)]
[13:23:36.050]             }
[13:23:36.050]             function(cond) {
[13:23:36.050]                 is_error <- inherits(cond, "error")
[13:23:36.050]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:36.050]                   NULL)
[13:23:36.050]                 if (is_error) {
[13:23:36.050]                   sessionInformation <- function() {
[13:23:36.050]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:36.050]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:36.050]                       search = base::search(), system = base::Sys.info())
[13:23:36.050]                   }
[13:23:36.050]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.050]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:36.050]                     cond$call), session = sessionInformation(), 
[13:23:36.050]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:36.050]                   signalCondition(cond)
[13:23:36.050]                 }
[13:23:36.050]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:36.050]                 "immediateCondition"))) {
[13:23:36.050]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:36.050]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.050]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:36.050]                   if (TRUE && !signal) {
[13:23:36.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.050]                     {
[13:23:36.050]                       inherits <- base::inherits
[13:23:36.050]                       invokeRestart <- base::invokeRestart
[13:23:36.050]                       is.null <- base::is.null
[13:23:36.050]                       muffled <- FALSE
[13:23:36.050]                       if (inherits(cond, "message")) {
[13:23:36.050]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.050]                         if (muffled) 
[13:23:36.050]                           invokeRestart("muffleMessage")
[13:23:36.050]                       }
[13:23:36.050]                       else if (inherits(cond, "warning")) {
[13:23:36.050]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.050]                         if (muffled) 
[13:23:36.050]                           invokeRestart("muffleWarning")
[13:23:36.050]                       }
[13:23:36.050]                       else if (inherits(cond, "condition")) {
[13:23:36.050]                         if (!is.null(pattern)) {
[13:23:36.050]                           computeRestarts <- base::computeRestarts
[13:23:36.050]                           grepl <- base::grepl
[13:23:36.050]                           restarts <- computeRestarts(cond)
[13:23:36.050]                           for (restart in restarts) {
[13:23:36.050]                             name <- restart$name
[13:23:36.050]                             if (is.null(name)) 
[13:23:36.050]                               next
[13:23:36.050]                             if (!grepl(pattern, name)) 
[13:23:36.050]                               next
[13:23:36.050]                             invokeRestart(restart)
[13:23:36.050]                             muffled <- TRUE
[13:23:36.050]                             break
[13:23:36.050]                           }
[13:23:36.050]                         }
[13:23:36.050]                       }
[13:23:36.050]                       invisible(muffled)
[13:23:36.050]                     }
[13:23:36.050]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.050]                   }
[13:23:36.050]                 }
[13:23:36.050]                 else {
[13:23:36.050]                   if (TRUE) {
[13:23:36.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.050]                     {
[13:23:36.050]                       inherits <- base::inherits
[13:23:36.050]                       invokeRestart <- base::invokeRestart
[13:23:36.050]                       is.null <- base::is.null
[13:23:36.050]                       muffled <- FALSE
[13:23:36.050]                       if (inherits(cond, "message")) {
[13:23:36.050]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.050]                         if (muffled) 
[13:23:36.050]                           invokeRestart("muffleMessage")
[13:23:36.050]                       }
[13:23:36.050]                       else if (inherits(cond, "warning")) {
[13:23:36.050]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.050]                         if (muffled) 
[13:23:36.050]                           invokeRestart("muffleWarning")
[13:23:36.050]                       }
[13:23:36.050]                       else if (inherits(cond, "condition")) {
[13:23:36.050]                         if (!is.null(pattern)) {
[13:23:36.050]                           computeRestarts <- base::computeRestarts
[13:23:36.050]                           grepl <- base::grepl
[13:23:36.050]                           restarts <- computeRestarts(cond)
[13:23:36.050]                           for (restart in restarts) {
[13:23:36.050]                             name <- restart$name
[13:23:36.050]                             if (is.null(name)) 
[13:23:36.050]                               next
[13:23:36.050]                             if (!grepl(pattern, name)) 
[13:23:36.050]                               next
[13:23:36.050]                             invokeRestart(restart)
[13:23:36.050]                             muffled <- TRUE
[13:23:36.050]                             break
[13:23:36.050]                           }
[13:23:36.050]                         }
[13:23:36.050]                       }
[13:23:36.050]                       invisible(muffled)
[13:23:36.050]                     }
[13:23:36.050]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.050]                   }
[13:23:36.050]                 }
[13:23:36.050]             }
[13:23:36.050]         }))
[13:23:36.050]     }, error = function(ex) {
[13:23:36.050]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:36.050]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.050]                 ...future.rng), started = ...future.startTime, 
[13:23:36.050]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:36.050]             version = "1.8"), class = "FutureResult")
[13:23:36.050]     }, finally = {
[13:23:36.050]         if (!identical(...future.workdir, getwd())) 
[13:23:36.050]             setwd(...future.workdir)
[13:23:36.050]         {
[13:23:36.050]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:36.050]                 ...future.oldOptions$nwarnings <- NULL
[13:23:36.050]             }
[13:23:36.050]             base::options(...future.oldOptions)
[13:23:36.050]             if (.Platform$OS.type == "windows") {
[13:23:36.050]                 old_names <- names(...future.oldEnvVars)
[13:23:36.050]                 envs <- base::Sys.getenv()
[13:23:36.050]                 names <- names(envs)
[13:23:36.050]                 common <- intersect(names, old_names)
[13:23:36.050]                 added <- setdiff(names, old_names)
[13:23:36.050]                 removed <- setdiff(old_names, names)
[13:23:36.050]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:36.050]                   envs[common]]
[13:23:36.050]                 NAMES <- toupper(changed)
[13:23:36.050]                 args <- list()
[13:23:36.050]                 for (kk in seq_along(NAMES)) {
[13:23:36.050]                   name <- changed[[kk]]
[13:23:36.050]                   NAME <- NAMES[[kk]]
[13:23:36.050]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.050]                     next
[13:23:36.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.050]                 }
[13:23:36.050]                 NAMES <- toupper(added)
[13:23:36.050]                 for (kk in seq_along(NAMES)) {
[13:23:36.050]                   name <- added[[kk]]
[13:23:36.050]                   NAME <- NAMES[[kk]]
[13:23:36.050]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.050]                     next
[13:23:36.050]                   args[[name]] <- ""
[13:23:36.050]                 }
[13:23:36.050]                 NAMES <- toupper(removed)
[13:23:36.050]                 for (kk in seq_along(NAMES)) {
[13:23:36.050]                   name <- removed[[kk]]
[13:23:36.050]                   NAME <- NAMES[[kk]]
[13:23:36.050]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.050]                     next
[13:23:36.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.050]                 }
[13:23:36.050]                 if (length(args) > 0) 
[13:23:36.050]                   base::do.call(base::Sys.setenv, args = args)
[13:23:36.050]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:36.050]             }
[13:23:36.050]             else {
[13:23:36.050]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:36.050]             }
[13:23:36.050]             {
[13:23:36.050]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:36.050]                   0L) {
[13:23:36.050]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:36.050]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:36.050]                   base::options(opts)
[13:23:36.050]                 }
[13:23:36.050]                 {
[13:23:36.050]                   {
[13:23:36.050]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:36.050]                     NULL
[13:23:36.050]                   }
[13:23:36.050]                   options(future.plan = NULL)
[13:23:36.050]                   if (is.na(NA_character_)) 
[13:23:36.050]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.050]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:36.050]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:36.050]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:36.050]                     envir = parent.frame()) 
[13:23:36.050]                   {
[13:23:36.050]                     if (is.function(workers)) 
[13:23:36.050]                       workers <- workers()
[13:23:36.050]                     workers <- structure(as.integer(workers), 
[13:23:36.050]                       class = class(workers))
[13:23:36.050]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:36.050]                       workers >= 1)
[13:23:36.050]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:36.050]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:36.050]                     }
[13:23:36.050]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:36.050]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:36.050]                       envir = envir)
[13:23:36.050]                     if (!future$lazy) 
[13:23:36.050]                       future <- run(future)
[13:23:36.050]                     invisible(future)
[13:23:36.050]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:36.050]                 }
[13:23:36.050]             }
[13:23:36.050]         }
[13:23:36.050]     })
[13:23:36.050]     if (TRUE) {
[13:23:36.050]         base::sink(type = "output", split = FALSE)
[13:23:36.050]         if (TRUE) {
[13:23:36.050]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:36.050]         }
[13:23:36.050]         else {
[13:23:36.050]             ...future.result["stdout"] <- base::list(NULL)
[13:23:36.050]         }
[13:23:36.050]         base::close(...future.stdout)
[13:23:36.050]         ...future.stdout <- NULL
[13:23:36.050]     }
[13:23:36.050]     ...future.result$conditions <- ...future.conditions
[13:23:36.050]     ...future.result$finished <- base::Sys.time()
[13:23:36.050]     ...future.result
[13:23:36.050] }
[13:23:36.053] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[13:23:36.054] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[13:23:36.054] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[13:23:36.054] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[13:23:36.055] MultisessionFuture started
[13:23:36.055] - Launch lazy future ... done
[13:23:36.055] run() for ‘MultisessionFuture’ ... done
[13:23:36.055] result() for ClusterFuture ...
[13:23:36.055] receiveMessageFromWorker() for ClusterFuture ...
[13:23:36.055] - Validating connection of MultisessionFuture
[13:23:36.102] - received message: FutureResult
[13:23:36.102] - Received FutureResult
[13:23:36.102] - Erased future from FutureRegistry
[13:23:36.102] result() for ClusterFuture ...
[13:23:36.102] - result already collected: FutureResult
[13:23:36.102] result() for ClusterFuture ... done
[13:23:36.102] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:36.103] result() for ClusterFuture ... done
[13:23:36.103] result() for ClusterFuture ...
[13:23:36.103] - result already collected: FutureResult
[13:23:36.103] result() for ClusterFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:36.103] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:36.104] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:36.106] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:23:36.106] Searching for globals ... DONE
[13:23:36.106] Resolving globals: TRUE
[13:23:36.106] Resolving any globals that are futures ...
[13:23:36.106] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:23:36.106] Resolving any globals that are futures ... DONE
[13:23:36.107] Resolving futures part of globals (recursively) ...
[13:23:36.107] resolve() on list ...
[13:23:36.107]  recursive: 99
[13:23:36.107]  length: 1
[13:23:36.107]  elements: ‘a’
[13:23:36.107]  length: 0 (resolved future 1)
[13:23:36.107] resolve() on list ... DONE
[13:23:36.107] - globals: [1] ‘a’
[13:23:36.107] Resolving futures part of globals (recursively) ... DONE
[13:23:36.108] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:36.108] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:23:36.108] - globals: [1] ‘a’
[13:23:36.108] 
[13:23:36.108] getGlobalsAndPackages() ... DONE
[13:23:36.109] run() for ‘Future’ ...
[13:23:36.109] - state: ‘created’
[13:23:36.109] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:36.123] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:36.124] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:36.124]   - Field: ‘node’
[13:23:36.124]   - Field: ‘label’
[13:23:36.124]   - Field: ‘local’
[13:23:36.124]   - Field: ‘owner’
[13:23:36.124]   - Field: ‘envir’
[13:23:36.124]   - Field: ‘workers’
[13:23:36.124]   - Field: ‘packages’
[13:23:36.124]   - Field: ‘gc’
[13:23:36.124]   - Field: ‘conditions’
[13:23:36.125]   - Field: ‘persistent’
[13:23:36.125]   - Field: ‘expr’
[13:23:36.125]   - Field: ‘uuid’
[13:23:36.125]   - Field: ‘seed’
[13:23:36.125]   - Field: ‘version’
[13:23:36.125]   - Field: ‘result’
[13:23:36.125]   - Field: ‘asynchronous’
[13:23:36.125]   - Field: ‘calls’
[13:23:36.125]   - Field: ‘globals’
[13:23:36.125]   - Field: ‘stdout’
[13:23:36.125]   - Field: ‘earlySignal’
[13:23:36.126]   - Field: ‘lazy’
[13:23:36.126]   - Field: ‘state’
[13:23:36.126] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:36.126] - Launch lazy future ...
[13:23:36.126] Packages needed by the future expression (n = 0): <none>
[13:23:36.126] Packages needed by future strategies (n = 0): <none>
[13:23:36.127] {
[13:23:36.127]     {
[13:23:36.127]         {
[13:23:36.127]             ...future.startTime <- base::Sys.time()
[13:23:36.127]             {
[13:23:36.127]                 {
[13:23:36.127]                   {
[13:23:36.127]                     {
[13:23:36.127]                       base::local({
[13:23:36.127]                         has_future <- base::requireNamespace("future", 
[13:23:36.127]                           quietly = TRUE)
[13:23:36.127]                         if (has_future) {
[13:23:36.127]                           ns <- base::getNamespace("future")
[13:23:36.127]                           version <- ns[[".package"]][["version"]]
[13:23:36.127]                           if (is.null(version)) 
[13:23:36.127]                             version <- utils::packageVersion("future")
[13:23:36.127]                         }
[13:23:36.127]                         else {
[13:23:36.127]                           version <- NULL
[13:23:36.127]                         }
[13:23:36.127]                         if (!has_future || version < "1.8.0") {
[13:23:36.127]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:36.127]                             "", base::R.version$version.string), 
[13:23:36.127]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:36.127]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:36.127]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:36.127]                               "release", "version")], collapse = " "), 
[13:23:36.127]                             hostname = base::Sys.info()[["nodename"]])
[13:23:36.127]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:36.127]                             info)
[13:23:36.127]                           info <- base::paste(info, collapse = "; ")
[13:23:36.127]                           if (!has_future) {
[13:23:36.127]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:36.127]                               info)
[13:23:36.127]                           }
[13:23:36.127]                           else {
[13:23:36.127]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:36.127]                               info, version)
[13:23:36.127]                           }
[13:23:36.127]                           base::stop(msg)
[13:23:36.127]                         }
[13:23:36.127]                       })
[13:23:36.127]                     }
[13:23:36.127]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:36.127]                     base::options(mc.cores = 1L)
[13:23:36.127]                   }
[13:23:36.127]                   options(future.plan = NULL)
[13:23:36.127]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.127]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:36.127]                 }
[13:23:36.127]                 ...future.workdir <- getwd()
[13:23:36.127]             }
[13:23:36.127]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:36.127]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:36.127]         }
[13:23:36.127]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:36.127]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:36.127]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:36.127]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:36.127]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:36.127]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:36.127]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:36.127]             base::names(...future.oldOptions))
[13:23:36.127]     }
[13:23:36.127]     if (FALSE) {
[13:23:36.127]     }
[13:23:36.127]     else {
[13:23:36.127]         if (TRUE) {
[13:23:36.127]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:36.127]                 open = "w")
[13:23:36.127]         }
[13:23:36.127]         else {
[13:23:36.127]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:36.127]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:36.127]         }
[13:23:36.127]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:36.127]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:36.127]             base::sink(type = "output", split = FALSE)
[13:23:36.127]             base::close(...future.stdout)
[13:23:36.127]         }, add = TRUE)
[13:23:36.127]     }
[13:23:36.127]     ...future.frame <- base::sys.nframe()
[13:23:36.127]     ...future.conditions <- base::list()
[13:23:36.127]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:36.127]     if (FALSE) {
[13:23:36.127]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:36.127]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:36.127]     }
[13:23:36.127]     ...future.result <- base::tryCatch({
[13:23:36.127]         base::withCallingHandlers({
[13:23:36.127]             ...future.value <- base::withVisible(base::local({
[13:23:36.127]                 ...future.makeSendCondition <- base::local({
[13:23:36.127]                   sendCondition <- NULL
[13:23:36.127]                   function(frame = 1L) {
[13:23:36.127]                     if (is.function(sendCondition)) 
[13:23:36.127]                       return(sendCondition)
[13:23:36.127]                     ns <- getNamespace("parallel")
[13:23:36.127]                     if (exists("sendData", mode = "function", 
[13:23:36.127]                       envir = ns)) {
[13:23:36.127]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:36.127]                         envir = ns)
[13:23:36.127]                       envir <- sys.frame(frame)
[13:23:36.127]                       master <- NULL
[13:23:36.127]                       while (!identical(envir, .GlobalEnv) && 
[13:23:36.127]                         !identical(envir, emptyenv())) {
[13:23:36.127]                         if (exists("master", mode = "list", envir = envir, 
[13:23:36.127]                           inherits = FALSE)) {
[13:23:36.127]                           master <- get("master", mode = "list", 
[13:23:36.127]                             envir = envir, inherits = FALSE)
[13:23:36.127]                           if (inherits(master, c("SOCKnode", 
[13:23:36.127]                             "SOCK0node"))) {
[13:23:36.127]                             sendCondition <<- function(cond) {
[13:23:36.127]                               data <- list(type = "VALUE", value = cond, 
[13:23:36.127]                                 success = TRUE)
[13:23:36.127]                               parallel_sendData(master, data)
[13:23:36.127]                             }
[13:23:36.127]                             return(sendCondition)
[13:23:36.127]                           }
[13:23:36.127]                         }
[13:23:36.127]                         frame <- frame + 1L
[13:23:36.127]                         envir <- sys.frame(frame)
[13:23:36.127]                       }
[13:23:36.127]                     }
[13:23:36.127]                     sendCondition <<- function(cond) NULL
[13:23:36.127]                   }
[13:23:36.127]                 })
[13:23:36.127]                 withCallingHandlers({
[13:23:36.127]                   {
[13:23:36.127]                     b <- a
[13:23:36.127]                     a <- 2
[13:23:36.127]                     a * b
[13:23:36.127]                   }
[13:23:36.127]                 }, immediateCondition = function(cond) {
[13:23:36.127]                   sendCondition <- ...future.makeSendCondition()
[13:23:36.127]                   sendCondition(cond)
[13:23:36.127]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.127]                   {
[13:23:36.127]                     inherits <- base::inherits
[13:23:36.127]                     invokeRestart <- base::invokeRestart
[13:23:36.127]                     is.null <- base::is.null
[13:23:36.127]                     muffled <- FALSE
[13:23:36.127]                     if (inherits(cond, "message")) {
[13:23:36.127]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:36.127]                       if (muffled) 
[13:23:36.127]                         invokeRestart("muffleMessage")
[13:23:36.127]                     }
[13:23:36.127]                     else if (inherits(cond, "warning")) {
[13:23:36.127]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:36.127]                       if (muffled) 
[13:23:36.127]                         invokeRestart("muffleWarning")
[13:23:36.127]                     }
[13:23:36.127]                     else if (inherits(cond, "condition")) {
[13:23:36.127]                       if (!is.null(pattern)) {
[13:23:36.127]                         computeRestarts <- base::computeRestarts
[13:23:36.127]                         grepl <- base::grepl
[13:23:36.127]                         restarts <- computeRestarts(cond)
[13:23:36.127]                         for (restart in restarts) {
[13:23:36.127]                           name <- restart$name
[13:23:36.127]                           if (is.null(name)) 
[13:23:36.127]                             next
[13:23:36.127]                           if (!grepl(pattern, name)) 
[13:23:36.127]                             next
[13:23:36.127]                           invokeRestart(restart)
[13:23:36.127]                           muffled <- TRUE
[13:23:36.127]                           break
[13:23:36.127]                         }
[13:23:36.127]                       }
[13:23:36.127]                     }
[13:23:36.127]                     invisible(muffled)
[13:23:36.127]                   }
[13:23:36.127]                   muffleCondition(cond)
[13:23:36.127]                 })
[13:23:36.127]             }))
[13:23:36.127]             future::FutureResult(value = ...future.value$value, 
[13:23:36.127]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.127]                   ...future.rng), globalenv = if (FALSE) 
[13:23:36.127]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:36.127]                     ...future.globalenv.names))
[13:23:36.127]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:36.127]         }, condition = base::local({
[13:23:36.127]             c <- base::c
[13:23:36.127]             inherits <- base::inherits
[13:23:36.127]             invokeRestart <- base::invokeRestart
[13:23:36.127]             length <- base::length
[13:23:36.127]             list <- base::list
[13:23:36.127]             seq.int <- base::seq.int
[13:23:36.127]             signalCondition <- base::signalCondition
[13:23:36.127]             sys.calls <- base::sys.calls
[13:23:36.127]             `[[` <- base::`[[`
[13:23:36.127]             `+` <- base::`+`
[13:23:36.127]             `<<-` <- base::`<<-`
[13:23:36.127]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:36.127]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:36.127]                   3L)]
[13:23:36.127]             }
[13:23:36.127]             function(cond) {
[13:23:36.127]                 is_error <- inherits(cond, "error")
[13:23:36.127]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:36.127]                   NULL)
[13:23:36.127]                 if (is_error) {
[13:23:36.127]                   sessionInformation <- function() {
[13:23:36.127]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:36.127]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:36.127]                       search = base::search(), system = base::Sys.info())
[13:23:36.127]                   }
[13:23:36.127]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.127]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:36.127]                     cond$call), session = sessionInformation(), 
[13:23:36.127]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:36.127]                   signalCondition(cond)
[13:23:36.127]                 }
[13:23:36.127]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:36.127]                 "immediateCondition"))) {
[13:23:36.127]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:36.127]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.127]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:36.127]                   if (TRUE && !signal) {
[13:23:36.127]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.127]                     {
[13:23:36.127]                       inherits <- base::inherits
[13:23:36.127]                       invokeRestart <- base::invokeRestart
[13:23:36.127]                       is.null <- base::is.null
[13:23:36.127]                       muffled <- FALSE
[13:23:36.127]                       if (inherits(cond, "message")) {
[13:23:36.127]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.127]                         if (muffled) 
[13:23:36.127]                           invokeRestart("muffleMessage")
[13:23:36.127]                       }
[13:23:36.127]                       else if (inherits(cond, "warning")) {
[13:23:36.127]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.127]                         if (muffled) 
[13:23:36.127]                           invokeRestart("muffleWarning")
[13:23:36.127]                       }
[13:23:36.127]                       else if (inherits(cond, "condition")) {
[13:23:36.127]                         if (!is.null(pattern)) {
[13:23:36.127]                           computeRestarts <- base::computeRestarts
[13:23:36.127]                           grepl <- base::grepl
[13:23:36.127]                           restarts <- computeRestarts(cond)
[13:23:36.127]                           for (restart in restarts) {
[13:23:36.127]                             name <- restart$name
[13:23:36.127]                             if (is.null(name)) 
[13:23:36.127]                               next
[13:23:36.127]                             if (!grepl(pattern, name)) 
[13:23:36.127]                               next
[13:23:36.127]                             invokeRestart(restart)
[13:23:36.127]                             muffled <- TRUE
[13:23:36.127]                             break
[13:23:36.127]                           }
[13:23:36.127]                         }
[13:23:36.127]                       }
[13:23:36.127]                       invisible(muffled)
[13:23:36.127]                     }
[13:23:36.127]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.127]                   }
[13:23:36.127]                 }
[13:23:36.127]                 else {
[13:23:36.127]                   if (TRUE) {
[13:23:36.127]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.127]                     {
[13:23:36.127]                       inherits <- base::inherits
[13:23:36.127]                       invokeRestart <- base::invokeRestart
[13:23:36.127]                       is.null <- base::is.null
[13:23:36.127]                       muffled <- FALSE
[13:23:36.127]                       if (inherits(cond, "message")) {
[13:23:36.127]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.127]                         if (muffled) 
[13:23:36.127]                           invokeRestart("muffleMessage")
[13:23:36.127]                       }
[13:23:36.127]                       else if (inherits(cond, "warning")) {
[13:23:36.127]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.127]                         if (muffled) 
[13:23:36.127]                           invokeRestart("muffleWarning")
[13:23:36.127]                       }
[13:23:36.127]                       else if (inherits(cond, "condition")) {
[13:23:36.127]                         if (!is.null(pattern)) {
[13:23:36.127]                           computeRestarts <- base::computeRestarts
[13:23:36.127]                           grepl <- base::grepl
[13:23:36.127]                           restarts <- computeRestarts(cond)
[13:23:36.127]                           for (restart in restarts) {
[13:23:36.127]                             name <- restart$name
[13:23:36.127]                             if (is.null(name)) 
[13:23:36.127]                               next
[13:23:36.127]                             if (!grepl(pattern, name)) 
[13:23:36.127]                               next
[13:23:36.127]                             invokeRestart(restart)
[13:23:36.127]                             muffled <- TRUE
[13:23:36.127]                             break
[13:23:36.127]                           }
[13:23:36.127]                         }
[13:23:36.127]                       }
[13:23:36.127]                       invisible(muffled)
[13:23:36.127]                     }
[13:23:36.127]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.127]                   }
[13:23:36.127]                 }
[13:23:36.127]             }
[13:23:36.127]         }))
[13:23:36.127]     }, error = function(ex) {
[13:23:36.127]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:36.127]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.127]                 ...future.rng), started = ...future.startTime, 
[13:23:36.127]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:36.127]             version = "1.8"), class = "FutureResult")
[13:23:36.127]     }, finally = {
[13:23:36.127]         if (!identical(...future.workdir, getwd())) 
[13:23:36.127]             setwd(...future.workdir)
[13:23:36.127]         {
[13:23:36.127]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:36.127]                 ...future.oldOptions$nwarnings <- NULL
[13:23:36.127]             }
[13:23:36.127]             base::options(...future.oldOptions)
[13:23:36.127]             if (.Platform$OS.type == "windows") {
[13:23:36.127]                 old_names <- names(...future.oldEnvVars)
[13:23:36.127]                 envs <- base::Sys.getenv()
[13:23:36.127]                 names <- names(envs)
[13:23:36.127]                 common <- intersect(names, old_names)
[13:23:36.127]                 added <- setdiff(names, old_names)
[13:23:36.127]                 removed <- setdiff(old_names, names)
[13:23:36.127]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:36.127]                   envs[common]]
[13:23:36.127]                 NAMES <- toupper(changed)
[13:23:36.127]                 args <- list()
[13:23:36.127]                 for (kk in seq_along(NAMES)) {
[13:23:36.127]                   name <- changed[[kk]]
[13:23:36.127]                   NAME <- NAMES[[kk]]
[13:23:36.127]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.127]                     next
[13:23:36.127]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.127]                 }
[13:23:36.127]                 NAMES <- toupper(added)
[13:23:36.127]                 for (kk in seq_along(NAMES)) {
[13:23:36.127]                   name <- added[[kk]]
[13:23:36.127]                   NAME <- NAMES[[kk]]
[13:23:36.127]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.127]                     next
[13:23:36.127]                   args[[name]] <- ""
[13:23:36.127]                 }
[13:23:36.127]                 NAMES <- toupper(removed)
[13:23:36.127]                 for (kk in seq_along(NAMES)) {
[13:23:36.127]                   name <- removed[[kk]]
[13:23:36.127]                   NAME <- NAMES[[kk]]
[13:23:36.127]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.127]                     next
[13:23:36.127]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.127]                 }
[13:23:36.127]                 if (length(args) > 0) 
[13:23:36.127]                   base::do.call(base::Sys.setenv, args = args)
[13:23:36.127]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:36.127]             }
[13:23:36.127]             else {
[13:23:36.127]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:36.127]             }
[13:23:36.127]             {
[13:23:36.127]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:36.127]                   0L) {
[13:23:36.127]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:36.127]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:36.127]                   base::options(opts)
[13:23:36.127]                 }
[13:23:36.127]                 {
[13:23:36.127]                   {
[13:23:36.127]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:36.127]                     NULL
[13:23:36.127]                   }
[13:23:36.127]                   options(future.plan = NULL)
[13:23:36.127]                   if (is.na(NA_character_)) 
[13:23:36.127]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.127]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:36.127]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:36.127]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:36.127]                     envir = parent.frame()) 
[13:23:36.127]                   {
[13:23:36.127]                     if (is.function(workers)) 
[13:23:36.127]                       workers <- workers()
[13:23:36.127]                     workers <- structure(as.integer(workers), 
[13:23:36.127]                       class = class(workers))
[13:23:36.127]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:36.127]                       workers >= 1)
[13:23:36.127]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:36.127]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:36.127]                     }
[13:23:36.127]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:36.127]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:36.127]                       envir = envir)
[13:23:36.127]                     if (!future$lazy) 
[13:23:36.127]                       future <- run(future)
[13:23:36.127]                     invisible(future)
[13:23:36.127]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:36.127]                 }
[13:23:36.127]             }
[13:23:36.127]         }
[13:23:36.127]     })
[13:23:36.127]     if (TRUE) {
[13:23:36.127]         base::sink(type = "output", split = FALSE)
[13:23:36.127]         if (TRUE) {
[13:23:36.127]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:36.127]         }
[13:23:36.127]         else {
[13:23:36.127]             ...future.result["stdout"] <- base::list(NULL)
[13:23:36.127]         }
[13:23:36.127]         base::close(...future.stdout)
[13:23:36.127]         ...future.stdout <- NULL
[13:23:36.127]     }
[13:23:36.127]     ...future.result$conditions <- ...future.conditions
[13:23:36.127]     ...future.result$finished <- base::Sys.time()
[13:23:36.127]     ...future.result
[13:23:36.127] }
[13:23:36.130] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[13:23:36.130] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[13:23:36.130] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[13:23:36.130] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[13:23:36.131] MultisessionFuture started
[13:23:36.131] - Launch lazy future ... done
[13:23:36.131] run() for ‘MultisessionFuture’ ... done
[13:23:36.131] result() for ClusterFuture ...
[13:23:36.131] receiveMessageFromWorker() for ClusterFuture ...
[13:23:36.131] - Validating connection of MultisessionFuture
[13:23:36.178] - received message: FutureResult
[13:23:36.178] - Received FutureResult
[13:23:36.178] - Erased future from FutureRegistry
[13:23:36.178] result() for ClusterFuture ...
[13:23:36.178] - result already collected: FutureResult
[13:23:36.178] result() for ClusterFuture ... done
[13:23:36.179] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:36.179] result() for ClusterFuture ... done
[13:23:36.179] result() for ClusterFuture ...
[13:23:36.179] - result already collected: FutureResult
[13:23:36.179] result() for ClusterFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:36.180] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:36.180] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:36.182] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:36.182] Searching for globals ... DONE
[13:23:36.182] Resolving globals: TRUE
[13:23:36.182] Resolving any globals that are futures ...
[13:23:36.182] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:36.182] Resolving any globals that are futures ... DONE
[13:23:36.183] Resolving futures part of globals (recursively) ...
[13:23:36.183] resolve() on list ...
[13:23:36.183]  recursive: 99
[13:23:36.183]  length: 2
[13:23:36.183]  elements: ‘a’, ‘ii’
[13:23:36.183]  length: 1 (resolved future 1)
[13:23:36.184]  length: 0 (resolved future 2)
[13:23:36.184] resolve() on list ... DONE
[13:23:36.184] - globals: [2] ‘a’, ‘ii’
[13:23:36.184] Resolving futures part of globals (recursively) ... DONE
[13:23:36.184] The total size of the 2 globals is 112 bytes (112 bytes)
[13:23:36.187] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:23:36.187] - globals: [2] ‘a’, ‘ii’
[13:23:36.187] 
[13:23:36.187] getGlobalsAndPackages() ... DONE
[13:23:36.188] run() for ‘Future’ ...
[13:23:36.188] - state: ‘created’
[13:23:36.188] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:36.203] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:36.203] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:36.204]   - Field: ‘node’
[13:23:36.204]   - Field: ‘label’
[13:23:36.204]   - Field: ‘local’
[13:23:36.204]   - Field: ‘owner’
[13:23:36.204]   - Field: ‘envir’
[13:23:36.204]   - Field: ‘workers’
[13:23:36.204]   - Field: ‘packages’
[13:23:36.204]   - Field: ‘gc’
[13:23:36.204]   - Field: ‘conditions’
[13:23:36.205]   - Field: ‘persistent’
[13:23:36.205]   - Field: ‘expr’
[13:23:36.205]   - Field: ‘uuid’
[13:23:36.205]   - Field: ‘seed’
[13:23:36.205]   - Field: ‘version’
[13:23:36.205]   - Field: ‘result’
[13:23:36.205]   - Field: ‘asynchronous’
[13:23:36.205]   - Field: ‘calls’
[13:23:36.205]   - Field: ‘globals’
[13:23:36.205]   - Field: ‘stdout’
[13:23:36.205]   - Field: ‘earlySignal’
[13:23:36.206]   - Field: ‘lazy’
[13:23:36.206]   - Field: ‘state’
[13:23:36.206] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:36.206] - Launch lazy future ...
[13:23:36.206] Packages needed by the future expression (n = 0): <none>
[13:23:36.206] Packages needed by future strategies (n = 0): <none>
[13:23:36.207] {
[13:23:36.207]     {
[13:23:36.207]         {
[13:23:36.207]             ...future.startTime <- base::Sys.time()
[13:23:36.207]             {
[13:23:36.207]                 {
[13:23:36.207]                   {
[13:23:36.207]                     {
[13:23:36.207]                       base::local({
[13:23:36.207]                         has_future <- base::requireNamespace("future", 
[13:23:36.207]                           quietly = TRUE)
[13:23:36.207]                         if (has_future) {
[13:23:36.207]                           ns <- base::getNamespace("future")
[13:23:36.207]                           version <- ns[[".package"]][["version"]]
[13:23:36.207]                           if (is.null(version)) 
[13:23:36.207]                             version <- utils::packageVersion("future")
[13:23:36.207]                         }
[13:23:36.207]                         else {
[13:23:36.207]                           version <- NULL
[13:23:36.207]                         }
[13:23:36.207]                         if (!has_future || version < "1.8.0") {
[13:23:36.207]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:36.207]                             "", base::R.version$version.string), 
[13:23:36.207]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:36.207]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:36.207]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:36.207]                               "release", "version")], collapse = " "), 
[13:23:36.207]                             hostname = base::Sys.info()[["nodename"]])
[13:23:36.207]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:36.207]                             info)
[13:23:36.207]                           info <- base::paste(info, collapse = "; ")
[13:23:36.207]                           if (!has_future) {
[13:23:36.207]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:36.207]                               info)
[13:23:36.207]                           }
[13:23:36.207]                           else {
[13:23:36.207]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:36.207]                               info, version)
[13:23:36.207]                           }
[13:23:36.207]                           base::stop(msg)
[13:23:36.207]                         }
[13:23:36.207]                       })
[13:23:36.207]                     }
[13:23:36.207]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:36.207]                     base::options(mc.cores = 1L)
[13:23:36.207]                   }
[13:23:36.207]                   options(future.plan = NULL)
[13:23:36.207]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.207]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:36.207]                 }
[13:23:36.207]                 ...future.workdir <- getwd()
[13:23:36.207]             }
[13:23:36.207]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:36.207]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:36.207]         }
[13:23:36.207]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:36.207]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:36.207]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:36.207]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:36.207]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:36.207]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:36.207]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:36.207]             base::names(...future.oldOptions))
[13:23:36.207]     }
[13:23:36.207]     if (FALSE) {
[13:23:36.207]     }
[13:23:36.207]     else {
[13:23:36.207]         if (TRUE) {
[13:23:36.207]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:36.207]                 open = "w")
[13:23:36.207]         }
[13:23:36.207]         else {
[13:23:36.207]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:36.207]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:36.207]         }
[13:23:36.207]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:36.207]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:36.207]             base::sink(type = "output", split = FALSE)
[13:23:36.207]             base::close(...future.stdout)
[13:23:36.207]         }, add = TRUE)
[13:23:36.207]     }
[13:23:36.207]     ...future.frame <- base::sys.nframe()
[13:23:36.207]     ...future.conditions <- base::list()
[13:23:36.207]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:36.207]     if (FALSE) {
[13:23:36.207]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:36.207]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:36.207]     }
[13:23:36.207]     ...future.result <- base::tryCatch({
[13:23:36.207]         base::withCallingHandlers({
[13:23:36.207]             ...future.value <- base::withVisible(base::local({
[13:23:36.207]                 ...future.makeSendCondition <- base::local({
[13:23:36.207]                   sendCondition <- NULL
[13:23:36.207]                   function(frame = 1L) {
[13:23:36.207]                     if (is.function(sendCondition)) 
[13:23:36.207]                       return(sendCondition)
[13:23:36.207]                     ns <- getNamespace("parallel")
[13:23:36.207]                     if (exists("sendData", mode = "function", 
[13:23:36.207]                       envir = ns)) {
[13:23:36.207]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:36.207]                         envir = ns)
[13:23:36.207]                       envir <- sys.frame(frame)
[13:23:36.207]                       master <- NULL
[13:23:36.207]                       while (!identical(envir, .GlobalEnv) && 
[13:23:36.207]                         !identical(envir, emptyenv())) {
[13:23:36.207]                         if (exists("master", mode = "list", envir = envir, 
[13:23:36.207]                           inherits = FALSE)) {
[13:23:36.207]                           master <- get("master", mode = "list", 
[13:23:36.207]                             envir = envir, inherits = FALSE)
[13:23:36.207]                           if (inherits(master, c("SOCKnode", 
[13:23:36.207]                             "SOCK0node"))) {
[13:23:36.207]                             sendCondition <<- function(cond) {
[13:23:36.207]                               data <- list(type = "VALUE", value = cond, 
[13:23:36.207]                                 success = TRUE)
[13:23:36.207]                               parallel_sendData(master, data)
[13:23:36.207]                             }
[13:23:36.207]                             return(sendCondition)
[13:23:36.207]                           }
[13:23:36.207]                         }
[13:23:36.207]                         frame <- frame + 1L
[13:23:36.207]                         envir <- sys.frame(frame)
[13:23:36.207]                       }
[13:23:36.207]                     }
[13:23:36.207]                     sendCondition <<- function(cond) NULL
[13:23:36.207]                   }
[13:23:36.207]                 })
[13:23:36.207]                 withCallingHandlers({
[13:23:36.207]                   {
[13:23:36.207]                     b <- a * ii
[13:23:36.207]                     a <- 0
[13:23:36.207]                     b
[13:23:36.207]                   }
[13:23:36.207]                 }, immediateCondition = function(cond) {
[13:23:36.207]                   sendCondition <- ...future.makeSendCondition()
[13:23:36.207]                   sendCondition(cond)
[13:23:36.207]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.207]                   {
[13:23:36.207]                     inherits <- base::inherits
[13:23:36.207]                     invokeRestart <- base::invokeRestart
[13:23:36.207]                     is.null <- base::is.null
[13:23:36.207]                     muffled <- FALSE
[13:23:36.207]                     if (inherits(cond, "message")) {
[13:23:36.207]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:36.207]                       if (muffled) 
[13:23:36.207]                         invokeRestart("muffleMessage")
[13:23:36.207]                     }
[13:23:36.207]                     else if (inherits(cond, "warning")) {
[13:23:36.207]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:36.207]                       if (muffled) 
[13:23:36.207]                         invokeRestart("muffleWarning")
[13:23:36.207]                     }
[13:23:36.207]                     else if (inherits(cond, "condition")) {
[13:23:36.207]                       if (!is.null(pattern)) {
[13:23:36.207]                         computeRestarts <- base::computeRestarts
[13:23:36.207]                         grepl <- base::grepl
[13:23:36.207]                         restarts <- computeRestarts(cond)
[13:23:36.207]                         for (restart in restarts) {
[13:23:36.207]                           name <- restart$name
[13:23:36.207]                           if (is.null(name)) 
[13:23:36.207]                             next
[13:23:36.207]                           if (!grepl(pattern, name)) 
[13:23:36.207]                             next
[13:23:36.207]                           invokeRestart(restart)
[13:23:36.207]                           muffled <- TRUE
[13:23:36.207]                           break
[13:23:36.207]                         }
[13:23:36.207]                       }
[13:23:36.207]                     }
[13:23:36.207]                     invisible(muffled)
[13:23:36.207]                   }
[13:23:36.207]                   muffleCondition(cond)
[13:23:36.207]                 })
[13:23:36.207]             }))
[13:23:36.207]             future::FutureResult(value = ...future.value$value, 
[13:23:36.207]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.207]                   ...future.rng), globalenv = if (FALSE) 
[13:23:36.207]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:36.207]                     ...future.globalenv.names))
[13:23:36.207]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:36.207]         }, condition = base::local({
[13:23:36.207]             c <- base::c
[13:23:36.207]             inherits <- base::inherits
[13:23:36.207]             invokeRestart <- base::invokeRestart
[13:23:36.207]             length <- base::length
[13:23:36.207]             list <- base::list
[13:23:36.207]             seq.int <- base::seq.int
[13:23:36.207]             signalCondition <- base::signalCondition
[13:23:36.207]             sys.calls <- base::sys.calls
[13:23:36.207]             `[[` <- base::`[[`
[13:23:36.207]             `+` <- base::`+`
[13:23:36.207]             `<<-` <- base::`<<-`
[13:23:36.207]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:36.207]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:36.207]                   3L)]
[13:23:36.207]             }
[13:23:36.207]             function(cond) {
[13:23:36.207]                 is_error <- inherits(cond, "error")
[13:23:36.207]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:36.207]                   NULL)
[13:23:36.207]                 if (is_error) {
[13:23:36.207]                   sessionInformation <- function() {
[13:23:36.207]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:36.207]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:36.207]                       search = base::search(), system = base::Sys.info())
[13:23:36.207]                   }
[13:23:36.207]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.207]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:36.207]                     cond$call), session = sessionInformation(), 
[13:23:36.207]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:36.207]                   signalCondition(cond)
[13:23:36.207]                 }
[13:23:36.207]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:36.207]                 "immediateCondition"))) {
[13:23:36.207]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:36.207]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.207]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:36.207]                   if (TRUE && !signal) {
[13:23:36.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.207]                     {
[13:23:36.207]                       inherits <- base::inherits
[13:23:36.207]                       invokeRestart <- base::invokeRestart
[13:23:36.207]                       is.null <- base::is.null
[13:23:36.207]                       muffled <- FALSE
[13:23:36.207]                       if (inherits(cond, "message")) {
[13:23:36.207]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.207]                         if (muffled) 
[13:23:36.207]                           invokeRestart("muffleMessage")
[13:23:36.207]                       }
[13:23:36.207]                       else if (inherits(cond, "warning")) {
[13:23:36.207]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.207]                         if (muffled) 
[13:23:36.207]                           invokeRestart("muffleWarning")
[13:23:36.207]                       }
[13:23:36.207]                       else if (inherits(cond, "condition")) {
[13:23:36.207]                         if (!is.null(pattern)) {
[13:23:36.207]                           computeRestarts <- base::computeRestarts
[13:23:36.207]                           grepl <- base::grepl
[13:23:36.207]                           restarts <- computeRestarts(cond)
[13:23:36.207]                           for (restart in restarts) {
[13:23:36.207]                             name <- restart$name
[13:23:36.207]                             if (is.null(name)) 
[13:23:36.207]                               next
[13:23:36.207]                             if (!grepl(pattern, name)) 
[13:23:36.207]                               next
[13:23:36.207]                             invokeRestart(restart)
[13:23:36.207]                             muffled <- TRUE
[13:23:36.207]                             break
[13:23:36.207]                           }
[13:23:36.207]                         }
[13:23:36.207]                       }
[13:23:36.207]                       invisible(muffled)
[13:23:36.207]                     }
[13:23:36.207]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.207]                   }
[13:23:36.207]                 }
[13:23:36.207]                 else {
[13:23:36.207]                   if (TRUE) {
[13:23:36.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.207]                     {
[13:23:36.207]                       inherits <- base::inherits
[13:23:36.207]                       invokeRestart <- base::invokeRestart
[13:23:36.207]                       is.null <- base::is.null
[13:23:36.207]                       muffled <- FALSE
[13:23:36.207]                       if (inherits(cond, "message")) {
[13:23:36.207]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.207]                         if (muffled) 
[13:23:36.207]                           invokeRestart("muffleMessage")
[13:23:36.207]                       }
[13:23:36.207]                       else if (inherits(cond, "warning")) {
[13:23:36.207]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.207]                         if (muffled) 
[13:23:36.207]                           invokeRestart("muffleWarning")
[13:23:36.207]                       }
[13:23:36.207]                       else if (inherits(cond, "condition")) {
[13:23:36.207]                         if (!is.null(pattern)) {
[13:23:36.207]                           computeRestarts <- base::computeRestarts
[13:23:36.207]                           grepl <- base::grepl
[13:23:36.207]                           restarts <- computeRestarts(cond)
[13:23:36.207]                           for (restart in restarts) {
[13:23:36.207]                             name <- restart$name
[13:23:36.207]                             if (is.null(name)) 
[13:23:36.207]                               next
[13:23:36.207]                             if (!grepl(pattern, name)) 
[13:23:36.207]                               next
[13:23:36.207]                             invokeRestart(restart)
[13:23:36.207]                             muffled <- TRUE
[13:23:36.207]                             break
[13:23:36.207]                           }
[13:23:36.207]                         }
[13:23:36.207]                       }
[13:23:36.207]                       invisible(muffled)
[13:23:36.207]                     }
[13:23:36.207]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.207]                   }
[13:23:36.207]                 }
[13:23:36.207]             }
[13:23:36.207]         }))
[13:23:36.207]     }, error = function(ex) {
[13:23:36.207]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:36.207]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.207]                 ...future.rng), started = ...future.startTime, 
[13:23:36.207]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:36.207]             version = "1.8"), class = "FutureResult")
[13:23:36.207]     }, finally = {
[13:23:36.207]         if (!identical(...future.workdir, getwd())) 
[13:23:36.207]             setwd(...future.workdir)
[13:23:36.207]         {
[13:23:36.207]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:36.207]                 ...future.oldOptions$nwarnings <- NULL
[13:23:36.207]             }
[13:23:36.207]             base::options(...future.oldOptions)
[13:23:36.207]             if (.Platform$OS.type == "windows") {
[13:23:36.207]                 old_names <- names(...future.oldEnvVars)
[13:23:36.207]                 envs <- base::Sys.getenv()
[13:23:36.207]                 names <- names(envs)
[13:23:36.207]                 common <- intersect(names, old_names)
[13:23:36.207]                 added <- setdiff(names, old_names)
[13:23:36.207]                 removed <- setdiff(old_names, names)
[13:23:36.207]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:36.207]                   envs[common]]
[13:23:36.207]                 NAMES <- toupper(changed)
[13:23:36.207]                 args <- list()
[13:23:36.207]                 for (kk in seq_along(NAMES)) {
[13:23:36.207]                   name <- changed[[kk]]
[13:23:36.207]                   NAME <- NAMES[[kk]]
[13:23:36.207]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.207]                     next
[13:23:36.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.207]                 }
[13:23:36.207]                 NAMES <- toupper(added)
[13:23:36.207]                 for (kk in seq_along(NAMES)) {
[13:23:36.207]                   name <- added[[kk]]
[13:23:36.207]                   NAME <- NAMES[[kk]]
[13:23:36.207]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.207]                     next
[13:23:36.207]                   args[[name]] <- ""
[13:23:36.207]                 }
[13:23:36.207]                 NAMES <- toupper(removed)
[13:23:36.207]                 for (kk in seq_along(NAMES)) {
[13:23:36.207]                   name <- removed[[kk]]
[13:23:36.207]                   NAME <- NAMES[[kk]]
[13:23:36.207]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.207]                     next
[13:23:36.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.207]                 }
[13:23:36.207]                 if (length(args) > 0) 
[13:23:36.207]                   base::do.call(base::Sys.setenv, args = args)
[13:23:36.207]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:36.207]             }
[13:23:36.207]             else {
[13:23:36.207]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:36.207]             }
[13:23:36.207]             {
[13:23:36.207]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:36.207]                   0L) {
[13:23:36.207]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:36.207]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:36.207]                   base::options(opts)
[13:23:36.207]                 }
[13:23:36.207]                 {
[13:23:36.207]                   {
[13:23:36.207]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:36.207]                     NULL
[13:23:36.207]                   }
[13:23:36.207]                   options(future.plan = NULL)
[13:23:36.207]                   if (is.na(NA_character_)) 
[13:23:36.207]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.207]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:36.207]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:36.207]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:36.207]                     envir = parent.frame()) 
[13:23:36.207]                   {
[13:23:36.207]                     if (is.function(workers)) 
[13:23:36.207]                       workers <- workers()
[13:23:36.207]                     workers <- structure(as.integer(workers), 
[13:23:36.207]                       class = class(workers))
[13:23:36.207]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:36.207]                       workers >= 1)
[13:23:36.207]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:36.207]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:36.207]                     }
[13:23:36.207]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:36.207]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:36.207]                       envir = envir)
[13:23:36.207]                     if (!future$lazy) 
[13:23:36.207]                       future <- run(future)
[13:23:36.207]                     invisible(future)
[13:23:36.207]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:36.207]                 }
[13:23:36.207]             }
[13:23:36.207]         }
[13:23:36.207]     })
[13:23:36.207]     if (TRUE) {
[13:23:36.207]         base::sink(type = "output", split = FALSE)
[13:23:36.207]         if (TRUE) {
[13:23:36.207]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:36.207]         }
[13:23:36.207]         else {
[13:23:36.207]             ...future.result["stdout"] <- base::list(NULL)
[13:23:36.207]         }
[13:23:36.207]         base::close(...future.stdout)
[13:23:36.207]         ...future.stdout <- NULL
[13:23:36.207]     }
[13:23:36.207]     ...future.result$conditions <- ...future.conditions
[13:23:36.207]     ...future.result$finished <- base::Sys.time()
[13:23:36.207]     ...future.result
[13:23:36.207] }
[13:23:36.210] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[13:23:36.210] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[13:23:36.210] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[13:23:36.210] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[13:23:36.211] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[13:23:36.211] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[13:23:36.211] MultisessionFuture started
[13:23:36.212] - Launch lazy future ... done
[13:23:36.212] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:36.212] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:36.212] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:36.214] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:36.214] Searching for globals ... DONE
[13:23:36.215] Resolving globals: TRUE
[13:23:36.215] Resolving any globals that are futures ...
[13:23:36.215] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:36.215] Resolving any globals that are futures ... DONE
[13:23:36.215] Resolving futures part of globals (recursively) ...
[13:23:36.215] resolve() on list ...
[13:23:36.216]  recursive: 99
[13:23:36.216]  length: 2
[13:23:36.216]  elements: ‘a’, ‘ii’
[13:23:36.216]  length: 1 (resolved future 1)
[13:23:36.216]  length: 0 (resolved future 2)
[13:23:36.216] resolve() on list ... DONE
[13:23:36.216] - globals: [2] ‘a’, ‘ii’
[13:23:36.216] Resolving futures part of globals (recursively) ... DONE
[13:23:36.216] The total size of the 2 globals is 112 bytes (112 bytes)
[13:23:36.217] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:23:36.217] - globals: [2] ‘a’, ‘ii’
[13:23:36.217] 
[13:23:36.217] getGlobalsAndPackages() ... DONE
[13:23:36.217] run() for ‘Future’ ...
[13:23:36.218] - state: ‘created’
[13:23:36.218] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:36.233] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:36.233] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:36.233]   - Field: ‘node’
[13:23:36.233]   - Field: ‘label’
[13:23:36.233]   - Field: ‘local’
[13:23:36.234]   - Field: ‘owner’
[13:23:36.234]   - Field: ‘envir’
[13:23:36.234]   - Field: ‘workers’
[13:23:36.234]   - Field: ‘packages’
[13:23:36.234]   - Field: ‘gc’
[13:23:36.234]   - Field: ‘conditions’
[13:23:36.234]   - Field: ‘persistent’
[13:23:36.234]   - Field: ‘expr’
[13:23:36.234]   - Field: ‘uuid’
[13:23:36.234]   - Field: ‘seed’
[13:23:36.234]   - Field: ‘version’
[13:23:36.235]   - Field: ‘result’
[13:23:36.235]   - Field: ‘asynchronous’
[13:23:36.235]   - Field: ‘calls’
[13:23:36.235]   - Field: ‘globals’
[13:23:36.235]   - Field: ‘stdout’
[13:23:36.235]   - Field: ‘earlySignal’
[13:23:36.235]   - Field: ‘lazy’
[13:23:36.235]   - Field: ‘state’
[13:23:36.235] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:36.235] - Launch lazy future ...
[13:23:36.236] Packages needed by the future expression (n = 0): <none>
[13:23:36.236] Packages needed by future strategies (n = 0): <none>
[13:23:36.236] {
[13:23:36.236]     {
[13:23:36.236]         {
[13:23:36.236]             ...future.startTime <- base::Sys.time()
[13:23:36.236]             {
[13:23:36.236]                 {
[13:23:36.236]                   {
[13:23:36.236]                     {
[13:23:36.236]                       base::local({
[13:23:36.236]                         has_future <- base::requireNamespace("future", 
[13:23:36.236]                           quietly = TRUE)
[13:23:36.236]                         if (has_future) {
[13:23:36.236]                           ns <- base::getNamespace("future")
[13:23:36.236]                           version <- ns[[".package"]][["version"]]
[13:23:36.236]                           if (is.null(version)) 
[13:23:36.236]                             version <- utils::packageVersion("future")
[13:23:36.236]                         }
[13:23:36.236]                         else {
[13:23:36.236]                           version <- NULL
[13:23:36.236]                         }
[13:23:36.236]                         if (!has_future || version < "1.8.0") {
[13:23:36.236]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:36.236]                             "", base::R.version$version.string), 
[13:23:36.236]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:36.236]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:36.236]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:36.236]                               "release", "version")], collapse = " "), 
[13:23:36.236]                             hostname = base::Sys.info()[["nodename"]])
[13:23:36.236]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:36.236]                             info)
[13:23:36.236]                           info <- base::paste(info, collapse = "; ")
[13:23:36.236]                           if (!has_future) {
[13:23:36.236]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:36.236]                               info)
[13:23:36.236]                           }
[13:23:36.236]                           else {
[13:23:36.236]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:36.236]                               info, version)
[13:23:36.236]                           }
[13:23:36.236]                           base::stop(msg)
[13:23:36.236]                         }
[13:23:36.236]                       })
[13:23:36.236]                     }
[13:23:36.236]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:36.236]                     base::options(mc.cores = 1L)
[13:23:36.236]                   }
[13:23:36.236]                   options(future.plan = NULL)
[13:23:36.236]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.236]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:36.236]                 }
[13:23:36.236]                 ...future.workdir <- getwd()
[13:23:36.236]             }
[13:23:36.236]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:36.236]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:36.236]         }
[13:23:36.236]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:36.236]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:36.236]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:36.236]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:36.236]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:36.236]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:36.236]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:36.236]             base::names(...future.oldOptions))
[13:23:36.236]     }
[13:23:36.236]     if (FALSE) {
[13:23:36.236]     }
[13:23:36.236]     else {
[13:23:36.236]         if (TRUE) {
[13:23:36.236]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:36.236]                 open = "w")
[13:23:36.236]         }
[13:23:36.236]         else {
[13:23:36.236]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:36.236]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:36.236]         }
[13:23:36.236]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:36.236]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:36.236]             base::sink(type = "output", split = FALSE)
[13:23:36.236]             base::close(...future.stdout)
[13:23:36.236]         }, add = TRUE)
[13:23:36.236]     }
[13:23:36.236]     ...future.frame <- base::sys.nframe()
[13:23:36.236]     ...future.conditions <- base::list()
[13:23:36.236]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:36.236]     if (FALSE) {
[13:23:36.236]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:36.236]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:36.236]     }
[13:23:36.236]     ...future.result <- base::tryCatch({
[13:23:36.236]         base::withCallingHandlers({
[13:23:36.236]             ...future.value <- base::withVisible(base::local({
[13:23:36.236]                 ...future.makeSendCondition <- base::local({
[13:23:36.236]                   sendCondition <- NULL
[13:23:36.236]                   function(frame = 1L) {
[13:23:36.236]                     if (is.function(sendCondition)) 
[13:23:36.236]                       return(sendCondition)
[13:23:36.236]                     ns <- getNamespace("parallel")
[13:23:36.236]                     if (exists("sendData", mode = "function", 
[13:23:36.236]                       envir = ns)) {
[13:23:36.236]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:36.236]                         envir = ns)
[13:23:36.236]                       envir <- sys.frame(frame)
[13:23:36.236]                       master <- NULL
[13:23:36.236]                       while (!identical(envir, .GlobalEnv) && 
[13:23:36.236]                         !identical(envir, emptyenv())) {
[13:23:36.236]                         if (exists("master", mode = "list", envir = envir, 
[13:23:36.236]                           inherits = FALSE)) {
[13:23:36.236]                           master <- get("master", mode = "list", 
[13:23:36.236]                             envir = envir, inherits = FALSE)
[13:23:36.236]                           if (inherits(master, c("SOCKnode", 
[13:23:36.236]                             "SOCK0node"))) {
[13:23:36.236]                             sendCondition <<- function(cond) {
[13:23:36.236]                               data <- list(type = "VALUE", value = cond, 
[13:23:36.236]                                 success = TRUE)
[13:23:36.236]                               parallel_sendData(master, data)
[13:23:36.236]                             }
[13:23:36.236]                             return(sendCondition)
[13:23:36.236]                           }
[13:23:36.236]                         }
[13:23:36.236]                         frame <- frame + 1L
[13:23:36.236]                         envir <- sys.frame(frame)
[13:23:36.236]                       }
[13:23:36.236]                     }
[13:23:36.236]                     sendCondition <<- function(cond) NULL
[13:23:36.236]                   }
[13:23:36.236]                 })
[13:23:36.236]                 withCallingHandlers({
[13:23:36.236]                   {
[13:23:36.236]                     b <- a * ii
[13:23:36.236]                     a <- 0
[13:23:36.236]                     b
[13:23:36.236]                   }
[13:23:36.236]                 }, immediateCondition = function(cond) {
[13:23:36.236]                   sendCondition <- ...future.makeSendCondition()
[13:23:36.236]                   sendCondition(cond)
[13:23:36.236]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.236]                   {
[13:23:36.236]                     inherits <- base::inherits
[13:23:36.236]                     invokeRestart <- base::invokeRestart
[13:23:36.236]                     is.null <- base::is.null
[13:23:36.236]                     muffled <- FALSE
[13:23:36.236]                     if (inherits(cond, "message")) {
[13:23:36.236]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:36.236]                       if (muffled) 
[13:23:36.236]                         invokeRestart("muffleMessage")
[13:23:36.236]                     }
[13:23:36.236]                     else if (inherits(cond, "warning")) {
[13:23:36.236]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:36.236]                       if (muffled) 
[13:23:36.236]                         invokeRestart("muffleWarning")
[13:23:36.236]                     }
[13:23:36.236]                     else if (inherits(cond, "condition")) {
[13:23:36.236]                       if (!is.null(pattern)) {
[13:23:36.236]                         computeRestarts <- base::computeRestarts
[13:23:36.236]                         grepl <- base::grepl
[13:23:36.236]                         restarts <- computeRestarts(cond)
[13:23:36.236]                         for (restart in restarts) {
[13:23:36.236]                           name <- restart$name
[13:23:36.236]                           if (is.null(name)) 
[13:23:36.236]                             next
[13:23:36.236]                           if (!grepl(pattern, name)) 
[13:23:36.236]                             next
[13:23:36.236]                           invokeRestart(restart)
[13:23:36.236]                           muffled <- TRUE
[13:23:36.236]                           break
[13:23:36.236]                         }
[13:23:36.236]                       }
[13:23:36.236]                     }
[13:23:36.236]                     invisible(muffled)
[13:23:36.236]                   }
[13:23:36.236]                   muffleCondition(cond)
[13:23:36.236]                 })
[13:23:36.236]             }))
[13:23:36.236]             future::FutureResult(value = ...future.value$value, 
[13:23:36.236]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.236]                   ...future.rng), globalenv = if (FALSE) 
[13:23:36.236]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:36.236]                     ...future.globalenv.names))
[13:23:36.236]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:36.236]         }, condition = base::local({
[13:23:36.236]             c <- base::c
[13:23:36.236]             inherits <- base::inherits
[13:23:36.236]             invokeRestart <- base::invokeRestart
[13:23:36.236]             length <- base::length
[13:23:36.236]             list <- base::list
[13:23:36.236]             seq.int <- base::seq.int
[13:23:36.236]             signalCondition <- base::signalCondition
[13:23:36.236]             sys.calls <- base::sys.calls
[13:23:36.236]             `[[` <- base::`[[`
[13:23:36.236]             `+` <- base::`+`
[13:23:36.236]             `<<-` <- base::`<<-`
[13:23:36.236]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:36.236]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:36.236]                   3L)]
[13:23:36.236]             }
[13:23:36.236]             function(cond) {
[13:23:36.236]                 is_error <- inherits(cond, "error")
[13:23:36.236]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:36.236]                   NULL)
[13:23:36.236]                 if (is_error) {
[13:23:36.236]                   sessionInformation <- function() {
[13:23:36.236]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:36.236]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:36.236]                       search = base::search(), system = base::Sys.info())
[13:23:36.236]                   }
[13:23:36.236]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.236]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:36.236]                     cond$call), session = sessionInformation(), 
[13:23:36.236]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:36.236]                   signalCondition(cond)
[13:23:36.236]                 }
[13:23:36.236]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:36.236]                 "immediateCondition"))) {
[13:23:36.236]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:36.236]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.236]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:36.236]                   if (TRUE && !signal) {
[13:23:36.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.236]                     {
[13:23:36.236]                       inherits <- base::inherits
[13:23:36.236]                       invokeRestart <- base::invokeRestart
[13:23:36.236]                       is.null <- base::is.null
[13:23:36.236]                       muffled <- FALSE
[13:23:36.236]                       if (inherits(cond, "message")) {
[13:23:36.236]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.236]                         if (muffled) 
[13:23:36.236]                           invokeRestart("muffleMessage")
[13:23:36.236]                       }
[13:23:36.236]                       else if (inherits(cond, "warning")) {
[13:23:36.236]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.236]                         if (muffled) 
[13:23:36.236]                           invokeRestart("muffleWarning")
[13:23:36.236]                       }
[13:23:36.236]                       else if (inherits(cond, "condition")) {
[13:23:36.236]                         if (!is.null(pattern)) {
[13:23:36.236]                           computeRestarts <- base::computeRestarts
[13:23:36.236]                           grepl <- base::grepl
[13:23:36.236]                           restarts <- computeRestarts(cond)
[13:23:36.236]                           for (restart in restarts) {
[13:23:36.236]                             name <- restart$name
[13:23:36.236]                             if (is.null(name)) 
[13:23:36.236]                               next
[13:23:36.236]                             if (!grepl(pattern, name)) 
[13:23:36.236]                               next
[13:23:36.236]                             invokeRestart(restart)
[13:23:36.236]                             muffled <- TRUE
[13:23:36.236]                             break
[13:23:36.236]                           }
[13:23:36.236]                         }
[13:23:36.236]                       }
[13:23:36.236]                       invisible(muffled)
[13:23:36.236]                     }
[13:23:36.236]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.236]                   }
[13:23:36.236]                 }
[13:23:36.236]                 else {
[13:23:36.236]                   if (TRUE) {
[13:23:36.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.236]                     {
[13:23:36.236]                       inherits <- base::inherits
[13:23:36.236]                       invokeRestart <- base::invokeRestart
[13:23:36.236]                       is.null <- base::is.null
[13:23:36.236]                       muffled <- FALSE
[13:23:36.236]                       if (inherits(cond, "message")) {
[13:23:36.236]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.236]                         if (muffled) 
[13:23:36.236]                           invokeRestart("muffleMessage")
[13:23:36.236]                       }
[13:23:36.236]                       else if (inherits(cond, "warning")) {
[13:23:36.236]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.236]                         if (muffled) 
[13:23:36.236]                           invokeRestart("muffleWarning")
[13:23:36.236]                       }
[13:23:36.236]                       else if (inherits(cond, "condition")) {
[13:23:36.236]                         if (!is.null(pattern)) {
[13:23:36.236]                           computeRestarts <- base::computeRestarts
[13:23:36.236]                           grepl <- base::grepl
[13:23:36.236]                           restarts <- computeRestarts(cond)
[13:23:36.236]                           for (restart in restarts) {
[13:23:36.236]                             name <- restart$name
[13:23:36.236]                             if (is.null(name)) 
[13:23:36.236]                               next
[13:23:36.236]                             if (!grepl(pattern, name)) 
[13:23:36.236]                               next
[13:23:36.236]                             invokeRestart(restart)
[13:23:36.236]                             muffled <- TRUE
[13:23:36.236]                             break
[13:23:36.236]                           }
[13:23:36.236]                         }
[13:23:36.236]                       }
[13:23:36.236]                       invisible(muffled)
[13:23:36.236]                     }
[13:23:36.236]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.236]                   }
[13:23:36.236]                 }
[13:23:36.236]             }
[13:23:36.236]         }))
[13:23:36.236]     }, error = function(ex) {
[13:23:36.236]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:36.236]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.236]                 ...future.rng), started = ...future.startTime, 
[13:23:36.236]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:36.236]             version = "1.8"), class = "FutureResult")
[13:23:36.236]     }, finally = {
[13:23:36.236]         if (!identical(...future.workdir, getwd())) 
[13:23:36.236]             setwd(...future.workdir)
[13:23:36.236]         {
[13:23:36.236]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:36.236]                 ...future.oldOptions$nwarnings <- NULL
[13:23:36.236]             }
[13:23:36.236]             base::options(...future.oldOptions)
[13:23:36.236]             if (.Platform$OS.type == "windows") {
[13:23:36.236]                 old_names <- names(...future.oldEnvVars)
[13:23:36.236]                 envs <- base::Sys.getenv()
[13:23:36.236]                 names <- names(envs)
[13:23:36.236]                 common <- intersect(names, old_names)
[13:23:36.236]                 added <- setdiff(names, old_names)
[13:23:36.236]                 removed <- setdiff(old_names, names)
[13:23:36.236]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:36.236]                   envs[common]]
[13:23:36.236]                 NAMES <- toupper(changed)
[13:23:36.236]                 args <- list()
[13:23:36.236]                 for (kk in seq_along(NAMES)) {
[13:23:36.236]                   name <- changed[[kk]]
[13:23:36.236]                   NAME <- NAMES[[kk]]
[13:23:36.236]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.236]                     next
[13:23:36.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.236]                 }
[13:23:36.236]                 NAMES <- toupper(added)
[13:23:36.236]                 for (kk in seq_along(NAMES)) {
[13:23:36.236]                   name <- added[[kk]]
[13:23:36.236]                   NAME <- NAMES[[kk]]
[13:23:36.236]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.236]                     next
[13:23:36.236]                   args[[name]] <- ""
[13:23:36.236]                 }
[13:23:36.236]                 NAMES <- toupper(removed)
[13:23:36.236]                 for (kk in seq_along(NAMES)) {
[13:23:36.236]                   name <- removed[[kk]]
[13:23:36.236]                   NAME <- NAMES[[kk]]
[13:23:36.236]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.236]                     next
[13:23:36.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.236]                 }
[13:23:36.236]                 if (length(args) > 0) 
[13:23:36.236]                   base::do.call(base::Sys.setenv, args = args)
[13:23:36.236]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:36.236]             }
[13:23:36.236]             else {
[13:23:36.236]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:36.236]             }
[13:23:36.236]             {
[13:23:36.236]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:36.236]                   0L) {
[13:23:36.236]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:36.236]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:36.236]                   base::options(opts)
[13:23:36.236]                 }
[13:23:36.236]                 {
[13:23:36.236]                   {
[13:23:36.236]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:36.236]                     NULL
[13:23:36.236]                   }
[13:23:36.236]                   options(future.plan = NULL)
[13:23:36.236]                   if (is.na(NA_character_)) 
[13:23:36.236]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.236]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:36.236]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:36.236]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:36.236]                     envir = parent.frame()) 
[13:23:36.236]                   {
[13:23:36.236]                     if (is.function(workers)) 
[13:23:36.236]                       workers <- workers()
[13:23:36.236]                     workers <- structure(as.integer(workers), 
[13:23:36.236]                       class = class(workers))
[13:23:36.236]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:36.236]                       workers >= 1)
[13:23:36.236]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:36.236]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:36.236]                     }
[13:23:36.236]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:36.236]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:36.236]                       envir = envir)
[13:23:36.236]                     if (!future$lazy) 
[13:23:36.236]                       future <- run(future)
[13:23:36.236]                     invisible(future)
[13:23:36.236]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:36.236]                 }
[13:23:36.236]             }
[13:23:36.236]         }
[13:23:36.236]     })
[13:23:36.236]     if (TRUE) {
[13:23:36.236]         base::sink(type = "output", split = FALSE)
[13:23:36.236]         if (TRUE) {
[13:23:36.236]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:36.236]         }
[13:23:36.236]         else {
[13:23:36.236]             ...future.result["stdout"] <- base::list(NULL)
[13:23:36.236]         }
[13:23:36.236]         base::close(...future.stdout)
[13:23:36.236]         ...future.stdout <- NULL
[13:23:36.236]     }
[13:23:36.236]     ...future.result$conditions <- ...future.conditions
[13:23:36.236]     ...future.result$finished <- base::Sys.time()
[13:23:36.236]     ...future.result
[13:23:36.236] }
[13:23:36.239] Poll #1 (0): usedNodes() = 2, workers = 2
[13:23:36.249] receiveMessageFromWorker() for ClusterFuture ...
[13:23:36.250] - Validating connection of MultisessionFuture
[13:23:36.250] - received message: FutureResult
[13:23:36.250] - Received FutureResult
[13:23:36.250] - Erased future from FutureRegistry
[13:23:36.250] result() for ClusterFuture ...
[13:23:36.251] - result already collected: FutureResult
[13:23:36.251] result() for ClusterFuture ... done
[13:23:36.251] signalConditions() ...
[13:23:36.251]  - include = ‘immediateCondition’
[13:23:36.251]  - exclude = 
[13:23:36.251]  - resignal = FALSE
[13:23:36.251]  - Number of conditions: 1
[13:23:36.251] signalConditions() ... done
[13:23:36.251] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:36.251] result() for ClusterFuture ...
[13:23:36.252] - result already collected: FutureResult
[13:23:36.252] result() for ClusterFuture ... done
[13:23:36.252] result() for ClusterFuture ...
[13:23:36.252] - result already collected: FutureResult
[13:23:36.252] result() for ClusterFuture ... done
[13:23:36.252] signalConditions() ...
[13:23:36.252]  - include = ‘immediateCondition’
[13:23:36.253]  - exclude = 
[13:23:36.253]  - resignal = FALSE
[13:23:36.253]  - Number of conditions: 1
[13:23:36.253] signalConditions() ... done
[13:23:36.254] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[13:23:36.254] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[13:23:36.255] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[13:23:36.255] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:23:36.255] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:23:36.255] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[13:23:36.256] MultisessionFuture started
[13:23:36.256] - Launch lazy future ... done
[13:23:36.257] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:36.257] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:36.258] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:36.260] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:36.261] Searching for globals ... DONE
[13:23:36.261] Resolving globals: TRUE
[13:23:36.261] Resolving any globals that are futures ...
[13:23:36.261] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:36.261] Resolving any globals that are futures ... DONE
[13:23:36.262] Resolving futures part of globals (recursively) ...
[13:23:36.262] resolve() on list ...
[13:23:36.262]  recursive: 99
[13:23:36.262]  length: 2
[13:23:36.262]  elements: ‘a’, ‘ii’
[13:23:36.263]  length: 1 (resolved future 1)
[13:23:36.263]  length: 0 (resolved future 2)
[13:23:36.263] resolve() on list ... DONE
[13:23:36.263] - globals: [2] ‘a’, ‘ii’
[13:23:36.263] Resolving futures part of globals (recursively) ... DONE
[13:23:36.263] The total size of the 2 globals is 112 bytes (112 bytes)
[13:23:36.264] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:23:36.264] - globals: [2] ‘a’, ‘ii’
[13:23:36.264] 
[13:23:36.264] getGlobalsAndPackages() ... DONE
[13:23:36.264] run() for ‘Future’ ...
[13:23:36.264] - state: ‘created’
[13:23:36.264] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:36.278] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:36.278] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:36.279]   - Field: ‘node’
[13:23:36.279]   - Field: ‘label’
[13:23:36.279]   - Field: ‘local’
[13:23:36.279]   - Field: ‘owner’
[13:23:36.279]   - Field: ‘envir’
[13:23:36.279]   - Field: ‘workers’
[13:23:36.279]   - Field: ‘packages’
[13:23:36.279]   - Field: ‘gc’
[13:23:36.279]   - Field: ‘conditions’
[13:23:36.279]   - Field: ‘persistent’
[13:23:36.280]   - Field: ‘expr’
[13:23:36.280]   - Field: ‘uuid’
[13:23:36.280]   - Field: ‘seed’
[13:23:36.280]   - Field: ‘version’
[13:23:36.280]   - Field: ‘result’
[13:23:36.280]   - Field: ‘asynchronous’
[13:23:36.280]   - Field: ‘calls’
[13:23:36.280]   - Field: ‘globals’
[13:23:36.280]   - Field: ‘stdout’
[13:23:36.280]   - Field: ‘earlySignal’
[13:23:36.280]   - Field: ‘lazy’
[13:23:36.281]   - Field: ‘state’
[13:23:36.281] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:36.281] - Launch lazy future ...
[13:23:36.281] Packages needed by the future expression (n = 0): <none>
[13:23:36.281] Packages needed by future strategies (n = 0): <none>
[13:23:36.282] {
[13:23:36.282]     {
[13:23:36.282]         {
[13:23:36.282]             ...future.startTime <- base::Sys.time()
[13:23:36.282]             {
[13:23:36.282]                 {
[13:23:36.282]                   {
[13:23:36.282]                     {
[13:23:36.282]                       base::local({
[13:23:36.282]                         has_future <- base::requireNamespace("future", 
[13:23:36.282]                           quietly = TRUE)
[13:23:36.282]                         if (has_future) {
[13:23:36.282]                           ns <- base::getNamespace("future")
[13:23:36.282]                           version <- ns[[".package"]][["version"]]
[13:23:36.282]                           if (is.null(version)) 
[13:23:36.282]                             version <- utils::packageVersion("future")
[13:23:36.282]                         }
[13:23:36.282]                         else {
[13:23:36.282]                           version <- NULL
[13:23:36.282]                         }
[13:23:36.282]                         if (!has_future || version < "1.8.0") {
[13:23:36.282]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:36.282]                             "", base::R.version$version.string), 
[13:23:36.282]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:36.282]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:36.282]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:36.282]                               "release", "version")], collapse = " "), 
[13:23:36.282]                             hostname = base::Sys.info()[["nodename"]])
[13:23:36.282]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:36.282]                             info)
[13:23:36.282]                           info <- base::paste(info, collapse = "; ")
[13:23:36.282]                           if (!has_future) {
[13:23:36.282]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:36.282]                               info)
[13:23:36.282]                           }
[13:23:36.282]                           else {
[13:23:36.282]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:36.282]                               info, version)
[13:23:36.282]                           }
[13:23:36.282]                           base::stop(msg)
[13:23:36.282]                         }
[13:23:36.282]                       })
[13:23:36.282]                     }
[13:23:36.282]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:36.282]                     base::options(mc.cores = 1L)
[13:23:36.282]                   }
[13:23:36.282]                   options(future.plan = NULL)
[13:23:36.282]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.282]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:36.282]                 }
[13:23:36.282]                 ...future.workdir <- getwd()
[13:23:36.282]             }
[13:23:36.282]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:36.282]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:36.282]         }
[13:23:36.282]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:36.282]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:36.282]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:36.282]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:36.282]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:36.282]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:36.282]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:36.282]             base::names(...future.oldOptions))
[13:23:36.282]     }
[13:23:36.282]     if (FALSE) {
[13:23:36.282]     }
[13:23:36.282]     else {
[13:23:36.282]         if (TRUE) {
[13:23:36.282]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:36.282]                 open = "w")
[13:23:36.282]         }
[13:23:36.282]         else {
[13:23:36.282]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:36.282]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:36.282]         }
[13:23:36.282]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:36.282]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:36.282]             base::sink(type = "output", split = FALSE)
[13:23:36.282]             base::close(...future.stdout)
[13:23:36.282]         }, add = TRUE)
[13:23:36.282]     }
[13:23:36.282]     ...future.frame <- base::sys.nframe()
[13:23:36.282]     ...future.conditions <- base::list()
[13:23:36.282]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:36.282]     if (FALSE) {
[13:23:36.282]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:36.282]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:36.282]     }
[13:23:36.282]     ...future.result <- base::tryCatch({
[13:23:36.282]         base::withCallingHandlers({
[13:23:36.282]             ...future.value <- base::withVisible(base::local({
[13:23:36.282]                 ...future.makeSendCondition <- base::local({
[13:23:36.282]                   sendCondition <- NULL
[13:23:36.282]                   function(frame = 1L) {
[13:23:36.282]                     if (is.function(sendCondition)) 
[13:23:36.282]                       return(sendCondition)
[13:23:36.282]                     ns <- getNamespace("parallel")
[13:23:36.282]                     if (exists("sendData", mode = "function", 
[13:23:36.282]                       envir = ns)) {
[13:23:36.282]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:36.282]                         envir = ns)
[13:23:36.282]                       envir <- sys.frame(frame)
[13:23:36.282]                       master <- NULL
[13:23:36.282]                       while (!identical(envir, .GlobalEnv) && 
[13:23:36.282]                         !identical(envir, emptyenv())) {
[13:23:36.282]                         if (exists("master", mode = "list", envir = envir, 
[13:23:36.282]                           inherits = FALSE)) {
[13:23:36.282]                           master <- get("master", mode = "list", 
[13:23:36.282]                             envir = envir, inherits = FALSE)
[13:23:36.282]                           if (inherits(master, c("SOCKnode", 
[13:23:36.282]                             "SOCK0node"))) {
[13:23:36.282]                             sendCondition <<- function(cond) {
[13:23:36.282]                               data <- list(type = "VALUE", value = cond, 
[13:23:36.282]                                 success = TRUE)
[13:23:36.282]                               parallel_sendData(master, data)
[13:23:36.282]                             }
[13:23:36.282]                             return(sendCondition)
[13:23:36.282]                           }
[13:23:36.282]                         }
[13:23:36.282]                         frame <- frame + 1L
[13:23:36.282]                         envir <- sys.frame(frame)
[13:23:36.282]                       }
[13:23:36.282]                     }
[13:23:36.282]                     sendCondition <<- function(cond) NULL
[13:23:36.282]                   }
[13:23:36.282]                 })
[13:23:36.282]                 withCallingHandlers({
[13:23:36.282]                   {
[13:23:36.282]                     b <- a * ii
[13:23:36.282]                     a <- 0
[13:23:36.282]                     b
[13:23:36.282]                   }
[13:23:36.282]                 }, immediateCondition = function(cond) {
[13:23:36.282]                   sendCondition <- ...future.makeSendCondition()
[13:23:36.282]                   sendCondition(cond)
[13:23:36.282]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.282]                   {
[13:23:36.282]                     inherits <- base::inherits
[13:23:36.282]                     invokeRestart <- base::invokeRestart
[13:23:36.282]                     is.null <- base::is.null
[13:23:36.282]                     muffled <- FALSE
[13:23:36.282]                     if (inherits(cond, "message")) {
[13:23:36.282]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:36.282]                       if (muffled) 
[13:23:36.282]                         invokeRestart("muffleMessage")
[13:23:36.282]                     }
[13:23:36.282]                     else if (inherits(cond, "warning")) {
[13:23:36.282]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:36.282]                       if (muffled) 
[13:23:36.282]                         invokeRestart("muffleWarning")
[13:23:36.282]                     }
[13:23:36.282]                     else if (inherits(cond, "condition")) {
[13:23:36.282]                       if (!is.null(pattern)) {
[13:23:36.282]                         computeRestarts <- base::computeRestarts
[13:23:36.282]                         grepl <- base::grepl
[13:23:36.282]                         restarts <- computeRestarts(cond)
[13:23:36.282]                         for (restart in restarts) {
[13:23:36.282]                           name <- restart$name
[13:23:36.282]                           if (is.null(name)) 
[13:23:36.282]                             next
[13:23:36.282]                           if (!grepl(pattern, name)) 
[13:23:36.282]                             next
[13:23:36.282]                           invokeRestart(restart)
[13:23:36.282]                           muffled <- TRUE
[13:23:36.282]                           break
[13:23:36.282]                         }
[13:23:36.282]                       }
[13:23:36.282]                     }
[13:23:36.282]                     invisible(muffled)
[13:23:36.282]                   }
[13:23:36.282]                   muffleCondition(cond)
[13:23:36.282]                 })
[13:23:36.282]             }))
[13:23:36.282]             future::FutureResult(value = ...future.value$value, 
[13:23:36.282]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.282]                   ...future.rng), globalenv = if (FALSE) 
[13:23:36.282]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:36.282]                     ...future.globalenv.names))
[13:23:36.282]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:36.282]         }, condition = base::local({
[13:23:36.282]             c <- base::c
[13:23:36.282]             inherits <- base::inherits
[13:23:36.282]             invokeRestart <- base::invokeRestart
[13:23:36.282]             length <- base::length
[13:23:36.282]             list <- base::list
[13:23:36.282]             seq.int <- base::seq.int
[13:23:36.282]             signalCondition <- base::signalCondition
[13:23:36.282]             sys.calls <- base::sys.calls
[13:23:36.282]             `[[` <- base::`[[`
[13:23:36.282]             `+` <- base::`+`
[13:23:36.282]             `<<-` <- base::`<<-`
[13:23:36.282]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:36.282]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:36.282]                   3L)]
[13:23:36.282]             }
[13:23:36.282]             function(cond) {
[13:23:36.282]                 is_error <- inherits(cond, "error")
[13:23:36.282]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:36.282]                   NULL)
[13:23:36.282]                 if (is_error) {
[13:23:36.282]                   sessionInformation <- function() {
[13:23:36.282]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:36.282]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:36.282]                       search = base::search(), system = base::Sys.info())
[13:23:36.282]                   }
[13:23:36.282]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.282]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:36.282]                     cond$call), session = sessionInformation(), 
[13:23:36.282]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:36.282]                   signalCondition(cond)
[13:23:36.282]                 }
[13:23:36.282]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:36.282]                 "immediateCondition"))) {
[13:23:36.282]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:36.282]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.282]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:36.282]                   if (TRUE && !signal) {
[13:23:36.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.282]                     {
[13:23:36.282]                       inherits <- base::inherits
[13:23:36.282]                       invokeRestart <- base::invokeRestart
[13:23:36.282]                       is.null <- base::is.null
[13:23:36.282]                       muffled <- FALSE
[13:23:36.282]                       if (inherits(cond, "message")) {
[13:23:36.282]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.282]                         if (muffled) 
[13:23:36.282]                           invokeRestart("muffleMessage")
[13:23:36.282]                       }
[13:23:36.282]                       else if (inherits(cond, "warning")) {
[13:23:36.282]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.282]                         if (muffled) 
[13:23:36.282]                           invokeRestart("muffleWarning")
[13:23:36.282]                       }
[13:23:36.282]                       else if (inherits(cond, "condition")) {
[13:23:36.282]                         if (!is.null(pattern)) {
[13:23:36.282]                           computeRestarts <- base::computeRestarts
[13:23:36.282]                           grepl <- base::grepl
[13:23:36.282]                           restarts <- computeRestarts(cond)
[13:23:36.282]                           for (restart in restarts) {
[13:23:36.282]                             name <- restart$name
[13:23:36.282]                             if (is.null(name)) 
[13:23:36.282]                               next
[13:23:36.282]                             if (!grepl(pattern, name)) 
[13:23:36.282]                               next
[13:23:36.282]                             invokeRestart(restart)
[13:23:36.282]                             muffled <- TRUE
[13:23:36.282]                             break
[13:23:36.282]                           }
[13:23:36.282]                         }
[13:23:36.282]                       }
[13:23:36.282]                       invisible(muffled)
[13:23:36.282]                     }
[13:23:36.282]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.282]                   }
[13:23:36.282]                 }
[13:23:36.282]                 else {
[13:23:36.282]                   if (TRUE) {
[13:23:36.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.282]                     {
[13:23:36.282]                       inherits <- base::inherits
[13:23:36.282]                       invokeRestart <- base::invokeRestart
[13:23:36.282]                       is.null <- base::is.null
[13:23:36.282]                       muffled <- FALSE
[13:23:36.282]                       if (inherits(cond, "message")) {
[13:23:36.282]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.282]                         if (muffled) 
[13:23:36.282]                           invokeRestart("muffleMessage")
[13:23:36.282]                       }
[13:23:36.282]                       else if (inherits(cond, "warning")) {
[13:23:36.282]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.282]                         if (muffled) 
[13:23:36.282]                           invokeRestart("muffleWarning")
[13:23:36.282]                       }
[13:23:36.282]                       else if (inherits(cond, "condition")) {
[13:23:36.282]                         if (!is.null(pattern)) {
[13:23:36.282]                           computeRestarts <- base::computeRestarts
[13:23:36.282]                           grepl <- base::grepl
[13:23:36.282]                           restarts <- computeRestarts(cond)
[13:23:36.282]                           for (restart in restarts) {
[13:23:36.282]                             name <- restart$name
[13:23:36.282]                             if (is.null(name)) 
[13:23:36.282]                               next
[13:23:36.282]                             if (!grepl(pattern, name)) 
[13:23:36.282]                               next
[13:23:36.282]                             invokeRestart(restart)
[13:23:36.282]                             muffled <- TRUE
[13:23:36.282]                             break
[13:23:36.282]                           }
[13:23:36.282]                         }
[13:23:36.282]                       }
[13:23:36.282]                       invisible(muffled)
[13:23:36.282]                     }
[13:23:36.282]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.282]                   }
[13:23:36.282]                 }
[13:23:36.282]             }
[13:23:36.282]         }))
[13:23:36.282]     }, error = function(ex) {
[13:23:36.282]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:36.282]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.282]                 ...future.rng), started = ...future.startTime, 
[13:23:36.282]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:36.282]             version = "1.8"), class = "FutureResult")
[13:23:36.282]     }, finally = {
[13:23:36.282]         if (!identical(...future.workdir, getwd())) 
[13:23:36.282]             setwd(...future.workdir)
[13:23:36.282]         {
[13:23:36.282]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:36.282]                 ...future.oldOptions$nwarnings <- NULL
[13:23:36.282]             }
[13:23:36.282]             base::options(...future.oldOptions)
[13:23:36.282]             if (.Platform$OS.type == "windows") {
[13:23:36.282]                 old_names <- names(...future.oldEnvVars)
[13:23:36.282]                 envs <- base::Sys.getenv()
[13:23:36.282]                 names <- names(envs)
[13:23:36.282]                 common <- intersect(names, old_names)
[13:23:36.282]                 added <- setdiff(names, old_names)
[13:23:36.282]                 removed <- setdiff(old_names, names)
[13:23:36.282]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:36.282]                   envs[common]]
[13:23:36.282]                 NAMES <- toupper(changed)
[13:23:36.282]                 args <- list()
[13:23:36.282]                 for (kk in seq_along(NAMES)) {
[13:23:36.282]                   name <- changed[[kk]]
[13:23:36.282]                   NAME <- NAMES[[kk]]
[13:23:36.282]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.282]                     next
[13:23:36.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.282]                 }
[13:23:36.282]                 NAMES <- toupper(added)
[13:23:36.282]                 for (kk in seq_along(NAMES)) {
[13:23:36.282]                   name <- added[[kk]]
[13:23:36.282]                   NAME <- NAMES[[kk]]
[13:23:36.282]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.282]                     next
[13:23:36.282]                   args[[name]] <- ""
[13:23:36.282]                 }
[13:23:36.282]                 NAMES <- toupper(removed)
[13:23:36.282]                 for (kk in seq_along(NAMES)) {
[13:23:36.282]                   name <- removed[[kk]]
[13:23:36.282]                   NAME <- NAMES[[kk]]
[13:23:36.282]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.282]                     next
[13:23:36.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.282]                 }
[13:23:36.282]                 if (length(args) > 0) 
[13:23:36.282]                   base::do.call(base::Sys.setenv, args = args)
[13:23:36.282]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:36.282]             }
[13:23:36.282]             else {
[13:23:36.282]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:36.282]             }
[13:23:36.282]             {
[13:23:36.282]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:36.282]                   0L) {
[13:23:36.282]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:36.282]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:36.282]                   base::options(opts)
[13:23:36.282]                 }
[13:23:36.282]                 {
[13:23:36.282]                   {
[13:23:36.282]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:36.282]                     NULL
[13:23:36.282]                   }
[13:23:36.282]                   options(future.plan = NULL)
[13:23:36.282]                   if (is.na(NA_character_)) 
[13:23:36.282]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.282]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:36.282]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:36.282]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:36.282]                     envir = parent.frame()) 
[13:23:36.282]                   {
[13:23:36.282]                     if (is.function(workers)) 
[13:23:36.282]                       workers <- workers()
[13:23:36.282]                     workers <- structure(as.integer(workers), 
[13:23:36.282]                       class = class(workers))
[13:23:36.282]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:36.282]                       workers >= 1)
[13:23:36.282]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:36.282]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:36.282]                     }
[13:23:36.282]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:36.282]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:36.282]                       envir = envir)
[13:23:36.282]                     if (!future$lazy) 
[13:23:36.282]                       future <- run(future)
[13:23:36.282]                     invisible(future)
[13:23:36.282]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:36.282]                 }
[13:23:36.282]             }
[13:23:36.282]         }
[13:23:36.282]     })
[13:23:36.282]     if (TRUE) {
[13:23:36.282]         base::sink(type = "output", split = FALSE)
[13:23:36.282]         if (TRUE) {
[13:23:36.282]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:36.282]         }
[13:23:36.282]         else {
[13:23:36.282]             ...future.result["stdout"] <- base::list(NULL)
[13:23:36.282]         }
[13:23:36.282]         base::close(...future.stdout)
[13:23:36.282]         ...future.stdout <- NULL
[13:23:36.282]     }
[13:23:36.282]     ...future.result$conditions <- ...future.conditions
[13:23:36.282]     ...future.result$finished <- base::Sys.time()
[13:23:36.282]     ...future.result
[13:23:36.282] }
[13:23:36.284] Poll #1 (0): usedNodes() = 2, workers = 2
[13:23:36.295] receiveMessageFromWorker() for ClusterFuture ...
[13:23:36.295] - Validating connection of MultisessionFuture
[13:23:36.295] - received message: FutureResult
[13:23:36.295] - Received FutureResult
[13:23:36.295] - Erased future from FutureRegistry
[13:23:36.296] result() for ClusterFuture ...
[13:23:36.296] - result already collected: FutureResult
[13:23:36.296] result() for ClusterFuture ... done
[13:23:36.296] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:36.296] result() for ClusterFuture ...
[13:23:36.296] - result already collected: FutureResult
[13:23:36.296] result() for ClusterFuture ... done
[13:23:36.296] result() for ClusterFuture ...
[13:23:36.296] - result already collected: FutureResult
[13:23:36.296] result() for ClusterFuture ... done
[13:23:36.297] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[13:23:36.297] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[13:23:36.298] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[13:23:36.298] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[13:23:36.298] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[13:23:36.299] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[13:23:36.299] MultisessionFuture started
[13:23:36.299] - Launch lazy future ... done
[13:23:36.299] run() for ‘MultisessionFuture’ ... done
[13:23:36.300] result() for ClusterFuture ...
[13:23:36.300] - result already collected: FutureResult
[13:23:36.300] result() for ClusterFuture ... done
[13:23:36.300] result() for ClusterFuture ...
[13:23:36.300] - result already collected: FutureResult
[13:23:36.300] result() for ClusterFuture ... done
[13:23:36.300] result() for ClusterFuture ...
[13:23:36.300] receiveMessageFromWorker() for ClusterFuture ...
[13:23:36.301] - Validating connection of MultisessionFuture
[13:23:36.309] - received message: FutureResult
[13:23:36.310] - Received FutureResult
[13:23:36.310] - Erased future from FutureRegistry
[13:23:36.310] result() for ClusterFuture ...
[13:23:36.310] - result already collected: FutureResult
[13:23:36.310] result() for ClusterFuture ... done
[13:23:36.310] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:36.310] result() for ClusterFuture ... done
[13:23:36.311] result() for ClusterFuture ...
[13:23:36.311] - result already collected: FutureResult
[13:23:36.311] result() for ClusterFuture ... done
[13:23:36.311] result() for ClusterFuture ...
[13:23:36.311] receiveMessageFromWorker() for ClusterFuture ...
[13:23:36.311] - Validating connection of MultisessionFuture
[13:23:36.350] - received message: FutureResult
[13:23:36.350] - Received FutureResult
[13:23:36.350] - Erased future from FutureRegistry
[13:23:36.350] result() for ClusterFuture ...
[13:23:36.350] - result already collected: FutureResult
[13:23:36.351] result() for ClusterFuture ... done
[13:23:36.351] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:36.351] result() for ClusterFuture ... done
[13:23:36.351] result() for ClusterFuture ...
[13:23:36.351] - result already collected: FutureResult
[13:23:36.351] result() for ClusterFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:36.352] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:36.352] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:36.354] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:36.354] Searching for globals ... DONE
[13:23:36.354] Resolving globals: TRUE
[13:23:36.354] Resolving any globals that are futures ...
[13:23:36.355] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:36.355] Resolving any globals that are futures ... DONE
[13:23:36.355] Resolving futures part of globals (recursively) ...
[13:23:36.355] resolve() on list ...
[13:23:36.355]  recursive: 99
[13:23:36.355]  length: 2
[13:23:36.356]  elements: ‘a’, ‘ii’
[13:23:36.356]  length: 1 (resolved future 1)
[13:23:36.356]  length: 0 (resolved future 2)
[13:23:36.356] resolve() on list ... DONE
[13:23:36.356] - globals: [2] ‘a’, ‘ii’
[13:23:36.356] Resolving futures part of globals (recursively) ... DONE
[13:23:36.356] The total size of the 2 globals is 112 bytes (112 bytes)
[13:23:36.357] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:23:36.357] - globals: [2] ‘a’, ‘ii’
[13:23:36.357] 
[13:23:36.357] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:36.358] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:36.358] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:36.360] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:36.360] Searching for globals ... DONE
[13:23:36.360] Resolving globals: TRUE
[13:23:36.360] Resolving any globals that are futures ...
[13:23:36.360] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:36.360] Resolving any globals that are futures ... DONE
[13:23:36.361] Resolving futures part of globals (recursively) ...
[13:23:36.361] resolve() on list ...
[13:23:36.361]  recursive: 99
[13:23:36.361]  length: 2
[13:23:36.361]  elements: ‘a’, ‘ii’
[13:23:36.361]  length: 1 (resolved future 1)
[13:23:36.361]  length: 0 (resolved future 2)
[13:23:36.362] resolve() on list ... DONE
[13:23:36.362] - globals: [2] ‘a’, ‘ii’
[13:23:36.362] Resolving futures part of globals (recursively) ... DONE
[13:23:36.362] The total size of the 2 globals is 112 bytes (112 bytes)
[13:23:36.362] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:23:36.362] - globals: [2] ‘a’, ‘ii’
[13:23:36.363] 
[13:23:36.363] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:36.363] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:36.363] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:36.365] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:36.365] Searching for globals ... DONE
[13:23:36.366] Resolving globals: TRUE
[13:23:36.366] Resolving any globals that are futures ...
[13:23:36.366] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:23:36.366] Resolving any globals that are futures ... DONE
[13:23:36.366] Resolving futures part of globals (recursively) ...
[13:23:36.366] resolve() on list ...
[13:23:36.366]  recursive: 99
[13:23:36.367]  length: 2
[13:23:36.367]  elements: ‘a’, ‘ii’
[13:23:36.367]  length: 1 (resolved future 1)
[13:23:36.367]  length: 0 (resolved future 2)
[13:23:36.367] resolve() on list ... DONE
[13:23:36.367] - globals: [2] ‘a’, ‘ii’
[13:23:36.367] Resolving futures part of globals (recursively) ... DONE
[13:23:36.367] The total size of the 2 globals is 112 bytes (112 bytes)
[13:23:36.368] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:23:36.368] - globals: [2] ‘a’, ‘ii’
[13:23:36.368] 
[13:23:36.368] getGlobalsAndPackages() ... DONE
[13:23:36.368] run() for ‘Future’ ...
[13:23:36.369] - state: ‘created’
[13:23:36.369] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:36.383] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:36.383] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:36.383]   - Field: ‘node’
[13:23:36.383]   - Field: ‘label’
[13:23:36.383]   - Field: ‘local’
[13:23:36.384]   - Field: ‘owner’
[13:23:36.384]   - Field: ‘envir’
[13:23:36.384]   - Field: ‘workers’
[13:23:36.384]   - Field: ‘packages’
[13:23:36.384]   - Field: ‘gc’
[13:23:36.384]   - Field: ‘conditions’
[13:23:36.384]   - Field: ‘persistent’
[13:23:36.384]   - Field: ‘expr’
[13:23:36.384]   - Field: ‘uuid’
[13:23:36.384]   - Field: ‘seed’
[13:23:36.385]   - Field: ‘version’
[13:23:36.385]   - Field: ‘result’
[13:23:36.385]   - Field: ‘asynchronous’
[13:23:36.385]   - Field: ‘calls’
[13:23:36.385]   - Field: ‘globals’
[13:23:36.385]   - Field: ‘stdout’
[13:23:36.385]   - Field: ‘earlySignal’
[13:23:36.385]   - Field: ‘lazy’
[13:23:36.385]   - Field: ‘state’
[13:23:36.388] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:36.388] - Launch lazy future ...
[13:23:36.388] Packages needed by the future expression (n = 0): <none>
[13:23:36.388] Packages needed by future strategies (n = 0): <none>
[13:23:36.389] {
[13:23:36.389]     {
[13:23:36.389]         {
[13:23:36.389]             ...future.startTime <- base::Sys.time()
[13:23:36.389]             {
[13:23:36.389]                 {
[13:23:36.389]                   {
[13:23:36.389]                     {
[13:23:36.389]                       base::local({
[13:23:36.389]                         has_future <- base::requireNamespace("future", 
[13:23:36.389]                           quietly = TRUE)
[13:23:36.389]                         if (has_future) {
[13:23:36.389]                           ns <- base::getNamespace("future")
[13:23:36.389]                           version <- ns[[".package"]][["version"]]
[13:23:36.389]                           if (is.null(version)) 
[13:23:36.389]                             version <- utils::packageVersion("future")
[13:23:36.389]                         }
[13:23:36.389]                         else {
[13:23:36.389]                           version <- NULL
[13:23:36.389]                         }
[13:23:36.389]                         if (!has_future || version < "1.8.0") {
[13:23:36.389]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:36.389]                             "", base::R.version$version.string), 
[13:23:36.389]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:36.389]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:36.389]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:36.389]                               "release", "version")], collapse = " "), 
[13:23:36.389]                             hostname = base::Sys.info()[["nodename"]])
[13:23:36.389]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:36.389]                             info)
[13:23:36.389]                           info <- base::paste(info, collapse = "; ")
[13:23:36.389]                           if (!has_future) {
[13:23:36.389]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:36.389]                               info)
[13:23:36.389]                           }
[13:23:36.389]                           else {
[13:23:36.389]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:36.389]                               info, version)
[13:23:36.389]                           }
[13:23:36.389]                           base::stop(msg)
[13:23:36.389]                         }
[13:23:36.389]                       })
[13:23:36.389]                     }
[13:23:36.389]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:36.389]                     base::options(mc.cores = 1L)
[13:23:36.389]                   }
[13:23:36.389]                   options(future.plan = NULL)
[13:23:36.389]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.389]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:36.389]                 }
[13:23:36.389]                 ...future.workdir <- getwd()
[13:23:36.389]             }
[13:23:36.389]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:36.389]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:36.389]         }
[13:23:36.389]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:36.389]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:36.389]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:36.389]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:36.389]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:36.389]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:36.389]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:36.389]             base::names(...future.oldOptions))
[13:23:36.389]     }
[13:23:36.389]     if (FALSE) {
[13:23:36.389]     }
[13:23:36.389]     else {
[13:23:36.389]         if (TRUE) {
[13:23:36.389]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:36.389]                 open = "w")
[13:23:36.389]         }
[13:23:36.389]         else {
[13:23:36.389]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:36.389]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:36.389]         }
[13:23:36.389]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:36.389]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:36.389]             base::sink(type = "output", split = FALSE)
[13:23:36.389]             base::close(...future.stdout)
[13:23:36.389]         }, add = TRUE)
[13:23:36.389]     }
[13:23:36.389]     ...future.frame <- base::sys.nframe()
[13:23:36.389]     ...future.conditions <- base::list()
[13:23:36.389]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:36.389]     if (FALSE) {
[13:23:36.389]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:36.389]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:36.389]     }
[13:23:36.389]     ...future.result <- base::tryCatch({
[13:23:36.389]         base::withCallingHandlers({
[13:23:36.389]             ...future.value <- base::withVisible(base::local({
[13:23:36.389]                 ...future.makeSendCondition <- base::local({
[13:23:36.389]                   sendCondition <- NULL
[13:23:36.389]                   function(frame = 1L) {
[13:23:36.389]                     if (is.function(sendCondition)) 
[13:23:36.389]                       return(sendCondition)
[13:23:36.389]                     ns <- getNamespace("parallel")
[13:23:36.389]                     if (exists("sendData", mode = "function", 
[13:23:36.389]                       envir = ns)) {
[13:23:36.389]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:36.389]                         envir = ns)
[13:23:36.389]                       envir <- sys.frame(frame)
[13:23:36.389]                       master <- NULL
[13:23:36.389]                       while (!identical(envir, .GlobalEnv) && 
[13:23:36.389]                         !identical(envir, emptyenv())) {
[13:23:36.389]                         if (exists("master", mode = "list", envir = envir, 
[13:23:36.389]                           inherits = FALSE)) {
[13:23:36.389]                           master <- get("master", mode = "list", 
[13:23:36.389]                             envir = envir, inherits = FALSE)
[13:23:36.389]                           if (inherits(master, c("SOCKnode", 
[13:23:36.389]                             "SOCK0node"))) {
[13:23:36.389]                             sendCondition <<- function(cond) {
[13:23:36.389]                               data <- list(type = "VALUE", value = cond, 
[13:23:36.389]                                 success = TRUE)
[13:23:36.389]                               parallel_sendData(master, data)
[13:23:36.389]                             }
[13:23:36.389]                             return(sendCondition)
[13:23:36.389]                           }
[13:23:36.389]                         }
[13:23:36.389]                         frame <- frame + 1L
[13:23:36.389]                         envir <- sys.frame(frame)
[13:23:36.389]                       }
[13:23:36.389]                     }
[13:23:36.389]                     sendCondition <<- function(cond) NULL
[13:23:36.389]                   }
[13:23:36.389]                 })
[13:23:36.389]                 withCallingHandlers({
[13:23:36.389]                   {
[13:23:36.389]                     b <- a * ii
[13:23:36.389]                     a <- 0
[13:23:36.389]                     b
[13:23:36.389]                   }
[13:23:36.389]                 }, immediateCondition = function(cond) {
[13:23:36.389]                   sendCondition <- ...future.makeSendCondition()
[13:23:36.389]                   sendCondition(cond)
[13:23:36.389]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.389]                   {
[13:23:36.389]                     inherits <- base::inherits
[13:23:36.389]                     invokeRestart <- base::invokeRestart
[13:23:36.389]                     is.null <- base::is.null
[13:23:36.389]                     muffled <- FALSE
[13:23:36.389]                     if (inherits(cond, "message")) {
[13:23:36.389]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:36.389]                       if (muffled) 
[13:23:36.389]                         invokeRestart("muffleMessage")
[13:23:36.389]                     }
[13:23:36.389]                     else if (inherits(cond, "warning")) {
[13:23:36.389]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:36.389]                       if (muffled) 
[13:23:36.389]                         invokeRestart("muffleWarning")
[13:23:36.389]                     }
[13:23:36.389]                     else if (inherits(cond, "condition")) {
[13:23:36.389]                       if (!is.null(pattern)) {
[13:23:36.389]                         computeRestarts <- base::computeRestarts
[13:23:36.389]                         grepl <- base::grepl
[13:23:36.389]                         restarts <- computeRestarts(cond)
[13:23:36.389]                         for (restart in restarts) {
[13:23:36.389]                           name <- restart$name
[13:23:36.389]                           if (is.null(name)) 
[13:23:36.389]                             next
[13:23:36.389]                           if (!grepl(pattern, name)) 
[13:23:36.389]                             next
[13:23:36.389]                           invokeRestart(restart)
[13:23:36.389]                           muffled <- TRUE
[13:23:36.389]                           break
[13:23:36.389]                         }
[13:23:36.389]                       }
[13:23:36.389]                     }
[13:23:36.389]                     invisible(muffled)
[13:23:36.389]                   }
[13:23:36.389]                   muffleCondition(cond)
[13:23:36.389]                 })
[13:23:36.389]             }))
[13:23:36.389]             future::FutureResult(value = ...future.value$value, 
[13:23:36.389]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.389]                   ...future.rng), globalenv = if (FALSE) 
[13:23:36.389]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:36.389]                     ...future.globalenv.names))
[13:23:36.389]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:36.389]         }, condition = base::local({
[13:23:36.389]             c <- base::c
[13:23:36.389]             inherits <- base::inherits
[13:23:36.389]             invokeRestart <- base::invokeRestart
[13:23:36.389]             length <- base::length
[13:23:36.389]             list <- base::list
[13:23:36.389]             seq.int <- base::seq.int
[13:23:36.389]             signalCondition <- base::signalCondition
[13:23:36.389]             sys.calls <- base::sys.calls
[13:23:36.389]             `[[` <- base::`[[`
[13:23:36.389]             `+` <- base::`+`
[13:23:36.389]             `<<-` <- base::`<<-`
[13:23:36.389]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:36.389]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:36.389]                   3L)]
[13:23:36.389]             }
[13:23:36.389]             function(cond) {
[13:23:36.389]                 is_error <- inherits(cond, "error")
[13:23:36.389]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:36.389]                   NULL)
[13:23:36.389]                 if (is_error) {
[13:23:36.389]                   sessionInformation <- function() {
[13:23:36.389]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:36.389]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:36.389]                       search = base::search(), system = base::Sys.info())
[13:23:36.389]                   }
[13:23:36.389]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.389]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:36.389]                     cond$call), session = sessionInformation(), 
[13:23:36.389]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:36.389]                   signalCondition(cond)
[13:23:36.389]                 }
[13:23:36.389]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:36.389]                 "immediateCondition"))) {
[13:23:36.389]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:36.389]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.389]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:36.389]                   if (TRUE && !signal) {
[13:23:36.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.389]                     {
[13:23:36.389]                       inherits <- base::inherits
[13:23:36.389]                       invokeRestart <- base::invokeRestart
[13:23:36.389]                       is.null <- base::is.null
[13:23:36.389]                       muffled <- FALSE
[13:23:36.389]                       if (inherits(cond, "message")) {
[13:23:36.389]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.389]                         if (muffled) 
[13:23:36.389]                           invokeRestart("muffleMessage")
[13:23:36.389]                       }
[13:23:36.389]                       else if (inherits(cond, "warning")) {
[13:23:36.389]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.389]                         if (muffled) 
[13:23:36.389]                           invokeRestart("muffleWarning")
[13:23:36.389]                       }
[13:23:36.389]                       else if (inherits(cond, "condition")) {
[13:23:36.389]                         if (!is.null(pattern)) {
[13:23:36.389]                           computeRestarts <- base::computeRestarts
[13:23:36.389]                           grepl <- base::grepl
[13:23:36.389]                           restarts <- computeRestarts(cond)
[13:23:36.389]                           for (restart in restarts) {
[13:23:36.389]                             name <- restart$name
[13:23:36.389]                             if (is.null(name)) 
[13:23:36.389]                               next
[13:23:36.389]                             if (!grepl(pattern, name)) 
[13:23:36.389]                               next
[13:23:36.389]                             invokeRestart(restart)
[13:23:36.389]                             muffled <- TRUE
[13:23:36.389]                             break
[13:23:36.389]                           }
[13:23:36.389]                         }
[13:23:36.389]                       }
[13:23:36.389]                       invisible(muffled)
[13:23:36.389]                     }
[13:23:36.389]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.389]                   }
[13:23:36.389]                 }
[13:23:36.389]                 else {
[13:23:36.389]                   if (TRUE) {
[13:23:36.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.389]                     {
[13:23:36.389]                       inherits <- base::inherits
[13:23:36.389]                       invokeRestart <- base::invokeRestart
[13:23:36.389]                       is.null <- base::is.null
[13:23:36.389]                       muffled <- FALSE
[13:23:36.389]                       if (inherits(cond, "message")) {
[13:23:36.389]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.389]                         if (muffled) 
[13:23:36.389]                           invokeRestart("muffleMessage")
[13:23:36.389]                       }
[13:23:36.389]                       else if (inherits(cond, "warning")) {
[13:23:36.389]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.389]                         if (muffled) 
[13:23:36.389]                           invokeRestart("muffleWarning")
[13:23:36.389]                       }
[13:23:36.389]                       else if (inherits(cond, "condition")) {
[13:23:36.389]                         if (!is.null(pattern)) {
[13:23:36.389]                           computeRestarts <- base::computeRestarts
[13:23:36.389]                           grepl <- base::grepl
[13:23:36.389]                           restarts <- computeRestarts(cond)
[13:23:36.389]                           for (restart in restarts) {
[13:23:36.389]                             name <- restart$name
[13:23:36.389]                             if (is.null(name)) 
[13:23:36.389]                               next
[13:23:36.389]                             if (!grepl(pattern, name)) 
[13:23:36.389]                               next
[13:23:36.389]                             invokeRestart(restart)
[13:23:36.389]                             muffled <- TRUE
[13:23:36.389]                             break
[13:23:36.389]                           }
[13:23:36.389]                         }
[13:23:36.389]                       }
[13:23:36.389]                       invisible(muffled)
[13:23:36.389]                     }
[13:23:36.389]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.389]                   }
[13:23:36.389]                 }
[13:23:36.389]             }
[13:23:36.389]         }))
[13:23:36.389]     }, error = function(ex) {
[13:23:36.389]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:36.389]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.389]                 ...future.rng), started = ...future.startTime, 
[13:23:36.389]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:36.389]             version = "1.8"), class = "FutureResult")
[13:23:36.389]     }, finally = {
[13:23:36.389]         if (!identical(...future.workdir, getwd())) 
[13:23:36.389]             setwd(...future.workdir)
[13:23:36.389]         {
[13:23:36.389]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:36.389]                 ...future.oldOptions$nwarnings <- NULL
[13:23:36.389]             }
[13:23:36.389]             base::options(...future.oldOptions)
[13:23:36.389]             if (.Platform$OS.type == "windows") {
[13:23:36.389]                 old_names <- names(...future.oldEnvVars)
[13:23:36.389]                 envs <- base::Sys.getenv()
[13:23:36.389]                 names <- names(envs)
[13:23:36.389]                 common <- intersect(names, old_names)
[13:23:36.389]                 added <- setdiff(names, old_names)
[13:23:36.389]                 removed <- setdiff(old_names, names)
[13:23:36.389]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:36.389]                   envs[common]]
[13:23:36.389]                 NAMES <- toupper(changed)
[13:23:36.389]                 args <- list()
[13:23:36.389]                 for (kk in seq_along(NAMES)) {
[13:23:36.389]                   name <- changed[[kk]]
[13:23:36.389]                   NAME <- NAMES[[kk]]
[13:23:36.389]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.389]                     next
[13:23:36.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.389]                 }
[13:23:36.389]                 NAMES <- toupper(added)
[13:23:36.389]                 for (kk in seq_along(NAMES)) {
[13:23:36.389]                   name <- added[[kk]]
[13:23:36.389]                   NAME <- NAMES[[kk]]
[13:23:36.389]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.389]                     next
[13:23:36.389]                   args[[name]] <- ""
[13:23:36.389]                 }
[13:23:36.389]                 NAMES <- toupper(removed)
[13:23:36.389]                 for (kk in seq_along(NAMES)) {
[13:23:36.389]                   name <- removed[[kk]]
[13:23:36.389]                   NAME <- NAMES[[kk]]
[13:23:36.389]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.389]                     next
[13:23:36.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.389]                 }
[13:23:36.389]                 if (length(args) > 0) 
[13:23:36.389]                   base::do.call(base::Sys.setenv, args = args)
[13:23:36.389]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:36.389]             }
[13:23:36.389]             else {
[13:23:36.389]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:36.389]             }
[13:23:36.389]             {
[13:23:36.389]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:36.389]                   0L) {
[13:23:36.389]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:36.389]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:36.389]                   base::options(opts)
[13:23:36.389]                 }
[13:23:36.389]                 {
[13:23:36.389]                   {
[13:23:36.389]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:36.389]                     NULL
[13:23:36.389]                   }
[13:23:36.389]                   options(future.plan = NULL)
[13:23:36.389]                   if (is.na(NA_character_)) 
[13:23:36.389]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.389]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:36.389]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:36.389]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:36.389]                     envir = parent.frame()) 
[13:23:36.389]                   {
[13:23:36.389]                     if (is.function(workers)) 
[13:23:36.389]                       workers <- workers()
[13:23:36.389]                     workers <- structure(as.integer(workers), 
[13:23:36.389]                       class = class(workers))
[13:23:36.389]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:36.389]                       workers >= 1)
[13:23:36.389]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:36.389]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:36.389]                     }
[13:23:36.389]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:36.389]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:36.389]                       envir = envir)
[13:23:36.389]                     if (!future$lazy) 
[13:23:36.389]                       future <- run(future)
[13:23:36.389]                     invisible(future)
[13:23:36.389]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:36.389]                 }
[13:23:36.389]             }
[13:23:36.389]         }
[13:23:36.389]     })
[13:23:36.389]     if (TRUE) {
[13:23:36.389]         base::sink(type = "output", split = FALSE)
[13:23:36.389]         if (TRUE) {
[13:23:36.389]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:36.389]         }
[13:23:36.389]         else {
[13:23:36.389]             ...future.result["stdout"] <- base::list(NULL)
[13:23:36.389]         }
[13:23:36.389]         base::close(...future.stdout)
[13:23:36.389]         ...future.stdout <- NULL
[13:23:36.389]     }
[13:23:36.389]     ...future.result$conditions <- ...future.conditions
[13:23:36.389]     ...future.result$finished <- base::Sys.time()
[13:23:36.389]     ...future.result
[13:23:36.389] }
[13:23:36.392] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[13:23:36.392] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[13:23:36.392] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[13:23:36.392] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:23:36.393] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:23:36.393] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[13:23:36.393] MultisessionFuture started
[13:23:36.394] - Launch lazy future ... done
[13:23:36.394] run() for ‘MultisessionFuture’ ... done
[13:23:36.394] result() for ClusterFuture ...
[13:23:36.394] receiveMessageFromWorker() for ClusterFuture ...
[13:23:36.394] - Validating connection of MultisessionFuture
[13:23:36.441] - received message: FutureResult
[13:23:36.441] - Received FutureResult
[13:23:36.442] - Erased future from FutureRegistry
[13:23:36.442] result() for ClusterFuture ...
[13:23:36.442] - result already collected: FutureResult
[13:23:36.442] result() for ClusterFuture ... done
[13:23:36.442] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:36.442] result() for ClusterFuture ... done
[13:23:36.442] result() for ClusterFuture ...
[13:23:36.442] - result already collected: FutureResult
[13:23:36.442] result() for ClusterFuture ... done
[13:23:36.443] run() for ‘Future’ ...
[13:23:36.443] - state: ‘created’
[13:23:36.443] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:36.458] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:36.458] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:36.459]   - Field: ‘node’
[13:23:36.459]   - Field: ‘label’
[13:23:36.459]   - Field: ‘local’
[13:23:36.459]   - Field: ‘owner’
[13:23:36.459]   - Field: ‘envir’
[13:23:36.459]   - Field: ‘workers’
[13:23:36.459]   - Field: ‘packages’
[13:23:36.459]   - Field: ‘gc’
[13:23:36.459]   - Field: ‘conditions’
[13:23:36.459]   - Field: ‘persistent’
[13:23:36.459]   - Field: ‘expr’
[13:23:36.460]   - Field: ‘uuid’
[13:23:36.460]   - Field: ‘seed’
[13:23:36.460]   - Field: ‘version’
[13:23:36.460]   - Field: ‘result’
[13:23:36.460]   - Field: ‘asynchronous’
[13:23:36.460]   - Field: ‘calls’
[13:23:36.460]   - Field: ‘globals’
[13:23:36.460]   - Field: ‘stdout’
[13:23:36.460]   - Field: ‘earlySignal’
[13:23:36.460]   - Field: ‘lazy’
[13:23:36.461]   - Field: ‘state’
[13:23:36.461] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:36.461] - Launch lazy future ...
[13:23:36.461] Packages needed by the future expression (n = 0): <none>
[13:23:36.461] Packages needed by future strategies (n = 0): <none>
[13:23:36.462] {
[13:23:36.462]     {
[13:23:36.462]         {
[13:23:36.462]             ...future.startTime <- base::Sys.time()
[13:23:36.462]             {
[13:23:36.462]                 {
[13:23:36.462]                   {
[13:23:36.462]                     {
[13:23:36.462]                       base::local({
[13:23:36.462]                         has_future <- base::requireNamespace("future", 
[13:23:36.462]                           quietly = TRUE)
[13:23:36.462]                         if (has_future) {
[13:23:36.462]                           ns <- base::getNamespace("future")
[13:23:36.462]                           version <- ns[[".package"]][["version"]]
[13:23:36.462]                           if (is.null(version)) 
[13:23:36.462]                             version <- utils::packageVersion("future")
[13:23:36.462]                         }
[13:23:36.462]                         else {
[13:23:36.462]                           version <- NULL
[13:23:36.462]                         }
[13:23:36.462]                         if (!has_future || version < "1.8.0") {
[13:23:36.462]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:36.462]                             "", base::R.version$version.string), 
[13:23:36.462]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:36.462]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:36.462]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:36.462]                               "release", "version")], collapse = " "), 
[13:23:36.462]                             hostname = base::Sys.info()[["nodename"]])
[13:23:36.462]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:36.462]                             info)
[13:23:36.462]                           info <- base::paste(info, collapse = "; ")
[13:23:36.462]                           if (!has_future) {
[13:23:36.462]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:36.462]                               info)
[13:23:36.462]                           }
[13:23:36.462]                           else {
[13:23:36.462]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:36.462]                               info, version)
[13:23:36.462]                           }
[13:23:36.462]                           base::stop(msg)
[13:23:36.462]                         }
[13:23:36.462]                       })
[13:23:36.462]                     }
[13:23:36.462]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:36.462]                     base::options(mc.cores = 1L)
[13:23:36.462]                   }
[13:23:36.462]                   options(future.plan = NULL)
[13:23:36.462]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.462]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:36.462]                 }
[13:23:36.462]                 ...future.workdir <- getwd()
[13:23:36.462]             }
[13:23:36.462]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:36.462]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:36.462]         }
[13:23:36.462]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:36.462]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:36.462]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:36.462]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:36.462]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:36.462]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:36.462]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:36.462]             base::names(...future.oldOptions))
[13:23:36.462]     }
[13:23:36.462]     if (FALSE) {
[13:23:36.462]     }
[13:23:36.462]     else {
[13:23:36.462]         if (TRUE) {
[13:23:36.462]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:36.462]                 open = "w")
[13:23:36.462]         }
[13:23:36.462]         else {
[13:23:36.462]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:36.462]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:36.462]         }
[13:23:36.462]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:36.462]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:36.462]             base::sink(type = "output", split = FALSE)
[13:23:36.462]             base::close(...future.stdout)
[13:23:36.462]         }, add = TRUE)
[13:23:36.462]     }
[13:23:36.462]     ...future.frame <- base::sys.nframe()
[13:23:36.462]     ...future.conditions <- base::list()
[13:23:36.462]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:36.462]     if (FALSE) {
[13:23:36.462]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:36.462]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:36.462]     }
[13:23:36.462]     ...future.result <- base::tryCatch({
[13:23:36.462]         base::withCallingHandlers({
[13:23:36.462]             ...future.value <- base::withVisible(base::local({
[13:23:36.462]                 ...future.makeSendCondition <- base::local({
[13:23:36.462]                   sendCondition <- NULL
[13:23:36.462]                   function(frame = 1L) {
[13:23:36.462]                     if (is.function(sendCondition)) 
[13:23:36.462]                       return(sendCondition)
[13:23:36.462]                     ns <- getNamespace("parallel")
[13:23:36.462]                     if (exists("sendData", mode = "function", 
[13:23:36.462]                       envir = ns)) {
[13:23:36.462]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:36.462]                         envir = ns)
[13:23:36.462]                       envir <- sys.frame(frame)
[13:23:36.462]                       master <- NULL
[13:23:36.462]                       while (!identical(envir, .GlobalEnv) && 
[13:23:36.462]                         !identical(envir, emptyenv())) {
[13:23:36.462]                         if (exists("master", mode = "list", envir = envir, 
[13:23:36.462]                           inherits = FALSE)) {
[13:23:36.462]                           master <- get("master", mode = "list", 
[13:23:36.462]                             envir = envir, inherits = FALSE)
[13:23:36.462]                           if (inherits(master, c("SOCKnode", 
[13:23:36.462]                             "SOCK0node"))) {
[13:23:36.462]                             sendCondition <<- function(cond) {
[13:23:36.462]                               data <- list(type = "VALUE", value = cond, 
[13:23:36.462]                                 success = TRUE)
[13:23:36.462]                               parallel_sendData(master, data)
[13:23:36.462]                             }
[13:23:36.462]                             return(sendCondition)
[13:23:36.462]                           }
[13:23:36.462]                         }
[13:23:36.462]                         frame <- frame + 1L
[13:23:36.462]                         envir <- sys.frame(frame)
[13:23:36.462]                       }
[13:23:36.462]                     }
[13:23:36.462]                     sendCondition <<- function(cond) NULL
[13:23:36.462]                   }
[13:23:36.462]                 })
[13:23:36.462]                 withCallingHandlers({
[13:23:36.462]                   {
[13:23:36.462]                     b <- a * ii
[13:23:36.462]                     a <- 0
[13:23:36.462]                     b
[13:23:36.462]                   }
[13:23:36.462]                 }, immediateCondition = function(cond) {
[13:23:36.462]                   sendCondition <- ...future.makeSendCondition()
[13:23:36.462]                   sendCondition(cond)
[13:23:36.462]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.462]                   {
[13:23:36.462]                     inherits <- base::inherits
[13:23:36.462]                     invokeRestart <- base::invokeRestart
[13:23:36.462]                     is.null <- base::is.null
[13:23:36.462]                     muffled <- FALSE
[13:23:36.462]                     if (inherits(cond, "message")) {
[13:23:36.462]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:36.462]                       if (muffled) 
[13:23:36.462]                         invokeRestart("muffleMessage")
[13:23:36.462]                     }
[13:23:36.462]                     else if (inherits(cond, "warning")) {
[13:23:36.462]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:36.462]                       if (muffled) 
[13:23:36.462]                         invokeRestart("muffleWarning")
[13:23:36.462]                     }
[13:23:36.462]                     else if (inherits(cond, "condition")) {
[13:23:36.462]                       if (!is.null(pattern)) {
[13:23:36.462]                         computeRestarts <- base::computeRestarts
[13:23:36.462]                         grepl <- base::grepl
[13:23:36.462]                         restarts <- computeRestarts(cond)
[13:23:36.462]                         for (restart in restarts) {
[13:23:36.462]                           name <- restart$name
[13:23:36.462]                           if (is.null(name)) 
[13:23:36.462]                             next
[13:23:36.462]                           if (!grepl(pattern, name)) 
[13:23:36.462]                             next
[13:23:36.462]                           invokeRestart(restart)
[13:23:36.462]                           muffled <- TRUE
[13:23:36.462]                           break
[13:23:36.462]                         }
[13:23:36.462]                       }
[13:23:36.462]                     }
[13:23:36.462]                     invisible(muffled)
[13:23:36.462]                   }
[13:23:36.462]                   muffleCondition(cond)
[13:23:36.462]                 })
[13:23:36.462]             }))
[13:23:36.462]             future::FutureResult(value = ...future.value$value, 
[13:23:36.462]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.462]                   ...future.rng), globalenv = if (FALSE) 
[13:23:36.462]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:36.462]                     ...future.globalenv.names))
[13:23:36.462]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:36.462]         }, condition = base::local({
[13:23:36.462]             c <- base::c
[13:23:36.462]             inherits <- base::inherits
[13:23:36.462]             invokeRestart <- base::invokeRestart
[13:23:36.462]             length <- base::length
[13:23:36.462]             list <- base::list
[13:23:36.462]             seq.int <- base::seq.int
[13:23:36.462]             signalCondition <- base::signalCondition
[13:23:36.462]             sys.calls <- base::sys.calls
[13:23:36.462]             `[[` <- base::`[[`
[13:23:36.462]             `+` <- base::`+`
[13:23:36.462]             `<<-` <- base::`<<-`
[13:23:36.462]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:36.462]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:36.462]                   3L)]
[13:23:36.462]             }
[13:23:36.462]             function(cond) {
[13:23:36.462]                 is_error <- inherits(cond, "error")
[13:23:36.462]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:36.462]                   NULL)
[13:23:36.462]                 if (is_error) {
[13:23:36.462]                   sessionInformation <- function() {
[13:23:36.462]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:36.462]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:36.462]                       search = base::search(), system = base::Sys.info())
[13:23:36.462]                   }
[13:23:36.462]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.462]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:36.462]                     cond$call), session = sessionInformation(), 
[13:23:36.462]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:36.462]                   signalCondition(cond)
[13:23:36.462]                 }
[13:23:36.462]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:36.462]                 "immediateCondition"))) {
[13:23:36.462]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:36.462]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.462]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:36.462]                   if (TRUE && !signal) {
[13:23:36.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.462]                     {
[13:23:36.462]                       inherits <- base::inherits
[13:23:36.462]                       invokeRestart <- base::invokeRestart
[13:23:36.462]                       is.null <- base::is.null
[13:23:36.462]                       muffled <- FALSE
[13:23:36.462]                       if (inherits(cond, "message")) {
[13:23:36.462]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.462]                         if (muffled) 
[13:23:36.462]                           invokeRestart("muffleMessage")
[13:23:36.462]                       }
[13:23:36.462]                       else if (inherits(cond, "warning")) {
[13:23:36.462]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.462]                         if (muffled) 
[13:23:36.462]                           invokeRestart("muffleWarning")
[13:23:36.462]                       }
[13:23:36.462]                       else if (inherits(cond, "condition")) {
[13:23:36.462]                         if (!is.null(pattern)) {
[13:23:36.462]                           computeRestarts <- base::computeRestarts
[13:23:36.462]                           grepl <- base::grepl
[13:23:36.462]                           restarts <- computeRestarts(cond)
[13:23:36.462]                           for (restart in restarts) {
[13:23:36.462]                             name <- restart$name
[13:23:36.462]                             if (is.null(name)) 
[13:23:36.462]                               next
[13:23:36.462]                             if (!grepl(pattern, name)) 
[13:23:36.462]                               next
[13:23:36.462]                             invokeRestart(restart)
[13:23:36.462]                             muffled <- TRUE
[13:23:36.462]                             break
[13:23:36.462]                           }
[13:23:36.462]                         }
[13:23:36.462]                       }
[13:23:36.462]                       invisible(muffled)
[13:23:36.462]                     }
[13:23:36.462]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.462]                   }
[13:23:36.462]                 }
[13:23:36.462]                 else {
[13:23:36.462]                   if (TRUE) {
[13:23:36.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.462]                     {
[13:23:36.462]                       inherits <- base::inherits
[13:23:36.462]                       invokeRestart <- base::invokeRestart
[13:23:36.462]                       is.null <- base::is.null
[13:23:36.462]                       muffled <- FALSE
[13:23:36.462]                       if (inherits(cond, "message")) {
[13:23:36.462]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.462]                         if (muffled) 
[13:23:36.462]                           invokeRestart("muffleMessage")
[13:23:36.462]                       }
[13:23:36.462]                       else if (inherits(cond, "warning")) {
[13:23:36.462]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.462]                         if (muffled) 
[13:23:36.462]                           invokeRestart("muffleWarning")
[13:23:36.462]                       }
[13:23:36.462]                       else if (inherits(cond, "condition")) {
[13:23:36.462]                         if (!is.null(pattern)) {
[13:23:36.462]                           computeRestarts <- base::computeRestarts
[13:23:36.462]                           grepl <- base::grepl
[13:23:36.462]                           restarts <- computeRestarts(cond)
[13:23:36.462]                           for (restart in restarts) {
[13:23:36.462]                             name <- restart$name
[13:23:36.462]                             if (is.null(name)) 
[13:23:36.462]                               next
[13:23:36.462]                             if (!grepl(pattern, name)) 
[13:23:36.462]                               next
[13:23:36.462]                             invokeRestart(restart)
[13:23:36.462]                             muffled <- TRUE
[13:23:36.462]                             break
[13:23:36.462]                           }
[13:23:36.462]                         }
[13:23:36.462]                       }
[13:23:36.462]                       invisible(muffled)
[13:23:36.462]                     }
[13:23:36.462]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.462]                   }
[13:23:36.462]                 }
[13:23:36.462]             }
[13:23:36.462]         }))
[13:23:36.462]     }, error = function(ex) {
[13:23:36.462]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:36.462]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.462]                 ...future.rng), started = ...future.startTime, 
[13:23:36.462]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:36.462]             version = "1.8"), class = "FutureResult")
[13:23:36.462]     }, finally = {
[13:23:36.462]         if (!identical(...future.workdir, getwd())) 
[13:23:36.462]             setwd(...future.workdir)
[13:23:36.462]         {
[13:23:36.462]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:36.462]                 ...future.oldOptions$nwarnings <- NULL
[13:23:36.462]             }
[13:23:36.462]             base::options(...future.oldOptions)
[13:23:36.462]             if (.Platform$OS.type == "windows") {
[13:23:36.462]                 old_names <- names(...future.oldEnvVars)
[13:23:36.462]                 envs <- base::Sys.getenv()
[13:23:36.462]                 names <- names(envs)
[13:23:36.462]                 common <- intersect(names, old_names)
[13:23:36.462]                 added <- setdiff(names, old_names)
[13:23:36.462]                 removed <- setdiff(old_names, names)
[13:23:36.462]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:36.462]                   envs[common]]
[13:23:36.462]                 NAMES <- toupper(changed)
[13:23:36.462]                 args <- list()
[13:23:36.462]                 for (kk in seq_along(NAMES)) {
[13:23:36.462]                   name <- changed[[kk]]
[13:23:36.462]                   NAME <- NAMES[[kk]]
[13:23:36.462]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.462]                     next
[13:23:36.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.462]                 }
[13:23:36.462]                 NAMES <- toupper(added)
[13:23:36.462]                 for (kk in seq_along(NAMES)) {
[13:23:36.462]                   name <- added[[kk]]
[13:23:36.462]                   NAME <- NAMES[[kk]]
[13:23:36.462]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.462]                     next
[13:23:36.462]                   args[[name]] <- ""
[13:23:36.462]                 }
[13:23:36.462]                 NAMES <- toupper(removed)
[13:23:36.462]                 for (kk in seq_along(NAMES)) {
[13:23:36.462]                   name <- removed[[kk]]
[13:23:36.462]                   NAME <- NAMES[[kk]]
[13:23:36.462]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.462]                     next
[13:23:36.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.462]                 }
[13:23:36.462]                 if (length(args) > 0) 
[13:23:36.462]                   base::do.call(base::Sys.setenv, args = args)
[13:23:36.462]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:36.462]             }
[13:23:36.462]             else {
[13:23:36.462]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:36.462]             }
[13:23:36.462]             {
[13:23:36.462]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:36.462]                   0L) {
[13:23:36.462]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:36.462]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:36.462]                   base::options(opts)
[13:23:36.462]                 }
[13:23:36.462]                 {
[13:23:36.462]                   {
[13:23:36.462]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:36.462]                     NULL
[13:23:36.462]                   }
[13:23:36.462]                   options(future.plan = NULL)
[13:23:36.462]                   if (is.na(NA_character_)) 
[13:23:36.462]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.462]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:36.462]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:36.462]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:36.462]                     envir = parent.frame()) 
[13:23:36.462]                   {
[13:23:36.462]                     if (is.function(workers)) 
[13:23:36.462]                       workers <- workers()
[13:23:36.462]                     workers <- structure(as.integer(workers), 
[13:23:36.462]                       class = class(workers))
[13:23:36.462]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:36.462]                       workers >= 1)
[13:23:36.462]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:36.462]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:36.462]                     }
[13:23:36.462]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:36.462]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:36.462]                       envir = envir)
[13:23:36.462]                     if (!future$lazy) 
[13:23:36.462]                       future <- run(future)
[13:23:36.462]                     invisible(future)
[13:23:36.462]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:36.462]                 }
[13:23:36.462]             }
[13:23:36.462]         }
[13:23:36.462]     })
[13:23:36.462]     if (TRUE) {
[13:23:36.462]         base::sink(type = "output", split = FALSE)
[13:23:36.462]         if (TRUE) {
[13:23:36.462]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:36.462]         }
[13:23:36.462]         else {
[13:23:36.462]             ...future.result["stdout"] <- base::list(NULL)
[13:23:36.462]         }
[13:23:36.462]         base::close(...future.stdout)
[13:23:36.462]         ...future.stdout <- NULL
[13:23:36.462]     }
[13:23:36.462]     ...future.result$conditions <- ...future.conditions
[13:23:36.462]     ...future.result$finished <- base::Sys.time()
[13:23:36.462]     ...future.result
[13:23:36.462] }
[13:23:36.465] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[13:23:36.465] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[13:23:36.465] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[13:23:36.465] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:23:36.466] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:23:36.466] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[13:23:36.467] MultisessionFuture started
[13:23:36.467] - Launch lazy future ... done
[13:23:36.467] run() for ‘MultisessionFuture’ ... done
[13:23:36.467] result() for ClusterFuture ...
[13:23:36.467] receiveMessageFromWorker() for ClusterFuture ...
[13:23:36.467] - Validating connection of MultisessionFuture
[13:23:36.513] - received message: FutureResult
[13:23:36.514] - Received FutureResult
[13:23:36.514] - Erased future from FutureRegistry
[13:23:36.514] result() for ClusterFuture ...
[13:23:36.514] - result already collected: FutureResult
[13:23:36.514] result() for ClusterFuture ... done
[13:23:36.514] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:36.514] result() for ClusterFuture ... done
[13:23:36.515] result() for ClusterFuture ...
[13:23:36.515] - result already collected: FutureResult
[13:23:36.515] result() for ClusterFuture ... done
[13:23:36.515] run() for ‘Future’ ...
[13:23:36.515] - state: ‘created’
[13:23:36.515] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:36.530] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:36.530] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:36.530]   - Field: ‘node’
[13:23:36.530]   - Field: ‘label’
[13:23:36.530]   - Field: ‘local’
[13:23:36.531]   - Field: ‘owner’
[13:23:36.531]   - Field: ‘envir’
[13:23:36.531]   - Field: ‘workers’
[13:23:36.531]   - Field: ‘packages’
[13:23:36.531]   - Field: ‘gc’
[13:23:36.531]   - Field: ‘conditions’
[13:23:36.531]   - Field: ‘persistent’
[13:23:36.531]   - Field: ‘expr’
[13:23:36.531]   - Field: ‘uuid’
[13:23:36.531]   - Field: ‘seed’
[13:23:36.531]   - Field: ‘version’
[13:23:36.532]   - Field: ‘result’
[13:23:36.532]   - Field: ‘asynchronous’
[13:23:36.532]   - Field: ‘calls’
[13:23:36.532]   - Field: ‘globals’
[13:23:36.532]   - Field: ‘stdout’
[13:23:36.532]   - Field: ‘earlySignal’
[13:23:36.532]   - Field: ‘lazy’
[13:23:36.532]   - Field: ‘state’
[13:23:36.532] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:36.533] - Launch lazy future ...
[13:23:36.533] Packages needed by the future expression (n = 0): <none>
[13:23:36.533] Packages needed by future strategies (n = 0): <none>
[13:23:36.533] {
[13:23:36.533]     {
[13:23:36.533]         {
[13:23:36.533]             ...future.startTime <- base::Sys.time()
[13:23:36.533]             {
[13:23:36.533]                 {
[13:23:36.533]                   {
[13:23:36.533]                     {
[13:23:36.533]                       base::local({
[13:23:36.533]                         has_future <- base::requireNamespace("future", 
[13:23:36.533]                           quietly = TRUE)
[13:23:36.533]                         if (has_future) {
[13:23:36.533]                           ns <- base::getNamespace("future")
[13:23:36.533]                           version <- ns[[".package"]][["version"]]
[13:23:36.533]                           if (is.null(version)) 
[13:23:36.533]                             version <- utils::packageVersion("future")
[13:23:36.533]                         }
[13:23:36.533]                         else {
[13:23:36.533]                           version <- NULL
[13:23:36.533]                         }
[13:23:36.533]                         if (!has_future || version < "1.8.0") {
[13:23:36.533]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:36.533]                             "", base::R.version$version.string), 
[13:23:36.533]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:36.533]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:36.533]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:36.533]                               "release", "version")], collapse = " "), 
[13:23:36.533]                             hostname = base::Sys.info()[["nodename"]])
[13:23:36.533]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:36.533]                             info)
[13:23:36.533]                           info <- base::paste(info, collapse = "; ")
[13:23:36.533]                           if (!has_future) {
[13:23:36.533]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:36.533]                               info)
[13:23:36.533]                           }
[13:23:36.533]                           else {
[13:23:36.533]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:36.533]                               info, version)
[13:23:36.533]                           }
[13:23:36.533]                           base::stop(msg)
[13:23:36.533]                         }
[13:23:36.533]                       })
[13:23:36.533]                     }
[13:23:36.533]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:36.533]                     base::options(mc.cores = 1L)
[13:23:36.533]                   }
[13:23:36.533]                   options(future.plan = NULL)
[13:23:36.533]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.533]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:36.533]                 }
[13:23:36.533]                 ...future.workdir <- getwd()
[13:23:36.533]             }
[13:23:36.533]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:36.533]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:36.533]         }
[13:23:36.533]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:36.533]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:36.533]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:36.533]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:36.533]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:36.533]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:36.533]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:36.533]             base::names(...future.oldOptions))
[13:23:36.533]     }
[13:23:36.533]     if (FALSE) {
[13:23:36.533]     }
[13:23:36.533]     else {
[13:23:36.533]         if (TRUE) {
[13:23:36.533]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:36.533]                 open = "w")
[13:23:36.533]         }
[13:23:36.533]         else {
[13:23:36.533]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:36.533]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:36.533]         }
[13:23:36.533]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:36.533]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:36.533]             base::sink(type = "output", split = FALSE)
[13:23:36.533]             base::close(...future.stdout)
[13:23:36.533]         }, add = TRUE)
[13:23:36.533]     }
[13:23:36.533]     ...future.frame <- base::sys.nframe()
[13:23:36.533]     ...future.conditions <- base::list()
[13:23:36.533]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:36.533]     if (FALSE) {
[13:23:36.533]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:36.533]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:36.533]     }
[13:23:36.533]     ...future.result <- base::tryCatch({
[13:23:36.533]         base::withCallingHandlers({
[13:23:36.533]             ...future.value <- base::withVisible(base::local({
[13:23:36.533]                 ...future.makeSendCondition <- base::local({
[13:23:36.533]                   sendCondition <- NULL
[13:23:36.533]                   function(frame = 1L) {
[13:23:36.533]                     if (is.function(sendCondition)) 
[13:23:36.533]                       return(sendCondition)
[13:23:36.533]                     ns <- getNamespace("parallel")
[13:23:36.533]                     if (exists("sendData", mode = "function", 
[13:23:36.533]                       envir = ns)) {
[13:23:36.533]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:36.533]                         envir = ns)
[13:23:36.533]                       envir <- sys.frame(frame)
[13:23:36.533]                       master <- NULL
[13:23:36.533]                       while (!identical(envir, .GlobalEnv) && 
[13:23:36.533]                         !identical(envir, emptyenv())) {
[13:23:36.533]                         if (exists("master", mode = "list", envir = envir, 
[13:23:36.533]                           inherits = FALSE)) {
[13:23:36.533]                           master <- get("master", mode = "list", 
[13:23:36.533]                             envir = envir, inherits = FALSE)
[13:23:36.533]                           if (inherits(master, c("SOCKnode", 
[13:23:36.533]                             "SOCK0node"))) {
[13:23:36.533]                             sendCondition <<- function(cond) {
[13:23:36.533]                               data <- list(type = "VALUE", value = cond, 
[13:23:36.533]                                 success = TRUE)
[13:23:36.533]                               parallel_sendData(master, data)
[13:23:36.533]                             }
[13:23:36.533]                             return(sendCondition)
[13:23:36.533]                           }
[13:23:36.533]                         }
[13:23:36.533]                         frame <- frame + 1L
[13:23:36.533]                         envir <- sys.frame(frame)
[13:23:36.533]                       }
[13:23:36.533]                     }
[13:23:36.533]                     sendCondition <<- function(cond) NULL
[13:23:36.533]                   }
[13:23:36.533]                 })
[13:23:36.533]                 withCallingHandlers({
[13:23:36.533]                   {
[13:23:36.533]                     b <- a * ii
[13:23:36.533]                     a <- 0
[13:23:36.533]                     b
[13:23:36.533]                   }
[13:23:36.533]                 }, immediateCondition = function(cond) {
[13:23:36.533]                   sendCondition <- ...future.makeSendCondition()
[13:23:36.533]                   sendCondition(cond)
[13:23:36.533]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.533]                   {
[13:23:36.533]                     inherits <- base::inherits
[13:23:36.533]                     invokeRestart <- base::invokeRestart
[13:23:36.533]                     is.null <- base::is.null
[13:23:36.533]                     muffled <- FALSE
[13:23:36.533]                     if (inherits(cond, "message")) {
[13:23:36.533]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:36.533]                       if (muffled) 
[13:23:36.533]                         invokeRestart("muffleMessage")
[13:23:36.533]                     }
[13:23:36.533]                     else if (inherits(cond, "warning")) {
[13:23:36.533]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:36.533]                       if (muffled) 
[13:23:36.533]                         invokeRestart("muffleWarning")
[13:23:36.533]                     }
[13:23:36.533]                     else if (inherits(cond, "condition")) {
[13:23:36.533]                       if (!is.null(pattern)) {
[13:23:36.533]                         computeRestarts <- base::computeRestarts
[13:23:36.533]                         grepl <- base::grepl
[13:23:36.533]                         restarts <- computeRestarts(cond)
[13:23:36.533]                         for (restart in restarts) {
[13:23:36.533]                           name <- restart$name
[13:23:36.533]                           if (is.null(name)) 
[13:23:36.533]                             next
[13:23:36.533]                           if (!grepl(pattern, name)) 
[13:23:36.533]                             next
[13:23:36.533]                           invokeRestart(restart)
[13:23:36.533]                           muffled <- TRUE
[13:23:36.533]                           break
[13:23:36.533]                         }
[13:23:36.533]                       }
[13:23:36.533]                     }
[13:23:36.533]                     invisible(muffled)
[13:23:36.533]                   }
[13:23:36.533]                   muffleCondition(cond)
[13:23:36.533]                 })
[13:23:36.533]             }))
[13:23:36.533]             future::FutureResult(value = ...future.value$value, 
[13:23:36.533]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.533]                   ...future.rng), globalenv = if (FALSE) 
[13:23:36.533]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:36.533]                     ...future.globalenv.names))
[13:23:36.533]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:36.533]         }, condition = base::local({
[13:23:36.533]             c <- base::c
[13:23:36.533]             inherits <- base::inherits
[13:23:36.533]             invokeRestart <- base::invokeRestart
[13:23:36.533]             length <- base::length
[13:23:36.533]             list <- base::list
[13:23:36.533]             seq.int <- base::seq.int
[13:23:36.533]             signalCondition <- base::signalCondition
[13:23:36.533]             sys.calls <- base::sys.calls
[13:23:36.533]             `[[` <- base::`[[`
[13:23:36.533]             `+` <- base::`+`
[13:23:36.533]             `<<-` <- base::`<<-`
[13:23:36.533]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:36.533]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:36.533]                   3L)]
[13:23:36.533]             }
[13:23:36.533]             function(cond) {
[13:23:36.533]                 is_error <- inherits(cond, "error")
[13:23:36.533]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:36.533]                   NULL)
[13:23:36.533]                 if (is_error) {
[13:23:36.533]                   sessionInformation <- function() {
[13:23:36.533]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:36.533]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:36.533]                       search = base::search(), system = base::Sys.info())
[13:23:36.533]                   }
[13:23:36.533]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.533]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:36.533]                     cond$call), session = sessionInformation(), 
[13:23:36.533]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:36.533]                   signalCondition(cond)
[13:23:36.533]                 }
[13:23:36.533]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:36.533]                 "immediateCondition"))) {
[13:23:36.533]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:36.533]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.533]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:36.533]                   if (TRUE && !signal) {
[13:23:36.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.533]                     {
[13:23:36.533]                       inherits <- base::inherits
[13:23:36.533]                       invokeRestart <- base::invokeRestart
[13:23:36.533]                       is.null <- base::is.null
[13:23:36.533]                       muffled <- FALSE
[13:23:36.533]                       if (inherits(cond, "message")) {
[13:23:36.533]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.533]                         if (muffled) 
[13:23:36.533]                           invokeRestart("muffleMessage")
[13:23:36.533]                       }
[13:23:36.533]                       else if (inherits(cond, "warning")) {
[13:23:36.533]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.533]                         if (muffled) 
[13:23:36.533]                           invokeRestart("muffleWarning")
[13:23:36.533]                       }
[13:23:36.533]                       else if (inherits(cond, "condition")) {
[13:23:36.533]                         if (!is.null(pattern)) {
[13:23:36.533]                           computeRestarts <- base::computeRestarts
[13:23:36.533]                           grepl <- base::grepl
[13:23:36.533]                           restarts <- computeRestarts(cond)
[13:23:36.533]                           for (restart in restarts) {
[13:23:36.533]                             name <- restart$name
[13:23:36.533]                             if (is.null(name)) 
[13:23:36.533]                               next
[13:23:36.533]                             if (!grepl(pattern, name)) 
[13:23:36.533]                               next
[13:23:36.533]                             invokeRestart(restart)
[13:23:36.533]                             muffled <- TRUE
[13:23:36.533]                             break
[13:23:36.533]                           }
[13:23:36.533]                         }
[13:23:36.533]                       }
[13:23:36.533]                       invisible(muffled)
[13:23:36.533]                     }
[13:23:36.533]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.533]                   }
[13:23:36.533]                 }
[13:23:36.533]                 else {
[13:23:36.533]                   if (TRUE) {
[13:23:36.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.533]                     {
[13:23:36.533]                       inherits <- base::inherits
[13:23:36.533]                       invokeRestart <- base::invokeRestart
[13:23:36.533]                       is.null <- base::is.null
[13:23:36.533]                       muffled <- FALSE
[13:23:36.533]                       if (inherits(cond, "message")) {
[13:23:36.533]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.533]                         if (muffled) 
[13:23:36.533]                           invokeRestart("muffleMessage")
[13:23:36.533]                       }
[13:23:36.533]                       else if (inherits(cond, "warning")) {
[13:23:36.533]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.533]                         if (muffled) 
[13:23:36.533]                           invokeRestart("muffleWarning")
[13:23:36.533]                       }
[13:23:36.533]                       else if (inherits(cond, "condition")) {
[13:23:36.533]                         if (!is.null(pattern)) {
[13:23:36.533]                           computeRestarts <- base::computeRestarts
[13:23:36.533]                           grepl <- base::grepl
[13:23:36.533]                           restarts <- computeRestarts(cond)
[13:23:36.533]                           for (restart in restarts) {
[13:23:36.533]                             name <- restart$name
[13:23:36.533]                             if (is.null(name)) 
[13:23:36.533]                               next
[13:23:36.533]                             if (!grepl(pattern, name)) 
[13:23:36.533]                               next
[13:23:36.533]                             invokeRestart(restart)
[13:23:36.533]                             muffled <- TRUE
[13:23:36.533]                             break
[13:23:36.533]                           }
[13:23:36.533]                         }
[13:23:36.533]                       }
[13:23:36.533]                       invisible(muffled)
[13:23:36.533]                     }
[13:23:36.533]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.533]                   }
[13:23:36.533]                 }
[13:23:36.533]             }
[13:23:36.533]         }))
[13:23:36.533]     }, error = function(ex) {
[13:23:36.533]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:36.533]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.533]                 ...future.rng), started = ...future.startTime, 
[13:23:36.533]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:36.533]             version = "1.8"), class = "FutureResult")
[13:23:36.533]     }, finally = {
[13:23:36.533]         if (!identical(...future.workdir, getwd())) 
[13:23:36.533]             setwd(...future.workdir)
[13:23:36.533]         {
[13:23:36.533]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:36.533]                 ...future.oldOptions$nwarnings <- NULL
[13:23:36.533]             }
[13:23:36.533]             base::options(...future.oldOptions)
[13:23:36.533]             if (.Platform$OS.type == "windows") {
[13:23:36.533]                 old_names <- names(...future.oldEnvVars)
[13:23:36.533]                 envs <- base::Sys.getenv()
[13:23:36.533]                 names <- names(envs)
[13:23:36.533]                 common <- intersect(names, old_names)
[13:23:36.533]                 added <- setdiff(names, old_names)
[13:23:36.533]                 removed <- setdiff(old_names, names)
[13:23:36.533]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:36.533]                   envs[common]]
[13:23:36.533]                 NAMES <- toupper(changed)
[13:23:36.533]                 args <- list()
[13:23:36.533]                 for (kk in seq_along(NAMES)) {
[13:23:36.533]                   name <- changed[[kk]]
[13:23:36.533]                   NAME <- NAMES[[kk]]
[13:23:36.533]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.533]                     next
[13:23:36.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.533]                 }
[13:23:36.533]                 NAMES <- toupper(added)
[13:23:36.533]                 for (kk in seq_along(NAMES)) {
[13:23:36.533]                   name <- added[[kk]]
[13:23:36.533]                   NAME <- NAMES[[kk]]
[13:23:36.533]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.533]                     next
[13:23:36.533]                   args[[name]] <- ""
[13:23:36.533]                 }
[13:23:36.533]                 NAMES <- toupper(removed)
[13:23:36.533]                 for (kk in seq_along(NAMES)) {
[13:23:36.533]                   name <- removed[[kk]]
[13:23:36.533]                   NAME <- NAMES[[kk]]
[13:23:36.533]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.533]                     next
[13:23:36.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.533]                 }
[13:23:36.533]                 if (length(args) > 0) 
[13:23:36.533]                   base::do.call(base::Sys.setenv, args = args)
[13:23:36.533]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:36.533]             }
[13:23:36.533]             else {
[13:23:36.533]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:36.533]             }
[13:23:36.533]             {
[13:23:36.533]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:36.533]                   0L) {
[13:23:36.533]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:36.533]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:36.533]                   base::options(opts)
[13:23:36.533]                 }
[13:23:36.533]                 {
[13:23:36.533]                   {
[13:23:36.533]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:36.533]                     NULL
[13:23:36.533]                   }
[13:23:36.533]                   options(future.plan = NULL)
[13:23:36.533]                   if (is.na(NA_character_)) 
[13:23:36.533]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.533]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:36.533]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:36.533]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:36.533]                     envir = parent.frame()) 
[13:23:36.533]                   {
[13:23:36.533]                     if (is.function(workers)) 
[13:23:36.533]                       workers <- workers()
[13:23:36.533]                     workers <- structure(as.integer(workers), 
[13:23:36.533]                       class = class(workers))
[13:23:36.533]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:36.533]                       workers >= 1)
[13:23:36.533]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:36.533]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:36.533]                     }
[13:23:36.533]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:36.533]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:36.533]                       envir = envir)
[13:23:36.533]                     if (!future$lazy) 
[13:23:36.533]                       future <- run(future)
[13:23:36.533]                     invisible(future)
[13:23:36.533]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:36.533]                 }
[13:23:36.533]             }
[13:23:36.533]         }
[13:23:36.533]     })
[13:23:36.533]     if (TRUE) {
[13:23:36.533]         base::sink(type = "output", split = FALSE)
[13:23:36.533]         if (TRUE) {
[13:23:36.533]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:36.533]         }
[13:23:36.533]         else {
[13:23:36.533]             ...future.result["stdout"] <- base::list(NULL)
[13:23:36.533]         }
[13:23:36.533]         base::close(...future.stdout)
[13:23:36.533]         ...future.stdout <- NULL
[13:23:36.533]     }
[13:23:36.533]     ...future.result$conditions <- ...future.conditions
[13:23:36.533]     ...future.result$finished <- base::Sys.time()
[13:23:36.533]     ...future.result
[13:23:36.533] }
[13:23:36.536] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[13:23:36.537] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[13:23:36.537] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[13:23:36.537] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:23:36.537] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:23:36.538] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[13:23:36.538] MultisessionFuture started
[13:23:36.538] - Launch lazy future ... done
[13:23:36.538] run() for ‘MultisessionFuture’ ... done
[13:23:36.538] result() for ClusterFuture ...
[13:23:36.539] receiveMessageFromWorker() for ClusterFuture ...
[13:23:36.539] - Validating connection of MultisessionFuture
[13:23:36.585] - received message: FutureResult
[13:23:36.586] - Received FutureResult
[13:23:36.586] - Erased future from FutureRegistry
[13:23:36.586] result() for ClusterFuture ...
[13:23:36.586] - result already collected: FutureResult
[13:23:36.586] result() for ClusterFuture ... done
[13:23:36.586] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:36.586] result() for ClusterFuture ... done
[13:23:36.586] result() for ClusterFuture ...
[13:23:36.586] - result already collected: FutureResult
[13:23:36.587] result() for ClusterFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:36.587] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:36.587] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:36.588] 
[13:23:36.588] Searching for globals ... DONE
[13:23:36.588] - globals: [0] <none>
[13:23:36.588] getGlobalsAndPackages() ... DONE
[13:23:36.588] run() for ‘Future’ ...
[13:23:36.588] - state: ‘created’
[13:23:36.588] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:36.602] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:36.603] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:36.603]   - Field: ‘node’
[13:23:36.603]   - Field: ‘label’
[13:23:36.603]   - Field: ‘local’
[13:23:36.603]   - Field: ‘owner’
[13:23:36.603]   - Field: ‘envir’
[13:23:36.603]   - Field: ‘workers’
[13:23:36.603]   - Field: ‘packages’
[13:23:36.603]   - Field: ‘gc’
[13:23:36.604]   - Field: ‘conditions’
[13:23:36.604]   - Field: ‘persistent’
[13:23:36.604]   - Field: ‘expr’
[13:23:36.604]   - Field: ‘uuid’
[13:23:36.604]   - Field: ‘seed’
[13:23:36.604]   - Field: ‘version’
[13:23:36.604]   - Field: ‘result’
[13:23:36.604]   - Field: ‘asynchronous’
[13:23:36.604]   - Field: ‘calls’
[13:23:36.604]   - Field: ‘globals’
[13:23:36.605]   - Field: ‘stdout’
[13:23:36.605]   - Field: ‘earlySignal’
[13:23:36.605]   - Field: ‘lazy’
[13:23:36.605]   - Field: ‘state’
[13:23:36.605] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:36.605] - Launch lazy future ...
[13:23:36.605] Packages needed by the future expression (n = 0): <none>
[13:23:36.605] Packages needed by future strategies (n = 0): <none>
[13:23:36.606] {
[13:23:36.606]     {
[13:23:36.606]         {
[13:23:36.606]             ...future.startTime <- base::Sys.time()
[13:23:36.606]             {
[13:23:36.606]                 {
[13:23:36.606]                   {
[13:23:36.606]                     {
[13:23:36.606]                       base::local({
[13:23:36.606]                         has_future <- base::requireNamespace("future", 
[13:23:36.606]                           quietly = TRUE)
[13:23:36.606]                         if (has_future) {
[13:23:36.606]                           ns <- base::getNamespace("future")
[13:23:36.606]                           version <- ns[[".package"]][["version"]]
[13:23:36.606]                           if (is.null(version)) 
[13:23:36.606]                             version <- utils::packageVersion("future")
[13:23:36.606]                         }
[13:23:36.606]                         else {
[13:23:36.606]                           version <- NULL
[13:23:36.606]                         }
[13:23:36.606]                         if (!has_future || version < "1.8.0") {
[13:23:36.606]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:36.606]                             "", base::R.version$version.string), 
[13:23:36.606]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:36.606]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:36.606]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:36.606]                               "release", "version")], collapse = " "), 
[13:23:36.606]                             hostname = base::Sys.info()[["nodename"]])
[13:23:36.606]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:36.606]                             info)
[13:23:36.606]                           info <- base::paste(info, collapse = "; ")
[13:23:36.606]                           if (!has_future) {
[13:23:36.606]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:36.606]                               info)
[13:23:36.606]                           }
[13:23:36.606]                           else {
[13:23:36.606]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:36.606]                               info, version)
[13:23:36.606]                           }
[13:23:36.606]                           base::stop(msg)
[13:23:36.606]                         }
[13:23:36.606]                       })
[13:23:36.606]                     }
[13:23:36.606]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:36.606]                     base::options(mc.cores = 1L)
[13:23:36.606]                   }
[13:23:36.606]                   options(future.plan = NULL)
[13:23:36.606]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.606]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:36.606]                 }
[13:23:36.606]                 ...future.workdir <- getwd()
[13:23:36.606]             }
[13:23:36.606]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:36.606]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:36.606]         }
[13:23:36.606]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:36.606]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:36.606]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:36.606]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:36.606]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:36.606]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:36.606]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:36.606]             base::names(...future.oldOptions))
[13:23:36.606]     }
[13:23:36.606]     if (FALSE) {
[13:23:36.606]     }
[13:23:36.606]     else {
[13:23:36.606]         if (TRUE) {
[13:23:36.606]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:36.606]                 open = "w")
[13:23:36.606]         }
[13:23:36.606]         else {
[13:23:36.606]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:36.606]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:36.606]         }
[13:23:36.606]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:36.606]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:36.606]             base::sink(type = "output", split = FALSE)
[13:23:36.606]             base::close(...future.stdout)
[13:23:36.606]         }, add = TRUE)
[13:23:36.606]     }
[13:23:36.606]     ...future.frame <- base::sys.nframe()
[13:23:36.606]     ...future.conditions <- base::list()
[13:23:36.606]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:36.606]     if (FALSE) {
[13:23:36.606]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:36.606]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:36.606]     }
[13:23:36.606]     ...future.result <- base::tryCatch({
[13:23:36.606]         base::withCallingHandlers({
[13:23:36.606]             ...future.value <- base::withVisible(base::local({
[13:23:36.606]                 ...future.makeSendCondition <- base::local({
[13:23:36.606]                   sendCondition <- NULL
[13:23:36.606]                   function(frame = 1L) {
[13:23:36.606]                     if (is.function(sendCondition)) 
[13:23:36.606]                       return(sendCondition)
[13:23:36.606]                     ns <- getNamespace("parallel")
[13:23:36.606]                     if (exists("sendData", mode = "function", 
[13:23:36.606]                       envir = ns)) {
[13:23:36.606]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:36.606]                         envir = ns)
[13:23:36.606]                       envir <- sys.frame(frame)
[13:23:36.606]                       master <- NULL
[13:23:36.606]                       while (!identical(envir, .GlobalEnv) && 
[13:23:36.606]                         !identical(envir, emptyenv())) {
[13:23:36.606]                         if (exists("master", mode = "list", envir = envir, 
[13:23:36.606]                           inherits = FALSE)) {
[13:23:36.606]                           master <- get("master", mode = "list", 
[13:23:36.606]                             envir = envir, inherits = FALSE)
[13:23:36.606]                           if (inherits(master, c("SOCKnode", 
[13:23:36.606]                             "SOCK0node"))) {
[13:23:36.606]                             sendCondition <<- function(cond) {
[13:23:36.606]                               data <- list(type = "VALUE", value = cond, 
[13:23:36.606]                                 success = TRUE)
[13:23:36.606]                               parallel_sendData(master, data)
[13:23:36.606]                             }
[13:23:36.606]                             return(sendCondition)
[13:23:36.606]                           }
[13:23:36.606]                         }
[13:23:36.606]                         frame <- frame + 1L
[13:23:36.606]                         envir <- sys.frame(frame)
[13:23:36.606]                       }
[13:23:36.606]                     }
[13:23:36.606]                     sendCondition <<- function(cond) NULL
[13:23:36.606]                   }
[13:23:36.606]                 })
[13:23:36.606]                 withCallingHandlers({
[13:23:36.606]                   1
[13:23:36.606]                 }, immediateCondition = function(cond) {
[13:23:36.606]                   sendCondition <- ...future.makeSendCondition()
[13:23:36.606]                   sendCondition(cond)
[13:23:36.606]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.606]                   {
[13:23:36.606]                     inherits <- base::inherits
[13:23:36.606]                     invokeRestart <- base::invokeRestart
[13:23:36.606]                     is.null <- base::is.null
[13:23:36.606]                     muffled <- FALSE
[13:23:36.606]                     if (inherits(cond, "message")) {
[13:23:36.606]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:36.606]                       if (muffled) 
[13:23:36.606]                         invokeRestart("muffleMessage")
[13:23:36.606]                     }
[13:23:36.606]                     else if (inherits(cond, "warning")) {
[13:23:36.606]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:36.606]                       if (muffled) 
[13:23:36.606]                         invokeRestart("muffleWarning")
[13:23:36.606]                     }
[13:23:36.606]                     else if (inherits(cond, "condition")) {
[13:23:36.606]                       if (!is.null(pattern)) {
[13:23:36.606]                         computeRestarts <- base::computeRestarts
[13:23:36.606]                         grepl <- base::grepl
[13:23:36.606]                         restarts <- computeRestarts(cond)
[13:23:36.606]                         for (restart in restarts) {
[13:23:36.606]                           name <- restart$name
[13:23:36.606]                           if (is.null(name)) 
[13:23:36.606]                             next
[13:23:36.606]                           if (!grepl(pattern, name)) 
[13:23:36.606]                             next
[13:23:36.606]                           invokeRestart(restart)
[13:23:36.606]                           muffled <- TRUE
[13:23:36.606]                           break
[13:23:36.606]                         }
[13:23:36.606]                       }
[13:23:36.606]                     }
[13:23:36.606]                     invisible(muffled)
[13:23:36.606]                   }
[13:23:36.606]                   muffleCondition(cond)
[13:23:36.606]                 })
[13:23:36.606]             }))
[13:23:36.606]             future::FutureResult(value = ...future.value$value, 
[13:23:36.606]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.606]                   ...future.rng), globalenv = if (FALSE) 
[13:23:36.606]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:36.606]                     ...future.globalenv.names))
[13:23:36.606]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:36.606]         }, condition = base::local({
[13:23:36.606]             c <- base::c
[13:23:36.606]             inherits <- base::inherits
[13:23:36.606]             invokeRestart <- base::invokeRestart
[13:23:36.606]             length <- base::length
[13:23:36.606]             list <- base::list
[13:23:36.606]             seq.int <- base::seq.int
[13:23:36.606]             signalCondition <- base::signalCondition
[13:23:36.606]             sys.calls <- base::sys.calls
[13:23:36.606]             `[[` <- base::`[[`
[13:23:36.606]             `+` <- base::`+`
[13:23:36.606]             `<<-` <- base::`<<-`
[13:23:36.606]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:36.606]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:36.606]                   3L)]
[13:23:36.606]             }
[13:23:36.606]             function(cond) {
[13:23:36.606]                 is_error <- inherits(cond, "error")
[13:23:36.606]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:36.606]                   NULL)
[13:23:36.606]                 if (is_error) {
[13:23:36.606]                   sessionInformation <- function() {
[13:23:36.606]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:36.606]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:36.606]                       search = base::search(), system = base::Sys.info())
[13:23:36.606]                   }
[13:23:36.606]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.606]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:36.606]                     cond$call), session = sessionInformation(), 
[13:23:36.606]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:36.606]                   signalCondition(cond)
[13:23:36.606]                 }
[13:23:36.606]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:36.606]                 "immediateCondition"))) {
[13:23:36.606]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:36.606]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.606]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:36.606]                   if (TRUE && !signal) {
[13:23:36.606]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.606]                     {
[13:23:36.606]                       inherits <- base::inherits
[13:23:36.606]                       invokeRestart <- base::invokeRestart
[13:23:36.606]                       is.null <- base::is.null
[13:23:36.606]                       muffled <- FALSE
[13:23:36.606]                       if (inherits(cond, "message")) {
[13:23:36.606]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.606]                         if (muffled) 
[13:23:36.606]                           invokeRestart("muffleMessage")
[13:23:36.606]                       }
[13:23:36.606]                       else if (inherits(cond, "warning")) {
[13:23:36.606]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.606]                         if (muffled) 
[13:23:36.606]                           invokeRestart("muffleWarning")
[13:23:36.606]                       }
[13:23:36.606]                       else if (inherits(cond, "condition")) {
[13:23:36.606]                         if (!is.null(pattern)) {
[13:23:36.606]                           computeRestarts <- base::computeRestarts
[13:23:36.606]                           grepl <- base::grepl
[13:23:36.606]                           restarts <- computeRestarts(cond)
[13:23:36.606]                           for (restart in restarts) {
[13:23:36.606]                             name <- restart$name
[13:23:36.606]                             if (is.null(name)) 
[13:23:36.606]                               next
[13:23:36.606]                             if (!grepl(pattern, name)) 
[13:23:36.606]                               next
[13:23:36.606]                             invokeRestart(restart)
[13:23:36.606]                             muffled <- TRUE
[13:23:36.606]                             break
[13:23:36.606]                           }
[13:23:36.606]                         }
[13:23:36.606]                       }
[13:23:36.606]                       invisible(muffled)
[13:23:36.606]                     }
[13:23:36.606]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.606]                   }
[13:23:36.606]                 }
[13:23:36.606]                 else {
[13:23:36.606]                   if (TRUE) {
[13:23:36.606]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.606]                     {
[13:23:36.606]                       inherits <- base::inherits
[13:23:36.606]                       invokeRestart <- base::invokeRestart
[13:23:36.606]                       is.null <- base::is.null
[13:23:36.606]                       muffled <- FALSE
[13:23:36.606]                       if (inherits(cond, "message")) {
[13:23:36.606]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.606]                         if (muffled) 
[13:23:36.606]                           invokeRestart("muffleMessage")
[13:23:36.606]                       }
[13:23:36.606]                       else if (inherits(cond, "warning")) {
[13:23:36.606]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.606]                         if (muffled) 
[13:23:36.606]                           invokeRestart("muffleWarning")
[13:23:36.606]                       }
[13:23:36.606]                       else if (inherits(cond, "condition")) {
[13:23:36.606]                         if (!is.null(pattern)) {
[13:23:36.606]                           computeRestarts <- base::computeRestarts
[13:23:36.606]                           grepl <- base::grepl
[13:23:36.606]                           restarts <- computeRestarts(cond)
[13:23:36.606]                           for (restart in restarts) {
[13:23:36.606]                             name <- restart$name
[13:23:36.606]                             if (is.null(name)) 
[13:23:36.606]                               next
[13:23:36.606]                             if (!grepl(pattern, name)) 
[13:23:36.606]                               next
[13:23:36.606]                             invokeRestart(restart)
[13:23:36.606]                             muffled <- TRUE
[13:23:36.606]                             break
[13:23:36.606]                           }
[13:23:36.606]                         }
[13:23:36.606]                       }
[13:23:36.606]                       invisible(muffled)
[13:23:36.606]                     }
[13:23:36.606]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.606]                   }
[13:23:36.606]                 }
[13:23:36.606]             }
[13:23:36.606]         }))
[13:23:36.606]     }, error = function(ex) {
[13:23:36.606]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:36.606]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.606]                 ...future.rng), started = ...future.startTime, 
[13:23:36.606]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:36.606]             version = "1.8"), class = "FutureResult")
[13:23:36.606]     }, finally = {
[13:23:36.606]         if (!identical(...future.workdir, getwd())) 
[13:23:36.606]             setwd(...future.workdir)
[13:23:36.606]         {
[13:23:36.606]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:36.606]                 ...future.oldOptions$nwarnings <- NULL
[13:23:36.606]             }
[13:23:36.606]             base::options(...future.oldOptions)
[13:23:36.606]             if (.Platform$OS.type == "windows") {
[13:23:36.606]                 old_names <- names(...future.oldEnvVars)
[13:23:36.606]                 envs <- base::Sys.getenv()
[13:23:36.606]                 names <- names(envs)
[13:23:36.606]                 common <- intersect(names, old_names)
[13:23:36.606]                 added <- setdiff(names, old_names)
[13:23:36.606]                 removed <- setdiff(old_names, names)
[13:23:36.606]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:36.606]                   envs[common]]
[13:23:36.606]                 NAMES <- toupper(changed)
[13:23:36.606]                 args <- list()
[13:23:36.606]                 for (kk in seq_along(NAMES)) {
[13:23:36.606]                   name <- changed[[kk]]
[13:23:36.606]                   NAME <- NAMES[[kk]]
[13:23:36.606]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.606]                     next
[13:23:36.606]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.606]                 }
[13:23:36.606]                 NAMES <- toupper(added)
[13:23:36.606]                 for (kk in seq_along(NAMES)) {
[13:23:36.606]                   name <- added[[kk]]
[13:23:36.606]                   NAME <- NAMES[[kk]]
[13:23:36.606]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.606]                     next
[13:23:36.606]                   args[[name]] <- ""
[13:23:36.606]                 }
[13:23:36.606]                 NAMES <- toupper(removed)
[13:23:36.606]                 for (kk in seq_along(NAMES)) {
[13:23:36.606]                   name <- removed[[kk]]
[13:23:36.606]                   NAME <- NAMES[[kk]]
[13:23:36.606]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.606]                     next
[13:23:36.606]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.606]                 }
[13:23:36.606]                 if (length(args) > 0) 
[13:23:36.606]                   base::do.call(base::Sys.setenv, args = args)
[13:23:36.606]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:36.606]             }
[13:23:36.606]             else {
[13:23:36.606]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:36.606]             }
[13:23:36.606]             {
[13:23:36.606]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:36.606]                   0L) {
[13:23:36.606]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:36.606]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:36.606]                   base::options(opts)
[13:23:36.606]                 }
[13:23:36.606]                 {
[13:23:36.606]                   {
[13:23:36.606]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:36.606]                     NULL
[13:23:36.606]                   }
[13:23:36.606]                   options(future.plan = NULL)
[13:23:36.606]                   if (is.na(NA_character_)) 
[13:23:36.606]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.606]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:36.606]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:36.606]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:36.606]                     envir = parent.frame()) 
[13:23:36.606]                   {
[13:23:36.606]                     if (is.function(workers)) 
[13:23:36.606]                       workers <- workers()
[13:23:36.606]                     workers <- structure(as.integer(workers), 
[13:23:36.606]                       class = class(workers))
[13:23:36.606]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:36.606]                       workers >= 1)
[13:23:36.606]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:36.606]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:36.606]                     }
[13:23:36.606]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:36.606]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:36.606]                       envir = envir)
[13:23:36.606]                     if (!future$lazy) 
[13:23:36.606]                       future <- run(future)
[13:23:36.606]                     invisible(future)
[13:23:36.606]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:36.606]                 }
[13:23:36.606]             }
[13:23:36.606]         }
[13:23:36.606]     })
[13:23:36.606]     if (TRUE) {
[13:23:36.606]         base::sink(type = "output", split = FALSE)
[13:23:36.606]         if (TRUE) {
[13:23:36.606]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:36.606]         }
[13:23:36.606]         else {
[13:23:36.606]             ...future.result["stdout"] <- base::list(NULL)
[13:23:36.606]         }
[13:23:36.606]         base::close(...future.stdout)
[13:23:36.606]         ...future.stdout <- NULL
[13:23:36.606]     }
[13:23:36.606]     ...future.result$conditions <- ...future.conditions
[13:23:36.606]     ...future.result$finished <- base::Sys.time()
[13:23:36.606]     ...future.result
[13:23:36.606] }
[13:23:36.609] MultisessionFuture started
[13:23:36.609] - Launch lazy future ... done
[13:23:36.609] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:36.610] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:36.610] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:36.611] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:36.611] Searching for globals ... DONE
[13:23:36.611] Resolving globals: TRUE
[13:23:36.611] Resolving any globals that are futures ...
[13:23:36.611] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:36.611] Resolving any globals that are futures ... DONE
[13:23:36.611] Resolving futures part of globals (recursively) ...
[13:23:36.612] resolve() on list ...
[13:23:36.612]  recursive: 99
[13:23:36.612]  length: 1
[13:23:36.612]  elements: ‘a’
[13:23:36.657] receiveMessageFromWorker() for ClusterFuture ...
[13:23:36.657] - Validating connection of MultisessionFuture
[13:23:36.658] - received message: FutureResult
[13:23:36.658] - Received FutureResult
[13:23:36.658] - Erased future from FutureRegistry
[13:23:36.658] result() for ClusterFuture ...
[13:23:36.658] - result already collected: FutureResult
[13:23:36.658] result() for ClusterFuture ... done
[13:23:36.658] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:36.658] Future #1
[13:23:36.658] result() for ClusterFuture ...
[13:23:36.659] - result already collected: FutureResult
[13:23:36.659] result() for ClusterFuture ... done
[13:23:36.659] result() for ClusterFuture ...
[13:23:36.659] - result already collected: FutureResult
[13:23:36.659] result() for ClusterFuture ... done
[13:23:36.659] A MultisessionFuture was resolved
[13:23:36.659]  length: 0 (resolved future 1)
[13:23:36.659] resolve() on list ... DONE
[13:23:36.659] - globals: [1] ‘a’
[13:23:36.660] Resolving futures part of globals (recursively) ... DONE
[13:23:36.662] The total size of the 1 globals is 1.56 MiB (1640840 bytes)
[13:23:36.662] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.56 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.56 MiB of class ‘environment’)
[13:23:36.662] - globals: [1] ‘a’
[13:23:36.662] - packages: [1] ‘future’
[13:23:36.662] getGlobalsAndPackages() ... DONE
[13:23:36.663] run() for ‘Future’ ...
[13:23:36.663] - state: ‘created’
[13:23:36.663] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:36.677] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:36.678] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:36.678]   - Field: ‘node’
[13:23:36.678]   - Field: ‘label’
[13:23:36.678]   - Field: ‘local’
[13:23:36.678]   - Field: ‘owner’
[13:23:36.678]   - Field: ‘envir’
[13:23:36.678]   - Field: ‘workers’
[13:23:36.678]   - Field: ‘packages’
[13:23:36.678]   - Field: ‘gc’
[13:23:36.678]   - Field: ‘conditions’
[13:23:36.679]   - Field: ‘persistent’
[13:23:36.679]   - Field: ‘expr’
[13:23:36.679]   - Field: ‘uuid’
[13:23:36.679]   - Field: ‘seed’
[13:23:36.679]   - Field: ‘version’
[13:23:36.679]   - Field: ‘result’
[13:23:36.679]   - Field: ‘asynchronous’
[13:23:36.679]   - Field: ‘calls’
[13:23:36.679]   - Field: ‘globals’
[13:23:36.679]   - Field: ‘stdout’
[13:23:36.680]   - Field: ‘earlySignal’
[13:23:36.680]   - Field: ‘lazy’
[13:23:36.680]   - Field: ‘state’
[13:23:36.680] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:36.680] - Launch lazy future ...
[13:23:36.680] Packages needed by the future expression (n = 1): ‘future’
[13:23:36.680] Packages needed by future strategies (n = 0): <none>
[13:23:36.681] {
[13:23:36.681]     {
[13:23:36.681]         {
[13:23:36.681]             ...future.startTime <- base::Sys.time()
[13:23:36.681]             {
[13:23:36.681]                 {
[13:23:36.681]                   {
[13:23:36.681]                     {
[13:23:36.681]                       {
[13:23:36.681]                         base::local({
[13:23:36.681]                           has_future <- base::requireNamespace("future", 
[13:23:36.681]                             quietly = TRUE)
[13:23:36.681]                           if (has_future) {
[13:23:36.681]                             ns <- base::getNamespace("future")
[13:23:36.681]                             version <- ns[[".package"]][["version"]]
[13:23:36.681]                             if (is.null(version)) 
[13:23:36.681]                               version <- utils::packageVersion("future")
[13:23:36.681]                           }
[13:23:36.681]                           else {
[13:23:36.681]                             version <- NULL
[13:23:36.681]                           }
[13:23:36.681]                           if (!has_future || version < "1.8.0") {
[13:23:36.681]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:36.681]                               "", base::R.version$version.string), 
[13:23:36.681]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:36.681]                                 base::R.version$platform, 8 * 
[13:23:36.681]                                   base::.Machine$sizeof.pointer), 
[13:23:36.681]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:36.681]                                 "release", "version")], collapse = " "), 
[13:23:36.681]                               hostname = base::Sys.info()[["nodename"]])
[13:23:36.681]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:36.681]                               info)
[13:23:36.681]                             info <- base::paste(info, collapse = "; ")
[13:23:36.681]                             if (!has_future) {
[13:23:36.681]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:36.681]                                 info)
[13:23:36.681]                             }
[13:23:36.681]                             else {
[13:23:36.681]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:36.681]                                 info, version)
[13:23:36.681]                             }
[13:23:36.681]                             base::stop(msg)
[13:23:36.681]                           }
[13:23:36.681]                         })
[13:23:36.681]                       }
[13:23:36.681]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:36.681]                       base::options(mc.cores = 1L)
[13:23:36.681]                     }
[13:23:36.681]                     base::local({
[13:23:36.681]                       for (pkg in "future") {
[13:23:36.681]                         base::loadNamespace(pkg)
[13:23:36.681]                         base::library(pkg, character.only = TRUE)
[13:23:36.681]                       }
[13:23:36.681]                     })
[13:23:36.681]                   }
[13:23:36.681]                   options(future.plan = NULL)
[13:23:36.681]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.681]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:36.681]                 }
[13:23:36.681]                 ...future.workdir <- getwd()
[13:23:36.681]             }
[13:23:36.681]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:36.681]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:36.681]         }
[13:23:36.681]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:36.681]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:36.681]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:36.681]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:36.681]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:36.681]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:36.681]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:36.681]             base::names(...future.oldOptions))
[13:23:36.681]     }
[13:23:36.681]     if (FALSE) {
[13:23:36.681]     }
[13:23:36.681]     else {
[13:23:36.681]         if (TRUE) {
[13:23:36.681]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:36.681]                 open = "w")
[13:23:36.681]         }
[13:23:36.681]         else {
[13:23:36.681]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:36.681]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:36.681]         }
[13:23:36.681]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:36.681]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:36.681]             base::sink(type = "output", split = FALSE)
[13:23:36.681]             base::close(...future.stdout)
[13:23:36.681]         }, add = TRUE)
[13:23:36.681]     }
[13:23:36.681]     ...future.frame <- base::sys.nframe()
[13:23:36.681]     ...future.conditions <- base::list()
[13:23:36.681]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:36.681]     if (FALSE) {
[13:23:36.681]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:36.681]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:36.681]     }
[13:23:36.681]     ...future.result <- base::tryCatch({
[13:23:36.681]         base::withCallingHandlers({
[13:23:36.681]             ...future.value <- base::withVisible(base::local({
[13:23:36.681]                 ...future.makeSendCondition <- base::local({
[13:23:36.681]                   sendCondition <- NULL
[13:23:36.681]                   function(frame = 1L) {
[13:23:36.681]                     if (is.function(sendCondition)) 
[13:23:36.681]                       return(sendCondition)
[13:23:36.681]                     ns <- getNamespace("parallel")
[13:23:36.681]                     if (exists("sendData", mode = "function", 
[13:23:36.681]                       envir = ns)) {
[13:23:36.681]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:36.681]                         envir = ns)
[13:23:36.681]                       envir <- sys.frame(frame)
[13:23:36.681]                       master <- NULL
[13:23:36.681]                       while (!identical(envir, .GlobalEnv) && 
[13:23:36.681]                         !identical(envir, emptyenv())) {
[13:23:36.681]                         if (exists("master", mode = "list", envir = envir, 
[13:23:36.681]                           inherits = FALSE)) {
[13:23:36.681]                           master <- get("master", mode = "list", 
[13:23:36.681]                             envir = envir, inherits = FALSE)
[13:23:36.681]                           if (inherits(master, c("SOCKnode", 
[13:23:36.681]                             "SOCK0node"))) {
[13:23:36.681]                             sendCondition <<- function(cond) {
[13:23:36.681]                               data <- list(type = "VALUE", value = cond, 
[13:23:36.681]                                 success = TRUE)
[13:23:36.681]                               parallel_sendData(master, data)
[13:23:36.681]                             }
[13:23:36.681]                             return(sendCondition)
[13:23:36.681]                           }
[13:23:36.681]                         }
[13:23:36.681]                         frame <- frame + 1L
[13:23:36.681]                         envir <- sys.frame(frame)
[13:23:36.681]                       }
[13:23:36.681]                     }
[13:23:36.681]                     sendCondition <<- function(cond) NULL
[13:23:36.681]                   }
[13:23:36.681]                 })
[13:23:36.681]                 withCallingHandlers({
[13:23:36.681]                   value(a) + 1
[13:23:36.681]                 }, immediateCondition = function(cond) {
[13:23:36.681]                   sendCondition <- ...future.makeSendCondition()
[13:23:36.681]                   sendCondition(cond)
[13:23:36.681]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.681]                   {
[13:23:36.681]                     inherits <- base::inherits
[13:23:36.681]                     invokeRestart <- base::invokeRestart
[13:23:36.681]                     is.null <- base::is.null
[13:23:36.681]                     muffled <- FALSE
[13:23:36.681]                     if (inherits(cond, "message")) {
[13:23:36.681]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:36.681]                       if (muffled) 
[13:23:36.681]                         invokeRestart("muffleMessage")
[13:23:36.681]                     }
[13:23:36.681]                     else if (inherits(cond, "warning")) {
[13:23:36.681]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:36.681]                       if (muffled) 
[13:23:36.681]                         invokeRestart("muffleWarning")
[13:23:36.681]                     }
[13:23:36.681]                     else if (inherits(cond, "condition")) {
[13:23:36.681]                       if (!is.null(pattern)) {
[13:23:36.681]                         computeRestarts <- base::computeRestarts
[13:23:36.681]                         grepl <- base::grepl
[13:23:36.681]                         restarts <- computeRestarts(cond)
[13:23:36.681]                         for (restart in restarts) {
[13:23:36.681]                           name <- restart$name
[13:23:36.681]                           if (is.null(name)) 
[13:23:36.681]                             next
[13:23:36.681]                           if (!grepl(pattern, name)) 
[13:23:36.681]                             next
[13:23:36.681]                           invokeRestart(restart)
[13:23:36.681]                           muffled <- TRUE
[13:23:36.681]                           break
[13:23:36.681]                         }
[13:23:36.681]                       }
[13:23:36.681]                     }
[13:23:36.681]                     invisible(muffled)
[13:23:36.681]                   }
[13:23:36.681]                   muffleCondition(cond)
[13:23:36.681]                 })
[13:23:36.681]             }))
[13:23:36.681]             future::FutureResult(value = ...future.value$value, 
[13:23:36.681]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.681]                   ...future.rng), globalenv = if (FALSE) 
[13:23:36.681]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:36.681]                     ...future.globalenv.names))
[13:23:36.681]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:36.681]         }, condition = base::local({
[13:23:36.681]             c <- base::c
[13:23:36.681]             inherits <- base::inherits
[13:23:36.681]             invokeRestart <- base::invokeRestart
[13:23:36.681]             length <- base::length
[13:23:36.681]             list <- base::list
[13:23:36.681]             seq.int <- base::seq.int
[13:23:36.681]             signalCondition <- base::signalCondition
[13:23:36.681]             sys.calls <- base::sys.calls
[13:23:36.681]             `[[` <- base::`[[`
[13:23:36.681]             `+` <- base::`+`
[13:23:36.681]             `<<-` <- base::`<<-`
[13:23:36.681]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:36.681]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:36.681]                   3L)]
[13:23:36.681]             }
[13:23:36.681]             function(cond) {
[13:23:36.681]                 is_error <- inherits(cond, "error")
[13:23:36.681]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:36.681]                   NULL)
[13:23:36.681]                 if (is_error) {
[13:23:36.681]                   sessionInformation <- function() {
[13:23:36.681]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:36.681]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:36.681]                       search = base::search(), system = base::Sys.info())
[13:23:36.681]                   }
[13:23:36.681]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.681]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:36.681]                     cond$call), session = sessionInformation(), 
[13:23:36.681]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:36.681]                   signalCondition(cond)
[13:23:36.681]                 }
[13:23:36.681]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:36.681]                 "immediateCondition"))) {
[13:23:36.681]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:36.681]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.681]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:36.681]                   if (TRUE && !signal) {
[13:23:36.681]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.681]                     {
[13:23:36.681]                       inherits <- base::inherits
[13:23:36.681]                       invokeRestart <- base::invokeRestart
[13:23:36.681]                       is.null <- base::is.null
[13:23:36.681]                       muffled <- FALSE
[13:23:36.681]                       if (inherits(cond, "message")) {
[13:23:36.681]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.681]                         if (muffled) 
[13:23:36.681]                           invokeRestart("muffleMessage")
[13:23:36.681]                       }
[13:23:36.681]                       else if (inherits(cond, "warning")) {
[13:23:36.681]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.681]                         if (muffled) 
[13:23:36.681]                           invokeRestart("muffleWarning")
[13:23:36.681]                       }
[13:23:36.681]                       else if (inherits(cond, "condition")) {
[13:23:36.681]                         if (!is.null(pattern)) {
[13:23:36.681]                           computeRestarts <- base::computeRestarts
[13:23:36.681]                           grepl <- base::grepl
[13:23:36.681]                           restarts <- computeRestarts(cond)
[13:23:36.681]                           for (restart in restarts) {
[13:23:36.681]                             name <- restart$name
[13:23:36.681]                             if (is.null(name)) 
[13:23:36.681]                               next
[13:23:36.681]                             if (!grepl(pattern, name)) 
[13:23:36.681]                               next
[13:23:36.681]                             invokeRestart(restart)
[13:23:36.681]                             muffled <- TRUE
[13:23:36.681]                             break
[13:23:36.681]                           }
[13:23:36.681]                         }
[13:23:36.681]                       }
[13:23:36.681]                       invisible(muffled)
[13:23:36.681]                     }
[13:23:36.681]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.681]                   }
[13:23:36.681]                 }
[13:23:36.681]                 else {
[13:23:36.681]                   if (TRUE) {
[13:23:36.681]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.681]                     {
[13:23:36.681]                       inherits <- base::inherits
[13:23:36.681]                       invokeRestart <- base::invokeRestart
[13:23:36.681]                       is.null <- base::is.null
[13:23:36.681]                       muffled <- FALSE
[13:23:36.681]                       if (inherits(cond, "message")) {
[13:23:36.681]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.681]                         if (muffled) 
[13:23:36.681]                           invokeRestart("muffleMessage")
[13:23:36.681]                       }
[13:23:36.681]                       else if (inherits(cond, "warning")) {
[13:23:36.681]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.681]                         if (muffled) 
[13:23:36.681]                           invokeRestart("muffleWarning")
[13:23:36.681]                       }
[13:23:36.681]                       else if (inherits(cond, "condition")) {
[13:23:36.681]                         if (!is.null(pattern)) {
[13:23:36.681]                           computeRestarts <- base::computeRestarts
[13:23:36.681]                           grepl <- base::grepl
[13:23:36.681]                           restarts <- computeRestarts(cond)
[13:23:36.681]                           for (restart in restarts) {
[13:23:36.681]                             name <- restart$name
[13:23:36.681]                             if (is.null(name)) 
[13:23:36.681]                               next
[13:23:36.681]                             if (!grepl(pattern, name)) 
[13:23:36.681]                               next
[13:23:36.681]                             invokeRestart(restart)
[13:23:36.681]                             muffled <- TRUE
[13:23:36.681]                             break
[13:23:36.681]                           }
[13:23:36.681]                         }
[13:23:36.681]                       }
[13:23:36.681]                       invisible(muffled)
[13:23:36.681]                     }
[13:23:36.681]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.681]                   }
[13:23:36.681]                 }
[13:23:36.681]             }
[13:23:36.681]         }))
[13:23:36.681]     }, error = function(ex) {
[13:23:36.681]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:36.681]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.681]                 ...future.rng), started = ...future.startTime, 
[13:23:36.681]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:36.681]             version = "1.8"), class = "FutureResult")
[13:23:36.681]     }, finally = {
[13:23:36.681]         if (!identical(...future.workdir, getwd())) 
[13:23:36.681]             setwd(...future.workdir)
[13:23:36.681]         {
[13:23:36.681]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:36.681]                 ...future.oldOptions$nwarnings <- NULL
[13:23:36.681]             }
[13:23:36.681]             base::options(...future.oldOptions)
[13:23:36.681]             if (.Platform$OS.type == "windows") {
[13:23:36.681]                 old_names <- names(...future.oldEnvVars)
[13:23:36.681]                 envs <- base::Sys.getenv()
[13:23:36.681]                 names <- names(envs)
[13:23:36.681]                 common <- intersect(names, old_names)
[13:23:36.681]                 added <- setdiff(names, old_names)
[13:23:36.681]                 removed <- setdiff(old_names, names)
[13:23:36.681]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:36.681]                   envs[common]]
[13:23:36.681]                 NAMES <- toupper(changed)
[13:23:36.681]                 args <- list()
[13:23:36.681]                 for (kk in seq_along(NAMES)) {
[13:23:36.681]                   name <- changed[[kk]]
[13:23:36.681]                   NAME <- NAMES[[kk]]
[13:23:36.681]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.681]                     next
[13:23:36.681]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.681]                 }
[13:23:36.681]                 NAMES <- toupper(added)
[13:23:36.681]                 for (kk in seq_along(NAMES)) {
[13:23:36.681]                   name <- added[[kk]]
[13:23:36.681]                   NAME <- NAMES[[kk]]
[13:23:36.681]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.681]                     next
[13:23:36.681]                   args[[name]] <- ""
[13:23:36.681]                 }
[13:23:36.681]                 NAMES <- toupper(removed)
[13:23:36.681]                 for (kk in seq_along(NAMES)) {
[13:23:36.681]                   name <- removed[[kk]]
[13:23:36.681]                   NAME <- NAMES[[kk]]
[13:23:36.681]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.681]                     next
[13:23:36.681]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.681]                 }
[13:23:36.681]                 if (length(args) > 0) 
[13:23:36.681]                   base::do.call(base::Sys.setenv, args = args)
[13:23:36.681]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:36.681]             }
[13:23:36.681]             else {
[13:23:36.681]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:36.681]             }
[13:23:36.681]             {
[13:23:36.681]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:36.681]                   0L) {
[13:23:36.681]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:36.681]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:36.681]                   base::options(opts)
[13:23:36.681]                 }
[13:23:36.681]                 {
[13:23:36.681]                   {
[13:23:36.681]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:36.681]                     NULL
[13:23:36.681]                   }
[13:23:36.681]                   options(future.plan = NULL)
[13:23:36.681]                   if (is.na(NA_character_)) 
[13:23:36.681]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.681]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:36.681]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:36.681]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:36.681]                     envir = parent.frame()) 
[13:23:36.681]                   {
[13:23:36.681]                     if (is.function(workers)) 
[13:23:36.681]                       workers <- workers()
[13:23:36.681]                     workers <- structure(as.integer(workers), 
[13:23:36.681]                       class = class(workers))
[13:23:36.681]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:36.681]                       workers >= 1)
[13:23:36.681]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:36.681]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:36.681]                     }
[13:23:36.681]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:36.681]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:36.681]                       envir = envir)
[13:23:36.681]                     if (!future$lazy) 
[13:23:36.681]                       future <- run(future)
[13:23:36.681]                     invisible(future)
[13:23:36.681]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:36.681]                 }
[13:23:36.681]             }
[13:23:36.681]         }
[13:23:36.681]     })
[13:23:36.681]     if (TRUE) {
[13:23:36.681]         base::sink(type = "output", split = FALSE)
[13:23:36.681]         if (TRUE) {
[13:23:36.681]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:36.681]         }
[13:23:36.681]         else {
[13:23:36.681]             ...future.result["stdout"] <- base::list(NULL)
[13:23:36.681]         }
[13:23:36.681]         base::close(...future.stdout)
[13:23:36.681]         ...future.stdout <- NULL
[13:23:36.681]     }
[13:23:36.681]     ...future.result$conditions <- ...future.conditions
[13:23:36.681]     ...future.result$finished <- base::Sys.time()
[13:23:36.681]     ...future.result
[13:23:36.681] }
[13:23:36.684] Exporting 1 global objects (1.56 MiB) to cluster node #1 ...
[13:23:36.686] Exporting ‘a’ (1.56 MiB) to cluster node #1 ...
[13:23:36.737] Exporting ‘a’ (1.56 MiB) to cluster node #1 ... DONE
[13:23:36.737] Exporting 1 global objects (1.56 MiB) to cluster node #1 ... DONE
[13:23:36.738] MultisessionFuture started
[13:23:36.738] - Launch lazy future ... done
[13:23:36.738] run() for ‘MultisessionFuture’ ... done
[13:23:36.738] result() for ClusterFuture ...
[13:23:36.738] receiveMessageFromWorker() for ClusterFuture ...
[13:23:36.738] - Validating connection of MultisessionFuture
[13:23:36.794] - received message: FutureResult
[13:23:36.794] - Received FutureResult
[13:23:36.794] - Erased future from FutureRegistry
[13:23:36.794] result() for ClusterFuture ...
[13:23:36.794] - result already collected: FutureResult
[13:23:36.794] result() for ClusterFuture ... done
[13:23:36.794] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:36.795] result() for ClusterFuture ... done
[13:23:36.795] result() for ClusterFuture ...
[13:23:36.795] - result already collected: FutureResult
[13:23:36.795] result() for ClusterFuture ... done
value(b) = 2
[13:23:36.795] result() for ClusterFuture ...
[13:23:36.795] - result already collected: FutureResult
[13:23:36.795] result() for ClusterFuture ... done
[13:23:36.795] result() for ClusterFuture ...
[13:23:36.795] - result already collected: FutureResult
[13:23:36.796] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:36.796] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:36.796] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:36.796] 
[13:23:36.797] Searching for globals ... DONE
[13:23:36.797] - globals: [0] <none>
[13:23:36.797] getGlobalsAndPackages() ... DONE
[13:23:36.797] run() for ‘Future’ ...
[13:23:36.797] - state: ‘created’
[13:23:36.797] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:36.812] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:36.812] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:36.812]   - Field: ‘node’
[13:23:36.812]   - Field: ‘label’
[13:23:36.812]   - Field: ‘local’
[13:23:36.812]   - Field: ‘owner’
[13:23:36.812]   - Field: ‘envir’
[13:23:36.813]   - Field: ‘workers’
[13:23:36.813]   - Field: ‘packages’
[13:23:36.813]   - Field: ‘gc’
[13:23:36.813]   - Field: ‘conditions’
[13:23:36.813]   - Field: ‘persistent’
[13:23:36.813]   - Field: ‘expr’
[13:23:36.813]   - Field: ‘uuid’
[13:23:36.813]   - Field: ‘seed’
[13:23:36.813]   - Field: ‘version’
[13:23:36.813]   - Field: ‘result’
[13:23:36.813]   - Field: ‘asynchronous’
[13:23:36.814]   - Field: ‘calls’
[13:23:36.814]   - Field: ‘globals’
[13:23:36.814]   - Field: ‘stdout’
[13:23:36.814]   - Field: ‘earlySignal’
[13:23:36.814]   - Field: ‘lazy’
[13:23:36.814]   - Field: ‘state’
[13:23:36.814] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:36.814] - Launch lazy future ...
[13:23:36.814] Packages needed by the future expression (n = 0): <none>
[13:23:36.815] Packages needed by future strategies (n = 0): <none>
[13:23:36.815] {
[13:23:36.815]     {
[13:23:36.815]         {
[13:23:36.815]             ...future.startTime <- base::Sys.time()
[13:23:36.815]             {
[13:23:36.815]                 {
[13:23:36.815]                   {
[13:23:36.815]                     {
[13:23:36.815]                       base::local({
[13:23:36.815]                         has_future <- base::requireNamespace("future", 
[13:23:36.815]                           quietly = TRUE)
[13:23:36.815]                         if (has_future) {
[13:23:36.815]                           ns <- base::getNamespace("future")
[13:23:36.815]                           version <- ns[[".package"]][["version"]]
[13:23:36.815]                           if (is.null(version)) 
[13:23:36.815]                             version <- utils::packageVersion("future")
[13:23:36.815]                         }
[13:23:36.815]                         else {
[13:23:36.815]                           version <- NULL
[13:23:36.815]                         }
[13:23:36.815]                         if (!has_future || version < "1.8.0") {
[13:23:36.815]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:36.815]                             "", base::R.version$version.string), 
[13:23:36.815]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:36.815]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:36.815]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:36.815]                               "release", "version")], collapse = " "), 
[13:23:36.815]                             hostname = base::Sys.info()[["nodename"]])
[13:23:36.815]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:36.815]                             info)
[13:23:36.815]                           info <- base::paste(info, collapse = "; ")
[13:23:36.815]                           if (!has_future) {
[13:23:36.815]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:36.815]                               info)
[13:23:36.815]                           }
[13:23:36.815]                           else {
[13:23:36.815]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:36.815]                               info, version)
[13:23:36.815]                           }
[13:23:36.815]                           base::stop(msg)
[13:23:36.815]                         }
[13:23:36.815]                       })
[13:23:36.815]                     }
[13:23:36.815]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:36.815]                     base::options(mc.cores = 1L)
[13:23:36.815]                   }
[13:23:36.815]                   options(future.plan = NULL)
[13:23:36.815]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.815]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:36.815]                 }
[13:23:36.815]                 ...future.workdir <- getwd()
[13:23:36.815]             }
[13:23:36.815]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:36.815]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:36.815]         }
[13:23:36.815]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:36.815]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:36.815]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:36.815]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:36.815]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:36.815]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:36.815]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:36.815]             base::names(...future.oldOptions))
[13:23:36.815]     }
[13:23:36.815]     if (FALSE) {
[13:23:36.815]     }
[13:23:36.815]     else {
[13:23:36.815]         if (TRUE) {
[13:23:36.815]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:36.815]                 open = "w")
[13:23:36.815]         }
[13:23:36.815]         else {
[13:23:36.815]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:36.815]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:36.815]         }
[13:23:36.815]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:36.815]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:36.815]             base::sink(type = "output", split = FALSE)
[13:23:36.815]             base::close(...future.stdout)
[13:23:36.815]         }, add = TRUE)
[13:23:36.815]     }
[13:23:36.815]     ...future.frame <- base::sys.nframe()
[13:23:36.815]     ...future.conditions <- base::list()
[13:23:36.815]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:36.815]     if (FALSE) {
[13:23:36.815]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:36.815]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:36.815]     }
[13:23:36.815]     ...future.result <- base::tryCatch({
[13:23:36.815]         base::withCallingHandlers({
[13:23:36.815]             ...future.value <- base::withVisible(base::local({
[13:23:36.815]                 ...future.makeSendCondition <- base::local({
[13:23:36.815]                   sendCondition <- NULL
[13:23:36.815]                   function(frame = 1L) {
[13:23:36.815]                     if (is.function(sendCondition)) 
[13:23:36.815]                       return(sendCondition)
[13:23:36.815]                     ns <- getNamespace("parallel")
[13:23:36.815]                     if (exists("sendData", mode = "function", 
[13:23:36.815]                       envir = ns)) {
[13:23:36.815]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:36.815]                         envir = ns)
[13:23:36.815]                       envir <- sys.frame(frame)
[13:23:36.815]                       master <- NULL
[13:23:36.815]                       while (!identical(envir, .GlobalEnv) && 
[13:23:36.815]                         !identical(envir, emptyenv())) {
[13:23:36.815]                         if (exists("master", mode = "list", envir = envir, 
[13:23:36.815]                           inherits = FALSE)) {
[13:23:36.815]                           master <- get("master", mode = "list", 
[13:23:36.815]                             envir = envir, inherits = FALSE)
[13:23:36.815]                           if (inherits(master, c("SOCKnode", 
[13:23:36.815]                             "SOCK0node"))) {
[13:23:36.815]                             sendCondition <<- function(cond) {
[13:23:36.815]                               data <- list(type = "VALUE", value = cond, 
[13:23:36.815]                                 success = TRUE)
[13:23:36.815]                               parallel_sendData(master, data)
[13:23:36.815]                             }
[13:23:36.815]                             return(sendCondition)
[13:23:36.815]                           }
[13:23:36.815]                         }
[13:23:36.815]                         frame <- frame + 1L
[13:23:36.815]                         envir <- sys.frame(frame)
[13:23:36.815]                       }
[13:23:36.815]                     }
[13:23:36.815]                     sendCondition <<- function(cond) NULL
[13:23:36.815]                   }
[13:23:36.815]                 })
[13:23:36.815]                 withCallingHandlers({
[13:23:36.815]                   1
[13:23:36.815]                 }, immediateCondition = function(cond) {
[13:23:36.815]                   sendCondition <- ...future.makeSendCondition()
[13:23:36.815]                   sendCondition(cond)
[13:23:36.815]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.815]                   {
[13:23:36.815]                     inherits <- base::inherits
[13:23:36.815]                     invokeRestart <- base::invokeRestart
[13:23:36.815]                     is.null <- base::is.null
[13:23:36.815]                     muffled <- FALSE
[13:23:36.815]                     if (inherits(cond, "message")) {
[13:23:36.815]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:36.815]                       if (muffled) 
[13:23:36.815]                         invokeRestart("muffleMessage")
[13:23:36.815]                     }
[13:23:36.815]                     else if (inherits(cond, "warning")) {
[13:23:36.815]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:36.815]                       if (muffled) 
[13:23:36.815]                         invokeRestart("muffleWarning")
[13:23:36.815]                     }
[13:23:36.815]                     else if (inherits(cond, "condition")) {
[13:23:36.815]                       if (!is.null(pattern)) {
[13:23:36.815]                         computeRestarts <- base::computeRestarts
[13:23:36.815]                         grepl <- base::grepl
[13:23:36.815]                         restarts <- computeRestarts(cond)
[13:23:36.815]                         for (restart in restarts) {
[13:23:36.815]                           name <- restart$name
[13:23:36.815]                           if (is.null(name)) 
[13:23:36.815]                             next
[13:23:36.815]                           if (!grepl(pattern, name)) 
[13:23:36.815]                             next
[13:23:36.815]                           invokeRestart(restart)
[13:23:36.815]                           muffled <- TRUE
[13:23:36.815]                           break
[13:23:36.815]                         }
[13:23:36.815]                       }
[13:23:36.815]                     }
[13:23:36.815]                     invisible(muffled)
[13:23:36.815]                   }
[13:23:36.815]                   muffleCondition(cond)
[13:23:36.815]                 })
[13:23:36.815]             }))
[13:23:36.815]             future::FutureResult(value = ...future.value$value, 
[13:23:36.815]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.815]                   ...future.rng), globalenv = if (FALSE) 
[13:23:36.815]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:36.815]                     ...future.globalenv.names))
[13:23:36.815]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:36.815]         }, condition = base::local({
[13:23:36.815]             c <- base::c
[13:23:36.815]             inherits <- base::inherits
[13:23:36.815]             invokeRestart <- base::invokeRestart
[13:23:36.815]             length <- base::length
[13:23:36.815]             list <- base::list
[13:23:36.815]             seq.int <- base::seq.int
[13:23:36.815]             signalCondition <- base::signalCondition
[13:23:36.815]             sys.calls <- base::sys.calls
[13:23:36.815]             `[[` <- base::`[[`
[13:23:36.815]             `+` <- base::`+`
[13:23:36.815]             `<<-` <- base::`<<-`
[13:23:36.815]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:36.815]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:36.815]                   3L)]
[13:23:36.815]             }
[13:23:36.815]             function(cond) {
[13:23:36.815]                 is_error <- inherits(cond, "error")
[13:23:36.815]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:36.815]                   NULL)
[13:23:36.815]                 if (is_error) {
[13:23:36.815]                   sessionInformation <- function() {
[13:23:36.815]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:36.815]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:36.815]                       search = base::search(), system = base::Sys.info())
[13:23:36.815]                   }
[13:23:36.815]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.815]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:36.815]                     cond$call), session = sessionInformation(), 
[13:23:36.815]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:36.815]                   signalCondition(cond)
[13:23:36.815]                 }
[13:23:36.815]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:36.815]                 "immediateCondition"))) {
[13:23:36.815]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:36.815]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.815]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:36.815]                   if (TRUE && !signal) {
[13:23:36.815]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.815]                     {
[13:23:36.815]                       inherits <- base::inherits
[13:23:36.815]                       invokeRestart <- base::invokeRestart
[13:23:36.815]                       is.null <- base::is.null
[13:23:36.815]                       muffled <- FALSE
[13:23:36.815]                       if (inherits(cond, "message")) {
[13:23:36.815]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.815]                         if (muffled) 
[13:23:36.815]                           invokeRestart("muffleMessage")
[13:23:36.815]                       }
[13:23:36.815]                       else if (inherits(cond, "warning")) {
[13:23:36.815]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.815]                         if (muffled) 
[13:23:36.815]                           invokeRestart("muffleWarning")
[13:23:36.815]                       }
[13:23:36.815]                       else if (inherits(cond, "condition")) {
[13:23:36.815]                         if (!is.null(pattern)) {
[13:23:36.815]                           computeRestarts <- base::computeRestarts
[13:23:36.815]                           grepl <- base::grepl
[13:23:36.815]                           restarts <- computeRestarts(cond)
[13:23:36.815]                           for (restart in restarts) {
[13:23:36.815]                             name <- restart$name
[13:23:36.815]                             if (is.null(name)) 
[13:23:36.815]                               next
[13:23:36.815]                             if (!grepl(pattern, name)) 
[13:23:36.815]                               next
[13:23:36.815]                             invokeRestart(restart)
[13:23:36.815]                             muffled <- TRUE
[13:23:36.815]                             break
[13:23:36.815]                           }
[13:23:36.815]                         }
[13:23:36.815]                       }
[13:23:36.815]                       invisible(muffled)
[13:23:36.815]                     }
[13:23:36.815]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.815]                   }
[13:23:36.815]                 }
[13:23:36.815]                 else {
[13:23:36.815]                   if (TRUE) {
[13:23:36.815]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.815]                     {
[13:23:36.815]                       inherits <- base::inherits
[13:23:36.815]                       invokeRestart <- base::invokeRestart
[13:23:36.815]                       is.null <- base::is.null
[13:23:36.815]                       muffled <- FALSE
[13:23:36.815]                       if (inherits(cond, "message")) {
[13:23:36.815]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.815]                         if (muffled) 
[13:23:36.815]                           invokeRestart("muffleMessage")
[13:23:36.815]                       }
[13:23:36.815]                       else if (inherits(cond, "warning")) {
[13:23:36.815]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.815]                         if (muffled) 
[13:23:36.815]                           invokeRestart("muffleWarning")
[13:23:36.815]                       }
[13:23:36.815]                       else if (inherits(cond, "condition")) {
[13:23:36.815]                         if (!is.null(pattern)) {
[13:23:36.815]                           computeRestarts <- base::computeRestarts
[13:23:36.815]                           grepl <- base::grepl
[13:23:36.815]                           restarts <- computeRestarts(cond)
[13:23:36.815]                           for (restart in restarts) {
[13:23:36.815]                             name <- restart$name
[13:23:36.815]                             if (is.null(name)) 
[13:23:36.815]                               next
[13:23:36.815]                             if (!grepl(pattern, name)) 
[13:23:36.815]                               next
[13:23:36.815]                             invokeRestart(restart)
[13:23:36.815]                             muffled <- TRUE
[13:23:36.815]                             break
[13:23:36.815]                           }
[13:23:36.815]                         }
[13:23:36.815]                       }
[13:23:36.815]                       invisible(muffled)
[13:23:36.815]                     }
[13:23:36.815]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.815]                   }
[13:23:36.815]                 }
[13:23:36.815]             }
[13:23:36.815]         }))
[13:23:36.815]     }, error = function(ex) {
[13:23:36.815]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:36.815]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.815]                 ...future.rng), started = ...future.startTime, 
[13:23:36.815]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:36.815]             version = "1.8"), class = "FutureResult")
[13:23:36.815]     }, finally = {
[13:23:36.815]         if (!identical(...future.workdir, getwd())) 
[13:23:36.815]             setwd(...future.workdir)
[13:23:36.815]         {
[13:23:36.815]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:36.815]                 ...future.oldOptions$nwarnings <- NULL
[13:23:36.815]             }
[13:23:36.815]             base::options(...future.oldOptions)
[13:23:36.815]             if (.Platform$OS.type == "windows") {
[13:23:36.815]                 old_names <- names(...future.oldEnvVars)
[13:23:36.815]                 envs <- base::Sys.getenv()
[13:23:36.815]                 names <- names(envs)
[13:23:36.815]                 common <- intersect(names, old_names)
[13:23:36.815]                 added <- setdiff(names, old_names)
[13:23:36.815]                 removed <- setdiff(old_names, names)
[13:23:36.815]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:36.815]                   envs[common]]
[13:23:36.815]                 NAMES <- toupper(changed)
[13:23:36.815]                 args <- list()
[13:23:36.815]                 for (kk in seq_along(NAMES)) {
[13:23:36.815]                   name <- changed[[kk]]
[13:23:36.815]                   NAME <- NAMES[[kk]]
[13:23:36.815]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.815]                     next
[13:23:36.815]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.815]                 }
[13:23:36.815]                 NAMES <- toupper(added)
[13:23:36.815]                 for (kk in seq_along(NAMES)) {
[13:23:36.815]                   name <- added[[kk]]
[13:23:36.815]                   NAME <- NAMES[[kk]]
[13:23:36.815]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.815]                     next
[13:23:36.815]                   args[[name]] <- ""
[13:23:36.815]                 }
[13:23:36.815]                 NAMES <- toupper(removed)
[13:23:36.815]                 for (kk in seq_along(NAMES)) {
[13:23:36.815]                   name <- removed[[kk]]
[13:23:36.815]                   NAME <- NAMES[[kk]]
[13:23:36.815]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.815]                     next
[13:23:36.815]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.815]                 }
[13:23:36.815]                 if (length(args) > 0) 
[13:23:36.815]                   base::do.call(base::Sys.setenv, args = args)
[13:23:36.815]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:36.815]             }
[13:23:36.815]             else {
[13:23:36.815]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:36.815]             }
[13:23:36.815]             {
[13:23:36.815]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:36.815]                   0L) {
[13:23:36.815]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:36.815]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:36.815]                   base::options(opts)
[13:23:36.815]                 }
[13:23:36.815]                 {
[13:23:36.815]                   {
[13:23:36.815]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:36.815]                     NULL
[13:23:36.815]                   }
[13:23:36.815]                   options(future.plan = NULL)
[13:23:36.815]                   if (is.na(NA_character_)) 
[13:23:36.815]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.815]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:36.815]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:36.815]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:36.815]                     envir = parent.frame()) 
[13:23:36.815]                   {
[13:23:36.815]                     if (is.function(workers)) 
[13:23:36.815]                       workers <- workers()
[13:23:36.815]                     workers <- structure(as.integer(workers), 
[13:23:36.815]                       class = class(workers))
[13:23:36.815]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:36.815]                       workers >= 1)
[13:23:36.815]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:36.815]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:36.815]                     }
[13:23:36.815]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:36.815]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:36.815]                       envir = envir)
[13:23:36.815]                     if (!future$lazy) 
[13:23:36.815]                       future <- run(future)
[13:23:36.815]                     invisible(future)
[13:23:36.815]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:36.815]                 }
[13:23:36.815]             }
[13:23:36.815]         }
[13:23:36.815]     })
[13:23:36.815]     if (TRUE) {
[13:23:36.815]         base::sink(type = "output", split = FALSE)
[13:23:36.815]         if (TRUE) {
[13:23:36.815]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:36.815]         }
[13:23:36.815]         else {
[13:23:36.815]             ...future.result["stdout"] <- base::list(NULL)
[13:23:36.815]         }
[13:23:36.815]         base::close(...future.stdout)
[13:23:36.815]         ...future.stdout <- NULL
[13:23:36.815]     }
[13:23:36.815]     ...future.result$conditions <- ...future.conditions
[13:23:36.815]     ...future.result$finished <- base::Sys.time()
[13:23:36.815]     ...future.result
[13:23:36.815] }
[13:23:36.819] MultisessionFuture started
[13:23:36.819] - Launch lazy future ... done
[13:23:36.819] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:36.819] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:36.819] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:36.820] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:36.820] Searching for globals ... DONE
[13:23:36.820] Resolving globals: TRUE
[13:23:36.821] Resolving any globals that are futures ...
[13:23:36.821] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:36.821] Resolving any globals that are futures ... DONE
[13:23:36.821] Resolving futures part of globals (recursively) ...
[13:23:36.821] resolve() on list ...
[13:23:36.821]  recursive: 99
[13:23:36.822]  length: 1
[13:23:36.822]  elements: ‘a’
[13:23:36.865] receiveMessageFromWorker() for ClusterFuture ...
[13:23:36.866] - Validating connection of MultisessionFuture
[13:23:36.866] - received message: FutureResult
[13:23:36.866] - Received FutureResult
[13:23:36.866] - Erased future from FutureRegistry
[13:23:36.866] result() for ClusterFuture ...
[13:23:36.866] - result already collected: FutureResult
[13:23:36.866] result() for ClusterFuture ... done
[13:23:36.866] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:36.867] Future #1
[13:23:36.867] result() for ClusterFuture ...
[13:23:36.867] - result already collected: FutureResult
[13:23:36.867] result() for ClusterFuture ... done
[13:23:36.867] result() for ClusterFuture ...
[13:23:36.867] - result already collected: FutureResult
[13:23:36.867] result() for ClusterFuture ... done
[13:23:36.867] A MultisessionFuture was resolved
[13:23:36.867]  length: 0 (resolved future 1)
[13:23:36.868] resolve() on list ... DONE
[13:23:36.868] - globals: [1] ‘a’
[13:23:36.868] Resolving futures part of globals (recursively) ... DONE
[13:23:36.872] The total size of the 1 globals is 1.56 MiB (1640840 bytes)
[13:23:36.873] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.56 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.56 MiB of class ‘environment’)
[13:23:36.873] - globals: [1] ‘a’
[13:23:36.873] - packages: [1] ‘future’
[13:23:36.873] getGlobalsAndPackages() ... DONE
[13:23:36.874] run() for ‘Future’ ...
[13:23:36.874] - state: ‘created’
[13:23:36.874] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:36.888] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:36.888] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:36.888]   - Field: ‘node’
[13:23:36.888]   - Field: ‘label’
[13:23:36.889]   - Field: ‘local’
[13:23:36.889]   - Field: ‘owner’
[13:23:36.889]   - Field: ‘envir’
[13:23:36.889]   - Field: ‘workers’
[13:23:36.889]   - Field: ‘packages’
[13:23:36.889]   - Field: ‘gc’
[13:23:36.889]   - Field: ‘conditions’
[13:23:36.889]   - Field: ‘persistent’
[13:23:36.889]   - Field: ‘expr’
[13:23:36.889]   - Field: ‘uuid’
[13:23:36.889]   - Field: ‘seed’
[13:23:36.890]   - Field: ‘version’
[13:23:36.890]   - Field: ‘result’
[13:23:36.890]   - Field: ‘asynchronous’
[13:23:36.890]   - Field: ‘calls’
[13:23:36.890]   - Field: ‘globals’
[13:23:36.890]   - Field: ‘stdout’
[13:23:36.890]   - Field: ‘earlySignal’
[13:23:36.890]   - Field: ‘lazy’
[13:23:36.890]   - Field: ‘state’
[13:23:36.890] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:36.890] - Launch lazy future ...
[13:23:36.891] Packages needed by the future expression (n = 1): ‘future’
[13:23:36.891] Packages needed by future strategies (n = 0): <none>
[13:23:36.891] {
[13:23:36.891]     {
[13:23:36.891]         {
[13:23:36.891]             ...future.startTime <- base::Sys.time()
[13:23:36.891]             {
[13:23:36.891]                 {
[13:23:36.891]                   {
[13:23:36.891]                     {
[13:23:36.891]                       {
[13:23:36.891]                         base::local({
[13:23:36.891]                           has_future <- base::requireNamespace("future", 
[13:23:36.891]                             quietly = TRUE)
[13:23:36.891]                           if (has_future) {
[13:23:36.891]                             ns <- base::getNamespace("future")
[13:23:36.891]                             version <- ns[[".package"]][["version"]]
[13:23:36.891]                             if (is.null(version)) 
[13:23:36.891]                               version <- utils::packageVersion("future")
[13:23:36.891]                           }
[13:23:36.891]                           else {
[13:23:36.891]                             version <- NULL
[13:23:36.891]                           }
[13:23:36.891]                           if (!has_future || version < "1.8.0") {
[13:23:36.891]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:36.891]                               "", base::R.version$version.string), 
[13:23:36.891]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:36.891]                                 base::R.version$platform, 8 * 
[13:23:36.891]                                   base::.Machine$sizeof.pointer), 
[13:23:36.891]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:36.891]                                 "release", "version")], collapse = " "), 
[13:23:36.891]                               hostname = base::Sys.info()[["nodename"]])
[13:23:36.891]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:36.891]                               info)
[13:23:36.891]                             info <- base::paste(info, collapse = "; ")
[13:23:36.891]                             if (!has_future) {
[13:23:36.891]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:36.891]                                 info)
[13:23:36.891]                             }
[13:23:36.891]                             else {
[13:23:36.891]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:36.891]                                 info, version)
[13:23:36.891]                             }
[13:23:36.891]                             base::stop(msg)
[13:23:36.891]                           }
[13:23:36.891]                         })
[13:23:36.891]                       }
[13:23:36.891]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:36.891]                       base::options(mc.cores = 1L)
[13:23:36.891]                     }
[13:23:36.891]                     base::local({
[13:23:36.891]                       for (pkg in "future") {
[13:23:36.891]                         base::loadNamespace(pkg)
[13:23:36.891]                         base::library(pkg, character.only = TRUE)
[13:23:36.891]                       }
[13:23:36.891]                     })
[13:23:36.891]                   }
[13:23:36.891]                   options(future.plan = NULL)
[13:23:36.891]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.891]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:36.891]                 }
[13:23:36.891]                 ...future.workdir <- getwd()
[13:23:36.891]             }
[13:23:36.891]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:36.891]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:36.891]         }
[13:23:36.891]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:36.891]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:36.891]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:36.891]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:36.891]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:36.891]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:36.891]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:36.891]             base::names(...future.oldOptions))
[13:23:36.891]     }
[13:23:36.891]     if (FALSE) {
[13:23:36.891]     }
[13:23:36.891]     else {
[13:23:36.891]         if (TRUE) {
[13:23:36.891]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:36.891]                 open = "w")
[13:23:36.891]         }
[13:23:36.891]         else {
[13:23:36.891]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:36.891]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:36.891]         }
[13:23:36.891]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:36.891]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:36.891]             base::sink(type = "output", split = FALSE)
[13:23:36.891]             base::close(...future.stdout)
[13:23:36.891]         }, add = TRUE)
[13:23:36.891]     }
[13:23:36.891]     ...future.frame <- base::sys.nframe()
[13:23:36.891]     ...future.conditions <- base::list()
[13:23:36.891]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:36.891]     if (FALSE) {
[13:23:36.891]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:36.891]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:36.891]     }
[13:23:36.891]     ...future.result <- base::tryCatch({
[13:23:36.891]         base::withCallingHandlers({
[13:23:36.891]             ...future.value <- base::withVisible(base::local({
[13:23:36.891]                 ...future.makeSendCondition <- base::local({
[13:23:36.891]                   sendCondition <- NULL
[13:23:36.891]                   function(frame = 1L) {
[13:23:36.891]                     if (is.function(sendCondition)) 
[13:23:36.891]                       return(sendCondition)
[13:23:36.891]                     ns <- getNamespace("parallel")
[13:23:36.891]                     if (exists("sendData", mode = "function", 
[13:23:36.891]                       envir = ns)) {
[13:23:36.891]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:36.891]                         envir = ns)
[13:23:36.891]                       envir <- sys.frame(frame)
[13:23:36.891]                       master <- NULL
[13:23:36.891]                       while (!identical(envir, .GlobalEnv) && 
[13:23:36.891]                         !identical(envir, emptyenv())) {
[13:23:36.891]                         if (exists("master", mode = "list", envir = envir, 
[13:23:36.891]                           inherits = FALSE)) {
[13:23:36.891]                           master <- get("master", mode = "list", 
[13:23:36.891]                             envir = envir, inherits = FALSE)
[13:23:36.891]                           if (inherits(master, c("SOCKnode", 
[13:23:36.891]                             "SOCK0node"))) {
[13:23:36.891]                             sendCondition <<- function(cond) {
[13:23:36.891]                               data <- list(type = "VALUE", value = cond, 
[13:23:36.891]                                 success = TRUE)
[13:23:36.891]                               parallel_sendData(master, data)
[13:23:36.891]                             }
[13:23:36.891]                             return(sendCondition)
[13:23:36.891]                           }
[13:23:36.891]                         }
[13:23:36.891]                         frame <- frame + 1L
[13:23:36.891]                         envir <- sys.frame(frame)
[13:23:36.891]                       }
[13:23:36.891]                     }
[13:23:36.891]                     sendCondition <<- function(cond) NULL
[13:23:36.891]                   }
[13:23:36.891]                 })
[13:23:36.891]                 withCallingHandlers({
[13:23:36.891]                   value(a) + 1
[13:23:36.891]                 }, immediateCondition = function(cond) {
[13:23:36.891]                   sendCondition <- ...future.makeSendCondition()
[13:23:36.891]                   sendCondition(cond)
[13:23:36.891]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.891]                   {
[13:23:36.891]                     inherits <- base::inherits
[13:23:36.891]                     invokeRestart <- base::invokeRestart
[13:23:36.891]                     is.null <- base::is.null
[13:23:36.891]                     muffled <- FALSE
[13:23:36.891]                     if (inherits(cond, "message")) {
[13:23:36.891]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:36.891]                       if (muffled) 
[13:23:36.891]                         invokeRestart("muffleMessage")
[13:23:36.891]                     }
[13:23:36.891]                     else if (inherits(cond, "warning")) {
[13:23:36.891]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:36.891]                       if (muffled) 
[13:23:36.891]                         invokeRestart("muffleWarning")
[13:23:36.891]                     }
[13:23:36.891]                     else if (inherits(cond, "condition")) {
[13:23:36.891]                       if (!is.null(pattern)) {
[13:23:36.891]                         computeRestarts <- base::computeRestarts
[13:23:36.891]                         grepl <- base::grepl
[13:23:36.891]                         restarts <- computeRestarts(cond)
[13:23:36.891]                         for (restart in restarts) {
[13:23:36.891]                           name <- restart$name
[13:23:36.891]                           if (is.null(name)) 
[13:23:36.891]                             next
[13:23:36.891]                           if (!grepl(pattern, name)) 
[13:23:36.891]                             next
[13:23:36.891]                           invokeRestart(restart)
[13:23:36.891]                           muffled <- TRUE
[13:23:36.891]                           break
[13:23:36.891]                         }
[13:23:36.891]                       }
[13:23:36.891]                     }
[13:23:36.891]                     invisible(muffled)
[13:23:36.891]                   }
[13:23:36.891]                   muffleCondition(cond)
[13:23:36.891]                 })
[13:23:36.891]             }))
[13:23:36.891]             future::FutureResult(value = ...future.value$value, 
[13:23:36.891]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.891]                   ...future.rng), globalenv = if (FALSE) 
[13:23:36.891]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:36.891]                     ...future.globalenv.names))
[13:23:36.891]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:36.891]         }, condition = base::local({
[13:23:36.891]             c <- base::c
[13:23:36.891]             inherits <- base::inherits
[13:23:36.891]             invokeRestart <- base::invokeRestart
[13:23:36.891]             length <- base::length
[13:23:36.891]             list <- base::list
[13:23:36.891]             seq.int <- base::seq.int
[13:23:36.891]             signalCondition <- base::signalCondition
[13:23:36.891]             sys.calls <- base::sys.calls
[13:23:36.891]             `[[` <- base::`[[`
[13:23:36.891]             `+` <- base::`+`
[13:23:36.891]             `<<-` <- base::`<<-`
[13:23:36.891]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:36.891]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:36.891]                   3L)]
[13:23:36.891]             }
[13:23:36.891]             function(cond) {
[13:23:36.891]                 is_error <- inherits(cond, "error")
[13:23:36.891]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:36.891]                   NULL)
[13:23:36.891]                 if (is_error) {
[13:23:36.891]                   sessionInformation <- function() {
[13:23:36.891]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:36.891]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:36.891]                       search = base::search(), system = base::Sys.info())
[13:23:36.891]                   }
[13:23:36.891]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.891]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:36.891]                     cond$call), session = sessionInformation(), 
[13:23:36.891]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:36.891]                   signalCondition(cond)
[13:23:36.891]                 }
[13:23:36.891]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:36.891]                 "immediateCondition"))) {
[13:23:36.891]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:36.891]                   ...future.conditions[[length(...future.conditions) + 
[13:23:36.891]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:36.891]                   if (TRUE && !signal) {
[13:23:36.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.891]                     {
[13:23:36.891]                       inherits <- base::inherits
[13:23:36.891]                       invokeRestart <- base::invokeRestart
[13:23:36.891]                       is.null <- base::is.null
[13:23:36.891]                       muffled <- FALSE
[13:23:36.891]                       if (inherits(cond, "message")) {
[13:23:36.891]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.891]                         if (muffled) 
[13:23:36.891]                           invokeRestart("muffleMessage")
[13:23:36.891]                       }
[13:23:36.891]                       else if (inherits(cond, "warning")) {
[13:23:36.891]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.891]                         if (muffled) 
[13:23:36.891]                           invokeRestart("muffleWarning")
[13:23:36.891]                       }
[13:23:36.891]                       else if (inherits(cond, "condition")) {
[13:23:36.891]                         if (!is.null(pattern)) {
[13:23:36.891]                           computeRestarts <- base::computeRestarts
[13:23:36.891]                           grepl <- base::grepl
[13:23:36.891]                           restarts <- computeRestarts(cond)
[13:23:36.891]                           for (restart in restarts) {
[13:23:36.891]                             name <- restart$name
[13:23:36.891]                             if (is.null(name)) 
[13:23:36.891]                               next
[13:23:36.891]                             if (!grepl(pattern, name)) 
[13:23:36.891]                               next
[13:23:36.891]                             invokeRestart(restart)
[13:23:36.891]                             muffled <- TRUE
[13:23:36.891]                             break
[13:23:36.891]                           }
[13:23:36.891]                         }
[13:23:36.891]                       }
[13:23:36.891]                       invisible(muffled)
[13:23:36.891]                     }
[13:23:36.891]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.891]                   }
[13:23:36.891]                 }
[13:23:36.891]                 else {
[13:23:36.891]                   if (TRUE) {
[13:23:36.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:36.891]                     {
[13:23:36.891]                       inherits <- base::inherits
[13:23:36.891]                       invokeRestart <- base::invokeRestart
[13:23:36.891]                       is.null <- base::is.null
[13:23:36.891]                       muffled <- FALSE
[13:23:36.891]                       if (inherits(cond, "message")) {
[13:23:36.891]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:36.891]                         if (muffled) 
[13:23:36.891]                           invokeRestart("muffleMessage")
[13:23:36.891]                       }
[13:23:36.891]                       else if (inherits(cond, "warning")) {
[13:23:36.891]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:36.891]                         if (muffled) 
[13:23:36.891]                           invokeRestart("muffleWarning")
[13:23:36.891]                       }
[13:23:36.891]                       else if (inherits(cond, "condition")) {
[13:23:36.891]                         if (!is.null(pattern)) {
[13:23:36.891]                           computeRestarts <- base::computeRestarts
[13:23:36.891]                           grepl <- base::grepl
[13:23:36.891]                           restarts <- computeRestarts(cond)
[13:23:36.891]                           for (restart in restarts) {
[13:23:36.891]                             name <- restart$name
[13:23:36.891]                             if (is.null(name)) 
[13:23:36.891]                               next
[13:23:36.891]                             if (!grepl(pattern, name)) 
[13:23:36.891]                               next
[13:23:36.891]                             invokeRestart(restart)
[13:23:36.891]                             muffled <- TRUE
[13:23:36.891]                             break
[13:23:36.891]                           }
[13:23:36.891]                         }
[13:23:36.891]                       }
[13:23:36.891]                       invisible(muffled)
[13:23:36.891]                     }
[13:23:36.891]                     muffleCondition(cond, pattern = "^muffle")
[13:23:36.891]                   }
[13:23:36.891]                 }
[13:23:36.891]             }
[13:23:36.891]         }))
[13:23:36.891]     }, error = function(ex) {
[13:23:36.891]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:36.891]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:36.891]                 ...future.rng), started = ...future.startTime, 
[13:23:36.891]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:36.891]             version = "1.8"), class = "FutureResult")
[13:23:36.891]     }, finally = {
[13:23:36.891]         if (!identical(...future.workdir, getwd())) 
[13:23:36.891]             setwd(...future.workdir)
[13:23:36.891]         {
[13:23:36.891]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:36.891]                 ...future.oldOptions$nwarnings <- NULL
[13:23:36.891]             }
[13:23:36.891]             base::options(...future.oldOptions)
[13:23:36.891]             if (.Platform$OS.type == "windows") {
[13:23:36.891]                 old_names <- names(...future.oldEnvVars)
[13:23:36.891]                 envs <- base::Sys.getenv()
[13:23:36.891]                 names <- names(envs)
[13:23:36.891]                 common <- intersect(names, old_names)
[13:23:36.891]                 added <- setdiff(names, old_names)
[13:23:36.891]                 removed <- setdiff(old_names, names)
[13:23:36.891]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:36.891]                   envs[common]]
[13:23:36.891]                 NAMES <- toupper(changed)
[13:23:36.891]                 args <- list()
[13:23:36.891]                 for (kk in seq_along(NAMES)) {
[13:23:36.891]                   name <- changed[[kk]]
[13:23:36.891]                   NAME <- NAMES[[kk]]
[13:23:36.891]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.891]                     next
[13:23:36.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.891]                 }
[13:23:36.891]                 NAMES <- toupper(added)
[13:23:36.891]                 for (kk in seq_along(NAMES)) {
[13:23:36.891]                   name <- added[[kk]]
[13:23:36.891]                   NAME <- NAMES[[kk]]
[13:23:36.891]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.891]                     next
[13:23:36.891]                   args[[name]] <- ""
[13:23:36.891]                 }
[13:23:36.891]                 NAMES <- toupper(removed)
[13:23:36.891]                 for (kk in seq_along(NAMES)) {
[13:23:36.891]                   name <- removed[[kk]]
[13:23:36.891]                   NAME <- NAMES[[kk]]
[13:23:36.891]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:36.891]                     next
[13:23:36.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:36.891]                 }
[13:23:36.891]                 if (length(args) > 0) 
[13:23:36.891]                   base::do.call(base::Sys.setenv, args = args)
[13:23:36.891]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:36.891]             }
[13:23:36.891]             else {
[13:23:36.891]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:36.891]             }
[13:23:36.891]             {
[13:23:36.891]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:36.891]                   0L) {
[13:23:36.891]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:36.891]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:36.891]                   base::options(opts)
[13:23:36.891]                 }
[13:23:36.891]                 {
[13:23:36.891]                   {
[13:23:36.891]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:36.891]                     NULL
[13:23:36.891]                   }
[13:23:36.891]                   options(future.plan = NULL)
[13:23:36.891]                   if (is.na(NA_character_)) 
[13:23:36.891]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:36.891]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:36.891]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:36.891]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:36.891]                     envir = parent.frame()) 
[13:23:36.891]                   {
[13:23:36.891]                     if (is.function(workers)) 
[13:23:36.891]                       workers <- workers()
[13:23:36.891]                     workers <- structure(as.integer(workers), 
[13:23:36.891]                       class = class(workers))
[13:23:36.891]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:36.891]                       workers >= 1)
[13:23:36.891]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:36.891]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:36.891]                     }
[13:23:36.891]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:36.891]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:36.891]                       envir = envir)
[13:23:36.891]                     if (!future$lazy) 
[13:23:36.891]                       future <- run(future)
[13:23:36.891]                     invisible(future)
[13:23:36.891]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:36.891]                 }
[13:23:36.891]             }
[13:23:36.891]         }
[13:23:36.891]     })
[13:23:36.891]     if (TRUE) {
[13:23:36.891]         base::sink(type = "output", split = FALSE)
[13:23:36.891]         if (TRUE) {
[13:23:36.891]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:36.891]         }
[13:23:36.891]         else {
[13:23:36.891]             ...future.result["stdout"] <- base::list(NULL)
[13:23:36.891]         }
[13:23:36.891]         base::close(...future.stdout)
[13:23:36.891]         ...future.stdout <- NULL
[13:23:36.891]     }
[13:23:36.891]     ...future.result$conditions <- ...future.conditions
[13:23:36.891]     ...future.result$finished <- base::Sys.time()
[13:23:36.891]     ...future.result
[13:23:36.891] }
[13:23:36.894] Exporting 1 global objects (1.56 MiB) to cluster node #1 ...
[13:23:36.896] Exporting ‘a’ (1.56 MiB) to cluster node #1 ...
[13:23:36.948] Exporting ‘a’ (1.56 MiB) to cluster node #1 ... DONE
[13:23:36.949] Exporting 1 global objects (1.56 MiB) to cluster node #1 ... DONE
[13:23:36.949] MultisessionFuture started
[13:23:36.949] - Launch lazy future ... done
[13:23:36.949] run() for ‘MultisessionFuture’ ... done
[13:23:36.950] result() for ClusterFuture ...
[13:23:36.950] receiveMessageFromWorker() for ClusterFuture ...
[13:23:36.950] - Validating connection of MultisessionFuture
[13:23:36.998] - received message: FutureResult
[13:23:36.998] - Received FutureResult
[13:23:36.998] - Erased future from FutureRegistry
[13:23:36.998] result() for ClusterFuture ...
[13:23:36.998] - result already collected: FutureResult
[13:23:36.998] result() for ClusterFuture ... done
[13:23:36.999] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:36.999] result() for ClusterFuture ... done
[13:23:36.999] result() for ClusterFuture ...
[13:23:36.999] - result already collected: FutureResult
[13:23:36.999] result() for ClusterFuture ... done
value(b) = 2
[13:23:36.999] result() for ClusterFuture ...
[13:23:36.999] - result already collected: FutureResult
[13:23:36.999] result() for ClusterFuture ... done
[13:23:36.999] result() for ClusterFuture ...
[13:23:36.999] - result already collected: FutureResult
[13:23:37.000] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:37.000] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:37.000] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:37.001] 
[13:23:37.001] Searching for globals ... DONE
[13:23:37.001] - globals: [0] <none>
[13:23:37.001] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:37.001] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:37.001] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:37.002] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:37.002] Searching for globals ... DONE
[13:23:37.002] Resolving globals: TRUE
[13:23:37.002] Resolving any globals that are futures ...
[13:23:37.003] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:37.003] Resolving any globals that are futures ... DONE
[13:23:37.003] Resolving futures part of globals (recursively) ...
[13:23:37.003] resolve() on list ...
[13:23:37.003]  recursive: 99
[13:23:37.003]  length: 1
[13:23:37.003]  elements: ‘a’
[13:23:37.004] run() for ‘Future’ ...
[13:23:37.004] - state: ‘created’
[13:23:37.004] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:37.019] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:37.019] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:37.020]   - Field: ‘node’
[13:23:37.020]   - Field: ‘label’
[13:23:37.020]   - Field: ‘local’
[13:23:37.020]   - Field: ‘owner’
[13:23:37.020]   - Field: ‘envir’
[13:23:37.020]   - Field: ‘workers’
[13:23:37.020]   - Field: ‘packages’
[13:23:37.020]   - Field: ‘gc’
[13:23:37.020]   - Field: ‘conditions’
[13:23:37.021]   - Field: ‘persistent’
[13:23:37.021]   - Field: ‘expr’
[13:23:37.021]   - Field: ‘uuid’
[13:23:37.021]   - Field: ‘seed’
[13:23:37.021]   - Field: ‘version’
[13:23:37.021]   - Field: ‘result’
[13:23:37.021]   - Field: ‘asynchronous’
[13:23:37.021]   - Field: ‘calls’
[13:23:37.021]   - Field: ‘globals’
[13:23:37.021]   - Field: ‘stdout’
[13:23:37.022]   - Field: ‘earlySignal’
[13:23:37.022]   - Field: ‘lazy’
[13:23:37.022]   - Field: ‘state’
[13:23:37.022] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:37.022] - Launch lazy future ...
[13:23:37.022] Packages needed by the future expression (n = 0): <none>
[13:23:37.022] Packages needed by future strategies (n = 0): <none>
[13:23:37.023] {
[13:23:37.023]     {
[13:23:37.023]         {
[13:23:37.023]             ...future.startTime <- base::Sys.time()
[13:23:37.023]             {
[13:23:37.023]                 {
[13:23:37.023]                   {
[13:23:37.023]                     {
[13:23:37.023]                       base::local({
[13:23:37.023]                         has_future <- base::requireNamespace("future", 
[13:23:37.023]                           quietly = TRUE)
[13:23:37.023]                         if (has_future) {
[13:23:37.023]                           ns <- base::getNamespace("future")
[13:23:37.023]                           version <- ns[[".package"]][["version"]]
[13:23:37.023]                           if (is.null(version)) 
[13:23:37.023]                             version <- utils::packageVersion("future")
[13:23:37.023]                         }
[13:23:37.023]                         else {
[13:23:37.023]                           version <- NULL
[13:23:37.023]                         }
[13:23:37.023]                         if (!has_future || version < "1.8.0") {
[13:23:37.023]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:37.023]                             "", base::R.version$version.string), 
[13:23:37.023]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:37.023]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:37.023]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:37.023]                               "release", "version")], collapse = " "), 
[13:23:37.023]                             hostname = base::Sys.info()[["nodename"]])
[13:23:37.023]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:37.023]                             info)
[13:23:37.023]                           info <- base::paste(info, collapse = "; ")
[13:23:37.023]                           if (!has_future) {
[13:23:37.023]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:37.023]                               info)
[13:23:37.023]                           }
[13:23:37.023]                           else {
[13:23:37.023]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:37.023]                               info, version)
[13:23:37.023]                           }
[13:23:37.023]                           base::stop(msg)
[13:23:37.023]                         }
[13:23:37.023]                       })
[13:23:37.023]                     }
[13:23:37.023]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:37.023]                     base::options(mc.cores = 1L)
[13:23:37.023]                   }
[13:23:37.023]                   options(future.plan = NULL)
[13:23:37.023]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:37.023]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:37.023]                 }
[13:23:37.023]                 ...future.workdir <- getwd()
[13:23:37.023]             }
[13:23:37.023]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:37.023]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:37.023]         }
[13:23:37.023]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:37.023]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:37.023]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:37.023]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:37.023]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:37.023]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:37.023]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:37.023]             base::names(...future.oldOptions))
[13:23:37.023]     }
[13:23:37.023]     if (FALSE) {
[13:23:37.023]     }
[13:23:37.023]     else {
[13:23:37.023]         if (TRUE) {
[13:23:37.023]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:37.023]                 open = "w")
[13:23:37.023]         }
[13:23:37.023]         else {
[13:23:37.023]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:37.023]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:37.023]         }
[13:23:37.023]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:37.023]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:37.023]             base::sink(type = "output", split = FALSE)
[13:23:37.023]             base::close(...future.stdout)
[13:23:37.023]         }, add = TRUE)
[13:23:37.023]     }
[13:23:37.023]     ...future.frame <- base::sys.nframe()
[13:23:37.023]     ...future.conditions <- base::list()
[13:23:37.023]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:37.023]     if (FALSE) {
[13:23:37.023]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:37.023]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:37.023]     }
[13:23:37.023]     ...future.result <- base::tryCatch({
[13:23:37.023]         base::withCallingHandlers({
[13:23:37.023]             ...future.value <- base::withVisible(base::local({
[13:23:37.023]                 ...future.makeSendCondition <- base::local({
[13:23:37.023]                   sendCondition <- NULL
[13:23:37.023]                   function(frame = 1L) {
[13:23:37.023]                     if (is.function(sendCondition)) 
[13:23:37.023]                       return(sendCondition)
[13:23:37.023]                     ns <- getNamespace("parallel")
[13:23:37.023]                     if (exists("sendData", mode = "function", 
[13:23:37.023]                       envir = ns)) {
[13:23:37.023]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:37.023]                         envir = ns)
[13:23:37.023]                       envir <- sys.frame(frame)
[13:23:37.023]                       master <- NULL
[13:23:37.023]                       while (!identical(envir, .GlobalEnv) && 
[13:23:37.023]                         !identical(envir, emptyenv())) {
[13:23:37.023]                         if (exists("master", mode = "list", envir = envir, 
[13:23:37.023]                           inherits = FALSE)) {
[13:23:37.023]                           master <- get("master", mode = "list", 
[13:23:37.023]                             envir = envir, inherits = FALSE)
[13:23:37.023]                           if (inherits(master, c("SOCKnode", 
[13:23:37.023]                             "SOCK0node"))) {
[13:23:37.023]                             sendCondition <<- function(cond) {
[13:23:37.023]                               data <- list(type = "VALUE", value = cond, 
[13:23:37.023]                                 success = TRUE)
[13:23:37.023]                               parallel_sendData(master, data)
[13:23:37.023]                             }
[13:23:37.023]                             return(sendCondition)
[13:23:37.023]                           }
[13:23:37.023]                         }
[13:23:37.023]                         frame <- frame + 1L
[13:23:37.023]                         envir <- sys.frame(frame)
[13:23:37.023]                       }
[13:23:37.023]                     }
[13:23:37.023]                     sendCondition <<- function(cond) NULL
[13:23:37.023]                   }
[13:23:37.023]                 })
[13:23:37.023]                 withCallingHandlers({
[13:23:37.023]                   1
[13:23:37.023]                 }, immediateCondition = function(cond) {
[13:23:37.023]                   sendCondition <- ...future.makeSendCondition()
[13:23:37.023]                   sendCondition(cond)
[13:23:37.023]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:37.023]                   {
[13:23:37.023]                     inherits <- base::inherits
[13:23:37.023]                     invokeRestart <- base::invokeRestart
[13:23:37.023]                     is.null <- base::is.null
[13:23:37.023]                     muffled <- FALSE
[13:23:37.023]                     if (inherits(cond, "message")) {
[13:23:37.023]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:37.023]                       if (muffled) 
[13:23:37.023]                         invokeRestart("muffleMessage")
[13:23:37.023]                     }
[13:23:37.023]                     else if (inherits(cond, "warning")) {
[13:23:37.023]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:37.023]                       if (muffled) 
[13:23:37.023]                         invokeRestart("muffleWarning")
[13:23:37.023]                     }
[13:23:37.023]                     else if (inherits(cond, "condition")) {
[13:23:37.023]                       if (!is.null(pattern)) {
[13:23:37.023]                         computeRestarts <- base::computeRestarts
[13:23:37.023]                         grepl <- base::grepl
[13:23:37.023]                         restarts <- computeRestarts(cond)
[13:23:37.023]                         for (restart in restarts) {
[13:23:37.023]                           name <- restart$name
[13:23:37.023]                           if (is.null(name)) 
[13:23:37.023]                             next
[13:23:37.023]                           if (!grepl(pattern, name)) 
[13:23:37.023]                             next
[13:23:37.023]                           invokeRestart(restart)
[13:23:37.023]                           muffled <- TRUE
[13:23:37.023]                           break
[13:23:37.023]                         }
[13:23:37.023]                       }
[13:23:37.023]                     }
[13:23:37.023]                     invisible(muffled)
[13:23:37.023]                   }
[13:23:37.023]                   muffleCondition(cond)
[13:23:37.023]                 })
[13:23:37.023]             }))
[13:23:37.023]             future::FutureResult(value = ...future.value$value, 
[13:23:37.023]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:37.023]                   ...future.rng), globalenv = if (FALSE) 
[13:23:37.023]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:37.023]                     ...future.globalenv.names))
[13:23:37.023]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:37.023]         }, condition = base::local({
[13:23:37.023]             c <- base::c
[13:23:37.023]             inherits <- base::inherits
[13:23:37.023]             invokeRestart <- base::invokeRestart
[13:23:37.023]             length <- base::length
[13:23:37.023]             list <- base::list
[13:23:37.023]             seq.int <- base::seq.int
[13:23:37.023]             signalCondition <- base::signalCondition
[13:23:37.023]             sys.calls <- base::sys.calls
[13:23:37.023]             `[[` <- base::`[[`
[13:23:37.023]             `+` <- base::`+`
[13:23:37.023]             `<<-` <- base::`<<-`
[13:23:37.023]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:37.023]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:37.023]                   3L)]
[13:23:37.023]             }
[13:23:37.023]             function(cond) {
[13:23:37.023]                 is_error <- inherits(cond, "error")
[13:23:37.023]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:37.023]                   NULL)
[13:23:37.023]                 if (is_error) {
[13:23:37.023]                   sessionInformation <- function() {
[13:23:37.023]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:37.023]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:37.023]                       search = base::search(), system = base::Sys.info())
[13:23:37.023]                   }
[13:23:37.023]                   ...future.conditions[[length(...future.conditions) + 
[13:23:37.023]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:37.023]                     cond$call), session = sessionInformation(), 
[13:23:37.023]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:37.023]                   signalCondition(cond)
[13:23:37.023]                 }
[13:23:37.023]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:37.023]                 "immediateCondition"))) {
[13:23:37.023]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:37.023]                   ...future.conditions[[length(...future.conditions) + 
[13:23:37.023]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:37.023]                   if (TRUE && !signal) {
[13:23:37.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:37.023]                     {
[13:23:37.023]                       inherits <- base::inherits
[13:23:37.023]                       invokeRestart <- base::invokeRestart
[13:23:37.023]                       is.null <- base::is.null
[13:23:37.023]                       muffled <- FALSE
[13:23:37.023]                       if (inherits(cond, "message")) {
[13:23:37.023]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:37.023]                         if (muffled) 
[13:23:37.023]                           invokeRestart("muffleMessage")
[13:23:37.023]                       }
[13:23:37.023]                       else if (inherits(cond, "warning")) {
[13:23:37.023]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:37.023]                         if (muffled) 
[13:23:37.023]                           invokeRestart("muffleWarning")
[13:23:37.023]                       }
[13:23:37.023]                       else if (inherits(cond, "condition")) {
[13:23:37.023]                         if (!is.null(pattern)) {
[13:23:37.023]                           computeRestarts <- base::computeRestarts
[13:23:37.023]                           grepl <- base::grepl
[13:23:37.023]                           restarts <- computeRestarts(cond)
[13:23:37.023]                           for (restart in restarts) {
[13:23:37.023]                             name <- restart$name
[13:23:37.023]                             if (is.null(name)) 
[13:23:37.023]                               next
[13:23:37.023]                             if (!grepl(pattern, name)) 
[13:23:37.023]                               next
[13:23:37.023]                             invokeRestart(restart)
[13:23:37.023]                             muffled <- TRUE
[13:23:37.023]                             break
[13:23:37.023]                           }
[13:23:37.023]                         }
[13:23:37.023]                       }
[13:23:37.023]                       invisible(muffled)
[13:23:37.023]                     }
[13:23:37.023]                     muffleCondition(cond, pattern = "^muffle")
[13:23:37.023]                   }
[13:23:37.023]                 }
[13:23:37.023]                 else {
[13:23:37.023]                   if (TRUE) {
[13:23:37.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:37.023]                     {
[13:23:37.023]                       inherits <- base::inherits
[13:23:37.023]                       invokeRestart <- base::invokeRestart
[13:23:37.023]                       is.null <- base::is.null
[13:23:37.023]                       muffled <- FALSE
[13:23:37.023]                       if (inherits(cond, "message")) {
[13:23:37.023]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:37.023]                         if (muffled) 
[13:23:37.023]                           invokeRestart("muffleMessage")
[13:23:37.023]                       }
[13:23:37.023]                       else if (inherits(cond, "warning")) {
[13:23:37.023]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:37.023]                         if (muffled) 
[13:23:37.023]                           invokeRestart("muffleWarning")
[13:23:37.023]                       }
[13:23:37.023]                       else if (inherits(cond, "condition")) {
[13:23:37.023]                         if (!is.null(pattern)) {
[13:23:37.023]                           computeRestarts <- base::computeRestarts
[13:23:37.023]                           grepl <- base::grepl
[13:23:37.023]                           restarts <- computeRestarts(cond)
[13:23:37.023]                           for (restart in restarts) {
[13:23:37.023]                             name <- restart$name
[13:23:37.023]                             if (is.null(name)) 
[13:23:37.023]                               next
[13:23:37.023]                             if (!grepl(pattern, name)) 
[13:23:37.023]                               next
[13:23:37.023]                             invokeRestart(restart)
[13:23:37.023]                             muffled <- TRUE
[13:23:37.023]                             break
[13:23:37.023]                           }
[13:23:37.023]                         }
[13:23:37.023]                       }
[13:23:37.023]                       invisible(muffled)
[13:23:37.023]                     }
[13:23:37.023]                     muffleCondition(cond, pattern = "^muffle")
[13:23:37.023]                   }
[13:23:37.023]                 }
[13:23:37.023]             }
[13:23:37.023]         }))
[13:23:37.023]     }, error = function(ex) {
[13:23:37.023]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:37.023]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:37.023]                 ...future.rng), started = ...future.startTime, 
[13:23:37.023]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:37.023]             version = "1.8"), class = "FutureResult")
[13:23:37.023]     }, finally = {
[13:23:37.023]         if (!identical(...future.workdir, getwd())) 
[13:23:37.023]             setwd(...future.workdir)
[13:23:37.023]         {
[13:23:37.023]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:37.023]                 ...future.oldOptions$nwarnings <- NULL
[13:23:37.023]             }
[13:23:37.023]             base::options(...future.oldOptions)
[13:23:37.023]             if (.Platform$OS.type == "windows") {
[13:23:37.023]                 old_names <- names(...future.oldEnvVars)
[13:23:37.023]                 envs <- base::Sys.getenv()
[13:23:37.023]                 names <- names(envs)
[13:23:37.023]                 common <- intersect(names, old_names)
[13:23:37.023]                 added <- setdiff(names, old_names)
[13:23:37.023]                 removed <- setdiff(old_names, names)
[13:23:37.023]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:37.023]                   envs[common]]
[13:23:37.023]                 NAMES <- toupper(changed)
[13:23:37.023]                 args <- list()
[13:23:37.023]                 for (kk in seq_along(NAMES)) {
[13:23:37.023]                   name <- changed[[kk]]
[13:23:37.023]                   NAME <- NAMES[[kk]]
[13:23:37.023]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.023]                     next
[13:23:37.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:37.023]                 }
[13:23:37.023]                 NAMES <- toupper(added)
[13:23:37.023]                 for (kk in seq_along(NAMES)) {
[13:23:37.023]                   name <- added[[kk]]
[13:23:37.023]                   NAME <- NAMES[[kk]]
[13:23:37.023]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.023]                     next
[13:23:37.023]                   args[[name]] <- ""
[13:23:37.023]                 }
[13:23:37.023]                 NAMES <- toupper(removed)
[13:23:37.023]                 for (kk in seq_along(NAMES)) {
[13:23:37.023]                   name <- removed[[kk]]
[13:23:37.023]                   NAME <- NAMES[[kk]]
[13:23:37.023]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.023]                     next
[13:23:37.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:37.023]                 }
[13:23:37.023]                 if (length(args) > 0) 
[13:23:37.023]                   base::do.call(base::Sys.setenv, args = args)
[13:23:37.023]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:37.023]             }
[13:23:37.023]             else {
[13:23:37.023]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:37.023]             }
[13:23:37.023]             {
[13:23:37.023]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:37.023]                   0L) {
[13:23:37.023]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:37.023]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:37.023]                   base::options(opts)
[13:23:37.023]                 }
[13:23:37.023]                 {
[13:23:37.023]                   {
[13:23:37.023]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:37.023]                     NULL
[13:23:37.023]                   }
[13:23:37.023]                   options(future.plan = NULL)
[13:23:37.023]                   if (is.na(NA_character_)) 
[13:23:37.023]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:37.023]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:37.023]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:37.023]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:37.023]                     envir = parent.frame()) 
[13:23:37.023]                   {
[13:23:37.023]                     if (is.function(workers)) 
[13:23:37.023]                       workers <- workers()
[13:23:37.023]                     workers <- structure(as.integer(workers), 
[13:23:37.023]                       class = class(workers))
[13:23:37.023]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:37.023]                       workers >= 1)
[13:23:37.023]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:37.023]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:37.023]                     }
[13:23:37.023]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:37.023]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:37.023]                       envir = envir)
[13:23:37.023]                     if (!future$lazy) 
[13:23:37.023]                       future <- run(future)
[13:23:37.023]                     invisible(future)
[13:23:37.023]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:37.023]                 }
[13:23:37.023]             }
[13:23:37.023]         }
[13:23:37.023]     })
[13:23:37.023]     if (TRUE) {
[13:23:37.023]         base::sink(type = "output", split = FALSE)
[13:23:37.023]         if (TRUE) {
[13:23:37.023]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:37.023]         }
[13:23:37.023]         else {
[13:23:37.023]             ...future.result["stdout"] <- base::list(NULL)
[13:23:37.023]         }
[13:23:37.023]         base::close(...future.stdout)
[13:23:37.023]         ...future.stdout <- NULL
[13:23:37.023]     }
[13:23:37.023]     ...future.result$conditions <- ...future.conditions
[13:23:37.023]     ...future.result$finished <- base::Sys.time()
[13:23:37.023]     ...future.result
[13:23:37.023] }
[13:23:37.026] MultisessionFuture started
[13:23:37.026] - Launch lazy future ... done
[13:23:37.026] run() for ‘MultisessionFuture’ ... done
[13:23:37.075] receiveMessageFromWorker() for ClusterFuture ...
[13:23:37.076] - Validating connection of MultisessionFuture
[13:23:37.076] - received message: FutureResult
[13:23:37.076] - Received FutureResult
[13:23:37.076] - Erased future from FutureRegistry
[13:23:37.077] result() for ClusterFuture ...
[13:23:37.077] - result already collected: FutureResult
[13:23:37.077] result() for ClusterFuture ... done
[13:23:37.077] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:37.077] Future #1
[13:23:37.077] result() for ClusterFuture ...
[13:23:37.077] - result already collected: FutureResult
[13:23:37.077] result() for ClusterFuture ... done
[13:23:37.077] result() for ClusterFuture ...
[13:23:37.077] - result already collected: FutureResult
[13:23:37.077] result() for ClusterFuture ... done
[13:23:37.078] A MultisessionFuture was resolved
[13:23:37.078]  length: 0 (resolved future 1)
[13:23:37.078] resolve() on list ... DONE
[13:23:37.078] - globals: [1] ‘a’
[13:23:37.078] Resolving futures part of globals (recursively) ... DONE
[13:23:37.080] The total size of the 1 globals is 1.56 MiB (1641008 bytes)
[13:23:37.081] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.56 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.56 MiB of class ‘environment’)
[13:23:37.081] - globals: [1] ‘a’
[13:23:37.081] - packages: [1] ‘future’
[13:23:37.081] getGlobalsAndPackages() ... DONE
[13:23:37.081] run() for ‘Future’ ...
[13:23:37.081] - state: ‘created’
[13:23:37.082] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:37.096] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:37.096] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:37.096]   - Field: ‘node’
[13:23:37.096]   - Field: ‘label’
[13:23:37.096]   - Field: ‘local’
[13:23:37.096]   - Field: ‘owner’
[13:23:37.096]   - Field: ‘envir’
[13:23:37.097]   - Field: ‘workers’
[13:23:37.097]   - Field: ‘packages’
[13:23:37.097]   - Field: ‘gc’
[13:23:37.097]   - Field: ‘conditions’
[13:23:37.097]   - Field: ‘persistent’
[13:23:37.097]   - Field: ‘expr’
[13:23:37.097]   - Field: ‘uuid’
[13:23:37.097]   - Field: ‘seed’
[13:23:37.097]   - Field: ‘version’
[13:23:37.097]   - Field: ‘result’
[13:23:37.097]   - Field: ‘asynchronous’
[13:23:37.098]   - Field: ‘calls’
[13:23:37.098]   - Field: ‘globals’
[13:23:37.098]   - Field: ‘stdout’
[13:23:37.098]   - Field: ‘earlySignal’
[13:23:37.098]   - Field: ‘lazy’
[13:23:37.098]   - Field: ‘state’
[13:23:37.098] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:37.098] - Launch lazy future ...
[13:23:37.099] Packages needed by the future expression (n = 1): ‘future’
[13:23:37.099] Packages needed by future strategies (n = 0): <none>
[13:23:37.099] {
[13:23:37.099]     {
[13:23:37.099]         {
[13:23:37.099]             ...future.startTime <- base::Sys.time()
[13:23:37.099]             {
[13:23:37.099]                 {
[13:23:37.099]                   {
[13:23:37.099]                     {
[13:23:37.099]                       {
[13:23:37.099]                         base::local({
[13:23:37.099]                           has_future <- base::requireNamespace("future", 
[13:23:37.099]                             quietly = TRUE)
[13:23:37.099]                           if (has_future) {
[13:23:37.099]                             ns <- base::getNamespace("future")
[13:23:37.099]                             version <- ns[[".package"]][["version"]]
[13:23:37.099]                             if (is.null(version)) 
[13:23:37.099]                               version <- utils::packageVersion("future")
[13:23:37.099]                           }
[13:23:37.099]                           else {
[13:23:37.099]                             version <- NULL
[13:23:37.099]                           }
[13:23:37.099]                           if (!has_future || version < "1.8.0") {
[13:23:37.099]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:37.099]                               "", base::R.version$version.string), 
[13:23:37.099]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:37.099]                                 base::R.version$platform, 8 * 
[13:23:37.099]                                   base::.Machine$sizeof.pointer), 
[13:23:37.099]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:37.099]                                 "release", "version")], collapse = " "), 
[13:23:37.099]                               hostname = base::Sys.info()[["nodename"]])
[13:23:37.099]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:37.099]                               info)
[13:23:37.099]                             info <- base::paste(info, collapse = "; ")
[13:23:37.099]                             if (!has_future) {
[13:23:37.099]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:37.099]                                 info)
[13:23:37.099]                             }
[13:23:37.099]                             else {
[13:23:37.099]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:37.099]                                 info, version)
[13:23:37.099]                             }
[13:23:37.099]                             base::stop(msg)
[13:23:37.099]                           }
[13:23:37.099]                         })
[13:23:37.099]                       }
[13:23:37.099]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:37.099]                       base::options(mc.cores = 1L)
[13:23:37.099]                     }
[13:23:37.099]                     base::local({
[13:23:37.099]                       for (pkg in "future") {
[13:23:37.099]                         base::loadNamespace(pkg)
[13:23:37.099]                         base::library(pkg, character.only = TRUE)
[13:23:37.099]                       }
[13:23:37.099]                     })
[13:23:37.099]                   }
[13:23:37.099]                   options(future.plan = NULL)
[13:23:37.099]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:37.099]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:37.099]                 }
[13:23:37.099]                 ...future.workdir <- getwd()
[13:23:37.099]             }
[13:23:37.099]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:37.099]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:37.099]         }
[13:23:37.099]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:37.099]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:37.099]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:37.099]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:37.099]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:37.099]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:37.099]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:37.099]             base::names(...future.oldOptions))
[13:23:37.099]     }
[13:23:37.099]     if (FALSE) {
[13:23:37.099]     }
[13:23:37.099]     else {
[13:23:37.099]         if (TRUE) {
[13:23:37.099]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:37.099]                 open = "w")
[13:23:37.099]         }
[13:23:37.099]         else {
[13:23:37.099]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:37.099]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:37.099]         }
[13:23:37.099]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:37.099]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:37.099]             base::sink(type = "output", split = FALSE)
[13:23:37.099]             base::close(...future.stdout)
[13:23:37.099]         }, add = TRUE)
[13:23:37.099]     }
[13:23:37.099]     ...future.frame <- base::sys.nframe()
[13:23:37.099]     ...future.conditions <- base::list()
[13:23:37.099]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:37.099]     if (FALSE) {
[13:23:37.099]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:37.099]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:37.099]     }
[13:23:37.099]     ...future.result <- base::tryCatch({
[13:23:37.099]         base::withCallingHandlers({
[13:23:37.099]             ...future.value <- base::withVisible(base::local({
[13:23:37.099]                 ...future.makeSendCondition <- base::local({
[13:23:37.099]                   sendCondition <- NULL
[13:23:37.099]                   function(frame = 1L) {
[13:23:37.099]                     if (is.function(sendCondition)) 
[13:23:37.099]                       return(sendCondition)
[13:23:37.099]                     ns <- getNamespace("parallel")
[13:23:37.099]                     if (exists("sendData", mode = "function", 
[13:23:37.099]                       envir = ns)) {
[13:23:37.099]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:37.099]                         envir = ns)
[13:23:37.099]                       envir <- sys.frame(frame)
[13:23:37.099]                       master <- NULL
[13:23:37.099]                       while (!identical(envir, .GlobalEnv) && 
[13:23:37.099]                         !identical(envir, emptyenv())) {
[13:23:37.099]                         if (exists("master", mode = "list", envir = envir, 
[13:23:37.099]                           inherits = FALSE)) {
[13:23:37.099]                           master <- get("master", mode = "list", 
[13:23:37.099]                             envir = envir, inherits = FALSE)
[13:23:37.099]                           if (inherits(master, c("SOCKnode", 
[13:23:37.099]                             "SOCK0node"))) {
[13:23:37.099]                             sendCondition <<- function(cond) {
[13:23:37.099]                               data <- list(type = "VALUE", value = cond, 
[13:23:37.099]                                 success = TRUE)
[13:23:37.099]                               parallel_sendData(master, data)
[13:23:37.099]                             }
[13:23:37.099]                             return(sendCondition)
[13:23:37.099]                           }
[13:23:37.099]                         }
[13:23:37.099]                         frame <- frame + 1L
[13:23:37.099]                         envir <- sys.frame(frame)
[13:23:37.099]                       }
[13:23:37.099]                     }
[13:23:37.099]                     sendCondition <<- function(cond) NULL
[13:23:37.099]                   }
[13:23:37.099]                 })
[13:23:37.099]                 withCallingHandlers({
[13:23:37.099]                   value(a) + 1
[13:23:37.099]                 }, immediateCondition = function(cond) {
[13:23:37.099]                   sendCondition <- ...future.makeSendCondition()
[13:23:37.099]                   sendCondition(cond)
[13:23:37.099]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:37.099]                   {
[13:23:37.099]                     inherits <- base::inherits
[13:23:37.099]                     invokeRestart <- base::invokeRestart
[13:23:37.099]                     is.null <- base::is.null
[13:23:37.099]                     muffled <- FALSE
[13:23:37.099]                     if (inherits(cond, "message")) {
[13:23:37.099]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:37.099]                       if (muffled) 
[13:23:37.099]                         invokeRestart("muffleMessage")
[13:23:37.099]                     }
[13:23:37.099]                     else if (inherits(cond, "warning")) {
[13:23:37.099]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:37.099]                       if (muffled) 
[13:23:37.099]                         invokeRestart("muffleWarning")
[13:23:37.099]                     }
[13:23:37.099]                     else if (inherits(cond, "condition")) {
[13:23:37.099]                       if (!is.null(pattern)) {
[13:23:37.099]                         computeRestarts <- base::computeRestarts
[13:23:37.099]                         grepl <- base::grepl
[13:23:37.099]                         restarts <- computeRestarts(cond)
[13:23:37.099]                         for (restart in restarts) {
[13:23:37.099]                           name <- restart$name
[13:23:37.099]                           if (is.null(name)) 
[13:23:37.099]                             next
[13:23:37.099]                           if (!grepl(pattern, name)) 
[13:23:37.099]                             next
[13:23:37.099]                           invokeRestart(restart)
[13:23:37.099]                           muffled <- TRUE
[13:23:37.099]                           break
[13:23:37.099]                         }
[13:23:37.099]                       }
[13:23:37.099]                     }
[13:23:37.099]                     invisible(muffled)
[13:23:37.099]                   }
[13:23:37.099]                   muffleCondition(cond)
[13:23:37.099]                 })
[13:23:37.099]             }))
[13:23:37.099]             future::FutureResult(value = ...future.value$value, 
[13:23:37.099]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:37.099]                   ...future.rng), globalenv = if (FALSE) 
[13:23:37.099]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:37.099]                     ...future.globalenv.names))
[13:23:37.099]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:37.099]         }, condition = base::local({
[13:23:37.099]             c <- base::c
[13:23:37.099]             inherits <- base::inherits
[13:23:37.099]             invokeRestart <- base::invokeRestart
[13:23:37.099]             length <- base::length
[13:23:37.099]             list <- base::list
[13:23:37.099]             seq.int <- base::seq.int
[13:23:37.099]             signalCondition <- base::signalCondition
[13:23:37.099]             sys.calls <- base::sys.calls
[13:23:37.099]             `[[` <- base::`[[`
[13:23:37.099]             `+` <- base::`+`
[13:23:37.099]             `<<-` <- base::`<<-`
[13:23:37.099]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:37.099]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:37.099]                   3L)]
[13:23:37.099]             }
[13:23:37.099]             function(cond) {
[13:23:37.099]                 is_error <- inherits(cond, "error")
[13:23:37.099]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:37.099]                   NULL)
[13:23:37.099]                 if (is_error) {
[13:23:37.099]                   sessionInformation <- function() {
[13:23:37.099]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:37.099]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:37.099]                       search = base::search(), system = base::Sys.info())
[13:23:37.099]                   }
[13:23:37.099]                   ...future.conditions[[length(...future.conditions) + 
[13:23:37.099]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:37.099]                     cond$call), session = sessionInformation(), 
[13:23:37.099]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:37.099]                   signalCondition(cond)
[13:23:37.099]                 }
[13:23:37.099]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:37.099]                 "immediateCondition"))) {
[13:23:37.099]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:37.099]                   ...future.conditions[[length(...future.conditions) + 
[13:23:37.099]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:37.099]                   if (TRUE && !signal) {
[13:23:37.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:37.099]                     {
[13:23:37.099]                       inherits <- base::inherits
[13:23:37.099]                       invokeRestart <- base::invokeRestart
[13:23:37.099]                       is.null <- base::is.null
[13:23:37.099]                       muffled <- FALSE
[13:23:37.099]                       if (inherits(cond, "message")) {
[13:23:37.099]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:37.099]                         if (muffled) 
[13:23:37.099]                           invokeRestart("muffleMessage")
[13:23:37.099]                       }
[13:23:37.099]                       else if (inherits(cond, "warning")) {
[13:23:37.099]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:37.099]                         if (muffled) 
[13:23:37.099]                           invokeRestart("muffleWarning")
[13:23:37.099]                       }
[13:23:37.099]                       else if (inherits(cond, "condition")) {
[13:23:37.099]                         if (!is.null(pattern)) {
[13:23:37.099]                           computeRestarts <- base::computeRestarts
[13:23:37.099]                           grepl <- base::grepl
[13:23:37.099]                           restarts <- computeRestarts(cond)
[13:23:37.099]                           for (restart in restarts) {
[13:23:37.099]                             name <- restart$name
[13:23:37.099]                             if (is.null(name)) 
[13:23:37.099]                               next
[13:23:37.099]                             if (!grepl(pattern, name)) 
[13:23:37.099]                               next
[13:23:37.099]                             invokeRestart(restart)
[13:23:37.099]                             muffled <- TRUE
[13:23:37.099]                             break
[13:23:37.099]                           }
[13:23:37.099]                         }
[13:23:37.099]                       }
[13:23:37.099]                       invisible(muffled)
[13:23:37.099]                     }
[13:23:37.099]                     muffleCondition(cond, pattern = "^muffle")
[13:23:37.099]                   }
[13:23:37.099]                 }
[13:23:37.099]                 else {
[13:23:37.099]                   if (TRUE) {
[13:23:37.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:37.099]                     {
[13:23:37.099]                       inherits <- base::inherits
[13:23:37.099]                       invokeRestart <- base::invokeRestart
[13:23:37.099]                       is.null <- base::is.null
[13:23:37.099]                       muffled <- FALSE
[13:23:37.099]                       if (inherits(cond, "message")) {
[13:23:37.099]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:37.099]                         if (muffled) 
[13:23:37.099]                           invokeRestart("muffleMessage")
[13:23:37.099]                       }
[13:23:37.099]                       else if (inherits(cond, "warning")) {
[13:23:37.099]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:37.099]                         if (muffled) 
[13:23:37.099]                           invokeRestart("muffleWarning")
[13:23:37.099]                       }
[13:23:37.099]                       else if (inherits(cond, "condition")) {
[13:23:37.099]                         if (!is.null(pattern)) {
[13:23:37.099]                           computeRestarts <- base::computeRestarts
[13:23:37.099]                           grepl <- base::grepl
[13:23:37.099]                           restarts <- computeRestarts(cond)
[13:23:37.099]                           for (restart in restarts) {
[13:23:37.099]                             name <- restart$name
[13:23:37.099]                             if (is.null(name)) 
[13:23:37.099]                               next
[13:23:37.099]                             if (!grepl(pattern, name)) 
[13:23:37.099]                               next
[13:23:37.099]                             invokeRestart(restart)
[13:23:37.099]                             muffled <- TRUE
[13:23:37.099]                             break
[13:23:37.099]                           }
[13:23:37.099]                         }
[13:23:37.099]                       }
[13:23:37.099]                       invisible(muffled)
[13:23:37.099]                     }
[13:23:37.099]                     muffleCondition(cond, pattern = "^muffle")
[13:23:37.099]                   }
[13:23:37.099]                 }
[13:23:37.099]             }
[13:23:37.099]         }))
[13:23:37.099]     }, error = function(ex) {
[13:23:37.099]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:37.099]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:37.099]                 ...future.rng), started = ...future.startTime, 
[13:23:37.099]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:37.099]             version = "1.8"), class = "FutureResult")
[13:23:37.099]     }, finally = {
[13:23:37.099]         if (!identical(...future.workdir, getwd())) 
[13:23:37.099]             setwd(...future.workdir)
[13:23:37.099]         {
[13:23:37.099]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:37.099]                 ...future.oldOptions$nwarnings <- NULL
[13:23:37.099]             }
[13:23:37.099]             base::options(...future.oldOptions)
[13:23:37.099]             if (.Platform$OS.type == "windows") {
[13:23:37.099]                 old_names <- names(...future.oldEnvVars)
[13:23:37.099]                 envs <- base::Sys.getenv()
[13:23:37.099]                 names <- names(envs)
[13:23:37.099]                 common <- intersect(names, old_names)
[13:23:37.099]                 added <- setdiff(names, old_names)
[13:23:37.099]                 removed <- setdiff(old_names, names)
[13:23:37.099]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:37.099]                   envs[common]]
[13:23:37.099]                 NAMES <- toupper(changed)
[13:23:37.099]                 args <- list()
[13:23:37.099]                 for (kk in seq_along(NAMES)) {
[13:23:37.099]                   name <- changed[[kk]]
[13:23:37.099]                   NAME <- NAMES[[kk]]
[13:23:37.099]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.099]                     next
[13:23:37.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:37.099]                 }
[13:23:37.099]                 NAMES <- toupper(added)
[13:23:37.099]                 for (kk in seq_along(NAMES)) {
[13:23:37.099]                   name <- added[[kk]]
[13:23:37.099]                   NAME <- NAMES[[kk]]
[13:23:37.099]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.099]                     next
[13:23:37.099]                   args[[name]] <- ""
[13:23:37.099]                 }
[13:23:37.099]                 NAMES <- toupper(removed)
[13:23:37.099]                 for (kk in seq_along(NAMES)) {
[13:23:37.099]                   name <- removed[[kk]]
[13:23:37.099]                   NAME <- NAMES[[kk]]
[13:23:37.099]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.099]                     next
[13:23:37.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:37.099]                 }
[13:23:37.099]                 if (length(args) > 0) 
[13:23:37.099]                   base::do.call(base::Sys.setenv, args = args)
[13:23:37.099]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:37.099]             }
[13:23:37.099]             else {
[13:23:37.099]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:37.099]             }
[13:23:37.099]             {
[13:23:37.099]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:37.099]                   0L) {
[13:23:37.099]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:37.099]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:37.099]                   base::options(opts)
[13:23:37.099]                 }
[13:23:37.099]                 {
[13:23:37.099]                   {
[13:23:37.099]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:37.099]                     NULL
[13:23:37.099]                   }
[13:23:37.099]                   options(future.plan = NULL)
[13:23:37.099]                   if (is.na(NA_character_)) 
[13:23:37.099]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:37.099]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:37.099]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:37.099]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:37.099]                     envir = parent.frame()) 
[13:23:37.099]                   {
[13:23:37.099]                     if (is.function(workers)) 
[13:23:37.099]                       workers <- workers()
[13:23:37.099]                     workers <- structure(as.integer(workers), 
[13:23:37.099]                       class = class(workers))
[13:23:37.099]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:37.099]                       workers >= 1)
[13:23:37.099]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:37.099]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:37.099]                     }
[13:23:37.099]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:37.099]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:37.099]                       envir = envir)
[13:23:37.099]                     if (!future$lazy) 
[13:23:37.099]                       future <- run(future)
[13:23:37.099]                     invisible(future)
[13:23:37.099]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:37.099]                 }
[13:23:37.099]             }
[13:23:37.099]         }
[13:23:37.099]     })
[13:23:37.099]     if (TRUE) {
[13:23:37.099]         base::sink(type = "output", split = FALSE)
[13:23:37.099]         if (TRUE) {
[13:23:37.099]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:37.099]         }
[13:23:37.099]         else {
[13:23:37.099]             ...future.result["stdout"] <- base::list(NULL)
[13:23:37.099]         }
[13:23:37.099]         base::close(...future.stdout)
[13:23:37.099]         ...future.stdout <- NULL
[13:23:37.099]     }
[13:23:37.099]     ...future.result$conditions <- ...future.conditions
[13:23:37.099]     ...future.result$finished <- base::Sys.time()
[13:23:37.099]     ...future.result
[13:23:37.099] }
[13:23:37.102] Exporting 1 global objects (1.56 MiB) to cluster node #1 ...
[13:23:37.104] Exporting ‘a’ (1.56 MiB) to cluster node #1 ...
[13:23:37.156] Exporting ‘a’ (1.56 MiB) to cluster node #1 ... DONE
[13:23:37.157] Exporting 1 global objects (1.56 MiB) to cluster node #1 ... DONE
[13:23:37.157] MultisessionFuture started
[13:23:37.157] - Launch lazy future ... done
[13:23:37.157] run() for ‘MultisessionFuture’ ... done
[13:23:37.158] result() for ClusterFuture ...
[13:23:37.158] receiveMessageFromWorker() for ClusterFuture ...
[13:23:37.158] - Validating connection of MultisessionFuture
[13:23:37.206] - received message: FutureResult
[13:23:37.206] - Received FutureResult
[13:23:37.206] - Erased future from FutureRegistry
[13:23:37.206] result() for ClusterFuture ...
[13:23:37.206] - result already collected: FutureResult
[13:23:37.207] result() for ClusterFuture ... done
[13:23:37.207] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:37.207] result() for ClusterFuture ... done
[13:23:37.207] result() for ClusterFuture ...
[13:23:37.207] - result already collected: FutureResult
[13:23:37.207] result() for ClusterFuture ... done
value(b) = 2
[13:23:37.207] result() for ClusterFuture ...
[13:23:37.207] - result already collected: FutureResult
[13:23:37.207] result() for ClusterFuture ... done
[13:23:37.208] result() for ClusterFuture ...
[13:23:37.208] - result already collected: FutureResult
[13:23:37.208] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:37.208] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:37.208] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:37.209] 
[13:23:37.209] Searching for globals ... DONE
[13:23:37.209] - globals: [0] <none>
[13:23:37.209] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:37.209] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:37.210] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:37.210] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:23:37.210] Searching for globals ... DONE
[13:23:37.211] Resolving globals: TRUE
[13:23:37.211] Resolving any globals that are futures ...
[13:23:37.211] - globals: [3] ‘+’, ‘value’, ‘a’
[13:23:37.211] Resolving any globals that are futures ... DONE
[13:23:37.211] Resolving futures part of globals (recursively) ...
[13:23:37.211] resolve() on list ...
[13:23:37.212]  recursive: 99
[13:23:37.212]  length: 1
[13:23:37.212]  elements: ‘a’
[13:23:37.212] run() for ‘Future’ ...
[13:23:37.212] - state: ‘created’
[13:23:37.212] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:37.226] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:37.226] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:37.227]   - Field: ‘node’
[13:23:37.227]   - Field: ‘label’
[13:23:37.227]   - Field: ‘local’
[13:23:37.227]   - Field: ‘owner’
[13:23:37.227]   - Field: ‘envir’
[13:23:37.227]   - Field: ‘workers’
[13:23:37.227]   - Field: ‘packages’
[13:23:37.227]   - Field: ‘gc’
[13:23:37.227]   - Field: ‘conditions’
[13:23:37.227]   - Field: ‘persistent’
[13:23:37.228]   - Field: ‘expr’
[13:23:37.228]   - Field: ‘uuid’
[13:23:37.228]   - Field: ‘seed’
[13:23:37.228]   - Field: ‘version’
[13:23:37.228]   - Field: ‘result’
[13:23:37.228]   - Field: ‘asynchronous’
[13:23:37.228]   - Field: ‘calls’
[13:23:37.228]   - Field: ‘globals’
[13:23:37.228]   - Field: ‘stdout’
[13:23:37.228]   - Field: ‘earlySignal’
[13:23:37.229]   - Field: ‘lazy’
[13:23:37.229]   - Field: ‘state’
[13:23:37.229] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:37.229] - Launch lazy future ...
[13:23:37.229] Packages needed by the future expression (n = 0): <none>
[13:23:37.229] Packages needed by future strategies (n = 0): <none>
[13:23:37.230] {
[13:23:37.230]     {
[13:23:37.230]         {
[13:23:37.230]             ...future.startTime <- base::Sys.time()
[13:23:37.230]             {
[13:23:37.230]                 {
[13:23:37.230]                   {
[13:23:37.230]                     {
[13:23:37.230]                       base::local({
[13:23:37.230]                         has_future <- base::requireNamespace("future", 
[13:23:37.230]                           quietly = TRUE)
[13:23:37.230]                         if (has_future) {
[13:23:37.230]                           ns <- base::getNamespace("future")
[13:23:37.230]                           version <- ns[[".package"]][["version"]]
[13:23:37.230]                           if (is.null(version)) 
[13:23:37.230]                             version <- utils::packageVersion("future")
[13:23:37.230]                         }
[13:23:37.230]                         else {
[13:23:37.230]                           version <- NULL
[13:23:37.230]                         }
[13:23:37.230]                         if (!has_future || version < "1.8.0") {
[13:23:37.230]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:37.230]                             "", base::R.version$version.string), 
[13:23:37.230]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:37.230]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:37.230]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:37.230]                               "release", "version")], collapse = " "), 
[13:23:37.230]                             hostname = base::Sys.info()[["nodename"]])
[13:23:37.230]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:37.230]                             info)
[13:23:37.230]                           info <- base::paste(info, collapse = "; ")
[13:23:37.230]                           if (!has_future) {
[13:23:37.230]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:37.230]                               info)
[13:23:37.230]                           }
[13:23:37.230]                           else {
[13:23:37.230]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:37.230]                               info, version)
[13:23:37.230]                           }
[13:23:37.230]                           base::stop(msg)
[13:23:37.230]                         }
[13:23:37.230]                       })
[13:23:37.230]                     }
[13:23:37.230]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:37.230]                     base::options(mc.cores = 1L)
[13:23:37.230]                   }
[13:23:37.230]                   options(future.plan = NULL)
[13:23:37.230]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:37.230]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:37.230]                 }
[13:23:37.230]                 ...future.workdir <- getwd()
[13:23:37.230]             }
[13:23:37.230]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:37.230]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:37.230]         }
[13:23:37.230]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:37.230]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:37.230]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:37.230]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:37.230]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:37.230]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:37.230]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:37.230]             base::names(...future.oldOptions))
[13:23:37.230]     }
[13:23:37.230]     if (FALSE) {
[13:23:37.230]     }
[13:23:37.230]     else {
[13:23:37.230]         if (TRUE) {
[13:23:37.230]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:37.230]                 open = "w")
[13:23:37.230]         }
[13:23:37.230]         else {
[13:23:37.230]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:37.230]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:37.230]         }
[13:23:37.230]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:37.230]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:37.230]             base::sink(type = "output", split = FALSE)
[13:23:37.230]             base::close(...future.stdout)
[13:23:37.230]         }, add = TRUE)
[13:23:37.230]     }
[13:23:37.230]     ...future.frame <- base::sys.nframe()
[13:23:37.230]     ...future.conditions <- base::list()
[13:23:37.230]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:37.230]     if (FALSE) {
[13:23:37.230]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:37.230]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:37.230]     }
[13:23:37.230]     ...future.result <- base::tryCatch({
[13:23:37.230]         base::withCallingHandlers({
[13:23:37.230]             ...future.value <- base::withVisible(base::local({
[13:23:37.230]                 ...future.makeSendCondition <- base::local({
[13:23:37.230]                   sendCondition <- NULL
[13:23:37.230]                   function(frame = 1L) {
[13:23:37.230]                     if (is.function(sendCondition)) 
[13:23:37.230]                       return(sendCondition)
[13:23:37.230]                     ns <- getNamespace("parallel")
[13:23:37.230]                     if (exists("sendData", mode = "function", 
[13:23:37.230]                       envir = ns)) {
[13:23:37.230]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:37.230]                         envir = ns)
[13:23:37.230]                       envir <- sys.frame(frame)
[13:23:37.230]                       master <- NULL
[13:23:37.230]                       while (!identical(envir, .GlobalEnv) && 
[13:23:37.230]                         !identical(envir, emptyenv())) {
[13:23:37.230]                         if (exists("master", mode = "list", envir = envir, 
[13:23:37.230]                           inherits = FALSE)) {
[13:23:37.230]                           master <- get("master", mode = "list", 
[13:23:37.230]                             envir = envir, inherits = FALSE)
[13:23:37.230]                           if (inherits(master, c("SOCKnode", 
[13:23:37.230]                             "SOCK0node"))) {
[13:23:37.230]                             sendCondition <<- function(cond) {
[13:23:37.230]                               data <- list(type = "VALUE", value = cond, 
[13:23:37.230]                                 success = TRUE)
[13:23:37.230]                               parallel_sendData(master, data)
[13:23:37.230]                             }
[13:23:37.230]                             return(sendCondition)
[13:23:37.230]                           }
[13:23:37.230]                         }
[13:23:37.230]                         frame <- frame + 1L
[13:23:37.230]                         envir <- sys.frame(frame)
[13:23:37.230]                       }
[13:23:37.230]                     }
[13:23:37.230]                     sendCondition <<- function(cond) NULL
[13:23:37.230]                   }
[13:23:37.230]                 })
[13:23:37.230]                 withCallingHandlers({
[13:23:37.230]                   1
[13:23:37.230]                 }, immediateCondition = function(cond) {
[13:23:37.230]                   sendCondition <- ...future.makeSendCondition()
[13:23:37.230]                   sendCondition(cond)
[13:23:37.230]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:37.230]                   {
[13:23:37.230]                     inherits <- base::inherits
[13:23:37.230]                     invokeRestart <- base::invokeRestart
[13:23:37.230]                     is.null <- base::is.null
[13:23:37.230]                     muffled <- FALSE
[13:23:37.230]                     if (inherits(cond, "message")) {
[13:23:37.230]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:37.230]                       if (muffled) 
[13:23:37.230]                         invokeRestart("muffleMessage")
[13:23:37.230]                     }
[13:23:37.230]                     else if (inherits(cond, "warning")) {
[13:23:37.230]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:37.230]                       if (muffled) 
[13:23:37.230]                         invokeRestart("muffleWarning")
[13:23:37.230]                     }
[13:23:37.230]                     else if (inherits(cond, "condition")) {
[13:23:37.230]                       if (!is.null(pattern)) {
[13:23:37.230]                         computeRestarts <- base::computeRestarts
[13:23:37.230]                         grepl <- base::grepl
[13:23:37.230]                         restarts <- computeRestarts(cond)
[13:23:37.230]                         for (restart in restarts) {
[13:23:37.230]                           name <- restart$name
[13:23:37.230]                           if (is.null(name)) 
[13:23:37.230]                             next
[13:23:37.230]                           if (!grepl(pattern, name)) 
[13:23:37.230]                             next
[13:23:37.230]                           invokeRestart(restart)
[13:23:37.230]                           muffled <- TRUE
[13:23:37.230]                           break
[13:23:37.230]                         }
[13:23:37.230]                       }
[13:23:37.230]                     }
[13:23:37.230]                     invisible(muffled)
[13:23:37.230]                   }
[13:23:37.230]                   muffleCondition(cond)
[13:23:37.230]                 })
[13:23:37.230]             }))
[13:23:37.230]             future::FutureResult(value = ...future.value$value, 
[13:23:37.230]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:37.230]                   ...future.rng), globalenv = if (FALSE) 
[13:23:37.230]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:37.230]                     ...future.globalenv.names))
[13:23:37.230]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:37.230]         }, condition = base::local({
[13:23:37.230]             c <- base::c
[13:23:37.230]             inherits <- base::inherits
[13:23:37.230]             invokeRestart <- base::invokeRestart
[13:23:37.230]             length <- base::length
[13:23:37.230]             list <- base::list
[13:23:37.230]             seq.int <- base::seq.int
[13:23:37.230]             signalCondition <- base::signalCondition
[13:23:37.230]             sys.calls <- base::sys.calls
[13:23:37.230]             `[[` <- base::`[[`
[13:23:37.230]             `+` <- base::`+`
[13:23:37.230]             `<<-` <- base::`<<-`
[13:23:37.230]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:37.230]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:37.230]                   3L)]
[13:23:37.230]             }
[13:23:37.230]             function(cond) {
[13:23:37.230]                 is_error <- inherits(cond, "error")
[13:23:37.230]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:37.230]                   NULL)
[13:23:37.230]                 if (is_error) {
[13:23:37.230]                   sessionInformation <- function() {
[13:23:37.230]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:37.230]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:37.230]                       search = base::search(), system = base::Sys.info())
[13:23:37.230]                   }
[13:23:37.230]                   ...future.conditions[[length(...future.conditions) + 
[13:23:37.230]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:37.230]                     cond$call), session = sessionInformation(), 
[13:23:37.230]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:37.230]                   signalCondition(cond)
[13:23:37.230]                 }
[13:23:37.230]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:37.230]                 "immediateCondition"))) {
[13:23:37.230]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:37.230]                   ...future.conditions[[length(...future.conditions) + 
[13:23:37.230]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:37.230]                   if (TRUE && !signal) {
[13:23:37.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:37.230]                     {
[13:23:37.230]                       inherits <- base::inherits
[13:23:37.230]                       invokeRestart <- base::invokeRestart
[13:23:37.230]                       is.null <- base::is.null
[13:23:37.230]                       muffled <- FALSE
[13:23:37.230]                       if (inherits(cond, "message")) {
[13:23:37.230]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:37.230]                         if (muffled) 
[13:23:37.230]                           invokeRestart("muffleMessage")
[13:23:37.230]                       }
[13:23:37.230]                       else if (inherits(cond, "warning")) {
[13:23:37.230]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:37.230]                         if (muffled) 
[13:23:37.230]                           invokeRestart("muffleWarning")
[13:23:37.230]                       }
[13:23:37.230]                       else if (inherits(cond, "condition")) {
[13:23:37.230]                         if (!is.null(pattern)) {
[13:23:37.230]                           computeRestarts <- base::computeRestarts
[13:23:37.230]                           grepl <- base::grepl
[13:23:37.230]                           restarts <- computeRestarts(cond)
[13:23:37.230]                           for (restart in restarts) {
[13:23:37.230]                             name <- restart$name
[13:23:37.230]                             if (is.null(name)) 
[13:23:37.230]                               next
[13:23:37.230]                             if (!grepl(pattern, name)) 
[13:23:37.230]                               next
[13:23:37.230]                             invokeRestart(restart)
[13:23:37.230]                             muffled <- TRUE
[13:23:37.230]                             break
[13:23:37.230]                           }
[13:23:37.230]                         }
[13:23:37.230]                       }
[13:23:37.230]                       invisible(muffled)
[13:23:37.230]                     }
[13:23:37.230]                     muffleCondition(cond, pattern = "^muffle")
[13:23:37.230]                   }
[13:23:37.230]                 }
[13:23:37.230]                 else {
[13:23:37.230]                   if (TRUE) {
[13:23:37.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:37.230]                     {
[13:23:37.230]                       inherits <- base::inherits
[13:23:37.230]                       invokeRestart <- base::invokeRestart
[13:23:37.230]                       is.null <- base::is.null
[13:23:37.230]                       muffled <- FALSE
[13:23:37.230]                       if (inherits(cond, "message")) {
[13:23:37.230]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:37.230]                         if (muffled) 
[13:23:37.230]                           invokeRestart("muffleMessage")
[13:23:37.230]                       }
[13:23:37.230]                       else if (inherits(cond, "warning")) {
[13:23:37.230]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:37.230]                         if (muffled) 
[13:23:37.230]                           invokeRestart("muffleWarning")
[13:23:37.230]                       }
[13:23:37.230]                       else if (inherits(cond, "condition")) {
[13:23:37.230]                         if (!is.null(pattern)) {
[13:23:37.230]                           computeRestarts <- base::computeRestarts
[13:23:37.230]                           grepl <- base::grepl
[13:23:37.230]                           restarts <- computeRestarts(cond)
[13:23:37.230]                           for (restart in restarts) {
[13:23:37.230]                             name <- restart$name
[13:23:37.230]                             if (is.null(name)) 
[13:23:37.230]                               next
[13:23:37.230]                             if (!grepl(pattern, name)) 
[13:23:37.230]                               next
[13:23:37.230]                             invokeRestart(restart)
[13:23:37.230]                             muffled <- TRUE
[13:23:37.230]                             break
[13:23:37.230]                           }
[13:23:37.230]                         }
[13:23:37.230]                       }
[13:23:37.230]                       invisible(muffled)
[13:23:37.230]                     }
[13:23:37.230]                     muffleCondition(cond, pattern = "^muffle")
[13:23:37.230]                   }
[13:23:37.230]                 }
[13:23:37.230]             }
[13:23:37.230]         }))
[13:23:37.230]     }, error = function(ex) {
[13:23:37.230]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:37.230]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:37.230]                 ...future.rng), started = ...future.startTime, 
[13:23:37.230]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:37.230]             version = "1.8"), class = "FutureResult")
[13:23:37.230]     }, finally = {
[13:23:37.230]         if (!identical(...future.workdir, getwd())) 
[13:23:37.230]             setwd(...future.workdir)
[13:23:37.230]         {
[13:23:37.230]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:37.230]                 ...future.oldOptions$nwarnings <- NULL
[13:23:37.230]             }
[13:23:37.230]             base::options(...future.oldOptions)
[13:23:37.230]             if (.Platform$OS.type == "windows") {
[13:23:37.230]                 old_names <- names(...future.oldEnvVars)
[13:23:37.230]                 envs <- base::Sys.getenv()
[13:23:37.230]                 names <- names(envs)
[13:23:37.230]                 common <- intersect(names, old_names)
[13:23:37.230]                 added <- setdiff(names, old_names)
[13:23:37.230]                 removed <- setdiff(old_names, names)
[13:23:37.230]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:37.230]                   envs[common]]
[13:23:37.230]                 NAMES <- toupper(changed)
[13:23:37.230]                 args <- list()
[13:23:37.230]                 for (kk in seq_along(NAMES)) {
[13:23:37.230]                   name <- changed[[kk]]
[13:23:37.230]                   NAME <- NAMES[[kk]]
[13:23:37.230]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.230]                     next
[13:23:37.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:37.230]                 }
[13:23:37.230]                 NAMES <- toupper(added)
[13:23:37.230]                 for (kk in seq_along(NAMES)) {
[13:23:37.230]                   name <- added[[kk]]
[13:23:37.230]                   NAME <- NAMES[[kk]]
[13:23:37.230]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.230]                     next
[13:23:37.230]                   args[[name]] <- ""
[13:23:37.230]                 }
[13:23:37.230]                 NAMES <- toupper(removed)
[13:23:37.230]                 for (kk in seq_along(NAMES)) {
[13:23:37.230]                   name <- removed[[kk]]
[13:23:37.230]                   NAME <- NAMES[[kk]]
[13:23:37.230]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.230]                     next
[13:23:37.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:37.230]                 }
[13:23:37.230]                 if (length(args) > 0) 
[13:23:37.230]                   base::do.call(base::Sys.setenv, args = args)
[13:23:37.230]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:37.230]             }
[13:23:37.230]             else {
[13:23:37.230]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:37.230]             }
[13:23:37.230]             {
[13:23:37.230]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:37.230]                   0L) {
[13:23:37.230]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:37.230]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:37.230]                   base::options(opts)
[13:23:37.230]                 }
[13:23:37.230]                 {
[13:23:37.230]                   {
[13:23:37.230]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:37.230]                     NULL
[13:23:37.230]                   }
[13:23:37.230]                   options(future.plan = NULL)
[13:23:37.230]                   if (is.na(NA_character_)) 
[13:23:37.230]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:37.230]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:37.230]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:37.230]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:37.230]                     envir = parent.frame()) 
[13:23:37.230]                   {
[13:23:37.230]                     if (is.function(workers)) 
[13:23:37.230]                       workers <- workers()
[13:23:37.230]                     workers <- structure(as.integer(workers), 
[13:23:37.230]                       class = class(workers))
[13:23:37.230]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:37.230]                       workers >= 1)
[13:23:37.230]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:37.230]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:37.230]                     }
[13:23:37.230]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:37.230]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:37.230]                       envir = envir)
[13:23:37.230]                     if (!future$lazy) 
[13:23:37.230]                       future <- run(future)
[13:23:37.230]                     invisible(future)
[13:23:37.230]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:37.230]                 }
[13:23:37.230]             }
[13:23:37.230]         }
[13:23:37.230]     })
[13:23:37.230]     if (TRUE) {
[13:23:37.230]         base::sink(type = "output", split = FALSE)
[13:23:37.230]         if (TRUE) {
[13:23:37.230]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:37.230]         }
[13:23:37.230]         else {
[13:23:37.230]             ...future.result["stdout"] <- base::list(NULL)
[13:23:37.230]         }
[13:23:37.230]         base::close(...future.stdout)
[13:23:37.230]         ...future.stdout <- NULL
[13:23:37.230]     }
[13:23:37.230]     ...future.result$conditions <- ...future.conditions
[13:23:37.230]     ...future.result$finished <- base::Sys.time()
[13:23:37.230]     ...future.result
[13:23:37.230] }
[13:23:37.233] MultisessionFuture started
[13:23:37.233] - Launch lazy future ... done
[13:23:37.233] run() for ‘MultisessionFuture’ ... done
[13:23:37.281] receiveMessageFromWorker() for ClusterFuture ...
[13:23:37.282] - Validating connection of MultisessionFuture
[13:23:37.282] - received message: FutureResult
[13:23:37.282] - Received FutureResult
[13:23:37.282] - Erased future from FutureRegistry
[13:23:37.282] result() for ClusterFuture ...
[13:23:37.282] - result already collected: FutureResult
[13:23:37.283] result() for ClusterFuture ... done
[13:23:37.283] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:37.283] Future #1
[13:23:37.283] result() for ClusterFuture ...
[13:23:37.283] - result already collected: FutureResult
[13:23:37.283] result() for ClusterFuture ... done
[13:23:37.283] result() for ClusterFuture ...
[13:23:37.283] - result already collected: FutureResult
[13:23:37.283] result() for ClusterFuture ... done
[13:23:37.283] A MultisessionFuture was resolved
[13:23:37.284]  length: 0 (resolved future 1)
[13:23:37.284] resolve() on list ... DONE
[13:23:37.284] - globals: [1] ‘a’
[13:23:37.284] Resolving futures part of globals (recursively) ... DONE
[13:23:37.286] The total size of the 1 globals is 1.56 MiB (1641008 bytes)
[13:23:37.287] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.56 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.56 MiB of class ‘environment’)
[13:23:37.287] - globals: [1] ‘a’
[13:23:37.287] - packages: [1] ‘future’
[13:23:37.287] getGlobalsAndPackages() ... DONE
[13:23:37.287] run() for ‘Future’ ...
[13:23:37.287] - state: ‘created’
[13:23:37.287] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:37.308] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:37.308] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:37.308]   - Field: ‘node’
[13:23:37.309]   - Field: ‘label’
[13:23:37.309]   - Field: ‘local’
[13:23:37.309]   - Field: ‘owner’
[13:23:37.309]   - Field: ‘envir’
[13:23:37.309]   - Field: ‘workers’
[13:23:37.309]   - Field: ‘packages’
[13:23:37.309]   - Field: ‘gc’
[13:23:37.309]   - Field: ‘conditions’
[13:23:37.309]   - Field: ‘persistent’
[13:23:37.310]   - Field: ‘expr’
[13:23:37.310]   - Field: ‘uuid’
[13:23:37.310]   - Field: ‘seed’
[13:23:37.310]   - Field: ‘version’
[13:23:37.310]   - Field: ‘result’
[13:23:37.310]   - Field: ‘asynchronous’
[13:23:37.310]   - Field: ‘calls’
[13:23:37.310]   - Field: ‘globals’
[13:23:37.310]   - Field: ‘stdout’
[13:23:37.311]   - Field: ‘earlySignal’
[13:23:37.311]   - Field: ‘lazy’
[13:23:37.311]   - Field: ‘state’
[13:23:37.311] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:37.311] - Launch lazy future ...
[13:23:37.311] Packages needed by the future expression (n = 1): ‘future’
[13:23:37.311] Packages needed by future strategies (n = 0): <none>
[13:23:37.312] {
[13:23:37.312]     {
[13:23:37.312]         {
[13:23:37.312]             ...future.startTime <- base::Sys.time()
[13:23:37.312]             {
[13:23:37.312]                 {
[13:23:37.312]                   {
[13:23:37.312]                     {
[13:23:37.312]                       {
[13:23:37.312]                         base::local({
[13:23:37.312]                           has_future <- base::requireNamespace("future", 
[13:23:37.312]                             quietly = TRUE)
[13:23:37.312]                           if (has_future) {
[13:23:37.312]                             ns <- base::getNamespace("future")
[13:23:37.312]                             version <- ns[[".package"]][["version"]]
[13:23:37.312]                             if (is.null(version)) 
[13:23:37.312]                               version <- utils::packageVersion("future")
[13:23:37.312]                           }
[13:23:37.312]                           else {
[13:23:37.312]                             version <- NULL
[13:23:37.312]                           }
[13:23:37.312]                           if (!has_future || version < "1.8.0") {
[13:23:37.312]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:37.312]                               "", base::R.version$version.string), 
[13:23:37.312]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:37.312]                                 base::R.version$platform, 8 * 
[13:23:37.312]                                   base::.Machine$sizeof.pointer), 
[13:23:37.312]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:37.312]                                 "release", "version")], collapse = " "), 
[13:23:37.312]                               hostname = base::Sys.info()[["nodename"]])
[13:23:37.312]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:37.312]                               info)
[13:23:37.312]                             info <- base::paste(info, collapse = "; ")
[13:23:37.312]                             if (!has_future) {
[13:23:37.312]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:37.312]                                 info)
[13:23:37.312]                             }
[13:23:37.312]                             else {
[13:23:37.312]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:37.312]                                 info, version)
[13:23:37.312]                             }
[13:23:37.312]                             base::stop(msg)
[13:23:37.312]                           }
[13:23:37.312]                         })
[13:23:37.312]                       }
[13:23:37.312]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:37.312]                       base::options(mc.cores = 1L)
[13:23:37.312]                     }
[13:23:37.312]                     base::local({
[13:23:37.312]                       for (pkg in "future") {
[13:23:37.312]                         base::loadNamespace(pkg)
[13:23:37.312]                         base::library(pkg, character.only = TRUE)
[13:23:37.312]                       }
[13:23:37.312]                     })
[13:23:37.312]                   }
[13:23:37.312]                   options(future.plan = NULL)
[13:23:37.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:37.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:37.312]                 }
[13:23:37.312]                 ...future.workdir <- getwd()
[13:23:37.312]             }
[13:23:37.312]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:37.312]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:37.312]         }
[13:23:37.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:37.312]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:37.312]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:37.312]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:37.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:37.312]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:37.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:37.312]             base::names(...future.oldOptions))
[13:23:37.312]     }
[13:23:37.312]     if (FALSE) {
[13:23:37.312]     }
[13:23:37.312]     else {
[13:23:37.312]         if (TRUE) {
[13:23:37.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:37.312]                 open = "w")
[13:23:37.312]         }
[13:23:37.312]         else {
[13:23:37.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:37.312]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:37.312]         }
[13:23:37.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:37.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:37.312]             base::sink(type = "output", split = FALSE)
[13:23:37.312]             base::close(...future.stdout)
[13:23:37.312]         }, add = TRUE)
[13:23:37.312]     }
[13:23:37.312]     ...future.frame <- base::sys.nframe()
[13:23:37.312]     ...future.conditions <- base::list()
[13:23:37.312]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:37.312]     if (FALSE) {
[13:23:37.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:37.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:37.312]     }
[13:23:37.312]     ...future.result <- base::tryCatch({
[13:23:37.312]         base::withCallingHandlers({
[13:23:37.312]             ...future.value <- base::withVisible(base::local({
[13:23:37.312]                 ...future.makeSendCondition <- base::local({
[13:23:37.312]                   sendCondition <- NULL
[13:23:37.312]                   function(frame = 1L) {
[13:23:37.312]                     if (is.function(sendCondition)) 
[13:23:37.312]                       return(sendCondition)
[13:23:37.312]                     ns <- getNamespace("parallel")
[13:23:37.312]                     if (exists("sendData", mode = "function", 
[13:23:37.312]                       envir = ns)) {
[13:23:37.312]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:37.312]                         envir = ns)
[13:23:37.312]                       envir <- sys.frame(frame)
[13:23:37.312]                       master <- NULL
[13:23:37.312]                       while (!identical(envir, .GlobalEnv) && 
[13:23:37.312]                         !identical(envir, emptyenv())) {
[13:23:37.312]                         if (exists("master", mode = "list", envir = envir, 
[13:23:37.312]                           inherits = FALSE)) {
[13:23:37.312]                           master <- get("master", mode = "list", 
[13:23:37.312]                             envir = envir, inherits = FALSE)
[13:23:37.312]                           if (inherits(master, c("SOCKnode", 
[13:23:37.312]                             "SOCK0node"))) {
[13:23:37.312]                             sendCondition <<- function(cond) {
[13:23:37.312]                               data <- list(type = "VALUE", value = cond, 
[13:23:37.312]                                 success = TRUE)
[13:23:37.312]                               parallel_sendData(master, data)
[13:23:37.312]                             }
[13:23:37.312]                             return(sendCondition)
[13:23:37.312]                           }
[13:23:37.312]                         }
[13:23:37.312]                         frame <- frame + 1L
[13:23:37.312]                         envir <- sys.frame(frame)
[13:23:37.312]                       }
[13:23:37.312]                     }
[13:23:37.312]                     sendCondition <<- function(cond) NULL
[13:23:37.312]                   }
[13:23:37.312]                 })
[13:23:37.312]                 withCallingHandlers({
[13:23:37.312]                   value(a) + 1
[13:23:37.312]                 }, immediateCondition = function(cond) {
[13:23:37.312]                   sendCondition <- ...future.makeSendCondition()
[13:23:37.312]                   sendCondition(cond)
[13:23:37.312]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:37.312]                   {
[13:23:37.312]                     inherits <- base::inherits
[13:23:37.312]                     invokeRestart <- base::invokeRestart
[13:23:37.312]                     is.null <- base::is.null
[13:23:37.312]                     muffled <- FALSE
[13:23:37.312]                     if (inherits(cond, "message")) {
[13:23:37.312]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:37.312]                       if (muffled) 
[13:23:37.312]                         invokeRestart("muffleMessage")
[13:23:37.312]                     }
[13:23:37.312]                     else if (inherits(cond, "warning")) {
[13:23:37.312]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:37.312]                       if (muffled) 
[13:23:37.312]                         invokeRestart("muffleWarning")
[13:23:37.312]                     }
[13:23:37.312]                     else if (inherits(cond, "condition")) {
[13:23:37.312]                       if (!is.null(pattern)) {
[13:23:37.312]                         computeRestarts <- base::computeRestarts
[13:23:37.312]                         grepl <- base::grepl
[13:23:37.312]                         restarts <- computeRestarts(cond)
[13:23:37.312]                         for (restart in restarts) {
[13:23:37.312]                           name <- restart$name
[13:23:37.312]                           if (is.null(name)) 
[13:23:37.312]                             next
[13:23:37.312]                           if (!grepl(pattern, name)) 
[13:23:37.312]                             next
[13:23:37.312]                           invokeRestart(restart)
[13:23:37.312]                           muffled <- TRUE
[13:23:37.312]                           break
[13:23:37.312]                         }
[13:23:37.312]                       }
[13:23:37.312]                     }
[13:23:37.312]                     invisible(muffled)
[13:23:37.312]                   }
[13:23:37.312]                   muffleCondition(cond)
[13:23:37.312]                 })
[13:23:37.312]             }))
[13:23:37.312]             future::FutureResult(value = ...future.value$value, 
[13:23:37.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:37.312]                   ...future.rng), globalenv = if (FALSE) 
[13:23:37.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:37.312]                     ...future.globalenv.names))
[13:23:37.312]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:37.312]         }, condition = base::local({
[13:23:37.312]             c <- base::c
[13:23:37.312]             inherits <- base::inherits
[13:23:37.312]             invokeRestart <- base::invokeRestart
[13:23:37.312]             length <- base::length
[13:23:37.312]             list <- base::list
[13:23:37.312]             seq.int <- base::seq.int
[13:23:37.312]             signalCondition <- base::signalCondition
[13:23:37.312]             sys.calls <- base::sys.calls
[13:23:37.312]             `[[` <- base::`[[`
[13:23:37.312]             `+` <- base::`+`
[13:23:37.312]             `<<-` <- base::`<<-`
[13:23:37.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:37.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:37.312]                   3L)]
[13:23:37.312]             }
[13:23:37.312]             function(cond) {
[13:23:37.312]                 is_error <- inherits(cond, "error")
[13:23:37.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:37.312]                   NULL)
[13:23:37.312]                 if (is_error) {
[13:23:37.312]                   sessionInformation <- function() {
[13:23:37.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:37.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:37.312]                       search = base::search(), system = base::Sys.info())
[13:23:37.312]                   }
[13:23:37.312]                   ...future.conditions[[length(...future.conditions) + 
[13:23:37.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:37.312]                     cond$call), session = sessionInformation(), 
[13:23:37.312]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:37.312]                   signalCondition(cond)
[13:23:37.312]                 }
[13:23:37.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:37.312]                 "immediateCondition"))) {
[13:23:37.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:37.312]                   ...future.conditions[[length(...future.conditions) + 
[13:23:37.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:37.312]                   if (TRUE && !signal) {
[13:23:37.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:37.312]                     {
[13:23:37.312]                       inherits <- base::inherits
[13:23:37.312]                       invokeRestart <- base::invokeRestart
[13:23:37.312]                       is.null <- base::is.null
[13:23:37.312]                       muffled <- FALSE
[13:23:37.312]                       if (inherits(cond, "message")) {
[13:23:37.312]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:37.312]                         if (muffled) 
[13:23:37.312]                           invokeRestart("muffleMessage")
[13:23:37.312]                       }
[13:23:37.312]                       else if (inherits(cond, "warning")) {
[13:23:37.312]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:37.312]                         if (muffled) 
[13:23:37.312]                           invokeRestart("muffleWarning")
[13:23:37.312]                       }
[13:23:37.312]                       else if (inherits(cond, "condition")) {
[13:23:37.312]                         if (!is.null(pattern)) {
[13:23:37.312]                           computeRestarts <- base::computeRestarts
[13:23:37.312]                           grepl <- base::grepl
[13:23:37.312]                           restarts <- computeRestarts(cond)
[13:23:37.312]                           for (restart in restarts) {
[13:23:37.312]                             name <- restart$name
[13:23:37.312]                             if (is.null(name)) 
[13:23:37.312]                               next
[13:23:37.312]                             if (!grepl(pattern, name)) 
[13:23:37.312]                               next
[13:23:37.312]                             invokeRestart(restart)
[13:23:37.312]                             muffled <- TRUE
[13:23:37.312]                             break
[13:23:37.312]                           }
[13:23:37.312]                         }
[13:23:37.312]                       }
[13:23:37.312]                       invisible(muffled)
[13:23:37.312]                     }
[13:23:37.312]                     muffleCondition(cond, pattern = "^muffle")
[13:23:37.312]                   }
[13:23:37.312]                 }
[13:23:37.312]                 else {
[13:23:37.312]                   if (TRUE) {
[13:23:37.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:37.312]                     {
[13:23:37.312]                       inherits <- base::inherits
[13:23:37.312]                       invokeRestart <- base::invokeRestart
[13:23:37.312]                       is.null <- base::is.null
[13:23:37.312]                       muffled <- FALSE
[13:23:37.312]                       if (inherits(cond, "message")) {
[13:23:37.312]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:37.312]                         if (muffled) 
[13:23:37.312]                           invokeRestart("muffleMessage")
[13:23:37.312]                       }
[13:23:37.312]                       else if (inherits(cond, "warning")) {
[13:23:37.312]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:37.312]                         if (muffled) 
[13:23:37.312]                           invokeRestart("muffleWarning")
[13:23:37.312]                       }
[13:23:37.312]                       else if (inherits(cond, "condition")) {
[13:23:37.312]                         if (!is.null(pattern)) {
[13:23:37.312]                           computeRestarts <- base::computeRestarts
[13:23:37.312]                           grepl <- base::grepl
[13:23:37.312]                           restarts <- computeRestarts(cond)
[13:23:37.312]                           for (restart in restarts) {
[13:23:37.312]                             name <- restart$name
[13:23:37.312]                             if (is.null(name)) 
[13:23:37.312]                               next
[13:23:37.312]                             if (!grepl(pattern, name)) 
[13:23:37.312]                               next
[13:23:37.312]                             invokeRestart(restart)
[13:23:37.312]                             muffled <- TRUE
[13:23:37.312]                             break
[13:23:37.312]                           }
[13:23:37.312]                         }
[13:23:37.312]                       }
[13:23:37.312]                       invisible(muffled)
[13:23:37.312]                     }
[13:23:37.312]                     muffleCondition(cond, pattern = "^muffle")
[13:23:37.312]                   }
[13:23:37.312]                 }
[13:23:37.312]             }
[13:23:37.312]         }))
[13:23:37.312]     }, error = function(ex) {
[13:23:37.312]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:37.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:37.312]                 ...future.rng), started = ...future.startTime, 
[13:23:37.312]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:37.312]             version = "1.8"), class = "FutureResult")
[13:23:37.312]     }, finally = {
[13:23:37.312]         if (!identical(...future.workdir, getwd())) 
[13:23:37.312]             setwd(...future.workdir)
[13:23:37.312]         {
[13:23:37.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:37.312]                 ...future.oldOptions$nwarnings <- NULL
[13:23:37.312]             }
[13:23:37.312]             base::options(...future.oldOptions)
[13:23:37.312]             if (.Platform$OS.type == "windows") {
[13:23:37.312]                 old_names <- names(...future.oldEnvVars)
[13:23:37.312]                 envs <- base::Sys.getenv()
[13:23:37.312]                 names <- names(envs)
[13:23:37.312]                 common <- intersect(names, old_names)
[13:23:37.312]                 added <- setdiff(names, old_names)
[13:23:37.312]                 removed <- setdiff(old_names, names)
[13:23:37.312]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:37.312]                   envs[common]]
[13:23:37.312]                 NAMES <- toupper(changed)
[13:23:37.312]                 args <- list()
[13:23:37.312]                 for (kk in seq_along(NAMES)) {
[13:23:37.312]                   name <- changed[[kk]]
[13:23:37.312]                   NAME <- NAMES[[kk]]
[13:23:37.312]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.312]                     next
[13:23:37.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:37.312]                 }
[13:23:37.312]                 NAMES <- toupper(added)
[13:23:37.312]                 for (kk in seq_along(NAMES)) {
[13:23:37.312]                   name <- added[[kk]]
[13:23:37.312]                   NAME <- NAMES[[kk]]
[13:23:37.312]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.312]                     next
[13:23:37.312]                   args[[name]] <- ""
[13:23:37.312]                 }
[13:23:37.312]                 NAMES <- toupper(removed)
[13:23:37.312]                 for (kk in seq_along(NAMES)) {
[13:23:37.312]                   name <- removed[[kk]]
[13:23:37.312]                   NAME <- NAMES[[kk]]
[13:23:37.312]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.312]                     next
[13:23:37.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:37.312]                 }
[13:23:37.312]                 if (length(args) > 0) 
[13:23:37.312]                   base::do.call(base::Sys.setenv, args = args)
[13:23:37.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:37.312]             }
[13:23:37.312]             else {
[13:23:37.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:37.312]             }
[13:23:37.312]             {
[13:23:37.312]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:37.312]                   0L) {
[13:23:37.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:37.312]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:37.312]                   base::options(opts)
[13:23:37.312]                 }
[13:23:37.312]                 {
[13:23:37.312]                   {
[13:23:37.312]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:37.312]                     NULL
[13:23:37.312]                   }
[13:23:37.312]                   options(future.plan = NULL)
[13:23:37.312]                   if (is.na(NA_character_)) 
[13:23:37.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:37.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:37.312]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:37.312]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:37.312]                     envir = parent.frame()) 
[13:23:37.312]                   {
[13:23:37.312]                     if (is.function(workers)) 
[13:23:37.312]                       workers <- workers()
[13:23:37.312]                     workers <- structure(as.integer(workers), 
[13:23:37.312]                       class = class(workers))
[13:23:37.312]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:37.312]                       workers >= 1)
[13:23:37.312]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:37.312]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:37.312]                     }
[13:23:37.312]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:37.312]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:37.312]                       envir = envir)
[13:23:37.312]                     if (!future$lazy) 
[13:23:37.312]                       future <- run(future)
[13:23:37.312]                     invisible(future)
[13:23:37.312]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:37.312]                 }
[13:23:37.312]             }
[13:23:37.312]         }
[13:23:37.312]     })
[13:23:37.312]     if (TRUE) {
[13:23:37.312]         base::sink(type = "output", split = FALSE)
[13:23:37.312]         if (TRUE) {
[13:23:37.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:37.312]         }
[13:23:37.312]         else {
[13:23:37.312]             ...future.result["stdout"] <- base::list(NULL)
[13:23:37.312]         }
[13:23:37.312]         base::close(...future.stdout)
[13:23:37.312]         ...future.stdout <- NULL
[13:23:37.312]     }
[13:23:37.312]     ...future.result$conditions <- ...future.conditions
[13:23:37.312]     ...future.result$finished <- base::Sys.time()
[13:23:37.312]     ...future.result
[13:23:37.312] }
[13:23:37.315] Exporting 1 global objects (1.56 MiB) to cluster node #1 ...
[13:23:37.317] Exporting ‘a’ (1.56 MiB) to cluster node #1 ...
[13:23:37.368] Exporting ‘a’ (1.56 MiB) to cluster node #1 ... DONE
[13:23:37.369] Exporting 1 global objects (1.56 MiB) to cluster node #1 ... DONE
[13:23:37.369] MultisessionFuture started
[13:23:37.369] - Launch lazy future ... done
[13:23:37.370] run() for ‘MultisessionFuture’ ... done
[13:23:37.370] result() for ClusterFuture ...
[13:23:37.370] receiveMessageFromWorker() for ClusterFuture ...
[13:23:37.370] - Validating connection of MultisessionFuture
[13:23:37.418] - received message: FutureResult
[13:23:37.418] - Received FutureResult
[13:23:37.418] - Erased future from FutureRegistry
[13:23:37.418] result() for ClusterFuture ...
[13:23:37.419] - result already collected: FutureResult
[13:23:37.419] result() for ClusterFuture ... done
[13:23:37.419] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:37.419] result() for ClusterFuture ... done
[13:23:37.419] result() for ClusterFuture ...
[13:23:37.419] - result already collected: FutureResult
[13:23:37.419] result() for ClusterFuture ... done
value(b) = 2
[13:23:37.419] result() for ClusterFuture ...
[13:23:37.419] - result already collected: FutureResult
[13:23:37.420] result() for ClusterFuture ... done
[13:23:37.420] result() for ClusterFuture ...
[13:23:37.420] - result already collected: FutureResult
[13:23:37.420] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:37.420] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:37.420] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:37.421] - globals found: [2] ‘{’, ‘pkg’
[13:23:37.421] Searching for globals ... DONE
[13:23:37.421] Resolving globals: TRUE
[13:23:37.421] Resolving any globals that are futures ...
[13:23:37.422] - globals: [2] ‘{’, ‘pkg’
[13:23:37.422] Resolving any globals that are futures ... DONE
[13:23:37.422] Resolving futures part of globals (recursively) ...
[13:23:37.422] resolve() on list ...
[13:23:37.422]  recursive: 99
[13:23:37.422]  length: 1
[13:23:37.422]  elements: ‘pkg’
[13:23:37.423]  length: 0 (resolved future 1)
[13:23:37.423] resolve() on list ... DONE
[13:23:37.423] - globals: [1] ‘pkg’
[13:23:37.423] Resolving futures part of globals (recursively) ... DONE
[13:23:37.423] The total size of the 1 globals is 112 bytes (112 bytes)
[13:23:37.423] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[13:23:37.424] - globals: [1] ‘pkg’
[13:23:37.424] 
[13:23:37.424] getGlobalsAndPackages() ... DONE
[13:23:37.424] Packages needed by the future expression (n = 0): <none>
[13:23:37.424] Packages needed by future strategies (n = 0): <none>
[13:23:37.425] {
[13:23:37.425]     {
[13:23:37.425]         {
[13:23:37.425]             ...future.startTime <- base::Sys.time()
[13:23:37.425]             {
[13:23:37.425]                 {
[13:23:37.425]                   {
[13:23:37.425]                     base::local({
[13:23:37.425]                       has_future <- base::requireNamespace("future", 
[13:23:37.425]                         quietly = TRUE)
[13:23:37.425]                       if (has_future) {
[13:23:37.425]                         ns <- base::getNamespace("future")
[13:23:37.425]                         version <- ns[[".package"]][["version"]]
[13:23:37.425]                         if (is.null(version)) 
[13:23:37.425]                           version <- utils::packageVersion("future")
[13:23:37.425]                       }
[13:23:37.425]                       else {
[13:23:37.425]                         version <- NULL
[13:23:37.425]                       }
[13:23:37.425]                       if (!has_future || version < "1.8.0") {
[13:23:37.425]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:37.425]                           "", base::R.version$version.string), 
[13:23:37.425]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:37.425]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:37.425]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:37.425]                             "release", "version")], collapse = " "), 
[13:23:37.425]                           hostname = base::Sys.info()[["nodename"]])
[13:23:37.425]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:37.425]                           info)
[13:23:37.425]                         info <- base::paste(info, collapse = "; ")
[13:23:37.425]                         if (!has_future) {
[13:23:37.425]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:37.425]                             info)
[13:23:37.425]                         }
[13:23:37.425]                         else {
[13:23:37.425]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:37.425]                             info, version)
[13:23:37.425]                         }
[13:23:37.425]                         base::stop(msg)
[13:23:37.425]                       }
[13:23:37.425]                     })
[13:23:37.425]                   }
[13:23:37.425]                   options(future.plan = NULL)
[13:23:37.425]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:37.425]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:37.425]                 }
[13:23:37.425]                 ...future.workdir <- getwd()
[13:23:37.425]             }
[13:23:37.425]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:37.425]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:37.425]         }
[13:23:37.425]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:37.425]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:37.425]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:37.425]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:37.425]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:37.425]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:37.425]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:37.425]             base::names(...future.oldOptions))
[13:23:37.425]     }
[13:23:37.425]     if (FALSE) {
[13:23:37.425]     }
[13:23:37.425]     else {
[13:23:37.425]         if (TRUE) {
[13:23:37.425]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:37.425]                 open = "w")
[13:23:37.425]         }
[13:23:37.425]         else {
[13:23:37.425]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:37.425]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:37.425]         }
[13:23:37.425]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:37.425]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:37.425]             base::sink(type = "output", split = FALSE)
[13:23:37.425]             base::close(...future.stdout)
[13:23:37.425]         }, add = TRUE)
[13:23:37.425]     }
[13:23:37.425]     ...future.frame <- base::sys.nframe()
[13:23:37.425]     ...future.conditions <- base::list()
[13:23:37.425]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:37.425]     if (FALSE) {
[13:23:37.425]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:37.425]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:37.425]     }
[13:23:37.425]     ...future.result <- base::tryCatch({
[13:23:37.425]         base::withCallingHandlers({
[13:23:37.425]             ...future.value <- base::withVisible(base::local({
[13:23:37.425]                 pkg
[13:23:37.425]             }))
[13:23:37.425]             future::FutureResult(value = ...future.value$value, 
[13:23:37.425]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:37.425]                   ...future.rng), globalenv = if (FALSE) 
[13:23:37.425]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:37.425]                     ...future.globalenv.names))
[13:23:37.425]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:37.425]         }, condition = base::local({
[13:23:37.425]             c <- base::c
[13:23:37.425]             inherits <- base::inherits
[13:23:37.425]             invokeRestart <- base::invokeRestart
[13:23:37.425]             length <- base::length
[13:23:37.425]             list <- base::list
[13:23:37.425]             seq.int <- base::seq.int
[13:23:37.425]             signalCondition <- base::signalCondition
[13:23:37.425]             sys.calls <- base::sys.calls
[13:23:37.425]             `[[` <- base::`[[`
[13:23:37.425]             `+` <- base::`+`
[13:23:37.425]             `<<-` <- base::`<<-`
[13:23:37.425]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:37.425]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:37.425]                   3L)]
[13:23:37.425]             }
[13:23:37.425]             function(cond) {
[13:23:37.425]                 is_error <- inherits(cond, "error")
[13:23:37.425]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:37.425]                   NULL)
[13:23:37.425]                 if (is_error) {
[13:23:37.425]                   sessionInformation <- function() {
[13:23:37.425]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:37.425]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:37.425]                       search = base::search(), system = base::Sys.info())
[13:23:37.425]                   }
[13:23:37.425]                   ...future.conditions[[length(...future.conditions) + 
[13:23:37.425]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:37.425]                     cond$call), session = sessionInformation(), 
[13:23:37.425]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:37.425]                   signalCondition(cond)
[13:23:37.425]                 }
[13:23:37.425]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:37.425]                 "immediateCondition"))) {
[13:23:37.425]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:37.425]                   ...future.conditions[[length(...future.conditions) + 
[13:23:37.425]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:37.425]                   if (TRUE && !signal) {
[13:23:37.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:37.425]                     {
[13:23:37.425]                       inherits <- base::inherits
[13:23:37.425]                       invokeRestart <- base::invokeRestart
[13:23:37.425]                       is.null <- base::is.null
[13:23:37.425]                       muffled <- FALSE
[13:23:37.425]                       if (inherits(cond, "message")) {
[13:23:37.425]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:37.425]                         if (muffled) 
[13:23:37.425]                           invokeRestart("muffleMessage")
[13:23:37.425]                       }
[13:23:37.425]                       else if (inherits(cond, "warning")) {
[13:23:37.425]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:37.425]                         if (muffled) 
[13:23:37.425]                           invokeRestart("muffleWarning")
[13:23:37.425]                       }
[13:23:37.425]                       else if (inherits(cond, "condition")) {
[13:23:37.425]                         if (!is.null(pattern)) {
[13:23:37.425]                           computeRestarts <- base::computeRestarts
[13:23:37.425]                           grepl <- base::grepl
[13:23:37.425]                           restarts <- computeRestarts(cond)
[13:23:37.425]                           for (restart in restarts) {
[13:23:37.425]                             name <- restart$name
[13:23:37.425]                             if (is.null(name)) 
[13:23:37.425]                               next
[13:23:37.425]                             if (!grepl(pattern, name)) 
[13:23:37.425]                               next
[13:23:37.425]                             invokeRestart(restart)
[13:23:37.425]                             muffled <- TRUE
[13:23:37.425]                             break
[13:23:37.425]                           }
[13:23:37.425]                         }
[13:23:37.425]                       }
[13:23:37.425]                       invisible(muffled)
[13:23:37.425]                     }
[13:23:37.425]                     muffleCondition(cond, pattern = "^muffle")
[13:23:37.425]                   }
[13:23:37.425]                 }
[13:23:37.425]                 else {
[13:23:37.425]                   if (TRUE) {
[13:23:37.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:37.425]                     {
[13:23:37.425]                       inherits <- base::inherits
[13:23:37.425]                       invokeRestart <- base::invokeRestart
[13:23:37.425]                       is.null <- base::is.null
[13:23:37.425]                       muffled <- FALSE
[13:23:37.425]                       if (inherits(cond, "message")) {
[13:23:37.425]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:37.425]                         if (muffled) 
[13:23:37.425]                           invokeRestart("muffleMessage")
[13:23:37.425]                       }
[13:23:37.425]                       else if (inherits(cond, "warning")) {
[13:23:37.425]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:37.425]                         if (muffled) 
[13:23:37.425]                           invokeRestart("muffleWarning")
[13:23:37.425]                       }
[13:23:37.425]                       else if (inherits(cond, "condition")) {
[13:23:37.425]                         if (!is.null(pattern)) {
[13:23:37.425]                           computeRestarts <- base::computeRestarts
[13:23:37.425]                           grepl <- base::grepl
[13:23:37.425]                           restarts <- computeRestarts(cond)
[13:23:37.425]                           for (restart in restarts) {
[13:23:37.425]                             name <- restart$name
[13:23:37.425]                             if (is.null(name)) 
[13:23:37.425]                               next
[13:23:37.425]                             if (!grepl(pattern, name)) 
[13:23:37.425]                               next
[13:23:37.425]                             invokeRestart(restart)
[13:23:37.425]                             muffled <- TRUE
[13:23:37.425]                             break
[13:23:37.425]                           }
[13:23:37.425]                         }
[13:23:37.425]                       }
[13:23:37.425]                       invisible(muffled)
[13:23:37.425]                     }
[13:23:37.425]                     muffleCondition(cond, pattern = "^muffle")
[13:23:37.425]                   }
[13:23:37.425]                 }
[13:23:37.425]             }
[13:23:37.425]         }))
[13:23:37.425]     }, error = function(ex) {
[13:23:37.425]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:37.425]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:37.425]                 ...future.rng), started = ...future.startTime, 
[13:23:37.425]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:37.425]             version = "1.8"), class = "FutureResult")
[13:23:37.425]     }, finally = {
[13:23:37.425]         if (!identical(...future.workdir, getwd())) 
[13:23:37.425]             setwd(...future.workdir)
[13:23:37.425]         {
[13:23:37.425]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:37.425]                 ...future.oldOptions$nwarnings <- NULL
[13:23:37.425]             }
[13:23:37.425]             base::options(...future.oldOptions)
[13:23:37.425]             if (.Platform$OS.type == "windows") {
[13:23:37.425]                 old_names <- names(...future.oldEnvVars)
[13:23:37.425]                 envs <- base::Sys.getenv()
[13:23:37.425]                 names <- names(envs)
[13:23:37.425]                 common <- intersect(names, old_names)
[13:23:37.425]                 added <- setdiff(names, old_names)
[13:23:37.425]                 removed <- setdiff(old_names, names)
[13:23:37.425]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:37.425]                   envs[common]]
[13:23:37.425]                 NAMES <- toupper(changed)
[13:23:37.425]                 args <- list()
[13:23:37.425]                 for (kk in seq_along(NAMES)) {
[13:23:37.425]                   name <- changed[[kk]]
[13:23:37.425]                   NAME <- NAMES[[kk]]
[13:23:37.425]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.425]                     next
[13:23:37.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:37.425]                 }
[13:23:37.425]                 NAMES <- toupper(added)
[13:23:37.425]                 for (kk in seq_along(NAMES)) {
[13:23:37.425]                   name <- added[[kk]]
[13:23:37.425]                   NAME <- NAMES[[kk]]
[13:23:37.425]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.425]                     next
[13:23:37.425]                   args[[name]] <- ""
[13:23:37.425]                 }
[13:23:37.425]                 NAMES <- toupper(removed)
[13:23:37.425]                 for (kk in seq_along(NAMES)) {
[13:23:37.425]                   name <- removed[[kk]]
[13:23:37.425]                   NAME <- NAMES[[kk]]
[13:23:37.425]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.425]                     next
[13:23:37.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:37.425]                 }
[13:23:37.425]                 if (length(args) > 0) 
[13:23:37.425]                   base::do.call(base::Sys.setenv, args = args)
[13:23:37.425]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:37.425]             }
[13:23:37.425]             else {
[13:23:37.425]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:37.425]             }
[13:23:37.425]             {
[13:23:37.425]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:37.425]                   0L) {
[13:23:37.425]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:37.425]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:37.425]                   base::options(opts)
[13:23:37.425]                 }
[13:23:37.425]                 {
[13:23:37.425]                   {
[13:23:37.425]                     NULL
[13:23:37.425]                     RNGkind("Mersenne-Twister")
[13:23:37.425]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:37.425]                       inherits = FALSE)
[13:23:37.425]                   }
[13:23:37.425]                   options(future.plan = NULL)
[13:23:37.425]                   if (is.na(NA_character_)) 
[13:23:37.425]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:37.425]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:37.425]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:37.425]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:37.425]                     envir = parent.frame()) 
[13:23:37.425]                   {
[13:23:37.425]                     if (is.function(workers)) 
[13:23:37.425]                       workers <- workers()
[13:23:37.425]                     workers <- structure(as.integer(workers), 
[13:23:37.425]                       class = class(workers))
[13:23:37.425]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:37.425]                       workers >= 1)
[13:23:37.425]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:37.425]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:37.425]                     }
[13:23:37.425]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:37.425]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:37.425]                       envir = envir)
[13:23:37.425]                     if (!future$lazy) 
[13:23:37.425]                       future <- run(future)
[13:23:37.425]                     invisible(future)
[13:23:37.425]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:37.425]                 }
[13:23:37.425]             }
[13:23:37.425]         }
[13:23:37.425]     })
[13:23:37.425]     if (TRUE) {
[13:23:37.425]         base::sink(type = "output", split = FALSE)
[13:23:37.425]         if (TRUE) {
[13:23:37.425]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:37.425]         }
[13:23:37.425]         else {
[13:23:37.425]             ...future.result["stdout"] <- base::list(NULL)
[13:23:37.425]         }
[13:23:37.425]         base::close(...future.stdout)
[13:23:37.425]         ...future.stdout <- NULL
[13:23:37.425]     }
[13:23:37.425]     ...future.result$conditions <- ...future.conditions
[13:23:37.425]     ...future.result$finished <- base::Sys.time()
[13:23:37.425]     ...future.result
[13:23:37.425] }
[13:23:37.426] assign_globals() ...
[13:23:37.427] List of 1
[13:23:37.427]  $ pkg: chr "foo"
[13:23:37.427]  - attr(*, "where")=List of 1
[13:23:37.427]   ..$ pkg:<environment: R_EmptyEnv> 
[13:23:37.427]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:37.427]  - attr(*, "resolved")= logi TRUE
[13:23:37.427]  - attr(*, "total_size")= num 112
[13:23:37.429] - copied ‘pkg’ to environment
[13:23:37.429] assign_globals() ... done
[13:23:37.429] plan(): Setting new future strategy stack:
[13:23:37.429] List of future strategies:
[13:23:37.429] 1. sequential:
[13:23:37.429]    - args: function (..., envir = parent.frame())
[13:23:37.429]    - tweaked: FALSE
[13:23:37.429]    - call: NULL
[13:23:37.430] plan(): nbrOfWorkers() = 1
[13:23:37.431] plan(): Setting new future strategy stack:
[13:23:37.431] List of future strategies:
[13:23:37.431] 1. multisession:
[13:23:37.431]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:23:37.431]    - tweaked: FALSE
[13:23:37.431]    - call: plan(strategy)
[13:23:37.435] plan(): nbrOfWorkers() = 2
[13:23:37.435] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:37.436] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:37.436] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:37.438] - globals found: [3] ‘{’, ‘<-’, ‘+’
[13:23:37.438] Searching for globals ... DONE
[13:23:37.438] Resolving globals: TRUE
[13:23:37.438] Resolving any globals that are futures ...
[13:23:37.438] - globals: [3] ‘{’, ‘<-’, ‘+’
[13:23:37.438] Resolving any globals that are futures ... DONE
[13:23:37.439] 
[13:23:37.439] 
[13:23:37.439] getGlobalsAndPackages() ... DONE
[13:23:37.439] run() for ‘Future’ ...
[13:23:37.439] - state: ‘created’
[13:23:37.440] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:37.455] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:37.456] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:37.456]   - Field: ‘node’
[13:23:37.456]   - Field: ‘label’
[13:23:37.456]   - Field: ‘local’
[13:23:37.456]   - Field: ‘owner’
[13:23:37.456]   - Field: ‘envir’
[13:23:37.456]   - Field: ‘workers’
[13:23:37.456]   - Field: ‘packages’
[13:23:37.456]   - Field: ‘gc’
[13:23:37.457]   - Field: ‘conditions’
[13:23:37.457]   - Field: ‘persistent’
[13:23:37.457]   - Field: ‘expr’
[13:23:37.457]   - Field: ‘uuid’
[13:23:37.457]   - Field: ‘seed’
[13:23:37.457]   - Field: ‘version’
[13:23:37.457]   - Field: ‘result’
[13:23:37.457]   - Field: ‘asynchronous’
[13:23:37.457]   - Field: ‘calls’
[13:23:37.457]   - Field: ‘globals’
[13:23:37.458]   - Field: ‘stdout’
[13:23:37.458]   - Field: ‘earlySignal’
[13:23:37.458]   - Field: ‘lazy’
[13:23:37.458]   - Field: ‘state’
[13:23:37.458] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:37.458] - Launch lazy future ...
[13:23:37.458] Packages needed by the future expression (n = 0): <none>
[13:23:37.458] Packages needed by future strategies (n = 0): <none>
[13:23:37.459] {
[13:23:37.459]     {
[13:23:37.459]         {
[13:23:37.459]             ...future.startTime <- base::Sys.time()
[13:23:37.459]             {
[13:23:37.459]                 {
[13:23:37.459]                   {
[13:23:37.459]                     {
[13:23:37.459]                       base::local({
[13:23:37.459]                         has_future <- base::requireNamespace("future", 
[13:23:37.459]                           quietly = TRUE)
[13:23:37.459]                         if (has_future) {
[13:23:37.459]                           ns <- base::getNamespace("future")
[13:23:37.459]                           version <- ns[[".package"]][["version"]]
[13:23:37.459]                           if (is.null(version)) 
[13:23:37.459]                             version <- utils::packageVersion("future")
[13:23:37.459]                         }
[13:23:37.459]                         else {
[13:23:37.459]                           version <- NULL
[13:23:37.459]                         }
[13:23:37.459]                         if (!has_future || version < "1.8.0") {
[13:23:37.459]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:37.459]                             "", base::R.version$version.string), 
[13:23:37.459]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:37.459]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:37.459]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:37.459]                               "release", "version")], collapse = " "), 
[13:23:37.459]                             hostname = base::Sys.info()[["nodename"]])
[13:23:37.459]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:37.459]                             info)
[13:23:37.459]                           info <- base::paste(info, collapse = "; ")
[13:23:37.459]                           if (!has_future) {
[13:23:37.459]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:37.459]                               info)
[13:23:37.459]                           }
[13:23:37.459]                           else {
[13:23:37.459]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:37.459]                               info, version)
[13:23:37.459]                           }
[13:23:37.459]                           base::stop(msg)
[13:23:37.459]                         }
[13:23:37.459]                       })
[13:23:37.459]                     }
[13:23:37.459]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:37.459]                     base::options(mc.cores = 1L)
[13:23:37.459]                   }
[13:23:37.459]                   options(future.plan = NULL)
[13:23:37.459]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:37.459]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:37.459]                 }
[13:23:37.459]                 ...future.workdir <- getwd()
[13:23:37.459]             }
[13:23:37.459]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:37.459]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:37.459]         }
[13:23:37.459]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:37.459]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:37.459]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:37.459]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:37.459]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:37.459]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:37.459]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:37.459]             base::names(...future.oldOptions))
[13:23:37.459]     }
[13:23:37.459]     if (FALSE) {
[13:23:37.459]     }
[13:23:37.459]     else {
[13:23:37.459]         if (TRUE) {
[13:23:37.459]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:37.459]                 open = "w")
[13:23:37.459]         }
[13:23:37.459]         else {
[13:23:37.459]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:37.459]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:37.459]         }
[13:23:37.459]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:37.459]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:37.459]             base::sink(type = "output", split = FALSE)
[13:23:37.459]             base::close(...future.stdout)
[13:23:37.459]         }, add = TRUE)
[13:23:37.459]     }
[13:23:37.459]     ...future.frame <- base::sys.nframe()
[13:23:37.459]     ...future.conditions <- base::list()
[13:23:37.459]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:37.459]     if (FALSE) {
[13:23:37.459]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:37.459]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:37.459]     }
[13:23:37.459]     ...future.result <- base::tryCatch({
[13:23:37.459]         base::withCallingHandlers({
[13:23:37.459]             ...future.value <- base::withVisible(base::local({
[13:23:37.459]                 ...future.makeSendCondition <- base::local({
[13:23:37.459]                   sendCondition <- NULL
[13:23:37.459]                   function(frame = 1L) {
[13:23:37.459]                     if (is.function(sendCondition)) 
[13:23:37.459]                       return(sendCondition)
[13:23:37.459]                     ns <- getNamespace("parallel")
[13:23:37.459]                     if (exists("sendData", mode = "function", 
[13:23:37.459]                       envir = ns)) {
[13:23:37.459]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:37.459]                         envir = ns)
[13:23:37.459]                       envir <- sys.frame(frame)
[13:23:37.459]                       master <- NULL
[13:23:37.459]                       while (!identical(envir, .GlobalEnv) && 
[13:23:37.459]                         !identical(envir, emptyenv())) {
[13:23:37.459]                         if (exists("master", mode = "list", envir = envir, 
[13:23:37.459]                           inherits = FALSE)) {
[13:23:37.459]                           master <- get("master", mode = "list", 
[13:23:37.459]                             envir = envir, inherits = FALSE)
[13:23:37.459]                           if (inherits(master, c("SOCKnode", 
[13:23:37.459]                             "SOCK0node"))) {
[13:23:37.459]                             sendCondition <<- function(cond) {
[13:23:37.459]                               data <- list(type = "VALUE", value = cond, 
[13:23:37.459]                                 success = TRUE)
[13:23:37.459]                               parallel_sendData(master, data)
[13:23:37.459]                             }
[13:23:37.459]                             return(sendCondition)
[13:23:37.459]                           }
[13:23:37.459]                         }
[13:23:37.459]                         frame <- frame + 1L
[13:23:37.459]                         envir <- sys.frame(frame)
[13:23:37.459]                       }
[13:23:37.459]                     }
[13:23:37.459]                     sendCondition <<- function(cond) NULL
[13:23:37.459]                   }
[13:23:37.459]                 })
[13:23:37.459]                 withCallingHandlers({
[13:23:37.459]                   {
[13:23:37.459]                     x <- 0
[13:23:37.459]                     x <- x + 1
[13:23:37.459]                     x
[13:23:37.459]                   }
[13:23:37.459]                 }, immediateCondition = function(cond) {
[13:23:37.459]                   sendCondition <- ...future.makeSendCondition()
[13:23:37.459]                   sendCondition(cond)
[13:23:37.459]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:37.459]                   {
[13:23:37.459]                     inherits <- base::inherits
[13:23:37.459]                     invokeRestart <- base::invokeRestart
[13:23:37.459]                     is.null <- base::is.null
[13:23:37.459]                     muffled <- FALSE
[13:23:37.459]                     if (inherits(cond, "message")) {
[13:23:37.459]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:37.459]                       if (muffled) 
[13:23:37.459]                         invokeRestart("muffleMessage")
[13:23:37.459]                     }
[13:23:37.459]                     else if (inherits(cond, "warning")) {
[13:23:37.459]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:37.459]                       if (muffled) 
[13:23:37.459]                         invokeRestart("muffleWarning")
[13:23:37.459]                     }
[13:23:37.459]                     else if (inherits(cond, "condition")) {
[13:23:37.459]                       if (!is.null(pattern)) {
[13:23:37.459]                         computeRestarts <- base::computeRestarts
[13:23:37.459]                         grepl <- base::grepl
[13:23:37.459]                         restarts <- computeRestarts(cond)
[13:23:37.459]                         for (restart in restarts) {
[13:23:37.459]                           name <- restart$name
[13:23:37.459]                           if (is.null(name)) 
[13:23:37.459]                             next
[13:23:37.459]                           if (!grepl(pattern, name)) 
[13:23:37.459]                             next
[13:23:37.459]                           invokeRestart(restart)
[13:23:37.459]                           muffled <- TRUE
[13:23:37.459]                           break
[13:23:37.459]                         }
[13:23:37.459]                       }
[13:23:37.459]                     }
[13:23:37.459]                     invisible(muffled)
[13:23:37.459]                   }
[13:23:37.459]                   muffleCondition(cond)
[13:23:37.459]                 })
[13:23:37.459]             }))
[13:23:37.459]             future::FutureResult(value = ...future.value$value, 
[13:23:37.459]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:37.459]                   ...future.rng), globalenv = if (FALSE) 
[13:23:37.459]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:37.459]                     ...future.globalenv.names))
[13:23:37.459]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:37.459]         }, condition = base::local({
[13:23:37.459]             c <- base::c
[13:23:37.459]             inherits <- base::inherits
[13:23:37.459]             invokeRestart <- base::invokeRestart
[13:23:37.459]             length <- base::length
[13:23:37.459]             list <- base::list
[13:23:37.459]             seq.int <- base::seq.int
[13:23:37.459]             signalCondition <- base::signalCondition
[13:23:37.459]             sys.calls <- base::sys.calls
[13:23:37.459]             `[[` <- base::`[[`
[13:23:37.459]             `+` <- base::`+`
[13:23:37.459]             `<<-` <- base::`<<-`
[13:23:37.459]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:37.459]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:37.459]                   3L)]
[13:23:37.459]             }
[13:23:37.459]             function(cond) {
[13:23:37.459]                 is_error <- inherits(cond, "error")
[13:23:37.459]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:37.459]                   NULL)
[13:23:37.459]                 if (is_error) {
[13:23:37.459]                   sessionInformation <- function() {
[13:23:37.459]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:37.459]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:37.459]                       search = base::search(), system = base::Sys.info())
[13:23:37.459]                   }
[13:23:37.459]                   ...future.conditions[[length(...future.conditions) + 
[13:23:37.459]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:37.459]                     cond$call), session = sessionInformation(), 
[13:23:37.459]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:37.459]                   signalCondition(cond)
[13:23:37.459]                 }
[13:23:37.459]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:37.459]                 "immediateCondition"))) {
[13:23:37.459]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:37.459]                   ...future.conditions[[length(...future.conditions) + 
[13:23:37.459]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:37.459]                   if (TRUE && !signal) {
[13:23:37.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:37.459]                     {
[13:23:37.459]                       inherits <- base::inherits
[13:23:37.459]                       invokeRestart <- base::invokeRestart
[13:23:37.459]                       is.null <- base::is.null
[13:23:37.459]                       muffled <- FALSE
[13:23:37.459]                       if (inherits(cond, "message")) {
[13:23:37.459]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:37.459]                         if (muffled) 
[13:23:37.459]                           invokeRestart("muffleMessage")
[13:23:37.459]                       }
[13:23:37.459]                       else if (inherits(cond, "warning")) {
[13:23:37.459]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:37.459]                         if (muffled) 
[13:23:37.459]                           invokeRestart("muffleWarning")
[13:23:37.459]                       }
[13:23:37.459]                       else if (inherits(cond, "condition")) {
[13:23:37.459]                         if (!is.null(pattern)) {
[13:23:37.459]                           computeRestarts <- base::computeRestarts
[13:23:37.459]                           grepl <- base::grepl
[13:23:37.459]                           restarts <- computeRestarts(cond)
[13:23:37.459]                           for (restart in restarts) {
[13:23:37.459]                             name <- restart$name
[13:23:37.459]                             if (is.null(name)) 
[13:23:37.459]                               next
[13:23:37.459]                             if (!grepl(pattern, name)) 
[13:23:37.459]                               next
[13:23:37.459]                             invokeRestart(restart)
[13:23:37.459]                             muffled <- TRUE
[13:23:37.459]                             break
[13:23:37.459]                           }
[13:23:37.459]                         }
[13:23:37.459]                       }
[13:23:37.459]                       invisible(muffled)
[13:23:37.459]                     }
[13:23:37.459]                     muffleCondition(cond, pattern = "^muffle")
[13:23:37.459]                   }
[13:23:37.459]                 }
[13:23:37.459]                 else {
[13:23:37.459]                   if (TRUE) {
[13:23:37.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:37.459]                     {
[13:23:37.459]                       inherits <- base::inherits
[13:23:37.459]                       invokeRestart <- base::invokeRestart
[13:23:37.459]                       is.null <- base::is.null
[13:23:37.459]                       muffled <- FALSE
[13:23:37.459]                       if (inherits(cond, "message")) {
[13:23:37.459]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:37.459]                         if (muffled) 
[13:23:37.459]                           invokeRestart("muffleMessage")
[13:23:37.459]                       }
[13:23:37.459]                       else if (inherits(cond, "warning")) {
[13:23:37.459]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:37.459]                         if (muffled) 
[13:23:37.459]                           invokeRestart("muffleWarning")
[13:23:37.459]                       }
[13:23:37.459]                       else if (inherits(cond, "condition")) {
[13:23:37.459]                         if (!is.null(pattern)) {
[13:23:37.459]                           computeRestarts <- base::computeRestarts
[13:23:37.459]                           grepl <- base::grepl
[13:23:37.459]                           restarts <- computeRestarts(cond)
[13:23:37.459]                           for (restart in restarts) {
[13:23:37.459]                             name <- restart$name
[13:23:37.459]                             if (is.null(name)) 
[13:23:37.459]                               next
[13:23:37.459]                             if (!grepl(pattern, name)) 
[13:23:37.459]                               next
[13:23:37.459]                             invokeRestart(restart)
[13:23:37.459]                             muffled <- TRUE
[13:23:37.459]                             break
[13:23:37.459]                           }
[13:23:37.459]                         }
[13:23:37.459]                       }
[13:23:37.459]                       invisible(muffled)
[13:23:37.459]                     }
[13:23:37.459]                     muffleCondition(cond, pattern = "^muffle")
[13:23:37.459]                   }
[13:23:37.459]                 }
[13:23:37.459]             }
[13:23:37.459]         }))
[13:23:37.459]     }, error = function(ex) {
[13:23:37.459]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:37.459]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:37.459]                 ...future.rng), started = ...future.startTime, 
[13:23:37.459]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:37.459]             version = "1.8"), class = "FutureResult")
[13:23:37.459]     }, finally = {
[13:23:37.459]         if (!identical(...future.workdir, getwd())) 
[13:23:37.459]             setwd(...future.workdir)
[13:23:37.459]         {
[13:23:37.459]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:37.459]                 ...future.oldOptions$nwarnings <- NULL
[13:23:37.459]             }
[13:23:37.459]             base::options(...future.oldOptions)
[13:23:37.459]             if (.Platform$OS.type == "windows") {
[13:23:37.459]                 old_names <- names(...future.oldEnvVars)
[13:23:37.459]                 envs <- base::Sys.getenv()
[13:23:37.459]                 names <- names(envs)
[13:23:37.459]                 common <- intersect(names, old_names)
[13:23:37.459]                 added <- setdiff(names, old_names)
[13:23:37.459]                 removed <- setdiff(old_names, names)
[13:23:37.459]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:37.459]                   envs[common]]
[13:23:37.459]                 NAMES <- toupper(changed)
[13:23:37.459]                 args <- list()
[13:23:37.459]                 for (kk in seq_along(NAMES)) {
[13:23:37.459]                   name <- changed[[kk]]
[13:23:37.459]                   NAME <- NAMES[[kk]]
[13:23:37.459]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.459]                     next
[13:23:37.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:37.459]                 }
[13:23:37.459]                 NAMES <- toupper(added)
[13:23:37.459]                 for (kk in seq_along(NAMES)) {
[13:23:37.459]                   name <- added[[kk]]
[13:23:37.459]                   NAME <- NAMES[[kk]]
[13:23:37.459]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.459]                     next
[13:23:37.459]                   args[[name]] <- ""
[13:23:37.459]                 }
[13:23:37.459]                 NAMES <- toupper(removed)
[13:23:37.459]                 for (kk in seq_along(NAMES)) {
[13:23:37.459]                   name <- removed[[kk]]
[13:23:37.459]                   NAME <- NAMES[[kk]]
[13:23:37.459]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.459]                     next
[13:23:37.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:37.459]                 }
[13:23:37.459]                 if (length(args) > 0) 
[13:23:37.459]                   base::do.call(base::Sys.setenv, args = args)
[13:23:37.459]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:37.459]             }
[13:23:37.459]             else {
[13:23:37.459]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:37.459]             }
[13:23:37.459]             {
[13:23:37.459]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:37.459]                   0L) {
[13:23:37.459]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:37.459]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:37.459]                   base::options(opts)
[13:23:37.459]                 }
[13:23:37.459]                 {
[13:23:37.459]                   {
[13:23:37.459]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:37.459]                     NULL
[13:23:37.459]                   }
[13:23:37.459]                   options(future.plan = NULL)
[13:23:37.459]                   if (is.na(NA_character_)) 
[13:23:37.459]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:37.459]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:37.459]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:37.459]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:37.459]                     envir = parent.frame()) 
[13:23:37.459]                   {
[13:23:37.459]                     if (is.function(workers)) 
[13:23:37.459]                       workers <- workers()
[13:23:37.459]                     workers <- structure(as.integer(workers), 
[13:23:37.459]                       class = class(workers))
[13:23:37.459]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:37.459]                       workers >= 1)
[13:23:37.459]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:37.459]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:37.459]                     }
[13:23:37.459]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:37.459]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:37.459]                       envir = envir)
[13:23:37.459]                     if (!future$lazy) 
[13:23:37.459]                       future <- run(future)
[13:23:37.459]                     invisible(future)
[13:23:37.459]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:37.459]                 }
[13:23:37.459]             }
[13:23:37.459]         }
[13:23:37.459]     })
[13:23:37.459]     if (TRUE) {
[13:23:37.459]         base::sink(type = "output", split = FALSE)
[13:23:37.459]         if (TRUE) {
[13:23:37.459]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:37.459]         }
[13:23:37.459]         else {
[13:23:37.459]             ...future.result["stdout"] <- base::list(NULL)
[13:23:37.459]         }
[13:23:37.459]         base::close(...future.stdout)
[13:23:37.459]         ...future.stdout <- NULL
[13:23:37.459]     }
[13:23:37.459]     ...future.result$conditions <- ...future.conditions
[13:23:37.459]     ...future.result$finished <- base::Sys.time()
[13:23:37.459]     ...future.result
[13:23:37.459] }
[13:23:37.463] MultisessionFuture started
[13:23:37.463] - Launch lazy future ... done
[13:23:37.463] run() for ‘MultisessionFuture’ ... done
[13:23:37.463] result() for ClusterFuture ...
[13:23:37.463] receiveMessageFromWorker() for ClusterFuture ...
[13:23:37.463] - Validating connection of MultisessionFuture
[13:23:37.510] - received message: FutureResult
[13:23:37.510] - Received FutureResult
[13:23:37.510] - Erased future from FutureRegistry
[13:23:37.510] result() for ClusterFuture ...
[13:23:37.510] - result already collected: FutureResult
[13:23:37.510] result() for ClusterFuture ... done
[13:23:37.511] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:37.511] result() for ClusterFuture ... done
[13:23:37.511] result() for ClusterFuture ...
[13:23:37.511] - result already collected: FutureResult
[13:23:37.511] result() for ClusterFuture ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:37.511] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:37.512] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:37.513] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[13:23:37.513] Searching for globals ... DONE
[13:23:37.513] Resolving globals: TRUE
[13:23:37.514] Resolving any globals that are futures ...
[13:23:37.514] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[13:23:37.514] Resolving any globals that are futures ... DONE
[13:23:37.514] Resolving futures part of globals (recursively) ...
[13:23:37.514] resolve() on list ...
[13:23:37.514]  recursive: 99
[13:23:37.515]  length: 1
[13:23:37.515]  elements: ‘x’
[13:23:37.515]  length: 0 (resolved future 1)
[13:23:37.515] resolve() on list ... DONE
[13:23:37.515] - globals: [1] ‘x’
[13:23:37.515] Resolving futures part of globals (recursively) ... DONE
[13:23:37.515] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:37.516] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[13:23:37.516] - globals: [1] ‘x’
[13:23:37.516] 
[13:23:37.516] getGlobalsAndPackages() ... DONE
[13:23:37.516] run() for ‘Future’ ...
[13:23:37.516] - state: ‘created’
[13:23:37.516] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:37.531] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:37.531] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:37.531]   - Field: ‘node’
[13:23:37.531]   - Field: ‘label’
[13:23:37.532]   - Field: ‘local’
[13:23:37.532]   - Field: ‘owner’
[13:23:37.532]   - Field: ‘envir’
[13:23:37.532]   - Field: ‘workers’
[13:23:37.532]   - Field: ‘packages’
[13:23:37.532]   - Field: ‘gc’
[13:23:37.532]   - Field: ‘conditions’
[13:23:37.532]   - Field: ‘persistent’
[13:23:37.532]   - Field: ‘expr’
[13:23:37.533]   - Field: ‘uuid’
[13:23:37.533]   - Field: ‘seed’
[13:23:37.533]   - Field: ‘version’
[13:23:37.533]   - Field: ‘result’
[13:23:37.533]   - Field: ‘asynchronous’
[13:23:37.533]   - Field: ‘calls’
[13:23:37.533]   - Field: ‘globals’
[13:23:37.533]   - Field: ‘stdout’
[13:23:37.533]   - Field: ‘earlySignal’
[13:23:37.533]   - Field: ‘lazy’
[13:23:37.534]   - Field: ‘state’
[13:23:37.534] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:37.534] - Launch lazy future ...
[13:23:37.534] Packages needed by the future expression (n = 0): <none>
[13:23:37.534] Packages needed by future strategies (n = 0): <none>
[13:23:37.535] {
[13:23:37.535]     {
[13:23:37.535]         {
[13:23:37.535]             ...future.startTime <- base::Sys.time()
[13:23:37.535]             {
[13:23:37.535]                 {
[13:23:37.535]                   {
[13:23:37.535]                     {
[13:23:37.535]                       base::local({
[13:23:37.535]                         has_future <- base::requireNamespace("future", 
[13:23:37.535]                           quietly = TRUE)
[13:23:37.535]                         if (has_future) {
[13:23:37.535]                           ns <- base::getNamespace("future")
[13:23:37.535]                           version <- ns[[".package"]][["version"]]
[13:23:37.535]                           if (is.null(version)) 
[13:23:37.535]                             version <- utils::packageVersion("future")
[13:23:37.535]                         }
[13:23:37.535]                         else {
[13:23:37.535]                           version <- NULL
[13:23:37.535]                         }
[13:23:37.535]                         if (!has_future || version < "1.8.0") {
[13:23:37.535]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:37.535]                             "", base::R.version$version.string), 
[13:23:37.535]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:37.535]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:37.535]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:37.535]                               "release", "version")], collapse = " "), 
[13:23:37.535]                             hostname = base::Sys.info()[["nodename"]])
[13:23:37.535]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:37.535]                             info)
[13:23:37.535]                           info <- base::paste(info, collapse = "; ")
[13:23:37.535]                           if (!has_future) {
[13:23:37.535]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:37.535]                               info)
[13:23:37.535]                           }
[13:23:37.535]                           else {
[13:23:37.535]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:37.535]                               info, version)
[13:23:37.535]                           }
[13:23:37.535]                           base::stop(msg)
[13:23:37.535]                         }
[13:23:37.535]                       })
[13:23:37.535]                     }
[13:23:37.535]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:37.535]                     base::options(mc.cores = 1L)
[13:23:37.535]                   }
[13:23:37.535]                   options(future.plan = NULL)
[13:23:37.535]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:37.535]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:37.535]                 }
[13:23:37.535]                 ...future.workdir <- getwd()
[13:23:37.535]             }
[13:23:37.535]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:37.535]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:37.535]         }
[13:23:37.535]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:37.535]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:37.535]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:37.535]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:37.535]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:37.535]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:37.535]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:37.535]             base::names(...future.oldOptions))
[13:23:37.535]     }
[13:23:37.535]     if (FALSE) {
[13:23:37.535]     }
[13:23:37.535]     else {
[13:23:37.535]         if (TRUE) {
[13:23:37.535]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:37.535]                 open = "w")
[13:23:37.535]         }
[13:23:37.535]         else {
[13:23:37.535]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:37.535]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:37.535]         }
[13:23:37.535]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:37.535]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:37.535]             base::sink(type = "output", split = FALSE)
[13:23:37.535]             base::close(...future.stdout)
[13:23:37.535]         }, add = TRUE)
[13:23:37.535]     }
[13:23:37.535]     ...future.frame <- base::sys.nframe()
[13:23:37.535]     ...future.conditions <- base::list()
[13:23:37.535]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:37.535]     if (FALSE) {
[13:23:37.535]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:37.535]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:37.535]     }
[13:23:37.535]     ...future.result <- base::tryCatch({
[13:23:37.535]         base::withCallingHandlers({
[13:23:37.535]             ...future.value <- base::withVisible(base::local({
[13:23:37.535]                 ...future.makeSendCondition <- base::local({
[13:23:37.535]                   sendCondition <- NULL
[13:23:37.535]                   function(frame = 1L) {
[13:23:37.535]                     if (is.function(sendCondition)) 
[13:23:37.535]                       return(sendCondition)
[13:23:37.535]                     ns <- getNamespace("parallel")
[13:23:37.535]                     if (exists("sendData", mode = "function", 
[13:23:37.535]                       envir = ns)) {
[13:23:37.535]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:37.535]                         envir = ns)
[13:23:37.535]                       envir <- sys.frame(frame)
[13:23:37.535]                       master <- NULL
[13:23:37.535]                       while (!identical(envir, .GlobalEnv) && 
[13:23:37.535]                         !identical(envir, emptyenv())) {
[13:23:37.535]                         if (exists("master", mode = "list", envir = envir, 
[13:23:37.535]                           inherits = FALSE)) {
[13:23:37.535]                           master <- get("master", mode = "list", 
[13:23:37.535]                             envir = envir, inherits = FALSE)
[13:23:37.535]                           if (inherits(master, c("SOCKnode", 
[13:23:37.535]                             "SOCK0node"))) {
[13:23:37.535]                             sendCondition <<- function(cond) {
[13:23:37.535]                               data <- list(type = "VALUE", value = cond, 
[13:23:37.535]                                 success = TRUE)
[13:23:37.535]                               parallel_sendData(master, data)
[13:23:37.535]                             }
[13:23:37.535]                             return(sendCondition)
[13:23:37.535]                           }
[13:23:37.535]                         }
[13:23:37.535]                         frame <- frame + 1L
[13:23:37.535]                         envir <- sys.frame(frame)
[13:23:37.535]                       }
[13:23:37.535]                     }
[13:23:37.535]                     sendCondition <<- function(cond) NULL
[13:23:37.535]                   }
[13:23:37.535]                 })
[13:23:37.535]                 withCallingHandlers({
[13:23:37.535]                   {
[13:23:37.535]                     x <- x + 1
[13:23:37.535]                     x
[13:23:37.535]                   }
[13:23:37.535]                 }, immediateCondition = function(cond) {
[13:23:37.535]                   sendCondition <- ...future.makeSendCondition()
[13:23:37.535]                   sendCondition(cond)
[13:23:37.535]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:37.535]                   {
[13:23:37.535]                     inherits <- base::inherits
[13:23:37.535]                     invokeRestart <- base::invokeRestart
[13:23:37.535]                     is.null <- base::is.null
[13:23:37.535]                     muffled <- FALSE
[13:23:37.535]                     if (inherits(cond, "message")) {
[13:23:37.535]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:37.535]                       if (muffled) 
[13:23:37.535]                         invokeRestart("muffleMessage")
[13:23:37.535]                     }
[13:23:37.535]                     else if (inherits(cond, "warning")) {
[13:23:37.535]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:37.535]                       if (muffled) 
[13:23:37.535]                         invokeRestart("muffleWarning")
[13:23:37.535]                     }
[13:23:37.535]                     else if (inherits(cond, "condition")) {
[13:23:37.535]                       if (!is.null(pattern)) {
[13:23:37.535]                         computeRestarts <- base::computeRestarts
[13:23:37.535]                         grepl <- base::grepl
[13:23:37.535]                         restarts <- computeRestarts(cond)
[13:23:37.535]                         for (restart in restarts) {
[13:23:37.535]                           name <- restart$name
[13:23:37.535]                           if (is.null(name)) 
[13:23:37.535]                             next
[13:23:37.535]                           if (!grepl(pattern, name)) 
[13:23:37.535]                             next
[13:23:37.535]                           invokeRestart(restart)
[13:23:37.535]                           muffled <- TRUE
[13:23:37.535]                           break
[13:23:37.535]                         }
[13:23:37.535]                       }
[13:23:37.535]                     }
[13:23:37.535]                     invisible(muffled)
[13:23:37.535]                   }
[13:23:37.535]                   muffleCondition(cond)
[13:23:37.535]                 })
[13:23:37.535]             }))
[13:23:37.535]             future::FutureResult(value = ...future.value$value, 
[13:23:37.535]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:37.535]                   ...future.rng), globalenv = if (FALSE) 
[13:23:37.535]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:37.535]                     ...future.globalenv.names))
[13:23:37.535]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:37.535]         }, condition = base::local({
[13:23:37.535]             c <- base::c
[13:23:37.535]             inherits <- base::inherits
[13:23:37.535]             invokeRestart <- base::invokeRestart
[13:23:37.535]             length <- base::length
[13:23:37.535]             list <- base::list
[13:23:37.535]             seq.int <- base::seq.int
[13:23:37.535]             signalCondition <- base::signalCondition
[13:23:37.535]             sys.calls <- base::sys.calls
[13:23:37.535]             `[[` <- base::`[[`
[13:23:37.535]             `+` <- base::`+`
[13:23:37.535]             `<<-` <- base::`<<-`
[13:23:37.535]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:37.535]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:37.535]                   3L)]
[13:23:37.535]             }
[13:23:37.535]             function(cond) {
[13:23:37.535]                 is_error <- inherits(cond, "error")
[13:23:37.535]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:37.535]                   NULL)
[13:23:37.535]                 if (is_error) {
[13:23:37.535]                   sessionInformation <- function() {
[13:23:37.535]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:37.535]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:37.535]                       search = base::search(), system = base::Sys.info())
[13:23:37.535]                   }
[13:23:37.535]                   ...future.conditions[[length(...future.conditions) + 
[13:23:37.535]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:37.535]                     cond$call), session = sessionInformation(), 
[13:23:37.535]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:37.535]                   signalCondition(cond)
[13:23:37.535]                 }
[13:23:37.535]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:37.535]                 "immediateCondition"))) {
[13:23:37.535]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:37.535]                   ...future.conditions[[length(...future.conditions) + 
[13:23:37.535]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:37.535]                   if (TRUE && !signal) {
[13:23:37.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:37.535]                     {
[13:23:37.535]                       inherits <- base::inherits
[13:23:37.535]                       invokeRestart <- base::invokeRestart
[13:23:37.535]                       is.null <- base::is.null
[13:23:37.535]                       muffled <- FALSE
[13:23:37.535]                       if (inherits(cond, "message")) {
[13:23:37.535]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:37.535]                         if (muffled) 
[13:23:37.535]                           invokeRestart("muffleMessage")
[13:23:37.535]                       }
[13:23:37.535]                       else if (inherits(cond, "warning")) {
[13:23:37.535]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:37.535]                         if (muffled) 
[13:23:37.535]                           invokeRestart("muffleWarning")
[13:23:37.535]                       }
[13:23:37.535]                       else if (inherits(cond, "condition")) {
[13:23:37.535]                         if (!is.null(pattern)) {
[13:23:37.535]                           computeRestarts <- base::computeRestarts
[13:23:37.535]                           grepl <- base::grepl
[13:23:37.535]                           restarts <- computeRestarts(cond)
[13:23:37.535]                           for (restart in restarts) {
[13:23:37.535]                             name <- restart$name
[13:23:37.535]                             if (is.null(name)) 
[13:23:37.535]                               next
[13:23:37.535]                             if (!grepl(pattern, name)) 
[13:23:37.535]                               next
[13:23:37.535]                             invokeRestart(restart)
[13:23:37.535]                             muffled <- TRUE
[13:23:37.535]                             break
[13:23:37.535]                           }
[13:23:37.535]                         }
[13:23:37.535]                       }
[13:23:37.535]                       invisible(muffled)
[13:23:37.535]                     }
[13:23:37.535]                     muffleCondition(cond, pattern = "^muffle")
[13:23:37.535]                   }
[13:23:37.535]                 }
[13:23:37.535]                 else {
[13:23:37.535]                   if (TRUE) {
[13:23:37.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:37.535]                     {
[13:23:37.535]                       inherits <- base::inherits
[13:23:37.535]                       invokeRestart <- base::invokeRestart
[13:23:37.535]                       is.null <- base::is.null
[13:23:37.535]                       muffled <- FALSE
[13:23:37.535]                       if (inherits(cond, "message")) {
[13:23:37.535]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:37.535]                         if (muffled) 
[13:23:37.535]                           invokeRestart("muffleMessage")
[13:23:37.535]                       }
[13:23:37.535]                       else if (inherits(cond, "warning")) {
[13:23:37.535]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:37.535]                         if (muffled) 
[13:23:37.535]                           invokeRestart("muffleWarning")
[13:23:37.535]                       }
[13:23:37.535]                       else if (inherits(cond, "condition")) {
[13:23:37.535]                         if (!is.null(pattern)) {
[13:23:37.535]                           computeRestarts <- base::computeRestarts
[13:23:37.535]                           grepl <- base::grepl
[13:23:37.535]                           restarts <- computeRestarts(cond)
[13:23:37.535]                           for (restart in restarts) {
[13:23:37.535]                             name <- restart$name
[13:23:37.535]                             if (is.null(name)) 
[13:23:37.535]                               next
[13:23:37.535]                             if (!grepl(pattern, name)) 
[13:23:37.535]                               next
[13:23:37.535]                             invokeRestart(restart)
[13:23:37.535]                             muffled <- TRUE
[13:23:37.535]                             break
[13:23:37.535]                           }
[13:23:37.535]                         }
[13:23:37.535]                       }
[13:23:37.535]                       invisible(muffled)
[13:23:37.535]                     }
[13:23:37.535]                     muffleCondition(cond, pattern = "^muffle")
[13:23:37.535]                   }
[13:23:37.535]                 }
[13:23:37.535]             }
[13:23:37.535]         }))
[13:23:37.535]     }, error = function(ex) {
[13:23:37.535]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:37.535]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:37.535]                 ...future.rng), started = ...future.startTime, 
[13:23:37.535]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:37.535]             version = "1.8"), class = "FutureResult")
[13:23:37.535]     }, finally = {
[13:23:37.535]         if (!identical(...future.workdir, getwd())) 
[13:23:37.535]             setwd(...future.workdir)
[13:23:37.535]         {
[13:23:37.535]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:37.535]                 ...future.oldOptions$nwarnings <- NULL
[13:23:37.535]             }
[13:23:37.535]             base::options(...future.oldOptions)
[13:23:37.535]             if (.Platform$OS.type == "windows") {
[13:23:37.535]                 old_names <- names(...future.oldEnvVars)
[13:23:37.535]                 envs <- base::Sys.getenv()
[13:23:37.535]                 names <- names(envs)
[13:23:37.535]                 common <- intersect(names, old_names)
[13:23:37.535]                 added <- setdiff(names, old_names)
[13:23:37.535]                 removed <- setdiff(old_names, names)
[13:23:37.535]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:37.535]                   envs[common]]
[13:23:37.535]                 NAMES <- toupper(changed)
[13:23:37.535]                 args <- list()
[13:23:37.535]                 for (kk in seq_along(NAMES)) {
[13:23:37.535]                   name <- changed[[kk]]
[13:23:37.535]                   NAME <- NAMES[[kk]]
[13:23:37.535]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.535]                     next
[13:23:37.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:37.535]                 }
[13:23:37.535]                 NAMES <- toupper(added)
[13:23:37.535]                 for (kk in seq_along(NAMES)) {
[13:23:37.535]                   name <- added[[kk]]
[13:23:37.535]                   NAME <- NAMES[[kk]]
[13:23:37.535]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.535]                     next
[13:23:37.535]                   args[[name]] <- ""
[13:23:37.535]                 }
[13:23:37.535]                 NAMES <- toupper(removed)
[13:23:37.535]                 for (kk in seq_along(NAMES)) {
[13:23:37.535]                   name <- removed[[kk]]
[13:23:37.535]                   NAME <- NAMES[[kk]]
[13:23:37.535]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.535]                     next
[13:23:37.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:37.535]                 }
[13:23:37.535]                 if (length(args) > 0) 
[13:23:37.535]                   base::do.call(base::Sys.setenv, args = args)
[13:23:37.535]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:37.535]             }
[13:23:37.535]             else {
[13:23:37.535]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:37.535]             }
[13:23:37.535]             {
[13:23:37.535]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:37.535]                   0L) {
[13:23:37.535]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:37.535]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:37.535]                   base::options(opts)
[13:23:37.535]                 }
[13:23:37.535]                 {
[13:23:37.535]                   {
[13:23:37.535]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:37.535]                     NULL
[13:23:37.535]                   }
[13:23:37.535]                   options(future.plan = NULL)
[13:23:37.535]                   if (is.na(NA_character_)) 
[13:23:37.535]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:37.535]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:37.535]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:37.535]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:37.535]                     envir = parent.frame()) 
[13:23:37.535]                   {
[13:23:37.535]                     if (is.function(workers)) 
[13:23:37.535]                       workers <- workers()
[13:23:37.535]                     workers <- structure(as.integer(workers), 
[13:23:37.535]                       class = class(workers))
[13:23:37.535]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:37.535]                       workers >= 1)
[13:23:37.535]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:37.535]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:37.535]                     }
[13:23:37.535]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:37.535]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:37.535]                       envir = envir)
[13:23:37.535]                     if (!future$lazy) 
[13:23:37.535]                       future <- run(future)
[13:23:37.535]                     invisible(future)
[13:23:37.535]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:37.535]                 }
[13:23:37.535]             }
[13:23:37.535]         }
[13:23:37.535]     })
[13:23:37.535]     if (TRUE) {
[13:23:37.535]         base::sink(type = "output", split = FALSE)
[13:23:37.535]         if (TRUE) {
[13:23:37.535]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:37.535]         }
[13:23:37.535]         else {
[13:23:37.535]             ...future.result["stdout"] <- base::list(NULL)
[13:23:37.535]         }
[13:23:37.535]         base::close(...future.stdout)
[13:23:37.535]         ...future.stdout <- NULL
[13:23:37.535]     }
[13:23:37.535]     ...future.result$conditions <- ...future.conditions
[13:23:37.535]     ...future.result$finished <- base::Sys.time()
[13:23:37.535]     ...future.result
[13:23:37.535] }
[13:23:37.538] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:23:37.538] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[13:23:37.538] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[13:23:37.538] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:23:37.539] MultisessionFuture started
[13:23:37.539] - Launch lazy future ... done
[13:23:37.539] run() for ‘MultisessionFuture’ ... done
[13:23:37.539] result() for ClusterFuture ...
[13:23:37.539] receiveMessageFromWorker() for ClusterFuture ...
[13:23:37.540] - Validating connection of MultisessionFuture
[13:23:37.586] - received message: FutureResult
[13:23:37.586] - Received FutureResult
[13:23:37.586] - Erased future from FutureRegistry
[13:23:37.586] result() for ClusterFuture ...
[13:23:37.586] - result already collected: FutureResult
[13:23:37.586] result() for ClusterFuture ... done
[13:23:37.587] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:37.587] result() for ClusterFuture ... done
[13:23:37.587] result() for ClusterFuture ...
[13:23:37.587] - result already collected: FutureResult
[13:23:37.587] result() for ClusterFuture ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:23:37.587] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:23:37.588] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:23:37.589] - globals found: [3] ‘{’, ‘<-’, ‘x’
[13:23:37.589] Searching for globals ... DONE
[13:23:37.590] Resolving globals: TRUE
[13:23:37.590] Resolving any globals that are futures ...
[13:23:37.590] - globals: [3] ‘{’, ‘<-’, ‘x’
[13:23:37.590] Resolving any globals that are futures ... DONE
[13:23:37.590] Resolving futures part of globals (recursively) ...
[13:23:37.590] resolve() on list ...
[13:23:37.591]  recursive: 99
[13:23:37.591]  length: 1
[13:23:37.591]  elements: ‘x’
[13:23:37.591]  length: 0 (resolved future 1)
[13:23:37.591] resolve() on list ... DONE
[13:23:37.591] - globals: [1] ‘x’
[13:23:37.591] Resolving futures part of globals (recursively) ... DONE
[13:23:37.591] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[13:23:37.592] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[13:23:37.592] - globals: [1] ‘x’
[13:23:37.592] 
[13:23:37.592] getGlobalsAndPackages() ... DONE
[13:23:37.592] run() for ‘Future’ ...
[13:23:37.592] - state: ‘created’
[13:23:37.593] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:37.607] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:37.607] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:37.608]   - Field: ‘node’
[13:23:37.608]   - Field: ‘label’
[13:23:37.608]   - Field: ‘local’
[13:23:37.608]   - Field: ‘owner’
[13:23:37.608]   - Field: ‘envir’
[13:23:37.608]   - Field: ‘workers’
[13:23:37.608]   - Field: ‘packages’
[13:23:37.608]   - Field: ‘gc’
[13:23:37.609]   - Field: ‘conditions’
[13:23:37.609]   - Field: ‘persistent’
[13:23:37.609]   - Field: ‘expr’
[13:23:37.609]   - Field: ‘uuid’
[13:23:37.609]   - Field: ‘seed’
[13:23:37.609]   - Field: ‘version’
[13:23:37.609]   - Field: ‘result’
[13:23:37.609]   - Field: ‘asynchronous’
[13:23:37.609]   - Field: ‘calls’
[13:23:37.609]   - Field: ‘globals’
[13:23:37.609]   - Field: ‘stdout’
[13:23:37.610]   - Field: ‘earlySignal’
[13:23:37.610]   - Field: ‘lazy’
[13:23:37.610]   - Field: ‘state’
[13:23:37.610] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:37.610] - Launch lazy future ...
[13:23:37.610] Packages needed by the future expression (n = 0): <none>
[13:23:37.610] Packages needed by future strategies (n = 0): <none>
[13:23:37.611] {
[13:23:37.611]     {
[13:23:37.611]         {
[13:23:37.611]             ...future.startTime <- base::Sys.time()
[13:23:37.611]             {
[13:23:37.611]                 {
[13:23:37.611]                   {
[13:23:37.611]                     {
[13:23:37.611]                       base::local({
[13:23:37.611]                         has_future <- base::requireNamespace("future", 
[13:23:37.611]                           quietly = TRUE)
[13:23:37.611]                         if (has_future) {
[13:23:37.611]                           ns <- base::getNamespace("future")
[13:23:37.611]                           version <- ns[[".package"]][["version"]]
[13:23:37.611]                           if (is.null(version)) 
[13:23:37.611]                             version <- utils::packageVersion("future")
[13:23:37.611]                         }
[13:23:37.611]                         else {
[13:23:37.611]                           version <- NULL
[13:23:37.611]                         }
[13:23:37.611]                         if (!has_future || version < "1.8.0") {
[13:23:37.611]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:37.611]                             "", base::R.version$version.string), 
[13:23:37.611]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:37.611]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:37.611]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:37.611]                               "release", "version")], collapse = " "), 
[13:23:37.611]                             hostname = base::Sys.info()[["nodename"]])
[13:23:37.611]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:37.611]                             info)
[13:23:37.611]                           info <- base::paste(info, collapse = "; ")
[13:23:37.611]                           if (!has_future) {
[13:23:37.611]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:37.611]                               info)
[13:23:37.611]                           }
[13:23:37.611]                           else {
[13:23:37.611]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:37.611]                               info, version)
[13:23:37.611]                           }
[13:23:37.611]                           base::stop(msg)
[13:23:37.611]                         }
[13:23:37.611]                       })
[13:23:37.611]                     }
[13:23:37.611]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:37.611]                     base::options(mc.cores = 1L)
[13:23:37.611]                   }
[13:23:37.611]                   options(future.plan = NULL)
[13:23:37.611]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:37.611]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:37.611]                 }
[13:23:37.611]                 ...future.workdir <- getwd()
[13:23:37.611]             }
[13:23:37.611]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:37.611]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:37.611]         }
[13:23:37.611]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:23:37.611]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:23:37.611]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:23:37.611]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:23:37.611]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:37.611]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:37.611]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:37.611]             base::names(...future.oldOptions))
[13:23:37.611]     }
[13:23:37.611]     if (FALSE) {
[13:23:37.611]     }
[13:23:37.611]     else {
[13:23:37.611]         if (TRUE) {
[13:23:37.611]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:37.611]                 open = "w")
[13:23:37.611]         }
[13:23:37.611]         else {
[13:23:37.611]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:37.611]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:37.611]         }
[13:23:37.611]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:37.611]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:37.611]             base::sink(type = "output", split = FALSE)
[13:23:37.611]             base::close(...future.stdout)
[13:23:37.611]         }, add = TRUE)
[13:23:37.611]     }
[13:23:37.611]     ...future.frame <- base::sys.nframe()
[13:23:37.611]     ...future.conditions <- base::list()
[13:23:37.611]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:37.611]     if (FALSE) {
[13:23:37.611]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:37.611]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:37.611]     }
[13:23:37.611]     ...future.result <- base::tryCatch({
[13:23:37.611]         base::withCallingHandlers({
[13:23:37.611]             ...future.value <- base::withVisible(base::local({
[13:23:37.611]                 ...future.makeSendCondition <- base::local({
[13:23:37.611]                   sendCondition <- NULL
[13:23:37.611]                   function(frame = 1L) {
[13:23:37.611]                     if (is.function(sendCondition)) 
[13:23:37.611]                       return(sendCondition)
[13:23:37.611]                     ns <- getNamespace("parallel")
[13:23:37.611]                     if (exists("sendData", mode = "function", 
[13:23:37.611]                       envir = ns)) {
[13:23:37.611]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:37.611]                         envir = ns)
[13:23:37.611]                       envir <- sys.frame(frame)
[13:23:37.611]                       master <- NULL
[13:23:37.611]                       while (!identical(envir, .GlobalEnv) && 
[13:23:37.611]                         !identical(envir, emptyenv())) {
[13:23:37.611]                         if (exists("master", mode = "list", envir = envir, 
[13:23:37.611]                           inherits = FALSE)) {
[13:23:37.611]                           master <- get("master", mode = "list", 
[13:23:37.611]                             envir = envir, inherits = FALSE)
[13:23:37.611]                           if (inherits(master, c("SOCKnode", 
[13:23:37.611]                             "SOCK0node"))) {
[13:23:37.611]                             sendCondition <<- function(cond) {
[13:23:37.611]                               data <- list(type = "VALUE", value = cond, 
[13:23:37.611]                                 success = TRUE)
[13:23:37.611]                               parallel_sendData(master, data)
[13:23:37.611]                             }
[13:23:37.611]                             return(sendCondition)
[13:23:37.611]                           }
[13:23:37.611]                         }
[13:23:37.611]                         frame <- frame + 1L
[13:23:37.611]                         envir <- sys.frame(frame)
[13:23:37.611]                       }
[13:23:37.611]                     }
[13:23:37.611]                     sendCondition <<- function(cond) NULL
[13:23:37.611]                   }
[13:23:37.611]                 })
[13:23:37.611]                 withCallingHandlers({
[13:23:37.611]                   {
[13:23:37.611]                     x <- x()
[13:23:37.611]                     x
[13:23:37.611]                   }
[13:23:37.611]                 }, immediateCondition = function(cond) {
[13:23:37.611]                   sendCondition <- ...future.makeSendCondition()
[13:23:37.611]                   sendCondition(cond)
[13:23:37.611]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:37.611]                   {
[13:23:37.611]                     inherits <- base::inherits
[13:23:37.611]                     invokeRestart <- base::invokeRestart
[13:23:37.611]                     is.null <- base::is.null
[13:23:37.611]                     muffled <- FALSE
[13:23:37.611]                     if (inherits(cond, "message")) {
[13:23:37.611]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:37.611]                       if (muffled) 
[13:23:37.611]                         invokeRestart("muffleMessage")
[13:23:37.611]                     }
[13:23:37.611]                     else if (inherits(cond, "warning")) {
[13:23:37.611]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:37.611]                       if (muffled) 
[13:23:37.611]                         invokeRestart("muffleWarning")
[13:23:37.611]                     }
[13:23:37.611]                     else if (inherits(cond, "condition")) {
[13:23:37.611]                       if (!is.null(pattern)) {
[13:23:37.611]                         computeRestarts <- base::computeRestarts
[13:23:37.611]                         grepl <- base::grepl
[13:23:37.611]                         restarts <- computeRestarts(cond)
[13:23:37.611]                         for (restart in restarts) {
[13:23:37.611]                           name <- restart$name
[13:23:37.611]                           if (is.null(name)) 
[13:23:37.611]                             next
[13:23:37.611]                           if (!grepl(pattern, name)) 
[13:23:37.611]                             next
[13:23:37.611]                           invokeRestart(restart)
[13:23:37.611]                           muffled <- TRUE
[13:23:37.611]                           break
[13:23:37.611]                         }
[13:23:37.611]                       }
[13:23:37.611]                     }
[13:23:37.611]                     invisible(muffled)
[13:23:37.611]                   }
[13:23:37.611]                   muffleCondition(cond)
[13:23:37.611]                 })
[13:23:37.611]             }))
[13:23:37.611]             future::FutureResult(value = ...future.value$value, 
[13:23:37.611]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:37.611]                   ...future.rng), globalenv = if (FALSE) 
[13:23:37.611]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:37.611]                     ...future.globalenv.names))
[13:23:37.611]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:37.611]         }, condition = base::local({
[13:23:37.611]             c <- base::c
[13:23:37.611]             inherits <- base::inherits
[13:23:37.611]             invokeRestart <- base::invokeRestart
[13:23:37.611]             length <- base::length
[13:23:37.611]             list <- base::list
[13:23:37.611]             seq.int <- base::seq.int
[13:23:37.611]             signalCondition <- base::signalCondition
[13:23:37.611]             sys.calls <- base::sys.calls
[13:23:37.611]             `[[` <- base::`[[`
[13:23:37.611]             `+` <- base::`+`
[13:23:37.611]             `<<-` <- base::`<<-`
[13:23:37.611]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:37.611]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:37.611]                   3L)]
[13:23:37.611]             }
[13:23:37.611]             function(cond) {
[13:23:37.611]                 is_error <- inherits(cond, "error")
[13:23:37.611]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:37.611]                   NULL)
[13:23:37.611]                 if (is_error) {
[13:23:37.611]                   sessionInformation <- function() {
[13:23:37.611]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:37.611]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:37.611]                       search = base::search(), system = base::Sys.info())
[13:23:37.611]                   }
[13:23:37.611]                   ...future.conditions[[length(...future.conditions) + 
[13:23:37.611]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:37.611]                     cond$call), session = sessionInformation(), 
[13:23:37.611]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:37.611]                   signalCondition(cond)
[13:23:37.611]                 }
[13:23:37.611]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:37.611]                 "immediateCondition"))) {
[13:23:37.611]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:37.611]                   ...future.conditions[[length(...future.conditions) + 
[13:23:37.611]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:37.611]                   if (TRUE && !signal) {
[13:23:37.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:37.611]                     {
[13:23:37.611]                       inherits <- base::inherits
[13:23:37.611]                       invokeRestart <- base::invokeRestart
[13:23:37.611]                       is.null <- base::is.null
[13:23:37.611]                       muffled <- FALSE
[13:23:37.611]                       if (inherits(cond, "message")) {
[13:23:37.611]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:37.611]                         if (muffled) 
[13:23:37.611]                           invokeRestart("muffleMessage")
[13:23:37.611]                       }
[13:23:37.611]                       else if (inherits(cond, "warning")) {
[13:23:37.611]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:37.611]                         if (muffled) 
[13:23:37.611]                           invokeRestart("muffleWarning")
[13:23:37.611]                       }
[13:23:37.611]                       else if (inherits(cond, "condition")) {
[13:23:37.611]                         if (!is.null(pattern)) {
[13:23:37.611]                           computeRestarts <- base::computeRestarts
[13:23:37.611]                           grepl <- base::grepl
[13:23:37.611]                           restarts <- computeRestarts(cond)
[13:23:37.611]                           for (restart in restarts) {
[13:23:37.611]                             name <- restart$name
[13:23:37.611]                             if (is.null(name)) 
[13:23:37.611]                               next
[13:23:37.611]                             if (!grepl(pattern, name)) 
[13:23:37.611]                               next
[13:23:37.611]                             invokeRestart(restart)
[13:23:37.611]                             muffled <- TRUE
[13:23:37.611]                             break
[13:23:37.611]                           }
[13:23:37.611]                         }
[13:23:37.611]                       }
[13:23:37.611]                       invisible(muffled)
[13:23:37.611]                     }
[13:23:37.611]                     muffleCondition(cond, pattern = "^muffle")
[13:23:37.611]                   }
[13:23:37.611]                 }
[13:23:37.611]                 else {
[13:23:37.611]                   if (TRUE) {
[13:23:37.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:37.611]                     {
[13:23:37.611]                       inherits <- base::inherits
[13:23:37.611]                       invokeRestart <- base::invokeRestart
[13:23:37.611]                       is.null <- base::is.null
[13:23:37.611]                       muffled <- FALSE
[13:23:37.611]                       if (inherits(cond, "message")) {
[13:23:37.611]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:37.611]                         if (muffled) 
[13:23:37.611]                           invokeRestart("muffleMessage")
[13:23:37.611]                       }
[13:23:37.611]                       else if (inherits(cond, "warning")) {
[13:23:37.611]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:37.611]                         if (muffled) 
[13:23:37.611]                           invokeRestart("muffleWarning")
[13:23:37.611]                       }
[13:23:37.611]                       else if (inherits(cond, "condition")) {
[13:23:37.611]                         if (!is.null(pattern)) {
[13:23:37.611]                           computeRestarts <- base::computeRestarts
[13:23:37.611]                           grepl <- base::grepl
[13:23:37.611]                           restarts <- computeRestarts(cond)
[13:23:37.611]                           for (restart in restarts) {
[13:23:37.611]                             name <- restart$name
[13:23:37.611]                             if (is.null(name)) 
[13:23:37.611]                               next
[13:23:37.611]                             if (!grepl(pattern, name)) 
[13:23:37.611]                               next
[13:23:37.611]                             invokeRestart(restart)
[13:23:37.611]                             muffled <- TRUE
[13:23:37.611]                             break
[13:23:37.611]                           }
[13:23:37.611]                         }
[13:23:37.611]                       }
[13:23:37.611]                       invisible(muffled)
[13:23:37.611]                     }
[13:23:37.611]                     muffleCondition(cond, pattern = "^muffle")
[13:23:37.611]                   }
[13:23:37.611]                 }
[13:23:37.611]             }
[13:23:37.611]         }))
[13:23:37.611]     }, error = function(ex) {
[13:23:37.611]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:37.611]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:37.611]                 ...future.rng), started = ...future.startTime, 
[13:23:37.611]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:37.611]             version = "1.8"), class = "FutureResult")
[13:23:37.611]     }, finally = {
[13:23:37.611]         if (!identical(...future.workdir, getwd())) 
[13:23:37.611]             setwd(...future.workdir)
[13:23:37.611]         {
[13:23:37.611]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:37.611]                 ...future.oldOptions$nwarnings <- NULL
[13:23:37.611]             }
[13:23:37.611]             base::options(...future.oldOptions)
[13:23:37.611]             if (.Platform$OS.type == "windows") {
[13:23:37.611]                 old_names <- names(...future.oldEnvVars)
[13:23:37.611]                 envs <- base::Sys.getenv()
[13:23:37.611]                 names <- names(envs)
[13:23:37.611]                 common <- intersect(names, old_names)
[13:23:37.611]                 added <- setdiff(names, old_names)
[13:23:37.611]                 removed <- setdiff(old_names, names)
[13:23:37.611]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:37.611]                   envs[common]]
[13:23:37.611]                 NAMES <- toupper(changed)
[13:23:37.611]                 args <- list()
[13:23:37.611]                 for (kk in seq_along(NAMES)) {
[13:23:37.611]                   name <- changed[[kk]]
[13:23:37.611]                   NAME <- NAMES[[kk]]
[13:23:37.611]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.611]                     next
[13:23:37.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:37.611]                 }
[13:23:37.611]                 NAMES <- toupper(added)
[13:23:37.611]                 for (kk in seq_along(NAMES)) {
[13:23:37.611]                   name <- added[[kk]]
[13:23:37.611]                   NAME <- NAMES[[kk]]
[13:23:37.611]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.611]                     next
[13:23:37.611]                   args[[name]] <- ""
[13:23:37.611]                 }
[13:23:37.611]                 NAMES <- toupper(removed)
[13:23:37.611]                 for (kk in seq_along(NAMES)) {
[13:23:37.611]                   name <- removed[[kk]]
[13:23:37.611]                   NAME <- NAMES[[kk]]
[13:23:37.611]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:37.611]                     next
[13:23:37.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:37.611]                 }
[13:23:37.611]                 if (length(args) > 0) 
[13:23:37.611]                   base::do.call(base::Sys.setenv, args = args)
[13:23:37.611]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:37.611]             }
[13:23:37.611]             else {
[13:23:37.611]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:37.611]             }
[13:23:37.611]             {
[13:23:37.611]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:37.611]                   0L) {
[13:23:37.611]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:37.611]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:37.611]                   base::options(opts)
[13:23:37.611]                 }
[13:23:37.611]                 {
[13:23:37.611]                   {
[13:23:37.611]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:37.611]                     NULL
[13:23:37.611]                   }
[13:23:37.611]                   options(future.plan = NULL)
[13:23:37.611]                   if (is.na(NA_character_)) 
[13:23:37.611]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:37.611]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:37.611]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:37.611]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:37.611]                     envir = parent.frame()) 
[13:23:37.611]                   {
[13:23:37.611]                     if (is.function(workers)) 
[13:23:37.611]                       workers <- workers()
[13:23:37.611]                     workers <- structure(as.integer(workers), 
[13:23:37.611]                       class = class(workers))
[13:23:37.611]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:37.611]                       workers >= 1)
[13:23:37.611]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:37.611]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:37.611]                     }
[13:23:37.611]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:37.611]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:37.611]                       envir = envir)
[13:23:37.611]                     if (!future$lazy) 
[13:23:37.611]                       future <- run(future)
[13:23:37.611]                     invisible(future)
[13:23:37.611]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:37.611]                 }
[13:23:37.611]             }
[13:23:37.611]         }
[13:23:37.611]     })
[13:23:37.611]     if (TRUE) {
[13:23:37.611]         base::sink(type = "output", split = FALSE)
[13:23:37.611]         if (TRUE) {
[13:23:37.611]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:37.611]         }
[13:23:37.611]         else {
[13:23:37.611]             ...future.result["stdout"] <- base::list(NULL)
[13:23:37.611]         }
[13:23:37.611]         base::close(...future.stdout)
[13:23:37.611]         ...future.stdout <- NULL
[13:23:37.611]     }
[13:23:37.611]     ...future.result$conditions <- ...future.conditions
[13:23:37.611]     ...future.result$finished <- base::Sys.time()
[13:23:37.611]     ...future.result
[13:23:37.611] }
[13:23:37.614] Exporting 1 global objects (1.01 KiB) to cluster node #1 ...
[13:23:37.614] Exporting ‘x’ (1.01 KiB) to cluster node #1 ...
[13:23:37.614] Exporting ‘x’ (1.01 KiB) to cluster node #1 ... DONE
[13:23:37.615] Exporting 1 global objects (1.01 KiB) to cluster node #1 ... DONE
[13:23:37.615] MultisessionFuture started
[13:23:37.615] - Launch lazy future ... done
[13:23:37.615] run() for ‘MultisessionFuture’ ... done
[13:23:37.616] result() for ClusterFuture ...
[13:23:37.616] receiveMessageFromWorker() for ClusterFuture ...
[13:23:37.616] - Validating connection of MultisessionFuture
[13:23:37.662] - received message: FutureResult
[13:23:37.662] - Received FutureResult
[13:23:37.662] - Erased future from FutureRegistry
[13:23:37.663] result() for ClusterFuture ...
[13:23:37.663] - result already collected: FutureResult
[13:23:37.663] result() for ClusterFuture ... done
[13:23:37.663] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:37.663] result() for ClusterFuture ... done
[13:23:37.663] result() for ClusterFuture ...
[13:23:37.663] - result already collected: FutureResult
[13:23:37.663] result() for ClusterFuture ... done
value(f) = ‘TRUE’
Testing with 2 cores ... DONE
> 
> message("*** Tricky use cases related to globals ... DONE")
*** Tricky use cases related to globals ... DONE
> 
> source("incl/end.R")
[13:23:37.664] plan(): Setting new future strategy stack:
[13:23:37.664] List of future strategies:
[13:23:37.664] 1. FutureStrategy:
[13:23:37.664]    - args: function (..., envir = parent.frame())
[13:23:37.664]    - tweaked: FALSE
[13:23:37.664]    - call: future::plan(oplan)
[13:23:37.665] plan(): nbrOfWorkers() = 1
> 
