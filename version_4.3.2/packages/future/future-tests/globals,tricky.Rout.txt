
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:26:11.121] plan(): Setting new future strategy stack:
[10:26:11.121] List of future strategies:
[10:26:11.121] 1. sequential:
[10:26:11.121]    - args: function (..., envir = parent.frame())
[10:26:11.121]    - tweaked: FALSE
[10:26:11.121]    - call: future::plan("sequential")
[10:26:11.135] plan(): nbrOfWorkers() = 1
> library("listenv")
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Tricky use cases related to globals ...")
*** Tricky use cases related to globals ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   message("- Local variables with the same name as globals ...")
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     methods <- c("conservative", "ordered")
+     for (method in methods) {
+       options(future.globals.method = method)
+       message(sprintf("Method for identifying globals: '%s' ...", method))
+ 
+       a <- 3
+ 
+       yTruth <- local({
+         b <- a
+         a <- 2
+         a * b
+       })
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       }
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       a <- 3
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       } %lazy% TRUE
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         }
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         } %lazy% TRUE
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Assert that `a` is resolved and turned into a constant future
+       ## at the moment when future `b` is created.
+       ## Requires options(future.globals.resolve = TRUE).
+       a <- future(1)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+ 
+       ## BUG FIX: In future (<= 1.0.0) a global 'pkg' would be
+       ## overwritten by the name of the last package attached
+       ## by the future.
+       pkg <- "foo"
+       f <- sequential({ pkg })
+       v <- value(f)
+       message(sprintf("value(f) = %s", sQuote(v)))
+       stopifnot(pkg == "foo", v == "foo")
+       
+       message(sprintf("Method for identifying globals: '%s' ... DONE", method))
+     }
+ 
+     ## BUG FIX: In globals (<= 0.10.3) a global 'x' in LHS of an assignment
+     ## would be missed.
+     options(future.globals.method = "ordered")
+ 
+     ## A local
+     x <- 1
+     f <- future({ x <- 0; x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 1)
+     
+     ## A global
+     x <- 1
+     f <- future({ x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 2)
+ 
+     ## A global
+     x <- function() TRUE
+     f <- future({ x <- x(); x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == TRUE)
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- Local variables with the same name as globals ...
- plan('sequential') ...
[10:26:11.223] plan(): Setting new future strategy stack:
[10:26:11.224] List of future strategies:
[10:26:11.224] 1. sequential:
[10:26:11.224]    - args: function (..., envir = parent.frame())
[10:26:11.224]    - tweaked: FALSE
[10:26:11.224]    - call: plan(strategy)
[10:26:11.235] plan(): nbrOfWorkers() = 1
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.237] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.237] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:11.243] - globals found: [3] ‘{’, ‘<-’, ‘*’
[10:26:11.244] Searching for globals ... DONE
[10:26:11.244] Resolving globals: TRUE
[10:26:11.244] Resolving any globals that are futures ...
[10:26:11.244] - globals: [3] ‘{’, ‘<-’, ‘*’
[10:26:11.244] Resolving any globals that are futures ... DONE
[10:26:11.245] 
[10:26:11.245] 
[10:26:11.245] getGlobalsAndPackages() ... DONE
[10:26:11.245] run() for ‘Future’ ...
[10:26:11.246] - state: ‘created’
[10:26:11.246] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.246] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.246] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.246]   - Field: ‘label’
[10:26:11.246]   - Field: ‘local’
[10:26:11.247]   - Field: ‘owner’
[10:26:11.247]   - Field: ‘envir’
[10:26:11.247]   - Field: ‘packages’
[10:26:11.247]   - Field: ‘gc’
[10:26:11.247]   - Field: ‘conditions’
[10:26:11.247]   - Field: ‘expr’
[10:26:11.247]   - Field: ‘uuid’
[10:26:11.247]   - Field: ‘seed’
[10:26:11.247]   - Field: ‘version’
[10:26:11.247]   - Field: ‘result’
[10:26:11.247]   - Field: ‘asynchronous’
[10:26:11.248]   - Field: ‘calls’
[10:26:11.248]   - Field: ‘globals’
[10:26:11.248]   - Field: ‘stdout’
[10:26:11.248]   - Field: ‘earlySignal’
[10:26:11.248]   - Field: ‘lazy’
[10:26:11.248]   - Field: ‘state’
[10:26:11.248] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.248] - Launch lazy future ...
[10:26:11.249] Packages needed by the future expression (n = 0): <none>
[10:26:11.249] Packages needed by future strategies (n = 0): <none>
[10:26:11.250] {
[10:26:11.250]     {
[10:26:11.250]         {
[10:26:11.250]             ...future.startTime <- base::Sys.time()
[10:26:11.250]             {
[10:26:11.250]                 {
[10:26:11.250]                   {
[10:26:11.250]                     base::local({
[10:26:11.250]                       has_future <- base::requireNamespace("future", 
[10:26:11.250]                         quietly = TRUE)
[10:26:11.250]                       if (has_future) {
[10:26:11.250]                         ns <- base::getNamespace("future")
[10:26:11.250]                         version <- ns[[".package"]][["version"]]
[10:26:11.250]                         if (is.null(version)) 
[10:26:11.250]                           version <- utils::packageVersion("future")
[10:26:11.250]                       }
[10:26:11.250]                       else {
[10:26:11.250]                         version <- NULL
[10:26:11.250]                       }
[10:26:11.250]                       if (!has_future || version < "1.8.0") {
[10:26:11.250]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.250]                           "", base::R.version$version.string), 
[10:26:11.250]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.250]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.250]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.250]                             "release", "version")], collapse = " "), 
[10:26:11.250]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.250]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.250]                           info)
[10:26:11.250]                         info <- base::paste(info, collapse = "; ")
[10:26:11.250]                         if (!has_future) {
[10:26:11.250]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.250]                             info)
[10:26:11.250]                         }
[10:26:11.250]                         else {
[10:26:11.250]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.250]                             info, version)
[10:26:11.250]                         }
[10:26:11.250]                         base::stop(msg)
[10:26:11.250]                       }
[10:26:11.250]                     })
[10:26:11.250]                   }
[10:26:11.250]                   options(future.plan = NULL)
[10:26:11.250]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.250]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.250]                 }
[10:26:11.250]                 ...future.workdir <- getwd()
[10:26:11.250]             }
[10:26:11.250]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.250]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.250]         }
[10:26:11.250]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.250]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:11.250]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.250]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.250]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.250]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.250]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.250]             base::names(...future.oldOptions))
[10:26:11.250]     }
[10:26:11.250]     if (FALSE) {
[10:26:11.250]     }
[10:26:11.250]     else {
[10:26:11.250]         if (TRUE) {
[10:26:11.250]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.250]                 open = "w")
[10:26:11.250]         }
[10:26:11.250]         else {
[10:26:11.250]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.250]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.250]         }
[10:26:11.250]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.250]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.250]             base::sink(type = "output", split = FALSE)
[10:26:11.250]             base::close(...future.stdout)
[10:26:11.250]         }, add = TRUE)
[10:26:11.250]     }
[10:26:11.250]     ...future.frame <- base::sys.nframe()
[10:26:11.250]     ...future.conditions <- base::list()
[10:26:11.250]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.250]     if (FALSE) {
[10:26:11.250]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.250]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.250]     }
[10:26:11.250]     ...future.result <- base::tryCatch({
[10:26:11.250]         base::withCallingHandlers({
[10:26:11.250]             ...future.value <- base::withVisible(base::local({
[10:26:11.250]                 b <- a
[10:26:11.250]                 a <- 2
[10:26:11.250]                 a * b
[10:26:11.250]             }))
[10:26:11.250]             future::FutureResult(value = ...future.value$value, 
[10:26:11.250]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.250]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.250]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.250]                     ...future.globalenv.names))
[10:26:11.250]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.250]         }, condition = base::local({
[10:26:11.250]             c <- base::c
[10:26:11.250]             inherits <- base::inherits
[10:26:11.250]             invokeRestart <- base::invokeRestart
[10:26:11.250]             length <- base::length
[10:26:11.250]             list <- base::list
[10:26:11.250]             seq.int <- base::seq.int
[10:26:11.250]             signalCondition <- base::signalCondition
[10:26:11.250]             sys.calls <- base::sys.calls
[10:26:11.250]             `[[` <- base::`[[`
[10:26:11.250]             `+` <- base::`+`
[10:26:11.250]             `<<-` <- base::`<<-`
[10:26:11.250]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.250]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.250]                   3L)]
[10:26:11.250]             }
[10:26:11.250]             function(cond) {
[10:26:11.250]                 is_error <- inherits(cond, "error")
[10:26:11.250]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.250]                   NULL)
[10:26:11.250]                 if (is_error) {
[10:26:11.250]                   sessionInformation <- function() {
[10:26:11.250]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.250]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.250]                       search = base::search(), system = base::Sys.info())
[10:26:11.250]                   }
[10:26:11.250]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.250]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.250]                     cond$call), session = sessionInformation(), 
[10:26:11.250]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.250]                   signalCondition(cond)
[10:26:11.250]                 }
[10:26:11.250]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.250]                 "immediateCondition"))) {
[10:26:11.250]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.250]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.250]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.250]                   if (TRUE && !signal) {
[10:26:11.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.250]                     {
[10:26:11.250]                       inherits <- base::inherits
[10:26:11.250]                       invokeRestart <- base::invokeRestart
[10:26:11.250]                       is.null <- base::is.null
[10:26:11.250]                       muffled <- FALSE
[10:26:11.250]                       if (inherits(cond, "message")) {
[10:26:11.250]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.250]                         if (muffled) 
[10:26:11.250]                           invokeRestart("muffleMessage")
[10:26:11.250]                       }
[10:26:11.250]                       else if (inherits(cond, "warning")) {
[10:26:11.250]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.250]                         if (muffled) 
[10:26:11.250]                           invokeRestart("muffleWarning")
[10:26:11.250]                       }
[10:26:11.250]                       else if (inherits(cond, "condition")) {
[10:26:11.250]                         if (!is.null(pattern)) {
[10:26:11.250]                           computeRestarts <- base::computeRestarts
[10:26:11.250]                           grepl <- base::grepl
[10:26:11.250]                           restarts <- computeRestarts(cond)
[10:26:11.250]                           for (restart in restarts) {
[10:26:11.250]                             name <- restart$name
[10:26:11.250]                             if (is.null(name)) 
[10:26:11.250]                               next
[10:26:11.250]                             if (!grepl(pattern, name)) 
[10:26:11.250]                               next
[10:26:11.250]                             invokeRestart(restart)
[10:26:11.250]                             muffled <- TRUE
[10:26:11.250]                             break
[10:26:11.250]                           }
[10:26:11.250]                         }
[10:26:11.250]                       }
[10:26:11.250]                       invisible(muffled)
[10:26:11.250]                     }
[10:26:11.250]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.250]                   }
[10:26:11.250]                 }
[10:26:11.250]                 else {
[10:26:11.250]                   if (TRUE) {
[10:26:11.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.250]                     {
[10:26:11.250]                       inherits <- base::inherits
[10:26:11.250]                       invokeRestart <- base::invokeRestart
[10:26:11.250]                       is.null <- base::is.null
[10:26:11.250]                       muffled <- FALSE
[10:26:11.250]                       if (inherits(cond, "message")) {
[10:26:11.250]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.250]                         if (muffled) 
[10:26:11.250]                           invokeRestart("muffleMessage")
[10:26:11.250]                       }
[10:26:11.250]                       else if (inherits(cond, "warning")) {
[10:26:11.250]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.250]                         if (muffled) 
[10:26:11.250]                           invokeRestart("muffleWarning")
[10:26:11.250]                       }
[10:26:11.250]                       else if (inherits(cond, "condition")) {
[10:26:11.250]                         if (!is.null(pattern)) {
[10:26:11.250]                           computeRestarts <- base::computeRestarts
[10:26:11.250]                           grepl <- base::grepl
[10:26:11.250]                           restarts <- computeRestarts(cond)
[10:26:11.250]                           for (restart in restarts) {
[10:26:11.250]                             name <- restart$name
[10:26:11.250]                             if (is.null(name)) 
[10:26:11.250]                               next
[10:26:11.250]                             if (!grepl(pattern, name)) 
[10:26:11.250]                               next
[10:26:11.250]                             invokeRestart(restart)
[10:26:11.250]                             muffled <- TRUE
[10:26:11.250]                             break
[10:26:11.250]                           }
[10:26:11.250]                         }
[10:26:11.250]                       }
[10:26:11.250]                       invisible(muffled)
[10:26:11.250]                     }
[10:26:11.250]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.250]                   }
[10:26:11.250]                 }
[10:26:11.250]             }
[10:26:11.250]         }))
[10:26:11.250]     }, error = function(ex) {
[10:26:11.250]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.250]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.250]                 ...future.rng), started = ...future.startTime, 
[10:26:11.250]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.250]             version = "1.8"), class = "FutureResult")
[10:26:11.250]     }, finally = {
[10:26:11.250]         if (!identical(...future.workdir, getwd())) 
[10:26:11.250]             setwd(...future.workdir)
[10:26:11.250]         {
[10:26:11.250]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.250]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.250]             }
[10:26:11.250]             base::options(...future.oldOptions)
[10:26:11.250]             if (.Platform$OS.type == "windows") {
[10:26:11.250]                 old_names <- names(...future.oldEnvVars)
[10:26:11.250]                 envs <- base::Sys.getenv()
[10:26:11.250]                 names <- names(envs)
[10:26:11.250]                 common <- intersect(names, old_names)
[10:26:11.250]                 added <- setdiff(names, old_names)
[10:26:11.250]                 removed <- setdiff(old_names, names)
[10:26:11.250]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.250]                   envs[common]]
[10:26:11.250]                 NAMES <- toupper(changed)
[10:26:11.250]                 args <- list()
[10:26:11.250]                 for (kk in seq_along(NAMES)) {
[10:26:11.250]                   name <- changed[[kk]]
[10:26:11.250]                   NAME <- NAMES[[kk]]
[10:26:11.250]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.250]                     next
[10:26:11.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.250]                 }
[10:26:11.250]                 NAMES <- toupper(added)
[10:26:11.250]                 for (kk in seq_along(NAMES)) {
[10:26:11.250]                   name <- added[[kk]]
[10:26:11.250]                   NAME <- NAMES[[kk]]
[10:26:11.250]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.250]                     next
[10:26:11.250]                   args[[name]] <- ""
[10:26:11.250]                 }
[10:26:11.250]                 NAMES <- toupper(removed)
[10:26:11.250]                 for (kk in seq_along(NAMES)) {
[10:26:11.250]                   name <- removed[[kk]]
[10:26:11.250]                   NAME <- NAMES[[kk]]
[10:26:11.250]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.250]                     next
[10:26:11.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.250]                 }
[10:26:11.250]                 if (length(args) > 0) 
[10:26:11.250]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.250]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.250]             }
[10:26:11.250]             else {
[10:26:11.250]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.250]             }
[10:26:11.250]             {
[10:26:11.250]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.250]                   0L) {
[10:26:11.250]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.250]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.250]                   base::options(opts)
[10:26:11.250]                 }
[10:26:11.250]                 {
[10:26:11.250]                   {
[10:26:11.250]                     NULL
[10:26:11.250]                     RNGkind("Mersenne-Twister")
[10:26:11.250]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.250]                       inherits = FALSE)
[10:26:11.250]                   }
[10:26:11.250]                   options(future.plan = NULL)
[10:26:11.250]                   if (is.na(NA_character_)) 
[10:26:11.250]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.250]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.250]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.250]                   {
[10:26:11.250]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.250]                     if (!future$lazy) 
[10:26:11.250]                       future <- run(future)
[10:26:11.250]                     invisible(future)
[10:26:11.250]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.250]                 }
[10:26:11.250]             }
[10:26:11.250]         }
[10:26:11.250]     })
[10:26:11.250]     if (TRUE) {
[10:26:11.250]         base::sink(type = "output", split = FALSE)
[10:26:11.250]         if (TRUE) {
[10:26:11.250]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.250]         }
[10:26:11.250]         else {
[10:26:11.250]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.250]         }
[10:26:11.250]         base::close(...future.stdout)
[10:26:11.250]         ...future.stdout <- NULL
[10:26:11.250]     }
[10:26:11.250]     ...future.result$conditions <- ...future.conditions
[10:26:11.250]     ...future.result$finished <- base::Sys.time()
[10:26:11.250]     ...future.result
[10:26:11.250] }
[10:26:11.252] plan(): Setting new future strategy stack:
[10:26:11.252] List of future strategies:
[10:26:11.252] 1. sequential:
[10:26:11.252]    - args: function (..., envir = parent.frame())
[10:26:11.252]    - tweaked: FALSE
[10:26:11.252]    - call: NULL
[10:26:11.252] plan(): nbrOfWorkers() = 1
[10:26:11.253] plan(): Setting new future strategy stack:
[10:26:11.253] List of future strategies:
[10:26:11.253] 1. sequential:
[10:26:11.253]    - args: function (..., envir = parent.frame())
[10:26:11.253]    - tweaked: FALSE
[10:26:11.253]    - call: plan(strategy)
[10:26:11.254] plan(): nbrOfWorkers() = 1
[10:26:11.254] SequentialFuture started (and completed)
[10:26:11.254] - Launch lazy future ... done
[10:26:11.255] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.255] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.256] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:11.257] - globals found: [3] ‘{’, ‘<-’, ‘*’
[10:26:11.257] Searching for globals ... DONE
[10:26:11.257] Resolving globals: TRUE
[10:26:11.257] Resolving any globals that are futures ...
[10:26:11.257] - globals: [3] ‘{’, ‘<-’, ‘*’
[10:26:11.257] Resolving any globals that are futures ... DONE
[10:26:11.258] 
[10:26:11.258] 
[10:26:11.258] getGlobalsAndPackages() ... DONE
[10:26:11.260] run() for ‘Future’ ...
[10:26:11.260] - state: ‘created’
[10:26:11.260] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.260] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.260] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.260]   - Field: ‘label’
[10:26:11.260]   - Field: ‘local’
[10:26:11.261]   - Field: ‘owner’
[10:26:11.261]   - Field: ‘envir’
[10:26:11.261]   - Field: ‘packages’
[10:26:11.261]   - Field: ‘gc’
[10:26:11.261]   - Field: ‘conditions’
[10:26:11.261]   - Field: ‘expr’
[10:26:11.261]   - Field: ‘uuid’
[10:26:11.261]   - Field: ‘seed’
[10:26:11.261]   - Field: ‘version’
[10:26:11.261]   - Field: ‘result’
[10:26:11.261]   - Field: ‘asynchronous’
[10:26:11.262]   - Field: ‘calls’
[10:26:11.262]   - Field: ‘globals’
[10:26:11.262]   - Field: ‘stdout’
[10:26:11.262]   - Field: ‘earlySignal’
[10:26:11.262]   - Field: ‘lazy’
[10:26:11.262]   - Field: ‘state’
[10:26:11.262] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.262] - Launch lazy future ...
[10:26:11.262] Packages needed by the future expression (n = 0): <none>
[10:26:11.262] Packages needed by future strategies (n = 0): <none>
[10:26:11.263] {
[10:26:11.263]     {
[10:26:11.263]         {
[10:26:11.263]             ...future.startTime <- base::Sys.time()
[10:26:11.263]             {
[10:26:11.263]                 {
[10:26:11.263]                   {
[10:26:11.263]                     base::local({
[10:26:11.263]                       has_future <- base::requireNamespace("future", 
[10:26:11.263]                         quietly = TRUE)
[10:26:11.263]                       if (has_future) {
[10:26:11.263]                         ns <- base::getNamespace("future")
[10:26:11.263]                         version <- ns[[".package"]][["version"]]
[10:26:11.263]                         if (is.null(version)) 
[10:26:11.263]                           version <- utils::packageVersion("future")
[10:26:11.263]                       }
[10:26:11.263]                       else {
[10:26:11.263]                         version <- NULL
[10:26:11.263]                       }
[10:26:11.263]                       if (!has_future || version < "1.8.0") {
[10:26:11.263]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.263]                           "", base::R.version$version.string), 
[10:26:11.263]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.263]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.263]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.263]                             "release", "version")], collapse = " "), 
[10:26:11.263]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.263]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.263]                           info)
[10:26:11.263]                         info <- base::paste(info, collapse = "; ")
[10:26:11.263]                         if (!has_future) {
[10:26:11.263]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.263]                             info)
[10:26:11.263]                         }
[10:26:11.263]                         else {
[10:26:11.263]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.263]                             info, version)
[10:26:11.263]                         }
[10:26:11.263]                         base::stop(msg)
[10:26:11.263]                       }
[10:26:11.263]                     })
[10:26:11.263]                   }
[10:26:11.263]                   options(future.plan = NULL)
[10:26:11.263]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.263]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.263]                 }
[10:26:11.263]                 ...future.workdir <- getwd()
[10:26:11.263]             }
[10:26:11.263]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.263]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.263]         }
[10:26:11.263]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.263]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:11.263]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.263]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.263]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.263]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.263]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.263]             base::names(...future.oldOptions))
[10:26:11.263]     }
[10:26:11.263]     if (FALSE) {
[10:26:11.263]     }
[10:26:11.263]     else {
[10:26:11.263]         if (TRUE) {
[10:26:11.263]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.263]                 open = "w")
[10:26:11.263]         }
[10:26:11.263]         else {
[10:26:11.263]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.263]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.263]         }
[10:26:11.263]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.263]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.263]             base::sink(type = "output", split = FALSE)
[10:26:11.263]             base::close(...future.stdout)
[10:26:11.263]         }, add = TRUE)
[10:26:11.263]     }
[10:26:11.263]     ...future.frame <- base::sys.nframe()
[10:26:11.263]     ...future.conditions <- base::list()
[10:26:11.263]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.263]     if (FALSE) {
[10:26:11.263]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.263]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.263]     }
[10:26:11.263]     ...future.result <- base::tryCatch({
[10:26:11.263]         base::withCallingHandlers({
[10:26:11.263]             ...future.value <- base::withVisible(base::local({
[10:26:11.263]                 b <- a
[10:26:11.263]                 a <- 2
[10:26:11.263]                 a * b
[10:26:11.263]             }))
[10:26:11.263]             future::FutureResult(value = ...future.value$value, 
[10:26:11.263]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.263]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.263]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.263]                     ...future.globalenv.names))
[10:26:11.263]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.263]         }, condition = base::local({
[10:26:11.263]             c <- base::c
[10:26:11.263]             inherits <- base::inherits
[10:26:11.263]             invokeRestart <- base::invokeRestart
[10:26:11.263]             length <- base::length
[10:26:11.263]             list <- base::list
[10:26:11.263]             seq.int <- base::seq.int
[10:26:11.263]             signalCondition <- base::signalCondition
[10:26:11.263]             sys.calls <- base::sys.calls
[10:26:11.263]             `[[` <- base::`[[`
[10:26:11.263]             `+` <- base::`+`
[10:26:11.263]             `<<-` <- base::`<<-`
[10:26:11.263]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.263]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.263]                   3L)]
[10:26:11.263]             }
[10:26:11.263]             function(cond) {
[10:26:11.263]                 is_error <- inherits(cond, "error")
[10:26:11.263]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.263]                   NULL)
[10:26:11.263]                 if (is_error) {
[10:26:11.263]                   sessionInformation <- function() {
[10:26:11.263]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.263]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.263]                       search = base::search(), system = base::Sys.info())
[10:26:11.263]                   }
[10:26:11.263]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.263]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.263]                     cond$call), session = sessionInformation(), 
[10:26:11.263]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.263]                   signalCondition(cond)
[10:26:11.263]                 }
[10:26:11.263]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.263]                 "immediateCondition"))) {
[10:26:11.263]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.263]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.263]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.263]                   if (TRUE && !signal) {
[10:26:11.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.263]                     {
[10:26:11.263]                       inherits <- base::inherits
[10:26:11.263]                       invokeRestart <- base::invokeRestart
[10:26:11.263]                       is.null <- base::is.null
[10:26:11.263]                       muffled <- FALSE
[10:26:11.263]                       if (inherits(cond, "message")) {
[10:26:11.263]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.263]                         if (muffled) 
[10:26:11.263]                           invokeRestart("muffleMessage")
[10:26:11.263]                       }
[10:26:11.263]                       else if (inherits(cond, "warning")) {
[10:26:11.263]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.263]                         if (muffled) 
[10:26:11.263]                           invokeRestart("muffleWarning")
[10:26:11.263]                       }
[10:26:11.263]                       else if (inherits(cond, "condition")) {
[10:26:11.263]                         if (!is.null(pattern)) {
[10:26:11.263]                           computeRestarts <- base::computeRestarts
[10:26:11.263]                           grepl <- base::grepl
[10:26:11.263]                           restarts <- computeRestarts(cond)
[10:26:11.263]                           for (restart in restarts) {
[10:26:11.263]                             name <- restart$name
[10:26:11.263]                             if (is.null(name)) 
[10:26:11.263]                               next
[10:26:11.263]                             if (!grepl(pattern, name)) 
[10:26:11.263]                               next
[10:26:11.263]                             invokeRestart(restart)
[10:26:11.263]                             muffled <- TRUE
[10:26:11.263]                             break
[10:26:11.263]                           }
[10:26:11.263]                         }
[10:26:11.263]                       }
[10:26:11.263]                       invisible(muffled)
[10:26:11.263]                     }
[10:26:11.263]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.263]                   }
[10:26:11.263]                 }
[10:26:11.263]                 else {
[10:26:11.263]                   if (TRUE) {
[10:26:11.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.263]                     {
[10:26:11.263]                       inherits <- base::inherits
[10:26:11.263]                       invokeRestart <- base::invokeRestart
[10:26:11.263]                       is.null <- base::is.null
[10:26:11.263]                       muffled <- FALSE
[10:26:11.263]                       if (inherits(cond, "message")) {
[10:26:11.263]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.263]                         if (muffled) 
[10:26:11.263]                           invokeRestart("muffleMessage")
[10:26:11.263]                       }
[10:26:11.263]                       else if (inherits(cond, "warning")) {
[10:26:11.263]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.263]                         if (muffled) 
[10:26:11.263]                           invokeRestart("muffleWarning")
[10:26:11.263]                       }
[10:26:11.263]                       else if (inherits(cond, "condition")) {
[10:26:11.263]                         if (!is.null(pattern)) {
[10:26:11.263]                           computeRestarts <- base::computeRestarts
[10:26:11.263]                           grepl <- base::grepl
[10:26:11.263]                           restarts <- computeRestarts(cond)
[10:26:11.263]                           for (restart in restarts) {
[10:26:11.263]                             name <- restart$name
[10:26:11.263]                             if (is.null(name)) 
[10:26:11.263]                               next
[10:26:11.263]                             if (!grepl(pattern, name)) 
[10:26:11.263]                               next
[10:26:11.263]                             invokeRestart(restart)
[10:26:11.263]                             muffled <- TRUE
[10:26:11.263]                             break
[10:26:11.263]                           }
[10:26:11.263]                         }
[10:26:11.263]                       }
[10:26:11.263]                       invisible(muffled)
[10:26:11.263]                     }
[10:26:11.263]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.263]                   }
[10:26:11.263]                 }
[10:26:11.263]             }
[10:26:11.263]         }))
[10:26:11.263]     }, error = function(ex) {
[10:26:11.263]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.263]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.263]                 ...future.rng), started = ...future.startTime, 
[10:26:11.263]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.263]             version = "1.8"), class = "FutureResult")
[10:26:11.263]     }, finally = {
[10:26:11.263]         if (!identical(...future.workdir, getwd())) 
[10:26:11.263]             setwd(...future.workdir)
[10:26:11.263]         {
[10:26:11.263]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.263]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.263]             }
[10:26:11.263]             base::options(...future.oldOptions)
[10:26:11.263]             if (.Platform$OS.type == "windows") {
[10:26:11.263]                 old_names <- names(...future.oldEnvVars)
[10:26:11.263]                 envs <- base::Sys.getenv()
[10:26:11.263]                 names <- names(envs)
[10:26:11.263]                 common <- intersect(names, old_names)
[10:26:11.263]                 added <- setdiff(names, old_names)
[10:26:11.263]                 removed <- setdiff(old_names, names)
[10:26:11.263]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.263]                   envs[common]]
[10:26:11.263]                 NAMES <- toupper(changed)
[10:26:11.263]                 args <- list()
[10:26:11.263]                 for (kk in seq_along(NAMES)) {
[10:26:11.263]                   name <- changed[[kk]]
[10:26:11.263]                   NAME <- NAMES[[kk]]
[10:26:11.263]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.263]                     next
[10:26:11.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.263]                 }
[10:26:11.263]                 NAMES <- toupper(added)
[10:26:11.263]                 for (kk in seq_along(NAMES)) {
[10:26:11.263]                   name <- added[[kk]]
[10:26:11.263]                   NAME <- NAMES[[kk]]
[10:26:11.263]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.263]                     next
[10:26:11.263]                   args[[name]] <- ""
[10:26:11.263]                 }
[10:26:11.263]                 NAMES <- toupper(removed)
[10:26:11.263]                 for (kk in seq_along(NAMES)) {
[10:26:11.263]                   name <- removed[[kk]]
[10:26:11.263]                   NAME <- NAMES[[kk]]
[10:26:11.263]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.263]                     next
[10:26:11.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.263]                 }
[10:26:11.263]                 if (length(args) > 0) 
[10:26:11.263]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.263]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.263]             }
[10:26:11.263]             else {
[10:26:11.263]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.263]             }
[10:26:11.263]             {
[10:26:11.263]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.263]                   0L) {
[10:26:11.263]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.263]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.263]                   base::options(opts)
[10:26:11.263]                 }
[10:26:11.263]                 {
[10:26:11.263]                   {
[10:26:11.263]                     NULL
[10:26:11.263]                     RNGkind("Mersenne-Twister")
[10:26:11.263]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.263]                       inherits = FALSE)
[10:26:11.263]                   }
[10:26:11.263]                   options(future.plan = NULL)
[10:26:11.263]                   if (is.na(NA_character_)) 
[10:26:11.263]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.263]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.263]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.263]                   {
[10:26:11.263]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.263]                     if (!future$lazy) 
[10:26:11.263]                       future <- run(future)
[10:26:11.263]                     invisible(future)
[10:26:11.263]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.263]                 }
[10:26:11.263]             }
[10:26:11.263]         }
[10:26:11.263]     })
[10:26:11.263]     if (TRUE) {
[10:26:11.263]         base::sink(type = "output", split = FALSE)
[10:26:11.263]         if (TRUE) {
[10:26:11.263]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.263]         }
[10:26:11.263]         else {
[10:26:11.263]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.263]         }
[10:26:11.263]         base::close(...future.stdout)
[10:26:11.263]         ...future.stdout <- NULL
[10:26:11.263]     }
[10:26:11.263]     ...future.result$conditions <- ...future.conditions
[10:26:11.263]     ...future.result$finished <- base::Sys.time()
[10:26:11.263]     ...future.result
[10:26:11.263] }
[10:26:11.265] plan(): Setting new future strategy stack:
[10:26:11.265] List of future strategies:
[10:26:11.265] 1. sequential:
[10:26:11.265]    - args: function (..., envir = parent.frame())
[10:26:11.265]    - tweaked: FALSE
[10:26:11.265]    - call: NULL
[10:26:11.265] plan(): nbrOfWorkers() = 1
[10:26:11.266] plan(): Setting new future strategy stack:
[10:26:11.266] List of future strategies:
[10:26:11.266] 1. sequential:
[10:26:11.266]    - args: function (..., envir = parent.frame())
[10:26:11.266]    - tweaked: FALSE
[10:26:11.266]    - call: plan(strategy)
[10:26:11.266] plan(): nbrOfWorkers() = 1
[10:26:11.266] SequentialFuture started (and completed)
[10:26:11.267] signalConditions() ...
[10:26:11.267]  - include = ‘immediateCondition’
[10:26:11.267]  - exclude = 
[10:26:11.267]  - resignal = FALSE
[10:26:11.267]  - Number of conditions: 1
[10:26:11.267] signalConditions() ... done
[10:26:11.267] - Launch lazy future ... done
[10:26:11.267] run() for ‘SequentialFuture’ ... done
[10:26:11.267] signalConditions() ...
[10:26:11.267]  - include = ‘immediateCondition’
[10:26:11.267]  - exclude = 
[10:26:11.268]  - resignal = FALSE
[10:26:11.268]  - Number of conditions: 1
[10:26:11.268] signalConditions() ... done
[10:26:11.268] Future state: ‘finished’
[10:26:11.268] signalConditions() ...
[10:26:11.268]  - include = ‘condition’
[10:26:11.268]  - exclude = ‘immediateCondition’
[10:26:11.268]  - resignal = TRUE
[10:26:11.268]  - Number of conditions: 1
[10:26:11.268]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:26:11.268] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3e863ac79bce" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 10:26:11"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.284] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.284] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:11.286] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:11.286] Searching for globals ... DONE
[10:26:11.286] Resolving globals: TRUE
[10:26:11.286] Resolving any globals that are futures ...
[10:26:11.286] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:11.286] Resolving any globals that are futures ... DONE
[10:26:11.286] Resolving futures part of globals (recursively) ...
[10:26:11.288] resolve() on list ...
[10:26:11.288]  recursive: 99
[10:26:11.289]  length: 1
[10:26:11.289]  elements: ‘ii’
[10:26:11.289]  length: 0 (resolved future 1)
[10:26:11.289] resolve() on list ... DONE
[10:26:11.289] - globals: [1] ‘ii’
[10:26:11.289] Resolving futures part of globals (recursively) ... DONE
[10:26:11.290] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:11.290] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:11.290] - globals: [1] ‘ii’
[10:26:11.290] 
[10:26:11.290] getGlobalsAndPackages() ... DONE
[10:26:11.291] run() for ‘Future’ ...
[10:26:11.291] - state: ‘created’
[10:26:11.291] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.291] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.291] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.291]   - Field: ‘label’
[10:26:11.291]   - Field: ‘local’
[10:26:11.292]   - Field: ‘owner’
[10:26:11.292]   - Field: ‘envir’
[10:26:11.292]   - Field: ‘packages’
[10:26:11.292]   - Field: ‘gc’
[10:26:11.292]   - Field: ‘conditions’
[10:26:11.292]   - Field: ‘expr’
[10:26:11.292]   - Field: ‘uuid’
[10:26:11.292]   - Field: ‘seed’
[10:26:11.292]   - Field: ‘version’
[10:26:11.292]   - Field: ‘result’
[10:26:11.292]   - Field: ‘asynchronous’
[10:26:11.293]   - Field: ‘calls’
[10:26:11.293]   - Field: ‘globals’
[10:26:11.293]   - Field: ‘stdout’
[10:26:11.293]   - Field: ‘earlySignal’
[10:26:11.293]   - Field: ‘lazy’
[10:26:11.293]   - Field: ‘state’
[10:26:11.293] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.293] - Launch lazy future ...
[10:26:11.293] Packages needed by the future expression (n = 0): <none>
[10:26:11.293] Packages needed by future strategies (n = 0): <none>
[10:26:11.294] {
[10:26:11.294]     {
[10:26:11.294]         {
[10:26:11.294]             ...future.startTime <- base::Sys.time()
[10:26:11.294]             {
[10:26:11.294]                 {
[10:26:11.294]                   {
[10:26:11.294]                     base::local({
[10:26:11.294]                       has_future <- base::requireNamespace("future", 
[10:26:11.294]                         quietly = TRUE)
[10:26:11.294]                       if (has_future) {
[10:26:11.294]                         ns <- base::getNamespace("future")
[10:26:11.294]                         version <- ns[[".package"]][["version"]]
[10:26:11.294]                         if (is.null(version)) 
[10:26:11.294]                           version <- utils::packageVersion("future")
[10:26:11.294]                       }
[10:26:11.294]                       else {
[10:26:11.294]                         version <- NULL
[10:26:11.294]                       }
[10:26:11.294]                       if (!has_future || version < "1.8.0") {
[10:26:11.294]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.294]                           "", base::R.version$version.string), 
[10:26:11.294]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.294]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.294]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.294]                             "release", "version")], collapse = " "), 
[10:26:11.294]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.294]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.294]                           info)
[10:26:11.294]                         info <- base::paste(info, collapse = "; ")
[10:26:11.294]                         if (!has_future) {
[10:26:11.294]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.294]                             info)
[10:26:11.294]                         }
[10:26:11.294]                         else {
[10:26:11.294]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.294]                             info, version)
[10:26:11.294]                         }
[10:26:11.294]                         base::stop(msg)
[10:26:11.294]                       }
[10:26:11.294]                     })
[10:26:11.294]                   }
[10:26:11.294]                   options(future.plan = NULL)
[10:26:11.294]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.294]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.294]                 }
[10:26:11.294]                 ...future.workdir <- getwd()
[10:26:11.294]             }
[10:26:11.294]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.294]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.294]         }
[10:26:11.294]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.294]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:11.294]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.294]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.294]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.294]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.294]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.294]             base::names(...future.oldOptions))
[10:26:11.294]     }
[10:26:11.294]     if (FALSE) {
[10:26:11.294]     }
[10:26:11.294]     else {
[10:26:11.294]         if (TRUE) {
[10:26:11.294]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.294]                 open = "w")
[10:26:11.294]         }
[10:26:11.294]         else {
[10:26:11.294]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.294]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.294]         }
[10:26:11.294]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.294]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.294]             base::sink(type = "output", split = FALSE)
[10:26:11.294]             base::close(...future.stdout)
[10:26:11.294]         }, add = TRUE)
[10:26:11.294]     }
[10:26:11.294]     ...future.frame <- base::sys.nframe()
[10:26:11.294]     ...future.conditions <- base::list()
[10:26:11.294]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.294]     if (FALSE) {
[10:26:11.294]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.294]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.294]     }
[10:26:11.294]     ...future.result <- base::tryCatch({
[10:26:11.294]         base::withCallingHandlers({
[10:26:11.294]             ...future.value <- base::withVisible(base::local({
[10:26:11.294]                 b <- a * ii
[10:26:11.294]                 a <- 0
[10:26:11.294]                 b
[10:26:11.294]             }))
[10:26:11.294]             future::FutureResult(value = ...future.value$value, 
[10:26:11.294]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.294]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.294]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.294]                     ...future.globalenv.names))
[10:26:11.294]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.294]         }, condition = base::local({
[10:26:11.294]             c <- base::c
[10:26:11.294]             inherits <- base::inherits
[10:26:11.294]             invokeRestart <- base::invokeRestart
[10:26:11.294]             length <- base::length
[10:26:11.294]             list <- base::list
[10:26:11.294]             seq.int <- base::seq.int
[10:26:11.294]             signalCondition <- base::signalCondition
[10:26:11.294]             sys.calls <- base::sys.calls
[10:26:11.294]             `[[` <- base::`[[`
[10:26:11.294]             `+` <- base::`+`
[10:26:11.294]             `<<-` <- base::`<<-`
[10:26:11.294]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.294]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.294]                   3L)]
[10:26:11.294]             }
[10:26:11.294]             function(cond) {
[10:26:11.294]                 is_error <- inherits(cond, "error")
[10:26:11.294]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.294]                   NULL)
[10:26:11.294]                 if (is_error) {
[10:26:11.294]                   sessionInformation <- function() {
[10:26:11.294]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.294]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.294]                       search = base::search(), system = base::Sys.info())
[10:26:11.294]                   }
[10:26:11.294]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.294]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.294]                     cond$call), session = sessionInformation(), 
[10:26:11.294]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.294]                   signalCondition(cond)
[10:26:11.294]                 }
[10:26:11.294]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.294]                 "immediateCondition"))) {
[10:26:11.294]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.294]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.294]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.294]                   if (TRUE && !signal) {
[10:26:11.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.294]                     {
[10:26:11.294]                       inherits <- base::inherits
[10:26:11.294]                       invokeRestart <- base::invokeRestart
[10:26:11.294]                       is.null <- base::is.null
[10:26:11.294]                       muffled <- FALSE
[10:26:11.294]                       if (inherits(cond, "message")) {
[10:26:11.294]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.294]                         if (muffled) 
[10:26:11.294]                           invokeRestart("muffleMessage")
[10:26:11.294]                       }
[10:26:11.294]                       else if (inherits(cond, "warning")) {
[10:26:11.294]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.294]                         if (muffled) 
[10:26:11.294]                           invokeRestart("muffleWarning")
[10:26:11.294]                       }
[10:26:11.294]                       else if (inherits(cond, "condition")) {
[10:26:11.294]                         if (!is.null(pattern)) {
[10:26:11.294]                           computeRestarts <- base::computeRestarts
[10:26:11.294]                           grepl <- base::grepl
[10:26:11.294]                           restarts <- computeRestarts(cond)
[10:26:11.294]                           for (restart in restarts) {
[10:26:11.294]                             name <- restart$name
[10:26:11.294]                             if (is.null(name)) 
[10:26:11.294]                               next
[10:26:11.294]                             if (!grepl(pattern, name)) 
[10:26:11.294]                               next
[10:26:11.294]                             invokeRestart(restart)
[10:26:11.294]                             muffled <- TRUE
[10:26:11.294]                             break
[10:26:11.294]                           }
[10:26:11.294]                         }
[10:26:11.294]                       }
[10:26:11.294]                       invisible(muffled)
[10:26:11.294]                     }
[10:26:11.294]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.294]                   }
[10:26:11.294]                 }
[10:26:11.294]                 else {
[10:26:11.294]                   if (TRUE) {
[10:26:11.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.294]                     {
[10:26:11.294]                       inherits <- base::inherits
[10:26:11.294]                       invokeRestart <- base::invokeRestart
[10:26:11.294]                       is.null <- base::is.null
[10:26:11.294]                       muffled <- FALSE
[10:26:11.294]                       if (inherits(cond, "message")) {
[10:26:11.294]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.294]                         if (muffled) 
[10:26:11.294]                           invokeRestart("muffleMessage")
[10:26:11.294]                       }
[10:26:11.294]                       else if (inherits(cond, "warning")) {
[10:26:11.294]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.294]                         if (muffled) 
[10:26:11.294]                           invokeRestart("muffleWarning")
[10:26:11.294]                       }
[10:26:11.294]                       else if (inherits(cond, "condition")) {
[10:26:11.294]                         if (!is.null(pattern)) {
[10:26:11.294]                           computeRestarts <- base::computeRestarts
[10:26:11.294]                           grepl <- base::grepl
[10:26:11.294]                           restarts <- computeRestarts(cond)
[10:26:11.294]                           for (restart in restarts) {
[10:26:11.294]                             name <- restart$name
[10:26:11.294]                             if (is.null(name)) 
[10:26:11.294]                               next
[10:26:11.294]                             if (!grepl(pattern, name)) 
[10:26:11.294]                               next
[10:26:11.294]                             invokeRestart(restart)
[10:26:11.294]                             muffled <- TRUE
[10:26:11.294]                             break
[10:26:11.294]                           }
[10:26:11.294]                         }
[10:26:11.294]                       }
[10:26:11.294]                       invisible(muffled)
[10:26:11.294]                     }
[10:26:11.294]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.294]                   }
[10:26:11.294]                 }
[10:26:11.294]             }
[10:26:11.294]         }))
[10:26:11.294]     }, error = function(ex) {
[10:26:11.294]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.294]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.294]                 ...future.rng), started = ...future.startTime, 
[10:26:11.294]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.294]             version = "1.8"), class = "FutureResult")
[10:26:11.294]     }, finally = {
[10:26:11.294]         if (!identical(...future.workdir, getwd())) 
[10:26:11.294]             setwd(...future.workdir)
[10:26:11.294]         {
[10:26:11.294]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.294]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.294]             }
[10:26:11.294]             base::options(...future.oldOptions)
[10:26:11.294]             if (.Platform$OS.type == "windows") {
[10:26:11.294]                 old_names <- names(...future.oldEnvVars)
[10:26:11.294]                 envs <- base::Sys.getenv()
[10:26:11.294]                 names <- names(envs)
[10:26:11.294]                 common <- intersect(names, old_names)
[10:26:11.294]                 added <- setdiff(names, old_names)
[10:26:11.294]                 removed <- setdiff(old_names, names)
[10:26:11.294]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.294]                   envs[common]]
[10:26:11.294]                 NAMES <- toupper(changed)
[10:26:11.294]                 args <- list()
[10:26:11.294]                 for (kk in seq_along(NAMES)) {
[10:26:11.294]                   name <- changed[[kk]]
[10:26:11.294]                   NAME <- NAMES[[kk]]
[10:26:11.294]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.294]                     next
[10:26:11.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.294]                 }
[10:26:11.294]                 NAMES <- toupper(added)
[10:26:11.294]                 for (kk in seq_along(NAMES)) {
[10:26:11.294]                   name <- added[[kk]]
[10:26:11.294]                   NAME <- NAMES[[kk]]
[10:26:11.294]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.294]                     next
[10:26:11.294]                   args[[name]] <- ""
[10:26:11.294]                 }
[10:26:11.294]                 NAMES <- toupper(removed)
[10:26:11.294]                 for (kk in seq_along(NAMES)) {
[10:26:11.294]                   name <- removed[[kk]]
[10:26:11.294]                   NAME <- NAMES[[kk]]
[10:26:11.294]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.294]                     next
[10:26:11.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.294]                 }
[10:26:11.294]                 if (length(args) > 0) 
[10:26:11.294]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.294]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.294]             }
[10:26:11.294]             else {
[10:26:11.294]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.294]             }
[10:26:11.294]             {
[10:26:11.294]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.294]                   0L) {
[10:26:11.294]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.294]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.294]                   base::options(opts)
[10:26:11.294]                 }
[10:26:11.294]                 {
[10:26:11.294]                   {
[10:26:11.294]                     NULL
[10:26:11.294]                     RNGkind("Mersenne-Twister")
[10:26:11.294]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.294]                       inherits = FALSE)
[10:26:11.294]                   }
[10:26:11.294]                   options(future.plan = NULL)
[10:26:11.294]                   if (is.na(NA_character_)) 
[10:26:11.294]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.294]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.294]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.294]                   {
[10:26:11.294]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.294]                     if (!future$lazy) 
[10:26:11.294]                       future <- run(future)
[10:26:11.294]                     invisible(future)
[10:26:11.294]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.294]                 }
[10:26:11.294]             }
[10:26:11.294]         }
[10:26:11.294]     })
[10:26:11.294]     if (TRUE) {
[10:26:11.294]         base::sink(type = "output", split = FALSE)
[10:26:11.294]         if (TRUE) {
[10:26:11.294]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.294]         }
[10:26:11.294]         else {
[10:26:11.294]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.294]         }
[10:26:11.294]         base::close(...future.stdout)
[10:26:11.294]         ...future.stdout <- NULL
[10:26:11.294]     }
[10:26:11.294]     ...future.result$conditions <- ...future.conditions
[10:26:11.294]     ...future.result$finished <- base::Sys.time()
[10:26:11.294]     ...future.result
[10:26:11.294] }
[10:26:11.295] assign_globals() ...
[10:26:11.296] List of 1
[10:26:11.296]  $ ii: int 1
[10:26:11.296]  - attr(*, "where")=List of 1
[10:26:11.296]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:11.296]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.296]  - attr(*, "resolved")= logi TRUE
[10:26:11.296]  - attr(*, "total_size")= num 56
[10:26:11.296]  - attr(*, "already-done")= logi TRUE
[10:26:11.298] - copied ‘ii’ to environment
[10:26:11.298] assign_globals() ... done
[10:26:11.298] plan(): Setting new future strategy stack:
[10:26:11.298] List of future strategies:
[10:26:11.298] 1. sequential:
[10:26:11.298]    - args: function (..., envir = parent.frame())
[10:26:11.298]    - tweaked: FALSE
[10:26:11.298]    - call: NULL
[10:26:11.299] plan(): nbrOfWorkers() = 1
[10:26:11.299] plan(): Setting new future strategy stack:
[10:26:11.299] List of future strategies:
[10:26:11.299] 1. sequential:
[10:26:11.299]    - args: function (..., envir = parent.frame())
[10:26:11.299]    - tweaked: FALSE
[10:26:11.299]    - call: plan(strategy)
[10:26:11.300] plan(): nbrOfWorkers() = 1
[10:26:11.300] SequentialFuture started (and completed)
[10:26:11.300] - Launch lazy future ... done
[10:26:11.300] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.300] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.301] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:11.302] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:11.302] Searching for globals ... DONE
[10:26:11.302] Resolving globals: TRUE
[10:26:11.302] Resolving any globals that are futures ...
[10:26:11.302] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:11.302] Resolving any globals that are futures ... DONE
[10:26:11.303] Resolving futures part of globals (recursively) ...
[10:26:11.303] resolve() on list ...
[10:26:11.303]  recursive: 99
[10:26:11.303]  length: 1
[10:26:11.303]  elements: ‘ii’
[10:26:11.303]  length: 0 (resolved future 1)
[10:26:11.303] resolve() on list ... DONE
[10:26:11.303] - globals: [1] ‘ii’
[10:26:11.303] Resolving futures part of globals (recursively) ... DONE
[10:26:11.304] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:11.304] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:11.304] - globals: [1] ‘ii’
[10:26:11.304] 
[10:26:11.304] getGlobalsAndPackages() ... DONE
[10:26:11.304] run() for ‘Future’ ...
[10:26:11.305] - state: ‘created’
[10:26:11.305] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.305] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.305] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.305]   - Field: ‘label’
[10:26:11.305]   - Field: ‘local’
[10:26:11.305]   - Field: ‘owner’
[10:26:11.305]   - Field: ‘envir’
[10:26:11.305]   - Field: ‘packages’
[10:26:11.306]   - Field: ‘gc’
[10:26:11.306]   - Field: ‘conditions’
[10:26:11.306]   - Field: ‘expr’
[10:26:11.306]   - Field: ‘uuid’
[10:26:11.306]   - Field: ‘seed’
[10:26:11.306]   - Field: ‘version’
[10:26:11.306]   - Field: ‘result’
[10:26:11.306]   - Field: ‘asynchronous’
[10:26:11.306]   - Field: ‘calls’
[10:26:11.306]   - Field: ‘globals’
[10:26:11.306]   - Field: ‘stdout’
[10:26:11.306]   - Field: ‘earlySignal’
[10:26:11.307]   - Field: ‘lazy’
[10:26:11.307]   - Field: ‘state’
[10:26:11.307] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.307] - Launch lazy future ...
[10:26:11.307] Packages needed by the future expression (n = 0): <none>
[10:26:11.307] Packages needed by future strategies (n = 0): <none>
[10:26:11.307] {
[10:26:11.307]     {
[10:26:11.307]         {
[10:26:11.307]             ...future.startTime <- base::Sys.time()
[10:26:11.307]             {
[10:26:11.307]                 {
[10:26:11.307]                   {
[10:26:11.307]                     base::local({
[10:26:11.307]                       has_future <- base::requireNamespace("future", 
[10:26:11.307]                         quietly = TRUE)
[10:26:11.307]                       if (has_future) {
[10:26:11.307]                         ns <- base::getNamespace("future")
[10:26:11.307]                         version <- ns[[".package"]][["version"]]
[10:26:11.307]                         if (is.null(version)) 
[10:26:11.307]                           version <- utils::packageVersion("future")
[10:26:11.307]                       }
[10:26:11.307]                       else {
[10:26:11.307]                         version <- NULL
[10:26:11.307]                       }
[10:26:11.307]                       if (!has_future || version < "1.8.0") {
[10:26:11.307]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.307]                           "", base::R.version$version.string), 
[10:26:11.307]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.307]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.307]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.307]                             "release", "version")], collapse = " "), 
[10:26:11.307]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.307]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.307]                           info)
[10:26:11.307]                         info <- base::paste(info, collapse = "; ")
[10:26:11.307]                         if (!has_future) {
[10:26:11.307]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.307]                             info)
[10:26:11.307]                         }
[10:26:11.307]                         else {
[10:26:11.307]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.307]                             info, version)
[10:26:11.307]                         }
[10:26:11.307]                         base::stop(msg)
[10:26:11.307]                       }
[10:26:11.307]                     })
[10:26:11.307]                   }
[10:26:11.307]                   options(future.plan = NULL)
[10:26:11.307]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.307]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.307]                 }
[10:26:11.307]                 ...future.workdir <- getwd()
[10:26:11.307]             }
[10:26:11.307]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.307]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.307]         }
[10:26:11.307]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.307]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:11.307]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.307]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.307]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.307]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.307]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.307]             base::names(...future.oldOptions))
[10:26:11.307]     }
[10:26:11.307]     if (FALSE) {
[10:26:11.307]     }
[10:26:11.307]     else {
[10:26:11.307]         if (TRUE) {
[10:26:11.307]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.307]                 open = "w")
[10:26:11.307]         }
[10:26:11.307]         else {
[10:26:11.307]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.307]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.307]         }
[10:26:11.307]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.307]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.307]             base::sink(type = "output", split = FALSE)
[10:26:11.307]             base::close(...future.stdout)
[10:26:11.307]         }, add = TRUE)
[10:26:11.307]     }
[10:26:11.307]     ...future.frame <- base::sys.nframe()
[10:26:11.307]     ...future.conditions <- base::list()
[10:26:11.307]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.307]     if (FALSE) {
[10:26:11.307]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.307]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.307]     }
[10:26:11.307]     ...future.result <- base::tryCatch({
[10:26:11.307]         base::withCallingHandlers({
[10:26:11.307]             ...future.value <- base::withVisible(base::local({
[10:26:11.307]                 b <- a * ii
[10:26:11.307]                 a <- 0
[10:26:11.307]                 b
[10:26:11.307]             }))
[10:26:11.307]             future::FutureResult(value = ...future.value$value, 
[10:26:11.307]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.307]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.307]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.307]                     ...future.globalenv.names))
[10:26:11.307]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.307]         }, condition = base::local({
[10:26:11.307]             c <- base::c
[10:26:11.307]             inherits <- base::inherits
[10:26:11.307]             invokeRestart <- base::invokeRestart
[10:26:11.307]             length <- base::length
[10:26:11.307]             list <- base::list
[10:26:11.307]             seq.int <- base::seq.int
[10:26:11.307]             signalCondition <- base::signalCondition
[10:26:11.307]             sys.calls <- base::sys.calls
[10:26:11.307]             `[[` <- base::`[[`
[10:26:11.307]             `+` <- base::`+`
[10:26:11.307]             `<<-` <- base::`<<-`
[10:26:11.307]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.307]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.307]                   3L)]
[10:26:11.307]             }
[10:26:11.307]             function(cond) {
[10:26:11.307]                 is_error <- inherits(cond, "error")
[10:26:11.307]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.307]                   NULL)
[10:26:11.307]                 if (is_error) {
[10:26:11.307]                   sessionInformation <- function() {
[10:26:11.307]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.307]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.307]                       search = base::search(), system = base::Sys.info())
[10:26:11.307]                   }
[10:26:11.307]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.307]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.307]                     cond$call), session = sessionInformation(), 
[10:26:11.307]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.307]                   signalCondition(cond)
[10:26:11.307]                 }
[10:26:11.307]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.307]                 "immediateCondition"))) {
[10:26:11.307]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.307]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.307]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.307]                   if (TRUE && !signal) {
[10:26:11.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.307]                     {
[10:26:11.307]                       inherits <- base::inherits
[10:26:11.307]                       invokeRestart <- base::invokeRestart
[10:26:11.307]                       is.null <- base::is.null
[10:26:11.307]                       muffled <- FALSE
[10:26:11.307]                       if (inherits(cond, "message")) {
[10:26:11.307]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.307]                         if (muffled) 
[10:26:11.307]                           invokeRestart("muffleMessage")
[10:26:11.307]                       }
[10:26:11.307]                       else if (inherits(cond, "warning")) {
[10:26:11.307]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.307]                         if (muffled) 
[10:26:11.307]                           invokeRestart("muffleWarning")
[10:26:11.307]                       }
[10:26:11.307]                       else if (inherits(cond, "condition")) {
[10:26:11.307]                         if (!is.null(pattern)) {
[10:26:11.307]                           computeRestarts <- base::computeRestarts
[10:26:11.307]                           grepl <- base::grepl
[10:26:11.307]                           restarts <- computeRestarts(cond)
[10:26:11.307]                           for (restart in restarts) {
[10:26:11.307]                             name <- restart$name
[10:26:11.307]                             if (is.null(name)) 
[10:26:11.307]                               next
[10:26:11.307]                             if (!grepl(pattern, name)) 
[10:26:11.307]                               next
[10:26:11.307]                             invokeRestart(restart)
[10:26:11.307]                             muffled <- TRUE
[10:26:11.307]                             break
[10:26:11.307]                           }
[10:26:11.307]                         }
[10:26:11.307]                       }
[10:26:11.307]                       invisible(muffled)
[10:26:11.307]                     }
[10:26:11.307]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.307]                   }
[10:26:11.307]                 }
[10:26:11.307]                 else {
[10:26:11.307]                   if (TRUE) {
[10:26:11.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.307]                     {
[10:26:11.307]                       inherits <- base::inherits
[10:26:11.307]                       invokeRestart <- base::invokeRestart
[10:26:11.307]                       is.null <- base::is.null
[10:26:11.307]                       muffled <- FALSE
[10:26:11.307]                       if (inherits(cond, "message")) {
[10:26:11.307]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.307]                         if (muffled) 
[10:26:11.307]                           invokeRestart("muffleMessage")
[10:26:11.307]                       }
[10:26:11.307]                       else if (inherits(cond, "warning")) {
[10:26:11.307]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.307]                         if (muffled) 
[10:26:11.307]                           invokeRestart("muffleWarning")
[10:26:11.307]                       }
[10:26:11.307]                       else if (inherits(cond, "condition")) {
[10:26:11.307]                         if (!is.null(pattern)) {
[10:26:11.307]                           computeRestarts <- base::computeRestarts
[10:26:11.307]                           grepl <- base::grepl
[10:26:11.307]                           restarts <- computeRestarts(cond)
[10:26:11.307]                           for (restart in restarts) {
[10:26:11.307]                             name <- restart$name
[10:26:11.307]                             if (is.null(name)) 
[10:26:11.307]                               next
[10:26:11.307]                             if (!grepl(pattern, name)) 
[10:26:11.307]                               next
[10:26:11.307]                             invokeRestart(restart)
[10:26:11.307]                             muffled <- TRUE
[10:26:11.307]                             break
[10:26:11.307]                           }
[10:26:11.307]                         }
[10:26:11.307]                       }
[10:26:11.307]                       invisible(muffled)
[10:26:11.307]                     }
[10:26:11.307]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.307]                   }
[10:26:11.307]                 }
[10:26:11.307]             }
[10:26:11.307]         }))
[10:26:11.307]     }, error = function(ex) {
[10:26:11.307]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.307]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.307]                 ...future.rng), started = ...future.startTime, 
[10:26:11.307]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.307]             version = "1.8"), class = "FutureResult")
[10:26:11.307]     }, finally = {
[10:26:11.307]         if (!identical(...future.workdir, getwd())) 
[10:26:11.307]             setwd(...future.workdir)
[10:26:11.307]         {
[10:26:11.307]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.307]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.307]             }
[10:26:11.307]             base::options(...future.oldOptions)
[10:26:11.307]             if (.Platform$OS.type == "windows") {
[10:26:11.307]                 old_names <- names(...future.oldEnvVars)
[10:26:11.307]                 envs <- base::Sys.getenv()
[10:26:11.307]                 names <- names(envs)
[10:26:11.307]                 common <- intersect(names, old_names)
[10:26:11.307]                 added <- setdiff(names, old_names)
[10:26:11.307]                 removed <- setdiff(old_names, names)
[10:26:11.307]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.307]                   envs[common]]
[10:26:11.307]                 NAMES <- toupper(changed)
[10:26:11.307]                 args <- list()
[10:26:11.307]                 for (kk in seq_along(NAMES)) {
[10:26:11.307]                   name <- changed[[kk]]
[10:26:11.307]                   NAME <- NAMES[[kk]]
[10:26:11.307]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.307]                     next
[10:26:11.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.307]                 }
[10:26:11.307]                 NAMES <- toupper(added)
[10:26:11.307]                 for (kk in seq_along(NAMES)) {
[10:26:11.307]                   name <- added[[kk]]
[10:26:11.307]                   NAME <- NAMES[[kk]]
[10:26:11.307]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.307]                     next
[10:26:11.307]                   args[[name]] <- ""
[10:26:11.307]                 }
[10:26:11.307]                 NAMES <- toupper(removed)
[10:26:11.307]                 for (kk in seq_along(NAMES)) {
[10:26:11.307]                   name <- removed[[kk]]
[10:26:11.307]                   NAME <- NAMES[[kk]]
[10:26:11.307]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.307]                     next
[10:26:11.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.307]                 }
[10:26:11.307]                 if (length(args) > 0) 
[10:26:11.307]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.307]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.307]             }
[10:26:11.307]             else {
[10:26:11.307]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.307]             }
[10:26:11.307]             {
[10:26:11.307]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.307]                   0L) {
[10:26:11.307]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.307]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.307]                   base::options(opts)
[10:26:11.307]                 }
[10:26:11.307]                 {
[10:26:11.307]                   {
[10:26:11.307]                     NULL
[10:26:11.307]                     RNGkind("Mersenne-Twister")
[10:26:11.307]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.307]                       inherits = FALSE)
[10:26:11.307]                   }
[10:26:11.307]                   options(future.plan = NULL)
[10:26:11.307]                   if (is.na(NA_character_)) 
[10:26:11.307]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.307]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.307]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.307]                   {
[10:26:11.307]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.307]                     if (!future$lazy) 
[10:26:11.307]                       future <- run(future)
[10:26:11.307]                     invisible(future)
[10:26:11.307]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.307]                 }
[10:26:11.307]             }
[10:26:11.307]         }
[10:26:11.307]     })
[10:26:11.307]     if (TRUE) {
[10:26:11.307]         base::sink(type = "output", split = FALSE)
[10:26:11.307]         if (TRUE) {
[10:26:11.307]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.307]         }
[10:26:11.307]         else {
[10:26:11.307]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.307]         }
[10:26:11.307]         base::close(...future.stdout)
[10:26:11.307]         ...future.stdout <- NULL
[10:26:11.307]     }
[10:26:11.307]     ...future.result$conditions <- ...future.conditions
[10:26:11.307]     ...future.result$finished <- base::Sys.time()
[10:26:11.307]     ...future.result
[10:26:11.307] }
[10:26:11.309] assign_globals() ...
[10:26:11.309] List of 1
[10:26:11.309]  $ ii: int 2
[10:26:11.309]  - attr(*, "where")=List of 1
[10:26:11.309]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:11.309]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.309]  - attr(*, "resolved")= logi TRUE
[10:26:11.309]  - attr(*, "total_size")= num 56
[10:26:11.309]  - attr(*, "already-done")= logi TRUE
[10:26:11.312] - copied ‘ii’ to environment
[10:26:11.312] assign_globals() ... done
[10:26:11.312] plan(): Setting new future strategy stack:
[10:26:11.312] List of future strategies:
[10:26:11.312] 1. sequential:
[10:26:11.312]    - args: function (..., envir = parent.frame())
[10:26:11.312]    - tweaked: FALSE
[10:26:11.312]    - call: NULL
[10:26:11.312] plan(): nbrOfWorkers() = 1
[10:26:11.313] plan(): Setting new future strategy stack:
[10:26:11.313] List of future strategies:
[10:26:11.313] 1. sequential:
[10:26:11.313]    - args: function (..., envir = parent.frame())
[10:26:11.313]    - tweaked: FALSE
[10:26:11.313]    - call: plan(strategy)
[10:26:11.313] plan(): nbrOfWorkers() = 1
[10:26:11.314] SequentialFuture started (and completed)
[10:26:11.314] - Launch lazy future ... done
[10:26:11.314] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.314] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.314] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:11.317] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:11.317] Searching for globals ... DONE
[10:26:11.317] Resolving globals: TRUE
[10:26:11.317] Resolving any globals that are futures ...
[10:26:11.317] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:11.317] Resolving any globals that are futures ... DONE
[10:26:11.317] Resolving futures part of globals (recursively) ...
[10:26:11.318] resolve() on list ...
[10:26:11.318]  recursive: 99
[10:26:11.318]  length: 1
[10:26:11.318]  elements: ‘ii’
[10:26:11.318]  length: 0 (resolved future 1)
[10:26:11.318] resolve() on list ... DONE
[10:26:11.318] - globals: [1] ‘ii’
[10:26:11.318] Resolving futures part of globals (recursively) ... DONE
[10:26:11.318] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:11.319] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:11.319] - globals: [1] ‘ii’
[10:26:11.319] 
[10:26:11.319] getGlobalsAndPackages() ... DONE
[10:26:11.319] run() for ‘Future’ ...
[10:26:11.319] - state: ‘created’
[10:26:11.319] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.320] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.320] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.320]   - Field: ‘label’
[10:26:11.320]   - Field: ‘local’
[10:26:11.320]   - Field: ‘owner’
[10:26:11.320]   - Field: ‘envir’
[10:26:11.320]   - Field: ‘packages’
[10:26:11.320]   - Field: ‘gc’
[10:26:11.320]   - Field: ‘conditions’
[10:26:11.321]   - Field: ‘expr’
[10:26:11.321]   - Field: ‘uuid’
[10:26:11.321]   - Field: ‘seed’
[10:26:11.321]   - Field: ‘version’
[10:26:11.321]   - Field: ‘result’
[10:26:11.321]   - Field: ‘asynchronous’
[10:26:11.321]   - Field: ‘calls’
[10:26:11.321]   - Field: ‘globals’
[10:26:11.321]   - Field: ‘stdout’
[10:26:11.321]   - Field: ‘earlySignal’
[10:26:11.321]   - Field: ‘lazy’
[10:26:11.322]   - Field: ‘state’
[10:26:11.322] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.322] - Launch lazy future ...
[10:26:11.322] Packages needed by the future expression (n = 0): <none>
[10:26:11.322] Packages needed by future strategies (n = 0): <none>
[10:26:11.322] {
[10:26:11.322]     {
[10:26:11.322]         {
[10:26:11.322]             ...future.startTime <- base::Sys.time()
[10:26:11.322]             {
[10:26:11.322]                 {
[10:26:11.322]                   {
[10:26:11.322]                     base::local({
[10:26:11.322]                       has_future <- base::requireNamespace("future", 
[10:26:11.322]                         quietly = TRUE)
[10:26:11.322]                       if (has_future) {
[10:26:11.322]                         ns <- base::getNamespace("future")
[10:26:11.322]                         version <- ns[[".package"]][["version"]]
[10:26:11.322]                         if (is.null(version)) 
[10:26:11.322]                           version <- utils::packageVersion("future")
[10:26:11.322]                       }
[10:26:11.322]                       else {
[10:26:11.322]                         version <- NULL
[10:26:11.322]                       }
[10:26:11.322]                       if (!has_future || version < "1.8.0") {
[10:26:11.322]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.322]                           "", base::R.version$version.string), 
[10:26:11.322]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.322]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.322]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.322]                             "release", "version")], collapse = " "), 
[10:26:11.322]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.322]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.322]                           info)
[10:26:11.322]                         info <- base::paste(info, collapse = "; ")
[10:26:11.322]                         if (!has_future) {
[10:26:11.322]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.322]                             info)
[10:26:11.322]                         }
[10:26:11.322]                         else {
[10:26:11.322]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.322]                             info, version)
[10:26:11.322]                         }
[10:26:11.322]                         base::stop(msg)
[10:26:11.322]                       }
[10:26:11.322]                     })
[10:26:11.322]                   }
[10:26:11.322]                   options(future.plan = NULL)
[10:26:11.322]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.322]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.322]                 }
[10:26:11.322]                 ...future.workdir <- getwd()
[10:26:11.322]             }
[10:26:11.322]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.322]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.322]         }
[10:26:11.322]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.322]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:11.322]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.322]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.322]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.322]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.322]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.322]             base::names(...future.oldOptions))
[10:26:11.322]     }
[10:26:11.322]     if (FALSE) {
[10:26:11.322]     }
[10:26:11.322]     else {
[10:26:11.322]         if (TRUE) {
[10:26:11.322]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.322]                 open = "w")
[10:26:11.322]         }
[10:26:11.322]         else {
[10:26:11.322]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.322]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.322]         }
[10:26:11.322]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.322]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.322]             base::sink(type = "output", split = FALSE)
[10:26:11.322]             base::close(...future.stdout)
[10:26:11.322]         }, add = TRUE)
[10:26:11.322]     }
[10:26:11.322]     ...future.frame <- base::sys.nframe()
[10:26:11.322]     ...future.conditions <- base::list()
[10:26:11.322]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.322]     if (FALSE) {
[10:26:11.322]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.322]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.322]     }
[10:26:11.322]     ...future.result <- base::tryCatch({
[10:26:11.322]         base::withCallingHandlers({
[10:26:11.322]             ...future.value <- base::withVisible(base::local({
[10:26:11.322]                 b <- a * ii
[10:26:11.322]                 a <- 0
[10:26:11.322]                 b
[10:26:11.322]             }))
[10:26:11.322]             future::FutureResult(value = ...future.value$value, 
[10:26:11.322]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.322]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.322]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.322]                     ...future.globalenv.names))
[10:26:11.322]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.322]         }, condition = base::local({
[10:26:11.322]             c <- base::c
[10:26:11.322]             inherits <- base::inherits
[10:26:11.322]             invokeRestart <- base::invokeRestart
[10:26:11.322]             length <- base::length
[10:26:11.322]             list <- base::list
[10:26:11.322]             seq.int <- base::seq.int
[10:26:11.322]             signalCondition <- base::signalCondition
[10:26:11.322]             sys.calls <- base::sys.calls
[10:26:11.322]             `[[` <- base::`[[`
[10:26:11.322]             `+` <- base::`+`
[10:26:11.322]             `<<-` <- base::`<<-`
[10:26:11.322]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.322]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.322]                   3L)]
[10:26:11.322]             }
[10:26:11.322]             function(cond) {
[10:26:11.322]                 is_error <- inherits(cond, "error")
[10:26:11.322]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.322]                   NULL)
[10:26:11.322]                 if (is_error) {
[10:26:11.322]                   sessionInformation <- function() {
[10:26:11.322]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.322]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.322]                       search = base::search(), system = base::Sys.info())
[10:26:11.322]                   }
[10:26:11.322]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.322]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.322]                     cond$call), session = sessionInformation(), 
[10:26:11.322]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.322]                   signalCondition(cond)
[10:26:11.322]                 }
[10:26:11.322]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.322]                 "immediateCondition"))) {
[10:26:11.322]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.322]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.322]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.322]                   if (TRUE && !signal) {
[10:26:11.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.322]                     {
[10:26:11.322]                       inherits <- base::inherits
[10:26:11.322]                       invokeRestart <- base::invokeRestart
[10:26:11.322]                       is.null <- base::is.null
[10:26:11.322]                       muffled <- FALSE
[10:26:11.322]                       if (inherits(cond, "message")) {
[10:26:11.322]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.322]                         if (muffled) 
[10:26:11.322]                           invokeRestart("muffleMessage")
[10:26:11.322]                       }
[10:26:11.322]                       else if (inherits(cond, "warning")) {
[10:26:11.322]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.322]                         if (muffled) 
[10:26:11.322]                           invokeRestart("muffleWarning")
[10:26:11.322]                       }
[10:26:11.322]                       else if (inherits(cond, "condition")) {
[10:26:11.322]                         if (!is.null(pattern)) {
[10:26:11.322]                           computeRestarts <- base::computeRestarts
[10:26:11.322]                           grepl <- base::grepl
[10:26:11.322]                           restarts <- computeRestarts(cond)
[10:26:11.322]                           for (restart in restarts) {
[10:26:11.322]                             name <- restart$name
[10:26:11.322]                             if (is.null(name)) 
[10:26:11.322]                               next
[10:26:11.322]                             if (!grepl(pattern, name)) 
[10:26:11.322]                               next
[10:26:11.322]                             invokeRestart(restart)
[10:26:11.322]                             muffled <- TRUE
[10:26:11.322]                             break
[10:26:11.322]                           }
[10:26:11.322]                         }
[10:26:11.322]                       }
[10:26:11.322]                       invisible(muffled)
[10:26:11.322]                     }
[10:26:11.322]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.322]                   }
[10:26:11.322]                 }
[10:26:11.322]                 else {
[10:26:11.322]                   if (TRUE) {
[10:26:11.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.322]                     {
[10:26:11.322]                       inherits <- base::inherits
[10:26:11.322]                       invokeRestart <- base::invokeRestart
[10:26:11.322]                       is.null <- base::is.null
[10:26:11.322]                       muffled <- FALSE
[10:26:11.322]                       if (inherits(cond, "message")) {
[10:26:11.322]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.322]                         if (muffled) 
[10:26:11.322]                           invokeRestart("muffleMessage")
[10:26:11.322]                       }
[10:26:11.322]                       else if (inherits(cond, "warning")) {
[10:26:11.322]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.322]                         if (muffled) 
[10:26:11.322]                           invokeRestart("muffleWarning")
[10:26:11.322]                       }
[10:26:11.322]                       else if (inherits(cond, "condition")) {
[10:26:11.322]                         if (!is.null(pattern)) {
[10:26:11.322]                           computeRestarts <- base::computeRestarts
[10:26:11.322]                           grepl <- base::grepl
[10:26:11.322]                           restarts <- computeRestarts(cond)
[10:26:11.322]                           for (restart in restarts) {
[10:26:11.322]                             name <- restart$name
[10:26:11.322]                             if (is.null(name)) 
[10:26:11.322]                               next
[10:26:11.322]                             if (!grepl(pattern, name)) 
[10:26:11.322]                               next
[10:26:11.322]                             invokeRestart(restart)
[10:26:11.322]                             muffled <- TRUE
[10:26:11.322]                             break
[10:26:11.322]                           }
[10:26:11.322]                         }
[10:26:11.322]                       }
[10:26:11.322]                       invisible(muffled)
[10:26:11.322]                     }
[10:26:11.322]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.322]                   }
[10:26:11.322]                 }
[10:26:11.322]             }
[10:26:11.322]         }))
[10:26:11.322]     }, error = function(ex) {
[10:26:11.322]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.322]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.322]                 ...future.rng), started = ...future.startTime, 
[10:26:11.322]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.322]             version = "1.8"), class = "FutureResult")
[10:26:11.322]     }, finally = {
[10:26:11.322]         if (!identical(...future.workdir, getwd())) 
[10:26:11.322]             setwd(...future.workdir)
[10:26:11.322]         {
[10:26:11.322]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.322]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.322]             }
[10:26:11.322]             base::options(...future.oldOptions)
[10:26:11.322]             if (.Platform$OS.type == "windows") {
[10:26:11.322]                 old_names <- names(...future.oldEnvVars)
[10:26:11.322]                 envs <- base::Sys.getenv()
[10:26:11.322]                 names <- names(envs)
[10:26:11.322]                 common <- intersect(names, old_names)
[10:26:11.322]                 added <- setdiff(names, old_names)
[10:26:11.322]                 removed <- setdiff(old_names, names)
[10:26:11.322]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.322]                   envs[common]]
[10:26:11.322]                 NAMES <- toupper(changed)
[10:26:11.322]                 args <- list()
[10:26:11.322]                 for (kk in seq_along(NAMES)) {
[10:26:11.322]                   name <- changed[[kk]]
[10:26:11.322]                   NAME <- NAMES[[kk]]
[10:26:11.322]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.322]                     next
[10:26:11.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.322]                 }
[10:26:11.322]                 NAMES <- toupper(added)
[10:26:11.322]                 for (kk in seq_along(NAMES)) {
[10:26:11.322]                   name <- added[[kk]]
[10:26:11.322]                   NAME <- NAMES[[kk]]
[10:26:11.322]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.322]                     next
[10:26:11.322]                   args[[name]] <- ""
[10:26:11.322]                 }
[10:26:11.322]                 NAMES <- toupper(removed)
[10:26:11.322]                 for (kk in seq_along(NAMES)) {
[10:26:11.322]                   name <- removed[[kk]]
[10:26:11.322]                   NAME <- NAMES[[kk]]
[10:26:11.322]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.322]                     next
[10:26:11.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.322]                 }
[10:26:11.322]                 if (length(args) > 0) 
[10:26:11.322]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.322]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.322]             }
[10:26:11.322]             else {
[10:26:11.322]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.322]             }
[10:26:11.322]             {
[10:26:11.322]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.322]                   0L) {
[10:26:11.322]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.322]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.322]                   base::options(opts)
[10:26:11.322]                 }
[10:26:11.322]                 {
[10:26:11.322]                   {
[10:26:11.322]                     NULL
[10:26:11.322]                     RNGkind("Mersenne-Twister")
[10:26:11.322]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.322]                       inherits = FALSE)
[10:26:11.322]                   }
[10:26:11.322]                   options(future.plan = NULL)
[10:26:11.322]                   if (is.na(NA_character_)) 
[10:26:11.322]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.322]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.322]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.322]                   {
[10:26:11.322]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.322]                     if (!future$lazy) 
[10:26:11.322]                       future <- run(future)
[10:26:11.322]                     invisible(future)
[10:26:11.322]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.322]                 }
[10:26:11.322]             }
[10:26:11.322]         }
[10:26:11.322]     })
[10:26:11.322]     if (TRUE) {
[10:26:11.322]         base::sink(type = "output", split = FALSE)
[10:26:11.322]         if (TRUE) {
[10:26:11.322]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.322]         }
[10:26:11.322]         else {
[10:26:11.322]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.322]         }
[10:26:11.322]         base::close(...future.stdout)
[10:26:11.322]         ...future.stdout <- NULL
[10:26:11.322]     }
[10:26:11.322]     ...future.result$conditions <- ...future.conditions
[10:26:11.322]     ...future.result$finished <- base::Sys.time()
[10:26:11.322]     ...future.result
[10:26:11.322] }
[10:26:11.324] assign_globals() ...
[10:26:11.324] List of 1
[10:26:11.324]  $ ii: int 3
[10:26:11.324]  - attr(*, "where")=List of 1
[10:26:11.324]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:11.324]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.324]  - attr(*, "resolved")= logi TRUE
[10:26:11.324]  - attr(*, "total_size")= num 56
[10:26:11.324]  - attr(*, "already-done")= logi TRUE
[10:26:11.326] - copied ‘ii’ to environment
[10:26:11.326] assign_globals() ... done
[10:26:11.327] plan(): Setting new future strategy stack:
[10:26:11.327] List of future strategies:
[10:26:11.327] 1. sequential:
[10:26:11.327]    - args: function (..., envir = parent.frame())
[10:26:11.327]    - tweaked: FALSE
[10:26:11.327]    - call: NULL
[10:26:11.327] plan(): nbrOfWorkers() = 1
[10:26:11.328] plan(): Setting new future strategy stack:
[10:26:11.328] List of future strategies:
[10:26:11.328] 1. sequential:
[10:26:11.328]    - args: function (..., envir = parent.frame())
[10:26:11.328]    - tweaked: FALSE
[10:26:11.328]    - call: plan(strategy)
[10:26:11.328] plan(): nbrOfWorkers() = 1
[10:26:11.328] SequentialFuture started (and completed)
[10:26:11.328] - Launch lazy future ... done
[10:26:11.328] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.329] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.330] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:11.331] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:11.331] Searching for globals ... DONE
[10:26:11.331] Resolving globals: TRUE
[10:26:11.331] Resolving any globals that are futures ...
[10:26:11.331] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:11.331] Resolving any globals that are futures ... DONE
[10:26:11.332] Resolving futures part of globals (recursively) ...
[10:26:11.332] resolve() on list ...
[10:26:11.332]  recursive: 99
[10:26:11.332]  length: 1
[10:26:11.332]  elements: ‘ii’
[10:26:11.332]  length: 0 (resolved future 1)
[10:26:11.332] resolve() on list ... DONE
[10:26:11.332] - globals: [1] ‘ii’
[10:26:11.332] Resolving futures part of globals (recursively) ... DONE
[10:26:11.333] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:11.333] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:11.333] - globals: [1] ‘ii’
[10:26:11.333] 
[10:26:11.333] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.334] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.334] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:11.335] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:11.335] Searching for globals ... DONE
[10:26:11.335] Resolving globals: TRUE
[10:26:11.336] Resolving any globals that are futures ...
[10:26:11.336] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:11.336] Resolving any globals that are futures ... DONE
[10:26:11.336] Resolving futures part of globals (recursively) ...
[10:26:11.336] resolve() on list ...
[10:26:11.336]  recursive: 99
[10:26:11.336]  length: 1
[10:26:11.336]  elements: ‘ii’
[10:26:11.337]  length: 0 (resolved future 1)
[10:26:11.337] resolve() on list ... DONE
[10:26:11.337] - globals: [1] ‘ii’
[10:26:11.337] Resolving futures part of globals (recursively) ... DONE
[10:26:11.337] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:11.337] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:11.337] - globals: [1] ‘ii’
[10:26:11.337] 
[10:26:11.338] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.338] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.338] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:11.340] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:11.341] Searching for globals ... DONE
[10:26:11.341] Resolving globals: TRUE
[10:26:11.341] Resolving any globals that are futures ...
[10:26:11.341] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:11.341] Resolving any globals that are futures ... DONE
[10:26:11.341] Resolving futures part of globals (recursively) ...
[10:26:11.341] resolve() on list ...
[10:26:11.342]  recursive: 99
[10:26:11.342]  length: 1
[10:26:11.342]  elements: ‘ii’
[10:26:11.342]  length: 0 (resolved future 1)
[10:26:11.342] resolve() on list ... DONE
[10:26:11.342] - globals: [1] ‘ii’
[10:26:11.342] Resolving futures part of globals (recursively) ... DONE
[10:26:11.342] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:11.343] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:11.343] - globals: [1] ‘ii’
[10:26:11.343] 
[10:26:11.343] getGlobalsAndPackages() ... DONE
[10:26:11.343] run() for ‘Future’ ...
[10:26:11.343] - state: ‘created’
[10:26:11.343] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.344] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.344] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.344]   - Field: ‘label’
[10:26:11.344]   - Field: ‘local’
[10:26:11.344]   - Field: ‘owner’
[10:26:11.344]   - Field: ‘envir’
[10:26:11.344]   - Field: ‘packages’
[10:26:11.344]   - Field: ‘gc’
[10:26:11.344]   - Field: ‘conditions’
[10:26:11.344]   - Field: ‘expr’
[10:26:11.344]   - Field: ‘uuid’
[10:26:11.345]   - Field: ‘seed’
[10:26:11.345]   - Field: ‘version’
[10:26:11.345]   - Field: ‘result’
[10:26:11.345]   - Field: ‘asynchronous’
[10:26:11.345]   - Field: ‘calls’
[10:26:11.345]   - Field: ‘globals’
[10:26:11.345]   - Field: ‘stdout’
[10:26:11.345]   - Field: ‘earlySignal’
[10:26:11.345]   - Field: ‘lazy’
[10:26:11.345]   - Field: ‘state’
[10:26:11.345] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.346] - Launch lazy future ...
[10:26:11.346] Packages needed by the future expression (n = 0): <none>
[10:26:11.346] Packages needed by future strategies (n = 0): <none>
[10:26:11.346] {
[10:26:11.346]     {
[10:26:11.346]         {
[10:26:11.346]             ...future.startTime <- base::Sys.time()
[10:26:11.346]             {
[10:26:11.346]                 {
[10:26:11.346]                   {
[10:26:11.346]                     base::local({
[10:26:11.346]                       has_future <- base::requireNamespace("future", 
[10:26:11.346]                         quietly = TRUE)
[10:26:11.346]                       if (has_future) {
[10:26:11.346]                         ns <- base::getNamespace("future")
[10:26:11.346]                         version <- ns[[".package"]][["version"]]
[10:26:11.346]                         if (is.null(version)) 
[10:26:11.346]                           version <- utils::packageVersion("future")
[10:26:11.346]                       }
[10:26:11.346]                       else {
[10:26:11.346]                         version <- NULL
[10:26:11.346]                       }
[10:26:11.346]                       if (!has_future || version < "1.8.0") {
[10:26:11.346]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.346]                           "", base::R.version$version.string), 
[10:26:11.346]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.346]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.346]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.346]                             "release", "version")], collapse = " "), 
[10:26:11.346]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.346]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.346]                           info)
[10:26:11.346]                         info <- base::paste(info, collapse = "; ")
[10:26:11.346]                         if (!has_future) {
[10:26:11.346]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.346]                             info)
[10:26:11.346]                         }
[10:26:11.346]                         else {
[10:26:11.346]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.346]                             info, version)
[10:26:11.346]                         }
[10:26:11.346]                         base::stop(msg)
[10:26:11.346]                       }
[10:26:11.346]                     })
[10:26:11.346]                   }
[10:26:11.346]                   options(future.plan = NULL)
[10:26:11.346]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.346]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.346]                 }
[10:26:11.346]                 ...future.workdir <- getwd()
[10:26:11.346]             }
[10:26:11.346]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.346]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.346]         }
[10:26:11.346]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.346]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:11.346]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.346]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.346]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.346]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.346]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.346]             base::names(...future.oldOptions))
[10:26:11.346]     }
[10:26:11.346]     if (FALSE) {
[10:26:11.346]     }
[10:26:11.346]     else {
[10:26:11.346]         if (TRUE) {
[10:26:11.346]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.346]                 open = "w")
[10:26:11.346]         }
[10:26:11.346]         else {
[10:26:11.346]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.346]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.346]         }
[10:26:11.346]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.346]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.346]             base::sink(type = "output", split = FALSE)
[10:26:11.346]             base::close(...future.stdout)
[10:26:11.346]         }, add = TRUE)
[10:26:11.346]     }
[10:26:11.346]     ...future.frame <- base::sys.nframe()
[10:26:11.346]     ...future.conditions <- base::list()
[10:26:11.346]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.346]     if (FALSE) {
[10:26:11.346]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.346]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.346]     }
[10:26:11.346]     ...future.result <- base::tryCatch({
[10:26:11.346]         base::withCallingHandlers({
[10:26:11.346]             ...future.value <- base::withVisible(base::local({
[10:26:11.346]                 b <- a * ii
[10:26:11.346]                 a <- 0
[10:26:11.346]                 b
[10:26:11.346]             }))
[10:26:11.346]             future::FutureResult(value = ...future.value$value, 
[10:26:11.346]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.346]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.346]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.346]                     ...future.globalenv.names))
[10:26:11.346]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.346]         }, condition = base::local({
[10:26:11.346]             c <- base::c
[10:26:11.346]             inherits <- base::inherits
[10:26:11.346]             invokeRestart <- base::invokeRestart
[10:26:11.346]             length <- base::length
[10:26:11.346]             list <- base::list
[10:26:11.346]             seq.int <- base::seq.int
[10:26:11.346]             signalCondition <- base::signalCondition
[10:26:11.346]             sys.calls <- base::sys.calls
[10:26:11.346]             `[[` <- base::`[[`
[10:26:11.346]             `+` <- base::`+`
[10:26:11.346]             `<<-` <- base::`<<-`
[10:26:11.346]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.346]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.346]                   3L)]
[10:26:11.346]             }
[10:26:11.346]             function(cond) {
[10:26:11.346]                 is_error <- inherits(cond, "error")
[10:26:11.346]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.346]                   NULL)
[10:26:11.346]                 if (is_error) {
[10:26:11.346]                   sessionInformation <- function() {
[10:26:11.346]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.346]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.346]                       search = base::search(), system = base::Sys.info())
[10:26:11.346]                   }
[10:26:11.346]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.346]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.346]                     cond$call), session = sessionInformation(), 
[10:26:11.346]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.346]                   signalCondition(cond)
[10:26:11.346]                 }
[10:26:11.346]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.346]                 "immediateCondition"))) {
[10:26:11.346]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.346]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.346]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.346]                   if (TRUE && !signal) {
[10:26:11.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.346]                     {
[10:26:11.346]                       inherits <- base::inherits
[10:26:11.346]                       invokeRestart <- base::invokeRestart
[10:26:11.346]                       is.null <- base::is.null
[10:26:11.346]                       muffled <- FALSE
[10:26:11.346]                       if (inherits(cond, "message")) {
[10:26:11.346]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.346]                         if (muffled) 
[10:26:11.346]                           invokeRestart("muffleMessage")
[10:26:11.346]                       }
[10:26:11.346]                       else if (inherits(cond, "warning")) {
[10:26:11.346]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.346]                         if (muffled) 
[10:26:11.346]                           invokeRestart("muffleWarning")
[10:26:11.346]                       }
[10:26:11.346]                       else if (inherits(cond, "condition")) {
[10:26:11.346]                         if (!is.null(pattern)) {
[10:26:11.346]                           computeRestarts <- base::computeRestarts
[10:26:11.346]                           grepl <- base::grepl
[10:26:11.346]                           restarts <- computeRestarts(cond)
[10:26:11.346]                           for (restart in restarts) {
[10:26:11.346]                             name <- restart$name
[10:26:11.346]                             if (is.null(name)) 
[10:26:11.346]                               next
[10:26:11.346]                             if (!grepl(pattern, name)) 
[10:26:11.346]                               next
[10:26:11.346]                             invokeRestart(restart)
[10:26:11.346]                             muffled <- TRUE
[10:26:11.346]                             break
[10:26:11.346]                           }
[10:26:11.346]                         }
[10:26:11.346]                       }
[10:26:11.346]                       invisible(muffled)
[10:26:11.346]                     }
[10:26:11.346]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.346]                   }
[10:26:11.346]                 }
[10:26:11.346]                 else {
[10:26:11.346]                   if (TRUE) {
[10:26:11.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.346]                     {
[10:26:11.346]                       inherits <- base::inherits
[10:26:11.346]                       invokeRestart <- base::invokeRestart
[10:26:11.346]                       is.null <- base::is.null
[10:26:11.346]                       muffled <- FALSE
[10:26:11.346]                       if (inherits(cond, "message")) {
[10:26:11.346]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.346]                         if (muffled) 
[10:26:11.346]                           invokeRestart("muffleMessage")
[10:26:11.346]                       }
[10:26:11.346]                       else if (inherits(cond, "warning")) {
[10:26:11.346]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.346]                         if (muffled) 
[10:26:11.346]                           invokeRestart("muffleWarning")
[10:26:11.346]                       }
[10:26:11.346]                       else if (inherits(cond, "condition")) {
[10:26:11.346]                         if (!is.null(pattern)) {
[10:26:11.346]                           computeRestarts <- base::computeRestarts
[10:26:11.346]                           grepl <- base::grepl
[10:26:11.346]                           restarts <- computeRestarts(cond)
[10:26:11.346]                           for (restart in restarts) {
[10:26:11.346]                             name <- restart$name
[10:26:11.346]                             if (is.null(name)) 
[10:26:11.346]                               next
[10:26:11.346]                             if (!grepl(pattern, name)) 
[10:26:11.346]                               next
[10:26:11.346]                             invokeRestart(restart)
[10:26:11.346]                             muffled <- TRUE
[10:26:11.346]                             break
[10:26:11.346]                           }
[10:26:11.346]                         }
[10:26:11.346]                       }
[10:26:11.346]                       invisible(muffled)
[10:26:11.346]                     }
[10:26:11.346]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.346]                   }
[10:26:11.346]                 }
[10:26:11.346]             }
[10:26:11.346]         }))
[10:26:11.346]     }, error = function(ex) {
[10:26:11.346]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.346]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.346]                 ...future.rng), started = ...future.startTime, 
[10:26:11.346]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.346]             version = "1.8"), class = "FutureResult")
[10:26:11.346]     }, finally = {
[10:26:11.346]         if (!identical(...future.workdir, getwd())) 
[10:26:11.346]             setwd(...future.workdir)
[10:26:11.346]         {
[10:26:11.346]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.346]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.346]             }
[10:26:11.346]             base::options(...future.oldOptions)
[10:26:11.346]             if (.Platform$OS.type == "windows") {
[10:26:11.346]                 old_names <- names(...future.oldEnvVars)
[10:26:11.346]                 envs <- base::Sys.getenv()
[10:26:11.346]                 names <- names(envs)
[10:26:11.346]                 common <- intersect(names, old_names)
[10:26:11.346]                 added <- setdiff(names, old_names)
[10:26:11.346]                 removed <- setdiff(old_names, names)
[10:26:11.346]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.346]                   envs[common]]
[10:26:11.346]                 NAMES <- toupper(changed)
[10:26:11.346]                 args <- list()
[10:26:11.346]                 for (kk in seq_along(NAMES)) {
[10:26:11.346]                   name <- changed[[kk]]
[10:26:11.346]                   NAME <- NAMES[[kk]]
[10:26:11.346]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.346]                     next
[10:26:11.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.346]                 }
[10:26:11.346]                 NAMES <- toupper(added)
[10:26:11.346]                 for (kk in seq_along(NAMES)) {
[10:26:11.346]                   name <- added[[kk]]
[10:26:11.346]                   NAME <- NAMES[[kk]]
[10:26:11.346]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.346]                     next
[10:26:11.346]                   args[[name]] <- ""
[10:26:11.346]                 }
[10:26:11.346]                 NAMES <- toupper(removed)
[10:26:11.346]                 for (kk in seq_along(NAMES)) {
[10:26:11.346]                   name <- removed[[kk]]
[10:26:11.346]                   NAME <- NAMES[[kk]]
[10:26:11.346]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.346]                     next
[10:26:11.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.346]                 }
[10:26:11.346]                 if (length(args) > 0) 
[10:26:11.346]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.346]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.346]             }
[10:26:11.346]             else {
[10:26:11.346]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.346]             }
[10:26:11.346]             {
[10:26:11.346]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.346]                   0L) {
[10:26:11.346]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.346]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.346]                   base::options(opts)
[10:26:11.346]                 }
[10:26:11.346]                 {
[10:26:11.346]                   {
[10:26:11.346]                     NULL
[10:26:11.346]                     RNGkind("Mersenne-Twister")
[10:26:11.346]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.346]                       inherits = FALSE)
[10:26:11.346]                   }
[10:26:11.346]                   options(future.plan = NULL)
[10:26:11.346]                   if (is.na(NA_character_)) 
[10:26:11.346]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.346]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.346]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.346]                   {
[10:26:11.346]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.346]                     if (!future$lazy) 
[10:26:11.346]                       future <- run(future)
[10:26:11.346]                     invisible(future)
[10:26:11.346]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.346]                 }
[10:26:11.346]             }
[10:26:11.346]         }
[10:26:11.346]     })
[10:26:11.346]     if (TRUE) {
[10:26:11.346]         base::sink(type = "output", split = FALSE)
[10:26:11.346]         if (TRUE) {
[10:26:11.346]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.346]         }
[10:26:11.346]         else {
[10:26:11.346]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.346]         }
[10:26:11.346]         base::close(...future.stdout)
[10:26:11.346]         ...future.stdout <- NULL
[10:26:11.346]     }
[10:26:11.346]     ...future.result$conditions <- ...future.conditions
[10:26:11.346]     ...future.result$finished <- base::Sys.time()
[10:26:11.346]     ...future.result
[10:26:11.346] }
[10:26:11.348] assign_globals() ...
[10:26:11.348] List of 1
[10:26:11.348]  $ ii: int 1
[10:26:11.348]  - attr(*, "where")=List of 1
[10:26:11.348]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:11.348]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.348]  - attr(*, "resolved")= logi TRUE
[10:26:11.348]  - attr(*, "total_size")= num 56
[10:26:11.348]  - attr(*, "already-done")= logi TRUE
[10:26:11.350] - copied ‘ii’ to environment
[10:26:11.350] assign_globals() ... done
[10:26:11.351] plan(): Setting new future strategy stack:
[10:26:11.351] List of future strategies:
[10:26:11.351] 1. sequential:
[10:26:11.351]    - args: function (..., envir = parent.frame())
[10:26:11.351]    - tweaked: FALSE
[10:26:11.351]    - call: NULL
[10:26:11.351] plan(): nbrOfWorkers() = 1
[10:26:11.352] plan(): Setting new future strategy stack:
[10:26:11.352] List of future strategies:
[10:26:11.352] 1. sequential:
[10:26:11.352]    - args: function (..., envir = parent.frame())
[10:26:11.352]    - tweaked: FALSE
[10:26:11.352]    - call: plan(strategy)
[10:26:11.352] plan(): nbrOfWorkers() = 1
[10:26:11.352] SequentialFuture started (and completed)
[10:26:11.353] signalConditions() ...
[10:26:11.353]  - include = ‘immediateCondition’
[10:26:11.353]  - exclude = 
[10:26:11.353]  - resignal = FALSE
[10:26:11.353]  - Number of conditions: 1
[10:26:11.353] signalConditions() ... done
[10:26:11.353] - Launch lazy future ... done
[10:26:11.353] run() for ‘SequentialFuture’ ... done
[10:26:11.353] signalConditions() ...
[10:26:11.353]  - include = ‘immediateCondition’
[10:26:11.353]  - exclude = 
[10:26:11.354]  - resignal = FALSE
[10:26:11.354]  - Number of conditions: 1
[10:26:11.354] signalConditions() ... done
[10:26:11.354] Future state: ‘finished’
[10:26:11.354] signalConditions() ...
[10:26:11.354]  - include = ‘condition’
[10:26:11.354]  - exclude = ‘immediateCondition’
[10:26:11.354]  - resignal = TRUE
[10:26:11.354]  - Number of conditions: 1
[10:26:11.354]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:26:11.355] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a * ii ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a * ii ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3e863ac79bce" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 10:26:11"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.369] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.370] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:11.370] 
[10:26:11.370] Searching for globals ... DONE
[10:26:11.370] - globals: [0] <none>
[10:26:11.370] getGlobalsAndPackages() ... DONE
[10:26:11.371] run() for ‘Future’ ...
[10:26:11.371] - state: ‘created’
[10:26:11.371] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.371] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.371] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.371]   - Field: ‘label’
[10:26:11.371]   - Field: ‘local’
[10:26:11.372]   - Field: ‘owner’
[10:26:11.372]   - Field: ‘envir’
[10:26:11.372]   - Field: ‘packages’
[10:26:11.372]   - Field: ‘gc’
[10:26:11.372]   - Field: ‘conditions’
[10:26:11.372]   - Field: ‘expr’
[10:26:11.372]   - Field: ‘uuid’
[10:26:11.372]   - Field: ‘seed’
[10:26:11.372]   - Field: ‘version’
[10:26:11.372]   - Field: ‘result’
[10:26:11.372]   - Field: ‘asynchronous’
[10:26:11.373]   - Field: ‘calls’
[10:26:11.373]   - Field: ‘globals’
[10:26:11.373]   - Field: ‘stdout’
[10:26:11.373]   - Field: ‘earlySignal’
[10:26:11.373]   - Field: ‘lazy’
[10:26:11.373]   - Field: ‘state’
[10:26:11.373] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.373] - Launch lazy future ...
[10:26:11.373] Packages needed by the future expression (n = 0): <none>
[10:26:11.373] Packages needed by future strategies (n = 0): <none>
[10:26:11.374] {
[10:26:11.374]     {
[10:26:11.374]         {
[10:26:11.374]             ...future.startTime <- base::Sys.time()
[10:26:11.374]             {
[10:26:11.374]                 {
[10:26:11.374]                   {
[10:26:11.374]                     base::local({
[10:26:11.374]                       has_future <- base::requireNamespace("future", 
[10:26:11.374]                         quietly = TRUE)
[10:26:11.374]                       if (has_future) {
[10:26:11.374]                         ns <- base::getNamespace("future")
[10:26:11.374]                         version <- ns[[".package"]][["version"]]
[10:26:11.374]                         if (is.null(version)) 
[10:26:11.374]                           version <- utils::packageVersion("future")
[10:26:11.374]                       }
[10:26:11.374]                       else {
[10:26:11.374]                         version <- NULL
[10:26:11.374]                       }
[10:26:11.374]                       if (!has_future || version < "1.8.0") {
[10:26:11.374]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.374]                           "", base::R.version$version.string), 
[10:26:11.374]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.374]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.374]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.374]                             "release", "version")], collapse = " "), 
[10:26:11.374]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.374]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.374]                           info)
[10:26:11.374]                         info <- base::paste(info, collapse = "; ")
[10:26:11.374]                         if (!has_future) {
[10:26:11.374]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.374]                             info)
[10:26:11.374]                         }
[10:26:11.374]                         else {
[10:26:11.374]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.374]                             info, version)
[10:26:11.374]                         }
[10:26:11.374]                         base::stop(msg)
[10:26:11.374]                       }
[10:26:11.374]                     })
[10:26:11.374]                   }
[10:26:11.374]                   options(future.plan = NULL)
[10:26:11.374]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.374]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.374]                 }
[10:26:11.374]                 ...future.workdir <- getwd()
[10:26:11.374]             }
[10:26:11.374]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.374]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.374]         }
[10:26:11.374]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.374]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:11.374]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.374]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.374]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.374]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.374]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.374]             base::names(...future.oldOptions))
[10:26:11.374]     }
[10:26:11.374]     if (FALSE) {
[10:26:11.374]     }
[10:26:11.374]     else {
[10:26:11.374]         if (TRUE) {
[10:26:11.374]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.374]                 open = "w")
[10:26:11.374]         }
[10:26:11.374]         else {
[10:26:11.374]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.374]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.374]         }
[10:26:11.374]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.374]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.374]             base::sink(type = "output", split = FALSE)
[10:26:11.374]             base::close(...future.stdout)
[10:26:11.374]         }, add = TRUE)
[10:26:11.374]     }
[10:26:11.374]     ...future.frame <- base::sys.nframe()
[10:26:11.374]     ...future.conditions <- base::list()
[10:26:11.374]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.374]     if (FALSE) {
[10:26:11.374]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.374]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.374]     }
[10:26:11.374]     ...future.result <- base::tryCatch({
[10:26:11.374]         base::withCallingHandlers({
[10:26:11.374]             ...future.value <- base::withVisible(base::local(1))
[10:26:11.374]             future::FutureResult(value = ...future.value$value, 
[10:26:11.374]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.374]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.374]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.374]                     ...future.globalenv.names))
[10:26:11.374]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.374]         }, condition = base::local({
[10:26:11.374]             c <- base::c
[10:26:11.374]             inherits <- base::inherits
[10:26:11.374]             invokeRestart <- base::invokeRestart
[10:26:11.374]             length <- base::length
[10:26:11.374]             list <- base::list
[10:26:11.374]             seq.int <- base::seq.int
[10:26:11.374]             signalCondition <- base::signalCondition
[10:26:11.374]             sys.calls <- base::sys.calls
[10:26:11.374]             `[[` <- base::`[[`
[10:26:11.374]             `+` <- base::`+`
[10:26:11.374]             `<<-` <- base::`<<-`
[10:26:11.374]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.374]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.374]                   3L)]
[10:26:11.374]             }
[10:26:11.374]             function(cond) {
[10:26:11.374]                 is_error <- inherits(cond, "error")
[10:26:11.374]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.374]                   NULL)
[10:26:11.374]                 if (is_error) {
[10:26:11.374]                   sessionInformation <- function() {
[10:26:11.374]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.374]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.374]                       search = base::search(), system = base::Sys.info())
[10:26:11.374]                   }
[10:26:11.374]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.374]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.374]                     cond$call), session = sessionInformation(), 
[10:26:11.374]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.374]                   signalCondition(cond)
[10:26:11.374]                 }
[10:26:11.374]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.374]                 "immediateCondition"))) {
[10:26:11.374]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.374]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.374]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.374]                   if (TRUE && !signal) {
[10:26:11.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.374]                     {
[10:26:11.374]                       inherits <- base::inherits
[10:26:11.374]                       invokeRestart <- base::invokeRestart
[10:26:11.374]                       is.null <- base::is.null
[10:26:11.374]                       muffled <- FALSE
[10:26:11.374]                       if (inherits(cond, "message")) {
[10:26:11.374]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.374]                         if (muffled) 
[10:26:11.374]                           invokeRestart("muffleMessage")
[10:26:11.374]                       }
[10:26:11.374]                       else if (inherits(cond, "warning")) {
[10:26:11.374]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.374]                         if (muffled) 
[10:26:11.374]                           invokeRestart("muffleWarning")
[10:26:11.374]                       }
[10:26:11.374]                       else if (inherits(cond, "condition")) {
[10:26:11.374]                         if (!is.null(pattern)) {
[10:26:11.374]                           computeRestarts <- base::computeRestarts
[10:26:11.374]                           grepl <- base::grepl
[10:26:11.374]                           restarts <- computeRestarts(cond)
[10:26:11.374]                           for (restart in restarts) {
[10:26:11.374]                             name <- restart$name
[10:26:11.374]                             if (is.null(name)) 
[10:26:11.374]                               next
[10:26:11.374]                             if (!grepl(pattern, name)) 
[10:26:11.374]                               next
[10:26:11.374]                             invokeRestart(restart)
[10:26:11.374]                             muffled <- TRUE
[10:26:11.374]                             break
[10:26:11.374]                           }
[10:26:11.374]                         }
[10:26:11.374]                       }
[10:26:11.374]                       invisible(muffled)
[10:26:11.374]                     }
[10:26:11.374]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.374]                   }
[10:26:11.374]                 }
[10:26:11.374]                 else {
[10:26:11.374]                   if (TRUE) {
[10:26:11.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.374]                     {
[10:26:11.374]                       inherits <- base::inherits
[10:26:11.374]                       invokeRestart <- base::invokeRestart
[10:26:11.374]                       is.null <- base::is.null
[10:26:11.374]                       muffled <- FALSE
[10:26:11.374]                       if (inherits(cond, "message")) {
[10:26:11.374]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.374]                         if (muffled) 
[10:26:11.374]                           invokeRestart("muffleMessage")
[10:26:11.374]                       }
[10:26:11.374]                       else if (inherits(cond, "warning")) {
[10:26:11.374]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.374]                         if (muffled) 
[10:26:11.374]                           invokeRestart("muffleWarning")
[10:26:11.374]                       }
[10:26:11.374]                       else if (inherits(cond, "condition")) {
[10:26:11.374]                         if (!is.null(pattern)) {
[10:26:11.374]                           computeRestarts <- base::computeRestarts
[10:26:11.374]                           grepl <- base::grepl
[10:26:11.374]                           restarts <- computeRestarts(cond)
[10:26:11.374]                           for (restart in restarts) {
[10:26:11.374]                             name <- restart$name
[10:26:11.374]                             if (is.null(name)) 
[10:26:11.374]                               next
[10:26:11.374]                             if (!grepl(pattern, name)) 
[10:26:11.374]                               next
[10:26:11.374]                             invokeRestart(restart)
[10:26:11.374]                             muffled <- TRUE
[10:26:11.374]                             break
[10:26:11.374]                           }
[10:26:11.374]                         }
[10:26:11.374]                       }
[10:26:11.374]                       invisible(muffled)
[10:26:11.374]                     }
[10:26:11.374]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.374]                   }
[10:26:11.374]                 }
[10:26:11.374]             }
[10:26:11.374]         }))
[10:26:11.374]     }, error = function(ex) {
[10:26:11.374]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.374]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.374]                 ...future.rng), started = ...future.startTime, 
[10:26:11.374]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.374]             version = "1.8"), class = "FutureResult")
[10:26:11.374]     }, finally = {
[10:26:11.374]         if (!identical(...future.workdir, getwd())) 
[10:26:11.374]             setwd(...future.workdir)
[10:26:11.374]         {
[10:26:11.374]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.374]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.374]             }
[10:26:11.374]             base::options(...future.oldOptions)
[10:26:11.374]             if (.Platform$OS.type == "windows") {
[10:26:11.374]                 old_names <- names(...future.oldEnvVars)
[10:26:11.374]                 envs <- base::Sys.getenv()
[10:26:11.374]                 names <- names(envs)
[10:26:11.374]                 common <- intersect(names, old_names)
[10:26:11.374]                 added <- setdiff(names, old_names)
[10:26:11.374]                 removed <- setdiff(old_names, names)
[10:26:11.374]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.374]                   envs[common]]
[10:26:11.374]                 NAMES <- toupper(changed)
[10:26:11.374]                 args <- list()
[10:26:11.374]                 for (kk in seq_along(NAMES)) {
[10:26:11.374]                   name <- changed[[kk]]
[10:26:11.374]                   NAME <- NAMES[[kk]]
[10:26:11.374]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.374]                     next
[10:26:11.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.374]                 }
[10:26:11.374]                 NAMES <- toupper(added)
[10:26:11.374]                 for (kk in seq_along(NAMES)) {
[10:26:11.374]                   name <- added[[kk]]
[10:26:11.374]                   NAME <- NAMES[[kk]]
[10:26:11.374]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.374]                     next
[10:26:11.374]                   args[[name]] <- ""
[10:26:11.374]                 }
[10:26:11.374]                 NAMES <- toupper(removed)
[10:26:11.374]                 for (kk in seq_along(NAMES)) {
[10:26:11.374]                   name <- removed[[kk]]
[10:26:11.374]                   NAME <- NAMES[[kk]]
[10:26:11.374]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.374]                     next
[10:26:11.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.374]                 }
[10:26:11.374]                 if (length(args) > 0) 
[10:26:11.374]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.374]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.374]             }
[10:26:11.374]             else {
[10:26:11.374]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.374]             }
[10:26:11.374]             {
[10:26:11.374]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.374]                   0L) {
[10:26:11.374]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.374]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.374]                   base::options(opts)
[10:26:11.374]                 }
[10:26:11.374]                 {
[10:26:11.374]                   {
[10:26:11.374]                     NULL
[10:26:11.374]                     RNGkind("Mersenne-Twister")
[10:26:11.374]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.374]                       inherits = FALSE)
[10:26:11.374]                   }
[10:26:11.374]                   options(future.plan = NULL)
[10:26:11.374]                   if (is.na(NA_character_)) 
[10:26:11.374]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.374]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.374]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.374]                   {
[10:26:11.374]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.374]                     if (!future$lazy) 
[10:26:11.374]                       future <- run(future)
[10:26:11.374]                     invisible(future)
[10:26:11.374]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.374]                 }
[10:26:11.374]             }
[10:26:11.374]         }
[10:26:11.374]     })
[10:26:11.374]     if (TRUE) {
[10:26:11.374]         base::sink(type = "output", split = FALSE)
[10:26:11.374]         if (TRUE) {
[10:26:11.374]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.374]         }
[10:26:11.374]         else {
[10:26:11.374]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.374]         }
[10:26:11.374]         base::close(...future.stdout)
[10:26:11.374]         ...future.stdout <- NULL
[10:26:11.374]     }
[10:26:11.374]     ...future.result$conditions <- ...future.conditions
[10:26:11.374]     ...future.result$finished <- base::Sys.time()
[10:26:11.374]     ...future.result
[10:26:11.374] }
[10:26:11.376] plan(): Setting new future strategy stack:
[10:26:11.376] List of future strategies:
[10:26:11.376] 1. sequential:
[10:26:11.376]    - args: function (..., envir = parent.frame())
[10:26:11.376]    - tweaked: FALSE
[10:26:11.376]    - call: NULL
[10:26:11.376] plan(): nbrOfWorkers() = 1
[10:26:11.377] plan(): Setting new future strategy stack:
[10:26:11.377] List of future strategies:
[10:26:11.377] 1. sequential:
[10:26:11.377]    - args: function (..., envir = parent.frame())
[10:26:11.377]    - tweaked: FALSE
[10:26:11.377]    - call: plan(strategy)
[10:26:11.377] plan(): nbrOfWorkers() = 1
[10:26:11.377] SequentialFuture started (and completed)
[10:26:11.377] - Launch lazy future ... done
[10:26:11.378] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.378] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.378] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:11.379] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:11.379] Searching for globals ... DONE
[10:26:11.379] Resolving globals: TRUE
[10:26:11.379] Resolving any globals that are futures ...
[10:26:11.379] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:11.379] Resolving any globals that are futures ... DONE
[10:26:11.380] Resolving futures part of globals (recursively) ...
[10:26:11.380] resolve() on list ...
[10:26:11.380]  recursive: 99
[10:26:11.380]  length: 1
[10:26:11.380]  elements: ‘a’
[10:26:11.380] resolved() for ‘SequentialFuture’ ...
[10:26:11.380] - state: ‘finished’
[10:26:11.381] - run: TRUE
[10:26:11.381] - result: ‘FutureResult’
[10:26:11.381] resolved() for ‘SequentialFuture’ ... done
[10:26:11.381] Future #1
[10:26:11.381] resolved() for ‘SequentialFuture’ ...
[10:26:11.381] - state: ‘finished’
[10:26:11.381] - run: TRUE
[10:26:11.381] - result: ‘FutureResult’
[10:26:11.382] resolved() for ‘SequentialFuture’ ... done
[10:26:11.382] A SequentialFuture was resolved
[10:26:11.382]  length: 0 (resolved future 1)
[10:26:11.382] resolve() on list ... DONE
[10:26:11.382] - globals: [1] ‘a’
[10:26:11.382] Resolving futures part of globals (recursively) ... DONE
[10:26:11.383] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[10:26:11.383] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[10:26:11.383] - globals: [1] ‘a’
[10:26:11.383] - packages: [1] ‘future’
[10:26:11.383] getGlobalsAndPackages() ... DONE
[10:26:11.384] run() for ‘Future’ ...
[10:26:11.384] - state: ‘created’
[10:26:11.384] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.384] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.384] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.384]   - Field: ‘label’
[10:26:11.384]   - Field: ‘local’
[10:26:11.384]   - Field: ‘owner’
[10:26:11.385]   - Field: ‘envir’
[10:26:11.385]   - Field: ‘packages’
[10:26:11.385]   - Field: ‘gc’
[10:26:11.385]   - Field: ‘conditions’
[10:26:11.385]   - Field: ‘expr’
[10:26:11.385]   - Field: ‘uuid’
[10:26:11.385]   - Field: ‘seed’
[10:26:11.385]   - Field: ‘version’
[10:26:11.385]   - Field: ‘result’
[10:26:11.385]   - Field: ‘asynchronous’
[10:26:11.386]   - Field: ‘calls’
[10:26:11.386]   - Field: ‘globals’
[10:26:11.386]   - Field: ‘stdout’
[10:26:11.386]   - Field: ‘earlySignal’
[10:26:11.386]   - Field: ‘lazy’
[10:26:11.386]   - Field: ‘state’
[10:26:11.386] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.386] - Launch lazy future ...
[10:26:11.386] Packages needed by the future expression (n = 1): ‘future’
[10:26:11.386] Packages needed by future strategies (n = 0): <none>
[10:26:11.387] {
[10:26:11.387]     {
[10:26:11.387]         {
[10:26:11.387]             ...future.startTime <- base::Sys.time()
[10:26:11.387]             {
[10:26:11.387]                 {
[10:26:11.387]                   {
[10:26:11.387]                     {
[10:26:11.387]                       base::local({
[10:26:11.387]                         has_future <- base::requireNamespace("future", 
[10:26:11.387]                           quietly = TRUE)
[10:26:11.387]                         if (has_future) {
[10:26:11.387]                           ns <- base::getNamespace("future")
[10:26:11.387]                           version <- ns[[".package"]][["version"]]
[10:26:11.387]                           if (is.null(version)) 
[10:26:11.387]                             version <- utils::packageVersion("future")
[10:26:11.387]                         }
[10:26:11.387]                         else {
[10:26:11.387]                           version <- NULL
[10:26:11.387]                         }
[10:26:11.387]                         if (!has_future || version < "1.8.0") {
[10:26:11.387]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.387]                             "", base::R.version$version.string), 
[10:26:11.387]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:11.387]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.387]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.387]                               "release", "version")], collapse = " "), 
[10:26:11.387]                             hostname = base::Sys.info()[["nodename"]])
[10:26:11.387]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.387]                             info)
[10:26:11.387]                           info <- base::paste(info, collapse = "; ")
[10:26:11.387]                           if (!has_future) {
[10:26:11.387]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.387]                               info)
[10:26:11.387]                           }
[10:26:11.387]                           else {
[10:26:11.387]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.387]                               info, version)
[10:26:11.387]                           }
[10:26:11.387]                           base::stop(msg)
[10:26:11.387]                         }
[10:26:11.387]                       })
[10:26:11.387]                     }
[10:26:11.387]                     base::local({
[10:26:11.387]                       for (pkg in "future") {
[10:26:11.387]                         base::loadNamespace(pkg)
[10:26:11.387]                         base::library(pkg, character.only = TRUE)
[10:26:11.387]                       }
[10:26:11.387]                     })
[10:26:11.387]                   }
[10:26:11.387]                   options(future.plan = NULL)
[10:26:11.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.387]                 }
[10:26:11.387]                 ...future.workdir <- getwd()
[10:26:11.387]             }
[10:26:11.387]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.387]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.387]         }
[10:26:11.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.387]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:11.387]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.387]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.387]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.387]             base::names(...future.oldOptions))
[10:26:11.387]     }
[10:26:11.387]     if (FALSE) {
[10:26:11.387]     }
[10:26:11.387]     else {
[10:26:11.387]         if (TRUE) {
[10:26:11.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.387]                 open = "w")
[10:26:11.387]         }
[10:26:11.387]         else {
[10:26:11.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.387]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.387]         }
[10:26:11.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.387]             base::sink(type = "output", split = FALSE)
[10:26:11.387]             base::close(...future.stdout)
[10:26:11.387]         }, add = TRUE)
[10:26:11.387]     }
[10:26:11.387]     ...future.frame <- base::sys.nframe()
[10:26:11.387]     ...future.conditions <- base::list()
[10:26:11.387]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.387]     if (FALSE) {
[10:26:11.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.387]     }
[10:26:11.387]     ...future.result <- base::tryCatch({
[10:26:11.387]         base::withCallingHandlers({
[10:26:11.387]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:26:11.387]                 1))
[10:26:11.387]             future::FutureResult(value = ...future.value$value, 
[10:26:11.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.387]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.387]                     ...future.globalenv.names))
[10:26:11.387]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.387]         }, condition = base::local({
[10:26:11.387]             c <- base::c
[10:26:11.387]             inherits <- base::inherits
[10:26:11.387]             invokeRestart <- base::invokeRestart
[10:26:11.387]             length <- base::length
[10:26:11.387]             list <- base::list
[10:26:11.387]             seq.int <- base::seq.int
[10:26:11.387]             signalCondition <- base::signalCondition
[10:26:11.387]             sys.calls <- base::sys.calls
[10:26:11.387]             `[[` <- base::`[[`
[10:26:11.387]             `+` <- base::`+`
[10:26:11.387]             `<<-` <- base::`<<-`
[10:26:11.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.387]                   3L)]
[10:26:11.387]             }
[10:26:11.387]             function(cond) {
[10:26:11.387]                 is_error <- inherits(cond, "error")
[10:26:11.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.387]                   NULL)
[10:26:11.387]                 if (is_error) {
[10:26:11.387]                   sessionInformation <- function() {
[10:26:11.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.387]                       search = base::search(), system = base::Sys.info())
[10:26:11.387]                   }
[10:26:11.387]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.387]                     cond$call), session = sessionInformation(), 
[10:26:11.387]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.387]                   signalCondition(cond)
[10:26:11.387]                 }
[10:26:11.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.387]                 "immediateCondition"))) {
[10:26:11.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.387]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.387]                   if (TRUE && !signal) {
[10:26:11.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.387]                     {
[10:26:11.387]                       inherits <- base::inherits
[10:26:11.387]                       invokeRestart <- base::invokeRestart
[10:26:11.387]                       is.null <- base::is.null
[10:26:11.387]                       muffled <- FALSE
[10:26:11.387]                       if (inherits(cond, "message")) {
[10:26:11.387]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.387]                         if (muffled) 
[10:26:11.387]                           invokeRestart("muffleMessage")
[10:26:11.387]                       }
[10:26:11.387]                       else if (inherits(cond, "warning")) {
[10:26:11.387]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.387]                         if (muffled) 
[10:26:11.387]                           invokeRestart("muffleWarning")
[10:26:11.387]                       }
[10:26:11.387]                       else if (inherits(cond, "condition")) {
[10:26:11.387]                         if (!is.null(pattern)) {
[10:26:11.387]                           computeRestarts <- base::computeRestarts
[10:26:11.387]                           grepl <- base::grepl
[10:26:11.387]                           restarts <- computeRestarts(cond)
[10:26:11.387]                           for (restart in restarts) {
[10:26:11.387]                             name <- restart$name
[10:26:11.387]                             if (is.null(name)) 
[10:26:11.387]                               next
[10:26:11.387]                             if (!grepl(pattern, name)) 
[10:26:11.387]                               next
[10:26:11.387]                             invokeRestart(restart)
[10:26:11.387]                             muffled <- TRUE
[10:26:11.387]                             break
[10:26:11.387]                           }
[10:26:11.387]                         }
[10:26:11.387]                       }
[10:26:11.387]                       invisible(muffled)
[10:26:11.387]                     }
[10:26:11.387]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.387]                   }
[10:26:11.387]                 }
[10:26:11.387]                 else {
[10:26:11.387]                   if (TRUE) {
[10:26:11.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.387]                     {
[10:26:11.387]                       inherits <- base::inherits
[10:26:11.387]                       invokeRestart <- base::invokeRestart
[10:26:11.387]                       is.null <- base::is.null
[10:26:11.387]                       muffled <- FALSE
[10:26:11.387]                       if (inherits(cond, "message")) {
[10:26:11.387]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.387]                         if (muffled) 
[10:26:11.387]                           invokeRestart("muffleMessage")
[10:26:11.387]                       }
[10:26:11.387]                       else if (inherits(cond, "warning")) {
[10:26:11.387]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.387]                         if (muffled) 
[10:26:11.387]                           invokeRestart("muffleWarning")
[10:26:11.387]                       }
[10:26:11.387]                       else if (inherits(cond, "condition")) {
[10:26:11.387]                         if (!is.null(pattern)) {
[10:26:11.387]                           computeRestarts <- base::computeRestarts
[10:26:11.387]                           grepl <- base::grepl
[10:26:11.387]                           restarts <- computeRestarts(cond)
[10:26:11.387]                           for (restart in restarts) {
[10:26:11.387]                             name <- restart$name
[10:26:11.387]                             if (is.null(name)) 
[10:26:11.387]                               next
[10:26:11.387]                             if (!grepl(pattern, name)) 
[10:26:11.387]                               next
[10:26:11.387]                             invokeRestart(restart)
[10:26:11.387]                             muffled <- TRUE
[10:26:11.387]                             break
[10:26:11.387]                           }
[10:26:11.387]                         }
[10:26:11.387]                       }
[10:26:11.387]                       invisible(muffled)
[10:26:11.387]                     }
[10:26:11.387]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.387]                   }
[10:26:11.387]                 }
[10:26:11.387]             }
[10:26:11.387]         }))
[10:26:11.387]     }, error = function(ex) {
[10:26:11.387]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.387]                 ...future.rng), started = ...future.startTime, 
[10:26:11.387]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.387]             version = "1.8"), class = "FutureResult")
[10:26:11.387]     }, finally = {
[10:26:11.387]         if (!identical(...future.workdir, getwd())) 
[10:26:11.387]             setwd(...future.workdir)
[10:26:11.387]         {
[10:26:11.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.387]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.387]             }
[10:26:11.387]             base::options(...future.oldOptions)
[10:26:11.387]             if (.Platform$OS.type == "windows") {
[10:26:11.387]                 old_names <- names(...future.oldEnvVars)
[10:26:11.387]                 envs <- base::Sys.getenv()
[10:26:11.387]                 names <- names(envs)
[10:26:11.387]                 common <- intersect(names, old_names)
[10:26:11.387]                 added <- setdiff(names, old_names)
[10:26:11.387]                 removed <- setdiff(old_names, names)
[10:26:11.387]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.387]                   envs[common]]
[10:26:11.387]                 NAMES <- toupper(changed)
[10:26:11.387]                 args <- list()
[10:26:11.387]                 for (kk in seq_along(NAMES)) {
[10:26:11.387]                   name <- changed[[kk]]
[10:26:11.387]                   NAME <- NAMES[[kk]]
[10:26:11.387]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.387]                     next
[10:26:11.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.387]                 }
[10:26:11.387]                 NAMES <- toupper(added)
[10:26:11.387]                 for (kk in seq_along(NAMES)) {
[10:26:11.387]                   name <- added[[kk]]
[10:26:11.387]                   NAME <- NAMES[[kk]]
[10:26:11.387]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.387]                     next
[10:26:11.387]                   args[[name]] <- ""
[10:26:11.387]                 }
[10:26:11.387]                 NAMES <- toupper(removed)
[10:26:11.387]                 for (kk in seq_along(NAMES)) {
[10:26:11.387]                   name <- removed[[kk]]
[10:26:11.387]                   NAME <- NAMES[[kk]]
[10:26:11.387]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.387]                     next
[10:26:11.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.387]                 }
[10:26:11.387]                 if (length(args) > 0) 
[10:26:11.387]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.387]             }
[10:26:11.387]             else {
[10:26:11.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.387]             }
[10:26:11.387]             {
[10:26:11.387]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.387]                   0L) {
[10:26:11.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.387]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.387]                   base::options(opts)
[10:26:11.387]                 }
[10:26:11.387]                 {
[10:26:11.387]                   {
[10:26:11.387]                     NULL
[10:26:11.387]                     RNGkind("Mersenne-Twister")
[10:26:11.387]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.387]                       inherits = FALSE)
[10:26:11.387]                   }
[10:26:11.387]                   options(future.plan = NULL)
[10:26:11.387]                   if (is.na(NA_character_)) 
[10:26:11.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.387]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.387]                   {
[10:26:11.387]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.387]                     if (!future$lazy) 
[10:26:11.387]                       future <- run(future)
[10:26:11.387]                     invisible(future)
[10:26:11.387]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.387]                 }
[10:26:11.387]             }
[10:26:11.387]         }
[10:26:11.387]     })
[10:26:11.387]     if (TRUE) {
[10:26:11.387]         base::sink(type = "output", split = FALSE)
[10:26:11.387]         if (TRUE) {
[10:26:11.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.387]         }
[10:26:11.387]         else {
[10:26:11.387]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.387]         }
[10:26:11.387]         base::close(...future.stdout)
[10:26:11.387]         ...future.stdout <- NULL
[10:26:11.387]     }
[10:26:11.387]     ...future.result$conditions <- ...future.conditions
[10:26:11.387]     ...future.result$finished <- base::Sys.time()
[10:26:11.387]     ...future.result
[10:26:11.387] }
[10:26:11.388] assign_globals() ...
[10:26:11.389] List of 1
[10:26:11.389]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a01fd760d0> 
[10:26:11.389]  - attr(*, "where")=List of 1
[10:26:11.389]   ..$ a:<environment: R_EmptyEnv> 
[10:26:11.389]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.389]  - attr(*, "resolved")= logi TRUE
[10:26:11.389]  - attr(*, "total_size")= num 10424
[10:26:11.389]  - attr(*, "already-done")= logi TRUE
[10:26:11.391] - copied ‘a’ to environment
[10:26:11.391] assign_globals() ... done
[10:26:11.391] plan(): Setting new future strategy stack:
[10:26:11.393] List of future strategies:
[10:26:11.393] 1. sequential:
[10:26:11.393]    - args: function (..., envir = parent.frame())
[10:26:11.393]    - tweaked: FALSE
[10:26:11.393]    - call: NULL
[10:26:11.393] plan(): nbrOfWorkers() = 1
[10:26:11.394] plan(): Setting new future strategy stack:
[10:26:11.394] List of future strategies:
[10:26:11.394] 1. sequential:
[10:26:11.394]    - args: function (..., envir = parent.frame())
[10:26:11.394]    - tweaked: FALSE
[10:26:11.394]    - call: plan(strategy)
[10:26:11.394] plan(): nbrOfWorkers() = 1
[10:26:11.394] SequentialFuture started (and completed)
[10:26:11.394] - Launch lazy future ... done
[10:26:11.394] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.395] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.395] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:11.396] 
[10:26:11.396] Searching for globals ... DONE
[10:26:11.396] - globals: [0] <none>
[10:26:11.396] getGlobalsAndPackages() ... DONE
[10:26:11.396] run() for ‘Future’ ...
[10:26:11.396] - state: ‘created’
[10:26:11.396] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.397] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.397] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.397]   - Field: ‘label’
[10:26:11.397]   - Field: ‘local’
[10:26:11.397]   - Field: ‘owner’
[10:26:11.397]   - Field: ‘envir’
[10:26:11.397]   - Field: ‘packages’
[10:26:11.397]   - Field: ‘gc’
[10:26:11.397]   - Field: ‘conditions’
[10:26:11.397]   - Field: ‘expr’
[10:26:11.398]   - Field: ‘uuid’
[10:26:11.398]   - Field: ‘seed’
[10:26:11.398]   - Field: ‘version’
[10:26:11.398]   - Field: ‘result’
[10:26:11.398]   - Field: ‘asynchronous’
[10:26:11.398]   - Field: ‘calls’
[10:26:11.398]   - Field: ‘globals’
[10:26:11.398]   - Field: ‘stdout’
[10:26:11.398]   - Field: ‘earlySignal’
[10:26:11.398]   - Field: ‘lazy’
[10:26:11.398]   - Field: ‘state’
[10:26:11.399] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.399] - Launch lazy future ...
[10:26:11.399] Packages needed by the future expression (n = 0): <none>
[10:26:11.399] Packages needed by future strategies (n = 0): <none>
[10:26:11.399] {
[10:26:11.399]     {
[10:26:11.399]         {
[10:26:11.399]             ...future.startTime <- base::Sys.time()
[10:26:11.399]             {
[10:26:11.399]                 {
[10:26:11.399]                   {
[10:26:11.399]                     base::local({
[10:26:11.399]                       has_future <- base::requireNamespace("future", 
[10:26:11.399]                         quietly = TRUE)
[10:26:11.399]                       if (has_future) {
[10:26:11.399]                         ns <- base::getNamespace("future")
[10:26:11.399]                         version <- ns[[".package"]][["version"]]
[10:26:11.399]                         if (is.null(version)) 
[10:26:11.399]                           version <- utils::packageVersion("future")
[10:26:11.399]                       }
[10:26:11.399]                       else {
[10:26:11.399]                         version <- NULL
[10:26:11.399]                       }
[10:26:11.399]                       if (!has_future || version < "1.8.0") {
[10:26:11.399]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.399]                           "", base::R.version$version.string), 
[10:26:11.399]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.399]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.399]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.399]                             "release", "version")], collapse = " "), 
[10:26:11.399]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.399]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.399]                           info)
[10:26:11.399]                         info <- base::paste(info, collapse = "; ")
[10:26:11.399]                         if (!has_future) {
[10:26:11.399]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.399]                             info)
[10:26:11.399]                         }
[10:26:11.399]                         else {
[10:26:11.399]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.399]                             info, version)
[10:26:11.399]                         }
[10:26:11.399]                         base::stop(msg)
[10:26:11.399]                       }
[10:26:11.399]                     })
[10:26:11.399]                   }
[10:26:11.399]                   options(future.plan = NULL)
[10:26:11.399]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.399]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.399]                 }
[10:26:11.399]                 ...future.workdir <- getwd()
[10:26:11.399]             }
[10:26:11.399]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.399]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.399]         }
[10:26:11.399]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.399]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:11.399]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.399]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.399]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.399]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.399]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.399]             base::names(...future.oldOptions))
[10:26:11.399]     }
[10:26:11.399]     if (FALSE) {
[10:26:11.399]     }
[10:26:11.399]     else {
[10:26:11.399]         if (TRUE) {
[10:26:11.399]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.399]                 open = "w")
[10:26:11.399]         }
[10:26:11.399]         else {
[10:26:11.399]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.399]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.399]         }
[10:26:11.399]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.399]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.399]             base::sink(type = "output", split = FALSE)
[10:26:11.399]             base::close(...future.stdout)
[10:26:11.399]         }, add = TRUE)
[10:26:11.399]     }
[10:26:11.399]     ...future.frame <- base::sys.nframe()
[10:26:11.399]     ...future.conditions <- base::list()
[10:26:11.399]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.399]     if (FALSE) {
[10:26:11.399]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.399]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.399]     }
[10:26:11.399]     ...future.result <- base::tryCatch({
[10:26:11.399]         base::withCallingHandlers({
[10:26:11.399]             ...future.value <- base::withVisible(base::local(1))
[10:26:11.399]             future::FutureResult(value = ...future.value$value, 
[10:26:11.399]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.399]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.399]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.399]                     ...future.globalenv.names))
[10:26:11.399]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.399]         }, condition = base::local({
[10:26:11.399]             c <- base::c
[10:26:11.399]             inherits <- base::inherits
[10:26:11.399]             invokeRestart <- base::invokeRestart
[10:26:11.399]             length <- base::length
[10:26:11.399]             list <- base::list
[10:26:11.399]             seq.int <- base::seq.int
[10:26:11.399]             signalCondition <- base::signalCondition
[10:26:11.399]             sys.calls <- base::sys.calls
[10:26:11.399]             `[[` <- base::`[[`
[10:26:11.399]             `+` <- base::`+`
[10:26:11.399]             `<<-` <- base::`<<-`
[10:26:11.399]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.399]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.399]                   3L)]
[10:26:11.399]             }
[10:26:11.399]             function(cond) {
[10:26:11.399]                 is_error <- inherits(cond, "error")
[10:26:11.399]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.399]                   NULL)
[10:26:11.399]                 if (is_error) {
[10:26:11.399]                   sessionInformation <- function() {
[10:26:11.399]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.399]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.399]                       search = base::search(), system = base::Sys.info())
[10:26:11.399]                   }
[10:26:11.399]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.399]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.399]                     cond$call), session = sessionInformation(), 
[10:26:11.399]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.399]                   signalCondition(cond)
[10:26:11.399]                 }
[10:26:11.399]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.399]                 "immediateCondition"))) {
[10:26:11.399]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.399]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.399]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.399]                   if (TRUE && !signal) {
[10:26:11.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.399]                     {
[10:26:11.399]                       inherits <- base::inherits
[10:26:11.399]                       invokeRestart <- base::invokeRestart
[10:26:11.399]                       is.null <- base::is.null
[10:26:11.399]                       muffled <- FALSE
[10:26:11.399]                       if (inherits(cond, "message")) {
[10:26:11.399]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.399]                         if (muffled) 
[10:26:11.399]                           invokeRestart("muffleMessage")
[10:26:11.399]                       }
[10:26:11.399]                       else if (inherits(cond, "warning")) {
[10:26:11.399]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.399]                         if (muffled) 
[10:26:11.399]                           invokeRestart("muffleWarning")
[10:26:11.399]                       }
[10:26:11.399]                       else if (inherits(cond, "condition")) {
[10:26:11.399]                         if (!is.null(pattern)) {
[10:26:11.399]                           computeRestarts <- base::computeRestarts
[10:26:11.399]                           grepl <- base::grepl
[10:26:11.399]                           restarts <- computeRestarts(cond)
[10:26:11.399]                           for (restart in restarts) {
[10:26:11.399]                             name <- restart$name
[10:26:11.399]                             if (is.null(name)) 
[10:26:11.399]                               next
[10:26:11.399]                             if (!grepl(pattern, name)) 
[10:26:11.399]                               next
[10:26:11.399]                             invokeRestart(restart)
[10:26:11.399]                             muffled <- TRUE
[10:26:11.399]                             break
[10:26:11.399]                           }
[10:26:11.399]                         }
[10:26:11.399]                       }
[10:26:11.399]                       invisible(muffled)
[10:26:11.399]                     }
[10:26:11.399]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.399]                   }
[10:26:11.399]                 }
[10:26:11.399]                 else {
[10:26:11.399]                   if (TRUE) {
[10:26:11.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.399]                     {
[10:26:11.399]                       inherits <- base::inherits
[10:26:11.399]                       invokeRestart <- base::invokeRestart
[10:26:11.399]                       is.null <- base::is.null
[10:26:11.399]                       muffled <- FALSE
[10:26:11.399]                       if (inherits(cond, "message")) {
[10:26:11.399]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.399]                         if (muffled) 
[10:26:11.399]                           invokeRestart("muffleMessage")
[10:26:11.399]                       }
[10:26:11.399]                       else if (inherits(cond, "warning")) {
[10:26:11.399]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.399]                         if (muffled) 
[10:26:11.399]                           invokeRestart("muffleWarning")
[10:26:11.399]                       }
[10:26:11.399]                       else if (inherits(cond, "condition")) {
[10:26:11.399]                         if (!is.null(pattern)) {
[10:26:11.399]                           computeRestarts <- base::computeRestarts
[10:26:11.399]                           grepl <- base::grepl
[10:26:11.399]                           restarts <- computeRestarts(cond)
[10:26:11.399]                           for (restart in restarts) {
[10:26:11.399]                             name <- restart$name
[10:26:11.399]                             if (is.null(name)) 
[10:26:11.399]                               next
[10:26:11.399]                             if (!grepl(pattern, name)) 
[10:26:11.399]                               next
[10:26:11.399]                             invokeRestart(restart)
[10:26:11.399]                             muffled <- TRUE
[10:26:11.399]                             break
[10:26:11.399]                           }
[10:26:11.399]                         }
[10:26:11.399]                       }
[10:26:11.399]                       invisible(muffled)
[10:26:11.399]                     }
[10:26:11.399]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.399]                   }
[10:26:11.399]                 }
[10:26:11.399]             }
[10:26:11.399]         }))
[10:26:11.399]     }, error = function(ex) {
[10:26:11.399]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.399]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.399]                 ...future.rng), started = ...future.startTime, 
[10:26:11.399]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.399]             version = "1.8"), class = "FutureResult")
[10:26:11.399]     }, finally = {
[10:26:11.399]         if (!identical(...future.workdir, getwd())) 
[10:26:11.399]             setwd(...future.workdir)
[10:26:11.399]         {
[10:26:11.399]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.399]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.399]             }
[10:26:11.399]             base::options(...future.oldOptions)
[10:26:11.399]             if (.Platform$OS.type == "windows") {
[10:26:11.399]                 old_names <- names(...future.oldEnvVars)
[10:26:11.399]                 envs <- base::Sys.getenv()
[10:26:11.399]                 names <- names(envs)
[10:26:11.399]                 common <- intersect(names, old_names)
[10:26:11.399]                 added <- setdiff(names, old_names)
[10:26:11.399]                 removed <- setdiff(old_names, names)
[10:26:11.399]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.399]                   envs[common]]
[10:26:11.399]                 NAMES <- toupper(changed)
[10:26:11.399]                 args <- list()
[10:26:11.399]                 for (kk in seq_along(NAMES)) {
[10:26:11.399]                   name <- changed[[kk]]
[10:26:11.399]                   NAME <- NAMES[[kk]]
[10:26:11.399]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.399]                     next
[10:26:11.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.399]                 }
[10:26:11.399]                 NAMES <- toupper(added)
[10:26:11.399]                 for (kk in seq_along(NAMES)) {
[10:26:11.399]                   name <- added[[kk]]
[10:26:11.399]                   NAME <- NAMES[[kk]]
[10:26:11.399]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.399]                     next
[10:26:11.399]                   args[[name]] <- ""
[10:26:11.399]                 }
[10:26:11.399]                 NAMES <- toupper(removed)
[10:26:11.399]                 for (kk in seq_along(NAMES)) {
[10:26:11.399]                   name <- removed[[kk]]
[10:26:11.399]                   NAME <- NAMES[[kk]]
[10:26:11.399]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.399]                     next
[10:26:11.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.399]                 }
[10:26:11.399]                 if (length(args) > 0) 
[10:26:11.399]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.399]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.399]             }
[10:26:11.399]             else {
[10:26:11.399]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.399]             }
[10:26:11.399]             {
[10:26:11.399]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.399]                   0L) {
[10:26:11.399]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.399]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.399]                   base::options(opts)
[10:26:11.399]                 }
[10:26:11.399]                 {
[10:26:11.399]                   {
[10:26:11.399]                     NULL
[10:26:11.399]                     RNGkind("Mersenne-Twister")
[10:26:11.399]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.399]                       inherits = FALSE)
[10:26:11.399]                   }
[10:26:11.399]                   options(future.plan = NULL)
[10:26:11.399]                   if (is.na(NA_character_)) 
[10:26:11.399]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.399]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.399]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.399]                   {
[10:26:11.399]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.399]                     if (!future$lazy) 
[10:26:11.399]                       future <- run(future)
[10:26:11.399]                     invisible(future)
[10:26:11.399]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.399]                 }
[10:26:11.399]             }
[10:26:11.399]         }
[10:26:11.399]     })
[10:26:11.399]     if (TRUE) {
[10:26:11.399]         base::sink(type = "output", split = FALSE)
[10:26:11.399]         if (TRUE) {
[10:26:11.399]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.399]         }
[10:26:11.399]         else {
[10:26:11.399]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.399]         }
[10:26:11.399]         base::close(...future.stdout)
[10:26:11.399]         ...future.stdout <- NULL
[10:26:11.399]     }
[10:26:11.399]     ...future.result$conditions <- ...future.conditions
[10:26:11.399]     ...future.result$finished <- base::Sys.time()
[10:26:11.399]     ...future.result
[10:26:11.399] }
[10:26:11.401] plan(): Setting new future strategy stack:
[10:26:11.401] List of future strategies:
[10:26:11.401] 1. sequential:
[10:26:11.401]    - args: function (..., envir = parent.frame())
[10:26:11.401]    - tweaked: FALSE
[10:26:11.401]    - call: NULL
[10:26:11.401] plan(): nbrOfWorkers() = 1
[10:26:11.402] plan(): Setting new future strategy stack:
[10:26:11.402] List of future strategies:
[10:26:11.402] 1. sequential:
[10:26:11.402]    - args: function (..., envir = parent.frame())
[10:26:11.402]    - tweaked: FALSE
[10:26:11.402]    - call: plan(strategy)
[10:26:11.402] plan(): nbrOfWorkers() = 1
[10:26:11.403] SequentialFuture started (and completed)
[10:26:11.403] - Launch lazy future ... done
[10:26:11.403] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.403] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.403] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:11.404] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:11.404] Searching for globals ... DONE
[10:26:11.404] Resolving globals: TRUE
[10:26:11.404] Resolving any globals that are futures ...
[10:26:11.404] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:11.405] Resolving any globals that are futures ... DONE
[10:26:11.405] Resolving futures part of globals (recursively) ...
[10:26:11.405] resolve() on list ...
[10:26:11.405]  recursive: 99
[10:26:11.405]  length: 1
[10:26:11.405]  elements: ‘a’
[10:26:11.405] resolved() for ‘SequentialFuture’ ...
[10:26:11.406] - state: ‘finished’
[10:26:11.406] - run: TRUE
[10:26:11.406] - result: ‘FutureResult’
[10:26:11.406] resolved() for ‘SequentialFuture’ ... done
[10:26:11.406] Future #1
[10:26:11.406] resolved() for ‘SequentialFuture’ ...
[10:26:11.406] - state: ‘finished’
[10:26:11.406] - run: TRUE
[10:26:11.406] - result: ‘FutureResult’
[10:26:11.406] resolved() for ‘SequentialFuture’ ... done
[10:26:11.407] A SequentialFuture was resolved
[10:26:11.407]  length: 0 (resolved future 1)
[10:26:11.407] resolve() on list ... DONE
[10:26:11.407] - globals: [1] ‘a’
[10:26:11.407] Resolving futures part of globals (recursively) ... DONE
[10:26:11.408] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[10:26:11.408] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[10:26:11.408] - globals: [1] ‘a’
[10:26:11.408] - packages: [1] ‘future’
[10:26:11.408] getGlobalsAndPackages() ... DONE
[10:26:11.408] run() for ‘Future’ ...
[10:26:11.409] - state: ‘created’
[10:26:11.409] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.409] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.409] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.409]   - Field: ‘label’
[10:26:11.409]   - Field: ‘local’
[10:26:11.409]   - Field: ‘owner’
[10:26:11.409]   - Field: ‘envir’
[10:26:11.410]   - Field: ‘packages’
[10:26:11.410]   - Field: ‘gc’
[10:26:11.410]   - Field: ‘conditions’
[10:26:11.410]   - Field: ‘expr’
[10:26:11.410]   - Field: ‘uuid’
[10:26:11.410]   - Field: ‘seed’
[10:26:11.410]   - Field: ‘version’
[10:26:11.410]   - Field: ‘result’
[10:26:11.410]   - Field: ‘asynchronous’
[10:26:11.410]   - Field: ‘calls’
[10:26:11.410]   - Field: ‘globals’
[10:26:11.410]   - Field: ‘stdout’
[10:26:11.411]   - Field: ‘earlySignal’
[10:26:11.411]   - Field: ‘lazy’
[10:26:11.411]   - Field: ‘state’
[10:26:11.411] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.411] - Launch lazy future ...
[10:26:11.411] Packages needed by the future expression (n = 1): ‘future’
[10:26:11.411] Packages needed by future strategies (n = 0): <none>
[10:26:11.412] {
[10:26:11.412]     {
[10:26:11.412]         {
[10:26:11.412]             ...future.startTime <- base::Sys.time()
[10:26:11.412]             {
[10:26:11.412]                 {
[10:26:11.412]                   {
[10:26:11.412]                     {
[10:26:11.412]                       base::local({
[10:26:11.412]                         has_future <- base::requireNamespace("future", 
[10:26:11.412]                           quietly = TRUE)
[10:26:11.412]                         if (has_future) {
[10:26:11.412]                           ns <- base::getNamespace("future")
[10:26:11.412]                           version <- ns[[".package"]][["version"]]
[10:26:11.412]                           if (is.null(version)) 
[10:26:11.412]                             version <- utils::packageVersion("future")
[10:26:11.412]                         }
[10:26:11.412]                         else {
[10:26:11.412]                           version <- NULL
[10:26:11.412]                         }
[10:26:11.412]                         if (!has_future || version < "1.8.0") {
[10:26:11.412]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.412]                             "", base::R.version$version.string), 
[10:26:11.412]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:11.412]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.412]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.412]                               "release", "version")], collapse = " "), 
[10:26:11.412]                             hostname = base::Sys.info()[["nodename"]])
[10:26:11.412]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.412]                             info)
[10:26:11.412]                           info <- base::paste(info, collapse = "; ")
[10:26:11.412]                           if (!has_future) {
[10:26:11.412]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.412]                               info)
[10:26:11.412]                           }
[10:26:11.412]                           else {
[10:26:11.412]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.412]                               info, version)
[10:26:11.412]                           }
[10:26:11.412]                           base::stop(msg)
[10:26:11.412]                         }
[10:26:11.412]                       })
[10:26:11.412]                     }
[10:26:11.412]                     base::local({
[10:26:11.412]                       for (pkg in "future") {
[10:26:11.412]                         base::loadNamespace(pkg)
[10:26:11.412]                         base::library(pkg, character.only = TRUE)
[10:26:11.412]                       }
[10:26:11.412]                     })
[10:26:11.412]                   }
[10:26:11.412]                   options(future.plan = NULL)
[10:26:11.412]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.412]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.412]                 }
[10:26:11.412]                 ...future.workdir <- getwd()
[10:26:11.412]             }
[10:26:11.412]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.412]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.412]         }
[10:26:11.412]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.412]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:11.412]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.412]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.412]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.412]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.412]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.412]             base::names(...future.oldOptions))
[10:26:11.412]     }
[10:26:11.412]     if (FALSE) {
[10:26:11.412]     }
[10:26:11.412]     else {
[10:26:11.412]         if (TRUE) {
[10:26:11.412]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.412]                 open = "w")
[10:26:11.412]         }
[10:26:11.412]         else {
[10:26:11.412]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.412]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.412]         }
[10:26:11.412]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.412]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.412]             base::sink(type = "output", split = FALSE)
[10:26:11.412]             base::close(...future.stdout)
[10:26:11.412]         }, add = TRUE)
[10:26:11.412]     }
[10:26:11.412]     ...future.frame <- base::sys.nframe()
[10:26:11.412]     ...future.conditions <- base::list()
[10:26:11.412]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.412]     if (FALSE) {
[10:26:11.412]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.412]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.412]     }
[10:26:11.412]     ...future.result <- base::tryCatch({
[10:26:11.412]         base::withCallingHandlers({
[10:26:11.412]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:26:11.412]                 1))
[10:26:11.412]             future::FutureResult(value = ...future.value$value, 
[10:26:11.412]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.412]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.412]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.412]                     ...future.globalenv.names))
[10:26:11.412]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.412]         }, condition = base::local({
[10:26:11.412]             c <- base::c
[10:26:11.412]             inherits <- base::inherits
[10:26:11.412]             invokeRestart <- base::invokeRestart
[10:26:11.412]             length <- base::length
[10:26:11.412]             list <- base::list
[10:26:11.412]             seq.int <- base::seq.int
[10:26:11.412]             signalCondition <- base::signalCondition
[10:26:11.412]             sys.calls <- base::sys.calls
[10:26:11.412]             `[[` <- base::`[[`
[10:26:11.412]             `+` <- base::`+`
[10:26:11.412]             `<<-` <- base::`<<-`
[10:26:11.412]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.412]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.412]                   3L)]
[10:26:11.412]             }
[10:26:11.412]             function(cond) {
[10:26:11.412]                 is_error <- inherits(cond, "error")
[10:26:11.412]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.412]                   NULL)
[10:26:11.412]                 if (is_error) {
[10:26:11.412]                   sessionInformation <- function() {
[10:26:11.412]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.412]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.412]                       search = base::search(), system = base::Sys.info())
[10:26:11.412]                   }
[10:26:11.412]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.412]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.412]                     cond$call), session = sessionInformation(), 
[10:26:11.412]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.412]                   signalCondition(cond)
[10:26:11.412]                 }
[10:26:11.412]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.412]                 "immediateCondition"))) {
[10:26:11.412]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.412]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.412]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.412]                   if (TRUE && !signal) {
[10:26:11.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.412]                     {
[10:26:11.412]                       inherits <- base::inherits
[10:26:11.412]                       invokeRestart <- base::invokeRestart
[10:26:11.412]                       is.null <- base::is.null
[10:26:11.412]                       muffled <- FALSE
[10:26:11.412]                       if (inherits(cond, "message")) {
[10:26:11.412]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.412]                         if (muffled) 
[10:26:11.412]                           invokeRestart("muffleMessage")
[10:26:11.412]                       }
[10:26:11.412]                       else if (inherits(cond, "warning")) {
[10:26:11.412]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.412]                         if (muffled) 
[10:26:11.412]                           invokeRestart("muffleWarning")
[10:26:11.412]                       }
[10:26:11.412]                       else if (inherits(cond, "condition")) {
[10:26:11.412]                         if (!is.null(pattern)) {
[10:26:11.412]                           computeRestarts <- base::computeRestarts
[10:26:11.412]                           grepl <- base::grepl
[10:26:11.412]                           restarts <- computeRestarts(cond)
[10:26:11.412]                           for (restart in restarts) {
[10:26:11.412]                             name <- restart$name
[10:26:11.412]                             if (is.null(name)) 
[10:26:11.412]                               next
[10:26:11.412]                             if (!grepl(pattern, name)) 
[10:26:11.412]                               next
[10:26:11.412]                             invokeRestart(restart)
[10:26:11.412]                             muffled <- TRUE
[10:26:11.412]                             break
[10:26:11.412]                           }
[10:26:11.412]                         }
[10:26:11.412]                       }
[10:26:11.412]                       invisible(muffled)
[10:26:11.412]                     }
[10:26:11.412]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.412]                   }
[10:26:11.412]                 }
[10:26:11.412]                 else {
[10:26:11.412]                   if (TRUE) {
[10:26:11.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.412]                     {
[10:26:11.412]                       inherits <- base::inherits
[10:26:11.412]                       invokeRestart <- base::invokeRestart
[10:26:11.412]                       is.null <- base::is.null
[10:26:11.412]                       muffled <- FALSE
[10:26:11.412]                       if (inherits(cond, "message")) {
[10:26:11.412]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.412]                         if (muffled) 
[10:26:11.412]                           invokeRestart("muffleMessage")
[10:26:11.412]                       }
[10:26:11.412]                       else if (inherits(cond, "warning")) {
[10:26:11.412]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.412]                         if (muffled) 
[10:26:11.412]                           invokeRestart("muffleWarning")
[10:26:11.412]                       }
[10:26:11.412]                       else if (inherits(cond, "condition")) {
[10:26:11.412]                         if (!is.null(pattern)) {
[10:26:11.412]                           computeRestarts <- base::computeRestarts
[10:26:11.412]                           grepl <- base::grepl
[10:26:11.412]                           restarts <- computeRestarts(cond)
[10:26:11.412]                           for (restart in restarts) {
[10:26:11.412]                             name <- restart$name
[10:26:11.412]                             if (is.null(name)) 
[10:26:11.412]                               next
[10:26:11.412]                             if (!grepl(pattern, name)) 
[10:26:11.412]                               next
[10:26:11.412]                             invokeRestart(restart)
[10:26:11.412]                             muffled <- TRUE
[10:26:11.412]                             break
[10:26:11.412]                           }
[10:26:11.412]                         }
[10:26:11.412]                       }
[10:26:11.412]                       invisible(muffled)
[10:26:11.412]                     }
[10:26:11.412]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.412]                   }
[10:26:11.412]                 }
[10:26:11.412]             }
[10:26:11.412]         }))
[10:26:11.412]     }, error = function(ex) {
[10:26:11.412]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.412]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.412]                 ...future.rng), started = ...future.startTime, 
[10:26:11.412]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.412]             version = "1.8"), class = "FutureResult")
[10:26:11.412]     }, finally = {
[10:26:11.412]         if (!identical(...future.workdir, getwd())) 
[10:26:11.412]             setwd(...future.workdir)
[10:26:11.412]         {
[10:26:11.412]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.412]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.412]             }
[10:26:11.412]             base::options(...future.oldOptions)
[10:26:11.412]             if (.Platform$OS.type == "windows") {
[10:26:11.412]                 old_names <- names(...future.oldEnvVars)
[10:26:11.412]                 envs <- base::Sys.getenv()
[10:26:11.412]                 names <- names(envs)
[10:26:11.412]                 common <- intersect(names, old_names)
[10:26:11.412]                 added <- setdiff(names, old_names)
[10:26:11.412]                 removed <- setdiff(old_names, names)
[10:26:11.412]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.412]                   envs[common]]
[10:26:11.412]                 NAMES <- toupper(changed)
[10:26:11.412]                 args <- list()
[10:26:11.412]                 for (kk in seq_along(NAMES)) {
[10:26:11.412]                   name <- changed[[kk]]
[10:26:11.412]                   NAME <- NAMES[[kk]]
[10:26:11.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.412]                     next
[10:26:11.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.412]                 }
[10:26:11.412]                 NAMES <- toupper(added)
[10:26:11.412]                 for (kk in seq_along(NAMES)) {
[10:26:11.412]                   name <- added[[kk]]
[10:26:11.412]                   NAME <- NAMES[[kk]]
[10:26:11.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.412]                     next
[10:26:11.412]                   args[[name]] <- ""
[10:26:11.412]                 }
[10:26:11.412]                 NAMES <- toupper(removed)
[10:26:11.412]                 for (kk in seq_along(NAMES)) {
[10:26:11.412]                   name <- removed[[kk]]
[10:26:11.412]                   NAME <- NAMES[[kk]]
[10:26:11.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.412]                     next
[10:26:11.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.412]                 }
[10:26:11.412]                 if (length(args) > 0) 
[10:26:11.412]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.412]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.412]             }
[10:26:11.412]             else {
[10:26:11.412]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.412]             }
[10:26:11.412]             {
[10:26:11.412]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.412]                   0L) {
[10:26:11.412]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.412]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.412]                   base::options(opts)
[10:26:11.412]                 }
[10:26:11.412]                 {
[10:26:11.412]                   {
[10:26:11.412]                     NULL
[10:26:11.412]                     RNGkind("Mersenne-Twister")
[10:26:11.412]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.412]                       inherits = FALSE)
[10:26:11.412]                   }
[10:26:11.412]                   options(future.plan = NULL)
[10:26:11.412]                   if (is.na(NA_character_)) 
[10:26:11.412]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.412]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.412]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.412]                   {
[10:26:11.412]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.412]                     if (!future$lazy) 
[10:26:11.412]                       future <- run(future)
[10:26:11.412]                     invisible(future)
[10:26:11.412]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.412]                 }
[10:26:11.412]             }
[10:26:11.412]         }
[10:26:11.412]     })
[10:26:11.412]     if (TRUE) {
[10:26:11.412]         base::sink(type = "output", split = FALSE)
[10:26:11.412]         if (TRUE) {
[10:26:11.412]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.412]         }
[10:26:11.412]         else {
[10:26:11.412]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.412]         }
[10:26:11.412]         base::close(...future.stdout)
[10:26:11.412]         ...future.stdout <- NULL
[10:26:11.412]     }
[10:26:11.412]     ...future.result$conditions <- ...future.conditions
[10:26:11.412]     ...future.result$finished <- base::Sys.time()
[10:26:11.412]     ...future.result
[10:26:11.412] }
[10:26:11.413] assign_globals() ...
[10:26:11.413] List of 1
[10:26:11.413]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a0204b8760> 
[10:26:11.413]  - attr(*, "where")=List of 1
[10:26:11.413]   ..$ a:<environment: R_EmptyEnv> 
[10:26:11.413]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.413]  - attr(*, "resolved")= logi TRUE
[10:26:11.413]  - attr(*, "total_size")= num 10424
[10:26:11.413]  - attr(*, "already-done")= logi TRUE
[10:26:11.416] - copied ‘a’ to environment
[10:26:11.416] assign_globals() ... done
[10:26:11.416] plan(): Setting new future strategy stack:
[10:26:11.416] List of future strategies:
[10:26:11.416] 1. sequential:
[10:26:11.416]    - args: function (..., envir = parent.frame())
[10:26:11.416]    - tweaked: FALSE
[10:26:11.416]    - call: NULL
[10:26:11.416] plan(): nbrOfWorkers() = 1
[10:26:11.417] plan(): Setting new future strategy stack:
[10:26:11.417] List of future strategies:
[10:26:11.417] 1. sequential:
[10:26:11.417]    - args: function (..., envir = parent.frame())
[10:26:11.417]    - tweaked: FALSE
[10:26:11.417]    - call: plan(strategy)
[10:26:11.418] plan(): nbrOfWorkers() = 1
[10:26:11.418] SequentialFuture started (and completed)
[10:26:11.418] - Launch lazy future ... done
[10:26:11.419] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.419] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.420] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:11.420] 
[10:26:11.420] Searching for globals ... DONE
[10:26:11.420] - globals: [0] <none>
[10:26:11.420] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.421] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.421] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:11.422] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:11.422] Searching for globals ... DONE
[10:26:11.422] Resolving globals: TRUE
[10:26:11.422] Resolving any globals that are futures ...
[10:26:11.422] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:11.422] Resolving any globals that are futures ... DONE
[10:26:11.422] Resolving futures part of globals (recursively) ...
[10:26:11.423] resolve() on list ...
[10:26:11.423]  recursive: 99
[10:26:11.423]  length: 1
[10:26:11.423]  elements: ‘a’
[10:26:11.423] run() for ‘Future’ ...
[10:26:11.423] - state: ‘created’
[10:26:11.423] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.423] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.424] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.424]   - Field: ‘label’
[10:26:11.424]   - Field: ‘local’
[10:26:11.424]   - Field: ‘owner’
[10:26:11.424]   - Field: ‘envir’
[10:26:11.424]   - Field: ‘packages’
[10:26:11.424]   - Field: ‘gc’
[10:26:11.424]   - Field: ‘conditions’
[10:26:11.424]   - Field: ‘expr’
[10:26:11.424]   - Field: ‘uuid’
[10:26:11.424]   - Field: ‘seed’
[10:26:11.425]   - Field: ‘version’
[10:26:11.425]   - Field: ‘result’
[10:26:11.425]   - Field: ‘asynchronous’
[10:26:11.425]   - Field: ‘calls’
[10:26:11.425]   - Field: ‘globals’
[10:26:11.425]   - Field: ‘stdout’
[10:26:11.425]   - Field: ‘earlySignal’
[10:26:11.425]   - Field: ‘lazy’
[10:26:11.425]   - Field: ‘state’
[10:26:11.425] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.425] - Launch lazy future ...
[10:26:11.426] Packages needed by the future expression (n = 0): <none>
[10:26:11.426] Packages needed by future strategies (n = 0): <none>
[10:26:11.426] {
[10:26:11.426]     {
[10:26:11.426]         {
[10:26:11.426]             ...future.startTime <- base::Sys.time()
[10:26:11.426]             {
[10:26:11.426]                 {
[10:26:11.426]                   {
[10:26:11.426]                     base::local({
[10:26:11.426]                       has_future <- base::requireNamespace("future", 
[10:26:11.426]                         quietly = TRUE)
[10:26:11.426]                       if (has_future) {
[10:26:11.426]                         ns <- base::getNamespace("future")
[10:26:11.426]                         version <- ns[[".package"]][["version"]]
[10:26:11.426]                         if (is.null(version)) 
[10:26:11.426]                           version <- utils::packageVersion("future")
[10:26:11.426]                       }
[10:26:11.426]                       else {
[10:26:11.426]                         version <- NULL
[10:26:11.426]                       }
[10:26:11.426]                       if (!has_future || version < "1.8.0") {
[10:26:11.426]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.426]                           "", base::R.version$version.string), 
[10:26:11.426]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.426]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.426]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.426]                             "release", "version")], collapse = " "), 
[10:26:11.426]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.426]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.426]                           info)
[10:26:11.426]                         info <- base::paste(info, collapse = "; ")
[10:26:11.426]                         if (!has_future) {
[10:26:11.426]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.426]                             info)
[10:26:11.426]                         }
[10:26:11.426]                         else {
[10:26:11.426]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.426]                             info, version)
[10:26:11.426]                         }
[10:26:11.426]                         base::stop(msg)
[10:26:11.426]                       }
[10:26:11.426]                     })
[10:26:11.426]                   }
[10:26:11.426]                   options(future.plan = NULL)
[10:26:11.426]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.426]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.426]                 }
[10:26:11.426]                 ...future.workdir <- getwd()
[10:26:11.426]             }
[10:26:11.426]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.426]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.426]         }
[10:26:11.426]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.426]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:11.426]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.426]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.426]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.426]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.426]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.426]             base::names(...future.oldOptions))
[10:26:11.426]     }
[10:26:11.426]     if (FALSE) {
[10:26:11.426]     }
[10:26:11.426]     else {
[10:26:11.426]         if (TRUE) {
[10:26:11.426]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.426]                 open = "w")
[10:26:11.426]         }
[10:26:11.426]         else {
[10:26:11.426]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.426]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.426]         }
[10:26:11.426]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.426]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.426]             base::sink(type = "output", split = FALSE)
[10:26:11.426]             base::close(...future.stdout)
[10:26:11.426]         }, add = TRUE)
[10:26:11.426]     }
[10:26:11.426]     ...future.frame <- base::sys.nframe()
[10:26:11.426]     ...future.conditions <- base::list()
[10:26:11.426]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.426]     if (FALSE) {
[10:26:11.426]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.426]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.426]     }
[10:26:11.426]     ...future.result <- base::tryCatch({
[10:26:11.426]         base::withCallingHandlers({
[10:26:11.426]             ...future.value <- base::withVisible(base::local(1))
[10:26:11.426]             future::FutureResult(value = ...future.value$value, 
[10:26:11.426]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.426]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.426]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.426]                     ...future.globalenv.names))
[10:26:11.426]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.426]         }, condition = base::local({
[10:26:11.426]             c <- base::c
[10:26:11.426]             inherits <- base::inherits
[10:26:11.426]             invokeRestart <- base::invokeRestart
[10:26:11.426]             length <- base::length
[10:26:11.426]             list <- base::list
[10:26:11.426]             seq.int <- base::seq.int
[10:26:11.426]             signalCondition <- base::signalCondition
[10:26:11.426]             sys.calls <- base::sys.calls
[10:26:11.426]             `[[` <- base::`[[`
[10:26:11.426]             `+` <- base::`+`
[10:26:11.426]             `<<-` <- base::`<<-`
[10:26:11.426]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.426]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.426]                   3L)]
[10:26:11.426]             }
[10:26:11.426]             function(cond) {
[10:26:11.426]                 is_error <- inherits(cond, "error")
[10:26:11.426]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.426]                   NULL)
[10:26:11.426]                 if (is_error) {
[10:26:11.426]                   sessionInformation <- function() {
[10:26:11.426]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.426]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.426]                       search = base::search(), system = base::Sys.info())
[10:26:11.426]                   }
[10:26:11.426]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.426]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.426]                     cond$call), session = sessionInformation(), 
[10:26:11.426]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.426]                   signalCondition(cond)
[10:26:11.426]                 }
[10:26:11.426]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.426]                 "immediateCondition"))) {
[10:26:11.426]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.426]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.426]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.426]                   if (TRUE && !signal) {
[10:26:11.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.426]                     {
[10:26:11.426]                       inherits <- base::inherits
[10:26:11.426]                       invokeRestart <- base::invokeRestart
[10:26:11.426]                       is.null <- base::is.null
[10:26:11.426]                       muffled <- FALSE
[10:26:11.426]                       if (inherits(cond, "message")) {
[10:26:11.426]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.426]                         if (muffled) 
[10:26:11.426]                           invokeRestart("muffleMessage")
[10:26:11.426]                       }
[10:26:11.426]                       else if (inherits(cond, "warning")) {
[10:26:11.426]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.426]                         if (muffled) 
[10:26:11.426]                           invokeRestart("muffleWarning")
[10:26:11.426]                       }
[10:26:11.426]                       else if (inherits(cond, "condition")) {
[10:26:11.426]                         if (!is.null(pattern)) {
[10:26:11.426]                           computeRestarts <- base::computeRestarts
[10:26:11.426]                           grepl <- base::grepl
[10:26:11.426]                           restarts <- computeRestarts(cond)
[10:26:11.426]                           for (restart in restarts) {
[10:26:11.426]                             name <- restart$name
[10:26:11.426]                             if (is.null(name)) 
[10:26:11.426]                               next
[10:26:11.426]                             if (!grepl(pattern, name)) 
[10:26:11.426]                               next
[10:26:11.426]                             invokeRestart(restart)
[10:26:11.426]                             muffled <- TRUE
[10:26:11.426]                             break
[10:26:11.426]                           }
[10:26:11.426]                         }
[10:26:11.426]                       }
[10:26:11.426]                       invisible(muffled)
[10:26:11.426]                     }
[10:26:11.426]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.426]                   }
[10:26:11.426]                 }
[10:26:11.426]                 else {
[10:26:11.426]                   if (TRUE) {
[10:26:11.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.426]                     {
[10:26:11.426]                       inherits <- base::inherits
[10:26:11.426]                       invokeRestart <- base::invokeRestart
[10:26:11.426]                       is.null <- base::is.null
[10:26:11.426]                       muffled <- FALSE
[10:26:11.426]                       if (inherits(cond, "message")) {
[10:26:11.426]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.426]                         if (muffled) 
[10:26:11.426]                           invokeRestart("muffleMessage")
[10:26:11.426]                       }
[10:26:11.426]                       else if (inherits(cond, "warning")) {
[10:26:11.426]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.426]                         if (muffled) 
[10:26:11.426]                           invokeRestart("muffleWarning")
[10:26:11.426]                       }
[10:26:11.426]                       else if (inherits(cond, "condition")) {
[10:26:11.426]                         if (!is.null(pattern)) {
[10:26:11.426]                           computeRestarts <- base::computeRestarts
[10:26:11.426]                           grepl <- base::grepl
[10:26:11.426]                           restarts <- computeRestarts(cond)
[10:26:11.426]                           for (restart in restarts) {
[10:26:11.426]                             name <- restart$name
[10:26:11.426]                             if (is.null(name)) 
[10:26:11.426]                               next
[10:26:11.426]                             if (!grepl(pattern, name)) 
[10:26:11.426]                               next
[10:26:11.426]                             invokeRestart(restart)
[10:26:11.426]                             muffled <- TRUE
[10:26:11.426]                             break
[10:26:11.426]                           }
[10:26:11.426]                         }
[10:26:11.426]                       }
[10:26:11.426]                       invisible(muffled)
[10:26:11.426]                     }
[10:26:11.426]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.426]                   }
[10:26:11.426]                 }
[10:26:11.426]             }
[10:26:11.426]         }))
[10:26:11.426]     }, error = function(ex) {
[10:26:11.426]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.426]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.426]                 ...future.rng), started = ...future.startTime, 
[10:26:11.426]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.426]             version = "1.8"), class = "FutureResult")
[10:26:11.426]     }, finally = {
[10:26:11.426]         if (!identical(...future.workdir, getwd())) 
[10:26:11.426]             setwd(...future.workdir)
[10:26:11.426]         {
[10:26:11.426]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.426]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.426]             }
[10:26:11.426]             base::options(...future.oldOptions)
[10:26:11.426]             if (.Platform$OS.type == "windows") {
[10:26:11.426]                 old_names <- names(...future.oldEnvVars)
[10:26:11.426]                 envs <- base::Sys.getenv()
[10:26:11.426]                 names <- names(envs)
[10:26:11.426]                 common <- intersect(names, old_names)
[10:26:11.426]                 added <- setdiff(names, old_names)
[10:26:11.426]                 removed <- setdiff(old_names, names)
[10:26:11.426]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.426]                   envs[common]]
[10:26:11.426]                 NAMES <- toupper(changed)
[10:26:11.426]                 args <- list()
[10:26:11.426]                 for (kk in seq_along(NAMES)) {
[10:26:11.426]                   name <- changed[[kk]]
[10:26:11.426]                   NAME <- NAMES[[kk]]
[10:26:11.426]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.426]                     next
[10:26:11.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.426]                 }
[10:26:11.426]                 NAMES <- toupper(added)
[10:26:11.426]                 for (kk in seq_along(NAMES)) {
[10:26:11.426]                   name <- added[[kk]]
[10:26:11.426]                   NAME <- NAMES[[kk]]
[10:26:11.426]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.426]                     next
[10:26:11.426]                   args[[name]] <- ""
[10:26:11.426]                 }
[10:26:11.426]                 NAMES <- toupper(removed)
[10:26:11.426]                 for (kk in seq_along(NAMES)) {
[10:26:11.426]                   name <- removed[[kk]]
[10:26:11.426]                   NAME <- NAMES[[kk]]
[10:26:11.426]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.426]                     next
[10:26:11.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.426]                 }
[10:26:11.426]                 if (length(args) > 0) 
[10:26:11.426]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.426]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.426]             }
[10:26:11.426]             else {
[10:26:11.426]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.426]             }
[10:26:11.426]             {
[10:26:11.426]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.426]                   0L) {
[10:26:11.426]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.426]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.426]                   base::options(opts)
[10:26:11.426]                 }
[10:26:11.426]                 {
[10:26:11.426]                   {
[10:26:11.426]                     NULL
[10:26:11.426]                     RNGkind("Mersenne-Twister")
[10:26:11.426]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.426]                       inherits = FALSE)
[10:26:11.426]                   }
[10:26:11.426]                   options(future.plan = NULL)
[10:26:11.426]                   if (is.na(NA_character_)) 
[10:26:11.426]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.426]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.426]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.426]                   {
[10:26:11.426]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.426]                     if (!future$lazy) 
[10:26:11.426]                       future <- run(future)
[10:26:11.426]                     invisible(future)
[10:26:11.426]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.426]                 }
[10:26:11.426]             }
[10:26:11.426]         }
[10:26:11.426]     })
[10:26:11.426]     if (TRUE) {
[10:26:11.426]         base::sink(type = "output", split = FALSE)
[10:26:11.426]         if (TRUE) {
[10:26:11.426]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.426]         }
[10:26:11.426]         else {
[10:26:11.426]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.426]         }
[10:26:11.426]         base::close(...future.stdout)
[10:26:11.426]         ...future.stdout <- NULL
[10:26:11.426]     }
[10:26:11.426]     ...future.result$conditions <- ...future.conditions
[10:26:11.426]     ...future.result$finished <- base::Sys.time()
[10:26:11.426]     ...future.result
[10:26:11.426] }
[10:26:11.428] plan(): Setting new future strategy stack:
[10:26:11.428] List of future strategies:
[10:26:11.428] 1. sequential:
[10:26:11.428]    - args: function (..., envir = parent.frame())
[10:26:11.428]    - tweaked: FALSE
[10:26:11.428]    - call: NULL
[10:26:11.428] plan(): nbrOfWorkers() = 1
[10:26:11.429] plan(): Setting new future strategy stack:
[10:26:11.429] List of future strategies:
[10:26:11.429] 1. sequential:
[10:26:11.429]    - args: function (..., envir = parent.frame())
[10:26:11.429]    - tweaked: FALSE
[10:26:11.429]    - call: plan(strategy)
[10:26:11.429] plan(): nbrOfWorkers() = 1
[10:26:11.429] SequentialFuture started (and completed)
[10:26:11.430] - Launch lazy future ... done
[10:26:11.430] run() for ‘SequentialFuture’ ... done
[10:26:11.430] resolved() for ‘SequentialFuture’ ...
[10:26:11.430] - state: ‘finished’
[10:26:11.430] - run: TRUE
[10:26:11.430] - result: ‘FutureResult’
[10:26:11.430] resolved() for ‘SequentialFuture’ ... done
[10:26:11.430] Future #1
[10:26:11.430] resolved() for ‘SequentialFuture’ ...
[10:26:11.430] - state: ‘finished’
[10:26:11.431] - run: TRUE
[10:26:11.431] - result: ‘FutureResult’
[10:26:11.431] resolved() for ‘SequentialFuture’ ... done
[10:26:11.431] A SequentialFuture was resolved
[10:26:11.431]  length: 0 (resolved future 1)
[10:26:11.431] resolve() on list ... DONE
[10:26:11.431] - globals: [1] ‘a’
[10:26:11.431] Resolving futures part of globals (recursively) ... DONE
[10:26:11.432] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[10:26:11.432] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[10:26:11.432] - globals: [1] ‘a’
[10:26:11.432] - packages: [1] ‘future’
[10:26:11.432] getGlobalsAndPackages() ... DONE
[10:26:11.433] run() for ‘Future’ ...
[10:26:11.433] - state: ‘created’
[10:26:11.433] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.433] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.433] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.433]   - Field: ‘label’
[10:26:11.433]   - Field: ‘local’
[10:26:11.434]   - Field: ‘owner’
[10:26:11.434]   - Field: ‘envir’
[10:26:11.434]   - Field: ‘packages’
[10:26:11.434]   - Field: ‘gc’
[10:26:11.434]   - Field: ‘conditions’
[10:26:11.434]   - Field: ‘expr’
[10:26:11.434]   - Field: ‘uuid’
[10:26:11.434]   - Field: ‘seed’
[10:26:11.434]   - Field: ‘version’
[10:26:11.434]   - Field: ‘result’
[10:26:11.434]   - Field: ‘asynchronous’
[10:26:11.434]   - Field: ‘calls’
[10:26:11.435]   - Field: ‘globals’
[10:26:11.435]   - Field: ‘stdout’
[10:26:11.435]   - Field: ‘earlySignal’
[10:26:11.435]   - Field: ‘lazy’
[10:26:11.435]   - Field: ‘state’
[10:26:11.435] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.435] - Launch lazy future ...
[10:26:11.435] Packages needed by the future expression (n = 1): ‘future’
[10:26:11.435] Packages needed by future strategies (n = 0): <none>
[10:26:11.436] {
[10:26:11.436]     {
[10:26:11.436]         {
[10:26:11.436]             ...future.startTime <- base::Sys.time()
[10:26:11.436]             {
[10:26:11.436]                 {
[10:26:11.436]                   {
[10:26:11.436]                     {
[10:26:11.436]                       base::local({
[10:26:11.436]                         has_future <- base::requireNamespace("future", 
[10:26:11.436]                           quietly = TRUE)
[10:26:11.436]                         if (has_future) {
[10:26:11.436]                           ns <- base::getNamespace("future")
[10:26:11.436]                           version <- ns[[".package"]][["version"]]
[10:26:11.436]                           if (is.null(version)) 
[10:26:11.436]                             version <- utils::packageVersion("future")
[10:26:11.436]                         }
[10:26:11.436]                         else {
[10:26:11.436]                           version <- NULL
[10:26:11.436]                         }
[10:26:11.436]                         if (!has_future || version < "1.8.0") {
[10:26:11.436]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.436]                             "", base::R.version$version.string), 
[10:26:11.436]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:11.436]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.436]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.436]                               "release", "version")], collapse = " "), 
[10:26:11.436]                             hostname = base::Sys.info()[["nodename"]])
[10:26:11.436]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.436]                             info)
[10:26:11.436]                           info <- base::paste(info, collapse = "; ")
[10:26:11.436]                           if (!has_future) {
[10:26:11.436]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.436]                               info)
[10:26:11.436]                           }
[10:26:11.436]                           else {
[10:26:11.436]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.436]                               info, version)
[10:26:11.436]                           }
[10:26:11.436]                           base::stop(msg)
[10:26:11.436]                         }
[10:26:11.436]                       })
[10:26:11.436]                     }
[10:26:11.436]                     base::local({
[10:26:11.436]                       for (pkg in "future") {
[10:26:11.436]                         base::loadNamespace(pkg)
[10:26:11.436]                         base::library(pkg, character.only = TRUE)
[10:26:11.436]                       }
[10:26:11.436]                     })
[10:26:11.436]                   }
[10:26:11.436]                   options(future.plan = NULL)
[10:26:11.436]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.436]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.436]                 }
[10:26:11.436]                 ...future.workdir <- getwd()
[10:26:11.436]             }
[10:26:11.436]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.436]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.436]         }
[10:26:11.436]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.436]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:11.436]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.436]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.436]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.436]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.436]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.436]             base::names(...future.oldOptions))
[10:26:11.436]     }
[10:26:11.436]     if (FALSE) {
[10:26:11.436]     }
[10:26:11.436]     else {
[10:26:11.436]         if (TRUE) {
[10:26:11.436]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.436]                 open = "w")
[10:26:11.436]         }
[10:26:11.436]         else {
[10:26:11.436]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.436]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.436]         }
[10:26:11.436]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.436]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.436]             base::sink(type = "output", split = FALSE)
[10:26:11.436]             base::close(...future.stdout)
[10:26:11.436]         }, add = TRUE)
[10:26:11.436]     }
[10:26:11.436]     ...future.frame <- base::sys.nframe()
[10:26:11.436]     ...future.conditions <- base::list()
[10:26:11.436]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.436]     if (FALSE) {
[10:26:11.436]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.436]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.436]     }
[10:26:11.436]     ...future.result <- base::tryCatch({
[10:26:11.436]         base::withCallingHandlers({
[10:26:11.436]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:26:11.436]                 1))
[10:26:11.436]             future::FutureResult(value = ...future.value$value, 
[10:26:11.436]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.436]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.436]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.436]                     ...future.globalenv.names))
[10:26:11.436]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.436]         }, condition = base::local({
[10:26:11.436]             c <- base::c
[10:26:11.436]             inherits <- base::inherits
[10:26:11.436]             invokeRestart <- base::invokeRestart
[10:26:11.436]             length <- base::length
[10:26:11.436]             list <- base::list
[10:26:11.436]             seq.int <- base::seq.int
[10:26:11.436]             signalCondition <- base::signalCondition
[10:26:11.436]             sys.calls <- base::sys.calls
[10:26:11.436]             `[[` <- base::`[[`
[10:26:11.436]             `+` <- base::`+`
[10:26:11.436]             `<<-` <- base::`<<-`
[10:26:11.436]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.436]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.436]                   3L)]
[10:26:11.436]             }
[10:26:11.436]             function(cond) {
[10:26:11.436]                 is_error <- inherits(cond, "error")
[10:26:11.436]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.436]                   NULL)
[10:26:11.436]                 if (is_error) {
[10:26:11.436]                   sessionInformation <- function() {
[10:26:11.436]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.436]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.436]                       search = base::search(), system = base::Sys.info())
[10:26:11.436]                   }
[10:26:11.436]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.436]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.436]                     cond$call), session = sessionInformation(), 
[10:26:11.436]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.436]                   signalCondition(cond)
[10:26:11.436]                 }
[10:26:11.436]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.436]                 "immediateCondition"))) {
[10:26:11.436]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.436]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.436]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.436]                   if (TRUE && !signal) {
[10:26:11.436]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.436]                     {
[10:26:11.436]                       inherits <- base::inherits
[10:26:11.436]                       invokeRestart <- base::invokeRestart
[10:26:11.436]                       is.null <- base::is.null
[10:26:11.436]                       muffled <- FALSE
[10:26:11.436]                       if (inherits(cond, "message")) {
[10:26:11.436]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.436]                         if (muffled) 
[10:26:11.436]                           invokeRestart("muffleMessage")
[10:26:11.436]                       }
[10:26:11.436]                       else if (inherits(cond, "warning")) {
[10:26:11.436]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.436]                         if (muffled) 
[10:26:11.436]                           invokeRestart("muffleWarning")
[10:26:11.436]                       }
[10:26:11.436]                       else if (inherits(cond, "condition")) {
[10:26:11.436]                         if (!is.null(pattern)) {
[10:26:11.436]                           computeRestarts <- base::computeRestarts
[10:26:11.436]                           grepl <- base::grepl
[10:26:11.436]                           restarts <- computeRestarts(cond)
[10:26:11.436]                           for (restart in restarts) {
[10:26:11.436]                             name <- restart$name
[10:26:11.436]                             if (is.null(name)) 
[10:26:11.436]                               next
[10:26:11.436]                             if (!grepl(pattern, name)) 
[10:26:11.436]                               next
[10:26:11.436]                             invokeRestart(restart)
[10:26:11.436]                             muffled <- TRUE
[10:26:11.436]                             break
[10:26:11.436]                           }
[10:26:11.436]                         }
[10:26:11.436]                       }
[10:26:11.436]                       invisible(muffled)
[10:26:11.436]                     }
[10:26:11.436]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.436]                   }
[10:26:11.436]                 }
[10:26:11.436]                 else {
[10:26:11.436]                   if (TRUE) {
[10:26:11.436]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.436]                     {
[10:26:11.436]                       inherits <- base::inherits
[10:26:11.436]                       invokeRestart <- base::invokeRestart
[10:26:11.436]                       is.null <- base::is.null
[10:26:11.436]                       muffled <- FALSE
[10:26:11.436]                       if (inherits(cond, "message")) {
[10:26:11.436]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.436]                         if (muffled) 
[10:26:11.436]                           invokeRestart("muffleMessage")
[10:26:11.436]                       }
[10:26:11.436]                       else if (inherits(cond, "warning")) {
[10:26:11.436]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.436]                         if (muffled) 
[10:26:11.436]                           invokeRestart("muffleWarning")
[10:26:11.436]                       }
[10:26:11.436]                       else if (inherits(cond, "condition")) {
[10:26:11.436]                         if (!is.null(pattern)) {
[10:26:11.436]                           computeRestarts <- base::computeRestarts
[10:26:11.436]                           grepl <- base::grepl
[10:26:11.436]                           restarts <- computeRestarts(cond)
[10:26:11.436]                           for (restart in restarts) {
[10:26:11.436]                             name <- restart$name
[10:26:11.436]                             if (is.null(name)) 
[10:26:11.436]                               next
[10:26:11.436]                             if (!grepl(pattern, name)) 
[10:26:11.436]                               next
[10:26:11.436]                             invokeRestart(restart)
[10:26:11.436]                             muffled <- TRUE
[10:26:11.436]                             break
[10:26:11.436]                           }
[10:26:11.436]                         }
[10:26:11.436]                       }
[10:26:11.436]                       invisible(muffled)
[10:26:11.436]                     }
[10:26:11.436]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.436]                   }
[10:26:11.436]                 }
[10:26:11.436]             }
[10:26:11.436]         }))
[10:26:11.436]     }, error = function(ex) {
[10:26:11.436]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.436]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.436]                 ...future.rng), started = ...future.startTime, 
[10:26:11.436]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.436]             version = "1.8"), class = "FutureResult")
[10:26:11.436]     }, finally = {
[10:26:11.436]         if (!identical(...future.workdir, getwd())) 
[10:26:11.436]             setwd(...future.workdir)
[10:26:11.436]         {
[10:26:11.436]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.436]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.436]             }
[10:26:11.436]             base::options(...future.oldOptions)
[10:26:11.436]             if (.Platform$OS.type == "windows") {
[10:26:11.436]                 old_names <- names(...future.oldEnvVars)
[10:26:11.436]                 envs <- base::Sys.getenv()
[10:26:11.436]                 names <- names(envs)
[10:26:11.436]                 common <- intersect(names, old_names)
[10:26:11.436]                 added <- setdiff(names, old_names)
[10:26:11.436]                 removed <- setdiff(old_names, names)
[10:26:11.436]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.436]                   envs[common]]
[10:26:11.436]                 NAMES <- toupper(changed)
[10:26:11.436]                 args <- list()
[10:26:11.436]                 for (kk in seq_along(NAMES)) {
[10:26:11.436]                   name <- changed[[kk]]
[10:26:11.436]                   NAME <- NAMES[[kk]]
[10:26:11.436]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.436]                     next
[10:26:11.436]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.436]                 }
[10:26:11.436]                 NAMES <- toupper(added)
[10:26:11.436]                 for (kk in seq_along(NAMES)) {
[10:26:11.436]                   name <- added[[kk]]
[10:26:11.436]                   NAME <- NAMES[[kk]]
[10:26:11.436]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.436]                     next
[10:26:11.436]                   args[[name]] <- ""
[10:26:11.436]                 }
[10:26:11.436]                 NAMES <- toupper(removed)
[10:26:11.436]                 for (kk in seq_along(NAMES)) {
[10:26:11.436]                   name <- removed[[kk]]
[10:26:11.436]                   NAME <- NAMES[[kk]]
[10:26:11.436]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.436]                     next
[10:26:11.436]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.436]                 }
[10:26:11.436]                 if (length(args) > 0) 
[10:26:11.436]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.436]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.436]             }
[10:26:11.436]             else {
[10:26:11.436]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.436]             }
[10:26:11.436]             {
[10:26:11.436]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.436]                   0L) {
[10:26:11.436]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.436]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.436]                   base::options(opts)
[10:26:11.436]                 }
[10:26:11.436]                 {
[10:26:11.436]                   {
[10:26:11.436]                     NULL
[10:26:11.436]                     RNGkind("Mersenne-Twister")
[10:26:11.436]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.436]                       inherits = FALSE)
[10:26:11.436]                   }
[10:26:11.436]                   options(future.plan = NULL)
[10:26:11.436]                   if (is.na(NA_character_)) 
[10:26:11.436]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.436]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.436]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.436]                   {
[10:26:11.436]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.436]                     if (!future$lazy) 
[10:26:11.436]                       future <- run(future)
[10:26:11.436]                     invisible(future)
[10:26:11.436]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.436]                 }
[10:26:11.436]             }
[10:26:11.436]         }
[10:26:11.436]     })
[10:26:11.436]     if (TRUE) {
[10:26:11.436]         base::sink(type = "output", split = FALSE)
[10:26:11.436]         if (TRUE) {
[10:26:11.436]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.436]         }
[10:26:11.436]         else {
[10:26:11.436]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.436]         }
[10:26:11.436]         base::close(...future.stdout)
[10:26:11.436]         ...future.stdout <- NULL
[10:26:11.436]     }
[10:26:11.436]     ...future.result$conditions <- ...future.conditions
[10:26:11.436]     ...future.result$finished <- base::Sys.time()
[10:26:11.436]     ...future.result
[10:26:11.436] }
[10:26:11.437] assign_globals() ...
[10:26:11.437] List of 1
[10:26:11.437]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a020a531d0> 
[10:26:11.437]  - attr(*, "where")=List of 1
[10:26:11.437]   ..$ a:<environment: R_EmptyEnv> 
[10:26:11.437]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.437]  - attr(*, "resolved")= logi TRUE
[10:26:11.437]  - attr(*, "total_size")= num 10592
[10:26:11.437]  - attr(*, "already-done")= logi TRUE
[10:26:11.440] - copied ‘a’ to environment
[10:26:11.440] assign_globals() ... done
[10:26:11.440] plan(): Setting new future strategy stack:
[10:26:11.440] List of future strategies:
[10:26:11.440] 1. sequential:
[10:26:11.440]    - args: function (..., envir = parent.frame())
[10:26:11.440]    - tweaked: FALSE
[10:26:11.440]    - call: NULL
[10:26:11.441] plan(): nbrOfWorkers() = 1
[10:26:11.441] plan(): Setting new future strategy stack:
[10:26:11.441] List of future strategies:
[10:26:11.441] 1. sequential:
[10:26:11.441]    - args: function (..., envir = parent.frame())
[10:26:11.441]    - tweaked: FALSE
[10:26:11.441]    - call: plan(strategy)
[10:26:11.442] plan(): nbrOfWorkers() = 1
[10:26:11.442] SequentialFuture started (and completed)
[10:26:11.442] - Launch lazy future ... done
[10:26:11.442] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.443] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.443] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:11.443] 
[10:26:11.443] Searching for globals ... DONE
[10:26:11.443] - globals: [0] <none>
[10:26:11.443] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.445] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.445] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:11.446] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:11.446] Searching for globals ... DONE
[10:26:11.446] Resolving globals: TRUE
[10:26:11.446] Resolving any globals that are futures ...
[10:26:11.446] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:11.446] Resolving any globals that are futures ... DONE
[10:26:11.447] Resolving futures part of globals (recursively) ...
[10:26:11.447] resolve() on list ...
[10:26:11.447]  recursive: 99
[10:26:11.447]  length: 1
[10:26:11.447]  elements: ‘a’
[10:26:11.447] run() for ‘Future’ ...
[10:26:11.447] - state: ‘created’
[10:26:11.447] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.448] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.448] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.448]   - Field: ‘label’
[10:26:11.448]   - Field: ‘local’
[10:26:11.448]   - Field: ‘owner’
[10:26:11.448]   - Field: ‘envir’
[10:26:11.448]   - Field: ‘packages’
[10:26:11.448]   - Field: ‘gc’
[10:26:11.448]   - Field: ‘conditions’
[10:26:11.448]   - Field: ‘expr’
[10:26:11.449]   - Field: ‘uuid’
[10:26:11.449]   - Field: ‘seed’
[10:26:11.449]   - Field: ‘version’
[10:26:11.449]   - Field: ‘result’
[10:26:11.449]   - Field: ‘asynchronous’
[10:26:11.449]   - Field: ‘calls’
[10:26:11.449]   - Field: ‘globals’
[10:26:11.449]   - Field: ‘stdout’
[10:26:11.449]   - Field: ‘earlySignal’
[10:26:11.449]   - Field: ‘lazy’
[10:26:11.449]   - Field: ‘state’
[10:26:11.450] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.450] - Launch lazy future ...
[10:26:11.450] Packages needed by the future expression (n = 0): <none>
[10:26:11.450] Packages needed by future strategies (n = 0): <none>
[10:26:11.450] {
[10:26:11.450]     {
[10:26:11.450]         {
[10:26:11.450]             ...future.startTime <- base::Sys.time()
[10:26:11.450]             {
[10:26:11.450]                 {
[10:26:11.450]                   {
[10:26:11.450]                     base::local({
[10:26:11.450]                       has_future <- base::requireNamespace("future", 
[10:26:11.450]                         quietly = TRUE)
[10:26:11.450]                       if (has_future) {
[10:26:11.450]                         ns <- base::getNamespace("future")
[10:26:11.450]                         version <- ns[[".package"]][["version"]]
[10:26:11.450]                         if (is.null(version)) 
[10:26:11.450]                           version <- utils::packageVersion("future")
[10:26:11.450]                       }
[10:26:11.450]                       else {
[10:26:11.450]                         version <- NULL
[10:26:11.450]                       }
[10:26:11.450]                       if (!has_future || version < "1.8.0") {
[10:26:11.450]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.450]                           "", base::R.version$version.string), 
[10:26:11.450]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.450]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.450]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.450]                             "release", "version")], collapse = " "), 
[10:26:11.450]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.450]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.450]                           info)
[10:26:11.450]                         info <- base::paste(info, collapse = "; ")
[10:26:11.450]                         if (!has_future) {
[10:26:11.450]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.450]                             info)
[10:26:11.450]                         }
[10:26:11.450]                         else {
[10:26:11.450]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.450]                             info, version)
[10:26:11.450]                         }
[10:26:11.450]                         base::stop(msg)
[10:26:11.450]                       }
[10:26:11.450]                     })
[10:26:11.450]                   }
[10:26:11.450]                   options(future.plan = NULL)
[10:26:11.450]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.450]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.450]                 }
[10:26:11.450]                 ...future.workdir <- getwd()
[10:26:11.450]             }
[10:26:11.450]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.450]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.450]         }
[10:26:11.450]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.450]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:11.450]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.450]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.450]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.450]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.450]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.450]             base::names(...future.oldOptions))
[10:26:11.450]     }
[10:26:11.450]     if (FALSE) {
[10:26:11.450]     }
[10:26:11.450]     else {
[10:26:11.450]         if (TRUE) {
[10:26:11.450]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.450]                 open = "w")
[10:26:11.450]         }
[10:26:11.450]         else {
[10:26:11.450]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.450]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.450]         }
[10:26:11.450]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.450]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.450]             base::sink(type = "output", split = FALSE)
[10:26:11.450]             base::close(...future.stdout)
[10:26:11.450]         }, add = TRUE)
[10:26:11.450]     }
[10:26:11.450]     ...future.frame <- base::sys.nframe()
[10:26:11.450]     ...future.conditions <- base::list()
[10:26:11.450]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.450]     if (FALSE) {
[10:26:11.450]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.450]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.450]     }
[10:26:11.450]     ...future.result <- base::tryCatch({
[10:26:11.450]         base::withCallingHandlers({
[10:26:11.450]             ...future.value <- base::withVisible(base::local(1))
[10:26:11.450]             future::FutureResult(value = ...future.value$value, 
[10:26:11.450]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.450]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.450]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.450]                     ...future.globalenv.names))
[10:26:11.450]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.450]         }, condition = base::local({
[10:26:11.450]             c <- base::c
[10:26:11.450]             inherits <- base::inherits
[10:26:11.450]             invokeRestart <- base::invokeRestart
[10:26:11.450]             length <- base::length
[10:26:11.450]             list <- base::list
[10:26:11.450]             seq.int <- base::seq.int
[10:26:11.450]             signalCondition <- base::signalCondition
[10:26:11.450]             sys.calls <- base::sys.calls
[10:26:11.450]             `[[` <- base::`[[`
[10:26:11.450]             `+` <- base::`+`
[10:26:11.450]             `<<-` <- base::`<<-`
[10:26:11.450]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.450]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.450]                   3L)]
[10:26:11.450]             }
[10:26:11.450]             function(cond) {
[10:26:11.450]                 is_error <- inherits(cond, "error")
[10:26:11.450]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.450]                   NULL)
[10:26:11.450]                 if (is_error) {
[10:26:11.450]                   sessionInformation <- function() {
[10:26:11.450]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.450]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.450]                       search = base::search(), system = base::Sys.info())
[10:26:11.450]                   }
[10:26:11.450]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.450]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.450]                     cond$call), session = sessionInformation(), 
[10:26:11.450]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.450]                   signalCondition(cond)
[10:26:11.450]                 }
[10:26:11.450]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.450]                 "immediateCondition"))) {
[10:26:11.450]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.450]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.450]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.450]                   if (TRUE && !signal) {
[10:26:11.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.450]                     {
[10:26:11.450]                       inherits <- base::inherits
[10:26:11.450]                       invokeRestart <- base::invokeRestart
[10:26:11.450]                       is.null <- base::is.null
[10:26:11.450]                       muffled <- FALSE
[10:26:11.450]                       if (inherits(cond, "message")) {
[10:26:11.450]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.450]                         if (muffled) 
[10:26:11.450]                           invokeRestart("muffleMessage")
[10:26:11.450]                       }
[10:26:11.450]                       else if (inherits(cond, "warning")) {
[10:26:11.450]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.450]                         if (muffled) 
[10:26:11.450]                           invokeRestart("muffleWarning")
[10:26:11.450]                       }
[10:26:11.450]                       else if (inherits(cond, "condition")) {
[10:26:11.450]                         if (!is.null(pattern)) {
[10:26:11.450]                           computeRestarts <- base::computeRestarts
[10:26:11.450]                           grepl <- base::grepl
[10:26:11.450]                           restarts <- computeRestarts(cond)
[10:26:11.450]                           for (restart in restarts) {
[10:26:11.450]                             name <- restart$name
[10:26:11.450]                             if (is.null(name)) 
[10:26:11.450]                               next
[10:26:11.450]                             if (!grepl(pattern, name)) 
[10:26:11.450]                               next
[10:26:11.450]                             invokeRestart(restart)
[10:26:11.450]                             muffled <- TRUE
[10:26:11.450]                             break
[10:26:11.450]                           }
[10:26:11.450]                         }
[10:26:11.450]                       }
[10:26:11.450]                       invisible(muffled)
[10:26:11.450]                     }
[10:26:11.450]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.450]                   }
[10:26:11.450]                 }
[10:26:11.450]                 else {
[10:26:11.450]                   if (TRUE) {
[10:26:11.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.450]                     {
[10:26:11.450]                       inherits <- base::inherits
[10:26:11.450]                       invokeRestart <- base::invokeRestart
[10:26:11.450]                       is.null <- base::is.null
[10:26:11.450]                       muffled <- FALSE
[10:26:11.450]                       if (inherits(cond, "message")) {
[10:26:11.450]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.450]                         if (muffled) 
[10:26:11.450]                           invokeRestart("muffleMessage")
[10:26:11.450]                       }
[10:26:11.450]                       else if (inherits(cond, "warning")) {
[10:26:11.450]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.450]                         if (muffled) 
[10:26:11.450]                           invokeRestart("muffleWarning")
[10:26:11.450]                       }
[10:26:11.450]                       else if (inherits(cond, "condition")) {
[10:26:11.450]                         if (!is.null(pattern)) {
[10:26:11.450]                           computeRestarts <- base::computeRestarts
[10:26:11.450]                           grepl <- base::grepl
[10:26:11.450]                           restarts <- computeRestarts(cond)
[10:26:11.450]                           for (restart in restarts) {
[10:26:11.450]                             name <- restart$name
[10:26:11.450]                             if (is.null(name)) 
[10:26:11.450]                               next
[10:26:11.450]                             if (!grepl(pattern, name)) 
[10:26:11.450]                               next
[10:26:11.450]                             invokeRestart(restart)
[10:26:11.450]                             muffled <- TRUE
[10:26:11.450]                             break
[10:26:11.450]                           }
[10:26:11.450]                         }
[10:26:11.450]                       }
[10:26:11.450]                       invisible(muffled)
[10:26:11.450]                     }
[10:26:11.450]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.450]                   }
[10:26:11.450]                 }
[10:26:11.450]             }
[10:26:11.450]         }))
[10:26:11.450]     }, error = function(ex) {
[10:26:11.450]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.450]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.450]                 ...future.rng), started = ...future.startTime, 
[10:26:11.450]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.450]             version = "1.8"), class = "FutureResult")
[10:26:11.450]     }, finally = {
[10:26:11.450]         if (!identical(...future.workdir, getwd())) 
[10:26:11.450]             setwd(...future.workdir)
[10:26:11.450]         {
[10:26:11.450]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.450]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.450]             }
[10:26:11.450]             base::options(...future.oldOptions)
[10:26:11.450]             if (.Platform$OS.type == "windows") {
[10:26:11.450]                 old_names <- names(...future.oldEnvVars)
[10:26:11.450]                 envs <- base::Sys.getenv()
[10:26:11.450]                 names <- names(envs)
[10:26:11.450]                 common <- intersect(names, old_names)
[10:26:11.450]                 added <- setdiff(names, old_names)
[10:26:11.450]                 removed <- setdiff(old_names, names)
[10:26:11.450]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.450]                   envs[common]]
[10:26:11.450]                 NAMES <- toupper(changed)
[10:26:11.450]                 args <- list()
[10:26:11.450]                 for (kk in seq_along(NAMES)) {
[10:26:11.450]                   name <- changed[[kk]]
[10:26:11.450]                   NAME <- NAMES[[kk]]
[10:26:11.450]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.450]                     next
[10:26:11.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.450]                 }
[10:26:11.450]                 NAMES <- toupper(added)
[10:26:11.450]                 for (kk in seq_along(NAMES)) {
[10:26:11.450]                   name <- added[[kk]]
[10:26:11.450]                   NAME <- NAMES[[kk]]
[10:26:11.450]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.450]                     next
[10:26:11.450]                   args[[name]] <- ""
[10:26:11.450]                 }
[10:26:11.450]                 NAMES <- toupper(removed)
[10:26:11.450]                 for (kk in seq_along(NAMES)) {
[10:26:11.450]                   name <- removed[[kk]]
[10:26:11.450]                   NAME <- NAMES[[kk]]
[10:26:11.450]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.450]                     next
[10:26:11.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.450]                 }
[10:26:11.450]                 if (length(args) > 0) 
[10:26:11.450]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.450]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.450]             }
[10:26:11.450]             else {
[10:26:11.450]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.450]             }
[10:26:11.450]             {
[10:26:11.450]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.450]                   0L) {
[10:26:11.450]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.450]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.450]                   base::options(opts)
[10:26:11.450]                 }
[10:26:11.450]                 {
[10:26:11.450]                   {
[10:26:11.450]                     NULL
[10:26:11.450]                     RNGkind("Mersenne-Twister")
[10:26:11.450]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.450]                       inherits = FALSE)
[10:26:11.450]                   }
[10:26:11.450]                   options(future.plan = NULL)
[10:26:11.450]                   if (is.na(NA_character_)) 
[10:26:11.450]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.450]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.450]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.450]                   {
[10:26:11.450]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.450]                     if (!future$lazy) 
[10:26:11.450]                       future <- run(future)
[10:26:11.450]                     invisible(future)
[10:26:11.450]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.450]                 }
[10:26:11.450]             }
[10:26:11.450]         }
[10:26:11.450]     })
[10:26:11.450]     if (TRUE) {
[10:26:11.450]         base::sink(type = "output", split = FALSE)
[10:26:11.450]         if (TRUE) {
[10:26:11.450]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.450]         }
[10:26:11.450]         else {
[10:26:11.450]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.450]         }
[10:26:11.450]         base::close(...future.stdout)
[10:26:11.450]         ...future.stdout <- NULL
[10:26:11.450]     }
[10:26:11.450]     ...future.result$conditions <- ...future.conditions
[10:26:11.450]     ...future.result$finished <- base::Sys.time()
[10:26:11.450]     ...future.result
[10:26:11.450] }
[10:26:11.452] plan(): Setting new future strategy stack:
[10:26:11.452] List of future strategies:
[10:26:11.452] 1. sequential:
[10:26:11.452]    - args: function (..., envir = parent.frame())
[10:26:11.452]    - tweaked: FALSE
[10:26:11.452]    - call: NULL
[10:26:11.452] plan(): nbrOfWorkers() = 1
[10:26:11.453] plan(): Setting new future strategy stack:
[10:26:11.453] List of future strategies:
[10:26:11.453] 1. sequential:
[10:26:11.453]    - args: function (..., envir = parent.frame())
[10:26:11.453]    - tweaked: FALSE
[10:26:11.453]    - call: plan(strategy)
[10:26:11.453] plan(): nbrOfWorkers() = 1
[10:26:11.454] SequentialFuture started (and completed)
[10:26:11.454] - Launch lazy future ... done
[10:26:11.454] run() for ‘SequentialFuture’ ... done
[10:26:11.454] resolved() for ‘SequentialFuture’ ...
[10:26:11.454] - state: ‘finished’
[10:26:11.454] - run: TRUE
[10:26:11.454] - result: ‘FutureResult’
[10:26:11.454] resolved() for ‘SequentialFuture’ ... done
[10:26:11.454] Future #1
[10:26:11.455] resolved() for ‘SequentialFuture’ ...
[10:26:11.455] - state: ‘finished’
[10:26:11.455] - run: TRUE
[10:26:11.455] - result: ‘FutureResult’
[10:26:11.455] resolved() for ‘SequentialFuture’ ... done
[10:26:11.455] A SequentialFuture was resolved
[10:26:11.455]  length: 0 (resolved future 1)
[10:26:11.455] resolve() on list ... DONE
[10:26:11.455] - globals: [1] ‘a’
[10:26:11.455] Resolving futures part of globals (recursively) ... DONE
[10:26:11.456] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[10:26:11.456] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[10:26:11.457] - globals: [1] ‘a’
[10:26:11.457] - packages: [1] ‘future’
[10:26:11.457] getGlobalsAndPackages() ... DONE
[10:26:11.457] run() for ‘Future’ ...
[10:26:11.457] - state: ‘created’
[10:26:11.457] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.457] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.458] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.458]   - Field: ‘label’
[10:26:11.458]   - Field: ‘local’
[10:26:11.458]   - Field: ‘owner’
[10:26:11.458]   - Field: ‘envir’
[10:26:11.458]   - Field: ‘packages’
[10:26:11.458]   - Field: ‘gc’
[10:26:11.458]   - Field: ‘conditions’
[10:26:11.458]   - Field: ‘expr’
[10:26:11.458]   - Field: ‘uuid’
[10:26:11.458]   - Field: ‘seed’
[10:26:11.459]   - Field: ‘version’
[10:26:11.459]   - Field: ‘result’
[10:26:11.459]   - Field: ‘asynchronous’
[10:26:11.459]   - Field: ‘calls’
[10:26:11.459]   - Field: ‘globals’
[10:26:11.459]   - Field: ‘stdout’
[10:26:11.459]   - Field: ‘earlySignal’
[10:26:11.459]   - Field: ‘lazy’
[10:26:11.459]   - Field: ‘state’
[10:26:11.459] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.459] - Launch lazy future ...
[10:26:11.460] Packages needed by the future expression (n = 1): ‘future’
[10:26:11.460] Packages needed by future strategies (n = 0): <none>
[10:26:11.460] {
[10:26:11.460]     {
[10:26:11.460]         {
[10:26:11.460]             ...future.startTime <- base::Sys.time()
[10:26:11.460]             {
[10:26:11.460]                 {
[10:26:11.460]                   {
[10:26:11.460]                     {
[10:26:11.460]                       base::local({
[10:26:11.460]                         has_future <- base::requireNamespace("future", 
[10:26:11.460]                           quietly = TRUE)
[10:26:11.460]                         if (has_future) {
[10:26:11.460]                           ns <- base::getNamespace("future")
[10:26:11.460]                           version <- ns[[".package"]][["version"]]
[10:26:11.460]                           if (is.null(version)) 
[10:26:11.460]                             version <- utils::packageVersion("future")
[10:26:11.460]                         }
[10:26:11.460]                         else {
[10:26:11.460]                           version <- NULL
[10:26:11.460]                         }
[10:26:11.460]                         if (!has_future || version < "1.8.0") {
[10:26:11.460]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.460]                             "", base::R.version$version.string), 
[10:26:11.460]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:11.460]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.460]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.460]                               "release", "version")], collapse = " "), 
[10:26:11.460]                             hostname = base::Sys.info()[["nodename"]])
[10:26:11.460]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.460]                             info)
[10:26:11.460]                           info <- base::paste(info, collapse = "; ")
[10:26:11.460]                           if (!has_future) {
[10:26:11.460]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.460]                               info)
[10:26:11.460]                           }
[10:26:11.460]                           else {
[10:26:11.460]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.460]                               info, version)
[10:26:11.460]                           }
[10:26:11.460]                           base::stop(msg)
[10:26:11.460]                         }
[10:26:11.460]                       })
[10:26:11.460]                     }
[10:26:11.460]                     base::local({
[10:26:11.460]                       for (pkg in "future") {
[10:26:11.460]                         base::loadNamespace(pkg)
[10:26:11.460]                         base::library(pkg, character.only = TRUE)
[10:26:11.460]                       }
[10:26:11.460]                     })
[10:26:11.460]                   }
[10:26:11.460]                   options(future.plan = NULL)
[10:26:11.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.460]                 }
[10:26:11.460]                 ...future.workdir <- getwd()
[10:26:11.460]             }
[10:26:11.460]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.460]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.460]         }
[10:26:11.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.460]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:11.460]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.460]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.460]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.460]             base::names(...future.oldOptions))
[10:26:11.460]     }
[10:26:11.460]     if (FALSE) {
[10:26:11.460]     }
[10:26:11.460]     else {
[10:26:11.460]         if (TRUE) {
[10:26:11.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.460]                 open = "w")
[10:26:11.460]         }
[10:26:11.460]         else {
[10:26:11.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.460]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.460]         }
[10:26:11.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.460]             base::sink(type = "output", split = FALSE)
[10:26:11.460]             base::close(...future.stdout)
[10:26:11.460]         }, add = TRUE)
[10:26:11.460]     }
[10:26:11.460]     ...future.frame <- base::sys.nframe()
[10:26:11.460]     ...future.conditions <- base::list()
[10:26:11.460]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.460]     if (FALSE) {
[10:26:11.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.460]     }
[10:26:11.460]     ...future.result <- base::tryCatch({
[10:26:11.460]         base::withCallingHandlers({
[10:26:11.460]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:26:11.460]                 1))
[10:26:11.460]             future::FutureResult(value = ...future.value$value, 
[10:26:11.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.460]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.460]                     ...future.globalenv.names))
[10:26:11.460]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.460]         }, condition = base::local({
[10:26:11.460]             c <- base::c
[10:26:11.460]             inherits <- base::inherits
[10:26:11.460]             invokeRestart <- base::invokeRestart
[10:26:11.460]             length <- base::length
[10:26:11.460]             list <- base::list
[10:26:11.460]             seq.int <- base::seq.int
[10:26:11.460]             signalCondition <- base::signalCondition
[10:26:11.460]             sys.calls <- base::sys.calls
[10:26:11.460]             `[[` <- base::`[[`
[10:26:11.460]             `+` <- base::`+`
[10:26:11.460]             `<<-` <- base::`<<-`
[10:26:11.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.460]                   3L)]
[10:26:11.460]             }
[10:26:11.460]             function(cond) {
[10:26:11.460]                 is_error <- inherits(cond, "error")
[10:26:11.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.460]                   NULL)
[10:26:11.460]                 if (is_error) {
[10:26:11.460]                   sessionInformation <- function() {
[10:26:11.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.460]                       search = base::search(), system = base::Sys.info())
[10:26:11.460]                   }
[10:26:11.460]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.460]                     cond$call), session = sessionInformation(), 
[10:26:11.460]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.460]                   signalCondition(cond)
[10:26:11.460]                 }
[10:26:11.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.460]                 "immediateCondition"))) {
[10:26:11.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.460]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.460]                   if (TRUE && !signal) {
[10:26:11.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.460]                     {
[10:26:11.460]                       inherits <- base::inherits
[10:26:11.460]                       invokeRestart <- base::invokeRestart
[10:26:11.460]                       is.null <- base::is.null
[10:26:11.460]                       muffled <- FALSE
[10:26:11.460]                       if (inherits(cond, "message")) {
[10:26:11.460]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.460]                         if (muffled) 
[10:26:11.460]                           invokeRestart("muffleMessage")
[10:26:11.460]                       }
[10:26:11.460]                       else if (inherits(cond, "warning")) {
[10:26:11.460]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.460]                         if (muffled) 
[10:26:11.460]                           invokeRestart("muffleWarning")
[10:26:11.460]                       }
[10:26:11.460]                       else if (inherits(cond, "condition")) {
[10:26:11.460]                         if (!is.null(pattern)) {
[10:26:11.460]                           computeRestarts <- base::computeRestarts
[10:26:11.460]                           grepl <- base::grepl
[10:26:11.460]                           restarts <- computeRestarts(cond)
[10:26:11.460]                           for (restart in restarts) {
[10:26:11.460]                             name <- restart$name
[10:26:11.460]                             if (is.null(name)) 
[10:26:11.460]                               next
[10:26:11.460]                             if (!grepl(pattern, name)) 
[10:26:11.460]                               next
[10:26:11.460]                             invokeRestart(restart)
[10:26:11.460]                             muffled <- TRUE
[10:26:11.460]                             break
[10:26:11.460]                           }
[10:26:11.460]                         }
[10:26:11.460]                       }
[10:26:11.460]                       invisible(muffled)
[10:26:11.460]                     }
[10:26:11.460]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.460]                   }
[10:26:11.460]                 }
[10:26:11.460]                 else {
[10:26:11.460]                   if (TRUE) {
[10:26:11.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.460]                     {
[10:26:11.460]                       inherits <- base::inherits
[10:26:11.460]                       invokeRestart <- base::invokeRestart
[10:26:11.460]                       is.null <- base::is.null
[10:26:11.460]                       muffled <- FALSE
[10:26:11.460]                       if (inherits(cond, "message")) {
[10:26:11.460]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.460]                         if (muffled) 
[10:26:11.460]                           invokeRestart("muffleMessage")
[10:26:11.460]                       }
[10:26:11.460]                       else if (inherits(cond, "warning")) {
[10:26:11.460]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.460]                         if (muffled) 
[10:26:11.460]                           invokeRestart("muffleWarning")
[10:26:11.460]                       }
[10:26:11.460]                       else if (inherits(cond, "condition")) {
[10:26:11.460]                         if (!is.null(pattern)) {
[10:26:11.460]                           computeRestarts <- base::computeRestarts
[10:26:11.460]                           grepl <- base::grepl
[10:26:11.460]                           restarts <- computeRestarts(cond)
[10:26:11.460]                           for (restart in restarts) {
[10:26:11.460]                             name <- restart$name
[10:26:11.460]                             if (is.null(name)) 
[10:26:11.460]                               next
[10:26:11.460]                             if (!grepl(pattern, name)) 
[10:26:11.460]                               next
[10:26:11.460]                             invokeRestart(restart)
[10:26:11.460]                             muffled <- TRUE
[10:26:11.460]                             break
[10:26:11.460]                           }
[10:26:11.460]                         }
[10:26:11.460]                       }
[10:26:11.460]                       invisible(muffled)
[10:26:11.460]                     }
[10:26:11.460]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.460]                   }
[10:26:11.460]                 }
[10:26:11.460]             }
[10:26:11.460]         }))
[10:26:11.460]     }, error = function(ex) {
[10:26:11.460]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.460]                 ...future.rng), started = ...future.startTime, 
[10:26:11.460]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.460]             version = "1.8"), class = "FutureResult")
[10:26:11.460]     }, finally = {
[10:26:11.460]         if (!identical(...future.workdir, getwd())) 
[10:26:11.460]             setwd(...future.workdir)
[10:26:11.460]         {
[10:26:11.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.460]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.460]             }
[10:26:11.460]             base::options(...future.oldOptions)
[10:26:11.460]             if (.Platform$OS.type == "windows") {
[10:26:11.460]                 old_names <- names(...future.oldEnvVars)
[10:26:11.460]                 envs <- base::Sys.getenv()
[10:26:11.460]                 names <- names(envs)
[10:26:11.460]                 common <- intersect(names, old_names)
[10:26:11.460]                 added <- setdiff(names, old_names)
[10:26:11.460]                 removed <- setdiff(old_names, names)
[10:26:11.460]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.460]                   envs[common]]
[10:26:11.460]                 NAMES <- toupper(changed)
[10:26:11.460]                 args <- list()
[10:26:11.460]                 for (kk in seq_along(NAMES)) {
[10:26:11.460]                   name <- changed[[kk]]
[10:26:11.460]                   NAME <- NAMES[[kk]]
[10:26:11.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.460]                     next
[10:26:11.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.460]                 }
[10:26:11.460]                 NAMES <- toupper(added)
[10:26:11.460]                 for (kk in seq_along(NAMES)) {
[10:26:11.460]                   name <- added[[kk]]
[10:26:11.460]                   NAME <- NAMES[[kk]]
[10:26:11.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.460]                     next
[10:26:11.460]                   args[[name]] <- ""
[10:26:11.460]                 }
[10:26:11.460]                 NAMES <- toupper(removed)
[10:26:11.460]                 for (kk in seq_along(NAMES)) {
[10:26:11.460]                   name <- removed[[kk]]
[10:26:11.460]                   NAME <- NAMES[[kk]]
[10:26:11.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.460]                     next
[10:26:11.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.460]                 }
[10:26:11.460]                 if (length(args) > 0) 
[10:26:11.460]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.460]             }
[10:26:11.460]             else {
[10:26:11.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.460]             }
[10:26:11.460]             {
[10:26:11.460]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.460]                   0L) {
[10:26:11.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.460]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.460]                   base::options(opts)
[10:26:11.460]                 }
[10:26:11.460]                 {
[10:26:11.460]                   {
[10:26:11.460]                     NULL
[10:26:11.460]                     RNGkind("Mersenne-Twister")
[10:26:11.460]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.460]                       inherits = FALSE)
[10:26:11.460]                   }
[10:26:11.460]                   options(future.plan = NULL)
[10:26:11.460]                   if (is.na(NA_character_)) 
[10:26:11.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.460]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.460]                   {
[10:26:11.460]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.460]                     if (!future$lazy) 
[10:26:11.460]                       future <- run(future)
[10:26:11.460]                     invisible(future)
[10:26:11.460]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.460]                 }
[10:26:11.460]             }
[10:26:11.460]         }
[10:26:11.460]     })
[10:26:11.460]     if (TRUE) {
[10:26:11.460]         base::sink(type = "output", split = FALSE)
[10:26:11.460]         if (TRUE) {
[10:26:11.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.460]         }
[10:26:11.460]         else {
[10:26:11.460]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.460]         }
[10:26:11.460]         base::close(...future.stdout)
[10:26:11.460]         ...future.stdout <- NULL
[10:26:11.460]     }
[10:26:11.460]     ...future.result$conditions <- ...future.conditions
[10:26:11.460]     ...future.result$finished <- base::Sys.time()
[10:26:11.460]     ...future.result
[10:26:11.460] }
[10:26:11.462] assign_globals() ...
[10:26:11.462] List of 1
[10:26:11.462]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a021743d50> 
[10:26:11.462]  - attr(*, "where")=List of 1
[10:26:11.462]   ..$ a:<environment: R_EmptyEnv> 
[10:26:11.462]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.462]  - attr(*, "resolved")= logi TRUE
[10:26:11.462]  - attr(*, "total_size")= num 10592
[10:26:11.462]  - attr(*, "already-done")= logi TRUE
[10:26:11.464] - copied ‘a’ to environment
[10:26:11.464] assign_globals() ... done
[10:26:11.464] plan(): Setting new future strategy stack:
[10:26:11.464] List of future strategies:
[10:26:11.464] 1. sequential:
[10:26:11.464]    - args: function (..., envir = parent.frame())
[10:26:11.464]    - tweaked: FALSE
[10:26:11.464]    - call: NULL
[10:26:11.465] plan(): nbrOfWorkers() = 1
[10:26:11.466] plan(): Setting new future strategy stack:
[10:26:11.466] List of future strategies:
[10:26:11.466] 1. sequential:
[10:26:11.466]    - args: function (..., envir = parent.frame())
[10:26:11.466]    - tweaked: FALSE
[10:26:11.466]    - call: plan(strategy)
[10:26:11.466] plan(): nbrOfWorkers() = 1
[10:26:11.466] SequentialFuture started (and completed)
[10:26:11.466] - Launch lazy future ... done
[10:26:11.466] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.467] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.467] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:11.468] - globals found: [2] ‘{’, ‘pkg’
[10:26:11.468] Searching for globals ... DONE
[10:26:11.468] Resolving globals: TRUE
[10:26:11.468] Resolving any globals that are futures ...
[10:26:11.468] - globals: [2] ‘{’, ‘pkg’
[10:26:11.468] Resolving any globals that are futures ... DONE
[10:26:11.468] Resolving futures part of globals (recursively) ...
[10:26:11.469] resolve() on list ...
[10:26:11.469]  recursive: 99
[10:26:11.469]  length: 1
[10:26:11.469]  elements: ‘pkg’
[10:26:11.470]  length: 0 (resolved future 1)
[10:26:11.470] resolve() on list ... DONE
[10:26:11.470] - globals: [1] ‘pkg’
[10:26:11.470] Resolving futures part of globals (recursively) ... DONE
[10:26:11.470] The total size of the 1 globals is 112 bytes (112 bytes)
[10:26:11.471] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[10:26:11.471] - globals: [1] ‘pkg’
[10:26:11.471] 
[10:26:11.471] getGlobalsAndPackages() ... DONE
[10:26:11.471] Packages needed by the future expression (n = 0): <none>
[10:26:11.471] Packages needed by future strategies (n = 0): <none>
[10:26:11.472] {
[10:26:11.472]     {
[10:26:11.472]         {
[10:26:11.472]             ...future.startTime <- base::Sys.time()
[10:26:11.472]             {
[10:26:11.472]                 {
[10:26:11.472]                   {
[10:26:11.472]                     base::local({
[10:26:11.472]                       has_future <- base::requireNamespace("future", 
[10:26:11.472]                         quietly = TRUE)
[10:26:11.472]                       if (has_future) {
[10:26:11.472]                         ns <- base::getNamespace("future")
[10:26:11.472]                         version <- ns[[".package"]][["version"]]
[10:26:11.472]                         if (is.null(version)) 
[10:26:11.472]                           version <- utils::packageVersion("future")
[10:26:11.472]                       }
[10:26:11.472]                       else {
[10:26:11.472]                         version <- NULL
[10:26:11.472]                       }
[10:26:11.472]                       if (!has_future || version < "1.8.0") {
[10:26:11.472]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.472]                           "", base::R.version$version.string), 
[10:26:11.472]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.472]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.472]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.472]                             "release", "version")], collapse = " "), 
[10:26:11.472]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.472]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.472]                           info)
[10:26:11.472]                         info <- base::paste(info, collapse = "; ")
[10:26:11.472]                         if (!has_future) {
[10:26:11.472]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.472]                             info)
[10:26:11.472]                         }
[10:26:11.472]                         else {
[10:26:11.472]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.472]                             info, version)
[10:26:11.472]                         }
[10:26:11.472]                         base::stop(msg)
[10:26:11.472]                       }
[10:26:11.472]                     })
[10:26:11.472]                   }
[10:26:11.472]                   options(future.plan = NULL)
[10:26:11.472]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.472]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.472]                 }
[10:26:11.472]                 ...future.workdir <- getwd()
[10:26:11.472]             }
[10:26:11.472]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.472]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.472]         }
[10:26:11.472]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.472]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:11.472]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.472]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.472]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.472]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.472]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.472]             base::names(...future.oldOptions))
[10:26:11.472]     }
[10:26:11.472]     if (FALSE) {
[10:26:11.472]     }
[10:26:11.472]     else {
[10:26:11.472]         if (TRUE) {
[10:26:11.472]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.472]                 open = "w")
[10:26:11.472]         }
[10:26:11.472]         else {
[10:26:11.472]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.472]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.472]         }
[10:26:11.472]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.472]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.472]             base::sink(type = "output", split = FALSE)
[10:26:11.472]             base::close(...future.stdout)
[10:26:11.472]         }, add = TRUE)
[10:26:11.472]     }
[10:26:11.472]     ...future.frame <- base::sys.nframe()
[10:26:11.472]     ...future.conditions <- base::list()
[10:26:11.472]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.472]     if (FALSE) {
[10:26:11.472]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.472]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.472]     }
[10:26:11.472]     ...future.result <- base::tryCatch({
[10:26:11.472]         base::withCallingHandlers({
[10:26:11.472]             ...future.value <- base::withVisible(base::local({
[10:26:11.472]                 pkg
[10:26:11.472]             }))
[10:26:11.472]             future::FutureResult(value = ...future.value$value, 
[10:26:11.472]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.472]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.472]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.472]                     ...future.globalenv.names))
[10:26:11.472]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.472]         }, condition = base::local({
[10:26:11.472]             c <- base::c
[10:26:11.472]             inherits <- base::inherits
[10:26:11.472]             invokeRestart <- base::invokeRestart
[10:26:11.472]             length <- base::length
[10:26:11.472]             list <- base::list
[10:26:11.472]             seq.int <- base::seq.int
[10:26:11.472]             signalCondition <- base::signalCondition
[10:26:11.472]             sys.calls <- base::sys.calls
[10:26:11.472]             `[[` <- base::`[[`
[10:26:11.472]             `+` <- base::`+`
[10:26:11.472]             `<<-` <- base::`<<-`
[10:26:11.472]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.472]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.472]                   3L)]
[10:26:11.472]             }
[10:26:11.472]             function(cond) {
[10:26:11.472]                 is_error <- inherits(cond, "error")
[10:26:11.472]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.472]                   NULL)
[10:26:11.472]                 if (is_error) {
[10:26:11.472]                   sessionInformation <- function() {
[10:26:11.472]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.472]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.472]                       search = base::search(), system = base::Sys.info())
[10:26:11.472]                   }
[10:26:11.472]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.472]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.472]                     cond$call), session = sessionInformation(), 
[10:26:11.472]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.472]                   signalCondition(cond)
[10:26:11.472]                 }
[10:26:11.472]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.472]                 "immediateCondition"))) {
[10:26:11.472]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.472]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.472]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.472]                   if (TRUE && !signal) {
[10:26:11.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.472]                     {
[10:26:11.472]                       inherits <- base::inherits
[10:26:11.472]                       invokeRestart <- base::invokeRestart
[10:26:11.472]                       is.null <- base::is.null
[10:26:11.472]                       muffled <- FALSE
[10:26:11.472]                       if (inherits(cond, "message")) {
[10:26:11.472]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.472]                         if (muffled) 
[10:26:11.472]                           invokeRestart("muffleMessage")
[10:26:11.472]                       }
[10:26:11.472]                       else if (inherits(cond, "warning")) {
[10:26:11.472]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.472]                         if (muffled) 
[10:26:11.472]                           invokeRestart("muffleWarning")
[10:26:11.472]                       }
[10:26:11.472]                       else if (inherits(cond, "condition")) {
[10:26:11.472]                         if (!is.null(pattern)) {
[10:26:11.472]                           computeRestarts <- base::computeRestarts
[10:26:11.472]                           grepl <- base::grepl
[10:26:11.472]                           restarts <- computeRestarts(cond)
[10:26:11.472]                           for (restart in restarts) {
[10:26:11.472]                             name <- restart$name
[10:26:11.472]                             if (is.null(name)) 
[10:26:11.472]                               next
[10:26:11.472]                             if (!grepl(pattern, name)) 
[10:26:11.472]                               next
[10:26:11.472]                             invokeRestart(restart)
[10:26:11.472]                             muffled <- TRUE
[10:26:11.472]                             break
[10:26:11.472]                           }
[10:26:11.472]                         }
[10:26:11.472]                       }
[10:26:11.472]                       invisible(muffled)
[10:26:11.472]                     }
[10:26:11.472]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.472]                   }
[10:26:11.472]                 }
[10:26:11.472]                 else {
[10:26:11.472]                   if (TRUE) {
[10:26:11.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.472]                     {
[10:26:11.472]                       inherits <- base::inherits
[10:26:11.472]                       invokeRestart <- base::invokeRestart
[10:26:11.472]                       is.null <- base::is.null
[10:26:11.472]                       muffled <- FALSE
[10:26:11.472]                       if (inherits(cond, "message")) {
[10:26:11.472]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.472]                         if (muffled) 
[10:26:11.472]                           invokeRestart("muffleMessage")
[10:26:11.472]                       }
[10:26:11.472]                       else if (inherits(cond, "warning")) {
[10:26:11.472]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.472]                         if (muffled) 
[10:26:11.472]                           invokeRestart("muffleWarning")
[10:26:11.472]                       }
[10:26:11.472]                       else if (inherits(cond, "condition")) {
[10:26:11.472]                         if (!is.null(pattern)) {
[10:26:11.472]                           computeRestarts <- base::computeRestarts
[10:26:11.472]                           grepl <- base::grepl
[10:26:11.472]                           restarts <- computeRestarts(cond)
[10:26:11.472]                           for (restart in restarts) {
[10:26:11.472]                             name <- restart$name
[10:26:11.472]                             if (is.null(name)) 
[10:26:11.472]                               next
[10:26:11.472]                             if (!grepl(pattern, name)) 
[10:26:11.472]                               next
[10:26:11.472]                             invokeRestart(restart)
[10:26:11.472]                             muffled <- TRUE
[10:26:11.472]                             break
[10:26:11.472]                           }
[10:26:11.472]                         }
[10:26:11.472]                       }
[10:26:11.472]                       invisible(muffled)
[10:26:11.472]                     }
[10:26:11.472]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.472]                   }
[10:26:11.472]                 }
[10:26:11.472]             }
[10:26:11.472]         }))
[10:26:11.472]     }, error = function(ex) {
[10:26:11.472]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.472]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.472]                 ...future.rng), started = ...future.startTime, 
[10:26:11.472]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.472]             version = "1.8"), class = "FutureResult")
[10:26:11.472]     }, finally = {
[10:26:11.472]         if (!identical(...future.workdir, getwd())) 
[10:26:11.472]             setwd(...future.workdir)
[10:26:11.472]         {
[10:26:11.472]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.472]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.472]             }
[10:26:11.472]             base::options(...future.oldOptions)
[10:26:11.472]             if (.Platform$OS.type == "windows") {
[10:26:11.472]                 old_names <- names(...future.oldEnvVars)
[10:26:11.472]                 envs <- base::Sys.getenv()
[10:26:11.472]                 names <- names(envs)
[10:26:11.472]                 common <- intersect(names, old_names)
[10:26:11.472]                 added <- setdiff(names, old_names)
[10:26:11.472]                 removed <- setdiff(old_names, names)
[10:26:11.472]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.472]                   envs[common]]
[10:26:11.472]                 NAMES <- toupper(changed)
[10:26:11.472]                 args <- list()
[10:26:11.472]                 for (kk in seq_along(NAMES)) {
[10:26:11.472]                   name <- changed[[kk]]
[10:26:11.472]                   NAME <- NAMES[[kk]]
[10:26:11.472]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.472]                     next
[10:26:11.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.472]                 }
[10:26:11.472]                 NAMES <- toupper(added)
[10:26:11.472]                 for (kk in seq_along(NAMES)) {
[10:26:11.472]                   name <- added[[kk]]
[10:26:11.472]                   NAME <- NAMES[[kk]]
[10:26:11.472]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.472]                     next
[10:26:11.472]                   args[[name]] <- ""
[10:26:11.472]                 }
[10:26:11.472]                 NAMES <- toupper(removed)
[10:26:11.472]                 for (kk in seq_along(NAMES)) {
[10:26:11.472]                   name <- removed[[kk]]
[10:26:11.472]                   NAME <- NAMES[[kk]]
[10:26:11.472]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.472]                     next
[10:26:11.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.472]                 }
[10:26:11.472]                 if (length(args) > 0) 
[10:26:11.472]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.472]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.472]             }
[10:26:11.472]             else {
[10:26:11.472]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.472]             }
[10:26:11.472]             {
[10:26:11.472]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.472]                   0L) {
[10:26:11.472]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.472]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.472]                   base::options(opts)
[10:26:11.472]                 }
[10:26:11.472]                 {
[10:26:11.472]                   {
[10:26:11.472]                     NULL
[10:26:11.472]                     RNGkind("Mersenne-Twister")
[10:26:11.472]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.472]                       inherits = FALSE)
[10:26:11.472]                   }
[10:26:11.472]                   options(future.plan = NULL)
[10:26:11.472]                   if (is.na(NA_character_)) 
[10:26:11.472]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.472]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.472]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.472]                   {
[10:26:11.472]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.472]                     if (!future$lazy) 
[10:26:11.472]                       future <- run(future)
[10:26:11.472]                     invisible(future)
[10:26:11.472]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.472]                 }
[10:26:11.472]             }
[10:26:11.472]         }
[10:26:11.472]     })
[10:26:11.472]     if (TRUE) {
[10:26:11.472]         base::sink(type = "output", split = FALSE)
[10:26:11.472]         if (TRUE) {
[10:26:11.472]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.472]         }
[10:26:11.472]         else {
[10:26:11.472]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.472]         }
[10:26:11.472]         base::close(...future.stdout)
[10:26:11.472]         ...future.stdout <- NULL
[10:26:11.472]     }
[10:26:11.472]     ...future.result$conditions <- ...future.conditions
[10:26:11.472]     ...future.result$finished <- base::Sys.time()
[10:26:11.472]     ...future.result
[10:26:11.472] }
[10:26:11.473] assign_globals() ...
[10:26:11.473] List of 1
[10:26:11.473]  $ pkg: chr "foo"
[10:26:11.473]  - attr(*, "where")=List of 1
[10:26:11.473]   ..$ pkg:<environment: R_EmptyEnv> 
[10:26:11.473]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.473]  - attr(*, "resolved")= logi TRUE
[10:26:11.473]  - attr(*, "total_size")= num 112
[10:26:11.475] - copied ‘pkg’ to environment
[10:26:11.475] assign_globals() ... done
[10:26:11.476] plan(): Setting new future strategy stack:
[10:26:11.476] List of future strategies:
[10:26:11.476] 1. sequential:
[10:26:11.476]    - args: function (..., envir = parent.frame())
[10:26:11.476]    - tweaked: FALSE
[10:26:11.476]    - call: NULL
[10:26:11.476] plan(): nbrOfWorkers() = 1
[10:26:11.477] plan(): Setting new future strategy stack:
[10:26:11.477] List of future strategies:
[10:26:11.477] 1. sequential:
[10:26:11.477]    - args: function (..., envir = parent.frame())
[10:26:11.477]    - tweaked: FALSE
[10:26:11.477]    - call: plan(strategy)
[10:26:11.477] plan(): nbrOfWorkers() = 1
[10:26:11.477] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.478] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.478] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:11.480] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:26:11.480] Searching for globals ... DONE
[10:26:11.480] Resolving globals: TRUE
[10:26:11.480] Resolving any globals that are futures ...
[10:26:11.481] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:26:11.481] Resolving any globals that are futures ... DONE
[10:26:11.481] Resolving futures part of globals (recursively) ...
[10:26:11.481] resolve() on list ...
[10:26:11.481]  recursive: 99
[10:26:11.481]  length: 1
[10:26:11.481]  elements: ‘a’
[10:26:11.482]  length: 0 (resolved future 1)
[10:26:11.482] resolve() on list ... DONE
[10:26:11.482] - globals: [1] ‘a’
[10:26:11.482] Resolving futures part of globals (recursively) ... DONE
[10:26:11.482] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:11.482] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:26:11.482] - globals: [1] ‘a’
[10:26:11.482] 
[10:26:11.483] getGlobalsAndPackages() ... DONE
[10:26:11.483] run() for ‘Future’ ...
[10:26:11.483] - state: ‘created’
[10:26:11.483] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.483] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.483] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.483]   - Field: ‘label’
[10:26:11.484]   - Field: ‘local’
[10:26:11.484]   - Field: ‘owner’
[10:26:11.484]   - Field: ‘envir’
[10:26:11.484]   - Field: ‘packages’
[10:26:11.484]   - Field: ‘gc’
[10:26:11.484]   - Field: ‘conditions’
[10:26:11.484]   - Field: ‘expr’
[10:26:11.484]   - Field: ‘uuid’
[10:26:11.484]   - Field: ‘seed’
[10:26:11.484]   - Field: ‘version’
[10:26:11.484]   - Field: ‘result’
[10:26:11.484]   - Field: ‘asynchronous’
[10:26:11.485]   - Field: ‘calls’
[10:26:11.485]   - Field: ‘globals’
[10:26:11.485]   - Field: ‘stdout’
[10:26:11.485]   - Field: ‘earlySignal’
[10:26:11.485]   - Field: ‘lazy’
[10:26:11.485]   - Field: ‘state’
[10:26:11.485] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.485] - Launch lazy future ...
[10:26:11.485] Packages needed by the future expression (n = 0): <none>
[10:26:11.485] Packages needed by future strategies (n = 0): <none>
[10:26:11.486] {
[10:26:11.486]     {
[10:26:11.486]         {
[10:26:11.486]             ...future.startTime <- base::Sys.time()
[10:26:11.486]             {
[10:26:11.486]                 {
[10:26:11.486]                   {
[10:26:11.486]                     base::local({
[10:26:11.486]                       has_future <- base::requireNamespace("future", 
[10:26:11.486]                         quietly = TRUE)
[10:26:11.486]                       if (has_future) {
[10:26:11.486]                         ns <- base::getNamespace("future")
[10:26:11.486]                         version <- ns[[".package"]][["version"]]
[10:26:11.486]                         if (is.null(version)) 
[10:26:11.486]                           version <- utils::packageVersion("future")
[10:26:11.486]                       }
[10:26:11.486]                       else {
[10:26:11.486]                         version <- NULL
[10:26:11.486]                       }
[10:26:11.486]                       if (!has_future || version < "1.8.0") {
[10:26:11.486]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.486]                           "", base::R.version$version.string), 
[10:26:11.486]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.486]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.486]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.486]                             "release", "version")], collapse = " "), 
[10:26:11.486]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.486]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.486]                           info)
[10:26:11.486]                         info <- base::paste(info, collapse = "; ")
[10:26:11.486]                         if (!has_future) {
[10:26:11.486]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.486]                             info)
[10:26:11.486]                         }
[10:26:11.486]                         else {
[10:26:11.486]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.486]                             info, version)
[10:26:11.486]                         }
[10:26:11.486]                         base::stop(msg)
[10:26:11.486]                       }
[10:26:11.486]                     })
[10:26:11.486]                   }
[10:26:11.486]                   options(future.plan = NULL)
[10:26:11.486]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.486]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.486]                 }
[10:26:11.486]                 ...future.workdir <- getwd()
[10:26:11.486]             }
[10:26:11.486]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.486]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.486]         }
[10:26:11.486]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.486]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:11.486]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.486]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.486]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.486]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.486]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.486]             base::names(...future.oldOptions))
[10:26:11.486]     }
[10:26:11.486]     if (FALSE) {
[10:26:11.486]     }
[10:26:11.486]     else {
[10:26:11.486]         if (TRUE) {
[10:26:11.486]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.486]                 open = "w")
[10:26:11.486]         }
[10:26:11.486]         else {
[10:26:11.486]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.486]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.486]         }
[10:26:11.486]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.486]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.486]             base::sink(type = "output", split = FALSE)
[10:26:11.486]             base::close(...future.stdout)
[10:26:11.486]         }, add = TRUE)
[10:26:11.486]     }
[10:26:11.486]     ...future.frame <- base::sys.nframe()
[10:26:11.486]     ...future.conditions <- base::list()
[10:26:11.486]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.486]     if (FALSE) {
[10:26:11.486]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.486]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.486]     }
[10:26:11.486]     ...future.result <- base::tryCatch({
[10:26:11.486]         base::withCallingHandlers({
[10:26:11.486]             ...future.value <- base::withVisible(base::local({
[10:26:11.486]                 b <- a
[10:26:11.486]                 a <- 2
[10:26:11.486]                 a * b
[10:26:11.486]             }))
[10:26:11.486]             future::FutureResult(value = ...future.value$value, 
[10:26:11.486]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.486]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.486]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.486]                     ...future.globalenv.names))
[10:26:11.486]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.486]         }, condition = base::local({
[10:26:11.486]             c <- base::c
[10:26:11.486]             inherits <- base::inherits
[10:26:11.486]             invokeRestart <- base::invokeRestart
[10:26:11.486]             length <- base::length
[10:26:11.486]             list <- base::list
[10:26:11.486]             seq.int <- base::seq.int
[10:26:11.486]             signalCondition <- base::signalCondition
[10:26:11.486]             sys.calls <- base::sys.calls
[10:26:11.486]             `[[` <- base::`[[`
[10:26:11.486]             `+` <- base::`+`
[10:26:11.486]             `<<-` <- base::`<<-`
[10:26:11.486]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.486]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.486]                   3L)]
[10:26:11.486]             }
[10:26:11.486]             function(cond) {
[10:26:11.486]                 is_error <- inherits(cond, "error")
[10:26:11.486]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.486]                   NULL)
[10:26:11.486]                 if (is_error) {
[10:26:11.486]                   sessionInformation <- function() {
[10:26:11.486]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.486]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.486]                       search = base::search(), system = base::Sys.info())
[10:26:11.486]                   }
[10:26:11.486]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.486]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.486]                     cond$call), session = sessionInformation(), 
[10:26:11.486]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.486]                   signalCondition(cond)
[10:26:11.486]                 }
[10:26:11.486]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.486]                 "immediateCondition"))) {
[10:26:11.486]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.486]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.486]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.486]                   if (TRUE && !signal) {
[10:26:11.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.486]                     {
[10:26:11.486]                       inherits <- base::inherits
[10:26:11.486]                       invokeRestart <- base::invokeRestart
[10:26:11.486]                       is.null <- base::is.null
[10:26:11.486]                       muffled <- FALSE
[10:26:11.486]                       if (inherits(cond, "message")) {
[10:26:11.486]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.486]                         if (muffled) 
[10:26:11.486]                           invokeRestart("muffleMessage")
[10:26:11.486]                       }
[10:26:11.486]                       else if (inherits(cond, "warning")) {
[10:26:11.486]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.486]                         if (muffled) 
[10:26:11.486]                           invokeRestart("muffleWarning")
[10:26:11.486]                       }
[10:26:11.486]                       else if (inherits(cond, "condition")) {
[10:26:11.486]                         if (!is.null(pattern)) {
[10:26:11.486]                           computeRestarts <- base::computeRestarts
[10:26:11.486]                           grepl <- base::grepl
[10:26:11.486]                           restarts <- computeRestarts(cond)
[10:26:11.486]                           for (restart in restarts) {
[10:26:11.486]                             name <- restart$name
[10:26:11.486]                             if (is.null(name)) 
[10:26:11.486]                               next
[10:26:11.486]                             if (!grepl(pattern, name)) 
[10:26:11.486]                               next
[10:26:11.486]                             invokeRestart(restart)
[10:26:11.486]                             muffled <- TRUE
[10:26:11.486]                             break
[10:26:11.486]                           }
[10:26:11.486]                         }
[10:26:11.486]                       }
[10:26:11.486]                       invisible(muffled)
[10:26:11.486]                     }
[10:26:11.486]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.486]                   }
[10:26:11.486]                 }
[10:26:11.486]                 else {
[10:26:11.486]                   if (TRUE) {
[10:26:11.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.486]                     {
[10:26:11.486]                       inherits <- base::inherits
[10:26:11.486]                       invokeRestart <- base::invokeRestart
[10:26:11.486]                       is.null <- base::is.null
[10:26:11.486]                       muffled <- FALSE
[10:26:11.486]                       if (inherits(cond, "message")) {
[10:26:11.486]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.486]                         if (muffled) 
[10:26:11.486]                           invokeRestart("muffleMessage")
[10:26:11.486]                       }
[10:26:11.486]                       else if (inherits(cond, "warning")) {
[10:26:11.486]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.486]                         if (muffled) 
[10:26:11.486]                           invokeRestart("muffleWarning")
[10:26:11.486]                       }
[10:26:11.486]                       else if (inherits(cond, "condition")) {
[10:26:11.486]                         if (!is.null(pattern)) {
[10:26:11.486]                           computeRestarts <- base::computeRestarts
[10:26:11.486]                           grepl <- base::grepl
[10:26:11.486]                           restarts <- computeRestarts(cond)
[10:26:11.486]                           for (restart in restarts) {
[10:26:11.486]                             name <- restart$name
[10:26:11.486]                             if (is.null(name)) 
[10:26:11.486]                               next
[10:26:11.486]                             if (!grepl(pattern, name)) 
[10:26:11.486]                               next
[10:26:11.486]                             invokeRestart(restart)
[10:26:11.486]                             muffled <- TRUE
[10:26:11.486]                             break
[10:26:11.486]                           }
[10:26:11.486]                         }
[10:26:11.486]                       }
[10:26:11.486]                       invisible(muffled)
[10:26:11.486]                     }
[10:26:11.486]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.486]                   }
[10:26:11.486]                 }
[10:26:11.486]             }
[10:26:11.486]         }))
[10:26:11.486]     }, error = function(ex) {
[10:26:11.486]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.486]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.486]                 ...future.rng), started = ...future.startTime, 
[10:26:11.486]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.486]             version = "1.8"), class = "FutureResult")
[10:26:11.486]     }, finally = {
[10:26:11.486]         if (!identical(...future.workdir, getwd())) 
[10:26:11.486]             setwd(...future.workdir)
[10:26:11.486]         {
[10:26:11.486]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.486]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.486]             }
[10:26:11.486]             base::options(...future.oldOptions)
[10:26:11.486]             if (.Platform$OS.type == "windows") {
[10:26:11.486]                 old_names <- names(...future.oldEnvVars)
[10:26:11.486]                 envs <- base::Sys.getenv()
[10:26:11.486]                 names <- names(envs)
[10:26:11.486]                 common <- intersect(names, old_names)
[10:26:11.486]                 added <- setdiff(names, old_names)
[10:26:11.486]                 removed <- setdiff(old_names, names)
[10:26:11.486]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.486]                   envs[common]]
[10:26:11.486]                 NAMES <- toupper(changed)
[10:26:11.486]                 args <- list()
[10:26:11.486]                 for (kk in seq_along(NAMES)) {
[10:26:11.486]                   name <- changed[[kk]]
[10:26:11.486]                   NAME <- NAMES[[kk]]
[10:26:11.486]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.486]                     next
[10:26:11.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.486]                 }
[10:26:11.486]                 NAMES <- toupper(added)
[10:26:11.486]                 for (kk in seq_along(NAMES)) {
[10:26:11.486]                   name <- added[[kk]]
[10:26:11.486]                   NAME <- NAMES[[kk]]
[10:26:11.486]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.486]                     next
[10:26:11.486]                   args[[name]] <- ""
[10:26:11.486]                 }
[10:26:11.486]                 NAMES <- toupper(removed)
[10:26:11.486]                 for (kk in seq_along(NAMES)) {
[10:26:11.486]                   name <- removed[[kk]]
[10:26:11.486]                   NAME <- NAMES[[kk]]
[10:26:11.486]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.486]                     next
[10:26:11.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.486]                 }
[10:26:11.486]                 if (length(args) > 0) 
[10:26:11.486]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.486]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.486]             }
[10:26:11.486]             else {
[10:26:11.486]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.486]             }
[10:26:11.486]             {
[10:26:11.486]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.486]                   0L) {
[10:26:11.486]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.486]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.486]                   base::options(opts)
[10:26:11.486]                 }
[10:26:11.486]                 {
[10:26:11.486]                   {
[10:26:11.486]                     NULL
[10:26:11.486]                     RNGkind("Mersenne-Twister")
[10:26:11.486]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.486]                       inherits = FALSE)
[10:26:11.486]                   }
[10:26:11.486]                   options(future.plan = NULL)
[10:26:11.486]                   if (is.na(NA_character_)) 
[10:26:11.486]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.486]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.486]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.486]                   {
[10:26:11.486]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.486]                     if (!future$lazy) 
[10:26:11.486]                       future <- run(future)
[10:26:11.486]                     invisible(future)
[10:26:11.486]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.486]                 }
[10:26:11.486]             }
[10:26:11.486]         }
[10:26:11.486]     })
[10:26:11.486]     if (TRUE) {
[10:26:11.486]         base::sink(type = "output", split = FALSE)
[10:26:11.486]         if (TRUE) {
[10:26:11.486]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.486]         }
[10:26:11.486]         else {
[10:26:11.486]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.486]         }
[10:26:11.486]         base::close(...future.stdout)
[10:26:11.486]         ...future.stdout <- NULL
[10:26:11.486]     }
[10:26:11.486]     ...future.result$conditions <- ...future.conditions
[10:26:11.486]     ...future.result$finished <- base::Sys.time()
[10:26:11.486]     ...future.result
[10:26:11.486] }
[10:26:11.487] assign_globals() ...
[10:26:11.487] List of 1
[10:26:11.487]  $ a: num 3
[10:26:11.487]  - attr(*, "where")=List of 1
[10:26:11.487]   ..$ a:<environment: R_EmptyEnv> 
[10:26:11.487]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.487]  - attr(*, "resolved")= logi TRUE
[10:26:11.487]  - attr(*, "total_size")= num 56
[10:26:11.487]  - attr(*, "already-done")= logi TRUE
[10:26:11.490] - copied ‘a’ to environment
[10:26:11.490] assign_globals() ... done
[10:26:11.490] plan(): Setting new future strategy stack:
[10:26:11.490] List of future strategies:
[10:26:11.490] 1. sequential:
[10:26:11.490]    - args: function (..., envir = parent.frame())
[10:26:11.490]    - tweaked: FALSE
[10:26:11.490]    - call: NULL
[10:26:11.490] plan(): nbrOfWorkers() = 1
[10:26:11.491] plan(): Setting new future strategy stack:
[10:26:11.491] List of future strategies:
[10:26:11.491] 1. sequential:
[10:26:11.491]    - args: function (..., envir = parent.frame())
[10:26:11.491]    - tweaked: FALSE
[10:26:11.491]    - call: plan(strategy)
[10:26:11.492] plan(): nbrOfWorkers() = 1
[10:26:11.492] SequentialFuture started (and completed)
[10:26:11.492] - Launch lazy future ... done
[10:26:11.492] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.492] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.493] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:11.495] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:26:11.495] Searching for globals ... DONE
[10:26:11.495] Resolving globals: TRUE
[10:26:11.496] Resolving any globals that are futures ...
[10:26:11.496] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:26:11.496] Resolving any globals that are futures ... DONE
[10:26:11.496] Resolving futures part of globals (recursively) ...
[10:26:11.496] resolve() on list ...
[10:26:11.496]  recursive: 99
[10:26:11.496]  length: 1
[10:26:11.497]  elements: ‘a’
[10:26:11.497]  length: 0 (resolved future 1)
[10:26:11.497] resolve() on list ... DONE
[10:26:11.497] - globals: [1] ‘a’
[10:26:11.497] Resolving futures part of globals (recursively) ... DONE
[10:26:11.497] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:11.497] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:26:11.498] - globals: [1] ‘a’
[10:26:11.498] 
[10:26:11.498] getGlobalsAndPackages() ... DONE
[10:26:11.498] run() for ‘Future’ ...
[10:26:11.498] - state: ‘created’
[10:26:11.498] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.498] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.499] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.499]   - Field: ‘label’
[10:26:11.499]   - Field: ‘local’
[10:26:11.499]   - Field: ‘owner’
[10:26:11.499]   - Field: ‘envir’
[10:26:11.499]   - Field: ‘packages’
[10:26:11.499]   - Field: ‘gc’
[10:26:11.499]   - Field: ‘conditions’
[10:26:11.499]   - Field: ‘expr’
[10:26:11.499]   - Field: ‘uuid’
[10:26:11.499]   - Field: ‘seed’
[10:26:11.500]   - Field: ‘version’
[10:26:11.500]   - Field: ‘result’
[10:26:11.500]   - Field: ‘asynchronous’
[10:26:11.500]   - Field: ‘calls’
[10:26:11.500]   - Field: ‘globals’
[10:26:11.500]   - Field: ‘stdout’
[10:26:11.500]   - Field: ‘earlySignal’
[10:26:11.500]   - Field: ‘lazy’
[10:26:11.500]   - Field: ‘state’
[10:26:11.500] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.500] - Launch lazy future ...
[10:26:11.501] Packages needed by the future expression (n = 0): <none>
[10:26:11.501] Packages needed by future strategies (n = 0): <none>
[10:26:11.501] {
[10:26:11.501]     {
[10:26:11.501]         {
[10:26:11.501]             ...future.startTime <- base::Sys.time()
[10:26:11.501]             {
[10:26:11.501]                 {
[10:26:11.501]                   {
[10:26:11.501]                     base::local({
[10:26:11.501]                       has_future <- base::requireNamespace("future", 
[10:26:11.501]                         quietly = TRUE)
[10:26:11.501]                       if (has_future) {
[10:26:11.501]                         ns <- base::getNamespace("future")
[10:26:11.501]                         version <- ns[[".package"]][["version"]]
[10:26:11.501]                         if (is.null(version)) 
[10:26:11.501]                           version <- utils::packageVersion("future")
[10:26:11.501]                       }
[10:26:11.501]                       else {
[10:26:11.501]                         version <- NULL
[10:26:11.501]                       }
[10:26:11.501]                       if (!has_future || version < "1.8.0") {
[10:26:11.501]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.501]                           "", base::R.version$version.string), 
[10:26:11.501]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.501]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.501]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.501]                             "release", "version")], collapse = " "), 
[10:26:11.501]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.501]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.501]                           info)
[10:26:11.501]                         info <- base::paste(info, collapse = "; ")
[10:26:11.501]                         if (!has_future) {
[10:26:11.501]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.501]                             info)
[10:26:11.501]                         }
[10:26:11.501]                         else {
[10:26:11.501]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.501]                             info, version)
[10:26:11.501]                         }
[10:26:11.501]                         base::stop(msg)
[10:26:11.501]                       }
[10:26:11.501]                     })
[10:26:11.501]                   }
[10:26:11.501]                   options(future.plan = NULL)
[10:26:11.501]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.501]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.501]                 }
[10:26:11.501]                 ...future.workdir <- getwd()
[10:26:11.501]             }
[10:26:11.501]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.501]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.501]         }
[10:26:11.501]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.501]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:11.501]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.501]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.501]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.501]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.501]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.501]             base::names(...future.oldOptions))
[10:26:11.501]     }
[10:26:11.501]     if (FALSE) {
[10:26:11.501]     }
[10:26:11.501]     else {
[10:26:11.501]         if (TRUE) {
[10:26:11.501]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.501]                 open = "w")
[10:26:11.501]         }
[10:26:11.501]         else {
[10:26:11.501]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.501]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.501]         }
[10:26:11.501]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.501]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.501]             base::sink(type = "output", split = FALSE)
[10:26:11.501]             base::close(...future.stdout)
[10:26:11.501]         }, add = TRUE)
[10:26:11.501]     }
[10:26:11.501]     ...future.frame <- base::sys.nframe()
[10:26:11.501]     ...future.conditions <- base::list()
[10:26:11.501]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.501]     if (FALSE) {
[10:26:11.501]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.501]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.501]     }
[10:26:11.501]     ...future.result <- base::tryCatch({
[10:26:11.501]         base::withCallingHandlers({
[10:26:11.501]             ...future.value <- base::withVisible(base::local({
[10:26:11.501]                 b <- a
[10:26:11.501]                 a <- 2
[10:26:11.501]                 a * b
[10:26:11.501]             }))
[10:26:11.501]             future::FutureResult(value = ...future.value$value, 
[10:26:11.501]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.501]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.501]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.501]                     ...future.globalenv.names))
[10:26:11.501]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.501]         }, condition = base::local({
[10:26:11.501]             c <- base::c
[10:26:11.501]             inherits <- base::inherits
[10:26:11.501]             invokeRestart <- base::invokeRestart
[10:26:11.501]             length <- base::length
[10:26:11.501]             list <- base::list
[10:26:11.501]             seq.int <- base::seq.int
[10:26:11.501]             signalCondition <- base::signalCondition
[10:26:11.501]             sys.calls <- base::sys.calls
[10:26:11.501]             `[[` <- base::`[[`
[10:26:11.501]             `+` <- base::`+`
[10:26:11.501]             `<<-` <- base::`<<-`
[10:26:11.501]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.501]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.501]                   3L)]
[10:26:11.501]             }
[10:26:11.501]             function(cond) {
[10:26:11.501]                 is_error <- inherits(cond, "error")
[10:26:11.501]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.501]                   NULL)
[10:26:11.501]                 if (is_error) {
[10:26:11.501]                   sessionInformation <- function() {
[10:26:11.501]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.501]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.501]                       search = base::search(), system = base::Sys.info())
[10:26:11.501]                   }
[10:26:11.501]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.501]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.501]                     cond$call), session = sessionInformation(), 
[10:26:11.501]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.501]                   signalCondition(cond)
[10:26:11.501]                 }
[10:26:11.501]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.501]                 "immediateCondition"))) {
[10:26:11.501]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.501]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.501]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.501]                   if (TRUE && !signal) {
[10:26:11.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.501]                     {
[10:26:11.501]                       inherits <- base::inherits
[10:26:11.501]                       invokeRestart <- base::invokeRestart
[10:26:11.501]                       is.null <- base::is.null
[10:26:11.501]                       muffled <- FALSE
[10:26:11.501]                       if (inherits(cond, "message")) {
[10:26:11.501]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.501]                         if (muffled) 
[10:26:11.501]                           invokeRestart("muffleMessage")
[10:26:11.501]                       }
[10:26:11.501]                       else if (inherits(cond, "warning")) {
[10:26:11.501]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.501]                         if (muffled) 
[10:26:11.501]                           invokeRestart("muffleWarning")
[10:26:11.501]                       }
[10:26:11.501]                       else if (inherits(cond, "condition")) {
[10:26:11.501]                         if (!is.null(pattern)) {
[10:26:11.501]                           computeRestarts <- base::computeRestarts
[10:26:11.501]                           grepl <- base::grepl
[10:26:11.501]                           restarts <- computeRestarts(cond)
[10:26:11.501]                           for (restart in restarts) {
[10:26:11.501]                             name <- restart$name
[10:26:11.501]                             if (is.null(name)) 
[10:26:11.501]                               next
[10:26:11.501]                             if (!grepl(pattern, name)) 
[10:26:11.501]                               next
[10:26:11.501]                             invokeRestart(restart)
[10:26:11.501]                             muffled <- TRUE
[10:26:11.501]                             break
[10:26:11.501]                           }
[10:26:11.501]                         }
[10:26:11.501]                       }
[10:26:11.501]                       invisible(muffled)
[10:26:11.501]                     }
[10:26:11.501]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.501]                   }
[10:26:11.501]                 }
[10:26:11.501]                 else {
[10:26:11.501]                   if (TRUE) {
[10:26:11.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.501]                     {
[10:26:11.501]                       inherits <- base::inherits
[10:26:11.501]                       invokeRestart <- base::invokeRestart
[10:26:11.501]                       is.null <- base::is.null
[10:26:11.501]                       muffled <- FALSE
[10:26:11.501]                       if (inherits(cond, "message")) {
[10:26:11.501]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.501]                         if (muffled) 
[10:26:11.501]                           invokeRestart("muffleMessage")
[10:26:11.501]                       }
[10:26:11.501]                       else if (inherits(cond, "warning")) {
[10:26:11.501]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.501]                         if (muffled) 
[10:26:11.501]                           invokeRestart("muffleWarning")
[10:26:11.501]                       }
[10:26:11.501]                       else if (inherits(cond, "condition")) {
[10:26:11.501]                         if (!is.null(pattern)) {
[10:26:11.501]                           computeRestarts <- base::computeRestarts
[10:26:11.501]                           grepl <- base::grepl
[10:26:11.501]                           restarts <- computeRestarts(cond)
[10:26:11.501]                           for (restart in restarts) {
[10:26:11.501]                             name <- restart$name
[10:26:11.501]                             if (is.null(name)) 
[10:26:11.501]                               next
[10:26:11.501]                             if (!grepl(pattern, name)) 
[10:26:11.501]                               next
[10:26:11.501]                             invokeRestart(restart)
[10:26:11.501]                             muffled <- TRUE
[10:26:11.501]                             break
[10:26:11.501]                           }
[10:26:11.501]                         }
[10:26:11.501]                       }
[10:26:11.501]                       invisible(muffled)
[10:26:11.501]                     }
[10:26:11.501]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.501]                   }
[10:26:11.501]                 }
[10:26:11.501]             }
[10:26:11.501]         }))
[10:26:11.501]     }, error = function(ex) {
[10:26:11.501]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.501]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.501]                 ...future.rng), started = ...future.startTime, 
[10:26:11.501]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.501]             version = "1.8"), class = "FutureResult")
[10:26:11.501]     }, finally = {
[10:26:11.501]         if (!identical(...future.workdir, getwd())) 
[10:26:11.501]             setwd(...future.workdir)
[10:26:11.501]         {
[10:26:11.501]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.501]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.501]             }
[10:26:11.501]             base::options(...future.oldOptions)
[10:26:11.501]             if (.Platform$OS.type == "windows") {
[10:26:11.501]                 old_names <- names(...future.oldEnvVars)
[10:26:11.501]                 envs <- base::Sys.getenv()
[10:26:11.501]                 names <- names(envs)
[10:26:11.501]                 common <- intersect(names, old_names)
[10:26:11.501]                 added <- setdiff(names, old_names)
[10:26:11.501]                 removed <- setdiff(old_names, names)
[10:26:11.501]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.501]                   envs[common]]
[10:26:11.501]                 NAMES <- toupper(changed)
[10:26:11.501]                 args <- list()
[10:26:11.501]                 for (kk in seq_along(NAMES)) {
[10:26:11.501]                   name <- changed[[kk]]
[10:26:11.501]                   NAME <- NAMES[[kk]]
[10:26:11.501]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.501]                     next
[10:26:11.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.501]                 }
[10:26:11.501]                 NAMES <- toupper(added)
[10:26:11.501]                 for (kk in seq_along(NAMES)) {
[10:26:11.501]                   name <- added[[kk]]
[10:26:11.501]                   NAME <- NAMES[[kk]]
[10:26:11.501]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.501]                     next
[10:26:11.501]                   args[[name]] <- ""
[10:26:11.501]                 }
[10:26:11.501]                 NAMES <- toupper(removed)
[10:26:11.501]                 for (kk in seq_along(NAMES)) {
[10:26:11.501]                   name <- removed[[kk]]
[10:26:11.501]                   NAME <- NAMES[[kk]]
[10:26:11.501]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.501]                     next
[10:26:11.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.501]                 }
[10:26:11.501]                 if (length(args) > 0) 
[10:26:11.501]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.501]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.501]             }
[10:26:11.501]             else {
[10:26:11.501]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.501]             }
[10:26:11.501]             {
[10:26:11.501]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.501]                   0L) {
[10:26:11.501]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.501]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.501]                   base::options(opts)
[10:26:11.501]                 }
[10:26:11.501]                 {
[10:26:11.501]                   {
[10:26:11.501]                     NULL
[10:26:11.501]                     RNGkind("Mersenne-Twister")
[10:26:11.501]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.501]                       inherits = FALSE)
[10:26:11.501]                   }
[10:26:11.501]                   options(future.plan = NULL)
[10:26:11.501]                   if (is.na(NA_character_)) 
[10:26:11.501]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.501]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.501]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.501]                   {
[10:26:11.501]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.501]                     if (!future$lazy) 
[10:26:11.501]                       future <- run(future)
[10:26:11.501]                     invisible(future)
[10:26:11.501]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.501]                 }
[10:26:11.501]             }
[10:26:11.501]         }
[10:26:11.501]     })
[10:26:11.501]     if (TRUE) {
[10:26:11.501]         base::sink(type = "output", split = FALSE)
[10:26:11.501]         if (TRUE) {
[10:26:11.501]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.501]         }
[10:26:11.501]         else {
[10:26:11.501]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.501]         }
[10:26:11.501]         base::close(...future.stdout)
[10:26:11.501]         ...future.stdout <- NULL
[10:26:11.501]     }
[10:26:11.501]     ...future.result$conditions <- ...future.conditions
[10:26:11.501]     ...future.result$finished <- base::Sys.time()
[10:26:11.501]     ...future.result
[10:26:11.501] }
[10:26:11.503] assign_globals() ...
[10:26:11.503] List of 1
[10:26:11.503]  $ a: num 3
[10:26:11.503]  - attr(*, "where")=List of 1
[10:26:11.503]   ..$ a:<environment: R_EmptyEnv> 
[10:26:11.503]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.503]  - attr(*, "resolved")= logi TRUE
[10:26:11.503]  - attr(*, "total_size")= num 56
[10:26:11.503]  - attr(*, "already-done")= logi TRUE
[10:26:11.505] - copied ‘a’ to environment
[10:26:11.505] assign_globals() ... done
[10:26:11.505] plan(): Setting new future strategy stack:
[10:26:11.505] List of future strategies:
[10:26:11.505] 1. sequential:
[10:26:11.505]    - args: function (..., envir = parent.frame())
[10:26:11.505]    - tweaked: FALSE
[10:26:11.505]    - call: NULL
[10:26:11.506] plan(): nbrOfWorkers() = 1
[10:26:11.506] plan(): Setting new future strategy stack:
[10:26:11.507] List of future strategies:
[10:26:11.507] 1. sequential:
[10:26:11.507]    - args: function (..., envir = parent.frame())
[10:26:11.507]    - tweaked: FALSE
[10:26:11.507]    - call: plan(strategy)
[10:26:11.507] plan(): nbrOfWorkers() = 1
[10:26:11.507] SequentialFuture started (and completed)
[10:26:11.507] - Launch lazy future ... done
[10:26:11.507] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.508] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.508] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:11.510] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:11.510] Searching for globals ... DONE
[10:26:11.510] Resolving globals: TRUE
[10:26:11.510] Resolving any globals that are futures ...
[10:26:11.510] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:11.510] Resolving any globals that are futures ... DONE
[10:26:11.511] Resolving futures part of globals (recursively) ...
[10:26:11.511] resolve() on list ...
[10:26:11.511]  recursive: 99
[10:26:11.511]  length: 2
[10:26:11.511]  elements: ‘a’, ‘ii’
[10:26:11.511]  length: 1 (resolved future 1)
[10:26:11.511]  length: 0 (resolved future 2)
[10:26:11.511] resolve() on list ... DONE
[10:26:11.511] - globals: [2] ‘a’, ‘ii’
[10:26:11.511] Resolving futures part of globals (recursively) ... DONE
[10:26:11.512] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:11.512] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:26:11.512] - globals: [2] ‘a’, ‘ii’
[10:26:11.512] 
[10:26:11.512] getGlobalsAndPackages() ... DONE
[10:26:11.512] run() for ‘Future’ ...
[10:26:11.513] - state: ‘created’
[10:26:11.513] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.513] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.513] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.513]   - Field: ‘label’
[10:26:11.513]   - Field: ‘local’
[10:26:11.513]   - Field: ‘owner’
[10:26:11.513]   - Field: ‘envir’
[10:26:11.514]   - Field: ‘packages’
[10:26:11.514]   - Field: ‘gc’
[10:26:11.514]   - Field: ‘conditions’
[10:26:11.514]   - Field: ‘expr’
[10:26:11.514]   - Field: ‘uuid’
[10:26:11.514]   - Field: ‘seed’
[10:26:11.514]   - Field: ‘version’
[10:26:11.514]   - Field: ‘result’
[10:26:11.514]   - Field: ‘asynchronous’
[10:26:11.514]   - Field: ‘calls’
[10:26:11.514]   - Field: ‘globals’
[10:26:11.514]   - Field: ‘stdout’
[10:26:11.515]   - Field: ‘earlySignal’
[10:26:11.515]   - Field: ‘lazy’
[10:26:11.515]   - Field: ‘state’
[10:26:11.515] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.515] - Launch lazy future ...
[10:26:11.515] Packages needed by the future expression (n = 0): <none>
[10:26:11.515] Packages needed by future strategies (n = 0): <none>
[10:26:11.516] {
[10:26:11.516]     {
[10:26:11.516]         {
[10:26:11.516]             ...future.startTime <- base::Sys.time()
[10:26:11.516]             {
[10:26:11.516]                 {
[10:26:11.516]                   {
[10:26:11.516]                     base::local({
[10:26:11.516]                       has_future <- base::requireNamespace("future", 
[10:26:11.516]                         quietly = TRUE)
[10:26:11.516]                       if (has_future) {
[10:26:11.516]                         ns <- base::getNamespace("future")
[10:26:11.516]                         version <- ns[[".package"]][["version"]]
[10:26:11.516]                         if (is.null(version)) 
[10:26:11.516]                           version <- utils::packageVersion("future")
[10:26:11.516]                       }
[10:26:11.516]                       else {
[10:26:11.516]                         version <- NULL
[10:26:11.516]                       }
[10:26:11.516]                       if (!has_future || version < "1.8.0") {
[10:26:11.516]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.516]                           "", base::R.version$version.string), 
[10:26:11.516]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.516]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.516]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.516]                             "release", "version")], collapse = " "), 
[10:26:11.516]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.516]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.516]                           info)
[10:26:11.516]                         info <- base::paste(info, collapse = "; ")
[10:26:11.516]                         if (!has_future) {
[10:26:11.516]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.516]                             info)
[10:26:11.516]                         }
[10:26:11.516]                         else {
[10:26:11.516]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.516]                             info, version)
[10:26:11.516]                         }
[10:26:11.516]                         base::stop(msg)
[10:26:11.516]                       }
[10:26:11.516]                     })
[10:26:11.516]                   }
[10:26:11.516]                   options(future.plan = NULL)
[10:26:11.516]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.516]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.516]                 }
[10:26:11.516]                 ...future.workdir <- getwd()
[10:26:11.516]             }
[10:26:11.516]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.516]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.516]         }
[10:26:11.516]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.516]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:11.516]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.516]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.516]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.516]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.516]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.516]             base::names(...future.oldOptions))
[10:26:11.516]     }
[10:26:11.516]     if (FALSE) {
[10:26:11.516]     }
[10:26:11.516]     else {
[10:26:11.516]         if (TRUE) {
[10:26:11.516]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.516]                 open = "w")
[10:26:11.516]         }
[10:26:11.516]         else {
[10:26:11.516]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.516]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.516]         }
[10:26:11.516]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.516]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.516]             base::sink(type = "output", split = FALSE)
[10:26:11.516]             base::close(...future.stdout)
[10:26:11.516]         }, add = TRUE)
[10:26:11.516]     }
[10:26:11.516]     ...future.frame <- base::sys.nframe()
[10:26:11.516]     ...future.conditions <- base::list()
[10:26:11.516]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.516]     if (FALSE) {
[10:26:11.516]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.516]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.516]     }
[10:26:11.516]     ...future.result <- base::tryCatch({
[10:26:11.516]         base::withCallingHandlers({
[10:26:11.516]             ...future.value <- base::withVisible(base::local({
[10:26:11.516]                 b <- a * ii
[10:26:11.516]                 a <- 0
[10:26:11.516]                 b
[10:26:11.516]             }))
[10:26:11.516]             future::FutureResult(value = ...future.value$value, 
[10:26:11.516]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.516]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.516]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.516]                     ...future.globalenv.names))
[10:26:11.516]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.516]         }, condition = base::local({
[10:26:11.516]             c <- base::c
[10:26:11.516]             inherits <- base::inherits
[10:26:11.516]             invokeRestart <- base::invokeRestart
[10:26:11.516]             length <- base::length
[10:26:11.516]             list <- base::list
[10:26:11.516]             seq.int <- base::seq.int
[10:26:11.516]             signalCondition <- base::signalCondition
[10:26:11.516]             sys.calls <- base::sys.calls
[10:26:11.516]             `[[` <- base::`[[`
[10:26:11.516]             `+` <- base::`+`
[10:26:11.516]             `<<-` <- base::`<<-`
[10:26:11.516]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.516]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.516]                   3L)]
[10:26:11.516]             }
[10:26:11.516]             function(cond) {
[10:26:11.516]                 is_error <- inherits(cond, "error")
[10:26:11.516]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.516]                   NULL)
[10:26:11.516]                 if (is_error) {
[10:26:11.516]                   sessionInformation <- function() {
[10:26:11.516]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.516]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.516]                       search = base::search(), system = base::Sys.info())
[10:26:11.516]                   }
[10:26:11.516]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.516]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.516]                     cond$call), session = sessionInformation(), 
[10:26:11.516]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.516]                   signalCondition(cond)
[10:26:11.516]                 }
[10:26:11.516]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.516]                 "immediateCondition"))) {
[10:26:11.516]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.516]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.516]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.516]                   if (TRUE && !signal) {
[10:26:11.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.516]                     {
[10:26:11.516]                       inherits <- base::inherits
[10:26:11.516]                       invokeRestart <- base::invokeRestart
[10:26:11.516]                       is.null <- base::is.null
[10:26:11.516]                       muffled <- FALSE
[10:26:11.516]                       if (inherits(cond, "message")) {
[10:26:11.516]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.516]                         if (muffled) 
[10:26:11.516]                           invokeRestart("muffleMessage")
[10:26:11.516]                       }
[10:26:11.516]                       else if (inherits(cond, "warning")) {
[10:26:11.516]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.516]                         if (muffled) 
[10:26:11.516]                           invokeRestart("muffleWarning")
[10:26:11.516]                       }
[10:26:11.516]                       else if (inherits(cond, "condition")) {
[10:26:11.516]                         if (!is.null(pattern)) {
[10:26:11.516]                           computeRestarts <- base::computeRestarts
[10:26:11.516]                           grepl <- base::grepl
[10:26:11.516]                           restarts <- computeRestarts(cond)
[10:26:11.516]                           for (restart in restarts) {
[10:26:11.516]                             name <- restart$name
[10:26:11.516]                             if (is.null(name)) 
[10:26:11.516]                               next
[10:26:11.516]                             if (!grepl(pattern, name)) 
[10:26:11.516]                               next
[10:26:11.516]                             invokeRestart(restart)
[10:26:11.516]                             muffled <- TRUE
[10:26:11.516]                             break
[10:26:11.516]                           }
[10:26:11.516]                         }
[10:26:11.516]                       }
[10:26:11.516]                       invisible(muffled)
[10:26:11.516]                     }
[10:26:11.516]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.516]                   }
[10:26:11.516]                 }
[10:26:11.516]                 else {
[10:26:11.516]                   if (TRUE) {
[10:26:11.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.516]                     {
[10:26:11.516]                       inherits <- base::inherits
[10:26:11.516]                       invokeRestart <- base::invokeRestart
[10:26:11.516]                       is.null <- base::is.null
[10:26:11.516]                       muffled <- FALSE
[10:26:11.516]                       if (inherits(cond, "message")) {
[10:26:11.516]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.516]                         if (muffled) 
[10:26:11.516]                           invokeRestart("muffleMessage")
[10:26:11.516]                       }
[10:26:11.516]                       else if (inherits(cond, "warning")) {
[10:26:11.516]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.516]                         if (muffled) 
[10:26:11.516]                           invokeRestart("muffleWarning")
[10:26:11.516]                       }
[10:26:11.516]                       else if (inherits(cond, "condition")) {
[10:26:11.516]                         if (!is.null(pattern)) {
[10:26:11.516]                           computeRestarts <- base::computeRestarts
[10:26:11.516]                           grepl <- base::grepl
[10:26:11.516]                           restarts <- computeRestarts(cond)
[10:26:11.516]                           for (restart in restarts) {
[10:26:11.516]                             name <- restart$name
[10:26:11.516]                             if (is.null(name)) 
[10:26:11.516]                               next
[10:26:11.516]                             if (!grepl(pattern, name)) 
[10:26:11.516]                               next
[10:26:11.516]                             invokeRestart(restart)
[10:26:11.516]                             muffled <- TRUE
[10:26:11.516]                             break
[10:26:11.516]                           }
[10:26:11.516]                         }
[10:26:11.516]                       }
[10:26:11.516]                       invisible(muffled)
[10:26:11.516]                     }
[10:26:11.516]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.516]                   }
[10:26:11.516]                 }
[10:26:11.516]             }
[10:26:11.516]         }))
[10:26:11.516]     }, error = function(ex) {
[10:26:11.516]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.516]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.516]                 ...future.rng), started = ...future.startTime, 
[10:26:11.516]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.516]             version = "1.8"), class = "FutureResult")
[10:26:11.516]     }, finally = {
[10:26:11.516]         if (!identical(...future.workdir, getwd())) 
[10:26:11.516]             setwd(...future.workdir)
[10:26:11.516]         {
[10:26:11.516]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.516]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.516]             }
[10:26:11.516]             base::options(...future.oldOptions)
[10:26:11.516]             if (.Platform$OS.type == "windows") {
[10:26:11.516]                 old_names <- names(...future.oldEnvVars)
[10:26:11.516]                 envs <- base::Sys.getenv()
[10:26:11.516]                 names <- names(envs)
[10:26:11.516]                 common <- intersect(names, old_names)
[10:26:11.516]                 added <- setdiff(names, old_names)
[10:26:11.516]                 removed <- setdiff(old_names, names)
[10:26:11.516]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.516]                   envs[common]]
[10:26:11.516]                 NAMES <- toupper(changed)
[10:26:11.516]                 args <- list()
[10:26:11.516]                 for (kk in seq_along(NAMES)) {
[10:26:11.516]                   name <- changed[[kk]]
[10:26:11.516]                   NAME <- NAMES[[kk]]
[10:26:11.516]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.516]                     next
[10:26:11.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.516]                 }
[10:26:11.516]                 NAMES <- toupper(added)
[10:26:11.516]                 for (kk in seq_along(NAMES)) {
[10:26:11.516]                   name <- added[[kk]]
[10:26:11.516]                   NAME <- NAMES[[kk]]
[10:26:11.516]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.516]                     next
[10:26:11.516]                   args[[name]] <- ""
[10:26:11.516]                 }
[10:26:11.516]                 NAMES <- toupper(removed)
[10:26:11.516]                 for (kk in seq_along(NAMES)) {
[10:26:11.516]                   name <- removed[[kk]]
[10:26:11.516]                   NAME <- NAMES[[kk]]
[10:26:11.516]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.516]                     next
[10:26:11.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.516]                 }
[10:26:11.516]                 if (length(args) > 0) 
[10:26:11.516]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.516]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.516]             }
[10:26:11.516]             else {
[10:26:11.516]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.516]             }
[10:26:11.516]             {
[10:26:11.516]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.516]                   0L) {
[10:26:11.516]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.516]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.516]                   base::options(opts)
[10:26:11.516]                 }
[10:26:11.516]                 {
[10:26:11.516]                   {
[10:26:11.516]                     NULL
[10:26:11.516]                     RNGkind("Mersenne-Twister")
[10:26:11.516]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.516]                       inherits = FALSE)
[10:26:11.516]                   }
[10:26:11.516]                   options(future.plan = NULL)
[10:26:11.516]                   if (is.na(NA_character_)) 
[10:26:11.516]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.516]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.516]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.516]                   {
[10:26:11.516]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.516]                     if (!future$lazy) 
[10:26:11.516]                       future <- run(future)
[10:26:11.516]                     invisible(future)
[10:26:11.516]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.516]                 }
[10:26:11.516]             }
[10:26:11.516]         }
[10:26:11.516]     })
[10:26:11.516]     if (TRUE) {
[10:26:11.516]         base::sink(type = "output", split = FALSE)
[10:26:11.516]         if (TRUE) {
[10:26:11.516]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.516]         }
[10:26:11.516]         else {
[10:26:11.516]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.516]         }
[10:26:11.516]         base::close(...future.stdout)
[10:26:11.516]         ...future.stdout <- NULL
[10:26:11.516]     }
[10:26:11.516]     ...future.result$conditions <- ...future.conditions
[10:26:11.516]     ...future.result$finished <- base::Sys.time()
[10:26:11.516]     ...future.result
[10:26:11.516] }
[10:26:11.517] assign_globals() ...
[10:26:11.517] List of 2
[10:26:11.517]  $ a : num 1
[10:26:11.517]  $ ii: int 1
[10:26:11.517]  - attr(*, "where")=List of 2
[10:26:11.517]   ..$ a :<environment: R_EmptyEnv> 
[10:26:11.517]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:11.517]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.517]  - attr(*, "resolved")= logi TRUE
[10:26:11.517]  - attr(*, "total_size")= num 112
[10:26:11.517]  - attr(*, "already-done")= logi TRUE
[10:26:11.521] - copied ‘a’ to environment
[10:26:11.521] - copied ‘ii’ to environment
[10:26:11.521] assign_globals() ... done
[10:26:11.522] plan(): Setting new future strategy stack:
[10:26:11.522] List of future strategies:
[10:26:11.522] 1. sequential:
[10:26:11.522]    - args: function (..., envir = parent.frame())
[10:26:11.522]    - tweaked: FALSE
[10:26:11.522]    - call: NULL
[10:26:11.522] plan(): nbrOfWorkers() = 1
[10:26:11.523] plan(): Setting new future strategy stack:
[10:26:11.523] List of future strategies:
[10:26:11.523] 1. sequential:
[10:26:11.523]    - args: function (..., envir = parent.frame())
[10:26:11.523]    - tweaked: FALSE
[10:26:11.523]    - call: plan(strategy)
[10:26:11.523] plan(): nbrOfWorkers() = 1
[10:26:11.523] SequentialFuture started (and completed)
[10:26:11.523] - Launch lazy future ... done
[10:26:11.524] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.524] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.524] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:11.526] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:11.526] Searching for globals ... DONE
[10:26:11.526] Resolving globals: TRUE
[10:26:11.526] Resolving any globals that are futures ...
[10:26:11.526] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:11.526] Resolving any globals that are futures ... DONE
[10:26:11.527] Resolving futures part of globals (recursively) ...
[10:26:11.527] resolve() on list ...
[10:26:11.527]  recursive: 99
[10:26:11.527]  length: 2
[10:26:11.527]  elements: ‘a’, ‘ii’
[10:26:11.527]  length: 1 (resolved future 1)
[10:26:11.527]  length: 0 (resolved future 2)
[10:26:11.527] resolve() on list ... DONE
[10:26:11.527] - globals: [2] ‘a’, ‘ii’
[10:26:11.528] Resolving futures part of globals (recursively) ... DONE
[10:26:11.528] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:11.528] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:26:11.528] - globals: [2] ‘a’, ‘ii’
[10:26:11.528] 
[10:26:11.528] getGlobalsAndPackages() ... DONE
[10:26:11.529] run() for ‘Future’ ...
[10:26:11.529] - state: ‘created’
[10:26:11.529] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.529] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.529] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.529]   - Field: ‘label’
[10:26:11.529]   - Field: ‘local’
[10:26:11.529]   - Field: ‘owner’
[10:26:11.530]   - Field: ‘envir’
[10:26:11.530]   - Field: ‘packages’
[10:26:11.530]   - Field: ‘gc’
[10:26:11.530]   - Field: ‘conditions’
[10:26:11.530]   - Field: ‘expr’
[10:26:11.530]   - Field: ‘uuid’
[10:26:11.530]   - Field: ‘seed’
[10:26:11.530]   - Field: ‘version’
[10:26:11.530]   - Field: ‘result’
[10:26:11.530]   - Field: ‘asynchronous’
[10:26:11.530]   - Field: ‘calls’
[10:26:11.531]   - Field: ‘globals’
[10:26:11.531]   - Field: ‘stdout’
[10:26:11.531]   - Field: ‘earlySignal’
[10:26:11.531]   - Field: ‘lazy’
[10:26:11.531]   - Field: ‘state’
[10:26:11.531] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.531] - Launch lazy future ...
[10:26:11.531] Packages needed by the future expression (n = 0): <none>
[10:26:11.531] Packages needed by future strategies (n = 0): <none>
[10:26:11.532] {
[10:26:11.532]     {
[10:26:11.532]         {
[10:26:11.532]             ...future.startTime <- base::Sys.time()
[10:26:11.532]             {
[10:26:11.532]                 {
[10:26:11.532]                   {
[10:26:11.532]                     base::local({
[10:26:11.532]                       has_future <- base::requireNamespace("future", 
[10:26:11.532]                         quietly = TRUE)
[10:26:11.532]                       if (has_future) {
[10:26:11.532]                         ns <- base::getNamespace("future")
[10:26:11.532]                         version <- ns[[".package"]][["version"]]
[10:26:11.532]                         if (is.null(version)) 
[10:26:11.532]                           version <- utils::packageVersion("future")
[10:26:11.532]                       }
[10:26:11.532]                       else {
[10:26:11.532]                         version <- NULL
[10:26:11.532]                       }
[10:26:11.532]                       if (!has_future || version < "1.8.0") {
[10:26:11.532]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.532]                           "", base::R.version$version.string), 
[10:26:11.532]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.532]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.532]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.532]                             "release", "version")], collapse = " "), 
[10:26:11.532]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.532]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.532]                           info)
[10:26:11.532]                         info <- base::paste(info, collapse = "; ")
[10:26:11.532]                         if (!has_future) {
[10:26:11.532]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.532]                             info)
[10:26:11.532]                         }
[10:26:11.532]                         else {
[10:26:11.532]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.532]                             info, version)
[10:26:11.532]                         }
[10:26:11.532]                         base::stop(msg)
[10:26:11.532]                       }
[10:26:11.532]                     })
[10:26:11.532]                   }
[10:26:11.532]                   options(future.plan = NULL)
[10:26:11.532]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.532]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.532]                 }
[10:26:11.532]                 ...future.workdir <- getwd()
[10:26:11.532]             }
[10:26:11.532]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.532]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.532]         }
[10:26:11.532]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.532]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:11.532]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.532]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.532]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.532]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.532]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.532]             base::names(...future.oldOptions))
[10:26:11.532]     }
[10:26:11.532]     if (FALSE) {
[10:26:11.532]     }
[10:26:11.532]     else {
[10:26:11.532]         if (TRUE) {
[10:26:11.532]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.532]                 open = "w")
[10:26:11.532]         }
[10:26:11.532]         else {
[10:26:11.532]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.532]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.532]         }
[10:26:11.532]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.532]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.532]             base::sink(type = "output", split = FALSE)
[10:26:11.532]             base::close(...future.stdout)
[10:26:11.532]         }, add = TRUE)
[10:26:11.532]     }
[10:26:11.532]     ...future.frame <- base::sys.nframe()
[10:26:11.532]     ...future.conditions <- base::list()
[10:26:11.532]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.532]     if (FALSE) {
[10:26:11.532]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.532]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.532]     }
[10:26:11.532]     ...future.result <- base::tryCatch({
[10:26:11.532]         base::withCallingHandlers({
[10:26:11.532]             ...future.value <- base::withVisible(base::local({
[10:26:11.532]                 b <- a * ii
[10:26:11.532]                 a <- 0
[10:26:11.532]                 b
[10:26:11.532]             }))
[10:26:11.532]             future::FutureResult(value = ...future.value$value, 
[10:26:11.532]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.532]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.532]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.532]                     ...future.globalenv.names))
[10:26:11.532]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.532]         }, condition = base::local({
[10:26:11.532]             c <- base::c
[10:26:11.532]             inherits <- base::inherits
[10:26:11.532]             invokeRestart <- base::invokeRestart
[10:26:11.532]             length <- base::length
[10:26:11.532]             list <- base::list
[10:26:11.532]             seq.int <- base::seq.int
[10:26:11.532]             signalCondition <- base::signalCondition
[10:26:11.532]             sys.calls <- base::sys.calls
[10:26:11.532]             `[[` <- base::`[[`
[10:26:11.532]             `+` <- base::`+`
[10:26:11.532]             `<<-` <- base::`<<-`
[10:26:11.532]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.532]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.532]                   3L)]
[10:26:11.532]             }
[10:26:11.532]             function(cond) {
[10:26:11.532]                 is_error <- inherits(cond, "error")
[10:26:11.532]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.532]                   NULL)
[10:26:11.532]                 if (is_error) {
[10:26:11.532]                   sessionInformation <- function() {
[10:26:11.532]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.532]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.532]                       search = base::search(), system = base::Sys.info())
[10:26:11.532]                   }
[10:26:11.532]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.532]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.532]                     cond$call), session = sessionInformation(), 
[10:26:11.532]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.532]                   signalCondition(cond)
[10:26:11.532]                 }
[10:26:11.532]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.532]                 "immediateCondition"))) {
[10:26:11.532]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.532]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.532]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.532]                   if (TRUE && !signal) {
[10:26:11.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.532]                     {
[10:26:11.532]                       inherits <- base::inherits
[10:26:11.532]                       invokeRestart <- base::invokeRestart
[10:26:11.532]                       is.null <- base::is.null
[10:26:11.532]                       muffled <- FALSE
[10:26:11.532]                       if (inherits(cond, "message")) {
[10:26:11.532]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.532]                         if (muffled) 
[10:26:11.532]                           invokeRestart("muffleMessage")
[10:26:11.532]                       }
[10:26:11.532]                       else if (inherits(cond, "warning")) {
[10:26:11.532]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.532]                         if (muffled) 
[10:26:11.532]                           invokeRestart("muffleWarning")
[10:26:11.532]                       }
[10:26:11.532]                       else if (inherits(cond, "condition")) {
[10:26:11.532]                         if (!is.null(pattern)) {
[10:26:11.532]                           computeRestarts <- base::computeRestarts
[10:26:11.532]                           grepl <- base::grepl
[10:26:11.532]                           restarts <- computeRestarts(cond)
[10:26:11.532]                           for (restart in restarts) {
[10:26:11.532]                             name <- restart$name
[10:26:11.532]                             if (is.null(name)) 
[10:26:11.532]                               next
[10:26:11.532]                             if (!grepl(pattern, name)) 
[10:26:11.532]                               next
[10:26:11.532]                             invokeRestart(restart)
[10:26:11.532]                             muffled <- TRUE
[10:26:11.532]                             break
[10:26:11.532]                           }
[10:26:11.532]                         }
[10:26:11.532]                       }
[10:26:11.532]                       invisible(muffled)
[10:26:11.532]                     }
[10:26:11.532]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.532]                   }
[10:26:11.532]                 }
[10:26:11.532]                 else {
[10:26:11.532]                   if (TRUE) {
[10:26:11.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.532]                     {
[10:26:11.532]                       inherits <- base::inherits
[10:26:11.532]                       invokeRestart <- base::invokeRestart
[10:26:11.532]                       is.null <- base::is.null
[10:26:11.532]                       muffled <- FALSE
[10:26:11.532]                       if (inherits(cond, "message")) {
[10:26:11.532]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.532]                         if (muffled) 
[10:26:11.532]                           invokeRestart("muffleMessage")
[10:26:11.532]                       }
[10:26:11.532]                       else if (inherits(cond, "warning")) {
[10:26:11.532]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.532]                         if (muffled) 
[10:26:11.532]                           invokeRestart("muffleWarning")
[10:26:11.532]                       }
[10:26:11.532]                       else if (inherits(cond, "condition")) {
[10:26:11.532]                         if (!is.null(pattern)) {
[10:26:11.532]                           computeRestarts <- base::computeRestarts
[10:26:11.532]                           grepl <- base::grepl
[10:26:11.532]                           restarts <- computeRestarts(cond)
[10:26:11.532]                           for (restart in restarts) {
[10:26:11.532]                             name <- restart$name
[10:26:11.532]                             if (is.null(name)) 
[10:26:11.532]                               next
[10:26:11.532]                             if (!grepl(pattern, name)) 
[10:26:11.532]                               next
[10:26:11.532]                             invokeRestart(restart)
[10:26:11.532]                             muffled <- TRUE
[10:26:11.532]                             break
[10:26:11.532]                           }
[10:26:11.532]                         }
[10:26:11.532]                       }
[10:26:11.532]                       invisible(muffled)
[10:26:11.532]                     }
[10:26:11.532]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.532]                   }
[10:26:11.532]                 }
[10:26:11.532]             }
[10:26:11.532]         }))
[10:26:11.532]     }, error = function(ex) {
[10:26:11.532]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.532]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.532]                 ...future.rng), started = ...future.startTime, 
[10:26:11.532]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.532]             version = "1.8"), class = "FutureResult")
[10:26:11.532]     }, finally = {
[10:26:11.532]         if (!identical(...future.workdir, getwd())) 
[10:26:11.532]             setwd(...future.workdir)
[10:26:11.532]         {
[10:26:11.532]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.532]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.532]             }
[10:26:11.532]             base::options(...future.oldOptions)
[10:26:11.532]             if (.Platform$OS.type == "windows") {
[10:26:11.532]                 old_names <- names(...future.oldEnvVars)
[10:26:11.532]                 envs <- base::Sys.getenv()
[10:26:11.532]                 names <- names(envs)
[10:26:11.532]                 common <- intersect(names, old_names)
[10:26:11.532]                 added <- setdiff(names, old_names)
[10:26:11.532]                 removed <- setdiff(old_names, names)
[10:26:11.532]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.532]                   envs[common]]
[10:26:11.532]                 NAMES <- toupper(changed)
[10:26:11.532]                 args <- list()
[10:26:11.532]                 for (kk in seq_along(NAMES)) {
[10:26:11.532]                   name <- changed[[kk]]
[10:26:11.532]                   NAME <- NAMES[[kk]]
[10:26:11.532]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.532]                     next
[10:26:11.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.532]                 }
[10:26:11.532]                 NAMES <- toupper(added)
[10:26:11.532]                 for (kk in seq_along(NAMES)) {
[10:26:11.532]                   name <- added[[kk]]
[10:26:11.532]                   NAME <- NAMES[[kk]]
[10:26:11.532]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.532]                     next
[10:26:11.532]                   args[[name]] <- ""
[10:26:11.532]                 }
[10:26:11.532]                 NAMES <- toupper(removed)
[10:26:11.532]                 for (kk in seq_along(NAMES)) {
[10:26:11.532]                   name <- removed[[kk]]
[10:26:11.532]                   NAME <- NAMES[[kk]]
[10:26:11.532]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.532]                     next
[10:26:11.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.532]                 }
[10:26:11.532]                 if (length(args) > 0) 
[10:26:11.532]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.532]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.532]             }
[10:26:11.532]             else {
[10:26:11.532]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.532]             }
[10:26:11.532]             {
[10:26:11.532]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.532]                   0L) {
[10:26:11.532]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.532]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.532]                   base::options(opts)
[10:26:11.532]                 }
[10:26:11.532]                 {
[10:26:11.532]                   {
[10:26:11.532]                     NULL
[10:26:11.532]                     RNGkind("Mersenne-Twister")
[10:26:11.532]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.532]                       inherits = FALSE)
[10:26:11.532]                   }
[10:26:11.532]                   options(future.plan = NULL)
[10:26:11.532]                   if (is.na(NA_character_)) 
[10:26:11.532]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.532]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.532]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.532]                   {
[10:26:11.532]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.532]                     if (!future$lazy) 
[10:26:11.532]                       future <- run(future)
[10:26:11.532]                     invisible(future)
[10:26:11.532]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.532]                 }
[10:26:11.532]             }
[10:26:11.532]         }
[10:26:11.532]     })
[10:26:11.532]     if (TRUE) {
[10:26:11.532]         base::sink(type = "output", split = FALSE)
[10:26:11.532]         if (TRUE) {
[10:26:11.532]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.532]         }
[10:26:11.532]         else {
[10:26:11.532]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.532]         }
[10:26:11.532]         base::close(...future.stdout)
[10:26:11.532]         ...future.stdout <- NULL
[10:26:11.532]     }
[10:26:11.532]     ...future.result$conditions <- ...future.conditions
[10:26:11.532]     ...future.result$finished <- base::Sys.time()
[10:26:11.532]     ...future.result
[10:26:11.532] }
[10:26:11.533] assign_globals() ...
[10:26:11.533] List of 2
[10:26:11.533]  $ a : num 1
[10:26:11.533]  $ ii: int 2
[10:26:11.533]  - attr(*, "where")=List of 2
[10:26:11.533]   ..$ a :<environment: R_EmptyEnv> 
[10:26:11.533]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:11.533]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.533]  - attr(*, "resolved")= logi TRUE
[10:26:11.533]  - attr(*, "total_size")= num 112
[10:26:11.533]  - attr(*, "already-done")= logi TRUE
[10:26:11.536] - copied ‘a’ to environment
[10:26:11.536] - copied ‘ii’ to environment
[10:26:11.536] assign_globals() ... done
[10:26:11.537] plan(): Setting new future strategy stack:
[10:26:11.537] List of future strategies:
[10:26:11.537] 1. sequential:
[10:26:11.537]    - args: function (..., envir = parent.frame())
[10:26:11.537]    - tweaked: FALSE
[10:26:11.537]    - call: NULL
[10:26:11.537] plan(): nbrOfWorkers() = 1
[10:26:11.538] plan(): Setting new future strategy stack:
[10:26:11.538] List of future strategies:
[10:26:11.538] 1. sequential:
[10:26:11.538]    - args: function (..., envir = parent.frame())
[10:26:11.538]    - tweaked: FALSE
[10:26:11.538]    - call: plan(strategy)
[10:26:11.538] plan(): nbrOfWorkers() = 1
[10:26:11.538] SequentialFuture started (and completed)
[10:26:11.538] - Launch lazy future ... done
[10:26:11.538] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.539] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.539] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:11.542] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:11.542] Searching for globals ... DONE
[10:26:11.542] Resolving globals: TRUE
[10:26:11.542] Resolving any globals that are futures ...
[10:26:11.542] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:11.542] Resolving any globals that are futures ... DONE
[10:26:11.542] Resolving futures part of globals (recursively) ...
[10:26:11.543] resolve() on list ...
[10:26:11.543]  recursive: 99
[10:26:11.543]  length: 2
[10:26:11.543]  elements: ‘a’, ‘ii’
[10:26:11.543]  length: 1 (resolved future 1)
[10:26:11.543]  length: 0 (resolved future 2)
[10:26:11.543] resolve() on list ... DONE
[10:26:11.543] - globals: [2] ‘a’, ‘ii’
[10:26:11.543] Resolving futures part of globals (recursively) ... DONE
[10:26:11.544] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:11.544] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:26:11.544] - globals: [2] ‘a’, ‘ii’
[10:26:11.544] 
[10:26:11.544] getGlobalsAndPackages() ... DONE
[10:26:11.544] run() for ‘Future’ ...
[10:26:11.545] - state: ‘created’
[10:26:11.545] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.545] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.545] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.545]   - Field: ‘label’
[10:26:11.545]   - Field: ‘local’
[10:26:11.545]   - Field: ‘owner’
[10:26:11.545]   - Field: ‘envir’
[10:26:11.545]   - Field: ‘packages’
[10:26:11.546]   - Field: ‘gc’
[10:26:11.546]   - Field: ‘conditions’
[10:26:11.546]   - Field: ‘expr’
[10:26:11.546]   - Field: ‘uuid’
[10:26:11.546]   - Field: ‘seed’
[10:26:11.546]   - Field: ‘version’
[10:26:11.546]   - Field: ‘result’
[10:26:11.546]   - Field: ‘asynchronous’
[10:26:11.546]   - Field: ‘calls’
[10:26:11.546]   - Field: ‘globals’
[10:26:11.546]   - Field: ‘stdout’
[10:26:11.547]   - Field: ‘earlySignal’
[10:26:11.547]   - Field: ‘lazy’
[10:26:11.547]   - Field: ‘state’
[10:26:11.547] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.547] - Launch lazy future ...
[10:26:11.547] Packages needed by the future expression (n = 0): <none>
[10:26:11.547] Packages needed by future strategies (n = 0): <none>
[10:26:11.547] {
[10:26:11.547]     {
[10:26:11.547]         {
[10:26:11.547]             ...future.startTime <- base::Sys.time()
[10:26:11.547]             {
[10:26:11.547]                 {
[10:26:11.547]                   {
[10:26:11.547]                     base::local({
[10:26:11.547]                       has_future <- base::requireNamespace("future", 
[10:26:11.547]                         quietly = TRUE)
[10:26:11.547]                       if (has_future) {
[10:26:11.547]                         ns <- base::getNamespace("future")
[10:26:11.547]                         version <- ns[[".package"]][["version"]]
[10:26:11.547]                         if (is.null(version)) 
[10:26:11.547]                           version <- utils::packageVersion("future")
[10:26:11.547]                       }
[10:26:11.547]                       else {
[10:26:11.547]                         version <- NULL
[10:26:11.547]                       }
[10:26:11.547]                       if (!has_future || version < "1.8.0") {
[10:26:11.547]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.547]                           "", base::R.version$version.string), 
[10:26:11.547]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.547]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.547]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.547]                             "release", "version")], collapse = " "), 
[10:26:11.547]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.547]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.547]                           info)
[10:26:11.547]                         info <- base::paste(info, collapse = "; ")
[10:26:11.547]                         if (!has_future) {
[10:26:11.547]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.547]                             info)
[10:26:11.547]                         }
[10:26:11.547]                         else {
[10:26:11.547]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.547]                             info, version)
[10:26:11.547]                         }
[10:26:11.547]                         base::stop(msg)
[10:26:11.547]                       }
[10:26:11.547]                     })
[10:26:11.547]                   }
[10:26:11.547]                   options(future.plan = NULL)
[10:26:11.547]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.547]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.547]                 }
[10:26:11.547]                 ...future.workdir <- getwd()
[10:26:11.547]             }
[10:26:11.547]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.547]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.547]         }
[10:26:11.547]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.547]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:11.547]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.547]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.547]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.547]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.547]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.547]             base::names(...future.oldOptions))
[10:26:11.547]     }
[10:26:11.547]     if (FALSE) {
[10:26:11.547]     }
[10:26:11.547]     else {
[10:26:11.547]         if (TRUE) {
[10:26:11.547]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.547]                 open = "w")
[10:26:11.547]         }
[10:26:11.547]         else {
[10:26:11.547]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.547]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.547]         }
[10:26:11.547]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.547]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.547]             base::sink(type = "output", split = FALSE)
[10:26:11.547]             base::close(...future.stdout)
[10:26:11.547]         }, add = TRUE)
[10:26:11.547]     }
[10:26:11.547]     ...future.frame <- base::sys.nframe()
[10:26:11.547]     ...future.conditions <- base::list()
[10:26:11.547]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.547]     if (FALSE) {
[10:26:11.547]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.547]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.547]     }
[10:26:11.547]     ...future.result <- base::tryCatch({
[10:26:11.547]         base::withCallingHandlers({
[10:26:11.547]             ...future.value <- base::withVisible(base::local({
[10:26:11.547]                 b <- a * ii
[10:26:11.547]                 a <- 0
[10:26:11.547]                 b
[10:26:11.547]             }))
[10:26:11.547]             future::FutureResult(value = ...future.value$value, 
[10:26:11.547]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.547]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.547]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.547]                     ...future.globalenv.names))
[10:26:11.547]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.547]         }, condition = base::local({
[10:26:11.547]             c <- base::c
[10:26:11.547]             inherits <- base::inherits
[10:26:11.547]             invokeRestart <- base::invokeRestart
[10:26:11.547]             length <- base::length
[10:26:11.547]             list <- base::list
[10:26:11.547]             seq.int <- base::seq.int
[10:26:11.547]             signalCondition <- base::signalCondition
[10:26:11.547]             sys.calls <- base::sys.calls
[10:26:11.547]             `[[` <- base::`[[`
[10:26:11.547]             `+` <- base::`+`
[10:26:11.547]             `<<-` <- base::`<<-`
[10:26:11.547]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.547]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.547]                   3L)]
[10:26:11.547]             }
[10:26:11.547]             function(cond) {
[10:26:11.547]                 is_error <- inherits(cond, "error")
[10:26:11.547]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.547]                   NULL)
[10:26:11.547]                 if (is_error) {
[10:26:11.547]                   sessionInformation <- function() {
[10:26:11.547]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.547]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.547]                       search = base::search(), system = base::Sys.info())
[10:26:11.547]                   }
[10:26:11.547]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.547]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.547]                     cond$call), session = sessionInformation(), 
[10:26:11.547]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.547]                   signalCondition(cond)
[10:26:11.547]                 }
[10:26:11.547]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.547]                 "immediateCondition"))) {
[10:26:11.547]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.547]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.547]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.547]                   if (TRUE && !signal) {
[10:26:11.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.547]                     {
[10:26:11.547]                       inherits <- base::inherits
[10:26:11.547]                       invokeRestart <- base::invokeRestart
[10:26:11.547]                       is.null <- base::is.null
[10:26:11.547]                       muffled <- FALSE
[10:26:11.547]                       if (inherits(cond, "message")) {
[10:26:11.547]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.547]                         if (muffled) 
[10:26:11.547]                           invokeRestart("muffleMessage")
[10:26:11.547]                       }
[10:26:11.547]                       else if (inherits(cond, "warning")) {
[10:26:11.547]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.547]                         if (muffled) 
[10:26:11.547]                           invokeRestart("muffleWarning")
[10:26:11.547]                       }
[10:26:11.547]                       else if (inherits(cond, "condition")) {
[10:26:11.547]                         if (!is.null(pattern)) {
[10:26:11.547]                           computeRestarts <- base::computeRestarts
[10:26:11.547]                           grepl <- base::grepl
[10:26:11.547]                           restarts <- computeRestarts(cond)
[10:26:11.547]                           for (restart in restarts) {
[10:26:11.547]                             name <- restart$name
[10:26:11.547]                             if (is.null(name)) 
[10:26:11.547]                               next
[10:26:11.547]                             if (!grepl(pattern, name)) 
[10:26:11.547]                               next
[10:26:11.547]                             invokeRestart(restart)
[10:26:11.547]                             muffled <- TRUE
[10:26:11.547]                             break
[10:26:11.547]                           }
[10:26:11.547]                         }
[10:26:11.547]                       }
[10:26:11.547]                       invisible(muffled)
[10:26:11.547]                     }
[10:26:11.547]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.547]                   }
[10:26:11.547]                 }
[10:26:11.547]                 else {
[10:26:11.547]                   if (TRUE) {
[10:26:11.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.547]                     {
[10:26:11.547]                       inherits <- base::inherits
[10:26:11.547]                       invokeRestart <- base::invokeRestart
[10:26:11.547]                       is.null <- base::is.null
[10:26:11.547]                       muffled <- FALSE
[10:26:11.547]                       if (inherits(cond, "message")) {
[10:26:11.547]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.547]                         if (muffled) 
[10:26:11.547]                           invokeRestart("muffleMessage")
[10:26:11.547]                       }
[10:26:11.547]                       else if (inherits(cond, "warning")) {
[10:26:11.547]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.547]                         if (muffled) 
[10:26:11.547]                           invokeRestart("muffleWarning")
[10:26:11.547]                       }
[10:26:11.547]                       else if (inherits(cond, "condition")) {
[10:26:11.547]                         if (!is.null(pattern)) {
[10:26:11.547]                           computeRestarts <- base::computeRestarts
[10:26:11.547]                           grepl <- base::grepl
[10:26:11.547]                           restarts <- computeRestarts(cond)
[10:26:11.547]                           for (restart in restarts) {
[10:26:11.547]                             name <- restart$name
[10:26:11.547]                             if (is.null(name)) 
[10:26:11.547]                               next
[10:26:11.547]                             if (!grepl(pattern, name)) 
[10:26:11.547]                               next
[10:26:11.547]                             invokeRestart(restart)
[10:26:11.547]                             muffled <- TRUE
[10:26:11.547]                             break
[10:26:11.547]                           }
[10:26:11.547]                         }
[10:26:11.547]                       }
[10:26:11.547]                       invisible(muffled)
[10:26:11.547]                     }
[10:26:11.547]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.547]                   }
[10:26:11.547]                 }
[10:26:11.547]             }
[10:26:11.547]         }))
[10:26:11.547]     }, error = function(ex) {
[10:26:11.547]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.547]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.547]                 ...future.rng), started = ...future.startTime, 
[10:26:11.547]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.547]             version = "1.8"), class = "FutureResult")
[10:26:11.547]     }, finally = {
[10:26:11.547]         if (!identical(...future.workdir, getwd())) 
[10:26:11.547]             setwd(...future.workdir)
[10:26:11.547]         {
[10:26:11.547]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.547]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.547]             }
[10:26:11.547]             base::options(...future.oldOptions)
[10:26:11.547]             if (.Platform$OS.type == "windows") {
[10:26:11.547]                 old_names <- names(...future.oldEnvVars)
[10:26:11.547]                 envs <- base::Sys.getenv()
[10:26:11.547]                 names <- names(envs)
[10:26:11.547]                 common <- intersect(names, old_names)
[10:26:11.547]                 added <- setdiff(names, old_names)
[10:26:11.547]                 removed <- setdiff(old_names, names)
[10:26:11.547]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.547]                   envs[common]]
[10:26:11.547]                 NAMES <- toupper(changed)
[10:26:11.547]                 args <- list()
[10:26:11.547]                 for (kk in seq_along(NAMES)) {
[10:26:11.547]                   name <- changed[[kk]]
[10:26:11.547]                   NAME <- NAMES[[kk]]
[10:26:11.547]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.547]                     next
[10:26:11.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.547]                 }
[10:26:11.547]                 NAMES <- toupper(added)
[10:26:11.547]                 for (kk in seq_along(NAMES)) {
[10:26:11.547]                   name <- added[[kk]]
[10:26:11.547]                   NAME <- NAMES[[kk]]
[10:26:11.547]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.547]                     next
[10:26:11.547]                   args[[name]] <- ""
[10:26:11.547]                 }
[10:26:11.547]                 NAMES <- toupper(removed)
[10:26:11.547]                 for (kk in seq_along(NAMES)) {
[10:26:11.547]                   name <- removed[[kk]]
[10:26:11.547]                   NAME <- NAMES[[kk]]
[10:26:11.547]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.547]                     next
[10:26:11.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.547]                 }
[10:26:11.547]                 if (length(args) > 0) 
[10:26:11.547]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.547]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.547]             }
[10:26:11.547]             else {
[10:26:11.547]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.547]             }
[10:26:11.547]             {
[10:26:11.547]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.547]                   0L) {
[10:26:11.547]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.547]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.547]                   base::options(opts)
[10:26:11.547]                 }
[10:26:11.547]                 {
[10:26:11.547]                   {
[10:26:11.547]                     NULL
[10:26:11.547]                     RNGkind("Mersenne-Twister")
[10:26:11.547]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.547]                       inherits = FALSE)
[10:26:11.547]                   }
[10:26:11.547]                   options(future.plan = NULL)
[10:26:11.547]                   if (is.na(NA_character_)) 
[10:26:11.547]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.547]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.547]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.547]                   {
[10:26:11.547]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.547]                     if (!future$lazy) 
[10:26:11.547]                       future <- run(future)
[10:26:11.547]                     invisible(future)
[10:26:11.547]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.547]                 }
[10:26:11.547]             }
[10:26:11.547]         }
[10:26:11.547]     })
[10:26:11.547]     if (TRUE) {
[10:26:11.547]         base::sink(type = "output", split = FALSE)
[10:26:11.547]         if (TRUE) {
[10:26:11.547]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.547]         }
[10:26:11.547]         else {
[10:26:11.547]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.547]         }
[10:26:11.547]         base::close(...future.stdout)
[10:26:11.547]         ...future.stdout <- NULL
[10:26:11.547]     }
[10:26:11.547]     ...future.result$conditions <- ...future.conditions
[10:26:11.547]     ...future.result$finished <- base::Sys.time()
[10:26:11.547]     ...future.result
[10:26:11.547] }
[10:26:11.549] assign_globals() ...
[10:26:11.549] List of 2
[10:26:11.549]  $ a : num 1
[10:26:11.549]  $ ii: int 3
[10:26:11.549]  - attr(*, "where")=List of 2
[10:26:11.549]   ..$ a :<environment: R_EmptyEnv> 
[10:26:11.549]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:11.549]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.549]  - attr(*, "resolved")= logi TRUE
[10:26:11.549]  - attr(*, "total_size")= num 112
[10:26:11.549]  - attr(*, "already-done")= logi TRUE
[10:26:11.552] - copied ‘a’ to environment
[10:26:11.552] - copied ‘ii’ to environment
[10:26:11.552] assign_globals() ... done
[10:26:11.552] plan(): Setting new future strategy stack:
[10:26:11.552] List of future strategies:
[10:26:11.552] 1. sequential:
[10:26:11.552]    - args: function (..., envir = parent.frame())
[10:26:11.552]    - tweaked: FALSE
[10:26:11.552]    - call: NULL
[10:26:11.553] plan(): nbrOfWorkers() = 1
[10:26:11.553] plan(): Setting new future strategy stack:
[10:26:11.554] List of future strategies:
[10:26:11.554] 1. sequential:
[10:26:11.554]    - args: function (..., envir = parent.frame())
[10:26:11.554]    - tweaked: FALSE
[10:26:11.554]    - call: plan(strategy)
[10:26:11.554] plan(): nbrOfWorkers() = 1
[10:26:11.554] SequentialFuture started (and completed)
[10:26:11.554] - Launch lazy future ... done
[10:26:11.554] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.555] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.555] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:11.557] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:11.557] Searching for globals ... DONE
[10:26:11.557] Resolving globals: TRUE
[10:26:11.557] Resolving any globals that are futures ...
[10:26:11.557] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:11.557] Resolving any globals that are futures ... DONE
[10:26:11.558] Resolving futures part of globals (recursively) ...
[10:26:11.558] resolve() on list ...
[10:26:11.558]  recursive: 99
[10:26:11.558]  length: 2
[10:26:11.558]  elements: ‘a’, ‘ii’
[10:26:11.558]  length: 1 (resolved future 1)
[10:26:11.558]  length: 0 (resolved future 2)
[10:26:11.558] resolve() on list ... DONE
[10:26:11.559] - globals: [2] ‘a’, ‘ii’
[10:26:11.559] Resolving futures part of globals (recursively) ... DONE
[10:26:11.559] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:11.559] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:26:11.559] - globals: [2] ‘a’, ‘ii’
[10:26:11.559] 
[10:26:11.559] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.560] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.560] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:11.562] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:11.562] Searching for globals ... DONE
[10:26:11.562] Resolving globals: TRUE
[10:26:11.562] Resolving any globals that are futures ...
[10:26:11.563] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:11.563] Resolving any globals that are futures ... DONE
[10:26:11.564] Resolving futures part of globals (recursively) ...
[10:26:11.564] resolve() on list ...
[10:26:11.564]  recursive: 99
[10:26:11.564]  length: 2
[10:26:11.564]  elements: ‘a’, ‘ii’
[10:26:11.564]  length: 1 (resolved future 1)
[10:26:11.564]  length: 0 (resolved future 2)
[10:26:11.564] resolve() on list ... DONE
[10:26:11.564] - globals: [2] ‘a’, ‘ii’
[10:26:11.565] Resolving futures part of globals (recursively) ... DONE
[10:26:11.565] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:11.565] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:26:11.565] - globals: [2] ‘a’, ‘ii’
[10:26:11.565] 
[10:26:11.565] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.566] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.566] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:11.568] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:11.568] Searching for globals ... DONE
[10:26:11.568] Resolving globals: TRUE
[10:26:11.568] Resolving any globals that are futures ...
[10:26:11.568] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:11.568] Resolving any globals that are futures ... DONE
[10:26:11.569] Resolving futures part of globals (recursively) ...
[10:26:11.569] resolve() on list ...
[10:26:11.569]  recursive: 99
[10:26:11.569]  length: 2
[10:26:11.569]  elements: ‘a’, ‘ii’
[10:26:11.569]  length: 1 (resolved future 1)
[10:26:11.569]  length: 0 (resolved future 2)
[10:26:11.569] resolve() on list ... DONE
[10:26:11.569] - globals: [2] ‘a’, ‘ii’
[10:26:11.569] Resolving futures part of globals (recursively) ... DONE
[10:26:11.570] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:11.570] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:26:11.570] - globals: [2] ‘a’, ‘ii’
[10:26:11.570] 
[10:26:11.570] getGlobalsAndPackages() ... DONE
[10:26:11.571] run() for ‘Future’ ...
[10:26:11.571] - state: ‘created’
[10:26:11.571] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.571] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.571] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.571]   - Field: ‘label’
[10:26:11.571]   - Field: ‘local’
[10:26:11.571]   - Field: ‘owner’
[10:26:11.571]   - Field: ‘envir’
[10:26:11.572]   - Field: ‘packages’
[10:26:11.572]   - Field: ‘gc’
[10:26:11.572]   - Field: ‘conditions’
[10:26:11.572]   - Field: ‘expr’
[10:26:11.572]   - Field: ‘uuid’
[10:26:11.572]   - Field: ‘seed’
[10:26:11.572]   - Field: ‘version’
[10:26:11.572]   - Field: ‘result’
[10:26:11.572]   - Field: ‘asynchronous’
[10:26:11.572]   - Field: ‘calls’
[10:26:11.572]   - Field: ‘globals’
[10:26:11.572]   - Field: ‘stdout’
[10:26:11.573]   - Field: ‘earlySignal’
[10:26:11.573]   - Field: ‘lazy’
[10:26:11.573]   - Field: ‘state’
[10:26:11.573] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.573] - Launch lazy future ...
[10:26:11.573] Packages needed by the future expression (n = 0): <none>
[10:26:11.573] Packages needed by future strategies (n = 0): <none>
[10:26:11.574] {
[10:26:11.574]     {
[10:26:11.574]         {
[10:26:11.574]             ...future.startTime <- base::Sys.time()
[10:26:11.574]             {
[10:26:11.574]                 {
[10:26:11.574]                   {
[10:26:11.574]                     base::local({
[10:26:11.574]                       has_future <- base::requireNamespace("future", 
[10:26:11.574]                         quietly = TRUE)
[10:26:11.574]                       if (has_future) {
[10:26:11.574]                         ns <- base::getNamespace("future")
[10:26:11.574]                         version <- ns[[".package"]][["version"]]
[10:26:11.574]                         if (is.null(version)) 
[10:26:11.574]                           version <- utils::packageVersion("future")
[10:26:11.574]                       }
[10:26:11.574]                       else {
[10:26:11.574]                         version <- NULL
[10:26:11.574]                       }
[10:26:11.574]                       if (!has_future || version < "1.8.0") {
[10:26:11.574]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.574]                           "", base::R.version$version.string), 
[10:26:11.574]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.574]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.574]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.574]                             "release", "version")], collapse = " "), 
[10:26:11.574]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.574]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.574]                           info)
[10:26:11.574]                         info <- base::paste(info, collapse = "; ")
[10:26:11.574]                         if (!has_future) {
[10:26:11.574]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.574]                             info)
[10:26:11.574]                         }
[10:26:11.574]                         else {
[10:26:11.574]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.574]                             info, version)
[10:26:11.574]                         }
[10:26:11.574]                         base::stop(msg)
[10:26:11.574]                       }
[10:26:11.574]                     })
[10:26:11.574]                   }
[10:26:11.574]                   options(future.plan = NULL)
[10:26:11.574]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.574]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.574]                 }
[10:26:11.574]                 ...future.workdir <- getwd()
[10:26:11.574]             }
[10:26:11.574]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.574]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.574]         }
[10:26:11.574]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.574]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:11.574]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.574]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.574]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.574]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.574]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.574]             base::names(...future.oldOptions))
[10:26:11.574]     }
[10:26:11.574]     if (FALSE) {
[10:26:11.574]     }
[10:26:11.574]     else {
[10:26:11.574]         if (TRUE) {
[10:26:11.574]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.574]                 open = "w")
[10:26:11.574]         }
[10:26:11.574]         else {
[10:26:11.574]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.574]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.574]         }
[10:26:11.574]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.574]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.574]             base::sink(type = "output", split = FALSE)
[10:26:11.574]             base::close(...future.stdout)
[10:26:11.574]         }, add = TRUE)
[10:26:11.574]     }
[10:26:11.574]     ...future.frame <- base::sys.nframe()
[10:26:11.574]     ...future.conditions <- base::list()
[10:26:11.574]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.574]     if (FALSE) {
[10:26:11.574]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.574]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.574]     }
[10:26:11.574]     ...future.result <- base::tryCatch({
[10:26:11.574]         base::withCallingHandlers({
[10:26:11.574]             ...future.value <- base::withVisible(base::local({
[10:26:11.574]                 b <- a * ii
[10:26:11.574]                 a <- 0
[10:26:11.574]                 b
[10:26:11.574]             }))
[10:26:11.574]             future::FutureResult(value = ...future.value$value, 
[10:26:11.574]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.574]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.574]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.574]                     ...future.globalenv.names))
[10:26:11.574]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.574]         }, condition = base::local({
[10:26:11.574]             c <- base::c
[10:26:11.574]             inherits <- base::inherits
[10:26:11.574]             invokeRestart <- base::invokeRestart
[10:26:11.574]             length <- base::length
[10:26:11.574]             list <- base::list
[10:26:11.574]             seq.int <- base::seq.int
[10:26:11.574]             signalCondition <- base::signalCondition
[10:26:11.574]             sys.calls <- base::sys.calls
[10:26:11.574]             `[[` <- base::`[[`
[10:26:11.574]             `+` <- base::`+`
[10:26:11.574]             `<<-` <- base::`<<-`
[10:26:11.574]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.574]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.574]                   3L)]
[10:26:11.574]             }
[10:26:11.574]             function(cond) {
[10:26:11.574]                 is_error <- inherits(cond, "error")
[10:26:11.574]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.574]                   NULL)
[10:26:11.574]                 if (is_error) {
[10:26:11.574]                   sessionInformation <- function() {
[10:26:11.574]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.574]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.574]                       search = base::search(), system = base::Sys.info())
[10:26:11.574]                   }
[10:26:11.574]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.574]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.574]                     cond$call), session = sessionInformation(), 
[10:26:11.574]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.574]                   signalCondition(cond)
[10:26:11.574]                 }
[10:26:11.574]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.574]                 "immediateCondition"))) {
[10:26:11.574]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.574]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.574]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.574]                   if (TRUE && !signal) {
[10:26:11.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.574]                     {
[10:26:11.574]                       inherits <- base::inherits
[10:26:11.574]                       invokeRestart <- base::invokeRestart
[10:26:11.574]                       is.null <- base::is.null
[10:26:11.574]                       muffled <- FALSE
[10:26:11.574]                       if (inherits(cond, "message")) {
[10:26:11.574]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.574]                         if (muffled) 
[10:26:11.574]                           invokeRestart("muffleMessage")
[10:26:11.574]                       }
[10:26:11.574]                       else if (inherits(cond, "warning")) {
[10:26:11.574]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.574]                         if (muffled) 
[10:26:11.574]                           invokeRestart("muffleWarning")
[10:26:11.574]                       }
[10:26:11.574]                       else if (inherits(cond, "condition")) {
[10:26:11.574]                         if (!is.null(pattern)) {
[10:26:11.574]                           computeRestarts <- base::computeRestarts
[10:26:11.574]                           grepl <- base::grepl
[10:26:11.574]                           restarts <- computeRestarts(cond)
[10:26:11.574]                           for (restart in restarts) {
[10:26:11.574]                             name <- restart$name
[10:26:11.574]                             if (is.null(name)) 
[10:26:11.574]                               next
[10:26:11.574]                             if (!grepl(pattern, name)) 
[10:26:11.574]                               next
[10:26:11.574]                             invokeRestart(restart)
[10:26:11.574]                             muffled <- TRUE
[10:26:11.574]                             break
[10:26:11.574]                           }
[10:26:11.574]                         }
[10:26:11.574]                       }
[10:26:11.574]                       invisible(muffled)
[10:26:11.574]                     }
[10:26:11.574]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.574]                   }
[10:26:11.574]                 }
[10:26:11.574]                 else {
[10:26:11.574]                   if (TRUE) {
[10:26:11.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.574]                     {
[10:26:11.574]                       inherits <- base::inherits
[10:26:11.574]                       invokeRestart <- base::invokeRestart
[10:26:11.574]                       is.null <- base::is.null
[10:26:11.574]                       muffled <- FALSE
[10:26:11.574]                       if (inherits(cond, "message")) {
[10:26:11.574]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.574]                         if (muffled) 
[10:26:11.574]                           invokeRestart("muffleMessage")
[10:26:11.574]                       }
[10:26:11.574]                       else if (inherits(cond, "warning")) {
[10:26:11.574]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.574]                         if (muffled) 
[10:26:11.574]                           invokeRestart("muffleWarning")
[10:26:11.574]                       }
[10:26:11.574]                       else if (inherits(cond, "condition")) {
[10:26:11.574]                         if (!is.null(pattern)) {
[10:26:11.574]                           computeRestarts <- base::computeRestarts
[10:26:11.574]                           grepl <- base::grepl
[10:26:11.574]                           restarts <- computeRestarts(cond)
[10:26:11.574]                           for (restart in restarts) {
[10:26:11.574]                             name <- restart$name
[10:26:11.574]                             if (is.null(name)) 
[10:26:11.574]                               next
[10:26:11.574]                             if (!grepl(pattern, name)) 
[10:26:11.574]                               next
[10:26:11.574]                             invokeRestart(restart)
[10:26:11.574]                             muffled <- TRUE
[10:26:11.574]                             break
[10:26:11.574]                           }
[10:26:11.574]                         }
[10:26:11.574]                       }
[10:26:11.574]                       invisible(muffled)
[10:26:11.574]                     }
[10:26:11.574]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.574]                   }
[10:26:11.574]                 }
[10:26:11.574]             }
[10:26:11.574]         }))
[10:26:11.574]     }, error = function(ex) {
[10:26:11.574]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.574]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.574]                 ...future.rng), started = ...future.startTime, 
[10:26:11.574]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.574]             version = "1.8"), class = "FutureResult")
[10:26:11.574]     }, finally = {
[10:26:11.574]         if (!identical(...future.workdir, getwd())) 
[10:26:11.574]             setwd(...future.workdir)
[10:26:11.574]         {
[10:26:11.574]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.574]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.574]             }
[10:26:11.574]             base::options(...future.oldOptions)
[10:26:11.574]             if (.Platform$OS.type == "windows") {
[10:26:11.574]                 old_names <- names(...future.oldEnvVars)
[10:26:11.574]                 envs <- base::Sys.getenv()
[10:26:11.574]                 names <- names(envs)
[10:26:11.574]                 common <- intersect(names, old_names)
[10:26:11.574]                 added <- setdiff(names, old_names)
[10:26:11.574]                 removed <- setdiff(old_names, names)
[10:26:11.574]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.574]                   envs[common]]
[10:26:11.574]                 NAMES <- toupper(changed)
[10:26:11.574]                 args <- list()
[10:26:11.574]                 for (kk in seq_along(NAMES)) {
[10:26:11.574]                   name <- changed[[kk]]
[10:26:11.574]                   NAME <- NAMES[[kk]]
[10:26:11.574]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.574]                     next
[10:26:11.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.574]                 }
[10:26:11.574]                 NAMES <- toupper(added)
[10:26:11.574]                 for (kk in seq_along(NAMES)) {
[10:26:11.574]                   name <- added[[kk]]
[10:26:11.574]                   NAME <- NAMES[[kk]]
[10:26:11.574]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.574]                     next
[10:26:11.574]                   args[[name]] <- ""
[10:26:11.574]                 }
[10:26:11.574]                 NAMES <- toupper(removed)
[10:26:11.574]                 for (kk in seq_along(NAMES)) {
[10:26:11.574]                   name <- removed[[kk]]
[10:26:11.574]                   NAME <- NAMES[[kk]]
[10:26:11.574]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.574]                     next
[10:26:11.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.574]                 }
[10:26:11.574]                 if (length(args) > 0) 
[10:26:11.574]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.574]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.574]             }
[10:26:11.574]             else {
[10:26:11.574]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.574]             }
[10:26:11.574]             {
[10:26:11.574]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.574]                   0L) {
[10:26:11.574]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.574]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.574]                   base::options(opts)
[10:26:11.574]                 }
[10:26:11.574]                 {
[10:26:11.574]                   {
[10:26:11.574]                     NULL
[10:26:11.574]                     RNGkind("Mersenne-Twister")
[10:26:11.574]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.574]                       inherits = FALSE)
[10:26:11.574]                   }
[10:26:11.574]                   options(future.plan = NULL)
[10:26:11.574]                   if (is.na(NA_character_)) 
[10:26:11.574]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.574]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.574]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.574]                   {
[10:26:11.574]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.574]                     if (!future$lazy) 
[10:26:11.574]                       future <- run(future)
[10:26:11.574]                     invisible(future)
[10:26:11.574]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.574]                 }
[10:26:11.574]             }
[10:26:11.574]         }
[10:26:11.574]     })
[10:26:11.574]     if (TRUE) {
[10:26:11.574]         base::sink(type = "output", split = FALSE)
[10:26:11.574]         if (TRUE) {
[10:26:11.574]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.574]         }
[10:26:11.574]         else {
[10:26:11.574]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.574]         }
[10:26:11.574]         base::close(...future.stdout)
[10:26:11.574]         ...future.stdout <- NULL
[10:26:11.574]     }
[10:26:11.574]     ...future.result$conditions <- ...future.conditions
[10:26:11.574]     ...future.result$finished <- base::Sys.time()
[10:26:11.574]     ...future.result
[10:26:11.574] }
[10:26:11.575] assign_globals() ...
[10:26:11.575] List of 2
[10:26:11.575]  $ a : num 1
[10:26:11.575]  $ ii: int 1
[10:26:11.575]  - attr(*, "where")=List of 2
[10:26:11.575]   ..$ a :<environment: R_EmptyEnv> 
[10:26:11.575]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:11.575]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.575]  - attr(*, "resolved")= logi TRUE
[10:26:11.575]  - attr(*, "total_size")= num 112
[10:26:11.575]  - attr(*, "already-done")= logi TRUE
[10:26:11.578] - copied ‘a’ to environment
[10:26:11.578] - copied ‘ii’ to environment
[10:26:11.578] assign_globals() ... done
[10:26:11.578] plan(): Setting new future strategy stack:
[10:26:11.578] List of future strategies:
[10:26:11.578] 1. sequential:
[10:26:11.578]    - args: function (..., envir = parent.frame())
[10:26:11.578]    - tweaked: FALSE
[10:26:11.578]    - call: NULL
[10:26:11.579] plan(): nbrOfWorkers() = 1
[10:26:11.579] plan(): Setting new future strategy stack:
[10:26:11.580] List of future strategies:
[10:26:11.580] 1. sequential:
[10:26:11.580]    - args: function (..., envir = parent.frame())
[10:26:11.580]    - tweaked: FALSE
[10:26:11.580]    - call: plan(strategy)
[10:26:11.580] plan(): nbrOfWorkers() = 1
[10:26:11.580] SequentialFuture started (and completed)
[10:26:11.580] - Launch lazy future ... done
[10:26:11.580] run() for ‘SequentialFuture’ ... done
[10:26:11.580] run() for ‘Future’ ...
[10:26:11.581] - state: ‘created’
[10:26:11.581] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.581] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.581] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.581]   - Field: ‘label’
[10:26:11.581]   - Field: ‘local’
[10:26:11.581]   - Field: ‘owner’
[10:26:11.581]   - Field: ‘envir’
[10:26:11.581]   - Field: ‘packages’
[10:26:11.582]   - Field: ‘gc’
[10:26:11.582]   - Field: ‘conditions’
[10:26:11.582]   - Field: ‘expr’
[10:26:11.582]   - Field: ‘uuid’
[10:26:11.582]   - Field: ‘seed’
[10:26:11.582]   - Field: ‘version’
[10:26:11.582]   - Field: ‘result’
[10:26:11.582]   - Field: ‘asynchronous’
[10:26:11.582]   - Field: ‘calls’
[10:26:11.582]   - Field: ‘globals’
[10:26:11.582]   - Field: ‘stdout’
[10:26:11.583]   - Field: ‘earlySignal’
[10:26:11.583]   - Field: ‘lazy’
[10:26:11.583]   - Field: ‘state’
[10:26:11.583] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.583] - Launch lazy future ...
[10:26:11.583] Packages needed by the future expression (n = 0): <none>
[10:26:11.583] Packages needed by future strategies (n = 0): <none>
[10:26:11.583] {
[10:26:11.583]     {
[10:26:11.583]         {
[10:26:11.583]             ...future.startTime <- base::Sys.time()
[10:26:11.583]             {
[10:26:11.583]                 {
[10:26:11.583]                   {
[10:26:11.583]                     base::local({
[10:26:11.583]                       has_future <- base::requireNamespace("future", 
[10:26:11.583]                         quietly = TRUE)
[10:26:11.583]                       if (has_future) {
[10:26:11.583]                         ns <- base::getNamespace("future")
[10:26:11.583]                         version <- ns[[".package"]][["version"]]
[10:26:11.583]                         if (is.null(version)) 
[10:26:11.583]                           version <- utils::packageVersion("future")
[10:26:11.583]                       }
[10:26:11.583]                       else {
[10:26:11.583]                         version <- NULL
[10:26:11.583]                       }
[10:26:11.583]                       if (!has_future || version < "1.8.0") {
[10:26:11.583]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.583]                           "", base::R.version$version.string), 
[10:26:11.583]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.583]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.583]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.583]                             "release", "version")], collapse = " "), 
[10:26:11.583]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.583]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.583]                           info)
[10:26:11.583]                         info <- base::paste(info, collapse = "; ")
[10:26:11.583]                         if (!has_future) {
[10:26:11.583]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.583]                             info)
[10:26:11.583]                         }
[10:26:11.583]                         else {
[10:26:11.583]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.583]                             info, version)
[10:26:11.583]                         }
[10:26:11.583]                         base::stop(msg)
[10:26:11.583]                       }
[10:26:11.583]                     })
[10:26:11.583]                   }
[10:26:11.583]                   options(future.plan = NULL)
[10:26:11.583]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.583]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.583]                 }
[10:26:11.583]                 ...future.workdir <- getwd()
[10:26:11.583]             }
[10:26:11.583]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.583]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.583]         }
[10:26:11.583]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.583]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:11.583]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.583]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.583]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.583]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.583]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.583]             base::names(...future.oldOptions))
[10:26:11.583]     }
[10:26:11.583]     if (FALSE) {
[10:26:11.583]     }
[10:26:11.583]     else {
[10:26:11.583]         if (TRUE) {
[10:26:11.583]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.583]                 open = "w")
[10:26:11.583]         }
[10:26:11.583]         else {
[10:26:11.583]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.583]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.583]         }
[10:26:11.583]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.583]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.583]             base::sink(type = "output", split = FALSE)
[10:26:11.583]             base::close(...future.stdout)
[10:26:11.583]         }, add = TRUE)
[10:26:11.583]     }
[10:26:11.583]     ...future.frame <- base::sys.nframe()
[10:26:11.583]     ...future.conditions <- base::list()
[10:26:11.583]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.583]     if (FALSE) {
[10:26:11.583]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.583]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.583]     }
[10:26:11.583]     ...future.result <- base::tryCatch({
[10:26:11.583]         base::withCallingHandlers({
[10:26:11.583]             ...future.value <- base::withVisible(base::local({
[10:26:11.583]                 b <- a * ii
[10:26:11.583]                 a <- 0
[10:26:11.583]                 b
[10:26:11.583]             }))
[10:26:11.583]             future::FutureResult(value = ...future.value$value, 
[10:26:11.583]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.583]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.583]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.583]                     ...future.globalenv.names))
[10:26:11.583]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.583]         }, condition = base::local({
[10:26:11.583]             c <- base::c
[10:26:11.583]             inherits <- base::inherits
[10:26:11.583]             invokeRestart <- base::invokeRestart
[10:26:11.583]             length <- base::length
[10:26:11.583]             list <- base::list
[10:26:11.583]             seq.int <- base::seq.int
[10:26:11.583]             signalCondition <- base::signalCondition
[10:26:11.583]             sys.calls <- base::sys.calls
[10:26:11.583]             `[[` <- base::`[[`
[10:26:11.583]             `+` <- base::`+`
[10:26:11.583]             `<<-` <- base::`<<-`
[10:26:11.583]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.583]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.583]                   3L)]
[10:26:11.583]             }
[10:26:11.583]             function(cond) {
[10:26:11.583]                 is_error <- inherits(cond, "error")
[10:26:11.583]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.583]                   NULL)
[10:26:11.583]                 if (is_error) {
[10:26:11.583]                   sessionInformation <- function() {
[10:26:11.583]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.583]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.583]                       search = base::search(), system = base::Sys.info())
[10:26:11.583]                   }
[10:26:11.583]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.583]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.583]                     cond$call), session = sessionInformation(), 
[10:26:11.583]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.583]                   signalCondition(cond)
[10:26:11.583]                 }
[10:26:11.583]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.583]                 "immediateCondition"))) {
[10:26:11.583]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.583]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.583]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.583]                   if (TRUE && !signal) {
[10:26:11.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.583]                     {
[10:26:11.583]                       inherits <- base::inherits
[10:26:11.583]                       invokeRestart <- base::invokeRestart
[10:26:11.583]                       is.null <- base::is.null
[10:26:11.583]                       muffled <- FALSE
[10:26:11.583]                       if (inherits(cond, "message")) {
[10:26:11.583]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.583]                         if (muffled) 
[10:26:11.583]                           invokeRestart("muffleMessage")
[10:26:11.583]                       }
[10:26:11.583]                       else if (inherits(cond, "warning")) {
[10:26:11.583]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.583]                         if (muffled) 
[10:26:11.583]                           invokeRestart("muffleWarning")
[10:26:11.583]                       }
[10:26:11.583]                       else if (inherits(cond, "condition")) {
[10:26:11.583]                         if (!is.null(pattern)) {
[10:26:11.583]                           computeRestarts <- base::computeRestarts
[10:26:11.583]                           grepl <- base::grepl
[10:26:11.583]                           restarts <- computeRestarts(cond)
[10:26:11.583]                           for (restart in restarts) {
[10:26:11.583]                             name <- restart$name
[10:26:11.583]                             if (is.null(name)) 
[10:26:11.583]                               next
[10:26:11.583]                             if (!grepl(pattern, name)) 
[10:26:11.583]                               next
[10:26:11.583]                             invokeRestart(restart)
[10:26:11.583]                             muffled <- TRUE
[10:26:11.583]                             break
[10:26:11.583]                           }
[10:26:11.583]                         }
[10:26:11.583]                       }
[10:26:11.583]                       invisible(muffled)
[10:26:11.583]                     }
[10:26:11.583]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.583]                   }
[10:26:11.583]                 }
[10:26:11.583]                 else {
[10:26:11.583]                   if (TRUE) {
[10:26:11.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.583]                     {
[10:26:11.583]                       inherits <- base::inherits
[10:26:11.583]                       invokeRestart <- base::invokeRestart
[10:26:11.583]                       is.null <- base::is.null
[10:26:11.583]                       muffled <- FALSE
[10:26:11.583]                       if (inherits(cond, "message")) {
[10:26:11.583]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.583]                         if (muffled) 
[10:26:11.583]                           invokeRestart("muffleMessage")
[10:26:11.583]                       }
[10:26:11.583]                       else if (inherits(cond, "warning")) {
[10:26:11.583]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.583]                         if (muffled) 
[10:26:11.583]                           invokeRestart("muffleWarning")
[10:26:11.583]                       }
[10:26:11.583]                       else if (inherits(cond, "condition")) {
[10:26:11.583]                         if (!is.null(pattern)) {
[10:26:11.583]                           computeRestarts <- base::computeRestarts
[10:26:11.583]                           grepl <- base::grepl
[10:26:11.583]                           restarts <- computeRestarts(cond)
[10:26:11.583]                           for (restart in restarts) {
[10:26:11.583]                             name <- restart$name
[10:26:11.583]                             if (is.null(name)) 
[10:26:11.583]                               next
[10:26:11.583]                             if (!grepl(pattern, name)) 
[10:26:11.583]                               next
[10:26:11.583]                             invokeRestart(restart)
[10:26:11.583]                             muffled <- TRUE
[10:26:11.583]                             break
[10:26:11.583]                           }
[10:26:11.583]                         }
[10:26:11.583]                       }
[10:26:11.583]                       invisible(muffled)
[10:26:11.583]                     }
[10:26:11.583]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.583]                   }
[10:26:11.583]                 }
[10:26:11.583]             }
[10:26:11.583]         }))
[10:26:11.583]     }, error = function(ex) {
[10:26:11.583]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.583]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.583]                 ...future.rng), started = ...future.startTime, 
[10:26:11.583]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.583]             version = "1.8"), class = "FutureResult")
[10:26:11.583]     }, finally = {
[10:26:11.583]         if (!identical(...future.workdir, getwd())) 
[10:26:11.583]             setwd(...future.workdir)
[10:26:11.583]         {
[10:26:11.583]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.583]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.583]             }
[10:26:11.583]             base::options(...future.oldOptions)
[10:26:11.583]             if (.Platform$OS.type == "windows") {
[10:26:11.583]                 old_names <- names(...future.oldEnvVars)
[10:26:11.583]                 envs <- base::Sys.getenv()
[10:26:11.583]                 names <- names(envs)
[10:26:11.583]                 common <- intersect(names, old_names)
[10:26:11.583]                 added <- setdiff(names, old_names)
[10:26:11.583]                 removed <- setdiff(old_names, names)
[10:26:11.583]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.583]                   envs[common]]
[10:26:11.583]                 NAMES <- toupper(changed)
[10:26:11.583]                 args <- list()
[10:26:11.583]                 for (kk in seq_along(NAMES)) {
[10:26:11.583]                   name <- changed[[kk]]
[10:26:11.583]                   NAME <- NAMES[[kk]]
[10:26:11.583]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.583]                     next
[10:26:11.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.583]                 }
[10:26:11.583]                 NAMES <- toupper(added)
[10:26:11.583]                 for (kk in seq_along(NAMES)) {
[10:26:11.583]                   name <- added[[kk]]
[10:26:11.583]                   NAME <- NAMES[[kk]]
[10:26:11.583]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.583]                     next
[10:26:11.583]                   args[[name]] <- ""
[10:26:11.583]                 }
[10:26:11.583]                 NAMES <- toupper(removed)
[10:26:11.583]                 for (kk in seq_along(NAMES)) {
[10:26:11.583]                   name <- removed[[kk]]
[10:26:11.583]                   NAME <- NAMES[[kk]]
[10:26:11.583]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.583]                     next
[10:26:11.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.583]                 }
[10:26:11.583]                 if (length(args) > 0) 
[10:26:11.583]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.583]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.583]             }
[10:26:11.583]             else {
[10:26:11.583]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.583]             }
[10:26:11.583]             {
[10:26:11.583]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.583]                   0L) {
[10:26:11.583]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.583]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.583]                   base::options(opts)
[10:26:11.583]                 }
[10:26:11.583]                 {
[10:26:11.583]                   {
[10:26:11.583]                     NULL
[10:26:11.583]                     RNGkind("Mersenne-Twister")
[10:26:11.583]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.583]                       inherits = FALSE)
[10:26:11.583]                   }
[10:26:11.583]                   options(future.plan = NULL)
[10:26:11.583]                   if (is.na(NA_character_)) 
[10:26:11.583]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.583]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.583]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.583]                   {
[10:26:11.583]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.583]                     if (!future$lazy) 
[10:26:11.583]                       future <- run(future)
[10:26:11.583]                     invisible(future)
[10:26:11.583]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.583]                 }
[10:26:11.583]             }
[10:26:11.583]         }
[10:26:11.583]     })
[10:26:11.583]     if (TRUE) {
[10:26:11.583]         base::sink(type = "output", split = FALSE)
[10:26:11.583]         if (TRUE) {
[10:26:11.583]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.583]         }
[10:26:11.583]         else {
[10:26:11.583]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.583]         }
[10:26:11.583]         base::close(...future.stdout)
[10:26:11.583]         ...future.stdout <- NULL
[10:26:11.583]     }
[10:26:11.583]     ...future.result$conditions <- ...future.conditions
[10:26:11.583]     ...future.result$finished <- base::Sys.time()
[10:26:11.583]     ...future.result
[10:26:11.583] }
[10:26:11.585] assign_globals() ...
[10:26:11.585] List of 2
[10:26:11.585]  $ a : num 1
[10:26:11.585]  $ ii: int 2
[10:26:11.585]  - attr(*, "where")=List of 2
[10:26:11.585]   ..$ a :<environment: R_EmptyEnv> 
[10:26:11.585]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:11.585]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.585]  - attr(*, "resolved")= logi TRUE
[10:26:11.585]  - attr(*, "total_size")= num 112
[10:26:11.585]  - attr(*, "already-done")= logi TRUE
[10:26:11.589] - copied ‘a’ to environment
[10:26:11.589] - copied ‘ii’ to environment
[10:26:11.589] assign_globals() ... done
[10:26:11.589] plan(): Setting new future strategy stack:
[10:26:11.589] List of future strategies:
[10:26:11.589] 1. sequential:
[10:26:11.589]    - args: function (..., envir = parent.frame())
[10:26:11.589]    - tweaked: FALSE
[10:26:11.589]    - call: NULL
[10:26:11.590] plan(): nbrOfWorkers() = 1
[10:26:11.590] plan(): Setting new future strategy stack:
[10:26:11.591] List of future strategies:
[10:26:11.591] 1. sequential:
[10:26:11.591]    - args: function (..., envir = parent.frame())
[10:26:11.591]    - tweaked: FALSE
[10:26:11.591]    - call: plan(strategy)
[10:26:11.591] plan(): nbrOfWorkers() = 1
[10:26:11.591] SequentialFuture started (and completed)
[10:26:11.591] - Launch lazy future ... done
[10:26:11.591] run() for ‘SequentialFuture’ ... done
[10:26:11.591] run() for ‘Future’ ...
[10:26:11.591] - state: ‘created’
[10:26:11.592] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.592] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.592] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.592]   - Field: ‘label’
[10:26:11.592]   - Field: ‘local’
[10:26:11.592]   - Field: ‘owner’
[10:26:11.592]   - Field: ‘envir’
[10:26:11.592]   - Field: ‘packages’
[10:26:11.592]   - Field: ‘gc’
[10:26:11.593]   - Field: ‘conditions’
[10:26:11.593]   - Field: ‘expr’
[10:26:11.593]   - Field: ‘uuid’
[10:26:11.593]   - Field: ‘seed’
[10:26:11.593]   - Field: ‘version’
[10:26:11.593]   - Field: ‘result’
[10:26:11.593]   - Field: ‘asynchronous’
[10:26:11.593]   - Field: ‘calls’
[10:26:11.593]   - Field: ‘globals’
[10:26:11.593]   - Field: ‘stdout’
[10:26:11.593]   - Field: ‘earlySignal’
[10:26:11.594]   - Field: ‘lazy’
[10:26:11.594]   - Field: ‘state’
[10:26:11.594] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.594] - Launch lazy future ...
[10:26:11.594] Packages needed by the future expression (n = 0): <none>
[10:26:11.594] Packages needed by future strategies (n = 0): <none>
[10:26:11.594] {
[10:26:11.594]     {
[10:26:11.594]         {
[10:26:11.594]             ...future.startTime <- base::Sys.time()
[10:26:11.594]             {
[10:26:11.594]                 {
[10:26:11.594]                   {
[10:26:11.594]                     base::local({
[10:26:11.594]                       has_future <- base::requireNamespace("future", 
[10:26:11.594]                         quietly = TRUE)
[10:26:11.594]                       if (has_future) {
[10:26:11.594]                         ns <- base::getNamespace("future")
[10:26:11.594]                         version <- ns[[".package"]][["version"]]
[10:26:11.594]                         if (is.null(version)) 
[10:26:11.594]                           version <- utils::packageVersion("future")
[10:26:11.594]                       }
[10:26:11.594]                       else {
[10:26:11.594]                         version <- NULL
[10:26:11.594]                       }
[10:26:11.594]                       if (!has_future || version < "1.8.0") {
[10:26:11.594]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.594]                           "", base::R.version$version.string), 
[10:26:11.594]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.594]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.594]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.594]                             "release", "version")], collapse = " "), 
[10:26:11.594]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.594]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.594]                           info)
[10:26:11.594]                         info <- base::paste(info, collapse = "; ")
[10:26:11.594]                         if (!has_future) {
[10:26:11.594]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.594]                             info)
[10:26:11.594]                         }
[10:26:11.594]                         else {
[10:26:11.594]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.594]                             info, version)
[10:26:11.594]                         }
[10:26:11.594]                         base::stop(msg)
[10:26:11.594]                       }
[10:26:11.594]                     })
[10:26:11.594]                   }
[10:26:11.594]                   options(future.plan = NULL)
[10:26:11.594]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.594]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.594]                 }
[10:26:11.594]                 ...future.workdir <- getwd()
[10:26:11.594]             }
[10:26:11.594]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.594]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.594]         }
[10:26:11.594]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.594]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:11.594]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.594]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.594]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.594]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.594]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.594]             base::names(...future.oldOptions))
[10:26:11.594]     }
[10:26:11.594]     if (FALSE) {
[10:26:11.594]     }
[10:26:11.594]     else {
[10:26:11.594]         if (TRUE) {
[10:26:11.594]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.594]                 open = "w")
[10:26:11.594]         }
[10:26:11.594]         else {
[10:26:11.594]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.594]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.594]         }
[10:26:11.594]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.594]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.594]             base::sink(type = "output", split = FALSE)
[10:26:11.594]             base::close(...future.stdout)
[10:26:11.594]         }, add = TRUE)
[10:26:11.594]     }
[10:26:11.594]     ...future.frame <- base::sys.nframe()
[10:26:11.594]     ...future.conditions <- base::list()
[10:26:11.594]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.594]     if (FALSE) {
[10:26:11.594]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.594]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.594]     }
[10:26:11.594]     ...future.result <- base::tryCatch({
[10:26:11.594]         base::withCallingHandlers({
[10:26:11.594]             ...future.value <- base::withVisible(base::local({
[10:26:11.594]                 b <- a * ii
[10:26:11.594]                 a <- 0
[10:26:11.594]                 b
[10:26:11.594]             }))
[10:26:11.594]             future::FutureResult(value = ...future.value$value, 
[10:26:11.594]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.594]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.594]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.594]                     ...future.globalenv.names))
[10:26:11.594]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.594]         }, condition = base::local({
[10:26:11.594]             c <- base::c
[10:26:11.594]             inherits <- base::inherits
[10:26:11.594]             invokeRestart <- base::invokeRestart
[10:26:11.594]             length <- base::length
[10:26:11.594]             list <- base::list
[10:26:11.594]             seq.int <- base::seq.int
[10:26:11.594]             signalCondition <- base::signalCondition
[10:26:11.594]             sys.calls <- base::sys.calls
[10:26:11.594]             `[[` <- base::`[[`
[10:26:11.594]             `+` <- base::`+`
[10:26:11.594]             `<<-` <- base::`<<-`
[10:26:11.594]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.594]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.594]                   3L)]
[10:26:11.594]             }
[10:26:11.594]             function(cond) {
[10:26:11.594]                 is_error <- inherits(cond, "error")
[10:26:11.594]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.594]                   NULL)
[10:26:11.594]                 if (is_error) {
[10:26:11.594]                   sessionInformation <- function() {
[10:26:11.594]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.594]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.594]                       search = base::search(), system = base::Sys.info())
[10:26:11.594]                   }
[10:26:11.594]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.594]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.594]                     cond$call), session = sessionInformation(), 
[10:26:11.594]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.594]                   signalCondition(cond)
[10:26:11.594]                 }
[10:26:11.594]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.594]                 "immediateCondition"))) {
[10:26:11.594]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.594]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.594]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.594]                   if (TRUE && !signal) {
[10:26:11.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.594]                     {
[10:26:11.594]                       inherits <- base::inherits
[10:26:11.594]                       invokeRestart <- base::invokeRestart
[10:26:11.594]                       is.null <- base::is.null
[10:26:11.594]                       muffled <- FALSE
[10:26:11.594]                       if (inherits(cond, "message")) {
[10:26:11.594]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.594]                         if (muffled) 
[10:26:11.594]                           invokeRestart("muffleMessage")
[10:26:11.594]                       }
[10:26:11.594]                       else if (inherits(cond, "warning")) {
[10:26:11.594]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.594]                         if (muffled) 
[10:26:11.594]                           invokeRestart("muffleWarning")
[10:26:11.594]                       }
[10:26:11.594]                       else if (inherits(cond, "condition")) {
[10:26:11.594]                         if (!is.null(pattern)) {
[10:26:11.594]                           computeRestarts <- base::computeRestarts
[10:26:11.594]                           grepl <- base::grepl
[10:26:11.594]                           restarts <- computeRestarts(cond)
[10:26:11.594]                           for (restart in restarts) {
[10:26:11.594]                             name <- restart$name
[10:26:11.594]                             if (is.null(name)) 
[10:26:11.594]                               next
[10:26:11.594]                             if (!grepl(pattern, name)) 
[10:26:11.594]                               next
[10:26:11.594]                             invokeRestart(restart)
[10:26:11.594]                             muffled <- TRUE
[10:26:11.594]                             break
[10:26:11.594]                           }
[10:26:11.594]                         }
[10:26:11.594]                       }
[10:26:11.594]                       invisible(muffled)
[10:26:11.594]                     }
[10:26:11.594]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.594]                   }
[10:26:11.594]                 }
[10:26:11.594]                 else {
[10:26:11.594]                   if (TRUE) {
[10:26:11.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.594]                     {
[10:26:11.594]                       inherits <- base::inherits
[10:26:11.594]                       invokeRestart <- base::invokeRestart
[10:26:11.594]                       is.null <- base::is.null
[10:26:11.594]                       muffled <- FALSE
[10:26:11.594]                       if (inherits(cond, "message")) {
[10:26:11.594]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.594]                         if (muffled) 
[10:26:11.594]                           invokeRestart("muffleMessage")
[10:26:11.594]                       }
[10:26:11.594]                       else if (inherits(cond, "warning")) {
[10:26:11.594]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.594]                         if (muffled) 
[10:26:11.594]                           invokeRestart("muffleWarning")
[10:26:11.594]                       }
[10:26:11.594]                       else if (inherits(cond, "condition")) {
[10:26:11.594]                         if (!is.null(pattern)) {
[10:26:11.594]                           computeRestarts <- base::computeRestarts
[10:26:11.594]                           grepl <- base::grepl
[10:26:11.594]                           restarts <- computeRestarts(cond)
[10:26:11.594]                           for (restart in restarts) {
[10:26:11.594]                             name <- restart$name
[10:26:11.594]                             if (is.null(name)) 
[10:26:11.594]                               next
[10:26:11.594]                             if (!grepl(pattern, name)) 
[10:26:11.594]                               next
[10:26:11.594]                             invokeRestart(restart)
[10:26:11.594]                             muffled <- TRUE
[10:26:11.594]                             break
[10:26:11.594]                           }
[10:26:11.594]                         }
[10:26:11.594]                       }
[10:26:11.594]                       invisible(muffled)
[10:26:11.594]                     }
[10:26:11.594]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.594]                   }
[10:26:11.594]                 }
[10:26:11.594]             }
[10:26:11.594]         }))
[10:26:11.594]     }, error = function(ex) {
[10:26:11.594]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.594]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.594]                 ...future.rng), started = ...future.startTime, 
[10:26:11.594]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.594]             version = "1.8"), class = "FutureResult")
[10:26:11.594]     }, finally = {
[10:26:11.594]         if (!identical(...future.workdir, getwd())) 
[10:26:11.594]             setwd(...future.workdir)
[10:26:11.594]         {
[10:26:11.594]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.594]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.594]             }
[10:26:11.594]             base::options(...future.oldOptions)
[10:26:11.594]             if (.Platform$OS.type == "windows") {
[10:26:11.594]                 old_names <- names(...future.oldEnvVars)
[10:26:11.594]                 envs <- base::Sys.getenv()
[10:26:11.594]                 names <- names(envs)
[10:26:11.594]                 common <- intersect(names, old_names)
[10:26:11.594]                 added <- setdiff(names, old_names)
[10:26:11.594]                 removed <- setdiff(old_names, names)
[10:26:11.594]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.594]                   envs[common]]
[10:26:11.594]                 NAMES <- toupper(changed)
[10:26:11.594]                 args <- list()
[10:26:11.594]                 for (kk in seq_along(NAMES)) {
[10:26:11.594]                   name <- changed[[kk]]
[10:26:11.594]                   NAME <- NAMES[[kk]]
[10:26:11.594]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.594]                     next
[10:26:11.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.594]                 }
[10:26:11.594]                 NAMES <- toupper(added)
[10:26:11.594]                 for (kk in seq_along(NAMES)) {
[10:26:11.594]                   name <- added[[kk]]
[10:26:11.594]                   NAME <- NAMES[[kk]]
[10:26:11.594]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.594]                     next
[10:26:11.594]                   args[[name]] <- ""
[10:26:11.594]                 }
[10:26:11.594]                 NAMES <- toupper(removed)
[10:26:11.594]                 for (kk in seq_along(NAMES)) {
[10:26:11.594]                   name <- removed[[kk]]
[10:26:11.594]                   NAME <- NAMES[[kk]]
[10:26:11.594]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.594]                     next
[10:26:11.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.594]                 }
[10:26:11.594]                 if (length(args) > 0) 
[10:26:11.594]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.594]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.594]             }
[10:26:11.594]             else {
[10:26:11.594]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.594]             }
[10:26:11.594]             {
[10:26:11.594]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.594]                   0L) {
[10:26:11.594]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.594]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.594]                   base::options(opts)
[10:26:11.594]                 }
[10:26:11.594]                 {
[10:26:11.594]                   {
[10:26:11.594]                     NULL
[10:26:11.594]                     RNGkind("Mersenne-Twister")
[10:26:11.594]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.594]                       inherits = FALSE)
[10:26:11.594]                   }
[10:26:11.594]                   options(future.plan = NULL)
[10:26:11.594]                   if (is.na(NA_character_)) 
[10:26:11.594]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.594]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.594]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.594]                   {
[10:26:11.594]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.594]                     if (!future$lazy) 
[10:26:11.594]                       future <- run(future)
[10:26:11.594]                     invisible(future)
[10:26:11.594]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.594]                 }
[10:26:11.594]             }
[10:26:11.594]         }
[10:26:11.594]     })
[10:26:11.594]     if (TRUE) {
[10:26:11.594]         base::sink(type = "output", split = FALSE)
[10:26:11.594]         if (TRUE) {
[10:26:11.594]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.594]         }
[10:26:11.594]         else {
[10:26:11.594]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.594]         }
[10:26:11.594]         base::close(...future.stdout)
[10:26:11.594]         ...future.stdout <- NULL
[10:26:11.594]     }
[10:26:11.594]     ...future.result$conditions <- ...future.conditions
[10:26:11.594]     ...future.result$finished <- base::Sys.time()
[10:26:11.594]     ...future.result
[10:26:11.594] }
[10:26:11.596] assign_globals() ...
[10:26:11.596] List of 2
[10:26:11.596]  $ a : num 1
[10:26:11.596]  $ ii: int 3
[10:26:11.596]  - attr(*, "where")=List of 2
[10:26:11.596]   ..$ a :<environment: R_EmptyEnv> 
[10:26:11.596]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:11.596]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.596]  - attr(*, "resolved")= logi TRUE
[10:26:11.596]  - attr(*, "total_size")= num 112
[10:26:11.596]  - attr(*, "already-done")= logi TRUE
[10:26:11.599] - copied ‘a’ to environment
[10:26:11.599] - copied ‘ii’ to environment
[10:26:11.599] assign_globals() ... done
[10:26:11.599] plan(): Setting new future strategy stack:
[10:26:11.599] List of future strategies:
[10:26:11.599] 1. sequential:
[10:26:11.599]    - args: function (..., envir = parent.frame())
[10:26:11.599]    - tweaked: FALSE
[10:26:11.599]    - call: NULL
[10:26:11.600] plan(): nbrOfWorkers() = 1
[10:26:11.600] plan(): Setting new future strategy stack:
[10:26:11.600] List of future strategies:
[10:26:11.600] 1. sequential:
[10:26:11.600]    - args: function (..., envir = parent.frame())
[10:26:11.600]    - tweaked: FALSE
[10:26:11.600]    - call: plan(strategy)
[10:26:11.601] plan(): nbrOfWorkers() = 1
[10:26:11.601] SequentialFuture started (and completed)
[10:26:11.601] - Launch lazy future ... done
[10:26:11.601] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.601] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.602] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:11.602] 
[10:26:11.602] Searching for globals ... DONE
[10:26:11.602] - globals: [0] <none>
[10:26:11.602] getGlobalsAndPackages() ... DONE
[10:26:11.602] run() for ‘Future’ ...
[10:26:11.603] - state: ‘created’
[10:26:11.603] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.603] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.603] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.603]   - Field: ‘label’
[10:26:11.603]   - Field: ‘local’
[10:26:11.603]   - Field: ‘owner’
[10:26:11.603]   - Field: ‘envir’
[10:26:11.603]   - Field: ‘packages’
[10:26:11.604]   - Field: ‘gc’
[10:26:11.604]   - Field: ‘conditions’
[10:26:11.604]   - Field: ‘expr’
[10:26:11.604]   - Field: ‘uuid’
[10:26:11.604]   - Field: ‘seed’
[10:26:11.604]   - Field: ‘version’
[10:26:11.604]   - Field: ‘result’
[10:26:11.604]   - Field: ‘asynchronous’
[10:26:11.604]   - Field: ‘calls’
[10:26:11.604]   - Field: ‘globals’
[10:26:11.604]   - Field: ‘stdout’
[10:26:11.604]   - Field: ‘earlySignal’
[10:26:11.605]   - Field: ‘lazy’
[10:26:11.605]   - Field: ‘state’
[10:26:11.605] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.605] - Launch lazy future ...
[10:26:11.605] Packages needed by the future expression (n = 0): <none>
[10:26:11.605] Packages needed by future strategies (n = 0): <none>
[10:26:11.605] {
[10:26:11.605]     {
[10:26:11.605]         {
[10:26:11.605]             ...future.startTime <- base::Sys.time()
[10:26:11.605]             {
[10:26:11.605]                 {
[10:26:11.605]                   {
[10:26:11.605]                     base::local({
[10:26:11.605]                       has_future <- base::requireNamespace("future", 
[10:26:11.605]                         quietly = TRUE)
[10:26:11.605]                       if (has_future) {
[10:26:11.605]                         ns <- base::getNamespace("future")
[10:26:11.605]                         version <- ns[[".package"]][["version"]]
[10:26:11.605]                         if (is.null(version)) 
[10:26:11.605]                           version <- utils::packageVersion("future")
[10:26:11.605]                       }
[10:26:11.605]                       else {
[10:26:11.605]                         version <- NULL
[10:26:11.605]                       }
[10:26:11.605]                       if (!has_future || version < "1.8.0") {
[10:26:11.605]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.605]                           "", base::R.version$version.string), 
[10:26:11.605]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.605]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.605]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.605]                             "release", "version")], collapse = " "), 
[10:26:11.605]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.605]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.605]                           info)
[10:26:11.605]                         info <- base::paste(info, collapse = "; ")
[10:26:11.605]                         if (!has_future) {
[10:26:11.605]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.605]                             info)
[10:26:11.605]                         }
[10:26:11.605]                         else {
[10:26:11.605]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.605]                             info, version)
[10:26:11.605]                         }
[10:26:11.605]                         base::stop(msg)
[10:26:11.605]                       }
[10:26:11.605]                     })
[10:26:11.605]                   }
[10:26:11.605]                   options(future.plan = NULL)
[10:26:11.605]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.605]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.605]                 }
[10:26:11.605]                 ...future.workdir <- getwd()
[10:26:11.605]             }
[10:26:11.605]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.605]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.605]         }
[10:26:11.605]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.605]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:11.605]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.605]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.605]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.605]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.605]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.605]             base::names(...future.oldOptions))
[10:26:11.605]     }
[10:26:11.605]     if (FALSE) {
[10:26:11.605]     }
[10:26:11.605]     else {
[10:26:11.605]         if (TRUE) {
[10:26:11.605]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.605]                 open = "w")
[10:26:11.605]         }
[10:26:11.605]         else {
[10:26:11.605]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.605]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.605]         }
[10:26:11.605]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.605]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.605]             base::sink(type = "output", split = FALSE)
[10:26:11.605]             base::close(...future.stdout)
[10:26:11.605]         }, add = TRUE)
[10:26:11.605]     }
[10:26:11.605]     ...future.frame <- base::sys.nframe()
[10:26:11.605]     ...future.conditions <- base::list()
[10:26:11.605]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.605]     if (FALSE) {
[10:26:11.605]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.605]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.605]     }
[10:26:11.605]     ...future.result <- base::tryCatch({
[10:26:11.605]         base::withCallingHandlers({
[10:26:11.605]             ...future.value <- base::withVisible(base::local(1))
[10:26:11.605]             future::FutureResult(value = ...future.value$value, 
[10:26:11.605]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.605]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.605]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.605]                     ...future.globalenv.names))
[10:26:11.605]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.605]         }, condition = base::local({
[10:26:11.605]             c <- base::c
[10:26:11.605]             inherits <- base::inherits
[10:26:11.605]             invokeRestart <- base::invokeRestart
[10:26:11.605]             length <- base::length
[10:26:11.605]             list <- base::list
[10:26:11.605]             seq.int <- base::seq.int
[10:26:11.605]             signalCondition <- base::signalCondition
[10:26:11.605]             sys.calls <- base::sys.calls
[10:26:11.605]             `[[` <- base::`[[`
[10:26:11.605]             `+` <- base::`+`
[10:26:11.605]             `<<-` <- base::`<<-`
[10:26:11.605]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.605]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.605]                   3L)]
[10:26:11.605]             }
[10:26:11.605]             function(cond) {
[10:26:11.605]                 is_error <- inherits(cond, "error")
[10:26:11.605]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.605]                   NULL)
[10:26:11.605]                 if (is_error) {
[10:26:11.605]                   sessionInformation <- function() {
[10:26:11.605]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.605]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.605]                       search = base::search(), system = base::Sys.info())
[10:26:11.605]                   }
[10:26:11.605]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.605]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.605]                     cond$call), session = sessionInformation(), 
[10:26:11.605]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.605]                   signalCondition(cond)
[10:26:11.605]                 }
[10:26:11.605]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.605]                 "immediateCondition"))) {
[10:26:11.605]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.605]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.605]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.605]                   if (TRUE && !signal) {
[10:26:11.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.605]                     {
[10:26:11.605]                       inherits <- base::inherits
[10:26:11.605]                       invokeRestart <- base::invokeRestart
[10:26:11.605]                       is.null <- base::is.null
[10:26:11.605]                       muffled <- FALSE
[10:26:11.605]                       if (inherits(cond, "message")) {
[10:26:11.605]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.605]                         if (muffled) 
[10:26:11.605]                           invokeRestart("muffleMessage")
[10:26:11.605]                       }
[10:26:11.605]                       else if (inherits(cond, "warning")) {
[10:26:11.605]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.605]                         if (muffled) 
[10:26:11.605]                           invokeRestart("muffleWarning")
[10:26:11.605]                       }
[10:26:11.605]                       else if (inherits(cond, "condition")) {
[10:26:11.605]                         if (!is.null(pattern)) {
[10:26:11.605]                           computeRestarts <- base::computeRestarts
[10:26:11.605]                           grepl <- base::grepl
[10:26:11.605]                           restarts <- computeRestarts(cond)
[10:26:11.605]                           for (restart in restarts) {
[10:26:11.605]                             name <- restart$name
[10:26:11.605]                             if (is.null(name)) 
[10:26:11.605]                               next
[10:26:11.605]                             if (!grepl(pattern, name)) 
[10:26:11.605]                               next
[10:26:11.605]                             invokeRestart(restart)
[10:26:11.605]                             muffled <- TRUE
[10:26:11.605]                             break
[10:26:11.605]                           }
[10:26:11.605]                         }
[10:26:11.605]                       }
[10:26:11.605]                       invisible(muffled)
[10:26:11.605]                     }
[10:26:11.605]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.605]                   }
[10:26:11.605]                 }
[10:26:11.605]                 else {
[10:26:11.605]                   if (TRUE) {
[10:26:11.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.605]                     {
[10:26:11.605]                       inherits <- base::inherits
[10:26:11.605]                       invokeRestart <- base::invokeRestart
[10:26:11.605]                       is.null <- base::is.null
[10:26:11.605]                       muffled <- FALSE
[10:26:11.605]                       if (inherits(cond, "message")) {
[10:26:11.605]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.605]                         if (muffled) 
[10:26:11.605]                           invokeRestart("muffleMessage")
[10:26:11.605]                       }
[10:26:11.605]                       else if (inherits(cond, "warning")) {
[10:26:11.605]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.605]                         if (muffled) 
[10:26:11.605]                           invokeRestart("muffleWarning")
[10:26:11.605]                       }
[10:26:11.605]                       else if (inherits(cond, "condition")) {
[10:26:11.605]                         if (!is.null(pattern)) {
[10:26:11.605]                           computeRestarts <- base::computeRestarts
[10:26:11.605]                           grepl <- base::grepl
[10:26:11.605]                           restarts <- computeRestarts(cond)
[10:26:11.605]                           for (restart in restarts) {
[10:26:11.605]                             name <- restart$name
[10:26:11.605]                             if (is.null(name)) 
[10:26:11.605]                               next
[10:26:11.605]                             if (!grepl(pattern, name)) 
[10:26:11.605]                               next
[10:26:11.605]                             invokeRestart(restart)
[10:26:11.605]                             muffled <- TRUE
[10:26:11.605]                             break
[10:26:11.605]                           }
[10:26:11.605]                         }
[10:26:11.605]                       }
[10:26:11.605]                       invisible(muffled)
[10:26:11.605]                     }
[10:26:11.605]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.605]                   }
[10:26:11.605]                 }
[10:26:11.605]             }
[10:26:11.605]         }))
[10:26:11.605]     }, error = function(ex) {
[10:26:11.605]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.605]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.605]                 ...future.rng), started = ...future.startTime, 
[10:26:11.605]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.605]             version = "1.8"), class = "FutureResult")
[10:26:11.605]     }, finally = {
[10:26:11.605]         if (!identical(...future.workdir, getwd())) 
[10:26:11.605]             setwd(...future.workdir)
[10:26:11.605]         {
[10:26:11.605]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.605]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.605]             }
[10:26:11.605]             base::options(...future.oldOptions)
[10:26:11.605]             if (.Platform$OS.type == "windows") {
[10:26:11.605]                 old_names <- names(...future.oldEnvVars)
[10:26:11.605]                 envs <- base::Sys.getenv()
[10:26:11.605]                 names <- names(envs)
[10:26:11.605]                 common <- intersect(names, old_names)
[10:26:11.605]                 added <- setdiff(names, old_names)
[10:26:11.605]                 removed <- setdiff(old_names, names)
[10:26:11.605]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.605]                   envs[common]]
[10:26:11.605]                 NAMES <- toupper(changed)
[10:26:11.605]                 args <- list()
[10:26:11.605]                 for (kk in seq_along(NAMES)) {
[10:26:11.605]                   name <- changed[[kk]]
[10:26:11.605]                   NAME <- NAMES[[kk]]
[10:26:11.605]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.605]                     next
[10:26:11.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.605]                 }
[10:26:11.605]                 NAMES <- toupper(added)
[10:26:11.605]                 for (kk in seq_along(NAMES)) {
[10:26:11.605]                   name <- added[[kk]]
[10:26:11.605]                   NAME <- NAMES[[kk]]
[10:26:11.605]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.605]                     next
[10:26:11.605]                   args[[name]] <- ""
[10:26:11.605]                 }
[10:26:11.605]                 NAMES <- toupper(removed)
[10:26:11.605]                 for (kk in seq_along(NAMES)) {
[10:26:11.605]                   name <- removed[[kk]]
[10:26:11.605]                   NAME <- NAMES[[kk]]
[10:26:11.605]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.605]                     next
[10:26:11.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.605]                 }
[10:26:11.605]                 if (length(args) > 0) 
[10:26:11.605]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.605]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.605]             }
[10:26:11.605]             else {
[10:26:11.605]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.605]             }
[10:26:11.605]             {
[10:26:11.605]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.605]                   0L) {
[10:26:11.605]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.605]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.605]                   base::options(opts)
[10:26:11.605]                 }
[10:26:11.605]                 {
[10:26:11.605]                   {
[10:26:11.605]                     NULL
[10:26:11.605]                     RNGkind("Mersenne-Twister")
[10:26:11.605]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.605]                       inherits = FALSE)
[10:26:11.605]                   }
[10:26:11.605]                   options(future.plan = NULL)
[10:26:11.605]                   if (is.na(NA_character_)) 
[10:26:11.605]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.605]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.605]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.605]                   {
[10:26:11.605]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.605]                     if (!future$lazy) 
[10:26:11.605]                       future <- run(future)
[10:26:11.605]                     invisible(future)
[10:26:11.605]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.605]                 }
[10:26:11.605]             }
[10:26:11.605]         }
[10:26:11.605]     })
[10:26:11.605]     if (TRUE) {
[10:26:11.605]         base::sink(type = "output", split = FALSE)
[10:26:11.605]         if (TRUE) {
[10:26:11.605]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.605]         }
[10:26:11.605]         else {
[10:26:11.605]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.605]         }
[10:26:11.605]         base::close(...future.stdout)
[10:26:11.605]         ...future.stdout <- NULL
[10:26:11.605]     }
[10:26:11.605]     ...future.result$conditions <- ...future.conditions
[10:26:11.605]     ...future.result$finished <- base::Sys.time()
[10:26:11.605]     ...future.result
[10:26:11.605] }
[10:26:11.607] plan(): Setting new future strategy stack:
[10:26:11.607] List of future strategies:
[10:26:11.607] 1. sequential:
[10:26:11.607]    - args: function (..., envir = parent.frame())
[10:26:11.607]    - tweaked: FALSE
[10:26:11.607]    - call: NULL
[10:26:11.608] plan(): nbrOfWorkers() = 1
[10:26:11.608] plan(): Setting new future strategy stack:
[10:26:11.608] List of future strategies:
[10:26:11.608] 1. sequential:
[10:26:11.608]    - args: function (..., envir = parent.frame())
[10:26:11.608]    - tweaked: FALSE
[10:26:11.608]    - call: plan(strategy)
[10:26:11.609] plan(): nbrOfWorkers() = 1
[10:26:11.609] SequentialFuture started (and completed)
[10:26:11.609] - Launch lazy future ... done
[10:26:11.609] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.609] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.609] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:11.611] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:11.611] Searching for globals ... DONE
[10:26:11.611] Resolving globals: TRUE
[10:26:11.611] Resolving any globals that are futures ...
[10:26:11.611] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:11.612] Resolving any globals that are futures ... DONE
[10:26:11.612] Resolving futures part of globals (recursively) ...
[10:26:11.612] resolve() on list ...
[10:26:11.612]  recursive: 99
[10:26:11.612]  length: 1
[10:26:11.612]  elements: ‘a’
[10:26:11.612] resolved() for ‘SequentialFuture’ ...
[10:26:11.613] - state: ‘finished’
[10:26:11.613] - run: TRUE
[10:26:11.613] - result: ‘FutureResult’
[10:26:11.613] resolved() for ‘SequentialFuture’ ... done
[10:26:11.613] Future #1
[10:26:11.613] resolved() for ‘SequentialFuture’ ...
[10:26:11.613] - state: ‘finished’
[10:26:11.613] - run: TRUE
[10:26:11.613] - result: ‘FutureResult’
[10:26:11.613] resolved() for ‘SequentialFuture’ ... done
[10:26:11.613] A SequentialFuture was resolved
[10:26:11.614]  length: 0 (resolved future 1)
[10:26:11.614] resolve() on list ... DONE
[10:26:11.614] - globals: [1] ‘a’
[10:26:11.614] Resolving futures part of globals (recursively) ... DONE
[10:26:11.616] The total size of the 1 globals is 1.54 MiB (1615912 bytes)
[10:26:11.616] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.54 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.54 MiB of class ‘environment’)
[10:26:11.616] - globals: [1] ‘a’
[10:26:11.616] - packages: [1] ‘future’
[10:26:11.616] getGlobalsAndPackages() ... DONE
[10:26:11.616] run() for ‘Future’ ...
[10:26:11.617] - state: ‘created’
[10:26:11.617] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.617] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.617] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.617]   - Field: ‘label’
[10:26:11.617]   - Field: ‘local’
[10:26:11.617]   - Field: ‘owner’
[10:26:11.617]   - Field: ‘envir’
[10:26:11.617]   - Field: ‘packages’
[10:26:11.618]   - Field: ‘gc’
[10:26:11.618]   - Field: ‘conditions’
[10:26:11.618]   - Field: ‘expr’
[10:26:11.618]   - Field: ‘uuid’
[10:26:11.618]   - Field: ‘seed’
[10:26:11.618]   - Field: ‘version’
[10:26:11.618]   - Field: ‘result’
[10:26:11.618]   - Field: ‘asynchronous’
[10:26:11.618]   - Field: ‘calls’
[10:26:11.618]   - Field: ‘globals’
[10:26:11.618]   - Field: ‘stdout’
[10:26:11.618]   - Field: ‘earlySignal’
[10:26:11.619]   - Field: ‘lazy’
[10:26:11.619]   - Field: ‘state’
[10:26:11.619] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.619] - Launch lazy future ...
[10:26:11.619] Packages needed by the future expression (n = 1): ‘future’
[10:26:11.619] Packages needed by future strategies (n = 0): <none>
[10:26:11.620] {
[10:26:11.620]     {
[10:26:11.620]         {
[10:26:11.620]             ...future.startTime <- base::Sys.time()
[10:26:11.620]             {
[10:26:11.620]                 {
[10:26:11.620]                   {
[10:26:11.620]                     {
[10:26:11.620]                       base::local({
[10:26:11.620]                         has_future <- base::requireNamespace("future", 
[10:26:11.620]                           quietly = TRUE)
[10:26:11.620]                         if (has_future) {
[10:26:11.620]                           ns <- base::getNamespace("future")
[10:26:11.620]                           version <- ns[[".package"]][["version"]]
[10:26:11.620]                           if (is.null(version)) 
[10:26:11.620]                             version <- utils::packageVersion("future")
[10:26:11.620]                         }
[10:26:11.620]                         else {
[10:26:11.620]                           version <- NULL
[10:26:11.620]                         }
[10:26:11.620]                         if (!has_future || version < "1.8.0") {
[10:26:11.620]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.620]                             "", base::R.version$version.string), 
[10:26:11.620]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:11.620]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.620]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.620]                               "release", "version")], collapse = " "), 
[10:26:11.620]                             hostname = base::Sys.info()[["nodename"]])
[10:26:11.620]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.620]                             info)
[10:26:11.620]                           info <- base::paste(info, collapse = "; ")
[10:26:11.620]                           if (!has_future) {
[10:26:11.620]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.620]                               info)
[10:26:11.620]                           }
[10:26:11.620]                           else {
[10:26:11.620]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.620]                               info, version)
[10:26:11.620]                           }
[10:26:11.620]                           base::stop(msg)
[10:26:11.620]                         }
[10:26:11.620]                       })
[10:26:11.620]                     }
[10:26:11.620]                     base::local({
[10:26:11.620]                       for (pkg in "future") {
[10:26:11.620]                         base::loadNamespace(pkg)
[10:26:11.620]                         base::library(pkg, character.only = TRUE)
[10:26:11.620]                       }
[10:26:11.620]                     })
[10:26:11.620]                   }
[10:26:11.620]                   options(future.plan = NULL)
[10:26:11.620]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.620]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.620]                 }
[10:26:11.620]                 ...future.workdir <- getwd()
[10:26:11.620]             }
[10:26:11.620]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.620]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.620]         }
[10:26:11.620]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.620]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:11.620]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.620]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.620]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.620]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.620]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.620]             base::names(...future.oldOptions))
[10:26:11.620]     }
[10:26:11.620]     if (FALSE) {
[10:26:11.620]     }
[10:26:11.620]     else {
[10:26:11.620]         if (TRUE) {
[10:26:11.620]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.620]                 open = "w")
[10:26:11.620]         }
[10:26:11.620]         else {
[10:26:11.620]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.620]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.620]         }
[10:26:11.620]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.620]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.620]             base::sink(type = "output", split = FALSE)
[10:26:11.620]             base::close(...future.stdout)
[10:26:11.620]         }, add = TRUE)
[10:26:11.620]     }
[10:26:11.620]     ...future.frame <- base::sys.nframe()
[10:26:11.620]     ...future.conditions <- base::list()
[10:26:11.620]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.620]     if (FALSE) {
[10:26:11.620]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.620]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.620]     }
[10:26:11.620]     ...future.result <- base::tryCatch({
[10:26:11.620]         base::withCallingHandlers({
[10:26:11.620]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:26:11.620]                 1))
[10:26:11.620]             future::FutureResult(value = ...future.value$value, 
[10:26:11.620]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.620]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.620]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.620]                     ...future.globalenv.names))
[10:26:11.620]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.620]         }, condition = base::local({
[10:26:11.620]             c <- base::c
[10:26:11.620]             inherits <- base::inherits
[10:26:11.620]             invokeRestart <- base::invokeRestart
[10:26:11.620]             length <- base::length
[10:26:11.620]             list <- base::list
[10:26:11.620]             seq.int <- base::seq.int
[10:26:11.620]             signalCondition <- base::signalCondition
[10:26:11.620]             sys.calls <- base::sys.calls
[10:26:11.620]             `[[` <- base::`[[`
[10:26:11.620]             `+` <- base::`+`
[10:26:11.620]             `<<-` <- base::`<<-`
[10:26:11.620]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.620]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.620]                   3L)]
[10:26:11.620]             }
[10:26:11.620]             function(cond) {
[10:26:11.620]                 is_error <- inherits(cond, "error")
[10:26:11.620]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.620]                   NULL)
[10:26:11.620]                 if (is_error) {
[10:26:11.620]                   sessionInformation <- function() {
[10:26:11.620]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.620]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.620]                       search = base::search(), system = base::Sys.info())
[10:26:11.620]                   }
[10:26:11.620]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.620]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.620]                     cond$call), session = sessionInformation(), 
[10:26:11.620]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.620]                   signalCondition(cond)
[10:26:11.620]                 }
[10:26:11.620]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.620]                 "immediateCondition"))) {
[10:26:11.620]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.620]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.620]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.620]                   if (TRUE && !signal) {
[10:26:11.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.620]                     {
[10:26:11.620]                       inherits <- base::inherits
[10:26:11.620]                       invokeRestart <- base::invokeRestart
[10:26:11.620]                       is.null <- base::is.null
[10:26:11.620]                       muffled <- FALSE
[10:26:11.620]                       if (inherits(cond, "message")) {
[10:26:11.620]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.620]                         if (muffled) 
[10:26:11.620]                           invokeRestart("muffleMessage")
[10:26:11.620]                       }
[10:26:11.620]                       else if (inherits(cond, "warning")) {
[10:26:11.620]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.620]                         if (muffled) 
[10:26:11.620]                           invokeRestart("muffleWarning")
[10:26:11.620]                       }
[10:26:11.620]                       else if (inherits(cond, "condition")) {
[10:26:11.620]                         if (!is.null(pattern)) {
[10:26:11.620]                           computeRestarts <- base::computeRestarts
[10:26:11.620]                           grepl <- base::grepl
[10:26:11.620]                           restarts <- computeRestarts(cond)
[10:26:11.620]                           for (restart in restarts) {
[10:26:11.620]                             name <- restart$name
[10:26:11.620]                             if (is.null(name)) 
[10:26:11.620]                               next
[10:26:11.620]                             if (!grepl(pattern, name)) 
[10:26:11.620]                               next
[10:26:11.620]                             invokeRestart(restart)
[10:26:11.620]                             muffled <- TRUE
[10:26:11.620]                             break
[10:26:11.620]                           }
[10:26:11.620]                         }
[10:26:11.620]                       }
[10:26:11.620]                       invisible(muffled)
[10:26:11.620]                     }
[10:26:11.620]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.620]                   }
[10:26:11.620]                 }
[10:26:11.620]                 else {
[10:26:11.620]                   if (TRUE) {
[10:26:11.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.620]                     {
[10:26:11.620]                       inherits <- base::inherits
[10:26:11.620]                       invokeRestart <- base::invokeRestart
[10:26:11.620]                       is.null <- base::is.null
[10:26:11.620]                       muffled <- FALSE
[10:26:11.620]                       if (inherits(cond, "message")) {
[10:26:11.620]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.620]                         if (muffled) 
[10:26:11.620]                           invokeRestart("muffleMessage")
[10:26:11.620]                       }
[10:26:11.620]                       else if (inherits(cond, "warning")) {
[10:26:11.620]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.620]                         if (muffled) 
[10:26:11.620]                           invokeRestart("muffleWarning")
[10:26:11.620]                       }
[10:26:11.620]                       else if (inherits(cond, "condition")) {
[10:26:11.620]                         if (!is.null(pattern)) {
[10:26:11.620]                           computeRestarts <- base::computeRestarts
[10:26:11.620]                           grepl <- base::grepl
[10:26:11.620]                           restarts <- computeRestarts(cond)
[10:26:11.620]                           for (restart in restarts) {
[10:26:11.620]                             name <- restart$name
[10:26:11.620]                             if (is.null(name)) 
[10:26:11.620]                               next
[10:26:11.620]                             if (!grepl(pattern, name)) 
[10:26:11.620]                               next
[10:26:11.620]                             invokeRestart(restart)
[10:26:11.620]                             muffled <- TRUE
[10:26:11.620]                             break
[10:26:11.620]                           }
[10:26:11.620]                         }
[10:26:11.620]                       }
[10:26:11.620]                       invisible(muffled)
[10:26:11.620]                     }
[10:26:11.620]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.620]                   }
[10:26:11.620]                 }
[10:26:11.620]             }
[10:26:11.620]         }))
[10:26:11.620]     }, error = function(ex) {
[10:26:11.620]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.620]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.620]                 ...future.rng), started = ...future.startTime, 
[10:26:11.620]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.620]             version = "1.8"), class = "FutureResult")
[10:26:11.620]     }, finally = {
[10:26:11.620]         if (!identical(...future.workdir, getwd())) 
[10:26:11.620]             setwd(...future.workdir)
[10:26:11.620]         {
[10:26:11.620]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.620]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.620]             }
[10:26:11.620]             base::options(...future.oldOptions)
[10:26:11.620]             if (.Platform$OS.type == "windows") {
[10:26:11.620]                 old_names <- names(...future.oldEnvVars)
[10:26:11.620]                 envs <- base::Sys.getenv()
[10:26:11.620]                 names <- names(envs)
[10:26:11.620]                 common <- intersect(names, old_names)
[10:26:11.620]                 added <- setdiff(names, old_names)
[10:26:11.620]                 removed <- setdiff(old_names, names)
[10:26:11.620]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.620]                   envs[common]]
[10:26:11.620]                 NAMES <- toupper(changed)
[10:26:11.620]                 args <- list()
[10:26:11.620]                 for (kk in seq_along(NAMES)) {
[10:26:11.620]                   name <- changed[[kk]]
[10:26:11.620]                   NAME <- NAMES[[kk]]
[10:26:11.620]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.620]                     next
[10:26:11.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.620]                 }
[10:26:11.620]                 NAMES <- toupper(added)
[10:26:11.620]                 for (kk in seq_along(NAMES)) {
[10:26:11.620]                   name <- added[[kk]]
[10:26:11.620]                   NAME <- NAMES[[kk]]
[10:26:11.620]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.620]                     next
[10:26:11.620]                   args[[name]] <- ""
[10:26:11.620]                 }
[10:26:11.620]                 NAMES <- toupper(removed)
[10:26:11.620]                 for (kk in seq_along(NAMES)) {
[10:26:11.620]                   name <- removed[[kk]]
[10:26:11.620]                   NAME <- NAMES[[kk]]
[10:26:11.620]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.620]                     next
[10:26:11.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.620]                 }
[10:26:11.620]                 if (length(args) > 0) 
[10:26:11.620]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.620]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.620]             }
[10:26:11.620]             else {
[10:26:11.620]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.620]             }
[10:26:11.620]             {
[10:26:11.620]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.620]                   0L) {
[10:26:11.620]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.620]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.620]                   base::options(opts)
[10:26:11.620]                 }
[10:26:11.620]                 {
[10:26:11.620]                   {
[10:26:11.620]                     NULL
[10:26:11.620]                     RNGkind("Mersenne-Twister")
[10:26:11.620]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.620]                       inherits = FALSE)
[10:26:11.620]                   }
[10:26:11.620]                   options(future.plan = NULL)
[10:26:11.620]                   if (is.na(NA_character_)) 
[10:26:11.620]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.620]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.620]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.620]                   {
[10:26:11.620]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.620]                     if (!future$lazy) 
[10:26:11.620]                       future <- run(future)
[10:26:11.620]                     invisible(future)
[10:26:11.620]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.620]                 }
[10:26:11.620]             }
[10:26:11.620]         }
[10:26:11.620]     })
[10:26:11.620]     if (TRUE) {
[10:26:11.620]         base::sink(type = "output", split = FALSE)
[10:26:11.620]         if (TRUE) {
[10:26:11.620]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.620]         }
[10:26:11.620]         else {
[10:26:11.620]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.620]         }
[10:26:11.620]         base::close(...future.stdout)
[10:26:11.620]         ...future.stdout <- NULL
[10:26:11.620]     }
[10:26:11.620]     ...future.result$conditions <- ...future.conditions
[10:26:11.620]     ...future.result$finished <- base::Sys.time()
[10:26:11.620]     ...future.result
[10:26:11.620] }
[10:26:11.621] assign_globals() ...
[10:26:11.621] List of 1
[10:26:11.621]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a02223d298> 
[10:26:11.621]  - attr(*, "where")=List of 1
[10:26:11.621]   ..$ a:<environment: R_EmptyEnv> 
[10:26:11.621]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.621]  - attr(*, "resolved")= logi TRUE
[10:26:11.621]  - attr(*, "total_size")= num 1615912
[10:26:11.621]  - attr(*, "already-done")= logi TRUE
[10:26:11.623] - copied ‘a’ to environment
[10:26:11.624] assign_globals() ... done
[10:26:11.624] plan(): Setting new future strategy stack:
[10:26:11.624] List of future strategies:
[10:26:11.624] 1. sequential:
[10:26:11.624]    - args: function (..., envir = parent.frame())
[10:26:11.624]    - tweaked: FALSE
[10:26:11.624]    - call: NULL
[10:26:11.624] plan(): nbrOfWorkers() = 1
[10:26:11.625] plan(): Setting new future strategy stack:
[10:26:11.625] List of future strategies:
[10:26:11.625] 1. sequential:
[10:26:11.625]    - args: function (..., envir = parent.frame())
[10:26:11.625]    - tweaked: FALSE
[10:26:11.625]    - call: plan(strategy)
[10:26:11.625] plan(): nbrOfWorkers() = 1
[10:26:11.626] SequentialFuture started (and completed)
[10:26:11.626] - Launch lazy future ... done
[10:26:11.626] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.626] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.626] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:11.627] 
[10:26:11.627] Searching for globals ... DONE
[10:26:11.627] - globals: [0] <none>
[10:26:11.627] getGlobalsAndPackages() ... DONE
[10:26:11.627] run() for ‘Future’ ...
[10:26:11.627] - state: ‘created’
[10:26:11.627] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.628] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.628] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.628]   - Field: ‘label’
[10:26:11.628]   - Field: ‘local’
[10:26:11.628]   - Field: ‘owner’
[10:26:11.628]   - Field: ‘envir’
[10:26:11.628]   - Field: ‘packages’
[10:26:11.628]   - Field: ‘gc’
[10:26:11.628]   - Field: ‘conditions’
[10:26:11.628]   - Field: ‘expr’
[10:26:11.629]   - Field: ‘uuid’
[10:26:11.629]   - Field: ‘seed’
[10:26:11.629]   - Field: ‘version’
[10:26:11.629]   - Field: ‘result’
[10:26:11.629]   - Field: ‘asynchronous’
[10:26:11.629]   - Field: ‘calls’
[10:26:11.629]   - Field: ‘globals’
[10:26:11.629]   - Field: ‘stdout’
[10:26:11.629]   - Field: ‘earlySignal’
[10:26:11.629]   - Field: ‘lazy’
[10:26:11.629]   - Field: ‘state’
[10:26:11.630] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.630] - Launch lazy future ...
[10:26:11.630] Packages needed by the future expression (n = 0): <none>
[10:26:11.630] Packages needed by future strategies (n = 0): <none>
[10:26:11.630] {
[10:26:11.630]     {
[10:26:11.630]         {
[10:26:11.630]             ...future.startTime <- base::Sys.time()
[10:26:11.630]             {
[10:26:11.630]                 {
[10:26:11.630]                   {
[10:26:11.630]                     base::local({
[10:26:11.630]                       has_future <- base::requireNamespace("future", 
[10:26:11.630]                         quietly = TRUE)
[10:26:11.630]                       if (has_future) {
[10:26:11.630]                         ns <- base::getNamespace("future")
[10:26:11.630]                         version <- ns[[".package"]][["version"]]
[10:26:11.630]                         if (is.null(version)) 
[10:26:11.630]                           version <- utils::packageVersion("future")
[10:26:11.630]                       }
[10:26:11.630]                       else {
[10:26:11.630]                         version <- NULL
[10:26:11.630]                       }
[10:26:11.630]                       if (!has_future || version < "1.8.0") {
[10:26:11.630]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.630]                           "", base::R.version$version.string), 
[10:26:11.630]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.630]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.630]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.630]                             "release", "version")], collapse = " "), 
[10:26:11.630]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.630]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.630]                           info)
[10:26:11.630]                         info <- base::paste(info, collapse = "; ")
[10:26:11.630]                         if (!has_future) {
[10:26:11.630]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.630]                             info)
[10:26:11.630]                         }
[10:26:11.630]                         else {
[10:26:11.630]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.630]                             info, version)
[10:26:11.630]                         }
[10:26:11.630]                         base::stop(msg)
[10:26:11.630]                       }
[10:26:11.630]                     })
[10:26:11.630]                   }
[10:26:11.630]                   options(future.plan = NULL)
[10:26:11.630]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.630]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.630]                 }
[10:26:11.630]                 ...future.workdir <- getwd()
[10:26:11.630]             }
[10:26:11.630]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.630]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.630]         }
[10:26:11.630]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.630]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:11.630]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.630]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.630]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.630]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.630]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.630]             base::names(...future.oldOptions))
[10:26:11.630]     }
[10:26:11.630]     if (FALSE) {
[10:26:11.630]     }
[10:26:11.630]     else {
[10:26:11.630]         if (TRUE) {
[10:26:11.630]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.630]                 open = "w")
[10:26:11.630]         }
[10:26:11.630]         else {
[10:26:11.630]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.630]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.630]         }
[10:26:11.630]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.630]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.630]             base::sink(type = "output", split = FALSE)
[10:26:11.630]             base::close(...future.stdout)
[10:26:11.630]         }, add = TRUE)
[10:26:11.630]     }
[10:26:11.630]     ...future.frame <- base::sys.nframe()
[10:26:11.630]     ...future.conditions <- base::list()
[10:26:11.630]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.630]     if (FALSE) {
[10:26:11.630]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.630]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.630]     }
[10:26:11.630]     ...future.result <- base::tryCatch({
[10:26:11.630]         base::withCallingHandlers({
[10:26:11.630]             ...future.value <- base::withVisible(base::local(1))
[10:26:11.630]             future::FutureResult(value = ...future.value$value, 
[10:26:11.630]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.630]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.630]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.630]                     ...future.globalenv.names))
[10:26:11.630]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.630]         }, condition = base::local({
[10:26:11.630]             c <- base::c
[10:26:11.630]             inherits <- base::inherits
[10:26:11.630]             invokeRestart <- base::invokeRestart
[10:26:11.630]             length <- base::length
[10:26:11.630]             list <- base::list
[10:26:11.630]             seq.int <- base::seq.int
[10:26:11.630]             signalCondition <- base::signalCondition
[10:26:11.630]             sys.calls <- base::sys.calls
[10:26:11.630]             `[[` <- base::`[[`
[10:26:11.630]             `+` <- base::`+`
[10:26:11.630]             `<<-` <- base::`<<-`
[10:26:11.630]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.630]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.630]                   3L)]
[10:26:11.630]             }
[10:26:11.630]             function(cond) {
[10:26:11.630]                 is_error <- inherits(cond, "error")
[10:26:11.630]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.630]                   NULL)
[10:26:11.630]                 if (is_error) {
[10:26:11.630]                   sessionInformation <- function() {
[10:26:11.630]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.630]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.630]                       search = base::search(), system = base::Sys.info())
[10:26:11.630]                   }
[10:26:11.630]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.630]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.630]                     cond$call), session = sessionInformation(), 
[10:26:11.630]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.630]                   signalCondition(cond)
[10:26:11.630]                 }
[10:26:11.630]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.630]                 "immediateCondition"))) {
[10:26:11.630]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.630]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.630]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.630]                   if (TRUE && !signal) {
[10:26:11.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.630]                     {
[10:26:11.630]                       inherits <- base::inherits
[10:26:11.630]                       invokeRestart <- base::invokeRestart
[10:26:11.630]                       is.null <- base::is.null
[10:26:11.630]                       muffled <- FALSE
[10:26:11.630]                       if (inherits(cond, "message")) {
[10:26:11.630]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.630]                         if (muffled) 
[10:26:11.630]                           invokeRestart("muffleMessage")
[10:26:11.630]                       }
[10:26:11.630]                       else if (inherits(cond, "warning")) {
[10:26:11.630]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.630]                         if (muffled) 
[10:26:11.630]                           invokeRestart("muffleWarning")
[10:26:11.630]                       }
[10:26:11.630]                       else if (inherits(cond, "condition")) {
[10:26:11.630]                         if (!is.null(pattern)) {
[10:26:11.630]                           computeRestarts <- base::computeRestarts
[10:26:11.630]                           grepl <- base::grepl
[10:26:11.630]                           restarts <- computeRestarts(cond)
[10:26:11.630]                           for (restart in restarts) {
[10:26:11.630]                             name <- restart$name
[10:26:11.630]                             if (is.null(name)) 
[10:26:11.630]                               next
[10:26:11.630]                             if (!grepl(pattern, name)) 
[10:26:11.630]                               next
[10:26:11.630]                             invokeRestart(restart)
[10:26:11.630]                             muffled <- TRUE
[10:26:11.630]                             break
[10:26:11.630]                           }
[10:26:11.630]                         }
[10:26:11.630]                       }
[10:26:11.630]                       invisible(muffled)
[10:26:11.630]                     }
[10:26:11.630]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.630]                   }
[10:26:11.630]                 }
[10:26:11.630]                 else {
[10:26:11.630]                   if (TRUE) {
[10:26:11.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.630]                     {
[10:26:11.630]                       inherits <- base::inherits
[10:26:11.630]                       invokeRestart <- base::invokeRestart
[10:26:11.630]                       is.null <- base::is.null
[10:26:11.630]                       muffled <- FALSE
[10:26:11.630]                       if (inherits(cond, "message")) {
[10:26:11.630]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.630]                         if (muffled) 
[10:26:11.630]                           invokeRestart("muffleMessage")
[10:26:11.630]                       }
[10:26:11.630]                       else if (inherits(cond, "warning")) {
[10:26:11.630]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.630]                         if (muffled) 
[10:26:11.630]                           invokeRestart("muffleWarning")
[10:26:11.630]                       }
[10:26:11.630]                       else if (inherits(cond, "condition")) {
[10:26:11.630]                         if (!is.null(pattern)) {
[10:26:11.630]                           computeRestarts <- base::computeRestarts
[10:26:11.630]                           grepl <- base::grepl
[10:26:11.630]                           restarts <- computeRestarts(cond)
[10:26:11.630]                           for (restart in restarts) {
[10:26:11.630]                             name <- restart$name
[10:26:11.630]                             if (is.null(name)) 
[10:26:11.630]                               next
[10:26:11.630]                             if (!grepl(pattern, name)) 
[10:26:11.630]                               next
[10:26:11.630]                             invokeRestart(restart)
[10:26:11.630]                             muffled <- TRUE
[10:26:11.630]                             break
[10:26:11.630]                           }
[10:26:11.630]                         }
[10:26:11.630]                       }
[10:26:11.630]                       invisible(muffled)
[10:26:11.630]                     }
[10:26:11.630]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.630]                   }
[10:26:11.630]                 }
[10:26:11.630]             }
[10:26:11.630]         }))
[10:26:11.630]     }, error = function(ex) {
[10:26:11.630]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.630]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.630]                 ...future.rng), started = ...future.startTime, 
[10:26:11.630]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.630]             version = "1.8"), class = "FutureResult")
[10:26:11.630]     }, finally = {
[10:26:11.630]         if (!identical(...future.workdir, getwd())) 
[10:26:11.630]             setwd(...future.workdir)
[10:26:11.630]         {
[10:26:11.630]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.630]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.630]             }
[10:26:11.630]             base::options(...future.oldOptions)
[10:26:11.630]             if (.Platform$OS.type == "windows") {
[10:26:11.630]                 old_names <- names(...future.oldEnvVars)
[10:26:11.630]                 envs <- base::Sys.getenv()
[10:26:11.630]                 names <- names(envs)
[10:26:11.630]                 common <- intersect(names, old_names)
[10:26:11.630]                 added <- setdiff(names, old_names)
[10:26:11.630]                 removed <- setdiff(old_names, names)
[10:26:11.630]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.630]                   envs[common]]
[10:26:11.630]                 NAMES <- toupper(changed)
[10:26:11.630]                 args <- list()
[10:26:11.630]                 for (kk in seq_along(NAMES)) {
[10:26:11.630]                   name <- changed[[kk]]
[10:26:11.630]                   NAME <- NAMES[[kk]]
[10:26:11.630]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.630]                     next
[10:26:11.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.630]                 }
[10:26:11.630]                 NAMES <- toupper(added)
[10:26:11.630]                 for (kk in seq_along(NAMES)) {
[10:26:11.630]                   name <- added[[kk]]
[10:26:11.630]                   NAME <- NAMES[[kk]]
[10:26:11.630]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.630]                     next
[10:26:11.630]                   args[[name]] <- ""
[10:26:11.630]                 }
[10:26:11.630]                 NAMES <- toupper(removed)
[10:26:11.630]                 for (kk in seq_along(NAMES)) {
[10:26:11.630]                   name <- removed[[kk]]
[10:26:11.630]                   NAME <- NAMES[[kk]]
[10:26:11.630]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.630]                     next
[10:26:11.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.630]                 }
[10:26:11.630]                 if (length(args) > 0) 
[10:26:11.630]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.630]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.630]             }
[10:26:11.630]             else {
[10:26:11.630]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.630]             }
[10:26:11.630]             {
[10:26:11.630]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.630]                   0L) {
[10:26:11.630]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.630]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.630]                   base::options(opts)
[10:26:11.630]                 }
[10:26:11.630]                 {
[10:26:11.630]                   {
[10:26:11.630]                     NULL
[10:26:11.630]                     RNGkind("Mersenne-Twister")
[10:26:11.630]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.630]                       inherits = FALSE)
[10:26:11.630]                   }
[10:26:11.630]                   options(future.plan = NULL)
[10:26:11.630]                   if (is.na(NA_character_)) 
[10:26:11.630]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.630]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.630]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.630]                   {
[10:26:11.630]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.630]                     if (!future$lazy) 
[10:26:11.630]                       future <- run(future)
[10:26:11.630]                     invisible(future)
[10:26:11.630]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.630]                 }
[10:26:11.630]             }
[10:26:11.630]         }
[10:26:11.630]     })
[10:26:11.630]     if (TRUE) {
[10:26:11.630]         base::sink(type = "output", split = FALSE)
[10:26:11.630]         if (TRUE) {
[10:26:11.630]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.630]         }
[10:26:11.630]         else {
[10:26:11.630]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.630]         }
[10:26:11.630]         base::close(...future.stdout)
[10:26:11.630]         ...future.stdout <- NULL
[10:26:11.630]     }
[10:26:11.630]     ...future.result$conditions <- ...future.conditions
[10:26:11.630]     ...future.result$finished <- base::Sys.time()
[10:26:11.630]     ...future.result
[10:26:11.630] }
[10:26:11.632] plan(): Setting new future strategy stack:
[10:26:11.632] List of future strategies:
[10:26:11.632] 1. sequential:
[10:26:11.632]    - args: function (..., envir = parent.frame())
[10:26:11.632]    - tweaked: FALSE
[10:26:11.632]    - call: NULL
[10:26:11.632] plan(): nbrOfWorkers() = 1
[10:26:11.633] plan(): Setting new future strategy stack:
[10:26:11.655] List of future strategies:
[10:26:11.655] 1. sequential:
[10:26:11.655]    - args: function (..., envir = parent.frame())
[10:26:11.655]    - tweaked: FALSE
[10:26:11.655]    - call: plan(strategy)
[10:26:11.656] plan(): nbrOfWorkers() = 1
[10:26:11.656] SequentialFuture started (and completed)
[10:26:11.656] - Launch lazy future ... done
[10:26:11.656] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.657] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.657] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:11.658] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:11.658] Searching for globals ... DONE
[10:26:11.658] Resolving globals: TRUE
[10:26:11.658] Resolving any globals that are futures ...
[10:26:11.658] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:11.658] Resolving any globals that are futures ... DONE
[10:26:11.658] Resolving futures part of globals (recursively) ...
[10:26:11.659] resolve() on list ...
[10:26:11.659]  recursive: 99
[10:26:11.659]  length: 1
[10:26:11.659]  elements: ‘a’
[10:26:11.659] resolved() for ‘SequentialFuture’ ...
[10:26:11.659] - state: ‘finished’
[10:26:11.659] - run: TRUE
[10:26:11.659] - result: ‘FutureResult’
[10:26:11.659] resolved() for ‘SequentialFuture’ ... done
[10:26:11.660] Future #1
[10:26:11.660] resolved() for ‘SequentialFuture’ ...
[10:26:11.660] - state: ‘finished’
[10:26:11.660] - run: TRUE
[10:26:11.660] - result: ‘FutureResult’
[10:26:11.660] resolved() for ‘SequentialFuture’ ... done
[10:26:11.660] A SequentialFuture was resolved
[10:26:11.660]  length: 0 (resolved future 1)
[10:26:11.660] resolve() on list ... DONE
[10:26:11.660] - globals: [1] ‘a’
[10:26:11.661] Resolving futures part of globals (recursively) ... DONE
[10:26:11.662] The total size of the 1 globals is 1.54 MiB (1615912 bytes)
[10:26:11.663] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.54 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.54 MiB of class ‘environment’)
[10:26:11.663] - globals: [1] ‘a’
[10:26:11.663] - packages: [1] ‘future’
[10:26:11.663] getGlobalsAndPackages() ... DONE
[10:26:11.663] run() for ‘Future’ ...
[10:26:11.663] - state: ‘created’
[10:26:11.663] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.664] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.664] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.664]   - Field: ‘label’
[10:26:11.664]   - Field: ‘local’
[10:26:11.664]   - Field: ‘owner’
[10:26:11.664]   - Field: ‘envir’
[10:26:11.664]   - Field: ‘packages’
[10:26:11.664]   - Field: ‘gc’
[10:26:11.665]   - Field: ‘conditions’
[10:26:11.665]   - Field: ‘expr’
[10:26:11.665]   - Field: ‘uuid’
[10:26:11.665]   - Field: ‘seed’
[10:26:11.665]   - Field: ‘version’
[10:26:11.665]   - Field: ‘result’
[10:26:11.665]   - Field: ‘asynchronous’
[10:26:11.665]   - Field: ‘calls’
[10:26:11.665]   - Field: ‘globals’
[10:26:11.665]   - Field: ‘stdout’
[10:26:11.665]   - Field: ‘earlySignal’
[10:26:11.666]   - Field: ‘lazy’
[10:26:11.666]   - Field: ‘state’
[10:26:11.666] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.666] - Launch lazy future ...
[10:26:11.666] Packages needed by the future expression (n = 1): ‘future’
[10:26:11.666] Packages needed by future strategies (n = 0): <none>
[10:26:11.667] {
[10:26:11.667]     {
[10:26:11.667]         {
[10:26:11.667]             ...future.startTime <- base::Sys.time()
[10:26:11.667]             {
[10:26:11.667]                 {
[10:26:11.667]                   {
[10:26:11.667]                     {
[10:26:11.667]                       base::local({
[10:26:11.667]                         has_future <- base::requireNamespace("future", 
[10:26:11.667]                           quietly = TRUE)
[10:26:11.667]                         if (has_future) {
[10:26:11.667]                           ns <- base::getNamespace("future")
[10:26:11.667]                           version <- ns[[".package"]][["version"]]
[10:26:11.667]                           if (is.null(version)) 
[10:26:11.667]                             version <- utils::packageVersion("future")
[10:26:11.667]                         }
[10:26:11.667]                         else {
[10:26:11.667]                           version <- NULL
[10:26:11.667]                         }
[10:26:11.667]                         if (!has_future || version < "1.8.0") {
[10:26:11.667]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.667]                             "", base::R.version$version.string), 
[10:26:11.667]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:11.667]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.667]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.667]                               "release", "version")], collapse = " "), 
[10:26:11.667]                             hostname = base::Sys.info()[["nodename"]])
[10:26:11.667]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.667]                             info)
[10:26:11.667]                           info <- base::paste(info, collapse = "; ")
[10:26:11.667]                           if (!has_future) {
[10:26:11.667]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.667]                               info)
[10:26:11.667]                           }
[10:26:11.667]                           else {
[10:26:11.667]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.667]                               info, version)
[10:26:11.667]                           }
[10:26:11.667]                           base::stop(msg)
[10:26:11.667]                         }
[10:26:11.667]                       })
[10:26:11.667]                     }
[10:26:11.667]                     base::local({
[10:26:11.667]                       for (pkg in "future") {
[10:26:11.667]                         base::loadNamespace(pkg)
[10:26:11.667]                         base::library(pkg, character.only = TRUE)
[10:26:11.667]                       }
[10:26:11.667]                     })
[10:26:11.667]                   }
[10:26:11.667]                   options(future.plan = NULL)
[10:26:11.667]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.667]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.667]                 }
[10:26:11.667]                 ...future.workdir <- getwd()
[10:26:11.667]             }
[10:26:11.667]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.667]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.667]         }
[10:26:11.667]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.667]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:11.667]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.667]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.667]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.667]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.667]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.667]             base::names(...future.oldOptions))
[10:26:11.667]     }
[10:26:11.667]     if (FALSE) {
[10:26:11.667]     }
[10:26:11.667]     else {
[10:26:11.667]         if (TRUE) {
[10:26:11.667]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.667]                 open = "w")
[10:26:11.667]         }
[10:26:11.667]         else {
[10:26:11.667]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.667]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.667]         }
[10:26:11.667]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.667]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.667]             base::sink(type = "output", split = FALSE)
[10:26:11.667]             base::close(...future.stdout)
[10:26:11.667]         }, add = TRUE)
[10:26:11.667]     }
[10:26:11.667]     ...future.frame <- base::sys.nframe()
[10:26:11.667]     ...future.conditions <- base::list()
[10:26:11.667]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.667]     if (FALSE) {
[10:26:11.667]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.667]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.667]     }
[10:26:11.667]     ...future.result <- base::tryCatch({
[10:26:11.667]         base::withCallingHandlers({
[10:26:11.667]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:26:11.667]                 1))
[10:26:11.667]             future::FutureResult(value = ...future.value$value, 
[10:26:11.667]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.667]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.667]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.667]                     ...future.globalenv.names))
[10:26:11.667]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.667]         }, condition = base::local({
[10:26:11.667]             c <- base::c
[10:26:11.667]             inherits <- base::inherits
[10:26:11.667]             invokeRestart <- base::invokeRestart
[10:26:11.667]             length <- base::length
[10:26:11.667]             list <- base::list
[10:26:11.667]             seq.int <- base::seq.int
[10:26:11.667]             signalCondition <- base::signalCondition
[10:26:11.667]             sys.calls <- base::sys.calls
[10:26:11.667]             `[[` <- base::`[[`
[10:26:11.667]             `+` <- base::`+`
[10:26:11.667]             `<<-` <- base::`<<-`
[10:26:11.667]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.667]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.667]                   3L)]
[10:26:11.667]             }
[10:26:11.667]             function(cond) {
[10:26:11.667]                 is_error <- inherits(cond, "error")
[10:26:11.667]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.667]                   NULL)
[10:26:11.667]                 if (is_error) {
[10:26:11.667]                   sessionInformation <- function() {
[10:26:11.667]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.667]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.667]                       search = base::search(), system = base::Sys.info())
[10:26:11.667]                   }
[10:26:11.667]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.667]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.667]                     cond$call), session = sessionInformation(), 
[10:26:11.667]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.667]                   signalCondition(cond)
[10:26:11.667]                 }
[10:26:11.667]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.667]                 "immediateCondition"))) {
[10:26:11.667]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.667]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.667]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.667]                   if (TRUE && !signal) {
[10:26:11.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.667]                     {
[10:26:11.667]                       inherits <- base::inherits
[10:26:11.667]                       invokeRestart <- base::invokeRestart
[10:26:11.667]                       is.null <- base::is.null
[10:26:11.667]                       muffled <- FALSE
[10:26:11.667]                       if (inherits(cond, "message")) {
[10:26:11.667]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.667]                         if (muffled) 
[10:26:11.667]                           invokeRestart("muffleMessage")
[10:26:11.667]                       }
[10:26:11.667]                       else if (inherits(cond, "warning")) {
[10:26:11.667]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.667]                         if (muffled) 
[10:26:11.667]                           invokeRestart("muffleWarning")
[10:26:11.667]                       }
[10:26:11.667]                       else if (inherits(cond, "condition")) {
[10:26:11.667]                         if (!is.null(pattern)) {
[10:26:11.667]                           computeRestarts <- base::computeRestarts
[10:26:11.667]                           grepl <- base::grepl
[10:26:11.667]                           restarts <- computeRestarts(cond)
[10:26:11.667]                           for (restart in restarts) {
[10:26:11.667]                             name <- restart$name
[10:26:11.667]                             if (is.null(name)) 
[10:26:11.667]                               next
[10:26:11.667]                             if (!grepl(pattern, name)) 
[10:26:11.667]                               next
[10:26:11.667]                             invokeRestart(restart)
[10:26:11.667]                             muffled <- TRUE
[10:26:11.667]                             break
[10:26:11.667]                           }
[10:26:11.667]                         }
[10:26:11.667]                       }
[10:26:11.667]                       invisible(muffled)
[10:26:11.667]                     }
[10:26:11.667]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.667]                   }
[10:26:11.667]                 }
[10:26:11.667]                 else {
[10:26:11.667]                   if (TRUE) {
[10:26:11.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.667]                     {
[10:26:11.667]                       inherits <- base::inherits
[10:26:11.667]                       invokeRestart <- base::invokeRestart
[10:26:11.667]                       is.null <- base::is.null
[10:26:11.667]                       muffled <- FALSE
[10:26:11.667]                       if (inherits(cond, "message")) {
[10:26:11.667]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.667]                         if (muffled) 
[10:26:11.667]                           invokeRestart("muffleMessage")
[10:26:11.667]                       }
[10:26:11.667]                       else if (inherits(cond, "warning")) {
[10:26:11.667]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.667]                         if (muffled) 
[10:26:11.667]                           invokeRestart("muffleWarning")
[10:26:11.667]                       }
[10:26:11.667]                       else if (inherits(cond, "condition")) {
[10:26:11.667]                         if (!is.null(pattern)) {
[10:26:11.667]                           computeRestarts <- base::computeRestarts
[10:26:11.667]                           grepl <- base::grepl
[10:26:11.667]                           restarts <- computeRestarts(cond)
[10:26:11.667]                           for (restart in restarts) {
[10:26:11.667]                             name <- restart$name
[10:26:11.667]                             if (is.null(name)) 
[10:26:11.667]                               next
[10:26:11.667]                             if (!grepl(pattern, name)) 
[10:26:11.667]                               next
[10:26:11.667]                             invokeRestart(restart)
[10:26:11.667]                             muffled <- TRUE
[10:26:11.667]                             break
[10:26:11.667]                           }
[10:26:11.667]                         }
[10:26:11.667]                       }
[10:26:11.667]                       invisible(muffled)
[10:26:11.667]                     }
[10:26:11.667]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.667]                   }
[10:26:11.667]                 }
[10:26:11.667]             }
[10:26:11.667]         }))
[10:26:11.667]     }, error = function(ex) {
[10:26:11.667]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.667]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.667]                 ...future.rng), started = ...future.startTime, 
[10:26:11.667]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.667]             version = "1.8"), class = "FutureResult")
[10:26:11.667]     }, finally = {
[10:26:11.667]         if (!identical(...future.workdir, getwd())) 
[10:26:11.667]             setwd(...future.workdir)
[10:26:11.667]         {
[10:26:11.667]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.667]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.667]             }
[10:26:11.667]             base::options(...future.oldOptions)
[10:26:11.667]             if (.Platform$OS.type == "windows") {
[10:26:11.667]                 old_names <- names(...future.oldEnvVars)
[10:26:11.667]                 envs <- base::Sys.getenv()
[10:26:11.667]                 names <- names(envs)
[10:26:11.667]                 common <- intersect(names, old_names)
[10:26:11.667]                 added <- setdiff(names, old_names)
[10:26:11.667]                 removed <- setdiff(old_names, names)
[10:26:11.667]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.667]                   envs[common]]
[10:26:11.667]                 NAMES <- toupper(changed)
[10:26:11.667]                 args <- list()
[10:26:11.667]                 for (kk in seq_along(NAMES)) {
[10:26:11.667]                   name <- changed[[kk]]
[10:26:11.667]                   NAME <- NAMES[[kk]]
[10:26:11.667]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.667]                     next
[10:26:11.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.667]                 }
[10:26:11.667]                 NAMES <- toupper(added)
[10:26:11.667]                 for (kk in seq_along(NAMES)) {
[10:26:11.667]                   name <- added[[kk]]
[10:26:11.667]                   NAME <- NAMES[[kk]]
[10:26:11.667]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.667]                     next
[10:26:11.667]                   args[[name]] <- ""
[10:26:11.667]                 }
[10:26:11.667]                 NAMES <- toupper(removed)
[10:26:11.667]                 for (kk in seq_along(NAMES)) {
[10:26:11.667]                   name <- removed[[kk]]
[10:26:11.667]                   NAME <- NAMES[[kk]]
[10:26:11.667]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.667]                     next
[10:26:11.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.667]                 }
[10:26:11.667]                 if (length(args) > 0) 
[10:26:11.667]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.667]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.667]             }
[10:26:11.667]             else {
[10:26:11.667]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.667]             }
[10:26:11.667]             {
[10:26:11.667]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.667]                   0L) {
[10:26:11.667]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.667]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.667]                   base::options(opts)
[10:26:11.667]                 }
[10:26:11.667]                 {
[10:26:11.667]                   {
[10:26:11.667]                     NULL
[10:26:11.667]                     RNGkind("Mersenne-Twister")
[10:26:11.667]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.667]                       inherits = FALSE)
[10:26:11.667]                   }
[10:26:11.667]                   options(future.plan = NULL)
[10:26:11.667]                   if (is.na(NA_character_)) 
[10:26:11.667]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.667]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.667]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.667]                   {
[10:26:11.667]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.667]                     if (!future$lazy) 
[10:26:11.667]                       future <- run(future)
[10:26:11.667]                     invisible(future)
[10:26:11.667]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.667]                 }
[10:26:11.667]             }
[10:26:11.667]         }
[10:26:11.667]     })
[10:26:11.667]     if (TRUE) {
[10:26:11.667]         base::sink(type = "output", split = FALSE)
[10:26:11.667]         if (TRUE) {
[10:26:11.667]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.667]         }
[10:26:11.667]         else {
[10:26:11.667]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.667]         }
[10:26:11.667]         base::close(...future.stdout)
[10:26:11.667]         ...future.stdout <- NULL
[10:26:11.667]     }
[10:26:11.667]     ...future.result$conditions <- ...future.conditions
[10:26:11.667]     ...future.result$finished <- base::Sys.time()
[10:26:11.667]     ...future.result
[10:26:11.667] }
[10:26:11.668] assign_globals() ...
[10:26:11.668] List of 1
[10:26:11.668]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a0222aadf8> 
[10:26:11.668]  - attr(*, "where")=List of 1
[10:26:11.668]   ..$ a:<environment: R_EmptyEnv> 
[10:26:11.668]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.668]  - attr(*, "resolved")= logi TRUE
[10:26:11.668]  - attr(*, "total_size")= num 1615912
[10:26:11.668]  - attr(*, "already-done")= logi TRUE
[10:26:11.671] - copied ‘a’ to environment
[10:26:11.671] assign_globals() ... done
[10:26:11.671] plan(): Setting new future strategy stack:
[10:26:11.671] List of future strategies:
[10:26:11.671] 1. sequential:
[10:26:11.671]    - args: function (..., envir = parent.frame())
[10:26:11.671]    - tweaked: FALSE
[10:26:11.671]    - call: NULL
[10:26:11.672] plan(): nbrOfWorkers() = 1
[10:26:11.672] plan(): Setting new future strategy stack:
[10:26:11.673] List of future strategies:
[10:26:11.673] 1. sequential:
[10:26:11.673]    - args: function (..., envir = parent.frame())
[10:26:11.673]    - tweaked: FALSE
[10:26:11.673]    - call: plan(strategy)
[10:26:11.673] plan(): nbrOfWorkers() = 1
[10:26:11.673] SequentialFuture started (and completed)
[10:26:11.673] - Launch lazy future ... done
[10:26:11.673] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.674] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.674] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:11.674] 
[10:26:11.674] Searching for globals ... DONE
[10:26:11.674] - globals: [0] <none>
[10:26:11.674] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.675] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.675] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:11.676] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:11.676] Searching for globals ... DONE
[10:26:11.676] Resolving globals: TRUE
[10:26:11.676] Resolving any globals that are futures ...
[10:26:11.676] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:11.676] Resolving any globals that are futures ... DONE
[10:26:11.676] Resolving futures part of globals (recursively) ...
[10:26:11.677] resolve() on list ...
[10:26:11.677]  recursive: 99
[10:26:11.677]  length: 1
[10:26:11.677]  elements: ‘a’
[10:26:11.677] run() for ‘Future’ ...
[10:26:11.677] - state: ‘created’
[10:26:11.677] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.677] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.678] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.678]   - Field: ‘label’
[10:26:11.678]   - Field: ‘local’
[10:26:11.678]   - Field: ‘owner’
[10:26:11.678]   - Field: ‘envir’
[10:26:11.678]   - Field: ‘packages’
[10:26:11.678]   - Field: ‘gc’
[10:26:11.678]   - Field: ‘conditions’
[10:26:11.678]   - Field: ‘expr’
[10:26:11.678]   - Field: ‘uuid’
[10:26:11.679]   - Field: ‘seed’
[10:26:11.679]   - Field: ‘version’
[10:26:11.679]   - Field: ‘result’
[10:26:11.679]   - Field: ‘asynchronous’
[10:26:11.679]   - Field: ‘calls’
[10:26:11.679]   - Field: ‘globals’
[10:26:11.679]   - Field: ‘stdout’
[10:26:11.679]   - Field: ‘earlySignal’
[10:26:11.679]   - Field: ‘lazy’
[10:26:11.679]   - Field: ‘state’
[10:26:11.679] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.680] - Launch lazy future ...
[10:26:11.680] Packages needed by the future expression (n = 0): <none>
[10:26:11.680] Packages needed by future strategies (n = 0): <none>
[10:26:11.680] {
[10:26:11.680]     {
[10:26:11.680]         {
[10:26:11.680]             ...future.startTime <- base::Sys.time()
[10:26:11.680]             {
[10:26:11.680]                 {
[10:26:11.680]                   {
[10:26:11.680]                     base::local({
[10:26:11.680]                       has_future <- base::requireNamespace("future", 
[10:26:11.680]                         quietly = TRUE)
[10:26:11.680]                       if (has_future) {
[10:26:11.680]                         ns <- base::getNamespace("future")
[10:26:11.680]                         version <- ns[[".package"]][["version"]]
[10:26:11.680]                         if (is.null(version)) 
[10:26:11.680]                           version <- utils::packageVersion("future")
[10:26:11.680]                       }
[10:26:11.680]                       else {
[10:26:11.680]                         version <- NULL
[10:26:11.680]                       }
[10:26:11.680]                       if (!has_future || version < "1.8.0") {
[10:26:11.680]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.680]                           "", base::R.version$version.string), 
[10:26:11.680]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.680]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.680]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.680]                             "release", "version")], collapse = " "), 
[10:26:11.680]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.680]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.680]                           info)
[10:26:11.680]                         info <- base::paste(info, collapse = "; ")
[10:26:11.680]                         if (!has_future) {
[10:26:11.680]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.680]                             info)
[10:26:11.680]                         }
[10:26:11.680]                         else {
[10:26:11.680]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.680]                             info, version)
[10:26:11.680]                         }
[10:26:11.680]                         base::stop(msg)
[10:26:11.680]                       }
[10:26:11.680]                     })
[10:26:11.680]                   }
[10:26:11.680]                   options(future.plan = NULL)
[10:26:11.680]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.680]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.680]                 }
[10:26:11.680]                 ...future.workdir <- getwd()
[10:26:11.680]             }
[10:26:11.680]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.680]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.680]         }
[10:26:11.680]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.680]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:11.680]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.680]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.680]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.680]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.680]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.680]             base::names(...future.oldOptions))
[10:26:11.680]     }
[10:26:11.680]     if (FALSE) {
[10:26:11.680]     }
[10:26:11.680]     else {
[10:26:11.680]         if (TRUE) {
[10:26:11.680]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.680]                 open = "w")
[10:26:11.680]         }
[10:26:11.680]         else {
[10:26:11.680]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.680]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.680]         }
[10:26:11.680]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.680]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.680]             base::sink(type = "output", split = FALSE)
[10:26:11.680]             base::close(...future.stdout)
[10:26:11.680]         }, add = TRUE)
[10:26:11.680]     }
[10:26:11.680]     ...future.frame <- base::sys.nframe()
[10:26:11.680]     ...future.conditions <- base::list()
[10:26:11.680]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.680]     if (FALSE) {
[10:26:11.680]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.680]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.680]     }
[10:26:11.680]     ...future.result <- base::tryCatch({
[10:26:11.680]         base::withCallingHandlers({
[10:26:11.680]             ...future.value <- base::withVisible(base::local(1))
[10:26:11.680]             future::FutureResult(value = ...future.value$value, 
[10:26:11.680]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.680]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.680]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.680]                     ...future.globalenv.names))
[10:26:11.680]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.680]         }, condition = base::local({
[10:26:11.680]             c <- base::c
[10:26:11.680]             inherits <- base::inherits
[10:26:11.680]             invokeRestart <- base::invokeRestart
[10:26:11.680]             length <- base::length
[10:26:11.680]             list <- base::list
[10:26:11.680]             seq.int <- base::seq.int
[10:26:11.680]             signalCondition <- base::signalCondition
[10:26:11.680]             sys.calls <- base::sys.calls
[10:26:11.680]             `[[` <- base::`[[`
[10:26:11.680]             `+` <- base::`+`
[10:26:11.680]             `<<-` <- base::`<<-`
[10:26:11.680]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.680]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.680]                   3L)]
[10:26:11.680]             }
[10:26:11.680]             function(cond) {
[10:26:11.680]                 is_error <- inherits(cond, "error")
[10:26:11.680]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.680]                   NULL)
[10:26:11.680]                 if (is_error) {
[10:26:11.680]                   sessionInformation <- function() {
[10:26:11.680]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.680]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.680]                       search = base::search(), system = base::Sys.info())
[10:26:11.680]                   }
[10:26:11.680]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.680]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.680]                     cond$call), session = sessionInformation(), 
[10:26:11.680]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.680]                   signalCondition(cond)
[10:26:11.680]                 }
[10:26:11.680]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.680]                 "immediateCondition"))) {
[10:26:11.680]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.680]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.680]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.680]                   if (TRUE && !signal) {
[10:26:11.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.680]                     {
[10:26:11.680]                       inherits <- base::inherits
[10:26:11.680]                       invokeRestart <- base::invokeRestart
[10:26:11.680]                       is.null <- base::is.null
[10:26:11.680]                       muffled <- FALSE
[10:26:11.680]                       if (inherits(cond, "message")) {
[10:26:11.680]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.680]                         if (muffled) 
[10:26:11.680]                           invokeRestart("muffleMessage")
[10:26:11.680]                       }
[10:26:11.680]                       else if (inherits(cond, "warning")) {
[10:26:11.680]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.680]                         if (muffled) 
[10:26:11.680]                           invokeRestart("muffleWarning")
[10:26:11.680]                       }
[10:26:11.680]                       else if (inherits(cond, "condition")) {
[10:26:11.680]                         if (!is.null(pattern)) {
[10:26:11.680]                           computeRestarts <- base::computeRestarts
[10:26:11.680]                           grepl <- base::grepl
[10:26:11.680]                           restarts <- computeRestarts(cond)
[10:26:11.680]                           for (restart in restarts) {
[10:26:11.680]                             name <- restart$name
[10:26:11.680]                             if (is.null(name)) 
[10:26:11.680]                               next
[10:26:11.680]                             if (!grepl(pattern, name)) 
[10:26:11.680]                               next
[10:26:11.680]                             invokeRestart(restart)
[10:26:11.680]                             muffled <- TRUE
[10:26:11.680]                             break
[10:26:11.680]                           }
[10:26:11.680]                         }
[10:26:11.680]                       }
[10:26:11.680]                       invisible(muffled)
[10:26:11.680]                     }
[10:26:11.680]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.680]                   }
[10:26:11.680]                 }
[10:26:11.680]                 else {
[10:26:11.680]                   if (TRUE) {
[10:26:11.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.680]                     {
[10:26:11.680]                       inherits <- base::inherits
[10:26:11.680]                       invokeRestart <- base::invokeRestart
[10:26:11.680]                       is.null <- base::is.null
[10:26:11.680]                       muffled <- FALSE
[10:26:11.680]                       if (inherits(cond, "message")) {
[10:26:11.680]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.680]                         if (muffled) 
[10:26:11.680]                           invokeRestart("muffleMessage")
[10:26:11.680]                       }
[10:26:11.680]                       else if (inherits(cond, "warning")) {
[10:26:11.680]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.680]                         if (muffled) 
[10:26:11.680]                           invokeRestart("muffleWarning")
[10:26:11.680]                       }
[10:26:11.680]                       else if (inherits(cond, "condition")) {
[10:26:11.680]                         if (!is.null(pattern)) {
[10:26:11.680]                           computeRestarts <- base::computeRestarts
[10:26:11.680]                           grepl <- base::grepl
[10:26:11.680]                           restarts <- computeRestarts(cond)
[10:26:11.680]                           for (restart in restarts) {
[10:26:11.680]                             name <- restart$name
[10:26:11.680]                             if (is.null(name)) 
[10:26:11.680]                               next
[10:26:11.680]                             if (!grepl(pattern, name)) 
[10:26:11.680]                               next
[10:26:11.680]                             invokeRestart(restart)
[10:26:11.680]                             muffled <- TRUE
[10:26:11.680]                             break
[10:26:11.680]                           }
[10:26:11.680]                         }
[10:26:11.680]                       }
[10:26:11.680]                       invisible(muffled)
[10:26:11.680]                     }
[10:26:11.680]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.680]                   }
[10:26:11.680]                 }
[10:26:11.680]             }
[10:26:11.680]         }))
[10:26:11.680]     }, error = function(ex) {
[10:26:11.680]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.680]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.680]                 ...future.rng), started = ...future.startTime, 
[10:26:11.680]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.680]             version = "1.8"), class = "FutureResult")
[10:26:11.680]     }, finally = {
[10:26:11.680]         if (!identical(...future.workdir, getwd())) 
[10:26:11.680]             setwd(...future.workdir)
[10:26:11.680]         {
[10:26:11.680]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.680]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.680]             }
[10:26:11.680]             base::options(...future.oldOptions)
[10:26:11.680]             if (.Platform$OS.type == "windows") {
[10:26:11.680]                 old_names <- names(...future.oldEnvVars)
[10:26:11.680]                 envs <- base::Sys.getenv()
[10:26:11.680]                 names <- names(envs)
[10:26:11.680]                 common <- intersect(names, old_names)
[10:26:11.680]                 added <- setdiff(names, old_names)
[10:26:11.680]                 removed <- setdiff(old_names, names)
[10:26:11.680]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.680]                   envs[common]]
[10:26:11.680]                 NAMES <- toupper(changed)
[10:26:11.680]                 args <- list()
[10:26:11.680]                 for (kk in seq_along(NAMES)) {
[10:26:11.680]                   name <- changed[[kk]]
[10:26:11.680]                   NAME <- NAMES[[kk]]
[10:26:11.680]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.680]                     next
[10:26:11.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.680]                 }
[10:26:11.680]                 NAMES <- toupper(added)
[10:26:11.680]                 for (kk in seq_along(NAMES)) {
[10:26:11.680]                   name <- added[[kk]]
[10:26:11.680]                   NAME <- NAMES[[kk]]
[10:26:11.680]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.680]                     next
[10:26:11.680]                   args[[name]] <- ""
[10:26:11.680]                 }
[10:26:11.680]                 NAMES <- toupper(removed)
[10:26:11.680]                 for (kk in seq_along(NAMES)) {
[10:26:11.680]                   name <- removed[[kk]]
[10:26:11.680]                   NAME <- NAMES[[kk]]
[10:26:11.680]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.680]                     next
[10:26:11.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.680]                 }
[10:26:11.680]                 if (length(args) > 0) 
[10:26:11.680]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.680]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.680]             }
[10:26:11.680]             else {
[10:26:11.680]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.680]             }
[10:26:11.680]             {
[10:26:11.680]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.680]                   0L) {
[10:26:11.680]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.680]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.680]                   base::options(opts)
[10:26:11.680]                 }
[10:26:11.680]                 {
[10:26:11.680]                   {
[10:26:11.680]                     NULL
[10:26:11.680]                     RNGkind("Mersenne-Twister")
[10:26:11.680]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.680]                       inherits = FALSE)
[10:26:11.680]                   }
[10:26:11.680]                   options(future.plan = NULL)
[10:26:11.680]                   if (is.na(NA_character_)) 
[10:26:11.680]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.680]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.680]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.680]                   {
[10:26:11.680]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.680]                     if (!future$lazy) 
[10:26:11.680]                       future <- run(future)
[10:26:11.680]                     invisible(future)
[10:26:11.680]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.680]                 }
[10:26:11.680]             }
[10:26:11.680]         }
[10:26:11.680]     })
[10:26:11.680]     if (TRUE) {
[10:26:11.680]         base::sink(type = "output", split = FALSE)
[10:26:11.680]         if (TRUE) {
[10:26:11.680]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.680]         }
[10:26:11.680]         else {
[10:26:11.680]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.680]         }
[10:26:11.680]         base::close(...future.stdout)
[10:26:11.680]         ...future.stdout <- NULL
[10:26:11.680]     }
[10:26:11.680]     ...future.result$conditions <- ...future.conditions
[10:26:11.680]     ...future.result$finished <- base::Sys.time()
[10:26:11.680]     ...future.result
[10:26:11.680] }
[10:26:11.682] plan(): Setting new future strategy stack:
[10:26:11.682] List of future strategies:
[10:26:11.682] 1. sequential:
[10:26:11.682]    - args: function (..., envir = parent.frame())
[10:26:11.682]    - tweaked: FALSE
[10:26:11.682]    - call: NULL
[10:26:11.682] plan(): nbrOfWorkers() = 1
[10:26:11.684] plan(): Setting new future strategy stack:
[10:26:11.684] List of future strategies:
[10:26:11.684] 1. sequential:
[10:26:11.684]    - args: function (..., envir = parent.frame())
[10:26:11.684]    - tweaked: FALSE
[10:26:11.684]    - call: plan(strategy)
[10:26:11.684] plan(): nbrOfWorkers() = 1
[10:26:11.685] SequentialFuture started (and completed)
[10:26:11.685] - Launch lazy future ... done
[10:26:11.685] run() for ‘SequentialFuture’ ... done
[10:26:11.685] resolved() for ‘SequentialFuture’ ...
[10:26:11.685] - state: ‘finished’
[10:26:11.685] - run: TRUE
[10:26:11.685] - result: ‘FutureResult’
[10:26:11.685] resolved() for ‘SequentialFuture’ ... done
[10:26:11.685] Future #1
[10:26:11.686] resolved() for ‘SequentialFuture’ ...
[10:26:11.686] - state: ‘finished’
[10:26:11.686] - run: TRUE
[10:26:11.686] - result: ‘FutureResult’
[10:26:11.686] resolved() for ‘SequentialFuture’ ... done
[10:26:11.686] A SequentialFuture was resolved
[10:26:11.686]  length: 0 (resolved future 1)
[10:26:11.686] resolve() on list ... DONE
[10:26:11.686] - globals: [1] ‘a’
[10:26:11.686] Resolving futures part of globals (recursively) ... DONE
[10:26:11.688] The total size of the 1 globals is 1.54 MiB (1616080 bytes)
[10:26:11.688] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.54 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.54 MiB of class ‘environment’)
[10:26:11.689] - globals: [1] ‘a’
[10:26:11.689] - packages: [1] ‘future’
[10:26:11.689] getGlobalsAndPackages() ... DONE
[10:26:11.689] run() for ‘Future’ ...
[10:26:11.689] - state: ‘created’
[10:26:11.689] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.689] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.690] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.690]   - Field: ‘label’
[10:26:11.690]   - Field: ‘local’
[10:26:11.690]   - Field: ‘owner’
[10:26:11.690]   - Field: ‘envir’
[10:26:11.690]   - Field: ‘packages’
[10:26:11.690]   - Field: ‘gc’
[10:26:11.690]   - Field: ‘conditions’
[10:26:11.690]   - Field: ‘expr’
[10:26:11.690]   - Field: ‘uuid’
[10:26:11.690]   - Field: ‘seed’
[10:26:11.691]   - Field: ‘version’
[10:26:11.691]   - Field: ‘result’
[10:26:11.691]   - Field: ‘asynchronous’
[10:26:11.691]   - Field: ‘calls’
[10:26:11.691]   - Field: ‘globals’
[10:26:11.691]   - Field: ‘stdout’
[10:26:11.691]   - Field: ‘earlySignal’
[10:26:11.691]   - Field: ‘lazy’
[10:26:11.691]   - Field: ‘state’
[10:26:11.691] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.691] - Launch lazy future ...
[10:26:11.692] Packages needed by the future expression (n = 1): ‘future’
[10:26:11.692] Packages needed by future strategies (n = 0): <none>
[10:26:11.692] {
[10:26:11.692]     {
[10:26:11.692]         {
[10:26:11.692]             ...future.startTime <- base::Sys.time()
[10:26:11.692]             {
[10:26:11.692]                 {
[10:26:11.692]                   {
[10:26:11.692]                     {
[10:26:11.692]                       base::local({
[10:26:11.692]                         has_future <- base::requireNamespace("future", 
[10:26:11.692]                           quietly = TRUE)
[10:26:11.692]                         if (has_future) {
[10:26:11.692]                           ns <- base::getNamespace("future")
[10:26:11.692]                           version <- ns[[".package"]][["version"]]
[10:26:11.692]                           if (is.null(version)) 
[10:26:11.692]                             version <- utils::packageVersion("future")
[10:26:11.692]                         }
[10:26:11.692]                         else {
[10:26:11.692]                           version <- NULL
[10:26:11.692]                         }
[10:26:11.692]                         if (!has_future || version < "1.8.0") {
[10:26:11.692]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.692]                             "", base::R.version$version.string), 
[10:26:11.692]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:11.692]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.692]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.692]                               "release", "version")], collapse = " "), 
[10:26:11.692]                             hostname = base::Sys.info()[["nodename"]])
[10:26:11.692]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.692]                             info)
[10:26:11.692]                           info <- base::paste(info, collapse = "; ")
[10:26:11.692]                           if (!has_future) {
[10:26:11.692]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.692]                               info)
[10:26:11.692]                           }
[10:26:11.692]                           else {
[10:26:11.692]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.692]                               info, version)
[10:26:11.692]                           }
[10:26:11.692]                           base::stop(msg)
[10:26:11.692]                         }
[10:26:11.692]                       })
[10:26:11.692]                     }
[10:26:11.692]                     base::local({
[10:26:11.692]                       for (pkg in "future") {
[10:26:11.692]                         base::loadNamespace(pkg)
[10:26:11.692]                         base::library(pkg, character.only = TRUE)
[10:26:11.692]                       }
[10:26:11.692]                     })
[10:26:11.692]                   }
[10:26:11.692]                   options(future.plan = NULL)
[10:26:11.692]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.692]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.692]                 }
[10:26:11.692]                 ...future.workdir <- getwd()
[10:26:11.692]             }
[10:26:11.692]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.692]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.692]         }
[10:26:11.692]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.692]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:11.692]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.692]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.692]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.692]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.692]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.692]             base::names(...future.oldOptions))
[10:26:11.692]     }
[10:26:11.692]     if (FALSE) {
[10:26:11.692]     }
[10:26:11.692]     else {
[10:26:11.692]         if (TRUE) {
[10:26:11.692]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.692]                 open = "w")
[10:26:11.692]         }
[10:26:11.692]         else {
[10:26:11.692]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.692]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.692]         }
[10:26:11.692]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.692]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.692]             base::sink(type = "output", split = FALSE)
[10:26:11.692]             base::close(...future.stdout)
[10:26:11.692]         }, add = TRUE)
[10:26:11.692]     }
[10:26:11.692]     ...future.frame <- base::sys.nframe()
[10:26:11.692]     ...future.conditions <- base::list()
[10:26:11.692]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.692]     if (FALSE) {
[10:26:11.692]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.692]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.692]     }
[10:26:11.692]     ...future.result <- base::tryCatch({
[10:26:11.692]         base::withCallingHandlers({
[10:26:11.692]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:26:11.692]                 1))
[10:26:11.692]             future::FutureResult(value = ...future.value$value, 
[10:26:11.692]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.692]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.692]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.692]                     ...future.globalenv.names))
[10:26:11.692]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.692]         }, condition = base::local({
[10:26:11.692]             c <- base::c
[10:26:11.692]             inherits <- base::inherits
[10:26:11.692]             invokeRestart <- base::invokeRestart
[10:26:11.692]             length <- base::length
[10:26:11.692]             list <- base::list
[10:26:11.692]             seq.int <- base::seq.int
[10:26:11.692]             signalCondition <- base::signalCondition
[10:26:11.692]             sys.calls <- base::sys.calls
[10:26:11.692]             `[[` <- base::`[[`
[10:26:11.692]             `+` <- base::`+`
[10:26:11.692]             `<<-` <- base::`<<-`
[10:26:11.692]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.692]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.692]                   3L)]
[10:26:11.692]             }
[10:26:11.692]             function(cond) {
[10:26:11.692]                 is_error <- inherits(cond, "error")
[10:26:11.692]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.692]                   NULL)
[10:26:11.692]                 if (is_error) {
[10:26:11.692]                   sessionInformation <- function() {
[10:26:11.692]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.692]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.692]                       search = base::search(), system = base::Sys.info())
[10:26:11.692]                   }
[10:26:11.692]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.692]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.692]                     cond$call), session = sessionInformation(), 
[10:26:11.692]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.692]                   signalCondition(cond)
[10:26:11.692]                 }
[10:26:11.692]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.692]                 "immediateCondition"))) {
[10:26:11.692]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.692]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.692]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.692]                   if (TRUE && !signal) {
[10:26:11.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.692]                     {
[10:26:11.692]                       inherits <- base::inherits
[10:26:11.692]                       invokeRestart <- base::invokeRestart
[10:26:11.692]                       is.null <- base::is.null
[10:26:11.692]                       muffled <- FALSE
[10:26:11.692]                       if (inherits(cond, "message")) {
[10:26:11.692]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.692]                         if (muffled) 
[10:26:11.692]                           invokeRestart("muffleMessage")
[10:26:11.692]                       }
[10:26:11.692]                       else if (inherits(cond, "warning")) {
[10:26:11.692]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.692]                         if (muffled) 
[10:26:11.692]                           invokeRestart("muffleWarning")
[10:26:11.692]                       }
[10:26:11.692]                       else if (inherits(cond, "condition")) {
[10:26:11.692]                         if (!is.null(pattern)) {
[10:26:11.692]                           computeRestarts <- base::computeRestarts
[10:26:11.692]                           grepl <- base::grepl
[10:26:11.692]                           restarts <- computeRestarts(cond)
[10:26:11.692]                           for (restart in restarts) {
[10:26:11.692]                             name <- restart$name
[10:26:11.692]                             if (is.null(name)) 
[10:26:11.692]                               next
[10:26:11.692]                             if (!grepl(pattern, name)) 
[10:26:11.692]                               next
[10:26:11.692]                             invokeRestart(restart)
[10:26:11.692]                             muffled <- TRUE
[10:26:11.692]                             break
[10:26:11.692]                           }
[10:26:11.692]                         }
[10:26:11.692]                       }
[10:26:11.692]                       invisible(muffled)
[10:26:11.692]                     }
[10:26:11.692]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.692]                   }
[10:26:11.692]                 }
[10:26:11.692]                 else {
[10:26:11.692]                   if (TRUE) {
[10:26:11.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.692]                     {
[10:26:11.692]                       inherits <- base::inherits
[10:26:11.692]                       invokeRestart <- base::invokeRestart
[10:26:11.692]                       is.null <- base::is.null
[10:26:11.692]                       muffled <- FALSE
[10:26:11.692]                       if (inherits(cond, "message")) {
[10:26:11.692]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.692]                         if (muffled) 
[10:26:11.692]                           invokeRestart("muffleMessage")
[10:26:11.692]                       }
[10:26:11.692]                       else if (inherits(cond, "warning")) {
[10:26:11.692]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.692]                         if (muffled) 
[10:26:11.692]                           invokeRestart("muffleWarning")
[10:26:11.692]                       }
[10:26:11.692]                       else if (inherits(cond, "condition")) {
[10:26:11.692]                         if (!is.null(pattern)) {
[10:26:11.692]                           computeRestarts <- base::computeRestarts
[10:26:11.692]                           grepl <- base::grepl
[10:26:11.692]                           restarts <- computeRestarts(cond)
[10:26:11.692]                           for (restart in restarts) {
[10:26:11.692]                             name <- restart$name
[10:26:11.692]                             if (is.null(name)) 
[10:26:11.692]                               next
[10:26:11.692]                             if (!grepl(pattern, name)) 
[10:26:11.692]                               next
[10:26:11.692]                             invokeRestart(restart)
[10:26:11.692]                             muffled <- TRUE
[10:26:11.692]                             break
[10:26:11.692]                           }
[10:26:11.692]                         }
[10:26:11.692]                       }
[10:26:11.692]                       invisible(muffled)
[10:26:11.692]                     }
[10:26:11.692]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.692]                   }
[10:26:11.692]                 }
[10:26:11.692]             }
[10:26:11.692]         }))
[10:26:11.692]     }, error = function(ex) {
[10:26:11.692]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.692]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.692]                 ...future.rng), started = ...future.startTime, 
[10:26:11.692]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.692]             version = "1.8"), class = "FutureResult")
[10:26:11.692]     }, finally = {
[10:26:11.692]         if (!identical(...future.workdir, getwd())) 
[10:26:11.692]             setwd(...future.workdir)
[10:26:11.692]         {
[10:26:11.692]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.692]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.692]             }
[10:26:11.692]             base::options(...future.oldOptions)
[10:26:11.692]             if (.Platform$OS.type == "windows") {
[10:26:11.692]                 old_names <- names(...future.oldEnvVars)
[10:26:11.692]                 envs <- base::Sys.getenv()
[10:26:11.692]                 names <- names(envs)
[10:26:11.692]                 common <- intersect(names, old_names)
[10:26:11.692]                 added <- setdiff(names, old_names)
[10:26:11.692]                 removed <- setdiff(old_names, names)
[10:26:11.692]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.692]                   envs[common]]
[10:26:11.692]                 NAMES <- toupper(changed)
[10:26:11.692]                 args <- list()
[10:26:11.692]                 for (kk in seq_along(NAMES)) {
[10:26:11.692]                   name <- changed[[kk]]
[10:26:11.692]                   NAME <- NAMES[[kk]]
[10:26:11.692]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.692]                     next
[10:26:11.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.692]                 }
[10:26:11.692]                 NAMES <- toupper(added)
[10:26:11.692]                 for (kk in seq_along(NAMES)) {
[10:26:11.692]                   name <- added[[kk]]
[10:26:11.692]                   NAME <- NAMES[[kk]]
[10:26:11.692]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.692]                     next
[10:26:11.692]                   args[[name]] <- ""
[10:26:11.692]                 }
[10:26:11.692]                 NAMES <- toupper(removed)
[10:26:11.692]                 for (kk in seq_along(NAMES)) {
[10:26:11.692]                   name <- removed[[kk]]
[10:26:11.692]                   NAME <- NAMES[[kk]]
[10:26:11.692]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.692]                     next
[10:26:11.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.692]                 }
[10:26:11.692]                 if (length(args) > 0) 
[10:26:11.692]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.692]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.692]             }
[10:26:11.692]             else {
[10:26:11.692]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.692]             }
[10:26:11.692]             {
[10:26:11.692]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.692]                   0L) {
[10:26:11.692]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.692]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.692]                   base::options(opts)
[10:26:11.692]                 }
[10:26:11.692]                 {
[10:26:11.692]                   {
[10:26:11.692]                     NULL
[10:26:11.692]                     RNGkind("Mersenne-Twister")
[10:26:11.692]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.692]                       inherits = FALSE)
[10:26:11.692]                   }
[10:26:11.692]                   options(future.plan = NULL)
[10:26:11.692]                   if (is.na(NA_character_)) 
[10:26:11.692]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.692]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.692]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.692]                   {
[10:26:11.692]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.692]                     if (!future$lazy) 
[10:26:11.692]                       future <- run(future)
[10:26:11.692]                     invisible(future)
[10:26:11.692]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.692]                 }
[10:26:11.692]             }
[10:26:11.692]         }
[10:26:11.692]     })
[10:26:11.692]     if (TRUE) {
[10:26:11.692]         base::sink(type = "output", split = FALSE)
[10:26:11.692]         if (TRUE) {
[10:26:11.692]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.692]         }
[10:26:11.692]         else {
[10:26:11.692]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.692]         }
[10:26:11.692]         base::close(...future.stdout)
[10:26:11.692]         ...future.stdout <- NULL
[10:26:11.692]     }
[10:26:11.692]     ...future.result$conditions <- ...future.conditions
[10:26:11.692]     ...future.result$finished <- base::Sys.time()
[10:26:11.692]     ...future.result
[10:26:11.692] }
[10:26:11.694] assign_globals() ...
[10:26:11.694] List of 1
[10:26:11.694]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a022251228> 
[10:26:11.694]  - attr(*, "where")=List of 1
[10:26:11.694]   ..$ a:<environment: R_EmptyEnv> 
[10:26:11.694]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.694]  - attr(*, "resolved")= logi TRUE
[10:26:11.694]  - attr(*, "total_size")= num 1616080
[10:26:11.694]  - attr(*, "already-done")= logi TRUE
[10:26:11.696] - copied ‘a’ to environment
[10:26:11.696] assign_globals() ... done
[10:26:11.697] plan(): Setting new future strategy stack:
[10:26:11.697] List of future strategies:
[10:26:11.697] 1. sequential:
[10:26:11.697]    - args: function (..., envir = parent.frame())
[10:26:11.697]    - tweaked: FALSE
[10:26:11.697]    - call: NULL
[10:26:11.697] plan(): nbrOfWorkers() = 1
[10:26:11.698] plan(): Setting new future strategy stack:
[10:26:11.698] List of future strategies:
[10:26:11.698] 1. sequential:
[10:26:11.698]    - args: function (..., envir = parent.frame())
[10:26:11.698]    - tweaked: FALSE
[10:26:11.698]    - call: plan(strategy)
[10:26:11.698] plan(): nbrOfWorkers() = 1
[10:26:11.698] SequentialFuture started (and completed)
[10:26:11.698] - Launch lazy future ... done
[10:26:11.698] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.699] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.699] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:11.699] 
[10:26:11.699] Searching for globals ... DONE
[10:26:11.700] - globals: [0] <none>
[10:26:11.700] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.700] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.700] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:11.701] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:11.701] Searching for globals ... DONE
[10:26:11.701] Resolving globals: TRUE
[10:26:11.701] Resolving any globals that are futures ...
[10:26:11.701] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:11.701] Resolving any globals that are futures ... DONE
[10:26:11.702] Resolving futures part of globals (recursively) ...
[10:26:11.702] resolve() on list ...
[10:26:11.702]  recursive: 99
[10:26:11.702]  length: 1
[10:26:11.702]  elements: ‘a’
[10:26:11.702] run() for ‘Future’ ...
[10:26:11.702] - state: ‘created’
[10:26:11.702] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.703] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.703] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.703]   - Field: ‘label’
[10:26:11.703]   - Field: ‘local’
[10:26:11.703]   - Field: ‘owner’
[10:26:11.703]   - Field: ‘envir’
[10:26:11.703]   - Field: ‘packages’
[10:26:11.703]   - Field: ‘gc’
[10:26:11.703]   - Field: ‘conditions’
[10:26:11.703]   - Field: ‘expr’
[10:26:11.704]   - Field: ‘uuid’
[10:26:11.704]   - Field: ‘seed’
[10:26:11.704]   - Field: ‘version’
[10:26:11.704]   - Field: ‘result’
[10:26:11.704]   - Field: ‘asynchronous’
[10:26:11.704]   - Field: ‘calls’
[10:26:11.704]   - Field: ‘globals’
[10:26:11.704]   - Field: ‘stdout’
[10:26:11.704]   - Field: ‘earlySignal’
[10:26:11.704]   - Field: ‘lazy’
[10:26:11.704]   - Field: ‘state’
[10:26:11.704] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.705] - Launch lazy future ...
[10:26:11.705] Packages needed by the future expression (n = 0): <none>
[10:26:11.705] Packages needed by future strategies (n = 0): <none>
[10:26:11.705] {
[10:26:11.705]     {
[10:26:11.705]         {
[10:26:11.705]             ...future.startTime <- base::Sys.time()
[10:26:11.705]             {
[10:26:11.705]                 {
[10:26:11.705]                   {
[10:26:11.705]                     base::local({
[10:26:11.705]                       has_future <- base::requireNamespace("future", 
[10:26:11.705]                         quietly = TRUE)
[10:26:11.705]                       if (has_future) {
[10:26:11.705]                         ns <- base::getNamespace("future")
[10:26:11.705]                         version <- ns[[".package"]][["version"]]
[10:26:11.705]                         if (is.null(version)) 
[10:26:11.705]                           version <- utils::packageVersion("future")
[10:26:11.705]                       }
[10:26:11.705]                       else {
[10:26:11.705]                         version <- NULL
[10:26:11.705]                       }
[10:26:11.705]                       if (!has_future || version < "1.8.0") {
[10:26:11.705]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.705]                           "", base::R.version$version.string), 
[10:26:11.705]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.705]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.705]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.705]                             "release", "version")], collapse = " "), 
[10:26:11.705]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.705]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.705]                           info)
[10:26:11.705]                         info <- base::paste(info, collapse = "; ")
[10:26:11.705]                         if (!has_future) {
[10:26:11.705]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.705]                             info)
[10:26:11.705]                         }
[10:26:11.705]                         else {
[10:26:11.705]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.705]                             info, version)
[10:26:11.705]                         }
[10:26:11.705]                         base::stop(msg)
[10:26:11.705]                       }
[10:26:11.705]                     })
[10:26:11.705]                   }
[10:26:11.705]                   options(future.plan = NULL)
[10:26:11.705]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.705]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.705]                 }
[10:26:11.705]                 ...future.workdir <- getwd()
[10:26:11.705]             }
[10:26:11.705]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.705]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.705]         }
[10:26:11.705]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.705]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:11.705]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.705]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.705]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.705]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.705]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.705]             base::names(...future.oldOptions))
[10:26:11.705]     }
[10:26:11.705]     if (FALSE) {
[10:26:11.705]     }
[10:26:11.705]     else {
[10:26:11.705]         if (TRUE) {
[10:26:11.705]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.705]                 open = "w")
[10:26:11.705]         }
[10:26:11.705]         else {
[10:26:11.705]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.705]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.705]         }
[10:26:11.705]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.705]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.705]             base::sink(type = "output", split = FALSE)
[10:26:11.705]             base::close(...future.stdout)
[10:26:11.705]         }, add = TRUE)
[10:26:11.705]     }
[10:26:11.705]     ...future.frame <- base::sys.nframe()
[10:26:11.705]     ...future.conditions <- base::list()
[10:26:11.705]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.705]     if (FALSE) {
[10:26:11.705]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.705]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.705]     }
[10:26:11.705]     ...future.result <- base::tryCatch({
[10:26:11.705]         base::withCallingHandlers({
[10:26:11.705]             ...future.value <- base::withVisible(base::local(1))
[10:26:11.705]             future::FutureResult(value = ...future.value$value, 
[10:26:11.705]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.705]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.705]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.705]                     ...future.globalenv.names))
[10:26:11.705]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.705]         }, condition = base::local({
[10:26:11.705]             c <- base::c
[10:26:11.705]             inherits <- base::inherits
[10:26:11.705]             invokeRestart <- base::invokeRestart
[10:26:11.705]             length <- base::length
[10:26:11.705]             list <- base::list
[10:26:11.705]             seq.int <- base::seq.int
[10:26:11.705]             signalCondition <- base::signalCondition
[10:26:11.705]             sys.calls <- base::sys.calls
[10:26:11.705]             `[[` <- base::`[[`
[10:26:11.705]             `+` <- base::`+`
[10:26:11.705]             `<<-` <- base::`<<-`
[10:26:11.705]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.705]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.705]                   3L)]
[10:26:11.705]             }
[10:26:11.705]             function(cond) {
[10:26:11.705]                 is_error <- inherits(cond, "error")
[10:26:11.705]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.705]                   NULL)
[10:26:11.705]                 if (is_error) {
[10:26:11.705]                   sessionInformation <- function() {
[10:26:11.705]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.705]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.705]                       search = base::search(), system = base::Sys.info())
[10:26:11.705]                   }
[10:26:11.705]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.705]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.705]                     cond$call), session = sessionInformation(), 
[10:26:11.705]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.705]                   signalCondition(cond)
[10:26:11.705]                 }
[10:26:11.705]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.705]                 "immediateCondition"))) {
[10:26:11.705]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.705]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.705]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.705]                   if (TRUE && !signal) {
[10:26:11.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.705]                     {
[10:26:11.705]                       inherits <- base::inherits
[10:26:11.705]                       invokeRestart <- base::invokeRestart
[10:26:11.705]                       is.null <- base::is.null
[10:26:11.705]                       muffled <- FALSE
[10:26:11.705]                       if (inherits(cond, "message")) {
[10:26:11.705]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.705]                         if (muffled) 
[10:26:11.705]                           invokeRestart("muffleMessage")
[10:26:11.705]                       }
[10:26:11.705]                       else if (inherits(cond, "warning")) {
[10:26:11.705]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.705]                         if (muffled) 
[10:26:11.705]                           invokeRestart("muffleWarning")
[10:26:11.705]                       }
[10:26:11.705]                       else if (inherits(cond, "condition")) {
[10:26:11.705]                         if (!is.null(pattern)) {
[10:26:11.705]                           computeRestarts <- base::computeRestarts
[10:26:11.705]                           grepl <- base::grepl
[10:26:11.705]                           restarts <- computeRestarts(cond)
[10:26:11.705]                           for (restart in restarts) {
[10:26:11.705]                             name <- restart$name
[10:26:11.705]                             if (is.null(name)) 
[10:26:11.705]                               next
[10:26:11.705]                             if (!grepl(pattern, name)) 
[10:26:11.705]                               next
[10:26:11.705]                             invokeRestart(restart)
[10:26:11.705]                             muffled <- TRUE
[10:26:11.705]                             break
[10:26:11.705]                           }
[10:26:11.705]                         }
[10:26:11.705]                       }
[10:26:11.705]                       invisible(muffled)
[10:26:11.705]                     }
[10:26:11.705]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.705]                   }
[10:26:11.705]                 }
[10:26:11.705]                 else {
[10:26:11.705]                   if (TRUE) {
[10:26:11.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.705]                     {
[10:26:11.705]                       inherits <- base::inherits
[10:26:11.705]                       invokeRestart <- base::invokeRestart
[10:26:11.705]                       is.null <- base::is.null
[10:26:11.705]                       muffled <- FALSE
[10:26:11.705]                       if (inherits(cond, "message")) {
[10:26:11.705]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.705]                         if (muffled) 
[10:26:11.705]                           invokeRestart("muffleMessage")
[10:26:11.705]                       }
[10:26:11.705]                       else if (inherits(cond, "warning")) {
[10:26:11.705]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.705]                         if (muffled) 
[10:26:11.705]                           invokeRestart("muffleWarning")
[10:26:11.705]                       }
[10:26:11.705]                       else if (inherits(cond, "condition")) {
[10:26:11.705]                         if (!is.null(pattern)) {
[10:26:11.705]                           computeRestarts <- base::computeRestarts
[10:26:11.705]                           grepl <- base::grepl
[10:26:11.705]                           restarts <- computeRestarts(cond)
[10:26:11.705]                           for (restart in restarts) {
[10:26:11.705]                             name <- restart$name
[10:26:11.705]                             if (is.null(name)) 
[10:26:11.705]                               next
[10:26:11.705]                             if (!grepl(pattern, name)) 
[10:26:11.705]                               next
[10:26:11.705]                             invokeRestart(restart)
[10:26:11.705]                             muffled <- TRUE
[10:26:11.705]                             break
[10:26:11.705]                           }
[10:26:11.705]                         }
[10:26:11.705]                       }
[10:26:11.705]                       invisible(muffled)
[10:26:11.705]                     }
[10:26:11.705]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.705]                   }
[10:26:11.705]                 }
[10:26:11.705]             }
[10:26:11.705]         }))
[10:26:11.705]     }, error = function(ex) {
[10:26:11.705]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.705]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.705]                 ...future.rng), started = ...future.startTime, 
[10:26:11.705]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.705]             version = "1.8"), class = "FutureResult")
[10:26:11.705]     }, finally = {
[10:26:11.705]         if (!identical(...future.workdir, getwd())) 
[10:26:11.705]             setwd(...future.workdir)
[10:26:11.705]         {
[10:26:11.705]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.705]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.705]             }
[10:26:11.705]             base::options(...future.oldOptions)
[10:26:11.705]             if (.Platform$OS.type == "windows") {
[10:26:11.705]                 old_names <- names(...future.oldEnvVars)
[10:26:11.705]                 envs <- base::Sys.getenv()
[10:26:11.705]                 names <- names(envs)
[10:26:11.705]                 common <- intersect(names, old_names)
[10:26:11.705]                 added <- setdiff(names, old_names)
[10:26:11.705]                 removed <- setdiff(old_names, names)
[10:26:11.705]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.705]                   envs[common]]
[10:26:11.705]                 NAMES <- toupper(changed)
[10:26:11.705]                 args <- list()
[10:26:11.705]                 for (kk in seq_along(NAMES)) {
[10:26:11.705]                   name <- changed[[kk]]
[10:26:11.705]                   NAME <- NAMES[[kk]]
[10:26:11.705]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.705]                     next
[10:26:11.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.705]                 }
[10:26:11.705]                 NAMES <- toupper(added)
[10:26:11.705]                 for (kk in seq_along(NAMES)) {
[10:26:11.705]                   name <- added[[kk]]
[10:26:11.705]                   NAME <- NAMES[[kk]]
[10:26:11.705]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.705]                     next
[10:26:11.705]                   args[[name]] <- ""
[10:26:11.705]                 }
[10:26:11.705]                 NAMES <- toupper(removed)
[10:26:11.705]                 for (kk in seq_along(NAMES)) {
[10:26:11.705]                   name <- removed[[kk]]
[10:26:11.705]                   NAME <- NAMES[[kk]]
[10:26:11.705]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.705]                     next
[10:26:11.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.705]                 }
[10:26:11.705]                 if (length(args) > 0) 
[10:26:11.705]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.705]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.705]             }
[10:26:11.705]             else {
[10:26:11.705]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.705]             }
[10:26:11.705]             {
[10:26:11.705]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.705]                   0L) {
[10:26:11.705]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.705]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.705]                   base::options(opts)
[10:26:11.705]                 }
[10:26:11.705]                 {
[10:26:11.705]                   {
[10:26:11.705]                     NULL
[10:26:11.705]                     RNGkind("Mersenne-Twister")
[10:26:11.705]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.705]                       inherits = FALSE)
[10:26:11.705]                   }
[10:26:11.705]                   options(future.plan = NULL)
[10:26:11.705]                   if (is.na(NA_character_)) 
[10:26:11.705]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.705]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.705]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.705]                   {
[10:26:11.705]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.705]                     if (!future$lazy) 
[10:26:11.705]                       future <- run(future)
[10:26:11.705]                     invisible(future)
[10:26:11.705]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.705]                 }
[10:26:11.705]             }
[10:26:11.705]         }
[10:26:11.705]     })
[10:26:11.705]     if (TRUE) {
[10:26:11.705]         base::sink(type = "output", split = FALSE)
[10:26:11.705]         if (TRUE) {
[10:26:11.705]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.705]         }
[10:26:11.705]         else {
[10:26:11.705]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.705]         }
[10:26:11.705]         base::close(...future.stdout)
[10:26:11.705]         ...future.stdout <- NULL
[10:26:11.705]     }
[10:26:11.705]     ...future.result$conditions <- ...future.conditions
[10:26:11.705]     ...future.result$finished <- base::Sys.time()
[10:26:11.705]     ...future.result
[10:26:11.705] }
[10:26:11.707] plan(): Setting new future strategy stack:
[10:26:11.707] List of future strategies:
[10:26:11.707] 1. sequential:
[10:26:11.707]    - args: function (..., envir = parent.frame())
[10:26:11.707]    - tweaked: FALSE
[10:26:11.707]    - call: NULL
[10:26:11.707] plan(): nbrOfWorkers() = 1
[10:26:11.708] plan(): Setting new future strategy stack:
[10:26:11.708] List of future strategies:
[10:26:11.708] 1. sequential:
[10:26:11.708]    - args: function (..., envir = parent.frame())
[10:26:11.708]    - tweaked: FALSE
[10:26:11.708]    - call: plan(strategy)
[10:26:11.708] plan(): nbrOfWorkers() = 1
[10:26:11.709] SequentialFuture started (and completed)
[10:26:11.709] - Launch lazy future ... done
[10:26:11.709] run() for ‘SequentialFuture’ ... done
[10:26:11.709] resolved() for ‘SequentialFuture’ ...
[10:26:11.709] - state: ‘finished’
[10:26:11.709] - run: TRUE
[10:26:11.709] - result: ‘FutureResult’
[10:26:11.709] resolved() for ‘SequentialFuture’ ... done
[10:26:11.709] Future #1
[10:26:11.710] resolved() for ‘SequentialFuture’ ...
[10:26:11.711] - state: ‘finished’
[10:26:11.711] - run: TRUE
[10:26:11.711] - result: ‘FutureResult’
[10:26:11.711] resolved() for ‘SequentialFuture’ ... done
[10:26:11.711] A SequentialFuture was resolved
[10:26:11.711]  length: 0 (resolved future 1)
[10:26:11.711] resolve() on list ... DONE
[10:26:11.711] - globals: [1] ‘a’
[10:26:11.711] Resolving futures part of globals (recursively) ... DONE
[10:26:11.713] The total size of the 1 globals is 1.54 MiB (1616080 bytes)
[10:26:11.713] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.54 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.54 MiB of class ‘environment’)
[10:26:11.714] - globals: [1] ‘a’
[10:26:11.714] - packages: [1] ‘future’
[10:26:11.714] getGlobalsAndPackages() ... DONE
[10:26:11.714] run() for ‘Future’ ...
[10:26:11.714] - state: ‘created’
[10:26:11.714] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.714] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.715] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.715]   - Field: ‘label’
[10:26:11.715]   - Field: ‘local’
[10:26:11.715]   - Field: ‘owner’
[10:26:11.715]   - Field: ‘envir’
[10:26:11.715]   - Field: ‘packages’
[10:26:11.715]   - Field: ‘gc’
[10:26:11.715]   - Field: ‘conditions’
[10:26:11.715]   - Field: ‘expr’
[10:26:11.715]   - Field: ‘uuid’
[10:26:11.715]   - Field: ‘seed’
[10:26:11.716]   - Field: ‘version’
[10:26:11.716]   - Field: ‘result’
[10:26:11.716]   - Field: ‘asynchronous’
[10:26:11.716]   - Field: ‘calls’
[10:26:11.716]   - Field: ‘globals’
[10:26:11.716]   - Field: ‘stdout’
[10:26:11.716]   - Field: ‘earlySignal’
[10:26:11.716]   - Field: ‘lazy’
[10:26:11.716]   - Field: ‘state’
[10:26:11.716] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.716] - Launch lazy future ...
[10:26:11.717] Packages needed by the future expression (n = 1): ‘future’
[10:26:11.717] Packages needed by future strategies (n = 0): <none>
[10:26:11.717] {
[10:26:11.717]     {
[10:26:11.717]         {
[10:26:11.717]             ...future.startTime <- base::Sys.time()
[10:26:11.717]             {
[10:26:11.717]                 {
[10:26:11.717]                   {
[10:26:11.717]                     {
[10:26:11.717]                       base::local({
[10:26:11.717]                         has_future <- base::requireNamespace("future", 
[10:26:11.717]                           quietly = TRUE)
[10:26:11.717]                         if (has_future) {
[10:26:11.717]                           ns <- base::getNamespace("future")
[10:26:11.717]                           version <- ns[[".package"]][["version"]]
[10:26:11.717]                           if (is.null(version)) 
[10:26:11.717]                             version <- utils::packageVersion("future")
[10:26:11.717]                         }
[10:26:11.717]                         else {
[10:26:11.717]                           version <- NULL
[10:26:11.717]                         }
[10:26:11.717]                         if (!has_future || version < "1.8.0") {
[10:26:11.717]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.717]                             "", base::R.version$version.string), 
[10:26:11.717]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:11.717]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.717]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.717]                               "release", "version")], collapse = " "), 
[10:26:11.717]                             hostname = base::Sys.info()[["nodename"]])
[10:26:11.717]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.717]                             info)
[10:26:11.717]                           info <- base::paste(info, collapse = "; ")
[10:26:11.717]                           if (!has_future) {
[10:26:11.717]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.717]                               info)
[10:26:11.717]                           }
[10:26:11.717]                           else {
[10:26:11.717]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.717]                               info, version)
[10:26:11.717]                           }
[10:26:11.717]                           base::stop(msg)
[10:26:11.717]                         }
[10:26:11.717]                       })
[10:26:11.717]                     }
[10:26:11.717]                     base::local({
[10:26:11.717]                       for (pkg in "future") {
[10:26:11.717]                         base::loadNamespace(pkg)
[10:26:11.717]                         base::library(pkg, character.only = TRUE)
[10:26:11.717]                       }
[10:26:11.717]                     })
[10:26:11.717]                   }
[10:26:11.717]                   options(future.plan = NULL)
[10:26:11.717]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.717]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.717]                 }
[10:26:11.717]                 ...future.workdir <- getwd()
[10:26:11.717]             }
[10:26:11.717]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.717]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.717]         }
[10:26:11.717]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.717]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:11.717]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.717]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.717]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.717]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.717]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.717]             base::names(...future.oldOptions))
[10:26:11.717]     }
[10:26:11.717]     if (FALSE) {
[10:26:11.717]     }
[10:26:11.717]     else {
[10:26:11.717]         if (TRUE) {
[10:26:11.717]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.717]                 open = "w")
[10:26:11.717]         }
[10:26:11.717]         else {
[10:26:11.717]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.717]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.717]         }
[10:26:11.717]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.717]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.717]             base::sink(type = "output", split = FALSE)
[10:26:11.717]             base::close(...future.stdout)
[10:26:11.717]         }, add = TRUE)
[10:26:11.717]     }
[10:26:11.717]     ...future.frame <- base::sys.nframe()
[10:26:11.717]     ...future.conditions <- base::list()
[10:26:11.717]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.717]     if (FALSE) {
[10:26:11.717]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.717]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.717]     }
[10:26:11.717]     ...future.result <- base::tryCatch({
[10:26:11.717]         base::withCallingHandlers({
[10:26:11.717]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:26:11.717]                 1))
[10:26:11.717]             future::FutureResult(value = ...future.value$value, 
[10:26:11.717]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.717]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.717]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.717]                     ...future.globalenv.names))
[10:26:11.717]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.717]         }, condition = base::local({
[10:26:11.717]             c <- base::c
[10:26:11.717]             inherits <- base::inherits
[10:26:11.717]             invokeRestart <- base::invokeRestart
[10:26:11.717]             length <- base::length
[10:26:11.717]             list <- base::list
[10:26:11.717]             seq.int <- base::seq.int
[10:26:11.717]             signalCondition <- base::signalCondition
[10:26:11.717]             sys.calls <- base::sys.calls
[10:26:11.717]             `[[` <- base::`[[`
[10:26:11.717]             `+` <- base::`+`
[10:26:11.717]             `<<-` <- base::`<<-`
[10:26:11.717]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.717]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.717]                   3L)]
[10:26:11.717]             }
[10:26:11.717]             function(cond) {
[10:26:11.717]                 is_error <- inherits(cond, "error")
[10:26:11.717]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.717]                   NULL)
[10:26:11.717]                 if (is_error) {
[10:26:11.717]                   sessionInformation <- function() {
[10:26:11.717]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.717]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.717]                       search = base::search(), system = base::Sys.info())
[10:26:11.717]                   }
[10:26:11.717]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.717]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.717]                     cond$call), session = sessionInformation(), 
[10:26:11.717]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.717]                   signalCondition(cond)
[10:26:11.717]                 }
[10:26:11.717]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.717]                 "immediateCondition"))) {
[10:26:11.717]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.717]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.717]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.717]                   if (TRUE && !signal) {
[10:26:11.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.717]                     {
[10:26:11.717]                       inherits <- base::inherits
[10:26:11.717]                       invokeRestart <- base::invokeRestart
[10:26:11.717]                       is.null <- base::is.null
[10:26:11.717]                       muffled <- FALSE
[10:26:11.717]                       if (inherits(cond, "message")) {
[10:26:11.717]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.717]                         if (muffled) 
[10:26:11.717]                           invokeRestart("muffleMessage")
[10:26:11.717]                       }
[10:26:11.717]                       else if (inherits(cond, "warning")) {
[10:26:11.717]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.717]                         if (muffled) 
[10:26:11.717]                           invokeRestart("muffleWarning")
[10:26:11.717]                       }
[10:26:11.717]                       else if (inherits(cond, "condition")) {
[10:26:11.717]                         if (!is.null(pattern)) {
[10:26:11.717]                           computeRestarts <- base::computeRestarts
[10:26:11.717]                           grepl <- base::grepl
[10:26:11.717]                           restarts <- computeRestarts(cond)
[10:26:11.717]                           for (restart in restarts) {
[10:26:11.717]                             name <- restart$name
[10:26:11.717]                             if (is.null(name)) 
[10:26:11.717]                               next
[10:26:11.717]                             if (!grepl(pattern, name)) 
[10:26:11.717]                               next
[10:26:11.717]                             invokeRestart(restart)
[10:26:11.717]                             muffled <- TRUE
[10:26:11.717]                             break
[10:26:11.717]                           }
[10:26:11.717]                         }
[10:26:11.717]                       }
[10:26:11.717]                       invisible(muffled)
[10:26:11.717]                     }
[10:26:11.717]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.717]                   }
[10:26:11.717]                 }
[10:26:11.717]                 else {
[10:26:11.717]                   if (TRUE) {
[10:26:11.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.717]                     {
[10:26:11.717]                       inherits <- base::inherits
[10:26:11.717]                       invokeRestart <- base::invokeRestart
[10:26:11.717]                       is.null <- base::is.null
[10:26:11.717]                       muffled <- FALSE
[10:26:11.717]                       if (inherits(cond, "message")) {
[10:26:11.717]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.717]                         if (muffled) 
[10:26:11.717]                           invokeRestart("muffleMessage")
[10:26:11.717]                       }
[10:26:11.717]                       else if (inherits(cond, "warning")) {
[10:26:11.717]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.717]                         if (muffled) 
[10:26:11.717]                           invokeRestart("muffleWarning")
[10:26:11.717]                       }
[10:26:11.717]                       else if (inherits(cond, "condition")) {
[10:26:11.717]                         if (!is.null(pattern)) {
[10:26:11.717]                           computeRestarts <- base::computeRestarts
[10:26:11.717]                           grepl <- base::grepl
[10:26:11.717]                           restarts <- computeRestarts(cond)
[10:26:11.717]                           for (restart in restarts) {
[10:26:11.717]                             name <- restart$name
[10:26:11.717]                             if (is.null(name)) 
[10:26:11.717]                               next
[10:26:11.717]                             if (!grepl(pattern, name)) 
[10:26:11.717]                               next
[10:26:11.717]                             invokeRestart(restart)
[10:26:11.717]                             muffled <- TRUE
[10:26:11.717]                             break
[10:26:11.717]                           }
[10:26:11.717]                         }
[10:26:11.717]                       }
[10:26:11.717]                       invisible(muffled)
[10:26:11.717]                     }
[10:26:11.717]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.717]                   }
[10:26:11.717]                 }
[10:26:11.717]             }
[10:26:11.717]         }))
[10:26:11.717]     }, error = function(ex) {
[10:26:11.717]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.717]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.717]                 ...future.rng), started = ...future.startTime, 
[10:26:11.717]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.717]             version = "1.8"), class = "FutureResult")
[10:26:11.717]     }, finally = {
[10:26:11.717]         if (!identical(...future.workdir, getwd())) 
[10:26:11.717]             setwd(...future.workdir)
[10:26:11.717]         {
[10:26:11.717]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.717]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.717]             }
[10:26:11.717]             base::options(...future.oldOptions)
[10:26:11.717]             if (.Platform$OS.type == "windows") {
[10:26:11.717]                 old_names <- names(...future.oldEnvVars)
[10:26:11.717]                 envs <- base::Sys.getenv()
[10:26:11.717]                 names <- names(envs)
[10:26:11.717]                 common <- intersect(names, old_names)
[10:26:11.717]                 added <- setdiff(names, old_names)
[10:26:11.717]                 removed <- setdiff(old_names, names)
[10:26:11.717]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.717]                   envs[common]]
[10:26:11.717]                 NAMES <- toupper(changed)
[10:26:11.717]                 args <- list()
[10:26:11.717]                 for (kk in seq_along(NAMES)) {
[10:26:11.717]                   name <- changed[[kk]]
[10:26:11.717]                   NAME <- NAMES[[kk]]
[10:26:11.717]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.717]                     next
[10:26:11.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.717]                 }
[10:26:11.717]                 NAMES <- toupper(added)
[10:26:11.717]                 for (kk in seq_along(NAMES)) {
[10:26:11.717]                   name <- added[[kk]]
[10:26:11.717]                   NAME <- NAMES[[kk]]
[10:26:11.717]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.717]                     next
[10:26:11.717]                   args[[name]] <- ""
[10:26:11.717]                 }
[10:26:11.717]                 NAMES <- toupper(removed)
[10:26:11.717]                 for (kk in seq_along(NAMES)) {
[10:26:11.717]                   name <- removed[[kk]]
[10:26:11.717]                   NAME <- NAMES[[kk]]
[10:26:11.717]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.717]                     next
[10:26:11.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.717]                 }
[10:26:11.717]                 if (length(args) > 0) 
[10:26:11.717]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.717]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.717]             }
[10:26:11.717]             else {
[10:26:11.717]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.717]             }
[10:26:11.717]             {
[10:26:11.717]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.717]                   0L) {
[10:26:11.717]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.717]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.717]                   base::options(opts)
[10:26:11.717]                 }
[10:26:11.717]                 {
[10:26:11.717]                   {
[10:26:11.717]                     NULL
[10:26:11.717]                     RNGkind("Mersenne-Twister")
[10:26:11.717]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.717]                       inherits = FALSE)
[10:26:11.717]                   }
[10:26:11.717]                   options(future.plan = NULL)
[10:26:11.717]                   if (is.na(NA_character_)) 
[10:26:11.717]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.717]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.717]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.717]                   {
[10:26:11.717]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.717]                     if (!future$lazy) 
[10:26:11.717]                       future <- run(future)
[10:26:11.717]                     invisible(future)
[10:26:11.717]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.717]                 }
[10:26:11.717]             }
[10:26:11.717]         }
[10:26:11.717]     })
[10:26:11.717]     if (TRUE) {
[10:26:11.717]         base::sink(type = "output", split = FALSE)
[10:26:11.717]         if (TRUE) {
[10:26:11.717]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.717]         }
[10:26:11.717]         else {
[10:26:11.717]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.717]         }
[10:26:11.717]         base::close(...future.stdout)
[10:26:11.717]         ...future.stdout <- NULL
[10:26:11.717]     }
[10:26:11.717]     ...future.result$conditions <- ...future.conditions
[10:26:11.717]     ...future.result$finished <- base::Sys.time()
[10:26:11.717]     ...future.result
[10:26:11.717] }
[10:26:11.719] assign_globals() ...
[10:26:11.719] List of 1
[10:26:11.719]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a02206af08> 
[10:26:11.719]  - attr(*, "where")=List of 1
[10:26:11.719]   ..$ a:<environment: R_EmptyEnv> 
[10:26:11.719]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.719]  - attr(*, "resolved")= logi TRUE
[10:26:11.719]  - attr(*, "total_size")= num 1616080
[10:26:11.719]  - attr(*, "already-done")= logi TRUE
[10:26:11.721] - copied ‘a’ to environment
[10:26:11.721] assign_globals() ... done
[10:26:11.721] plan(): Setting new future strategy stack:
[10:26:11.722] List of future strategies:
[10:26:11.722] 1. sequential:
[10:26:11.722]    - args: function (..., envir = parent.frame())
[10:26:11.722]    - tweaked: FALSE
[10:26:11.722]    - call: NULL
[10:26:11.722] plan(): nbrOfWorkers() = 1
[10:26:11.723] plan(): Setting new future strategy stack:
[10:26:11.723] List of future strategies:
[10:26:11.723] 1. sequential:
[10:26:11.723]    - args: function (..., envir = parent.frame())
[10:26:11.723]    - tweaked: FALSE
[10:26:11.723]    - call: plan(strategy)
[10:26:11.723] plan(): nbrOfWorkers() = 1
[10:26:11.723] SequentialFuture started (and completed)
[10:26:11.723] - Launch lazy future ... done
[10:26:11.723] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.724] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.724] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:11.725] - globals found: [2] ‘{’, ‘pkg’
[10:26:11.725] Searching for globals ... DONE
[10:26:11.725] Resolving globals: TRUE
[10:26:11.725] Resolving any globals that are futures ...
[10:26:11.725] - globals: [2] ‘{’, ‘pkg’
[10:26:11.725] Resolving any globals that are futures ... DONE
[10:26:11.725] Resolving futures part of globals (recursively) ...
[10:26:11.726] resolve() on list ...
[10:26:11.726]  recursive: 99
[10:26:11.726]  length: 1
[10:26:11.726]  elements: ‘pkg’
[10:26:11.726]  length: 0 (resolved future 1)
[10:26:11.726] resolve() on list ... DONE
[10:26:11.726] - globals: [1] ‘pkg’
[10:26:11.726] Resolving futures part of globals (recursively) ... DONE
[10:26:11.726] The total size of the 1 globals is 112 bytes (112 bytes)
[10:26:11.727] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[10:26:11.727] - globals: [1] ‘pkg’
[10:26:11.727] 
[10:26:11.727] getGlobalsAndPackages() ... DONE
[10:26:11.727] Packages needed by the future expression (n = 0): <none>
[10:26:11.727] Packages needed by future strategies (n = 0): <none>
[10:26:11.728] {
[10:26:11.728]     {
[10:26:11.728]         {
[10:26:11.728]             ...future.startTime <- base::Sys.time()
[10:26:11.728]             {
[10:26:11.728]                 {
[10:26:11.728]                   {
[10:26:11.728]                     base::local({
[10:26:11.728]                       has_future <- base::requireNamespace("future", 
[10:26:11.728]                         quietly = TRUE)
[10:26:11.728]                       if (has_future) {
[10:26:11.728]                         ns <- base::getNamespace("future")
[10:26:11.728]                         version <- ns[[".package"]][["version"]]
[10:26:11.728]                         if (is.null(version)) 
[10:26:11.728]                           version <- utils::packageVersion("future")
[10:26:11.728]                       }
[10:26:11.728]                       else {
[10:26:11.728]                         version <- NULL
[10:26:11.728]                       }
[10:26:11.728]                       if (!has_future || version < "1.8.0") {
[10:26:11.728]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.728]                           "", base::R.version$version.string), 
[10:26:11.728]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.728]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.728]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.728]                             "release", "version")], collapse = " "), 
[10:26:11.728]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.728]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.728]                           info)
[10:26:11.728]                         info <- base::paste(info, collapse = "; ")
[10:26:11.728]                         if (!has_future) {
[10:26:11.728]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.728]                             info)
[10:26:11.728]                         }
[10:26:11.728]                         else {
[10:26:11.728]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.728]                             info, version)
[10:26:11.728]                         }
[10:26:11.728]                         base::stop(msg)
[10:26:11.728]                       }
[10:26:11.728]                     })
[10:26:11.728]                   }
[10:26:11.728]                   options(future.plan = NULL)
[10:26:11.728]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.728]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.728]                 }
[10:26:11.728]                 ...future.workdir <- getwd()
[10:26:11.728]             }
[10:26:11.728]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.728]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.728]         }
[10:26:11.728]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.728]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:11.728]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.728]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.728]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.728]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.728]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.728]             base::names(...future.oldOptions))
[10:26:11.728]     }
[10:26:11.728]     if (FALSE) {
[10:26:11.728]     }
[10:26:11.728]     else {
[10:26:11.728]         if (TRUE) {
[10:26:11.728]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.728]                 open = "w")
[10:26:11.728]         }
[10:26:11.728]         else {
[10:26:11.728]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.728]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.728]         }
[10:26:11.728]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.728]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.728]             base::sink(type = "output", split = FALSE)
[10:26:11.728]             base::close(...future.stdout)
[10:26:11.728]         }, add = TRUE)
[10:26:11.728]     }
[10:26:11.728]     ...future.frame <- base::sys.nframe()
[10:26:11.728]     ...future.conditions <- base::list()
[10:26:11.728]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.728]     if (FALSE) {
[10:26:11.728]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.728]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.728]     }
[10:26:11.728]     ...future.result <- base::tryCatch({
[10:26:11.728]         base::withCallingHandlers({
[10:26:11.728]             ...future.value <- base::withVisible(base::local({
[10:26:11.728]                 pkg
[10:26:11.728]             }))
[10:26:11.728]             future::FutureResult(value = ...future.value$value, 
[10:26:11.728]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.728]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.728]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.728]                     ...future.globalenv.names))
[10:26:11.728]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.728]         }, condition = base::local({
[10:26:11.728]             c <- base::c
[10:26:11.728]             inherits <- base::inherits
[10:26:11.728]             invokeRestart <- base::invokeRestart
[10:26:11.728]             length <- base::length
[10:26:11.728]             list <- base::list
[10:26:11.728]             seq.int <- base::seq.int
[10:26:11.728]             signalCondition <- base::signalCondition
[10:26:11.728]             sys.calls <- base::sys.calls
[10:26:11.728]             `[[` <- base::`[[`
[10:26:11.728]             `+` <- base::`+`
[10:26:11.728]             `<<-` <- base::`<<-`
[10:26:11.728]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.728]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.728]                   3L)]
[10:26:11.728]             }
[10:26:11.728]             function(cond) {
[10:26:11.728]                 is_error <- inherits(cond, "error")
[10:26:11.728]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.728]                   NULL)
[10:26:11.728]                 if (is_error) {
[10:26:11.728]                   sessionInformation <- function() {
[10:26:11.728]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.728]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.728]                       search = base::search(), system = base::Sys.info())
[10:26:11.728]                   }
[10:26:11.728]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.728]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.728]                     cond$call), session = sessionInformation(), 
[10:26:11.728]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.728]                   signalCondition(cond)
[10:26:11.728]                 }
[10:26:11.728]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.728]                 "immediateCondition"))) {
[10:26:11.728]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.728]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.728]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.728]                   if (TRUE && !signal) {
[10:26:11.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.728]                     {
[10:26:11.728]                       inherits <- base::inherits
[10:26:11.728]                       invokeRestart <- base::invokeRestart
[10:26:11.728]                       is.null <- base::is.null
[10:26:11.728]                       muffled <- FALSE
[10:26:11.728]                       if (inherits(cond, "message")) {
[10:26:11.728]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.728]                         if (muffled) 
[10:26:11.728]                           invokeRestart("muffleMessage")
[10:26:11.728]                       }
[10:26:11.728]                       else if (inherits(cond, "warning")) {
[10:26:11.728]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.728]                         if (muffled) 
[10:26:11.728]                           invokeRestart("muffleWarning")
[10:26:11.728]                       }
[10:26:11.728]                       else if (inherits(cond, "condition")) {
[10:26:11.728]                         if (!is.null(pattern)) {
[10:26:11.728]                           computeRestarts <- base::computeRestarts
[10:26:11.728]                           grepl <- base::grepl
[10:26:11.728]                           restarts <- computeRestarts(cond)
[10:26:11.728]                           for (restart in restarts) {
[10:26:11.728]                             name <- restart$name
[10:26:11.728]                             if (is.null(name)) 
[10:26:11.728]                               next
[10:26:11.728]                             if (!grepl(pattern, name)) 
[10:26:11.728]                               next
[10:26:11.728]                             invokeRestart(restart)
[10:26:11.728]                             muffled <- TRUE
[10:26:11.728]                             break
[10:26:11.728]                           }
[10:26:11.728]                         }
[10:26:11.728]                       }
[10:26:11.728]                       invisible(muffled)
[10:26:11.728]                     }
[10:26:11.728]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.728]                   }
[10:26:11.728]                 }
[10:26:11.728]                 else {
[10:26:11.728]                   if (TRUE) {
[10:26:11.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.728]                     {
[10:26:11.728]                       inherits <- base::inherits
[10:26:11.728]                       invokeRestart <- base::invokeRestart
[10:26:11.728]                       is.null <- base::is.null
[10:26:11.728]                       muffled <- FALSE
[10:26:11.728]                       if (inherits(cond, "message")) {
[10:26:11.728]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.728]                         if (muffled) 
[10:26:11.728]                           invokeRestart("muffleMessage")
[10:26:11.728]                       }
[10:26:11.728]                       else if (inherits(cond, "warning")) {
[10:26:11.728]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.728]                         if (muffled) 
[10:26:11.728]                           invokeRestart("muffleWarning")
[10:26:11.728]                       }
[10:26:11.728]                       else if (inherits(cond, "condition")) {
[10:26:11.728]                         if (!is.null(pattern)) {
[10:26:11.728]                           computeRestarts <- base::computeRestarts
[10:26:11.728]                           grepl <- base::grepl
[10:26:11.728]                           restarts <- computeRestarts(cond)
[10:26:11.728]                           for (restart in restarts) {
[10:26:11.728]                             name <- restart$name
[10:26:11.728]                             if (is.null(name)) 
[10:26:11.728]                               next
[10:26:11.728]                             if (!grepl(pattern, name)) 
[10:26:11.728]                               next
[10:26:11.728]                             invokeRestart(restart)
[10:26:11.728]                             muffled <- TRUE
[10:26:11.728]                             break
[10:26:11.728]                           }
[10:26:11.728]                         }
[10:26:11.728]                       }
[10:26:11.728]                       invisible(muffled)
[10:26:11.728]                     }
[10:26:11.728]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.728]                   }
[10:26:11.728]                 }
[10:26:11.728]             }
[10:26:11.728]         }))
[10:26:11.728]     }, error = function(ex) {
[10:26:11.728]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.728]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.728]                 ...future.rng), started = ...future.startTime, 
[10:26:11.728]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.728]             version = "1.8"), class = "FutureResult")
[10:26:11.728]     }, finally = {
[10:26:11.728]         if (!identical(...future.workdir, getwd())) 
[10:26:11.728]             setwd(...future.workdir)
[10:26:11.728]         {
[10:26:11.728]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.728]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.728]             }
[10:26:11.728]             base::options(...future.oldOptions)
[10:26:11.728]             if (.Platform$OS.type == "windows") {
[10:26:11.728]                 old_names <- names(...future.oldEnvVars)
[10:26:11.728]                 envs <- base::Sys.getenv()
[10:26:11.728]                 names <- names(envs)
[10:26:11.728]                 common <- intersect(names, old_names)
[10:26:11.728]                 added <- setdiff(names, old_names)
[10:26:11.728]                 removed <- setdiff(old_names, names)
[10:26:11.728]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.728]                   envs[common]]
[10:26:11.728]                 NAMES <- toupper(changed)
[10:26:11.728]                 args <- list()
[10:26:11.728]                 for (kk in seq_along(NAMES)) {
[10:26:11.728]                   name <- changed[[kk]]
[10:26:11.728]                   NAME <- NAMES[[kk]]
[10:26:11.728]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.728]                     next
[10:26:11.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.728]                 }
[10:26:11.728]                 NAMES <- toupper(added)
[10:26:11.728]                 for (kk in seq_along(NAMES)) {
[10:26:11.728]                   name <- added[[kk]]
[10:26:11.728]                   NAME <- NAMES[[kk]]
[10:26:11.728]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.728]                     next
[10:26:11.728]                   args[[name]] <- ""
[10:26:11.728]                 }
[10:26:11.728]                 NAMES <- toupper(removed)
[10:26:11.728]                 for (kk in seq_along(NAMES)) {
[10:26:11.728]                   name <- removed[[kk]]
[10:26:11.728]                   NAME <- NAMES[[kk]]
[10:26:11.728]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.728]                     next
[10:26:11.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.728]                 }
[10:26:11.728]                 if (length(args) > 0) 
[10:26:11.728]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.728]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.728]             }
[10:26:11.728]             else {
[10:26:11.728]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.728]             }
[10:26:11.728]             {
[10:26:11.728]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.728]                   0L) {
[10:26:11.728]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.728]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.728]                   base::options(opts)
[10:26:11.728]                 }
[10:26:11.728]                 {
[10:26:11.728]                   {
[10:26:11.728]                     NULL
[10:26:11.728]                     RNGkind("Mersenne-Twister")
[10:26:11.728]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.728]                       inherits = FALSE)
[10:26:11.728]                   }
[10:26:11.728]                   options(future.plan = NULL)
[10:26:11.728]                   if (is.na(NA_character_)) 
[10:26:11.728]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.728]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.728]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.728]                   {
[10:26:11.728]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.728]                     if (!future$lazy) 
[10:26:11.728]                       future <- run(future)
[10:26:11.728]                     invisible(future)
[10:26:11.728]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.728]                 }
[10:26:11.728]             }
[10:26:11.728]         }
[10:26:11.728]     })
[10:26:11.728]     if (TRUE) {
[10:26:11.728]         base::sink(type = "output", split = FALSE)
[10:26:11.728]         if (TRUE) {
[10:26:11.728]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.728]         }
[10:26:11.728]         else {
[10:26:11.728]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.728]         }
[10:26:11.728]         base::close(...future.stdout)
[10:26:11.728]         ...future.stdout <- NULL
[10:26:11.728]     }
[10:26:11.728]     ...future.result$conditions <- ...future.conditions
[10:26:11.728]     ...future.result$finished <- base::Sys.time()
[10:26:11.728]     ...future.result
[10:26:11.728] }
[10:26:11.729] assign_globals() ...
[10:26:11.729] List of 1
[10:26:11.729]  $ pkg: chr "foo"
[10:26:11.729]  - attr(*, "where")=List of 1
[10:26:11.729]   ..$ pkg:<environment: R_EmptyEnv> 
[10:26:11.729]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.729]  - attr(*, "resolved")= logi TRUE
[10:26:11.729]  - attr(*, "total_size")= num 112
[10:26:11.731] - copied ‘pkg’ to environment
[10:26:11.732] assign_globals() ... done
[10:26:11.732] plan(): Setting new future strategy stack:
[10:26:11.732] List of future strategies:
[10:26:11.732] 1. sequential:
[10:26:11.732]    - args: function (..., envir = parent.frame())
[10:26:11.732]    - tweaked: FALSE
[10:26:11.732]    - call: NULL
[10:26:11.732] plan(): nbrOfWorkers() = 1
[10:26:11.733] plan(): Setting new future strategy stack:
[10:26:11.733] List of future strategies:
[10:26:11.733] 1. sequential:
[10:26:11.733]    - args: function (..., envir = parent.frame())
[10:26:11.733]    - tweaked: FALSE
[10:26:11.733]    - call: plan(strategy)
[10:26:11.734] plan(): nbrOfWorkers() = 1
[10:26:11.734] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.734] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.734] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:11.736] - globals found: [3] ‘{’, ‘<-’, ‘+’
[10:26:11.736] Searching for globals ... DONE
[10:26:11.737] Resolving globals: TRUE
[10:26:11.738] Resolving any globals that are futures ...
[10:26:11.738] - globals: [3] ‘{’, ‘<-’, ‘+’
[10:26:11.738] Resolving any globals that are futures ... DONE
[10:26:11.738] 
[10:26:11.738] 
[10:26:11.738] getGlobalsAndPackages() ... DONE
[10:26:11.739] run() for ‘Future’ ...
[10:26:11.739] - state: ‘created’
[10:26:11.739] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.739] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.739] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.739]   - Field: ‘label’
[10:26:11.739]   - Field: ‘local’
[10:26:11.740]   - Field: ‘owner’
[10:26:11.740]   - Field: ‘envir’
[10:26:11.740]   - Field: ‘packages’
[10:26:11.740]   - Field: ‘gc’
[10:26:11.740]   - Field: ‘conditions’
[10:26:11.740]   - Field: ‘expr’
[10:26:11.740]   - Field: ‘uuid’
[10:26:11.740]   - Field: ‘seed’
[10:26:11.740]   - Field: ‘version’
[10:26:11.740]   - Field: ‘result’
[10:26:11.741]   - Field: ‘asynchronous’
[10:26:11.741]   - Field: ‘calls’
[10:26:11.741]   - Field: ‘globals’
[10:26:11.741]   - Field: ‘stdout’
[10:26:11.741]   - Field: ‘earlySignal’
[10:26:11.741]   - Field: ‘lazy’
[10:26:11.741]   - Field: ‘state’
[10:26:11.741] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.741] - Launch lazy future ...
[10:26:11.741] Packages needed by the future expression (n = 0): <none>
[10:26:11.742] Packages needed by future strategies (n = 0): <none>
[10:26:11.742] {
[10:26:11.742]     {
[10:26:11.742]         {
[10:26:11.742]             ...future.startTime <- base::Sys.time()
[10:26:11.742]             {
[10:26:11.742]                 {
[10:26:11.742]                   {
[10:26:11.742]                     base::local({
[10:26:11.742]                       has_future <- base::requireNamespace("future", 
[10:26:11.742]                         quietly = TRUE)
[10:26:11.742]                       if (has_future) {
[10:26:11.742]                         ns <- base::getNamespace("future")
[10:26:11.742]                         version <- ns[[".package"]][["version"]]
[10:26:11.742]                         if (is.null(version)) 
[10:26:11.742]                           version <- utils::packageVersion("future")
[10:26:11.742]                       }
[10:26:11.742]                       else {
[10:26:11.742]                         version <- NULL
[10:26:11.742]                       }
[10:26:11.742]                       if (!has_future || version < "1.8.0") {
[10:26:11.742]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.742]                           "", base::R.version$version.string), 
[10:26:11.742]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.742]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.742]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.742]                             "release", "version")], collapse = " "), 
[10:26:11.742]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.742]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.742]                           info)
[10:26:11.742]                         info <- base::paste(info, collapse = "; ")
[10:26:11.742]                         if (!has_future) {
[10:26:11.742]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.742]                             info)
[10:26:11.742]                         }
[10:26:11.742]                         else {
[10:26:11.742]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.742]                             info, version)
[10:26:11.742]                         }
[10:26:11.742]                         base::stop(msg)
[10:26:11.742]                       }
[10:26:11.742]                     })
[10:26:11.742]                   }
[10:26:11.742]                   options(future.plan = NULL)
[10:26:11.742]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.742]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.742]                 }
[10:26:11.742]                 ...future.workdir <- getwd()
[10:26:11.742]             }
[10:26:11.742]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.742]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.742]         }
[10:26:11.742]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.742]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:11.742]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.742]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.742]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.742]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.742]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.742]             base::names(...future.oldOptions))
[10:26:11.742]     }
[10:26:11.742]     if (FALSE) {
[10:26:11.742]     }
[10:26:11.742]     else {
[10:26:11.742]         if (TRUE) {
[10:26:11.742]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.742]                 open = "w")
[10:26:11.742]         }
[10:26:11.742]         else {
[10:26:11.742]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.742]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.742]         }
[10:26:11.742]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.742]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.742]             base::sink(type = "output", split = FALSE)
[10:26:11.742]             base::close(...future.stdout)
[10:26:11.742]         }, add = TRUE)
[10:26:11.742]     }
[10:26:11.742]     ...future.frame <- base::sys.nframe()
[10:26:11.742]     ...future.conditions <- base::list()
[10:26:11.742]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.742]     if (FALSE) {
[10:26:11.742]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.742]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.742]     }
[10:26:11.742]     ...future.result <- base::tryCatch({
[10:26:11.742]         base::withCallingHandlers({
[10:26:11.742]             ...future.value <- base::withVisible(base::local({
[10:26:11.742]                 x <- 0
[10:26:11.742]                 x <- x + 1
[10:26:11.742]                 x
[10:26:11.742]             }))
[10:26:11.742]             future::FutureResult(value = ...future.value$value, 
[10:26:11.742]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.742]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.742]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.742]                     ...future.globalenv.names))
[10:26:11.742]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.742]         }, condition = base::local({
[10:26:11.742]             c <- base::c
[10:26:11.742]             inherits <- base::inherits
[10:26:11.742]             invokeRestart <- base::invokeRestart
[10:26:11.742]             length <- base::length
[10:26:11.742]             list <- base::list
[10:26:11.742]             seq.int <- base::seq.int
[10:26:11.742]             signalCondition <- base::signalCondition
[10:26:11.742]             sys.calls <- base::sys.calls
[10:26:11.742]             `[[` <- base::`[[`
[10:26:11.742]             `+` <- base::`+`
[10:26:11.742]             `<<-` <- base::`<<-`
[10:26:11.742]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.742]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.742]                   3L)]
[10:26:11.742]             }
[10:26:11.742]             function(cond) {
[10:26:11.742]                 is_error <- inherits(cond, "error")
[10:26:11.742]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.742]                   NULL)
[10:26:11.742]                 if (is_error) {
[10:26:11.742]                   sessionInformation <- function() {
[10:26:11.742]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.742]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.742]                       search = base::search(), system = base::Sys.info())
[10:26:11.742]                   }
[10:26:11.742]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.742]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.742]                     cond$call), session = sessionInformation(), 
[10:26:11.742]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.742]                   signalCondition(cond)
[10:26:11.742]                 }
[10:26:11.742]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.742]                 "immediateCondition"))) {
[10:26:11.742]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.742]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.742]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.742]                   if (TRUE && !signal) {
[10:26:11.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.742]                     {
[10:26:11.742]                       inherits <- base::inherits
[10:26:11.742]                       invokeRestart <- base::invokeRestart
[10:26:11.742]                       is.null <- base::is.null
[10:26:11.742]                       muffled <- FALSE
[10:26:11.742]                       if (inherits(cond, "message")) {
[10:26:11.742]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.742]                         if (muffled) 
[10:26:11.742]                           invokeRestart("muffleMessage")
[10:26:11.742]                       }
[10:26:11.742]                       else if (inherits(cond, "warning")) {
[10:26:11.742]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.742]                         if (muffled) 
[10:26:11.742]                           invokeRestart("muffleWarning")
[10:26:11.742]                       }
[10:26:11.742]                       else if (inherits(cond, "condition")) {
[10:26:11.742]                         if (!is.null(pattern)) {
[10:26:11.742]                           computeRestarts <- base::computeRestarts
[10:26:11.742]                           grepl <- base::grepl
[10:26:11.742]                           restarts <- computeRestarts(cond)
[10:26:11.742]                           for (restart in restarts) {
[10:26:11.742]                             name <- restart$name
[10:26:11.742]                             if (is.null(name)) 
[10:26:11.742]                               next
[10:26:11.742]                             if (!grepl(pattern, name)) 
[10:26:11.742]                               next
[10:26:11.742]                             invokeRestart(restart)
[10:26:11.742]                             muffled <- TRUE
[10:26:11.742]                             break
[10:26:11.742]                           }
[10:26:11.742]                         }
[10:26:11.742]                       }
[10:26:11.742]                       invisible(muffled)
[10:26:11.742]                     }
[10:26:11.742]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.742]                   }
[10:26:11.742]                 }
[10:26:11.742]                 else {
[10:26:11.742]                   if (TRUE) {
[10:26:11.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.742]                     {
[10:26:11.742]                       inherits <- base::inherits
[10:26:11.742]                       invokeRestart <- base::invokeRestart
[10:26:11.742]                       is.null <- base::is.null
[10:26:11.742]                       muffled <- FALSE
[10:26:11.742]                       if (inherits(cond, "message")) {
[10:26:11.742]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.742]                         if (muffled) 
[10:26:11.742]                           invokeRestart("muffleMessage")
[10:26:11.742]                       }
[10:26:11.742]                       else if (inherits(cond, "warning")) {
[10:26:11.742]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.742]                         if (muffled) 
[10:26:11.742]                           invokeRestart("muffleWarning")
[10:26:11.742]                       }
[10:26:11.742]                       else if (inherits(cond, "condition")) {
[10:26:11.742]                         if (!is.null(pattern)) {
[10:26:11.742]                           computeRestarts <- base::computeRestarts
[10:26:11.742]                           grepl <- base::grepl
[10:26:11.742]                           restarts <- computeRestarts(cond)
[10:26:11.742]                           for (restart in restarts) {
[10:26:11.742]                             name <- restart$name
[10:26:11.742]                             if (is.null(name)) 
[10:26:11.742]                               next
[10:26:11.742]                             if (!grepl(pattern, name)) 
[10:26:11.742]                               next
[10:26:11.742]                             invokeRestart(restart)
[10:26:11.742]                             muffled <- TRUE
[10:26:11.742]                             break
[10:26:11.742]                           }
[10:26:11.742]                         }
[10:26:11.742]                       }
[10:26:11.742]                       invisible(muffled)
[10:26:11.742]                     }
[10:26:11.742]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.742]                   }
[10:26:11.742]                 }
[10:26:11.742]             }
[10:26:11.742]         }))
[10:26:11.742]     }, error = function(ex) {
[10:26:11.742]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.742]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.742]                 ...future.rng), started = ...future.startTime, 
[10:26:11.742]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.742]             version = "1.8"), class = "FutureResult")
[10:26:11.742]     }, finally = {
[10:26:11.742]         if (!identical(...future.workdir, getwd())) 
[10:26:11.742]             setwd(...future.workdir)
[10:26:11.742]         {
[10:26:11.742]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.742]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.742]             }
[10:26:11.742]             base::options(...future.oldOptions)
[10:26:11.742]             if (.Platform$OS.type == "windows") {
[10:26:11.742]                 old_names <- names(...future.oldEnvVars)
[10:26:11.742]                 envs <- base::Sys.getenv()
[10:26:11.742]                 names <- names(envs)
[10:26:11.742]                 common <- intersect(names, old_names)
[10:26:11.742]                 added <- setdiff(names, old_names)
[10:26:11.742]                 removed <- setdiff(old_names, names)
[10:26:11.742]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.742]                   envs[common]]
[10:26:11.742]                 NAMES <- toupper(changed)
[10:26:11.742]                 args <- list()
[10:26:11.742]                 for (kk in seq_along(NAMES)) {
[10:26:11.742]                   name <- changed[[kk]]
[10:26:11.742]                   NAME <- NAMES[[kk]]
[10:26:11.742]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.742]                     next
[10:26:11.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.742]                 }
[10:26:11.742]                 NAMES <- toupper(added)
[10:26:11.742]                 for (kk in seq_along(NAMES)) {
[10:26:11.742]                   name <- added[[kk]]
[10:26:11.742]                   NAME <- NAMES[[kk]]
[10:26:11.742]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.742]                     next
[10:26:11.742]                   args[[name]] <- ""
[10:26:11.742]                 }
[10:26:11.742]                 NAMES <- toupper(removed)
[10:26:11.742]                 for (kk in seq_along(NAMES)) {
[10:26:11.742]                   name <- removed[[kk]]
[10:26:11.742]                   NAME <- NAMES[[kk]]
[10:26:11.742]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.742]                     next
[10:26:11.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.742]                 }
[10:26:11.742]                 if (length(args) > 0) 
[10:26:11.742]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.742]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.742]             }
[10:26:11.742]             else {
[10:26:11.742]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.742]             }
[10:26:11.742]             {
[10:26:11.742]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.742]                   0L) {
[10:26:11.742]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.742]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.742]                   base::options(opts)
[10:26:11.742]                 }
[10:26:11.742]                 {
[10:26:11.742]                   {
[10:26:11.742]                     NULL
[10:26:11.742]                     RNGkind("Mersenne-Twister")
[10:26:11.742]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.742]                       inherits = FALSE)
[10:26:11.742]                   }
[10:26:11.742]                   options(future.plan = NULL)
[10:26:11.742]                   if (is.na(NA_character_)) 
[10:26:11.742]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.742]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.742]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.742]                   {
[10:26:11.742]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.742]                     if (!future$lazy) 
[10:26:11.742]                       future <- run(future)
[10:26:11.742]                     invisible(future)
[10:26:11.742]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.742]                 }
[10:26:11.742]             }
[10:26:11.742]         }
[10:26:11.742]     })
[10:26:11.742]     if (TRUE) {
[10:26:11.742]         base::sink(type = "output", split = FALSE)
[10:26:11.742]         if (TRUE) {
[10:26:11.742]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.742]         }
[10:26:11.742]         else {
[10:26:11.742]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.742]         }
[10:26:11.742]         base::close(...future.stdout)
[10:26:11.742]         ...future.stdout <- NULL
[10:26:11.742]     }
[10:26:11.742]     ...future.result$conditions <- ...future.conditions
[10:26:11.742]     ...future.result$finished <- base::Sys.time()
[10:26:11.742]     ...future.result
[10:26:11.742] }
[10:26:11.744] plan(): Setting new future strategy stack:
[10:26:11.744] List of future strategies:
[10:26:11.744] 1. sequential:
[10:26:11.744]    - args: function (..., envir = parent.frame())
[10:26:11.744]    - tweaked: FALSE
[10:26:11.744]    - call: NULL
[10:26:11.744] plan(): nbrOfWorkers() = 1
[10:26:11.745] plan(): Setting new future strategy stack:
[10:26:11.745] List of future strategies:
[10:26:11.745] 1. sequential:
[10:26:11.745]    - args: function (..., envir = parent.frame())
[10:26:11.745]    - tweaked: FALSE
[10:26:11.745]    - call: plan(strategy)
[10:26:11.745] plan(): nbrOfWorkers() = 1
[10:26:11.746] SequentialFuture started (and completed)
[10:26:11.746] - Launch lazy future ... done
[10:26:11.746] run() for ‘SequentialFuture’ ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.746] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.746] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:11.748] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[10:26:11.748] Searching for globals ... DONE
[10:26:11.748] Resolving globals: TRUE
[10:26:11.748] Resolving any globals that are futures ...
[10:26:11.748] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[10:26:11.748] Resolving any globals that are futures ... DONE
[10:26:11.748] Resolving futures part of globals (recursively) ...
[10:26:11.749] resolve() on list ...
[10:26:11.749]  recursive: 99
[10:26:11.749]  length: 1
[10:26:11.749]  elements: ‘x’
[10:26:11.749]  length: 0 (resolved future 1)
[10:26:11.749] resolve() on list ... DONE
[10:26:11.749] - globals: [1] ‘x’
[10:26:11.749] Resolving futures part of globals (recursively) ... DONE
[10:26:11.750] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:11.750] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[10:26:11.750] - globals: [1] ‘x’
[10:26:11.750] 
[10:26:11.750] getGlobalsAndPackages() ... DONE
[10:26:11.750] run() for ‘Future’ ...
[10:26:11.750] - state: ‘created’
[10:26:11.751] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.751] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.751] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.751]   - Field: ‘label’
[10:26:11.751]   - Field: ‘local’
[10:26:11.751]   - Field: ‘owner’
[10:26:11.751]   - Field: ‘envir’
[10:26:11.751]   - Field: ‘packages’
[10:26:11.752]   - Field: ‘gc’
[10:26:11.752]   - Field: ‘conditions’
[10:26:11.752]   - Field: ‘expr’
[10:26:11.752]   - Field: ‘uuid’
[10:26:11.752]   - Field: ‘seed’
[10:26:11.752]   - Field: ‘version’
[10:26:11.752]   - Field: ‘result’
[10:26:11.752]   - Field: ‘asynchronous’
[10:26:11.752]   - Field: ‘calls’
[10:26:11.752]   - Field: ‘globals’
[10:26:11.752]   - Field: ‘stdout’
[10:26:11.753]   - Field: ‘earlySignal’
[10:26:11.753]   - Field: ‘lazy’
[10:26:11.753]   - Field: ‘state’
[10:26:11.753] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.753] - Launch lazy future ...
[10:26:11.753] Packages needed by the future expression (n = 0): <none>
[10:26:11.753] Packages needed by future strategies (n = 0): <none>
[10:26:11.754] {
[10:26:11.754]     {
[10:26:11.754]         {
[10:26:11.754]             ...future.startTime <- base::Sys.time()
[10:26:11.754]             {
[10:26:11.754]                 {
[10:26:11.754]                   {
[10:26:11.754]                     base::local({
[10:26:11.754]                       has_future <- base::requireNamespace("future", 
[10:26:11.754]                         quietly = TRUE)
[10:26:11.754]                       if (has_future) {
[10:26:11.754]                         ns <- base::getNamespace("future")
[10:26:11.754]                         version <- ns[[".package"]][["version"]]
[10:26:11.754]                         if (is.null(version)) 
[10:26:11.754]                           version <- utils::packageVersion("future")
[10:26:11.754]                       }
[10:26:11.754]                       else {
[10:26:11.754]                         version <- NULL
[10:26:11.754]                       }
[10:26:11.754]                       if (!has_future || version < "1.8.0") {
[10:26:11.754]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.754]                           "", base::R.version$version.string), 
[10:26:11.754]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.754]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.754]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.754]                             "release", "version")], collapse = " "), 
[10:26:11.754]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.754]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.754]                           info)
[10:26:11.754]                         info <- base::paste(info, collapse = "; ")
[10:26:11.754]                         if (!has_future) {
[10:26:11.754]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.754]                             info)
[10:26:11.754]                         }
[10:26:11.754]                         else {
[10:26:11.754]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.754]                             info, version)
[10:26:11.754]                         }
[10:26:11.754]                         base::stop(msg)
[10:26:11.754]                       }
[10:26:11.754]                     })
[10:26:11.754]                   }
[10:26:11.754]                   options(future.plan = NULL)
[10:26:11.754]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.754]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.754]                 }
[10:26:11.754]                 ...future.workdir <- getwd()
[10:26:11.754]             }
[10:26:11.754]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.754]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.754]         }
[10:26:11.754]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.754]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:11.754]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.754]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.754]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.754]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.754]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.754]             base::names(...future.oldOptions))
[10:26:11.754]     }
[10:26:11.754]     if (FALSE) {
[10:26:11.754]     }
[10:26:11.754]     else {
[10:26:11.754]         if (TRUE) {
[10:26:11.754]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.754]                 open = "w")
[10:26:11.754]         }
[10:26:11.754]         else {
[10:26:11.754]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.754]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.754]         }
[10:26:11.754]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.754]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.754]             base::sink(type = "output", split = FALSE)
[10:26:11.754]             base::close(...future.stdout)
[10:26:11.754]         }, add = TRUE)
[10:26:11.754]     }
[10:26:11.754]     ...future.frame <- base::sys.nframe()
[10:26:11.754]     ...future.conditions <- base::list()
[10:26:11.754]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.754]     if (FALSE) {
[10:26:11.754]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.754]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.754]     }
[10:26:11.754]     ...future.result <- base::tryCatch({
[10:26:11.754]         base::withCallingHandlers({
[10:26:11.754]             ...future.value <- base::withVisible(base::local({
[10:26:11.754]                 x <- x + 1
[10:26:11.754]                 x
[10:26:11.754]             }))
[10:26:11.754]             future::FutureResult(value = ...future.value$value, 
[10:26:11.754]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.754]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.754]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.754]                     ...future.globalenv.names))
[10:26:11.754]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.754]         }, condition = base::local({
[10:26:11.754]             c <- base::c
[10:26:11.754]             inherits <- base::inherits
[10:26:11.754]             invokeRestart <- base::invokeRestart
[10:26:11.754]             length <- base::length
[10:26:11.754]             list <- base::list
[10:26:11.754]             seq.int <- base::seq.int
[10:26:11.754]             signalCondition <- base::signalCondition
[10:26:11.754]             sys.calls <- base::sys.calls
[10:26:11.754]             `[[` <- base::`[[`
[10:26:11.754]             `+` <- base::`+`
[10:26:11.754]             `<<-` <- base::`<<-`
[10:26:11.754]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.754]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.754]                   3L)]
[10:26:11.754]             }
[10:26:11.754]             function(cond) {
[10:26:11.754]                 is_error <- inherits(cond, "error")
[10:26:11.754]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.754]                   NULL)
[10:26:11.754]                 if (is_error) {
[10:26:11.754]                   sessionInformation <- function() {
[10:26:11.754]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.754]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.754]                       search = base::search(), system = base::Sys.info())
[10:26:11.754]                   }
[10:26:11.754]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.754]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.754]                     cond$call), session = sessionInformation(), 
[10:26:11.754]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.754]                   signalCondition(cond)
[10:26:11.754]                 }
[10:26:11.754]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.754]                 "immediateCondition"))) {
[10:26:11.754]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.754]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.754]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.754]                   if (TRUE && !signal) {
[10:26:11.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.754]                     {
[10:26:11.754]                       inherits <- base::inherits
[10:26:11.754]                       invokeRestart <- base::invokeRestart
[10:26:11.754]                       is.null <- base::is.null
[10:26:11.754]                       muffled <- FALSE
[10:26:11.754]                       if (inherits(cond, "message")) {
[10:26:11.754]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.754]                         if (muffled) 
[10:26:11.754]                           invokeRestart("muffleMessage")
[10:26:11.754]                       }
[10:26:11.754]                       else if (inherits(cond, "warning")) {
[10:26:11.754]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.754]                         if (muffled) 
[10:26:11.754]                           invokeRestart("muffleWarning")
[10:26:11.754]                       }
[10:26:11.754]                       else if (inherits(cond, "condition")) {
[10:26:11.754]                         if (!is.null(pattern)) {
[10:26:11.754]                           computeRestarts <- base::computeRestarts
[10:26:11.754]                           grepl <- base::grepl
[10:26:11.754]                           restarts <- computeRestarts(cond)
[10:26:11.754]                           for (restart in restarts) {
[10:26:11.754]                             name <- restart$name
[10:26:11.754]                             if (is.null(name)) 
[10:26:11.754]                               next
[10:26:11.754]                             if (!grepl(pattern, name)) 
[10:26:11.754]                               next
[10:26:11.754]                             invokeRestart(restart)
[10:26:11.754]                             muffled <- TRUE
[10:26:11.754]                             break
[10:26:11.754]                           }
[10:26:11.754]                         }
[10:26:11.754]                       }
[10:26:11.754]                       invisible(muffled)
[10:26:11.754]                     }
[10:26:11.754]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.754]                   }
[10:26:11.754]                 }
[10:26:11.754]                 else {
[10:26:11.754]                   if (TRUE) {
[10:26:11.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.754]                     {
[10:26:11.754]                       inherits <- base::inherits
[10:26:11.754]                       invokeRestart <- base::invokeRestart
[10:26:11.754]                       is.null <- base::is.null
[10:26:11.754]                       muffled <- FALSE
[10:26:11.754]                       if (inherits(cond, "message")) {
[10:26:11.754]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.754]                         if (muffled) 
[10:26:11.754]                           invokeRestart("muffleMessage")
[10:26:11.754]                       }
[10:26:11.754]                       else if (inherits(cond, "warning")) {
[10:26:11.754]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.754]                         if (muffled) 
[10:26:11.754]                           invokeRestart("muffleWarning")
[10:26:11.754]                       }
[10:26:11.754]                       else if (inherits(cond, "condition")) {
[10:26:11.754]                         if (!is.null(pattern)) {
[10:26:11.754]                           computeRestarts <- base::computeRestarts
[10:26:11.754]                           grepl <- base::grepl
[10:26:11.754]                           restarts <- computeRestarts(cond)
[10:26:11.754]                           for (restart in restarts) {
[10:26:11.754]                             name <- restart$name
[10:26:11.754]                             if (is.null(name)) 
[10:26:11.754]                               next
[10:26:11.754]                             if (!grepl(pattern, name)) 
[10:26:11.754]                               next
[10:26:11.754]                             invokeRestart(restart)
[10:26:11.754]                             muffled <- TRUE
[10:26:11.754]                             break
[10:26:11.754]                           }
[10:26:11.754]                         }
[10:26:11.754]                       }
[10:26:11.754]                       invisible(muffled)
[10:26:11.754]                     }
[10:26:11.754]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.754]                   }
[10:26:11.754]                 }
[10:26:11.754]             }
[10:26:11.754]         }))
[10:26:11.754]     }, error = function(ex) {
[10:26:11.754]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.754]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.754]                 ...future.rng), started = ...future.startTime, 
[10:26:11.754]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.754]             version = "1.8"), class = "FutureResult")
[10:26:11.754]     }, finally = {
[10:26:11.754]         if (!identical(...future.workdir, getwd())) 
[10:26:11.754]             setwd(...future.workdir)
[10:26:11.754]         {
[10:26:11.754]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.754]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.754]             }
[10:26:11.754]             base::options(...future.oldOptions)
[10:26:11.754]             if (.Platform$OS.type == "windows") {
[10:26:11.754]                 old_names <- names(...future.oldEnvVars)
[10:26:11.754]                 envs <- base::Sys.getenv()
[10:26:11.754]                 names <- names(envs)
[10:26:11.754]                 common <- intersect(names, old_names)
[10:26:11.754]                 added <- setdiff(names, old_names)
[10:26:11.754]                 removed <- setdiff(old_names, names)
[10:26:11.754]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.754]                   envs[common]]
[10:26:11.754]                 NAMES <- toupper(changed)
[10:26:11.754]                 args <- list()
[10:26:11.754]                 for (kk in seq_along(NAMES)) {
[10:26:11.754]                   name <- changed[[kk]]
[10:26:11.754]                   NAME <- NAMES[[kk]]
[10:26:11.754]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.754]                     next
[10:26:11.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.754]                 }
[10:26:11.754]                 NAMES <- toupper(added)
[10:26:11.754]                 for (kk in seq_along(NAMES)) {
[10:26:11.754]                   name <- added[[kk]]
[10:26:11.754]                   NAME <- NAMES[[kk]]
[10:26:11.754]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.754]                     next
[10:26:11.754]                   args[[name]] <- ""
[10:26:11.754]                 }
[10:26:11.754]                 NAMES <- toupper(removed)
[10:26:11.754]                 for (kk in seq_along(NAMES)) {
[10:26:11.754]                   name <- removed[[kk]]
[10:26:11.754]                   NAME <- NAMES[[kk]]
[10:26:11.754]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.754]                     next
[10:26:11.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.754]                 }
[10:26:11.754]                 if (length(args) > 0) 
[10:26:11.754]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.754]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.754]             }
[10:26:11.754]             else {
[10:26:11.754]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.754]             }
[10:26:11.754]             {
[10:26:11.754]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.754]                   0L) {
[10:26:11.754]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.754]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.754]                   base::options(opts)
[10:26:11.754]                 }
[10:26:11.754]                 {
[10:26:11.754]                   {
[10:26:11.754]                     NULL
[10:26:11.754]                     RNGkind("Mersenne-Twister")
[10:26:11.754]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.754]                       inherits = FALSE)
[10:26:11.754]                   }
[10:26:11.754]                   options(future.plan = NULL)
[10:26:11.754]                   if (is.na(NA_character_)) 
[10:26:11.754]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.754]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.754]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.754]                   {
[10:26:11.754]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.754]                     if (!future$lazy) 
[10:26:11.754]                       future <- run(future)
[10:26:11.754]                     invisible(future)
[10:26:11.754]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.754]                 }
[10:26:11.754]             }
[10:26:11.754]         }
[10:26:11.754]     })
[10:26:11.754]     if (TRUE) {
[10:26:11.754]         base::sink(type = "output", split = FALSE)
[10:26:11.754]         if (TRUE) {
[10:26:11.754]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.754]         }
[10:26:11.754]         else {
[10:26:11.754]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.754]         }
[10:26:11.754]         base::close(...future.stdout)
[10:26:11.754]         ...future.stdout <- NULL
[10:26:11.754]     }
[10:26:11.754]     ...future.result$conditions <- ...future.conditions
[10:26:11.754]     ...future.result$finished <- base::Sys.time()
[10:26:11.754]     ...future.result
[10:26:11.754] }
[10:26:11.755] assign_globals() ...
[10:26:11.755] List of 1
[10:26:11.755]  $ x: num 1
[10:26:11.755]  - attr(*, "where")=List of 1
[10:26:11.755]   ..$ x:<environment: R_EmptyEnv> 
[10:26:11.755]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.755]  - attr(*, "resolved")= logi TRUE
[10:26:11.755]  - attr(*, "total_size")= num 56
[10:26:11.755]  - attr(*, "already-done")= logi TRUE
[10:26:11.758] - copied ‘x’ to environment
[10:26:11.758] assign_globals() ... done
[10:26:11.758] plan(): Setting new future strategy stack:
[10:26:11.758] List of future strategies:
[10:26:11.758] 1. sequential:
[10:26:11.758]    - args: function (..., envir = parent.frame())
[10:26:11.758]    - tweaked: FALSE
[10:26:11.758]    - call: NULL
[10:26:11.758] plan(): nbrOfWorkers() = 1
[10:26:11.759] plan(): Setting new future strategy stack:
[10:26:11.759] List of future strategies:
[10:26:11.759] 1. sequential:
[10:26:11.759]    - args: function (..., envir = parent.frame())
[10:26:11.759]    - tweaked: FALSE
[10:26:11.759]    - call: plan(strategy)
[10:26:11.759] plan(): nbrOfWorkers() = 1
[10:26:11.760] SequentialFuture started (and completed)
[10:26:11.760] - Launch lazy future ... done
[10:26:11.760] run() for ‘SequentialFuture’ ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.760] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.760] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:11.762] - globals found: [3] ‘{’, ‘<-’, ‘x’
[10:26:11.762] Searching for globals ... DONE
[10:26:11.762] Resolving globals: TRUE
[10:26:11.762] Resolving any globals that are futures ...
[10:26:11.763] - globals: [3] ‘{’, ‘<-’, ‘x’
[10:26:11.763] Resolving any globals that are futures ... DONE
[10:26:11.763] Resolving futures part of globals (recursively) ...
[10:26:11.763] resolve() on list ...
[10:26:11.763]  recursive: 99
[10:26:11.763]  length: 1
[10:26:11.763]  elements: ‘x’
[10:26:11.763]  length: 0 (resolved future 1)
[10:26:11.764] resolve() on list ... DONE
[10:26:11.764] - globals: [1] ‘x’
[10:26:11.764] Resolving futures part of globals (recursively) ... DONE
[10:26:11.764] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[10:26:11.765] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[10:26:11.766] - globals: [1] ‘x’
[10:26:11.766] 
[10:26:11.766] getGlobalsAndPackages() ... DONE
[10:26:11.766] run() for ‘Future’ ...
[10:26:11.766] - state: ‘created’
[10:26:11.766] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:11.766] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:11.767] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:11.767]   - Field: ‘label’
[10:26:11.767]   - Field: ‘local’
[10:26:11.767]   - Field: ‘owner’
[10:26:11.767]   - Field: ‘envir’
[10:26:11.767]   - Field: ‘packages’
[10:26:11.767]   - Field: ‘gc’
[10:26:11.767]   - Field: ‘conditions’
[10:26:11.767]   - Field: ‘expr’
[10:26:11.767]   - Field: ‘uuid’
[10:26:11.768]   - Field: ‘seed’
[10:26:11.768]   - Field: ‘version’
[10:26:11.768]   - Field: ‘result’
[10:26:11.768]   - Field: ‘asynchronous’
[10:26:11.768]   - Field: ‘calls’
[10:26:11.768]   - Field: ‘globals’
[10:26:11.768]   - Field: ‘stdout’
[10:26:11.768]   - Field: ‘earlySignal’
[10:26:11.768]   - Field: ‘lazy’
[10:26:11.768]   - Field: ‘state’
[10:26:11.768] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:11.769] - Launch lazy future ...
[10:26:11.769] Packages needed by the future expression (n = 0): <none>
[10:26:11.769] Packages needed by future strategies (n = 0): <none>
[10:26:11.769] {
[10:26:11.769]     {
[10:26:11.769]         {
[10:26:11.769]             ...future.startTime <- base::Sys.time()
[10:26:11.769]             {
[10:26:11.769]                 {
[10:26:11.769]                   {
[10:26:11.769]                     base::local({
[10:26:11.769]                       has_future <- base::requireNamespace("future", 
[10:26:11.769]                         quietly = TRUE)
[10:26:11.769]                       if (has_future) {
[10:26:11.769]                         ns <- base::getNamespace("future")
[10:26:11.769]                         version <- ns[[".package"]][["version"]]
[10:26:11.769]                         if (is.null(version)) 
[10:26:11.769]                           version <- utils::packageVersion("future")
[10:26:11.769]                       }
[10:26:11.769]                       else {
[10:26:11.769]                         version <- NULL
[10:26:11.769]                       }
[10:26:11.769]                       if (!has_future || version < "1.8.0") {
[10:26:11.769]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.769]                           "", base::R.version$version.string), 
[10:26:11.769]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:11.769]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.769]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.769]                             "release", "version")], collapse = " "), 
[10:26:11.769]                           hostname = base::Sys.info()[["nodename"]])
[10:26:11.769]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.769]                           info)
[10:26:11.769]                         info <- base::paste(info, collapse = "; ")
[10:26:11.769]                         if (!has_future) {
[10:26:11.769]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.769]                             info)
[10:26:11.769]                         }
[10:26:11.769]                         else {
[10:26:11.769]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.769]                             info, version)
[10:26:11.769]                         }
[10:26:11.769]                         base::stop(msg)
[10:26:11.769]                       }
[10:26:11.769]                     })
[10:26:11.769]                   }
[10:26:11.769]                   options(future.plan = NULL)
[10:26:11.769]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.769]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.769]                 }
[10:26:11.769]                 ...future.workdir <- getwd()
[10:26:11.769]             }
[10:26:11.769]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.769]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.769]         }
[10:26:11.769]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.769]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:11.769]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.769]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.769]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.769]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.769]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.769]             base::names(...future.oldOptions))
[10:26:11.769]     }
[10:26:11.769]     if (FALSE) {
[10:26:11.769]     }
[10:26:11.769]     else {
[10:26:11.769]         if (TRUE) {
[10:26:11.769]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.769]                 open = "w")
[10:26:11.769]         }
[10:26:11.769]         else {
[10:26:11.769]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.769]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.769]         }
[10:26:11.769]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.769]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.769]             base::sink(type = "output", split = FALSE)
[10:26:11.769]             base::close(...future.stdout)
[10:26:11.769]         }, add = TRUE)
[10:26:11.769]     }
[10:26:11.769]     ...future.frame <- base::sys.nframe()
[10:26:11.769]     ...future.conditions <- base::list()
[10:26:11.769]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.769]     if (FALSE) {
[10:26:11.769]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.769]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.769]     }
[10:26:11.769]     ...future.result <- base::tryCatch({
[10:26:11.769]         base::withCallingHandlers({
[10:26:11.769]             ...future.value <- base::withVisible(base::local({
[10:26:11.769]                 x <- x()
[10:26:11.769]                 x
[10:26:11.769]             }))
[10:26:11.769]             future::FutureResult(value = ...future.value$value, 
[10:26:11.769]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.769]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.769]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.769]                     ...future.globalenv.names))
[10:26:11.769]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.769]         }, condition = base::local({
[10:26:11.769]             c <- base::c
[10:26:11.769]             inherits <- base::inherits
[10:26:11.769]             invokeRestart <- base::invokeRestart
[10:26:11.769]             length <- base::length
[10:26:11.769]             list <- base::list
[10:26:11.769]             seq.int <- base::seq.int
[10:26:11.769]             signalCondition <- base::signalCondition
[10:26:11.769]             sys.calls <- base::sys.calls
[10:26:11.769]             `[[` <- base::`[[`
[10:26:11.769]             `+` <- base::`+`
[10:26:11.769]             `<<-` <- base::`<<-`
[10:26:11.769]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.769]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.769]                   3L)]
[10:26:11.769]             }
[10:26:11.769]             function(cond) {
[10:26:11.769]                 is_error <- inherits(cond, "error")
[10:26:11.769]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.769]                   NULL)
[10:26:11.769]                 if (is_error) {
[10:26:11.769]                   sessionInformation <- function() {
[10:26:11.769]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.769]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.769]                       search = base::search(), system = base::Sys.info())
[10:26:11.769]                   }
[10:26:11.769]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.769]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.769]                     cond$call), session = sessionInformation(), 
[10:26:11.769]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.769]                   signalCondition(cond)
[10:26:11.769]                 }
[10:26:11.769]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.769]                 "immediateCondition"))) {
[10:26:11.769]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.769]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.769]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.769]                   if (TRUE && !signal) {
[10:26:11.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.769]                     {
[10:26:11.769]                       inherits <- base::inherits
[10:26:11.769]                       invokeRestart <- base::invokeRestart
[10:26:11.769]                       is.null <- base::is.null
[10:26:11.769]                       muffled <- FALSE
[10:26:11.769]                       if (inherits(cond, "message")) {
[10:26:11.769]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.769]                         if (muffled) 
[10:26:11.769]                           invokeRestart("muffleMessage")
[10:26:11.769]                       }
[10:26:11.769]                       else if (inherits(cond, "warning")) {
[10:26:11.769]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.769]                         if (muffled) 
[10:26:11.769]                           invokeRestart("muffleWarning")
[10:26:11.769]                       }
[10:26:11.769]                       else if (inherits(cond, "condition")) {
[10:26:11.769]                         if (!is.null(pattern)) {
[10:26:11.769]                           computeRestarts <- base::computeRestarts
[10:26:11.769]                           grepl <- base::grepl
[10:26:11.769]                           restarts <- computeRestarts(cond)
[10:26:11.769]                           for (restart in restarts) {
[10:26:11.769]                             name <- restart$name
[10:26:11.769]                             if (is.null(name)) 
[10:26:11.769]                               next
[10:26:11.769]                             if (!grepl(pattern, name)) 
[10:26:11.769]                               next
[10:26:11.769]                             invokeRestart(restart)
[10:26:11.769]                             muffled <- TRUE
[10:26:11.769]                             break
[10:26:11.769]                           }
[10:26:11.769]                         }
[10:26:11.769]                       }
[10:26:11.769]                       invisible(muffled)
[10:26:11.769]                     }
[10:26:11.769]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.769]                   }
[10:26:11.769]                 }
[10:26:11.769]                 else {
[10:26:11.769]                   if (TRUE) {
[10:26:11.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.769]                     {
[10:26:11.769]                       inherits <- base::inherits
[10:26:11.769]                       invokeRestart <- base::invokeRestart
[10:26:11.769]                       is.null <- base::is.null
[10:26:11.769]                       muffled <- FALSE
[10:26:11.769]                       if (inherits(cond, "message")) {
[10:26:11.769]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.769]                         if (muffled) 
[10:26:11.769]                           invokeRestart("muffleMessage")
[10:26:11.769]                       }
[10:26:11.769]                       else if (inherits(cond, "warning")) {
[10:26:11.769]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.769]                         if (muffled) 
[10:26:11.769]                           invokeRestart("muffleWarning")
[10:26:11.769]                       }
[10:26:11.769]                       else if (inherits(cond, "condition")) {
[10:26:11.769]                         if (!is.null(pattern)) {
[10:26:11.769]                           computeRestarts <- base::computeRestarts
[10:26:11.769]                           grepl <- base::grepl
[10:26:11.769]                           restarts <- computeRestarts(cond)
[10:26:11.769]                           for (restart in restarts) {
[10:26:11.769]                             name <- restart$name
[10:26:11.769]                             if (is.null(name)) 
[10:26:11.769]                               next
[10:26:11.769]                             if (!grepl(pattern, name)) 
[10:26:11.769]                               next
[10:26:11.769]                             invokeRestart(restart)
[10:26:11.769]                             muffled <- TRUE
[10:26:11.769]                             break
[10:26:11.769]                           }
[10:26:11.769]                         }
[10:26:11.769]                       }
[10:26:11.769]                       invisible(muffled)
[10:26:11.769]                     }
[10:26:11.769]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.769]                   }
[10:26:11.769]                 }
[10:26:11.769]             }
[10:26:11.769]         }))
[10:26:11.769]     }, error = function(ex) {
[10:26:11.769]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.769]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.769]                 ...future.rng), started = ...future.startTime, 
[10:26:11.769]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.769]             version = "1.8"), class = "FutureResult")
[10:26:11.769]     }, finally = {
[10:26:11.769]         if (!identical(...future.workdir, getwd())) 
[10:26:11.769]             setwd(...future.workdir)
[10:26:11.769]         {
[10:26:11.769]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.769]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.769]             }
[10:26:11.769]             base::options(...future.oldOptions)
[10:26:11.769]             if (.Platform$OS.type == "windows") {
[10:26:11.769]                 old_names <- names(...future.oldEnvVars)
[10:26:11.769]                 envs <- base::Sys.getenv()
[10:26:11.769]                 names <- names(envs)
[10:26:11.769]                 common <- intersect(names, old_names)
[10:26:11.769]                 added <- setdiff(names, old_names)
[10:26:11.769]                 removed <- setdiff(old_names, names)
[10:26:11.769]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.769]                   envs[common]]
[10:26:11.769]                 NAMES <- toupper(changed)
[10:26:11.769]                 args <- list()
[10:26:11.769]                 for (kk in seq_along(NAMES)) {
[10:26:11.769]                   name <- changed[[kk]]
[10:26:11.769]                   NAME <- NAMES[[kk]]
[10:26:11.769]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.769]                     next
[10:26:11.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.769]                 }
[10:26:11.769]                 NAMES <- toupper(added)
[10:26:11.769]                 for (kk in seq_along(NAMES)) {
[10:26:11.769]                   name <- added[[kk]]
[10:26:11.769]                   NAME <- NAMES[[kk]]
[10:26:11.769]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.769]                     next
[10:26:11.769]                   args[[name]] <- ""
[10:26:11.769]                 }
[10:26:11.769]                 NAMES <- toupper(removed)
[10:26:11.769]                 for (kk in seq_along(NAMES)) {
[10:26:11.769]                   name <- removed[[kk]]
[10:26:11.769]                   NAME <- NAMES[[kk]]
[10:26:11.769]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.769]                     next
[10:26:11.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.769]                 }
[10:26:11.769]                 if (length(args) > 0) 
[10:26:11.769]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.769]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.769]             }
[10:26:11.769]             else {
[10:26:11.769]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.769]             }
[10:26:11.769]             {
[10:26:11.769]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.769]                   0L) {
[10:26:11.769]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.769]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.769]                   base::options(opts)
[10:26:11.769]                 }
[10:26:11.769]                 {
[10:26:11.769]                   {
[10:26:11.769]                     NULL
[10:26:11.769]                     RNGkind("Mersenne-Twister")
[10:26:11.769]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:11.769]                       inherits = FALSE)
[10:26:11.769]                   }
[10:26:11.769]                   options(future.plan = NULL)
[10:26:11.769]                   if (is.na(NA_character_)) 
[10:26:11.769]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.769]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.769]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:11.769]                   {
[10:26:11.769]                     future <- SequentialFuture(..., envir = envir)
[10:26:11.769]                     if (!future$lazy) 
[10:26:11.769]                       future <- run(future)
[10:26:11.769]                     invisible(future)
[10:26:11.769]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.769]                 }
[10:26:11.769]             }
[10:26:11.769]         }
[10:26:11.769]     })
[10:26:11.769]     if (TRUE) {
[10:26:11.769]         base::sink(type = "output", split = FALSE)
[10:26:11.769]         if (TRUE) {
[10:26:11.769]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.769]         }
[10:26:11.769]         else {
[10:26:11.769]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.769]         }
[10:26:11.769]         base::close(...future.stdout)
[10:26:11.769]         ...future.stdout <- NULL
[10:26:11.769]     }
[10:26:11.769]     ...future.result$conditions <- ...future.conditions
[10:26:11.769]     ...future.result$finished <- base::Sys.time()
[10:26:11.769]     ...future.result
[10:26:11.769] }
[10:26:11.771] assign_globals() ...
[10:26:11.771] List of 1
[10:26:11.771]  $ x:function ()  
[10:26:11.771]  - attr(*, "where")=List of 1
[10:26:11.771]   ..$ x:<environment: R_EmptyEnv> 
[10:26:11.771]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.771]  - attr(*, "resolved")= logi TRUE
[10:26:11.771]  - attr(*, "total_size")= num 1032
[10:26:11.771]  - attr(*, "already-done")= logi TRUE
[10:26:11.773] - reassign environment for ‘x’
[10:26:11.773] - copied ‘x’ to environment
[10:26:11.773] assign_globals() ... done
[10:26:11.774] plan(): Setting new future strategy stack:
[10:26:11.774] List of future strategies:
[10:26:11.774] 1. sequential:
[10:26:11.774]    - args: function (..., envir = parent.frame())
[10:26:11.774]    - tweaked: FALSE
[10:26:11.774]    - call: NULL
[10:26:11.774] plan(): nbrOfWorkers() = 1
[10:26:11.775] plan(): Setting new future strategy stack:
[10:26:11.775] List of future strategies:
[10:26:11.775] 1. sequential:
[10:26:11.775]    - args: function (..., envir = parent.frame())
[10:26:11.775]    - tweaked: FALSE
[10:26:11.775]    - call: plan(strategy)
[10:26:11.775] plan(): nbrOfWorkers() = 1
[10:26:11.775] SequentialFuture started (and completed)
[10:26:11.775] - Launch lazy future ... done
[10:26:11.775] run() for ‘SequentialFuture’ ... done
value(f) = ‘TRUE’
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- Local variables with the same name as globals ...
- plan('multicore') ...
[10:26:11.784] plan(): Setting new future strategy stack:
[10:26:11.784] List of future strategies:
[10:26:11.784] 1. multicore:
[10:26:11.784]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:11.784]    - tweaked: FALSE
[10:26:11.784]    - call: plan(strategy)
[10:26:11.787] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.788] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.788] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:11.789] - globals found: [3] ‘{’, ‘<-’, ‘*’
[10:26:11.789] Searching for globals ... DONE
[10:26:11.789] Resolving globals: TRUE
[10:26:11.789] Resolving any globals that are futures ...
[10:26:11.790] - globals: [3] ‘{’, ‘<-’, ‘*’
[10:26:11.790] Resolving any globals that are futures ... DONE
[10:26:11.790] 
[10:26:11.790] 
[10:26:11.790] getGlobalsAndPackages() ... DONE
[10:26:11.790] run() for ‘Future’ ...
[10:26:11.790] - state: ‘created’
[10:26:11.791] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:11.794] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:11.794] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:11.794]   - Field: ‘label’
[10:26:11.794]   - Field: ‘local’
[10:26:11.794]   - Field: ‘owner’
[10:26:11.795]   - Field: ‘envir’
[10:26:11.795]   - Field: ‘workers’
[10:26:11.796]   - Field: ‘packages’
[10:26:11.796]   - Field: ‘gc’
[10:26:11.796]   - Field: ‘job’
[10:26:11.796]   - Field: ‘conditions’
[10:26:11.796]   - Field: ‘expr’
[10:26:11.796]   - Field: ‘uuid’
[10:26:11.796]   - Field: ‘seed’
[10:26:11.796]   - Field: ‘version’
[10:26:11.797]   - Field: ‘result’
[10:26:11.797]   - Field: ‘asynchronous’
[10:26:11.797]   - Field: ‘calls’
[10:26:11.797]   - Field: ‘globals’
[10:26:11.797]   - Field: ‘stdout’
[10:26:11.797]   - Field: ‘earlySignal’
[10:26:11.797]   - Field: ‘lazy’
[10:26:11.797]   - Field: ‘state’
[10:26:11.797] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:11.797] - Launch lazy future ...
[10:26:11.798] Packages needed by the future expression (n = 0): <none>
[10:26:11.799] Packages needed by future strategies (n = 0): <none>
[10:26:11.799] {
[10:26:11.799]     {
[10:26:11.799]         {
[10:26:11.799]             ...future.startTime <- base::Sys.time()
[10:26:11.799]             {
[10:26:11.799]                 {
[10:26:11.799]                   {
[10:26:11.799]                     {
[10:26:11.799]                       base::local({
[10:26:11.799]                         has_future <- base::requireNamespace("future", 
[10:26:11.799]                           quietly = TRUE)
[10:26:11.799]                         if (has_future) {
[10:26:11.799]                           ns <- base::getNamespace("future")
[10:26:11.799]                           version <- ns[[".package"]][["version"]]
[10:26:11.799]                           if (is.null(version)) 
[10:26:11.799]                             version <- utils::packageVersion("future")
[10:26:11.799]                         }
[10:26:11.799]                         else {
[10:26:11.799]                           version <- NULL
[10:26:11.799]                         }
[10:26:11.799]                         if (!has_future || version < "1.8.0") {
[10:26:11.799]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.799]                             "", base::R.version$version.string), 
[10:26:11.799]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:11.799]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.799]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.799]                               "release", "version")], collapse = " "), 
[10:26:11.799]                             hostname = base::Sys.info()[["nodename"]])
[10:26:11.799]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.799]                             info)
[10:26:11.799]                           info <- base::paste(info, collapse = "; ")
[10:26:11.799]                           if (!has_future) {
[10:26:11.799]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.799]                               info)
[10:26:11.799]                           }
[10:26:11.799]                           else {
[10:26:11.799]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.799]                               info, version)
[10:26:11.799]                           }
[10:26:11.799]                           base::stop(msg)
[10:26:11.799]                         }
[10:26:11.799]                       })
[10:26:11.799]                     }
[10:26:11.799]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:11.799]                     base::options(mc.cores = 1L)
[10:26:11.799]                   }
[10:26:11.799]                   options(future.plan = NULL)
[10:26:11.799]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.799]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.799]                 }
[10:26:11.799]                 ...future.workdir <- getwd()
[10:26:11.799]             }
[10:26:11.799]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.799]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.799]         }
[10:26:11.799]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.799]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:11.799]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.799]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.799]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.799]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.799]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.799]             base::names(...future.oldOptions))
[10:26:11.799]     }
[10:26:11.799]     if (FALSE) {
[10:26:11.799]     }
[10:26:11.799]     else {
[10:26:11.799]         if (TRUE) {
[10:26:11.799]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.799]                 open = "w")
[10:26:11.799]         }
[10:26:11.799]         else {
[10:26:11.799]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.799]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.799]         }
[10:26:11.799]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.799]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.799]             base::sink(type = "output", split = FALSE)
[10:26:11.799]             base::close(...future.stdout)
[10:26:11.799]         }, add = TRUE)
[10:26:11.799]     }
[10:26:11.799]     ...future.frame <- base::sys.nframe()
[10:26:11.799]     ...future.conditions <- base::list()
[10:26:11.799]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.799]     if (FALSE) {
[10:26:11.799]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.799]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.799]     }
[10:26:11.799]     ...future.result <- base::tryCatch({
[10:26:11.799]         base::withCallingHandlers({
[10:26:11.799]             ...future.value <- base::withVisible(base::local({
[10:26:11.799]                 withCallingHandlers({
[10:26:11.799]                   {
[10:26:11.799]                     b <- a
[10:26:11.799]                     a <- 2
[10:26:11.799]                     a * b
[10:26:11.799]                   }
[10:26:11.799]                 }, immediateCondition = function(cond) {
[10:26:11.799]                   save_rds <- function (object, pathname, ...) 
[10:26:11.799]                   {
[10:26:11.799]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:11.799]                     if (file_test("-f", pathname_tmp)) {
[10:26:11.799]                       fi_tmp <- file.info(pathname_tmp)
[10:26:11.799]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:11.799]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:11.799]                         fi_tmp[["mtime"]])
[10:26:11.799]                     }
[10:26:11.799]                     tryCatch({
[10:26:11.799]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:11.799]                     }, error = function(ex) {
[10:26:11.799]                       msg <- conditionMessage(ex)
[10:26:11.799]                       fi_tmp <- file.info(pathname_tmp)
[10:26:11.799]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:11.799]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:11.799]                         fi_tmp[["mtime"]], msg)
[10:26:11.799]                       ex$message <- msg
[10:26:11.799]                       stop(ex)
[10:26:11.799]                     })
[10:26:11.799]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:11.799]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:11.799]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:11.799]                       fi_tmp <- file.info(pathname_tmp)
[10:26:11.799]                       fi <- file.info(pathname)
[10:26:11.799]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:11.799]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:11.799]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:11.799]                         fi[["size"]], fi[["mtime"]])
[10:26:11.799]                       stop(msg)
[10:26:11.799]                     }
[10:26:11.799]                     invisible(pathname)
[10:26:11.799]                   }
[10:26:11.799]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:11.799]                     rootPath = tempdir()) 
[10:26:11.799]                   {
[10:26:11.799]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:11.799]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:11.799]                       tmpdir = path, fileext = ".rds")
[10:26:11.799]                     save_rds(obj, file)
[10:26:11.799]                   }
[10:26:11.799]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:11.799]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.799]                   {
[10:26:11.799]                     inherits <- base::inherits
[10:26:11.799]                     invokeRestart <- base::invokeRestart
[10:26:11.799]                     is.null <- base::is.null
[10:26:11.799]                     muffled <- FALSE
[10:26:11.799]                     if (inherits(cond, "message")) {
[10:26:11.799]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:11.799]                       if (muffled) 
[10:26:11.799]                         invokeRestart("muffleMessage")
[10:26:11.799]                     }
[10:26:11.799]                     else if (inherits(cond, "warning")) {
[10:26:11.799]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:11.799]                       if (muffled) 
[10:26:11.799]                         invokeRestart("muffleWarning")
[10:26:11.799]                     }
[10:26:11.799]                     else if (inherits(cond, "condition")) {
[10:26:11.799]                       if (!is.null(pattern)) {
[10:26:11.799]                         computeRestarts <- base::computeRestarts
[10:26:11.799]                         grepl <- base::grepl
[10:26:11.799]                         restarts <- computeRestarts(cond)
[10:26:11.799]                         for (restart in restarts) {
[10:26:11.799]                           name <- restart$name
[10:26:11.799]                           if (is.null(name)) 
[10:26:11.799]                             next
[10:26:11.799]                           if (!grepl(pattern, name)) 
[10:26:11.799]                             next
[10:26:11.799]                           invokeRestart(restart)
[10:26:11.799]                           muffled <- TRUE
[10:26:11.799]                           break
[10:26:11.799]                         }
[10:26:11.799]                       }
[10:26:11.799]                     }
[10:26:11.799]                     invisible(muffled)
[10:26:11.799]                   }
[10:26:11.799]                   muffleCondition(cond)
[10:26:11.799]                 })
[10:26:11.799]             }))
[10:26:11.799]             future::FutureResult(value = ...future.value$value, 
[10:26:11.799]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.799]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.799]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.799]                     ...future.globalenv.names))
[10:26:11.799]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.799]         }, condition = base::local({
[10:26:11.799]             c <- base::c
[10:26:11.799]             inherits <- base::inherits
[10:26:11.799]             invokeRestart <- base::invokeRestart
[10:26:11.799]             length <- base::length
[10:26:11.799]             list <- base::list
[10:26:11.799]             seq.int <- base::seq.int
[10:26:11.799]             signalCondition <- base::signalCondition
[10:26:11.799]             sys.calls <- base::sys.calls
[10:26:11.799]             `[[` <- base::`[[`
[10:26:11.799]             `+` <- base::`+`
[10:26:11.799]             `<<-` <- base::`<<-`
[10:26:11.799]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.799]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.799]                   3L)]
[10:26:11.799]             }
[10:26:11.799]             function(cond) {
[10:26:11.799]                 is_error <- inherits(cond, "error")
[10:26:11.799]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.799]                   NULL)
[10:26:11.799]                 if (is_error) {
[10:26:11.799]                   sessionInformation <- function() {
[10:26:11.799]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.799]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.799]                       search = base::search(), system = base::Sys.info())
[10:26:11.799]                   }
[10:26:11.799]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.799]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.799]                     cond$call), session = sessionInformation(), 
[10:26:11.799]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.799]                   signalCondition(cond)
[10:26:11.799]                 }
[10:26:11.799]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.799]                 "immediateCondition"))) {
[10:26:11.799]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.799]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.799]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.799]                   if (TRUE && !signal) {
[10:26:11.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.799]                     {
[10:26:11.799]                       inherits <- base::inherits
[10:26:11.799]                       invokeRestart <- base::invokeRestart
[10:26:11.799]                       is.null <- base::is.null
[10:26:11.799]                       muffled <- FALSE
[10:26:11.799]                       if (inherits(cond, "message")) {
[10:26:11.799]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.799]                         if (muffled) 
[10:26:11.799]                           invokeRestart("muffleMessage")
[10:26:11.799]                       }
[10:26:11.799]                       else if (inherits(cond, "warning")) {
[10:26:11.799]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.799]                         if (muffled) 
[10:26:11.799]                           invokeRestart("muffleWarning")
[10:26:11.799]                       }
[10:26:11.799]                       else if (inherits(cond, "condition")) {
[10:26:11.799]                         if (!is.null(pattern)) {
[10:26:11.799]                           computeRestarts <- base::computeRestarts
[10:26:11.799]                           grepl <- base::grepl
[10:26:11.799]                           restarts <- computeRestarts(cond)
[10:26:11.799]                           for (restart in restarts) {
[10:26:11.799]                             name <- restart$name
[10:26:11.799]                             if (is.null(name)) 
[10:26:11.799]                               next
[10:26:11.799]                             if (!grepl(pattern, name)) 
[10:26:11.799]                               next
[10:26:11.799]                             invokeRestart(restart)
[10:26:11.799]                             muffled <- TRUE
[10:26:11.799]                             break
[10:26:11.799]                           }
[10:26:11.799]                         }
[10:26:11.799]                       }
[10:26:11.799]                       invisible(muffled)
[10:26:11.799]                     }
[10:26:11.799]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.799]                   }
[10:26:11.799]                 }
[10:26:11.799]                 else {
[10:26:11.799]                   if (TRUE) {
[10:26:11.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.799]                     {
[10:26:11.799]                       inherits <- base::inherits
[10:26:11.799]                       invokeRestart <- base::invokeRestart
[10:26:11.799]                       is.null <- base::is.null
[10:26:11.799]                       muffled <- FALSE
[10:26:11.799]                       if (inherits(cond, "message")) {
[10:26:11.799]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.799]                         if (muffled) 
[10:26:11.799]                           invokeRestart("muffleMessage")
[10:26:11.799]                       }
[10:26:11.799]                       else if (inherits(cond, "warning")) {
[10:26:11.799]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.799]                         if (muffled) 
[10:26:11.799]                           invokeRestart("muffleWarning")
[10:26:11.799]                       }
[10:26:11.799]                       else if (inherits(cond, "condition")) {
[10:26:11.799]                         if (!is.null(pattern)) {
[10:26:11.799]                           computeRestarts <- base::computeRestarts
[10:26:11.799]                           grepl <- base::grepl
[10:26:11.799]                           restarts <- computeRestarts(cond)
[10:26:11.799]                           for (restart in restarts) {
[10:26:11.799]                             name <- restart$name
[10:26:11.799]                             if (is.null(name)) 
[10:26:11.799]                               next
[10:26:11.799]                             if (!grepl(pattern, name)) 
[10:26:11.799]                               next
[10:26:11.799]                             invokeRestart(restart)
[10:26:11.799]                             muffled <- TRUE
[10:26:11.799]                             break
[10:26:11.799]                           }
[10:26:11.799]                         }
[10:26:11.799]                       }
[10:26:11.799]                       invisible(muffled)
[10:26:11.799]                     }
[10:26:11.799]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.799]                   }
[10:26:11.799]                 }
[10:26:11.799]             }
[10:26:11.799]         }))
[10:26:11.799]     }, error = function(ex) {
[10:26:11.799]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.799]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.799]                 ...future.rng), started = ...future.startTime, 
[10:26:11.799]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.799]             version = "1.8"), class = "FutureResult")
[10:26:11.799]     }, finally = {
[10:26:11.799]         if (!identical(...future.workdir, getwd())) 
[10:26:11.799]             setwd(...future.workdir)
[10:26:11.799]         {
[10:26:11.799]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.799]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.799]             }
[10:26:11.799]             base::options(...future.oldOptions)
[10:26:11.799]             if (.Platform$OS.type == "windows") {
[10:26:11.799]                 old_names <- names(...future.oldEnvVars)
[10:26:11.799]                 envs <- base::Sys.getenv()
[10:26:11.799]                 names <- names(envs)
[10:26:11.799]                 common <- intersect(names, old_names)
[10:26:11.799]                 added <- setdiff(names, old_names)
[10:26:11.799]                 removed <- setdiff(old_names, names)
[10:26:11.799]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.799]                   envs[common]]
[10:26:11.799]                 NAMES <- toupper(changed)
[10:26:11.799]                 args <- list()
[10:26:11.799]                 for (kk in seq_along(NAMES)) {
[10:26:11.799]                   name <- changed[[kk]]
[10:26:11.799]                   NAME <- NAMES[[kk]]
[10:26:11.799]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.799]                     next
[10:26:11.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.799]                 }
[10:26:11.799]                 NAMES <- toupper(added)
[10:26:11.799]                 for (kk in seq_along(NAMES)) {
[10:26:11.799]                   name <- added[[kk]]
[10:26:11.799]                   NAME <- NAMES[[kk]]
[10:26:11.799]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.799]                     next
[10:26:11.799]                   args[[name]] <- ""
[10:26:11.799]                 }
[10:26:11.799]                 NAMES <- toupper(removed)
[10:26:11.799]                 for (kk in seq_along(NAMES)) {
[10:26:11.799]                   name <- removed[[kk]]
[10:26:11.799]                   NAME <- NAMES[[kk]]
[10:26:11.799]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.799]                     next
[10:26:11.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.799]                 }
[10:26:11.799]                 if (length(args) > 0) 
[10:26:11.799]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.799]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.799]             }
[10:26:11.799]             else {
[10:26:11.799]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.799]             }
[10:26:11.799]             {
[10:26:11.799]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.799]                   0L) {
[10:26:11.799]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.799]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.799]                   base::options(opts)
[10:26:11.799]                 }
[10:26:11.799]                 {
[10:26:11.799]                   {
[10:26:11.799]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:11.799]                     NULL
[10:26:11.799]                   }
[10:26:11.799]                   options(future.plan = NULL)
[10:26:11.799]                   if (is.na(NA_character_)) 
[10:26:11.799]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.799]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.799]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:11.799]                     envir = parent.frame()) 
[10:26:11.799]                   {
[10:26:11.799]                     default_workers <- missing(workers)
[10:26:11.799]                     if (is.function(workers)) 
[10:26:11.799]                       workers <- workers()
[10:26:11.799]                     workers <- structure(as.integer(workers), 
[10:26:11.799]                       class = class(workers))
[10:26:11.799]                     stop_if_not(is.finite(workers), workers >= 
[10:26:11.799]                       1L)
[10:26:11.799]                     if ((workers == 1L && !inherits(workers, 
[10:26:11.799]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:11.799]                       if (default_workers) 
[10:26:11.799]                         supportsMulticore(warn = TRUE)
[10:26:11.799]                       return(sequential(..., envir = envir))
[10:26:11.799]                     }
[10:26:11.799]                     oopts <- options(mc.cores = workers)
[10:26:11.799]                     on.exit(options(oopts))
[10:26:11.799]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:11.799]                       envir = envir)
[10:26:11.799]                     if (!future$lazy) 
[10:26:11.799]                       future <- run(future)
[10:26:11.799]                     invisible(future)
[10:26:11.799]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.799]                 }
[10:26:11.799]             }
[10:26:11.799]         }
[10:26:11.799]     })
[10:26:11.799]     if (TRUE) {
[10:26:11.799]         base::sink(type = "output", split = FALSE)
[10:26:11.799]         if (TRUE) {
[10:26:11.799]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.799]         }
[10:26:11.799]         else {
[10:26:11.799]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.799]         }
[10:26:11.799]         base::close(...future.stdout)
[10:26:11.799]         ...future.stdout <- NULL
[10:26:11.799]     }
[10:26:11.799]     ...future.result$conditions <- ...future.conditions
[10:26:11.799]     ...future.result$finished <- base::Sys.time()
[10:26:11.799]     ...future.result
[10:26:11.799] }
[10:26:11.801] requestCore(): workers = 2
[10:26:11.804] MulticoreFuture started
[10:26:11.805] - Launch lazy future ... done
[10:26:11.805] plan(): Setting new future strategy stack:
[10:26:11.805] run() for ‘MulticoreFuture’ ... done
[10:26:11.806] List of future strategies:
[10:26:11.806] 1. sequential:
[10:26:11.806]    - args: function (..., envir = parent.frame())
[10:26:11.806]    - tweaked: FALSE
[10:26:11.806]    - call: NULL
[10:26:11.807] plan(): nbrOfWorkers() = 1
[10:26:11.807] result() for MulticoreFuture ...
[10:26:11.809] plan(): Setting new future strategy stack:
[10:26:11.809] List of future strategies:
[10:26:11.809] 1. multicore:
[10:26:11.809]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:11.809]    - tweaked: FALSE
[10:26:11.809]    - call: plan(strategy)
[10:26:11.815] plan(): nbrOfWorkers() = 2
[10:26:11.819] result() for MulticoreFuture ...
[10:26:11.820] result() for MulticoreFuture ... done
[10:26:11.820] result() for MulticoreFuture ... done
[10:26:11.820] result() for MulticoreFuture ...
[10:26:11.820] result() for MulticoreFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.821] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.821] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:11.823] - globals found: [3] ‘{’, ‘<-’, ‘*’
[10:26:11.823] Searching for globals ... DONE
[10:26:11.823] Resolving globals: TRUE
[10:26:11.823] Resolving any globals that are futures ...
[10:26:11.823] - globals: [3] ‘{’, ‘<-’, ‘*’
[10:26:11.823] Resolving any globals that are futures ... DONE
[10:26:11.824] 
[10:26:11.824] 
[10:26:11.824] getGlobalsAndPackages() ... DONE
[10:26:11.824] run() for ‘Future’ ...
[10:26:11.824] - state: ‘created’
[10:26:11.824] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:11.828] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:11.829] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:11.829]   - Field: ‘label’
[10:26:11.829]   - Field: ‘local’
[10:26:11.829]   - Field: ‘owner’
[10:26:11.829]   - Field: ‘envir’
[10:26:11.829]   - Field: ‘workers’
[10:26:11.829]   - Field: ‘packages’
[10:26:11.829]   - Field: ‘gc’
[10:26:11.830]   - Field: ‘job’
[10:26:11.830]   - Field: ‘conditions’
[10:26:11.830]   - Field: ‘expr’
[10:26:11.830]   - Field: ‘uuid’
[10:26:11.830]   - Field: ‘seed’
[10:26:11.830]   - Field: ‘version’
[10:26:11.830]   - Field: ‘result’
[10:26:11.830]   - Field: ‘asynchronous’
[10:26:11.830]   - Field: ‘calls’
[10:26:11.831]   - Field: ‘globals’
[10:26:11.831]   - Field: ‘stdout’
[10:26:11.831]   - Field: ‘earlySignal’
[10:26:11.831]   - Field: ‘lazy’
[10:26:11.831]   - Field: ‘state’
[10:26:11.831] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:11.831] - Launch lazy future ...
[10:26:11.832] Packages needed by the future expression (n = 0): <none>
[10:26:11.832] Packages needed by future strategies (n = 0): <none>
[10:26:11.832] {
[10:26:11.832]     {
[10:26:11.832]         {
[10:26:11.832]             ...future.startTime <- base::Sys.time()
[10:26:11.832]             {
[10:26:11.832]                 {
[10:26:11.832]                   {
[10:26:11.832]                     {
[10:26:11.832]                       base::local({
[10:26:11.832]                         has_future <- base::requireNamespace("future", 
[10:26:11.832]                           quietly = TRUE)
[10:26:11.832]                         if (has_future) {
[10:26:11.832]                           ns <- base::getNamespace("future")
[10:26:11.832]                           version <- ns[[".package"]][["version"]]
[10:26:11.832]                           if (is.null(version)) 
[10:26:11.832]                             version <- utils::packageVersion("future")
[10:26:11.832]                         }
[10:26:11.832]                         else {
[10:26:11.832]                           version <- NULL
[10:26:11.832]                         }
[10:26:11.832]                         if (!has_future || version < "1.8.0") {
[10:26:11.832]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.832]                             "", base::R.version$version.string), 
[10:26:11.832]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:11.832]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.832]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.832]                               "release", "version")], collapse = " "), 
[10:26:11.832]                             hostname = base::Sys.info()[["nodename"]])
[10:26:11.832]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.832]                             info)
[10:26:11.832]                           info <- base::paste(info, collapse = "; ")
[10:26:11.832]                           if (!has_future) {
[10:26:11.832]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.832]                               info)
[10:26:11.832]                           }
[10:26:11.832]                           else {
[10:26:11.832]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.832]                               info, version)
[10:26:11.832]                           }
[10:26:11.832]                           base::stop(msg)
[10:26:11.832]                         }
[10:26:11.832]                       })
[10:26:11.832]                     }
[10:26:11.832]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:11.832]                     base::options(mc.cores = 1L)
[10:26:11.832]                   }
[10:26:11.832]                   options(future.plan = NULL)
[10:26:11.832]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.832]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.832]                 }
[10:26:11.832]                 ...future.workdir <- getwd()
[10:26:11.832]             }
[10:26:11.832]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.832]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.832]         }
[10:26:11.832]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.832]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:11.832]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.832]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.832]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.832]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.832]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.832]             base::names(...future.oldOptions))
[10:26:11.832]     }
[10:26:11.832]     if (FALSE) {
[10:26:11.832]     }
[10:26:11.832]     else {
[10:26:11.832]         if (TRUE) {
[10:26:11.832]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.832]                 open = "w")
[10:26:11.832]         }
[10:26:11.832]         else {
[10:26:11.832]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.832]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.832]         }
[10:26:11.832]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.832]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.832]             base::sink(type = "output", split = FALSE)
[10:26:11.832]             base::close(...future.stdout)
[10:26:11.832]         }, add = TRUE)
[10:26:11.832]     }
[10:26:11.832]     ...future.frame <- base::sys.nframe()
[10:26:11.832]     ...future.conditions <- base::list()
[10:26:11.832]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.832]     if (FALSE) {
[10:26:11.832]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.832]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.832]     }
[10:26:11.832]     ...future.result <- base::tryCatch({
[10:26:11.832]         base::withCallingHandlers({
[10:26:11.832]             ...future.value <- base::withVisible(base::local({
[10:26:11.832]                 withCallingHandlers({
[10:26:11.832]                   {
[10:26:11.832]                     b <- a
[10:26:11.832]                     a <- 2
[10:26:11.832]                     a * b
[10:26:11.832]                   }
[10:26:11.832]                 }, immediateCondition = function(cond) {
[10:26:11.832]                   save_rds <- function (object, pathname, ...) 
[10:26:11.832]                   {
[10:26:11.832]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:11.832]                     if (file_test("-f", pathname_tmp)) {
[10:26:11.832]                       fi_tmp <- file.info(pathname_tmp)
[10:26:11.832]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:11.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:11.832]                         fi_tmp[["mtime"]])
[10:26:11.832]                     }
[10:26:11.832]                     tryCatch({
[10:26:11.832]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:11.832]                     }, error = function(ex) {
[10:26:11.832]                       msg <- conditionMessage(ex)
[10:26:11.832]                       fi_tmp <- file.info(pathname_tmp)
[10:26:11.832]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:11.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:11.832]                         fi_tmp[["mtime"]], msg)
[10:26:11.832]                       ex$message <- msg
[10:26:11.832]                       stop(ex)
[10:26:11.832]                     })
[10:26:11.832]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:11.832]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:11.832]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:11.832]                       fi_tmp <- file.info(pathname_tmp)
[10:26:11.832]                       fi <- file.info(pathname)
[10:26:11.832]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:11.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:11.832]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:11.832]                         fi[["size"]], fi[["mtime"]])
[10:26:11.832]                       stop(msg)
[10:26:11.832]                     }
[10:26:11.832]                     invisible(pathname)
[10:26:11.832]                   }
[10:26:11.832]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:11.832]                     rootPath = tempdir()) 
[10:26:11.832]                   {
[10:26:11.832]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:11.832]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:11.832]                       tmpdir = path, fileext = ".rds")
[10:26:11.832]                     save_rds(obj, file)
[10:26:11.832]                   }
[10:26:11.832]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:11.832]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.832]                   {
[10:26:11.832]                     inherits <- base::inherits
[10:26:11.832]                     invokeRestart <- base::invokeRestart
[10:26:11.832]                     is.null <- base::is.null
[10:26:11.832]                     muffled <- FALSE
[10:26:11.832]                     if (inherits(cond, "message")) {
[10:26:11.832]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:11.832]                       if (muffled) 
[10:26:11.832]                         invokeRestart("muffleMessage")
[10:26:11.832]                     }
[10:26:11.832]                     else if (inherits(cond, "warning")) {
[10:26:11.832]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:11.832]                       if (muffled) 
[10:26:11.832]                         invokeRestart("muffleWarning")
[10:26:11.832]                     }
[10:26:11.832]                     else if (inherits(cond, "condition")) {
[10:26:11.832]                       if (!is.null(pattern)) {
[10:26:11.832]                         computeRestarts <- base::computeRestarts
[10:26:11.832]                         grepl <- base::grepl
[10:26:11.832]                         restarts <- computeRestarts(cond)
[10:26:11.832]                         for (restart in restarts) {
[10:26:11.832]                           name <- restart$name
[10:26:11.832]                           if (is.null(name)) 
[10:26:11.832]                             next
[10:26:11.832]                           if (!grepl(pattern, name)) 
[10:26:11.832]                             next
[10:26:11.832]                           invokeRestart(restart)
[10:26:11.832]                           muffled <- TRUE
[10:26:11.832]                           break
[10:26:11.832]                         }
[10:26:11.832]                       }
[10:26:11.832]                     }
[10:26:11.832]                     invisible(muffled)
[10:26:11.832]                   }
[10:26:11.832]                   muffleCondition(cond)
[10:26:11.832]                 })
[10:26:11.832]             }))
[10:26:11.832]             future::FutureResult(value = ...future.value$value, 
[10:26:11.832]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.832]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.832]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.832]                     ...future.globalenv.names))
[10:26:11.832]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.832]         }, condition = base::local({
[10:26:11.832]             c <- base::c
[10:26:11.832]             inherits <- base::inherits
[10:26:11.832]             invokeRestart <- base::invokeRestart
[10:26:11.832]             length <- base::length
[10:26:11.832]             list <- base::list
[10:26:11.832]             seq.int <- base::seq.int
[10:26:11.832]             signalCondition <- base::signalCondition
[10:26:11.832]             sys.calls <- base::sys.calls
[10:26:11.832]             `[[` <- base::`[[`
[10:26:11.832]             `+` <- base::`+`
[10:26:11.832]             `<<-` <- base::`<<-`
[10:26:11.832]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.832]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.832]                   3L)]
[10:26:11.832]             }
[10:26:11.832]             function(cond) {
[10:26:11.832]                 is_error <- inherits(cond, "error")
[10:26:11.832]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.832]                   NULL)
[10:26:11.832]                 if (is_error) {
[10:26:11.832]                   sessionInformation <- function() {
[10:26:11.832]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.832]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.832]                       search = base::search(), system = base::Sys.info())
[10:26:11.832]                   }
[10:26:11.832]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.832]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.832]                     cond$call), session = sessionInformation(), 
[10:26:11.832]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.832]                   signalCondition(cond)
[10:26:11.832]                 }
[10:26:11.832]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.832]                 "immediateCondition"))) {
[10:26:11.832]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.832]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.832]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.832]                   if (TRUE && !signal) {
[10:26:11.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.832]                     {
[10:26:11.832]                       inherits <- base::inherits
[10:26:11.832]                       invokeRestart <- base::invokeRestart
[10:26:11.832]                       is.null <- base::is.null
[10:26:11.832]                       muffled <- FALSE
[10:26:11.832]                       if (inherits(cond, "message")) {
[10:26:11.832]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.832]                         if (muffled) 
[10:26:11.832]                           invokeRestart("muffleMessage")
[10:26:11.832]                       }
[10:26:11.832]                       else if (inherits(cond, "warning")) {
[10:26:11.832]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.832]                         if (muffled) 
[10:26:11.832]                           invokeRestart("muffleWarning")
[10:26:11.832]                       }
[10:26:11.832]                       else if (inherits(cond, "condition")) {
[10:26:11.832]                         if (!is.null(pattern)) {
[10:26:11.832]                           computeRestarts <- base::computeRestarts
[10:26:11.832]                           grepl <- base::grepl
[10:26:11.832]                           restarts <- computeRestarts(cond)
[10:26:11.832]                           for (restart in restarts) {
[10:26:11.832]                             name <- restart$name
[10:26:11.832]                             if (is.null(name)) 
[10:26:11.832]                               next
[10:26:11.832]                             if (!grepl(pattern, name)) 
[10:26:11.832]                               next
[10:26:11.832]                             invokeRestart(restart)
[10:26:11.832]                             muffled <- TRUE
[10:26:11.832]                             break
[10:26:11.832]                           }
[10:26:11.832]                         }
[10:26:11.832]                       }
[10:26:11.832]                       invisible(muffled)
[10:26:11.832]                     }
[10:26:11.832]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.832]                   }
[10:26:11.832]                 }
[10:26:11.832]                 else {
[10:26:11.832]                   if (TRUE) {
[10:26:11.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.832]                     {
[10:26:11.832]                       inherits <- base::inherits
[10:26:11.832]                       invokeRestart <- base::invokeRestart
[10:26:11.832]                       is.null <- base::is.null
[10:26:11.832]                       muffled <- FALSE
[10:26:11.832]                       if (inherits(cond, "message")) {
[10:26:11.832]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.832]                         if (muffled) 
[10:26:11.832]                           invokeRestart("muffleMessage")
[10:26:11.832]                       }
[10:26:11.832]                       else if (inherits(cond, "warning")) {
[10:26:11.832]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.832]                         if (muffled) 
[10:26:11.832]                           invokeRestart("muffleWarning")
[10:26:11.832]                       }
[10:26:11.832]                       else if (inherits(cond, "condition")) {
[10:26:11.832]                         if (!is.null(pattern)) {
[10:26:11.832]                           computeRestarts <- base::computeRestarts
[10:26:11.832]                           grepl <- base::grepl
[10:26:11.832]                           restarts <- computeRestarts(cond)
[10:26:11.832]                           for (restart in restarts) {
[10:26:11.832]                             name <- restart$name
[10:26:11.832]                             if (is.null(name)) 
[10:26:11.832]                               next
[10:26:11.832]                             if (!grepl(pattern, name)) 
[10:26:11.832]                               next
[10:26:11.832]                             invokeRestart(restart)
[10:26:11.832]                             muffled <- TRUE
[10:26:11.832]                             break
[10:26:11.832]                           }
[10:26:11.832]                         }
[10:26:11.832]                       }
[10:26:11.832]                       invisible(muffled)
[10:26:11.832]                     }
[10:26:11.832]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.832]                   }
[10:26:11.832]                 }
[10:26:11.832]             }
[10:26:11.832]         }))
[10:26:11.832]     }, error = function(ex) {
[10:26:11.832]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.832]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.832]                 ...future.rng), started = ...future.startTime, 
[10:26:11.832]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.832]             version = "1.8"), class = "FutureResult")
[10:26:11.832]     }, finally = {
[10:26:11.832]         if (!identical(...future.workdir, getwd())) 
[10:26:11.832]             setwd(...future.workdir)
[10:26:11.832]         {
[10:26:11.832]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.832]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.832]             }
[10:26:11.832]             base::options(...future.oldOptions)
[10:26:11.832]             if (.Platform$OS.type == "windows") {
[10:26:11.832]                 old_names <- names(...future.oldEnvVars)
[10:26:11.832]                 envs <- base::Sys.getenv()
[10:26:11.832]                 names <- names(envs)
[10:26:11.832]                 common <- intersect(names, old_names)
[10:26:11.832]                 added <- setdiff(names, old_names)
[10:26:11.832]                 removed <- setdiff(old_names, names)
[10:26:11.832]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.832]                   envs[common]]
[10:26:11.832]                 NAMES <- toupper(changed)
[10:26:11.832]                 args <- list()
[10:26:11.832]                 for (kk in seq_along(NAMES)) {
[10:26:11.832]                   name <- changed[[kk]]
[10:26:11.832]                   NAME <- NAMES[[kk]]
[10:26:11.832]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.832]                     next
[10:26:11.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.832]                 }
[10:26:11.832]                 NAMES <- toupper(added)
[10:26:11.832]                 for (kk in seq_along(NAMES)) {
[10:26:11.832]                   name <- added[[kk]]
[10:26:11.832]                   NAME <- NAMES[[kk]]
[10:26:11.832]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.832]                     next
[10:26:11.832]                   args[[name]] <- ""
[10:26:11.832]                 }
[10:26:11.832]                 NAMES <- toupper(removed)
[10:26:11.832]                 for (kk in seq_along(NAMES)) {
[10:26:11.832]                   name <- removed[[kk]]
[10:26:11.832]                   NAME <- NAMES[[kk]]
[10:26:11.832]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.832]                     next
[10:26:11.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.832]                 }
[10:26:11.832]                 if (length(args) > 0) 
[10:26:11.832]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.832]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.832]             }
[10:26:11.832]             else {
[10:26:11.832]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.832]             }
[10:26:11.832]             {
[10:26:11.832]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.832]                   0L) {
[10:26:11.832]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.832]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.832]                   base::options(opts)
[10:26:11.832]                 }
[10:26:11.832]                 {
[10:26:11.832]                   {
[10:26:11.832]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:11.832]                     NULL
[10:26:11.832]                   }
[10:26:11.832]                   options(future.plan = NULL)
[10:26:11.832]                   if (is.na(NA_character_)) 
[10:26:11.832]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.832]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.832]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:11.832]                     envir = parent.frame()) 
[10:26:11.832]                   {
[10:26:11.832]                     default_workers <- missing(workers)
[10:26:11.832]                     if (is.function(workers)) 
[10:26:11.832]                       workers <- workers()
[10:26:11.832]                     workers <- structure(as.integer(workers), 
[10:26:11.832]                       class = class(workers))
[10:26:11.832]                     stop_if_not(is.finite(workers), workers >= 
[10:26:11.832]                       1L)
[10:26:11.832]                     if ((workers == 1L && !inherits(workers, 
[10:26:11.832]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:11.832]                       if (default_workers) 
[10:26:11.832]                         supportsMulticore(warn = TRUE)
[10:26:11.832]                       return(sequential(..., envir = envir))
[10:26:11.832]                     }
[10:26:11.832]                     oopts <- options(mc.cores = workers)
[10:26:11.832]                     on.exit(options(oopts))
[10:26:11.832]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:11.832]                       envir = envir)
[10:26:11.832]                     if (!future$lazy) 
[10:26:11.832]                       future <- run(future)
[10:26:11.832]                     invisible(future)
[10:26:11.832]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.832]                 }
[10:26:11.832]             }
[10:26:11.832]         }
[10:26:11.832]     })
[10:26:11.832]     if (TRUE) {
[10:26:11.832]         base::sink(type = "output", split = FALSE)
[10:26:11.832]         if (TRUE) {
[10:26:11.832]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.832]         }
[10:26:11.832]         else {
[10:26:11.832]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.832]         }
[10:26:11.832]         base::close(...future.stdout)
[10:26:11.832]         ...future.stdout <- NULL
[10:26:11.832]     }
[10:26:11.832]     ...future.result$conditions <- ...future.conditions
[10:26:11.832]     ...future.result$finished <- base::Sys.time()
[10:26:11.832]     ...future.result
[10:26:11.832] }
[10:26:11.835] requestCore(): workers = 2
[10:26:11.837] MulticoreFuture started
[10:26:11.837] - Launch lazy future ... done
[10:26:11.837] run() for ‘MulticoreFuture’ ... done
[10:26:11.838] result() for MulticoreFuture ...
[10:26:11.838] plan(): Setting new future strategy stack:
[10:26:11.838] List of future strategies:
[10:26:11.838] 1. sequential:
[10:26:11.838]    - args: function (..., envir = parent.frame())
[10:26:11.838]    - tweaked: FALSE
[10:26:11.838]    - call: NULL
[10:26:11.839] plan(): nbrOfWorkers() = 1
[10:26:11.841] plan(): Setting new future strategy stack:
[10:26:11.841] List of future strategies:
[10:26:11.841] 1. multicore:
[10:26:11.841]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:11.841]    - tweaked: FALSE
[10:26:11.841]    - call: plan(strategy)
[10:26:11.846] plan(): nbrOfWorkers() = 2
[10:26:11.852] result() for MulticoreFuture ...
[10:26:11.852] result() for MulticoreFuture ... done
[10:26:11.852] signalConditions() ...
[10:26:11.852]  - include = ‘immediateCondition’
[10:26:11.853]  - exclude = 
[10:26:11.853]  - resignal = FALSE
[10:26:11.853]  - Number of conditions: 1
[10:26:11.853] signalConditions() ... done
[10:26:11.853] result() for MulticoreFuture ... done
[10:26:11.853] result() for MulticoreFuture ...
[10:26:11.853] result() for MulticoreFuture ... done
[10:26:11.853] signalConditions() ...
[10:26:11.854]  - include = ‘immediateCondition’
[10:26:11.854]  - exclude = 
[10:26:11.854]  - resignal = FALSE
[10:26:11.854]  - Number of conditions: 1
[10:26:11.854] signalConditions() ... done
[10:26:11.854] Future state: ‘finished’
[10:26:11.854] result() for MulticoreFuture ...
[10:26:11.854] result() for MulticoreFuture ... done
[10:26:11.855] signalConditions() ...
[10:26:11.855]  - include = ‘condition’
[10:26:11.855]  - exclude = ‘immediateCondition’
[10:26:11.855]  - resignal = TRUE
[10:26:11.855]  - Number of conditions: 1
[10:26:11.855]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:26:11.855] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 39
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3e863ac79bce" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 10:26:11"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.886] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.886] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:11.887] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:11.887] Searching for globals ... DONE
[10:26:11.887] Resolving globals: TRUE
[10:26:11.887] Resolving any globals that are futures ...
[10:26:11.888] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:11.888] Resolving any globals that are futures ... DONE
[10:26:11.888] Resolving futures part of globals (recursively) ...
[10:26:11.888] resolve() on list ...
[10:26:11.888]  recursive: 99
[10:26:11.888]  length: 1
[10:26:11.889]  elements: ‘ii’
[10:26:11.889]  length: 0 (resolved future 1)
[10:26:11.889] resolve() on list ... DONE
[10:26:11.889] - globals: [1] ‘ii’
[10:26:11.889] Resolving futures part of globals (recursively) ... DONE
[10:26:11.889] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:11.889] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:11.890] - globals: [1] ‘ii’
[10:26:11.890] 
[10:26:11.890] getGlobalsAndPackages() ... DONE
[10:26:11.890] run() for ‘Future’ ...
[10:26:11.890] - state: ‘created’
[10:26:11.890] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:11.894] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:11.894] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:11.895]   - Field: ‘label’
[10:26:11.895]   - Field: ‘local’
[10:26:11.895]   - Field: ‘owner’
[10:26:11.895]   - Field: ‘envir’
[10:26:11.895]   - Field: ‘workers’
[10:26:11.895]   - Field: ‘packages’
[10:26:11.895]   - Field: ‘gc’
[10:26:11.895]   - Field: ‘job’
[10:26:11.896]   - Field: ‘conditions’
[10:26:11.896]   - Field: ‘expr’
[10:26:11.896]   - Field: ‘uuid’
[10:26:11.896]   - Field: ‘seed’
[10:26:11.896]   - Field: ‘version’
[10:26:11.896]   - Field: ‘result’
[10:26:11.896]   - Field: ‘asynchronous’
[10:26:11.896]   - Field: ‘calls’
[10:26:11.896]   - Field: ‘globals’
[10:26:11.896]   - Field: ‘stdout’
[10:26:11.896]   - Field: ‘earlySignal’
[10:26:11.897]   - Field: ‘lazy’
[10:26:11.897]   - Field: ‘state’
[10:26:11.897] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:11.897] - Launch lazy future ...
[10:26:11.897] Packages needed by the future expression (n = 0): <none>
[10:26:11.897] Packages needed by future strategies (n = 0): <none>
[10:26:11.898] {
[10:26:11.898]     {
[10:26:11.898]         {
[10:26:11.898]             ...future.startTime <- base::Sys.time()
[10:26:11.898]             {
[10:26:11.898]                 {
[10:26:11.898]                   {
[10:26:11.898]                     {
[10:26:11.898]                       base::local({
[10:26:11.898]                         has_future <- base::requireNamespace("future", 
[10:26:11.898]                           quietly = TRUE)
[10:26:11.898]                         if (has_future) {
[10:26:11.898]                           ns <- base::getNamespace("future")
[10:26:11.898]                           version <- ns[[".package"]][["version"]]
[10:26:11.898]                           if (is.null(version)) 
[10:26:11.898]                             version <- utils::packageVersion("future")
[10:26:11.898]                         }
[10:26:11.898]                         else {
[10:26:11.898]                           version <- NULL
[10:26:11.898]                         }
[10:26:11.898]                         if (!has_future || version < "1.8.0") {
[10:26:11.898]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.898]                             "", base::R.version$version.string), 
[10:26:11.898]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:11.898]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.898]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.898]                               "release", "version")], collapse = " "), 
[10:26:11.898]                             hostname = base::Sys.info()[["nodename"]])
[10:26:11.898]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.898]                             info)
[10:26:11.898]                           info <- base::paste(info, collapse = "; ")
[10:26:11.898]                           if (!has_future) {
[10:26:11.898]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.898]                               info)
[10:26:11.898]                           }
[10:26:11.898]                           else {
[10:26:11.898]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.898]                               info, version)
[10:26:11.898]                           }
[10:26:11.898]                           base::stop(msg)
[10:26:11.898]                         }
[10:26:11.898]                       })
[10:26:11.898]                     }
[10:26:11.898]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:11.898]                     base::options(mc.cores = 1L)
[10:26:11.898]                   }
[10:26:11.898]                   options(future.plan = NULL)
[10:26:11.898]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.898]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.898]                 }
[10:26:11.898]                 ...future.workdir <- getwd()
[10:26:11.898]             }
[10:26:11.898]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.898]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.898]         }
[10:26:11.898]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.898]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:11.898]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.898]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.898]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.898]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.898]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.898]             base::names(...future.oldOptions))
[10:26:11.898]     }
[10:26:11.898]     if (FALSE) {
[10:26:11.898]     }
[10:26:11.898]     else {
[10:26:11.898]         if (TRUE) {
[10:26:11.898]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.898]                 open = "w")
[10:26:11.898]         }
[10:26:11.898]         else {
[10:26:11.898]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.898]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.898]         }
[10:26:11.898]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.898]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.898]             base::sink(type = "output", split = FALSE)
[10:26:11.898]             base::close(...future.stdout)
[10:26:11.898]         }, add = TRUE)
[10:26:11.898]     }
[10:26:11.898]     ...future.frame <- base::sys.nframe()
[10:26:11.898]     ...future.conditions <- base::list()
[10:26:11.898]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.898]     if (FALSE) {
[10:26:11.898]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.898]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.898]     }
[10:26:11.898]     ...future.result <- base::tryCatch({
[10:26:11.898]         base::withCallingHandlers({
[10:26:11.898]             ...future.value <- base::withVisible(base::local({
[10:26:11.898]                 withCallingHandlers({
[10:26:11.898]                   {
[10:26:11.898]                     b <- a * ii
[10:26:11.898]                     a <- 0
[10:26:11.898]                     b
[10:26:11.898]                   }
[10:26:11.898]                 }, immediateCondition = function(cond) {
[10:26:11.898]                   save_rds <- function (object, pathname, ...) 
[10:26:11.898]                   {
[10:26:11.898]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:11.898]                     if (file_test("-f", pathname_tmp)) {
[10:26:11.898]                       fi_tmp <- file.info(pathname_tmp)
[10:26:11.898]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:11.898]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:11.898]                         fi_tmp[["mtime"]])
[10:26:11.898]                     }
[10:26:11.898]                     tryCatch({
[10:26:11.898]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:11.898]                     }, error = function(ex) {
[10:26:11.898]                       msg <- conditionMessage(ex)
[10:26:11.898]                       fi_tmp <- file.info(pathname_tmp)
[10:26:11.898]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:11.898]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:11.898]                         fi_tmp[["mtime"]], msg)
[10:26:11.898]                       ex$message <- msg
[10:26:11.898]                       stop(ex)
[10:26:11.898]                     })
[10:26:11.898]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:11.898]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:11.898]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:11.898]                       fi_tmp <- file.info(pathname_tmp)
[10:26:11.898]                       fi <- file.info(pathname)
[10:26:11.898]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:11.898]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:11.898]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:11.898]                         fi[["size"]], fi[["mtime"]])
[10:26:11.898]                       stop(msg)
[10:26:11.898]                     }
[10:26:11.898]                     invisible(pathname)
[10:26:11.898]                   }
[10:26:11.898]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:11.898]                     rootPath = tempdir()) 
[10:26:11.898]                   {
[10:26:11.898]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:11.898]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:11.898]                       tmpdir = path, fileext = ".rds")
[10:26:11.898]                     save_rds(obj, file)
[10:26:11.898]                   }
[10:26:11.898]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:11.898]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.898]                   {
[10:26:11.898]                     inherits <- base::inherits
[10:26:11.898]                     invokeRestart <- base::invokeRestart
[10:26:11.898]                     is.null <- base::is.null
[10:26:11.898]                     muffled <- FALSE
[10:26:11.898]                     if (inherits(cond, "message")) {
[10:26:11.898]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:11.898]                       if (muffled) 
[10:26:11.898]                         invokeRestart("muffleMessage")
[10:26:11.898]                     }
[10:26:11.898]                     else if (inherits(cond, "warning")) {
[10:26:11.898]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:11.898]                       if (muffled) 
[10:26:11.898]                         invokeRestart("muffleWarning")
[10:26:11.898]                     }
[10:26:11.898]                     else if (inherits(cond, "condition")) {
[10:26:11.898]                       if (!is.null(pattern)) {
[10:26:11.898]                         computeRestarts <- base::computeRestarts
[10:26:11.898]                         grepl <- base::grepl
[10:26:11.898]                         restarts <- computeRestarts(cond)
[10:26:11.898]                         for (restart in restarts) {
[10:26:11.898]                           name <- restart$name
[10:26:11.898]                           if (is.null(name)) 
[10:26:11.898]                             next
[10:26:11.898]                           if (!grepl(pattern, name)) 
[10:26:11.898]                             next
[10:26:11.898]                           invokeRestart(restart)
[10:26:11.898]                           muffled <- TRUE
[10:26:11.898]                           break
[10:26:11.898]                         }
[10:26:11.898]                       }
[10:26:11.898]                     }
[10:26:11.898]                     invisible(muffled)
[10:26:11.898]                   }
[10:26:11.898]                   muffleCondition(cond)
[10:26:11.898]                 })
[10:26:11.898]             }))
[10:26:11.898]             future::FutureResult(value = ...future.value$value, 
[10:26:11.898]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.898]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.898]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.898]                     ...future.globalenv.names))
[10:26:11.898]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.898]         }, condition = base::local({
[10:26:11.898]             c <- base::c
[10:26:11.898]             inherits <- base::inherits
[10:26:11.898]             invokeRestart <- base::invokeRestart
[10:26:11.898]             length <- base::length
[10:26:11.898]             list <- base::list
[10:26:11.898]             seq.int <- base::seq.int
[10:26:11.898]             signalCondition <- base::signalCondition
[10:26:11.898]             sys.calls <- base::sys.calls
[10:26:11.898]             `[[` <- base::`[[`
[10:26:11.898]             `+` <- base::`+`
[10:26:11.898]             `<<-` <- base::`<<-`
[10:26:11.898]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.898]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.898]                   3L)]
[10:26:11.898]             }
[10:26:11.898]             function(cond) {
[10:26:11.898]                 is_error <- inherits(cond, "error")
[10:26:11.898]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.898]                   NULL)
[10:26:11.898]                 if (is_error) {
[10:26:11.898]                   sessionInformation <- function() {
[10:26:11.898]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.898]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.898]                       search = base::search(), system = base::Sys.info())
[10:26:11.898]                   }
[10:26:11.898]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.898]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.898]                     cond$call), session = sessionInformation(), 
[10:26:11.898]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.898]                   signalCondition(cond)
[10:26:11.898]                 }
[10:26:11.898]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.898]                 "immediateCondition"))) {
[10:26:11.898]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.898]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.898]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.898]                   if (TRUE && !signal) {
[10:26:11.898]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.898]                     {
[10:26:11.898]                       inherits <- base::inherits
[10:26:11.898]                       invokeRestart <- base::invokeRestart
[10:26:11.898]                       is.null <- base::is.null
[10:26:11.898]                       muffled <- FALSE
[10:26:11.898]                       if (inherits(cond, "message")) {
[10:26:11.898]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.898]                         if (muffled) 
[10:26:11.898]                           invokeRestart("muffleMessage")
[10:26:11.898]                       }
[10:26:11.898]                       else if (inherits(cond, "warning")) {
[10:26:11.898]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.898]                         if (muffled) 
[10:26:11.898]                           invokeRestart("muffleWarning")
[10:26:11.898]                       }
[10:26:11.898]                       else if (inherits(cond, "condition")) {
[10:26:11.898]                         if (!is.null(pattern)) {
[10:26:11.898]                           computeRestarts <- base::computeRestarts
[10:26:11.898]                           grepl <- base::grepl
[10:26:11.898]                           restarts <- computeRestarts(cond)
[10:26:11.898]                           for (restart in restarts) {
[10:26:11.898]                             name <- restart$name
[10:26:11.898]                             if (is.null(name)) 
[10:26:11.898]                               next
[10:26:11.898]                             if (!grepl(pattern, name)) 
[10:26:11.898]                               next
[10:26:11.898]                             invokeRestart(restart)
[10:26:11.898]                             muffled <- TRUE
[10:26:11.898]                             break
[10:26:11.898]                           }
[10:26:11.898]                         }
[10:26:11.898]                       }
[10:26:11.898]                       invisible(muffled)
[10:26:11.898]                     }
[10:26:11.898]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.898]                   }
[10:26:11.898]                 }
[10:26:11.898]                 else {
[10:26:11.898]                   if (TRUE) {
[10:26:11.898]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.898]                     {
[10:26:11.898]                       inherits <- base::inherits
[10:26:11.898]                       invokeRestart <- base::invokeRestart
[10:26:11.898]                       is.null <- base::is.null
[10:26:11.898]                       muffled <- FALSE
[10:26:11.898]                       if (inherits(cond, "message")) {
[10:26:11.898]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.898]                         if (muffled) 
[10:26:11.898]                           invokeRestart("muffleMessage")
[10:26:11.898]                       }
[10:26:11.898]                       else if (inherits(cond, "warning")) {
[10:26:11.898]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.898]                         if (muffled) 
[10:26:11.898]                           invokeRestart("muffleWarning")
[10:26:11.898]                       }
[10:26:11.898]                       else if (inherits(cond, "condition")) {
[10:26:11.898]                         if (!is.null(pattern)) {
[10:26:11.898]                           computeRestarts <- base::computeRestarts
[10:26:11.898]                           grepl <- base::grepl
[10:26:11.898]                           restarts <- computeRestarts(cond)
[10:26:11.898]                           for (restart in restarts) {
[10:26:11.898]                             name <- restart$name
[10:26:11.898]                             if (is.null(name)) 
[10:26:11.898]                               next
[10:26:11.898]                             if (!grepl(pattern, name)) 
[10:26:11.898]                               next
[10:26:11.898]                             invokeRestart(restart)
[10:26:11.898]                             muffled <- TRUE
[10:26:11.898]                             break
[10:26:11.898]                           }
[10:26:11.898]                         }
[10:26:11.898]                       }
[10:26:11.898]                       invisible(muffled)
[10:26:11.898]                     }
[10:26:11.898]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.898]                   }
[10:26:11.898]                 }
[10:26:11.898]             }
[10:26:11.898]         }))
[10:26:11.898]     }, error = function(ex) {
[10:26:11.898]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.898]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.898]                 ...future.rng), started = ...future.startTime, 
[10:26:11.898]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.898]             version = "1.8"), class = "FutureResult")
[10:26:11.898]     }, finally = {
[10:26:11.898]         if (!identical(...future.workdir, getwd())) 
[10:26:11.898]             setwd(...future.workdir)
[10:26:11.898]         {
[10:26:11.898]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.898]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.898]             }
[10:26:11.898]             base::options(...future.oldOptions)
[10:26:11.898]             if (.Platform$OS.type == "windows") {
[10:26:11.898]                 old_names <- names(...future.oldEnvVars)
[10:26:11.898]                 envs <- base::Sys.getenv()
[10:26:11.898]                 names <- names(envs)
[10:26:11.898]                 common <- intersect(names, old_names)
[10:26:11.898]                 added <- setdiff(names, old_names)
[10:26:11.898]                 removed <- setdiff(old_names, names)
[10:26:11.898]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.898]                   envs[common]]
[10:26:11.898]                 NAMES <- toupper(changed)
[10:26:11.898]                 args <- list()
[10:26:11.898]                 for (kk in seq_along(NAMES)) {
[10:26:11.898]                   name <- changed[[kk]]
[10:26:11.898]                   NAME <- NAMES[[kk]]
[10:26:11.898]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.898]                     next
[10:26:11.898]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.898]                 }
[10:26:11.898]                 NAMES <- toupper(added)
[10:26:11.898]                 for (kk in seq_along(NAMES)) {
[10:26:11.898]                   name <- added[[kk]]
[10:26:11.898]                   NAME <- NAMES[[kk]]
[10:26:11.898]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.898]                     next
[10:26:11.898]                   args[[name]] <- ""
[10:26:11.898]                 }
[10:26:11.898]                 NAMES <- toupper(removed)
[10:26:11.898]                 for (kk in seq_along(NAMES)) {
[10:26:11.898]                   name <- removed[[kk]]
[10:26:11.898]                   NAME <- NAMES[[kk]]
[10:26:11.898]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.898]                     next
[10:26:11.898]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.898]                 }
[10:26:11.898]                 if (length(args) > 0) 
[10:26:11.898]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.898]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.898]             }
[10:26:11.898]             else {
[10:26:11.898]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.898]             }
[10:26:11.898]             {
[10:26:11.898]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.898]                   0L) {
[10:26:11.898]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.898]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.898]                   base::options(opts)
[10:26:11.898]                 }
[10:26:11.898]                 {
[10:26:11.898]                   {
[10:26:11.898]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:11.898]                     NULL
[10:26:11.898]                   }
[10:26:11.898]                   options(future.plan = NULL)
[10:26:11.898]                   if (is.na(NA_character_)) 
[10:26:11.898]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.898]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.898]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:11.898]                     envir = parent.frame()) 
[10:26:11.898]                   {
[10:26:11.898]                     default_workers <- missing(workers)
[10:26:11.898]                     if (is.function(workers)) 
[10:26:11.898]                       workers <- workers()
[10:26:11.898]                     workers <- structure(as.integer(workers), 
[10:26:11.898]                       class = class(workers))
[10:26:11.898]                     stop_if_not(is.finite(workers), workers >= 
[10:26:11.898]                       1L)
[10:26:11.898]                     if ((workers == 1L && !inherits(workers, 
[10:26:11.898]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:11.898]                       if (default_workers) 
[10:26:11.898]                         supportsMulticore(warn = TRUE)
[10:26:11.898]                       return(sequential(..., envir = envir))
[10:26:11.898]                     }
[10:26:11.898]                     oopts <- options(mc.cores = workers)
[10:26:11.898]                     on.exit(options(oopts))
[10:26:11.898]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:11.898]                       envir = envir)
[10:26:11.898]                     if (!future$lazy) 
[10:26:11.898]                       future <- run(future)
[10:26:11.898]                     invisible(future)
[10:26:11.898]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.898]                 }
[10:26:11.898]             }
[10:26:11.898]         }
[10:26:11.898]     })
[10:26:11.898]     if (TRUE) {
[10:26:11.898]         base::sink(type = "output", split = FALSE)
[10:26:11.898]         if (TRUE) {
[10:26:11.898]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.898]         }
[10:26:11.898]         else {
[10:26:11.898]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.898]         }
[10:26:11.898]         base::close(...future.stdout)
[10:26:11.898]         ...future.stdout <- NULL
[10:26:11.898]     }
[10:26:11.898]     ...future.result$conditions <- ...future.conditions
[10:26:11.898]     ...future.result$finished <- base::Sys.time()
[10:26:11.898]     ...future.result
[10:26:11.898] }
[10:26:11.900] assign_globals() ...
[10:26:11.900] List of 1
[10:26:11.900]  $ ii: int 1
[10:26:11.900]  - attr(*, "where")=List of 1
[10:26:11.900]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:11.900]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.900]  - attr(*, "resolved")= logi TRUE
[10:26:11.900]  - attr(*, "total_size")= num 56
[10:26:11.900]  - attr(*, "already-done")= logi TRUE
[10:26:11.902] - copied ‘ii’ to environment
[10:26:11.903] assign_globals() ... done
[10:26:11.903] requestCore(): workers = 2
[10:26:11.905] MulticoreFuture started
[10:26:11.905] - Launch lazy future ... done
[10:26:11.905] run() for ‘MulticoreFuture’ ... done
[10:26:11.906] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.907] getGlobalsAndPackages() ...
[10:26:11.906] List of future strategies:
[10:26:11.906] 1. sequential:
[10:26:11.906]    - args: function (..., envir = parent.frame())
[10:26:11.906]    - tweaked: FALSE
[10:26:11.906]    - call: NULL
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.907] Searching for globals...
[10:26:11.907] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:11.909] plan(): Setting new future strategy stack:
[10:26:11.909] List of future strategies:
[10:26:11.909] 1. multicore:
[10:26:11.909]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:11.909]    - tweaked: FALSE
[10:26:11.909]    - call: plan(strategy)
[10:26:11.910] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:11.910] Searching for globals ... DONE
[10:26:11.910] Resolving globals: TRUE
[10:26:11.910] Resolving any globals that are futures ...
[10:26:11.910] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:11.911] Resolving any globals that are futures ... DONE
[10:26:11.911] Resolving futures part of globals (recursively) ...
[10:26:11.912] resolve() on list ...
[10:26:11.912]  recursive: 99
[10:26:11.912]  length: 1
[10:26:11.912]  elements: ‘ii’
[10:26:11.912]  length: 0 (resolved future 1)
[10:26:11.913] resolve() on list ... DONE
[10:26:11.913] - globals: [1] ‘ii’
[10:26:11.913] Resolving futures part of globals (recursively) ... DONE
[10:26:11.913] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:11.914] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:11.914] plan(): nbrOfWorkers() = 2
[10:26:11.914] - globals: [1] ‘ii’
[10:26:11.914] 
[10:26:11.914] getGlobalsAndPackages() ... DONE
[10:26:11.915] run() for ‘Future’ ...
[10:26:11.915] - state: ‘created’
[10:26:11.915] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:11.920] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:11.920] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:11.920]   - Field: ‘label’
[10:26:11.920]   - Field: ‘local’
[10:26:11.920]   - Field: ‘owner’
[10:26:11.921]   - Field: ‘envir’
[10:26:11.921]   - Field: ‘workers’
[10:26:11.921]   - Field: ‘packages’
[10:26:11.924]   - Field: ‘gc’
[10:26:11.924]   - Field: ‘job’
[10:26:11.924]   - Field: ‘conditions’
[10:26:11.925]   - Field: ‘expr’
[10:26:11.925]   - Field: ‘uuid’
[10:26:11.925]   - Field: ‘seed’
[10:26:11.926]   - Field: ‘version’
[10:26:11.926]   - Field: ‘result’
[10:26:11.926]   - Field: ‘asynchronous’
[10:26:11.926]   - Field: ‘calls’
[10:26:11.927]   - Field: ‘globals’
[10:26:11.927]   - Field: ‘stdout’
[10:26:11.927]   - Field: ‘earlySignal’
[10:26:11.927]   - Field: ‘lazy’
[10:26:11.927]   - Field: ‘state’
[10:26:11.928] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:11.928] - Launch lazy future ...
[10:26:11.928] Packages needed by the future expression (n = 0): <none>
[10:26:11.929] Packages needed by future strategies (n = 0): <none>
[10:26:11.929] {
[10:26:11.929]     {
[10:26:11.929]         {
[10:26:11.929]             ...future.startTime <- base::Sys.time()
[10:26:11.929]             {
[10:26:11.929]                 {
[10:26:11.929]                   {
[10:26:11.929]                     {
[10:26:11.929]                       base::local({
[10:26:11.929]                         has_future <- base::requireNamespace("future", 
[10:26:11.929]                           quietly = TRUE)
[10:26:11.929]                         if (has_future) {
[10:26:11.929]                           ns <- base::getNamespace("future")
[10:26:11.929]                           version <- ns[[".package"]][["version"]]
[10:26:11.929]                           if (is.null(version)) 
[10:26:11.929]                             version <- utils::packageVersion("future")
[10:26:11.929]                         }
[10:26:11.929]                         else {
[10:26:11.929]                           version <- NULL
[10:26:11.929]                         }
[10:26:11.929]                         if (!has_future || version < "1.8.0") {
[10:26:11.929]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.929]                             "", base::R.version$version.string), 
[10:26:11.929]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:11.929]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.929]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.929]                               "release", "version")], collapse = " "), 
[10:26:11.929]                             hostname = base::Sys.info()[["nodename"]])
[10:26:11.929]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.929]                             info)
[10:26:11.929]                           info <- base::paste(info, collapse = "; ")
[10:26:11.929]                           if (!has_future) {
[10:26:11.929]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.929]                               info)
[10:26:11.929]                           }
[10:26:11.929]                           else {
[10:26:11.929]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.929]                               info, version)
[10:26:11.929]                           }
[10:26:11.929]                           base::stop(msg)
[10:26:11.929]                         }
[10:26:11.929]                       })
[10:26:11.929]                     }
[10:26:11.929]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:11.929]                     base::options(mc.cores = 1L)
[10:26:11.929]                   }
[10:26:11.929]                   options(future.plan = NULL)
[10:26:11.929]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.929]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.929]                 }
[10:26:11.929]                 ...future.workdir <- getwd()
[10:26:11.929]             }
[10:26:11.929]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.929]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.929]         }
[10:26:11.929]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.929]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:11.929]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.929]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.929]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.929]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.929]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.929]             base::names(...future.oldOptions))
[10:26:11.929]     }
[10:26:11.929]     if (FALSE) {
[10:26:11.929]     }
[10:26:11.929]     else {
[10:26:11.929]         if (TRUE) {
[10:26:11.929]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.929]                 open = "w")
[10:26:11.929]         }
[10:26:11.929]         else {
[10:26:11.929]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.929]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.929]         }
[10:26:11.929]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.929]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.929]             base::sink(type = "output", split = FALSE)
[10:26:11.929]             base::close(...future.stdout)
[10:26:11.929]         }, add = TRUE)
[10:26:11.929]     }
[10:26:11.929]     ...future.frame <- base::sys.nframe()
[10:26:11.929]     ...future.conditions <- base::list()
[10:26:11.929]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.929]     if (FALSE) {
[10:26:11.929]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.929]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.929]     }
[10:26:11.929]     ...future.result <- base::tryCatch({
[10:26:11.929]         base::withCallingHandlers({
[10:26:11.929]             ...future.value <- base::withVisible(base::local({
[10:26:11.929]                 withCallingHandlers({
[10:26:11.929]                   {
[10:26:11.929]                     b <- a * ii
[10:26:11.929]                     a <- 0
[10:26:11.929]                     b
[10:26:11.929]                   }
[10:26:11.929]                 }, immediateCondition = function(cond) {
[10:26:11.929]                   save_rds <- function (object, pathname, ...) 
[10:26:11.929]                   {
[10:26:11.929]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:11.929]                     if (file_test("-f", pathname_tmp)) {
[10:26:11.929]                       fi_tmp <- file.info(pathname_tmp)
[10:26:11.929]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:11.929]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:11.929]                         fi_tmp[["mtime"]])
[10:26:11.929]                     }
[10:26:11.929]                     tryCatch({
[10:26:11.929]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:11.929]                     }, error = function(ex) {
[10:26:11.929]                       msg <- conditionMessage(ex)
[10:26:11.929]                       fi_tmp <- file.info(pathname_tmp)
[10:26:11.929]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:11.929]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:11.929]                         fi_tmp[["mtime"]], msg)
[10:26:11.929]                       ex$message <- msg
[10:26:11.929]                       stop(ex)
[10:26:11.929]                     })
[10:26:11.929]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:11.929]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:11.929]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:11.929]                       fi_tmp <- file.info(pathname_tmp)
[10:26:11.929]                       fi <- file.info(pathname)
[10:26:11.929]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:11.929]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:11.929]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:11.929]                         fi[["size"]], fi[["mtime"]])
[10:26:11.929]                       stop(msg)
[10:26:11.929]                     }
[10:26:11.929]                     invisible(pathname)
[10:26:11.929]                   }
[10:26:11.929]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:11.929]                     rootPath = tempdir()) 
[10:26:11.929]                   {
[10:26:11.929]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:11.929]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:11.929]                       tmpdir = path, fileext = ".rds")
[10:26:11.929]                     save_rds(obj, file)
[10:26:11.929]                   }
[10:26:11.929]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:11.929]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.929]                   {
[10:26:11.929]                     inherits <- base::inherits
[10:26:11.929]                     invokeRestart <- base::invokeRestart
[10:26:11.929]                     is.null <- base::is.null
[10:26:11.929]                     muffled <- FALSE
[10:26:11.929]                     if (inherits(cond, "message")) {
[10:26:11.929]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:11.929]                       if (muffled) 
[10:26:11.929]                         invokeRestart("muffleMessage")
[10:26:11.929]                     }
[10:26:11.929]                     else if (inherits(cond, "warning")) {
[10:26:11.929]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:11.929]                       if (muffled) 
[10:26:11.929]                         invokeRestart("muffleWarning")
[10:26:11.929]                     }
[10:26:11.929]                     else if (inherits(cond, "condition")) {
[10:26:11.929]                       if (!is.null(pattern)) {
[10:26:11.929]                         computeRestarts <- base::computeRestarts
[10:26:11.929]                         grepl <- base::grepl
[10:26:11.929]                         restarts <- computeRestarts(cond)
[10:26:11.929]                         for (restart in restarts) {
[10:26:11.929]                           name <- restart$name
[10:26:11.929]                           if (is.null(name)) 
[10:26:11.929]                             next
[10:26:11.929]                           if (!grepl(pattern, name)) 
[10:26:11.929]                             next
[10:26:11.929]                           invokeRestart(restart)
[10:26:11.929]                           muffled <- TRUE
[10:26:11.929]                           break
[10:26:11.929]                         }
[10:26:11.929]                       }
[10:26:11.929]                     }
[10:26:11.929]                     invisible(muffled)
[10:26:11.929]                   }
[10:26:11.929]                   muffleCondition(cond)
[10:26:11.929]                 })
[10:26:11.929]             }))
[10:26:11.929]             future::FutureResult(value = ...future.value$value, 
[10:26:11.929]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.929]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.929]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.929]                     ...future.globalenv.names))
[10:26:11.929]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.929]         }, condition = base::local({
[10:26:11.929]             c <- base::c
[10:26:11.929]             inherits <- base::inherits
[10:26:11.929]             invokeRestart <- base::invokeRestart
[10:26:11.929]             length <- base::length
[10:26:11.929]             list <- base::list
[10:26:11.929]             seq.int <- base::seq.int
[10:26:11.929]             signalCondition <- base::signalCondition
[10:26:11.929]             sys.calls <- base::sys.calls
[10:26:11.929]             `[[` <- base::`[[`
[10:26:11.929]             `+` <- base::`+`
[10:26:11.929]             `<<-` <- base::`<<-`
[10:26:11.929]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.929]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.929]                   3L)]
[10:26:11.929]             }
[10:26:11.929]             function(cond) {
[10:26:11.929]                 is_error <- inherits(cond, "error")
[10:26:11.929]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.929]                   NULL)
[10:26:11.929]                 if (is_error) {
[10:26:11.929]                   sessionInformation <- function() {
[10:26:11.929]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.929]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.929]                       search = base::search(), system = base::Sys.info())
[10:26:11.929]                   }
[10:26:11.929]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.929]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.929]                     cond$call), session = sessionInformation(), 
[10:26:11.929]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.929]                   signalCondition(cond)
[10:26:11.929]                 }
[10:26:11.929]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.929]                 "immediateCondition"))) {
[10:26:11.929]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.929]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.929]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.929]                   if (TRUE && !signal) {
[10:26:11.929]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.929]                     {
[10:26:11.929]                       inherits <- base::inherits
[10:26:11.929]                       invokeRestart <- base::invokeRestart
[10:26:11.929]                       is.null <- base::is.null
[10:26:11.929]                       muffled <- FALSE
[10:26:11.929]                       if (inherits(cond, "message")) {
[10:26:11.929]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.929]                         if (muffled) 
[10:26:11.929]                           invokeRestart("muffleMessage")
[10:26:11.929]                       }
[10:26:11.929]                       else if (inherits(cond, "warning")) {
[10:26:11.929]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.929]                         if (muffled) 
[10:26:11.929]                           invokeRestart("muffleWarning")
[10:26:11.929]                       }
[10:26:11.929]                       else if (inherits(cond, "condition")) {
[10:26:11.929]                         if (!is.null(pattern)) {
[10:26:11.929]                           computeRestarts <- base::computeRestarts
[10:26:11.929]                           grepl <- base::grepl
[10:26:11.929]                           restarts <- computeRestarts(cond)
[10:26:11.929]                           for (restart in restarts) {
[10:26:11.929]                             name <- restart$name
[10:26:11.929]                             if (is.null(name)) 
[10:26:11.929]                               next
[10:26:11.929]                             if (!grepl(pattern, name)) 
[10:26:11.929]                               next
[10:26:11.929]                             invokeRestart(restart)
[10:26:11.929]                             muffled <- TRUE
[10:26:11.929]                             break
[10:26:11.929]                           }
[10:26:11.929]                         }
[10:26:11.929]                       }
[10:26:11.929]                       invisible(muffled)
[10:26:11.929]                     }
[10:26:11.929]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.929]                   }
[10:26:11.929]                 }
[10:26:11.929]                 else {
[10:26:11.929]                   if (TRUE) {
[10:26:11.929]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.929]                     {
[10:26:11.929]                       inherits <- base::inherits
[10:26:11.929]                       invokeRestart <- base::invokeRestart
[10:26:11.929]                       is.null <- base::is.null
[10:26:11.929]                       muffled <- FALSE
[10:26:11.929]                       if (inherits(cond, "message")) {
[10:26:11.929]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.929]                         if (muffled) 
[10:26:11.929]                           invokeRestart("muffleMessage")
[10:26:11.929]                       }
[10:26:11.929]                       else if (inherits(cond, "warning")) {
[10:26:11.929]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.929]                         if (muffled) 
[10:26:11.929]                           invokeRestart("muffleWarning")
[10:26:11.929]                       }
[10:26:11.929]                       else if (inherits(cond, "condition")) {
[10:26:11.929]                         if (!is.null(pattern)) {
[10:26:11.929]                           computeRestarts <- base::computeRestarts
[10:26:11.929]                           grepl <- base::grepl
[10:26:11.929]                           restarts <- computeRestarts(cond)
[10:26:11.929]                           for (restart in restarts) {
[10:26:11.929]                             name <- restart$name
[10:26:11.929]                             if (is.null(name)) 
[10:26:11.929]                               next
[10:26:11.929]                             if (!grepl(pattern, name)) 
[10:26:11.929]                               next
[10:26:11.929]                             invokeRestart(restart)
[10:26:11.929]                             muffled <- TRUE
[10:26:11.929]                             break
[10:26:11.929]                           }
[10:26:11.929]                         }
[10:26:11.929]                       }
[10:26:11.929]                       invisible(muffled)
[10:26:11.929]                     }
[10:26:11.929]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.929]                   }
[10:26:11.929]                 }
[10:26:11.929]             }
[10:26:11.929]         }))
[10:26:11.929]     }, error = function(ex) {
[10:26:11.929]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.929]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.929]                 ...future.rng), started = ...future.startTime, 
[10:26:11.929]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.929]             version = "1.8"), class = "FutureResult")
[10:26:11.929]     }, finally = {
[10:26:11.929]         if (!identical(...future.workdir, getwd())) 
[10:26:11.929]             setwd(...future.workdir)
[10:26:11.929]         {
[10:26:11.929]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.929]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.929]             }
[10:26:11.929]             base::options(...future.oldOptions)
[10:26:11.929]             if (.Platform$OS.type == "windows") {
[10:26:11.929]                 old_names <- names(...future.oldEnvVars)
[10:26:11.929]                 envs <- base::Sys.getenv()
[10:26:11.929]                 names <- names(envs)
[10:26:11.929]                 common <- intersect(names, old_names)
[10:26:11.929]                 added <- setdiff(names, old_names)
[10:26:11.929]                 removed <- setdiff(old_names, names)
[10:26:11.929]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.929]                   envs[common]]
[10:26:11.929]                 NAMES <- toupper(changed)
[10:26:11.929]                 args <- list()
[10:26:11.929]                 for (kk in seq_along(NAMES)) {
[10:26:11.929]                   name <- changed[[kk]]
[10:26:11.929]                   NAME <- NAMES[[kk]]
[10:26:11.929]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.929]                     next
[10:26:11.929]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.929]                 }
[10:26:11.929]                 NAMES <- toupper(added)
[10:26:11.929]                 for (kk in seq_along(NAMES)) {
[10:26:11.929]                   name <- added[[kk]]
[10:26:11.929]                   NAME <- NAMES[[kk]]
[10:26:11.929]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.929]                     next
[10:26:11.929]                   args[[name]] <- ""
[10:26:11.929]                 }
[10:26:11.929]                 NAMES <- toupper(removed)
[10:26:11.929]                 for (kk in seq_along(NAMES)) {
[10:26:11.929]                   name <- removed[[kk]]
[10:26:11.929]                   NAME <- NAMES[[kk]]
[10:26:11.929]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.929]                     next
[10:26:11.929]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.929]                 }
[10:26:11.929]                 if (length(args) > 0) 
[10:26:11.929]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.929]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.929]             }
[10:26:11.929]             else {
[10:26:11.929]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.929]             }
[10:26:11.929]             {
[10:26:11.929]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.929]                   0L) {
[10:26:11.929]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.929]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.929]                   base::options(opts)
[10:26:11.929]                 }
[10:26:11.929]                 {
[10:26:11.929]                   {
[10:26:11.929]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:11.929]                     NULL
[10:26:11.929]                   }
[10:26:11.929]                   options(future.plan = NULL)
[10:26:11.929]                   if (is.na(NA_character_)) 
[10:26:11.929]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.929]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.929]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:11.929]                     envir = parent.frame()) 
[10:26:11.929]                   {
[10:26:11.929]                     default_workers <- missing(workers)
[10:26:11.929]                     if (is.function(workers)) 
[10:26:11.929]                       workers <- workers()
[10:26:11.929]                     workers <- structure(as.integer(workers), 
[10:26:11.929]                       class = class(workers))
[10:26:11.929]                     stop_if_not(is.finite(workers), workers >= 
[10:26:11.929]                       1L)
[10:26:11.929]                     if ((workers == 1L && !inherits(workers, 
[10:26:11.929]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:11.929]                       if (default_workers) 
[10:26:11.929]                         supportsMulticore(warn = TRUE)
[10:26:11.929]                       return(sequential(..., envir = envir))
[10:26:11.929]                     }
[10:26:11.929]                     oopts <- options(mc.cores = workers)
[10:26:11.929]                     on.exit(options(oopts))
[10:26:11.929]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:11.929]                       envir = envir)
[10:26:11.929]                     if (!future$lazy) 
[10:26:11.929]                       future <- run(future)
[10:26:11.929]                     invisible(future)
[10:26:11.929]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.929]                 }
[10:26:11.929]             }
[10:26:11.929]         }
[10:26:11.929]     })
[10:26:11.929]     if (TRUE) {
[10:26:11.929]         base::sink(type = "output", split = FALSE)
[10:26:11.929]         if (TRUE) {
[10:26:11.929]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.929]         }
[10:26:11.929]         else {
[10:26:11.929]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.929]         }
[10:26:11.929]         base::close(...future.stdout)
[10:26:11.929]         ...future.stdout <- NULL
[10:26:11.929]     }
[10:26:11.929]     ...future.result$conditions <- ...future.conditions
[10:26:11.929]     ...future.result$finished <- base::Sys.time()
[10:26:11.929]     ...future.result
[10:26:11.929] }
[10:26:11.932] assign_globals() ...
[10:26:11.932] List of 1
[10:26:11.932]  $ ii: int 2
[10:26:11.932]  - attr(*, "where")=List of 1
[10:26:11.932]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:11.932]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.932]  - attr(*, "resolved")= logi TRUE
[10:26:11.932]  - attr(*, "total_size")= num 56
[10:26:11.932]  - attr(*, "already-done")= logi TRUE
[10:26:11.936] - copied ‘ii’ to environment
[10:26:11.936] assign_globals() ... done
[10:26:11.937] requestCore(): workers = 2
[10:26:11.939] MulticoreFuture started
[10:26:11.939] - Launch lazy future ... done
[10:26:11.939] run() for ‘MulticoreFuture’ ... done
[10:26:11.940] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:11.940] List of future strategies:
[10:26:11.940] 1. sequential:
[10:26:11.940]    - args: function (..., envir = parent.frame())
[10:26:11.940]    - tweaked: FALSE
[10:26:11.940]    - call: NULL
[10:26:11.941] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:11.941] plan(): nbrOfWorkers() = 1
[10:26:11.941] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:11.943] plan(): Setting new future strategy stack:
[10:26:11.943] List of future strategies:
[10:26:11.943] 1. multicore:
[10:26:11.943]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:11.943]    - tweaked: FALSE
[10:26:11.943]    - call: plan(strategy)
[10:26:11.944] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:11.944] Searching for globals ... DONE
[10:26:11.945] Resolving globals: TRUE
[10:26:11.945] Resolving any globals that are futures ...
[10:26:11.945] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:11.945] Resolving any globals that are futures ... DONE
[10:26:11.946] Resolving futures part of globals (recursively) ...
[10:26:11.946] resolve() on list ...
[10:26:11.946]  recursive: 99
[10:26:11.947]  length: 1
[10:26:11.947]  elements: ‘ii’
[10:26:11.947]  length: 0 (resolved future 1)
[10:26:11.947] resolve() on list ... DONE
[10:26:11.947] - globals: [1] ‘ii’
[10:26:11.947] Resolving futures part of globals (recursively) ... DONE
[10:26:11.948] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:11.948] plan(): nbrOfWorkers() = 2
[10:26:11.948] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:11.948] - globals: [1] ‘ii’
[10:26:11.949] 
[10:26:11.949] getGlobalsAndPackages() ... DONE
[10:26:11.949] run() for ‘Future’ ...
[10:26:11.949] - state: ‘created’
[10:26:11.950] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:11.954] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:11.954] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:11.954]   - Field: ‘label’
[10:26:11.955]   - Field: ‘local’
[10:26:11.955]   - Field: ‘owner’
[10:26:11.955]   - Field: ‘envir’
[10:26:11.955]   - Field: ‘workers’
[10:26:11.955]   - Field: ‘packages’
[10:26:11.955]   - Field: ‘gc’
[10:26:11.955]   - Field: ‘job’
[10:26:11.956]   - Field: ‘conditions’
[10:26:11.956]   - Field: ‘expr’
[10:26:11.956]   - Field: ‘uuid’
[10:26:11.956]   - Field: ‘seed’
[10:26:11.956]   - Field: ‘version’
[10:26:11.956]   - Field: ‘result’
[10:26:11.956]   - Field: ‘asynchronous’
[10:26:11.957]   - Field: ‘calls’
[10:26:11.957]   - Field: ‘globals’
[10:26:11.957]   - Field: ‘stdout’
[10:26:11.957]   - Field: ‘earlySignal’
[10:26:11.957]   - Field: ‘lazy’
[10:26:11.957]   - Field: ‘state’
[10:26:11.957] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:11.958] - Launch lazy future ...
[10:26:11.958] Packages needed by the future expression (n = 0): <none>
[10:26:11.958] Packages needed by future strategies (n = 0): <none>
[10:26:11.959] {
[10:26:11.959]     {
[10:26:11.959]         {
[10:26:11.959]             ...future.startTime <- base::Sys.time()
[10:26:11.959]             {
[10:26:11.959]                 {
[10:26:11.959]                   {
[10:26:11.959]                     {
[10:26:11.959]                       base::local({
[10:26:11.959]                         has_future <- base::requireNamespace("future", 
[10:26:11.959]                           quietly = TRUE)
[10:26:11.959]                         if (has_future) {
[10:26:11.959]                           ns <- base::getNamespace("future")
[10:26:11.959]                           version <- ns[[".package"]][["version"]]
[10:26:11.959]                           if (is.null(version)) 
[10:26:11.959]                             version <- utils::packageVersion("future")
[10:26:11.959]                         }
[10:26:11.959]                         else {
[10:26:11.959]                           version <- NULL
[10:26:11.959]                         }
[10:26:11.959]                         if (!has_future || version < "1.8.0") {
[10:26:11.959]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:11.959]                             "", base::R.version$version.string), 
[10:26:11.959]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:11.959]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:11.959]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:11.959]                               "release", "version")], collapse = " "), 
[10:26:11.959]                             hostname = base::Sys.info()[["nodename"]])
[10:26:11.959]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:11.959]                             info)
[10:26:11.959]                           info <- base::paste(info, collapse = "; ")
[10:26:11.959]                           if (!has_future) {
[10:26:11.959]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:11.959]                               info)
[10:26:11.959]                           }
[10:26:11.959]                           else {
[10:26:11.959]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:11.959]                               info, version)
[10:26:11.959]                           }
[10:26:11.959]                           base::stop(msg)
[10:26:11.959]                         }
[10:26:11.959]                       })
[10:26:11.959]                     }
[10:26:11.959]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:11.959]                     base::options(mc.cores = 1L)
[10:26:11.959]                   }
[10:26:11.959]                   options(future.plan = NULL)
[10:26:11.959]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.959]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:11.959]                 }
[10:26:11.959]                 ...future.workdir <- getwd()
[10:26:11.959]             }
[10:26:11.959]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:11.959]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:11.959]         }
[10:26:11.959]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:11.959]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:11.959]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:11.959]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:11.959]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:11.959]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:11.959]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:11.959]             base::names(...future.oldOptions))
[10:26:11.959]     }
[10:26:11.959]     if (FALSE) {
[10:26:11.959]     }
[10:26:11.959]     else {
[10:26:11.959]         if (TRUE) {
[10:26:11.959]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:11.959]                 open = "w")
[10:26:11.959]         }
[10:26:11.959]         else {
[10:26:11.959]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:11.959]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:11.959]         }
[10:26:11.959]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:11.959]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:11.959]             base::sink(type = "output", split = FALSE)
[10:26:11.959]             base::close(...future.stdout)
[10:26:11.959]         }, add = TRUE)
[10:26:11.959]     }
[10:26:11.959]     ...future.frame <- base::sys.nframe()
[10:26:11.959]     ...future.conditions <- base::list()
[10:26:11.959]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:11.959]     if (FALSE) {
[10:26:11.959]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:11.959]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:11.959]     }
[10:26:11.959]     ...future.result <- base::tryCatch({
[10:26:11.959]         base::withCallingHandlers({
[10:26:11.959]             ...future.value <- base::withVisible(base::local({
[10:26:11.959]                 withCallingHandlers({
[10:26:11.959]                   {
[10:26:11.959]                     b <- a * ii
[10:26:11.959]                     a <- 0
[10:26:11.959]                     b
[10:26:11.959]                   }
[10:26:11.959]                 }, immediateCondition = function(cond) {
[10:26:11.959]                   save_rds <- function (object, pathname, ...) 
[10:26:11.959]                   {
[10:26:11.959]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:11.959]                     if (file_test("-f", pathname_tmp)) {
[10:26:11.959]                       fi_tmp <- file.info(pathname_tmp)
[10:26:11.959]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:11.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:11.959]                         fi_tmp[["mtime"]])
[10:26:11.959]                     }
[10:26:11.959]                     tryCatch({
[10:26:11.959]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:11.959]                     }, error = function(ex) {
[10:26:11.959]                       msg <- conditionMessage(ex)
[10:26:11.959]                       fi_tmp <- file.info(pathname_tmp)
[10:26:11.959]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:11.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:11.959]                         fi_tmp[["mtime"]], msg)
[10:26:11.959]                       ex$message <- msg
[10:26:11.959]                       stop(ex)
[10:26:11.959]                     })
[10:26:11.959]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:11.959]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:11.959]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:11.959]                       fi_tmp <- file.info(pathname_tmp)
[10:26:11.959]                       fi <- file.info(pathname)
[10:26:11.959]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:11.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:11.959]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:11.959]                         fi[["size"]], fi[["mtime"]])
[10:26:11.959]                       stop(msg)
[10:26:11.959]                     }
[10:26:11.959]                     invisible(pathname)
[10:26:11.959]                   }
[10:26:11.959]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:11.959]                     rootPath = tempdir()) 
[10:26:11.959]                   {
[10:26:11.959]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:11.959]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:11.959]                       tmpdir = path, fileext = ".rds")
[10:26:11.959]                     save_rds(obj, file)
[10:26:11.959]                   }
[10:26:11.959]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:11.959]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.959]                   {
[10:26:11.959]                     inherits <- base::inherits
[10:26:11.959]                     invokeRestart <- base::invokeRestart
[10:26:11.959]                     is.null <- base::is.null
[10:26:11.959]                     muffled <- FALSE
[10:26:11.959]                     if (inherits(cond, "message")) {
[10:26:11.959]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:11.959]                       if (muffled) 
[10:26:11.959]                         invokeRestart("muffleMessage")
[10:26:11.959]                     }
[10:26:11.959]                     else if (inherits(cond, "warning")) {
[10:26:11.959]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:11.959]                       if (muffled) 
[10:26:11.959]                         invokeRestart("muffleWarning")
[10:26:11.959]                     }
[10:26:11.959]                     else if (inherits(cond, "condition")) {
[10:26:11.959]                       if (!is.null(pattern)) {
[10:26:11.959]                         computeRestarts <- base::computeRestarts
[10:26:11.959]                         grepl <- base::grepl
[10:26:11.959]                         restarts <- computeRestarts(cond)
[10:26:11.959]                         for (restart in restarts) {
[10:26:11.959]                           name <- restart$name
[10:26:11.959]                           if (is.null(name)) 
[10:26:11.959]                             next
[10:26:11.959]                           if (!grepl(pattern, name)) 
[10:26:11.959]                             next
[10:26:11.959]                           invokeRestart(restart)
[10:26:11.959]                           muffled <- TRUE
[10:26:11.959]                           break
[10:26:11.959]                         }
[10:26:11.959]                       }
[10:26:11.959]                     }
[10:26:11.959]                     invisible(muffled)
[10:26:11.959]                   }
[10:26:11.959]                   muffleCondition(cond)
[10:26:11.959]                 })
[10:26:11.959]             }))
[10:26:11.959]             future::FutureResult(value = ...future.value$value, 
[10:26:11.959]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.959]                   ...future.rng), globalenv = if (FALSE) 
[10:26:11.959]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:11.959]                     ...future.globalenv.names))
[10:26:11.959]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:11.959]         }, condition = base::local({
[10:26:11.959]             c <- base::c
[10:26:11.959]             inherits <- base::inherits
[10:26:11.959]             invokeRestart <- base::invokeRestart
[10:26:11.959]             length <- base::length
[10:26:11.959]             list <- base::list
[10:26:11.959]             seq.int <- base::seq.int
[10:26:11.959]             signalCondition <- base::signalCondition
[10:26:11.959]             sys.calls <- base::sys.calls
[10:26:11.959]             `[[` <- base::`[[`
[10:26:11.959]             `+` <- base::`+`
[10:26:11.959]             `<<-` <- base::`<<-`
[10:26:11.959]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:11.959]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:11.959]                   3L)]
[10:26:11.959]             }
[10:26:11.959]             function(cond) {
[10:26:11.959]                 is_error <- inherits(cond, "error")
[10:26:11.959]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:11.959]                   NULL)
[10:26:11.959]                 if (is_error) {
[10:26:11.959]                   sessionInformation <- function() {
[10:26:11.959]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:11.959]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:11.959]                       search = base::search(), system = base::Sys.info())
[10:26:11.959]                   }
[10:26:11.959]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.959]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:11.959]                     cond$call), session = sessionInformation(), 
[10:26:11.959]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:11.959]                   signalCondition(cond)
[10:26:11.959]                 }
[10:26:11.959]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:11.959]                 "immediateCondition"))) {
[10:26:11.959]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:11.959]                   ...future.conditions[[length(...future.conditions) + 
[10:26:11.959]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:11.959]                   if (TRUE && !signal) {
[10:26:11.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.959]                     {
[10:26:11.959]                       inherits <- base::inherits
[10:26:11.959]                       invokeRestart <- base::invokeRestart
[10:26:11.959]                       is.null <- base::is.null
[10:26:11.959]                       muffled <- FALSE
[10:26:11.959]                       if (inherits(cond, "message")) {
[10:26:11.959]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.959]                         if (muffled) 
[10:26:11.959]                           invokeRestart("muffleMessage")
[10:26:11.959]                       }
[10:26:11.959]                       else if (inherits(cond, "warning")) {
[10:26:11.959]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.959]                         if (muffled) 
[10:26:11.959]                           invokeRestart("muffleWarning")
[10:26:11.959]                       }
[10:26:11.959]                       else if (inherits(cond, "condition")) {
[10:26:11.959]                         if (!is.null(pattern)) {
[10:26:11.959]                           computeRestarts <- base::computeRestarts
[10:26:11.959]                           grepl <- base::grepl
[10:26:11.959]                           restarts <- computeRestarts(cond)
[10:26:11.959]                           for (restart in restarts) {
[10:26:11.959]                             name <- restart$name
[10:26:11.959]                             if (is.null(name)) 
[10:26:11.959]                               next
[10:26:11.959]                             if (!grepl(pattern, name)) 
[10:26:11.959]                               next
[10:26:11.959]                             invokeRestart(restart)
[10:26:11.959]                             muffled <- TRUE
[10:26:11.959]                             break
[10:26:11.959]                           }
[10:26:11.959]                         }
[10:26:11.959]                       }
[10:26:11.959]                       invisible(muffled)
[10:26:11.959]                     }
[10:26:11.959]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.959]                   }
[10:26:11.959]                 }
[10:26:11.959]                 else {
[10:26:11.959]                   if (TRUE) {
[10:26:11.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:11.959]                     {
[10:26:11.959]                       inherits <- base::inherits
[10:26:11.959]                       invokeRestart <- base::invokeRestart
[10:26:11.959]                       is.null <- base::is.null
[10:26:11.959]                       muffled <- FALSE
[10:26:11.959]                       if (inherits(cond, "message")) {
[10:26:11.959]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:11.959]                         if (muffled) 
[10:26:11.959]                           invokeRestart("muffleMessage")
[10:26:11.959]                       }
[10:26:11.959]                       else if (inherits(cond, "warning")) {
[10:26:11.959]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:11.959]                         if (muffled) 
[10:26:11.959]                           invokeRestart("muffleWarning")
[10:26:11.959]                       }
[10:26:11.959]                       else if (inherits(cond, "condition")) {
[10:26:11.959]                         if (!is.null(pattern)) {
[10:26:11.959]                           computeRestarts <- base::computeRestarts
[10:26:11.959]                           grepl <- base::grepl
[10:26:11.959]                           restarts <- computeRestarts(cond)
[10:26:11.959]                           for (restart in restarts) {
[10:26:11.959]                             name <- restart$name
[10:26:11.959]                             if (is.null(name)) 
[10:26:11.959]                               next
[10:26:11.959]                             if (!grepl(pattern, name)) 
[10:26:11.959]                               next
[10:26:11.959]                             invokeRestart(restart)
[10:26:11.959]                             muffled <- TRUE
[10:26:11.959]                             break
[10:26:11.959]                           }
[10:26:11.959]                         }
[10:26:11.959]                       }
[10:26:11.959]                       invisible(muffled)
[10:26:11.959]                     }
[10:26:11.959]                     muffleCondition(cond, pattern = "^muffle")
[10:26:11.959]                   }
[10:26:11.959]                 }
[10:26:11.959]             }
[10:26:11.959]         }))
[10:26:11.959]     }, error = function(ex) {
[10:26:11.959]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:11.959]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:11.959]                 ...future.rng), started = ...future.startTime, 
[10:26:11.959]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:11.959]             version = "1.8"), class = "FutureResult")
[10:26:11.959]     }, finally = {
[10:26:11.959]         if (!identical(...future.workdir, getwd())) 
[10:26:11.959]             setwd(...future.workdir)
[10:26:11.959]         {
[10:26:11.959]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:11.959]                 ...future.oldOptions$nwarnings <- NULL
[10:26:11.959]             }
[10:26:11.959]             base::options(...future.oldOptions)
[10:26:11.959]             if (.Platform$OS.type == "windows") {
[10:26:11.959]                 old_names <- names(...future.oldEnvVars)
[10:26:11.959]                 envs <- base::Sys.getenv()
[10:26:11.959]                 names <- names(envs)
[10:26:11.959]                 common <- intersect(names, old_names)
[10:26:11.959]                 added <- setdiff(names, old_names)
[10:26:11.959]                 removed <- setdiff(old_names, names)
[10:26:11.959]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:11.959]                   envs[common]]
[10:26:11.959]                 NAMES <- toupper(changed)
[10:26:11.959]                 args <- list()
[10:26:11.959]                 for (kk in seq_along(NAMES)) {
[10:26:11.959]                   name <- changed[[kk]]
[10:26:11.959]                   NAME <- NAMES[[kk]]
[10:26:11.959]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.959]                     next
[10:26:11.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.959]                 }
[10:26:11.959]                 NAMES <- toupper(added)
[10:26:11.959]                 for (kk in seq_along(NAMES)) {
[10:26:11.959]                   name <- added[[kk]]
[10:26:11.959]                   NAME <- NAMES[[kk]]
[10:26:11.959]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.959]                     next
[10:26:11.959]                   args[[name]] <- ""
[10:26:11.959]                 }
[10:26:11.959]                 NAMES <- toupper(removed)
[10:26:11.959]                 for (kk in seq_along(NAMES)) {
[10:26:11.959]                   name <- removed[[kk]]
[10:26:11.959]                   NAME <- NAMES[[kk]]
[10:26:11.959]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:11.959]                     next
[10:26:11.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:11.959]                 }
[10:26:11.959]                 if (length(args) > 0) 
[10:26:11.959]                   base::do.call(base::Sys.setenv, args = args)
[10:26:11.959]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:11.959]             }
[10:26:11.959]             else {
[10:26:11.959]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:11.959]             }
[10:26:11.959]             {
[10:26:11.959]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:11.959]                   0L) {
[10:26:11.959]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:11.959]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:11.959]                   base::options(opts)
[10:26:11.959]                 }
[10:26:11.959]                 {
[10:26:11.959]                   {
[10:26:11.959]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:11.959]                     NULL
[10:26:11.959]                   }
[10:26:11.959]                   options(future.plan = NULL)
[10:26:11.959]                   if (is.na(NA_character_)) 
[10:26:11.959]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:11.959]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:11.959]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:11.959]                     envir = parent.frame()) 
[10:26:11.959]                   {
[10:26:11.959]                     default_workers <- missing(workers)
[10:26:11.959]                     if (is.function(workers)) 
[10:26:11.959]                       workers <- workers()
[10:26:11.959]                     workers <- structure(as.integer(workers), 
[10:26:11.959]                       class = class(workers))
[10:26:11.959]                     stop_if_not(is.finite(workers), workers >= 
[10:26:11.959]                       1L)
[10:26:11.959]                     if ((workers == 1L && !inherits(workers, 
[10:26:11.959]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:11.959]                       if (default_workers) 
[10:26:11.959]                         supportsMulticore(warn = TRUE)
[10:26:11.959]                       return(sequential(..., envir = envir))
[10:26:11.959]                     }
[10:26:11.959]                     oopts <- options(mc.cores = workers)
[10:26:11.959]                     on.exit(options(oopts))
[10:26:11.959]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:11.959]                       envir = envir)
[10:26:11.959]                     if (!future$lazy) 
[10:26:11.959]                       future <- run(future)
[10:26:11.959]                     invisible(future)
[10:26:11.959]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:11.959]                 }
[10:26:11.959]             }
[10:26:11.959]         }
[10:26:11.959]     })
[10:26:11.959]     if (TRUE) {
[10:26:11.959]         base::sink(type = "output", split = FALSE)
[10:26:11.959]         if (TRUE) {
[10:26:11.959]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:11.959]         }
[10:26:11.959]         else {
[10:26:11.959]             ...future.result["stdout"] <- base::list(NULL)
[10:26:11.959]         }
[10:26:11.959]         base::close(...future.stdout)
[10:26:11.959]         ...future.stdout <- NULL
[10:26:11.959]     }
[10:26:11.959]     ...future.result$conditions <- ...future.conditions
[10:26:11.959]     ...future.result$finished <- base::Sys.time()
[10:26:11.959]     ...future.result
[10:26:11.959] }
[10:26:11.962] assign_globals() ...
[10:26:11.962] List of 1
[10:26:11.962]  $ ii: int 3
[10:26:11.962]  - attr(*, "where")=List of 1
[10:26:11.962]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:11.962]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:11.962]  - attr(*, "resolved")= logi TRUE
[10:26:11.962]  - attr(*, "total_size")= num 56
[10:26:11.962]  - attr(*, "already-done")= logi TRUE
[10:26:11.966] - copied ‘ii’ to environment
[10:26:11.966] assign_globals() ... done
[10:26:11.967] requestCore(): workers = 2
[10:26:11.967] Poll #1 (0): usedCores() = 2, workers = 2
[10:26:11.978] result() for MulticoreFuture ...
[10:26:11.979] result() for MulticoreFuture ...
[10:26:11.979] result() for MulticoreFuture ... done
[10:26:11.980] result() for MulticoreFuture ... done
[10:26:11.980] result() for MulticoreFuture ...
[10:26:11.980] result() for MulticoreFuture ... done
[10:26:11.986] MulticoreFuture started
[10:26:11.987] - Launch lazy future ... done
[10:26:11.987] run() for ‘MulticoreFuture’ ... done
[10:26:11.987] plan(): Setting new future strategy stack:
[10:26:11.988] result() for MulticoreFuture ...
[10:26:11.989] result() for MulticoreFuture ... done
[10:26:11.988] List of future strategies:
[10:26:11.988] 1. sequential:
[10:26:11.988]    - args: function (..., envir = parent.frame())
[10:26:11.988]    - tweaked: FALSE
[10:26:11.988]    - call: NULL
[10:26:11.989] result() for MulticoreFuture ...
[10:26:11.989] plan(): nbrOfWorkers() = 1
[10:26:11.989] result() for MulticoreFuture ... done
[10:26:11.990] result() for MulticoreFuture ...
[10:26:11.992] plan(): Setting new future strategy stack:
[10:26:11.992] result() for MulticoreFuture ...
[10:26:11.992] result() for MulticoreFuture ... done
[10:26:11.992] List of future strategies:
[10:26:11.992] 1. multicore:
[10:26:11.992]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:11.992]    - tweaked: FALSE
[10:26:11.992]    - call: plan(strategy)
[10:26:11.993] result() for MulticoreFuture ... done
[10:26:11.993] result() for MulticoreFuture ...
[10:26:11.993] result() for MulticoreFuture ... done
[10:26:11.994] result() for MulticoreFuture ...
[10:26:11.997] plan(): nbrOfWorkers() = 2
[10:26:11.998] result() for MulticoreFuture ...
[10:26:11.998] result() for MulticoreFuture ... done
[10:26:11.998] result() for MulticoreFuture ... done
[10:26:11.999] result() for MulticoreFuture ...
[10:26:11.999] result() for MulticoreFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.000] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.000] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:12.002] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:12.002] Searching for globals ... DONE
[10:26:12.002] Resolving globals: TRUE
[10:26:12.003] Resolving any globals that are futures ...
[10:26:12.003] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:12.003] Resolving any globals that are futures ... DONE
[10:26:12.003] Resolving futures part of globals (recursively) ...
[10:26:12.004] resolve() on list ...
[10:26:12.004]  recursive: 99
[10:26:12.004]  length: 1
[10:26:12.004]  elements: ‘ii’
[10:26:12.004]  length: 0 (resolved future 1)
[10:26:12.004] resolve() on list ... DONE
[10:26:12.004] - globals: [1] ‘ii’
[10:26:12.004] Resolving futures part of globals (recursively) ... DONE
[10:26:12.005] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:12.005] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:12.005] - globals: [1] ‘ii’
[10:26:12.005] 
[10:26:12.005] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.006] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.006] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:12.008] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:12.008] Searching for globals ... DONE
[10:26:12.008] Resolving globals: TRUE
[10:26:12.008] Resolving any globals that are futures ...
[10:26:12.008] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:12.008] Resolving any globals that are futures ... DONE
[10:26:12.009] Resolving futures part of globals (recursively) ...
[10:26:12.009] resolve() on list ...
[10:26:12.009]  recursive: 99
[10:26:12.009]  length: 1
[10:26:12.009]  elements: ‘ii’
[10:26:12.010]  length: 0 (resolved future 1)
[10:26:12.010] resolve() on list ... DONE
[10:26:12.010] - globals: [1] ‘ii’
[10:26:12.010] Resolving futures part of globals (recursively) ... DONE
[10:26:12.010] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:12.010] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:12.011] - globals: [1] ‘ii’
[10:26:12.011] 
[10:26:12.011] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.011] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.012] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:12.013] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:12.013] Searching for globals ... DONE
[10:26:12.013] Resolving globals: TRUE
[10:26:12.013] Resolving any globals that are futures ...
[10:26:12.013] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:12.014] Resolving any globals that are futures ... DONE
[10:26:12.014] Resolving futures part of globals (recursively) ...
[10:26:12.014] resolve() on list ...
[10:26:12.014]  recursive: 99
[10:26:12.014]  length: 1
[10:26:12.014]  elements: ‘ii’
[10:26:12.015]  length: 0 (resolved future 1)
[10:26:12.015] resolve() on list ... DONE
[10:26:12.015] - globals: [1] ‘ii’
[10:26:12.015] Resolving futures part of globals (recursively) ... DONE
[10:26:12.015] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:12.015] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:12.015] - globals: [1] ‘ii’
[10:26:12.016] 
[10:26:12.016] getGlobalsAndPackages() ... DONE
[10:26:12.016] run() for ‘Future’ ...
[10:26:12.016] - state: ‘created’
[10:26:12.016] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.020] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.021] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.021]   - Field: ‘label’
[10:26:12.021]   - Field: ‘local’
[10:26:12.021]   - Field: ‘owner’
[10:26:12.021]   - Field: ‘envir’
[10:26:12.021]   - Field: ‘workers’
[10:26:12.021]   - Field: ‘packages’
[10:26:12.021]   - Field: ‘gc’
[10:26:12.021]   - Field: ‘job’
[10:26:12.022]   - Field: ‘conditions’
[10:26:12.023]   - Field: ‘expr’
[10:26:12.023]   - Field: ‘uuid’
[10:26:12.024]   - Field: ‘seed’
[10:26:12.024]   - Field: ‘version’
[10:26:12.024]   - Field: ‘result’
[10:26:12.024]   - Field: ‘asynchronous’
[10:26:12.024]   - Field: ‘calls’
[10:26:12.024]   - Field: ‘globals’
[10:26:12.024]   - Field: ‘stdout’
[10:26:12.024]   - Field: ‘earlySignal’
[10:26:12.024]   - Field: ‘lazy’
[10:26:12.024]   - Field: ‘state’
[10:26:12.025] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.025] - Launch lazy future ...
[10:26:12.025] Packages needed by the future expression (n = 0): <none>
[10:26:12.025] Packages needed by future strategies (n = 0): <none>
[10:26:12.026] {
[10:26:12.026]     {
[10:26:12.026]         {
[10:26:12.026]             ...future.startTime <- base::Sys.time()
[10:26:12.026]             {
[10:26:12.026]                 {
[10:26:12.026]                   {
[10:26:12.026]                     {
[10:26:12.026]                       base::local({
[10:26:12.026]                         has_future <- base::requireNamespace("future", 
[10:26:12.026]                           quietly = TRUE)
[10:26:12.026]                         if (has_future) {
[10:26:12.026]                           ns <- base::getNamespace("future")
[10:26:12.026]                           version <- ns[[".package"]][["version"]]
[10:26:12.026]                           if (is.null(version)) 
[10:26:12.026]                             version <- utils::packageVersion("future")
[10:26:12.026]                         }
[10:26:12.026]                         else {
[10:26:12.026]                           version <- NULL
[10:26:12.026]                         }
[10:26:12.026]                         if (!has_future || version < "1.8.0") {
[10:26:12.026]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.026]                             "", base::R.version$version.string), 
[10:26:12.026]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:12.026]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:12.026]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.026]                               "release", "version")], collapse = " "), 
[10:26:12.026]                             hostname = base::Sys.info()[["nodename"]])
[10:26:12.026]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.026]                             info)
[10:26:12.026]                           info <- base::paste(info, collapse = "; ")
[10:26:12.026]                           if (!has_future) {
[10:26:12.026]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.026]                               info)
[10:26:12.026]                           }
[10:26:12.026]                           else {
[10:26:12.026]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.026]                               info, version)
[10:26:12.026]                           }
[10:26:12.026]                           base::stop(msg)
[10:26:12.026]                         }
[10:26:12.026]                       })
[10:26:12.026]                     }
[10:26:12.026]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.026]                     base::options(mc.cores = 1L)
[10:26:12.026]                   }
[10:26:12.026]                   options(future.plan = NULL)
[10:26:12.026]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.026]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.026]                 }
[10:26:12.026]                 ...future.workdir <- getwd()
[10:26:12.026]             }
[10:26:12.026]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.026]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.026]         }
[10:26:12.026]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.026]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:12.026]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.026]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.026]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.026]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.026]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.026]             base::names(...future.oldOptions))
[10:26:12.026]     }
[10:26:12.026]     if (FALSE) {
[10:26:12.026]     }
[10:26:12.026]     else {
[10:26:12.026]         if (TRUE) {
[10:26:12.026]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.026]                 open = "w")
[10:26:12.026]         }
[10:26:12.026]         else {
[10:26:12.026]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.026]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.026]         }
[10:26:12.026]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.026]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.026]             base::sink(type = "output", split = FALSE)
[10:26:12.026]             base::close(...future.stdout)
[10:26:12.026]         }, add = TRUE)
[10:26:12.026]     }
[10:26:12.026]     ...future.frame <- base::sys.nframe()
[10:26:12.026]     ...future.conditions <- base::list()
[10:26:12.026]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.026]     if (FALSE) {
[10:26:12.026]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.026]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.026]     }
[10:26:12.026]     ...future.result <- base::tryCatch({
[10:26:12.026]         base::withCallingHandlers({
[10:26:12.026]             ...future.value <- base::withVisible(base::local({
[10:26:12.026]                 withCallingHandlers({
[10:26:12.026]                   {
[10:26:12.026]                     b <- a * ii
[10:26:12.026]                     a <- 0
[10:26:12.026]                     b
[10:26:12.026]                   }
[10:26:12.026]                 }, immediateCondition = function(cond) {
[10:26:12.026]                   save_rds <- function (object, pathname, ...) 
[10:26:12.026]                   {
[10:26:12.026]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.026]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.026]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.026]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.026]                         fi_tmp[["mtime"]])
[10:26:12.026]                     }
[10:26:12.026]                     tryCatch({
[10:26:12.026]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.026]                     }, error = function(ex) {
[10:26:12.026]                       msg <- conditionMessage(ex)
[10:26:12.026]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.026]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.026]                         fi_tmp[["mtime"]], msg)
[10:26:12.026]                       ex$message <- msg
[10:26:12.026]                       stop(ex)
[10:26:12.026]                     })
[10:26:12.026]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.026]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.026]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.026]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.026]                       fi <- file.info(pathname)
[10:26:12.026]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.026]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.026]                         fi[["size"]], fi[["mtime"]])
[10:26:12.026]                       stop(msg)
[10:26:12.026]                     }
[10:26:12.026]                     invisible(pathname)
[10:26:12.026]                   }
[10:26:12.026]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.026]                     rootPath = tempdir()) 
[10:26:12.026]                   {
[10:26:12.026]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.026]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.026]                       tmpdir = path, fileext = ".rds")
[10:26:12.026]                     save_rds(obj, file)
[10:26:12.026]                   }
[10:26:12.026]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.026]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.026]                   {
[10:26:12.026]                     inherits <- base::inherits
[10:26:12.026]                     invokeRestart <- base::invokeRestart
[10:26:12.026]                     is.null <- base::is.null
[10:26:12.026]                     muffled <- FALSE
[10:26:12.026]                     if (inherits(cond, "message")) {
[10:26:12.026]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.026]                       if (muffled) 
[10:26:12.026]                         invokeRestart("muffleMessage")
[10:26:12.026]                     }
[10:26:12.026]                     else if (inherits(cond, "warning")) {
[10:26:12.026]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.026]                       if (muffled) 
[10:26:12.026]                         invokeRestart("muffleWarning")
[10:26:12.026]                     }
[10:26:12.026]                     else if (inherits(cond, "condition")) {
[10:26:12.026]                       if (!is.null(pattern)) {
[10:26:12.026]                         computeRestarts <- base::computeRestarts
[10:26:12.026]                         grepl <- base::grepl
[10:26:12.026]                         restarts <- computeRestarts(cond)
[10:26:12.026]                         for (restart in restarts) {
[10:26:12.026]                           name <- restart$name
[10:26:12.026]                           if (is.null(name)) 
[10:26:12.026]                             next
[10:26:12.026]                           if (!grepl(pattern, name)) 
[10:26:12.026]                             next
[10:26:12.026]                           invokeRestart(restart)
[10:26:12.026]                           muffled <- TRUE
[10:26:12.026]                           break
[10:26:12.026]                         }
[10:26:12.026]                       }
[10:26:12.026]                     }
[10:26:12.026]                     invisible(muffled)
[10:26:12.026]                   }
[10:26:12.026]                   muffleCondition(cond)
[10:26:12.026]                 })
[10:26:12.026]             }))
[10:26:12.026]             future::FutureResult(value = ...future.value$value, 
[10:26:12.026]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.026]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.026]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.026]                     ...future.globalenv.names))
[10:26:12.026]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.026]         }, condition = base::local({
[10:26:12.026]             c <- base::c
[10:26:12.026]             inherits <- base::inherits
[10:26:12.026]             invokeRestart <- base::invokeRestart
[10:26:12.026]             length <- base::length
[10:26:12.026]             list <- base::list
[10:26:12.026]             seq.int <- base::seq.int
[10:26:12.026]             signalCondition <- base::signalCondition
[10:26:12.026]             sys.calls <- base::sys.calls
[10:26:12.026]             `[[` <- base::`[[`
[10:26:12.026]             `+` <- base::`+`
[10:26:12.026]             `<<-` <- base::`<<-`
[10:26:12.026]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.026]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.026]                   3L)]
[10:26:12.026]             }
[10:26:12.026]             function(cond) {
[10:26:12.026]                 is_error <- inherits(cond, "error")
[10:26:12.026]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.026]                   NULL)
[10:26:12.026]                 if (is_error) {
[10:26:12.026]                   sessionInformation <- function() {
[10:26:12.026]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.026]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.026]                       search = base::search(), system = base::Sys.info())
[10:26:12.026]                   }
[10:26:12.026]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.026]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.026]                     cond$call), session = sessionInformation(), 
[10:26:12.026]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.026]                   signalCondition(cond)
[10:26:12.026]                 }
[10:26:12.026]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.026]                 "immediateCondition"))) {
[10:26:12.026]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.026]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.026]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.026]                   if (TRUE && !signal) {
[10:26:12.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.026]                     {
[10:26:12.026]                       inherits <- base::inherits
[10:26:12.026]                       invokeRestart <- base::invokeRestart
[10:26:12.026]                       is.null <- base::is.null
[10:26:12.026]                       muffled <- FALSE
[10:26:12.026]                       if (inherits(cond, "message")) {
[10:26:12.026]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.026]                         if (muffled) 
[10:26:12.026]                           invokeRestart("muffleMessage")
[10:26:12.026]                       }
[10:26:12.026]                       else if (inherits(cond, "warning")) {
[10:26:12.026]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.026]                         if (muffled) 
[10:26:12.026]                           invokeRestart("muffleWarning")
[10:26:12.026]                       }
[10:26:12.026]                       else if (inherits(cond, "condition")) {
[10:26:12.026]                         if (!is.null(pattern)) {
[10:26:12.026]                           computeRestarts <- base::computeRestarts
[10:26:12.026]                           grepl <- base::grepl
[10:26:12.026]                           restarts <- computeRestarts(cond)
[10:26:12.026]                           for (restart in restarts) {
[10:26:12.026]                             name <- restart$name
[10:26:12.026]                             if (is.null(name)) 
[10:26:12.026]                               next
[10:26:12.026]                             if (!grepl(pattern, name)) 
[10:26:12.026]                               next
[10:26:12.026]                             invokeRestart(restart)
[10:26:12.026]                             muffled <- TRUE
[10:26:12.026]                             break
[10:26:12.026]                           }
[10:26:12.026]                         }
[10:26:12.026]                       }
[10:26:12.026]                       invisible(muffled)
[10:26:12.026]                     }
[10:26:12.026]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.026]                   }
[10:26:12.026]                 }
[10:26:12.026]                 else {
[10:26:12.026]                   if (TRUE) {
[10:26:12.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.026]                     {
[10:26:12.026]                       inherits <- base::inherits
[10:26:12.026]                       invokeRestart <- base::invokeRestart
[10:26:12.026]                       is.null <- base::is.null
[10:26:12.026]                       muffled <- FALSE
[10:26:12.026]                       if (inherits(cond, "message")) {
[10:26:12.026]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.026]                         if (muffled) 
[10:26:12.026]                           invokeRestart("muffleMessage")
[10:26:12.026]                       }
[10:26:12.026]                       else if (inherits(cond, "warning")) {
[10:26:12.026]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.026]                         if (muffled) 
[10:26:12.026]                           invokeRestart("muffleWarning")
[10:26:12.026]                       }
[10:26:12.026]                       else if (inherits(cond, "condition")) {
[10:26:12.026]                         if (!is.null(pattern)) {
[10:26:12.026]                           computeRestarts <- base::computeRestarts
[10:26:12.026]                           grepl <- base::grepl
[10:26:12.026]                           restarts <- computeRestarts(cond)
[10:26:12.026]                           for (restart in restarts) {
[10:26:12.026]                             name <- restart$name
[10:26:12.026]                             if (is.null(name)) 
[10:26:12.026]                               next
[10:26:12.026]                             if (!grepl(pattern, name)) 
[10:26:12.026]                               next
[10:26:12.026]                             invokeRestart(restart)
[10:26:12.026]                             muffled <- TRUE
[10:26:12.026]                             break
[10:26:12.026]                           }
[10:26:12.026]                         }
[10:26:12.026]                       }
[10:26:12.026]                       invisible(muffled)
[10:26:12.026]                     }
[10:26:12.026]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.026]                   }
[10:26:12.026]                 }
[10:26:12.026]             }
[10:26:12.026]         }))
[10:26:12.026]     }, error = function(ex) {
[10:26:12.026]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.026]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.026]                 ...future.rng), started = ...future.startTime, 
[10:26:12.026]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.026]             version = "1.8"), class = "FutureResult")
[10:26:12.026]     }, finally = {
[10:26:12.026]         if (!identical(...future.workdir, getwd())) 
[10:26:12.026]             setwd(...future.workdir)
[10:26:12.026]         {
[10:26:12.026]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.026]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.026]             }
[10:26:12.026]             base::options(...future.oldOptions)
[10:26:12.026]             if (.Platform$OS.type == "windows") {
[10:26:12.026]                 old_names <- names(...future.oldEnvVars)
[10:26:12.026]                 envs <- base::Sys.getenv()
[10:26:12.026]                 names <- names(envs)
[10:26:12.026]                 common <- intersect(names, old_names)
[10:26:12.026]                 added <- setdiff(names, old_names)
[10:26:12.026]                 removed <- setdiff(old_names, names)
[10:26:12.026]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.026]                   envs[common]]
[10:26:12.026]                 NAMES <- toupper(changed)
[10:26:12.026]                 args <- list()
[10:26:12.026]                 for (kk in seq_along(NAMES)) {
[10:26:12.026]                   name <- changed[[kk]]
[10:26:12.026]                   NAME <- NAMES[[kk]]
[10:26:12.026]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.026]                     next
[10:26:12.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.026]                 }
[10:26:12.026]                 NAMES <- toupper(added)
[10:26:12.026]                 for (kk in seq_along(NAMES)) {
[10:26:12.026]                   name <- added[[kk]]
[10:26:12.026]                   NAME <- NAMES[[kk]]
[10:26:12.026]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.026]                     next
[10:26:12.026]                   args[[name]] <- ""
[10:26:12.026]                 }
[10:26:12.026]                 NAMES <- toupper(removed)
[10:26:12.026]                 for (kk in seq_along(NAMES)) {
[10:26:12.026]                   name <- removed[[kk]]
[10:26:12.026]                   NAME <- NAMES[[kk]]
[10:26:12.026]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.026]                     next
[10:26:12.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.026]                 }
[10:26:12.026]                 if (length(args) > 0) 
[10:26:12.026]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.026]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.026]             }
[10:26:12.026]             else {
[10:26:12.026]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.026]             }
[10:26:12.026]             {
[10:26:12.026]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.026]                   0L) {
[10:26:12.026]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.026]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.026]                   base::options(opts)
[10:26:12.026]                 }
[10:26:12.026]                 {
[10:26:12.026]                   {
[10:26:12.026]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.026]                     NULL
[10:26:12.026]                   }
[10:26:12.026]                   options(future.plan = NULL)
[10:26:12.026]                   if (is.na(NA_character_)) 
[10:26:12.026]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.026]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.026]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.026]                     envir = parent.frame()) 
[10:26:12.026]                   {
[10:26:12.026]                     default_workers <- missing(workers)
[10:26:12.026]                     if (is.function(workers)) 
[10:26:12.026]                       workers <- workers()
[10:26:12.026]                     workers <- structure(as.integer(workers), 
[10:26:12.026]                       class = class(workers))
[10:26:12.026]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.026]                       1L)
[10:26:12.026]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.026]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.026]                       if (default_workers) 
[10:26:12.026]                         supportsMulticore(warn = TRUE)
[10:26:12.026]                       return(sequential(..., envir = envir))
[10:26:12.026]                     }
[10:26:12.026]                     oopts <- options(mc.cores = workers)
[10:26:12.026]                     on.exit(options(oopts))
[10:26:12.026]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.026]                       envir = envir)
[10:26:12.026]                     if (!future$lazy) 
[10:26:12.026]                       future <- run(future)
[10:26:12.026]                     invisible(future)
[10:26:12.026]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.026]                 }
[10:26:12.026]             }
[10:26:12.026]         }
[10:26:12.026]     })
[10:26:12.026]     if (TRUE) {
[10:26:12.026]         base::sink(type = "output", split = FALSE)
[10:26:12.026]         if (TRUE) {
[10:26:12.026]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.026]         }
[10:26:12.026]         else {
[10:26:12.026]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.026]         }
[10:26:12.026]         base::close(...future.stdout)
[10:26:12.026]         ...future.stdout <- NULL
[10:26:12.026]     }
[10:26:12.026]     ...future.result$conditions <- ...future.conditions
[10:26:12.026]     ...future.result$finished <- base::Sys.time()
[10:26:12.026]     ...future.result
[10:26:12.026] }
[10:26:12.028] assign_globals() ...
[10:26:12.028] List of 1
[10:26:12.028]  $ ii: int 1
[10:26:12.028]  - attr(*, "where")=List of 1
[10:26:12.028]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:12.028]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:12.028]  - attr(*, "resolved")= logi TRUE
[10:26:12.028]  - attr(*, "total_size")= num 56
[10:26:12.028]  - attr(*, "already-done")= logi TRUE
[10:26:12.031] - copied ‘ii’ to environment
[10:26:12.031] assign_globals() ... done
[10:26:12.031] requestCore(): workers = 2
[10:26:12.033] MulticoreFuture started
[10:26:12.033] - Launch lazy future ... done
[10:26:12.034] run() for ‘MulticoreFuture’ ... done
[10:26:12.034] result() for MulticoreFuture ...
[10:26:12.034] plan(): Setting new future strategy stack:
[10:26:12.034] List of future strategies:
[10:26:12.034] 1. sequential:
[10:26:12.034]    - args: function (..., envir = parent.frame())
[10:26:12.034]    - tweaked: FALSE
[10:26:12.034]    - call: NULL
[10:26:12.035] plan(): nbrOfWorkers() = 1
[10:26:12.037] plan(): Setting new future strategy stack:
[10:26:12.038] List of future strategies:
[10:26:12.038] 1. multicore:
[10:26:12.038]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.038]    - tweaked: FALSE
[10:26:12.038]    - call: plan(strategy)
[10:26:12.043] plan(): nbrOfWorkers() = 2
[10:26:12.050] result() for MulticoreFuture ...
[10:26:12.050] result() for MulticoreFuture ... done
[10:26:12.050] signalConditions() ...
[10:26:12.050]  - include = ‘immediateCondition’
[10:26:12.050]  - exclude = 
[10:26:12.050]  - resignal = FALSE
[10:26:12.050]  - Number of conditions: 1
[10:26:12.051] signalConditions() ... done
[10:26:12.051] result() for MulticoreFuture ... done
[10:26:12.051] result() for MulticoreFuture ...
[10:26:12.051] result() for MulticoreFuture ... done
[10:26:12.051] signalConditions() ...
[10:26:12.051]  - include = ‘immediateCondition’
[10:26:12.051]  - exclude = 
[10:26:12.051]  - resignal = FALSE
[10:26:12.052]  - Number of conditions: 1
[10:26:12.052] signalConditions() ... done
[10:26:12.052] Future state: ‘finished’
[10:26:12.052] result() for MulticoreFuture ...
[10:26:12.052] result() for MulticoreFuture ... done
[10:26:12.052] signalConditions() ...
[10:26:12.052]  - include = ‘condition’
[10:26:12.052]  - exclude = ‘immediateCondition’
[10:26:12.053]  - resignal = TRUE
[10:26:12.053]  - Number of conditions: 1
[10:26:12.053]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:26:12.053] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 45
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language local({     value <- value(future) ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3e863ac79bce" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 10:26:12"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.082] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.083] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:12.083] 
[10:26:12.083] Searching for globals ... DONE
[10:26:12.083] - globals: [0] <none>
[10:26:12.083] getGlobalsAndPackages() ... DONE
[10:26:12.084] run() for ‘Future’ ...
[10:26:12.084] - state: ‘created’
[10:26:12.084] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.089] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.089] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.089]   - Field: ‘label’
[10:26:12.089]   - Field: ‘local’
[10:26:12.090]   - Field: ‘owner’
[10:26:12.090]   - Field: ‘envir’
[10:26:12.090]   - Field: ‘workers’
[10:26:12.090]   - Field: ‘packages’
[10:26:12.090]   - Field: ‘gc’
[10:26:12.090]   - Field: ‘job’
[10:26:12.090]   - Field: ‘conditions’
[10:26:12.090]   - Field: ‘expr’
[10:26:12.090]   - Field: ‘uuid’
[10:26:12.090]   - Field: ‘seed’
[10:26:12.090]   - Field: ‘version’
[10:26:12.091]   - Field: ‘result’
[10:26:12.091]   - Field: ‘asynchronous’
[10:26:12.091]   - Field: ‘calls’
[10:26:12.091]   - Field: ‘globals’
[10:26:12.091]   - Field: ‘stdout’
[10:26:12.091]   - Field: ‘earlySignal’
[10:26:12.091]   - Field: ‘lazy’
[10:26:12.091]   - Field: ‘state’
[10:26:12.091] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.091] - Launch lazy future ...
[10:26:12.092] Packages needed by the future expression (n = 0): <none>
[10:26:12.092] Packages needed by future strategies (n = 0): <none>
[10:26:12.092] {
[10:26:12.092]     {
[10:26:12.092]         {
[10:26:12.092]             ...future.startTime <- base::Sys.time()
[10:26:12.092]             {
[10:26:12.092]                 {
[10:26:12.092]                   {
[10:26:12.092]                     {
[10:26:12.092]                       base::local({
[10:26:12.092]                         has_future <- base::requireNamespace("future", 
[10:26:12.092]                           quietly = TRUE)
[10:26:12.092]                         if (has_future) {
[10:26:12.092]                           ns <- base::getNamespace("future")
[10:26:12.092]                           version <- ns[[".package"]][["version"]]
[10:26:12.092]                           if (is.null(version)) 
[10:26:12.092]                             version <- utils::packageVersion("future")
[10:26:12.092]                         }
[10:26:12.092]                         else {
[10:26:12.092]                           version <- NULL
[10:26:12.092]                         }
[10:26:12.092]                         if (!has_future || version < "1.8.0") {
[10:26:12.092]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.092]                             "", base::R.version$version.string), 
[10:26:12.092]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:12.092]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:12.092]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.092]                               "release", "version")], collapse = " "), 
[10:26:12.092]                             hostname = base::Sys.info()[["nodename"]])
[10:26:12.092]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.092]                             info)
[10:26:12.092]                           info <- base::paste(info, collapse = "; ")
[10:26:12.092]                           if (!has_future) {
[10:26:12.092]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.092]                               info)
[10:26:12.092]                           }
[10:26:12.092]                           else {
[10:26:12.092]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.092]                               info, version)
[10:26:12.092]                           }
[10:26:12.092]                           base::stop(msg)
[10:26:12.092]                         }
[10:26:12.092]                       })
[10:26:12.092]                     }
[10:26:12.092]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.092]                     base::options(mc.cores = 1L)
[10:26:12.092]                   }
[10:26:12.092]                   options(future.plan = NULL)
[10:26:12.092]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.092]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.092]                 }
[10:26:12.092]                 ...future.workdir <- getwd()
[10:26:12.092]             }
[10:26:12.092]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.092]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.092]         }
[10:26:12.092]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.092]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:12.092]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.092]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.092]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.092]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.092]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.092]             base::names(...future.oldOptions))
[10:26:12.092]     }
[10:26:12.092]     if (FALSE) {
[10:26:12.092]     }
[10:26:12.092]     else {
[10:26:12.092]         if (TRUE) {
[10:26:12.092]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.092]                 open = "w")
[10:26:12.092]         }
[10:26:12.092]         else {
[10:26:12.092]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.092]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.092]         }
[10:26:12.092]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.092]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.092]             base::sink(type = "output", split = FALSE)
[10:26:12.092]             base::close(...future.stdout)
[10:26:12.092]         }, add = TRUE)
[10:26:12.092]     }
[10:26:12.092]     ...future.frame <- base::sys.nframe()
[10:26:12.092]     ...future.conditions <- base::list()
[10:26:12.092]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.092]     if (FALSE) {
[10:26:12.092]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.092]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.092]     }
[10:26:12.092]     ...future.result <- base::tryCatch({
[10:26:12.092]         base::withCallingHandlers({
[10:26:12.092]             ...future.value <- base::withVisible(base::local({
[10:26:12.092]                 withCallingHandlers({
[10:26:12.092]                   1
[10:26:12.092]                 }, immediateCondition = function(cond) {
[10:26:12.092]                   save_rds <- function (object, pathname, ...) 
[10:26:12.092]                   {
[10:26:12.092]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.092]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.092]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.092]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.092]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.092]                         fi_tmp[["mtime"]])
[10:26:12.092]                     }
[10:26:12.092]                     tryCatch({
[10:26:12.092]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.092]                     }, error = function(ex) {
[10:26:12.092]                       msg <- conditionMessage(ex)
[10:26:12.092]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.092]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.092]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.092]                         fi_tmp[["mtime"]], msg)
[10:26:12.092]                       ex$message <- msg
[10:26:12.092]                       stop(ex)
[10:26:12.092]                     })
[10:26:12.092]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.092]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.092]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.092]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.092]                       fi <- file.info(pathname)
[10:26:12.092]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.092]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.092]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.092]                         fi[["size"]], fi[["mtime"]])
[10:26:12.092]                       stop(msg)
[10:26:12.092]                     }
[10:26:12.092]                     invisible(pathname)
[10:26:12.092]                   }
[10:26:12.092]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.092]                     rootPath = tempdir()) 
[10:26:12.092]                   {
[10:26:12.092]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.092]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.092]                       tmpdir = path, fileext = ".rds")
[10:26:12.092]                     save_rds(obj, file)
[10:26:12.092]                   }
[10:26:12.092]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.092]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.092]                   {
[10:26:12.092]                     inherits <- base::inherits
[10:26:12.092]                     invokeRestart <- base::invokeRestart
[10:26:12.092]                     is.null <- base::is.null
[10:26:12.092]                     muffled <- FALSE
[10:26:12.092]                     if (inherits(cond, "message")) {
[10:26:12.092]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.092]                       if (muffled) 
[10:26:12.092]                         invokeRestart("muffleMessage")
[10:26:12.092]                     }
[10:26:12.092]                     else if (inherits(cond, "warning")) {
[10:26:12.092]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.092]                       if (muffled) 
[10:26:12.092]                         invokeRestart("muffleWarning")
[10:26:12.092]                     }
[10:26:12.092]                     else if (inherits(cond, "condition")) {
[10:26:12.092]                       if (!is.null(pattern)) {
[10:26:12.092]                         computeRestarts <- base::computeRestarts
[10:26:12.092]                         grepl <- base::grepl
[10:26:12.092]                         restarts <- computeRestarts(cond)
[10:26:12.092]                         for (restart in restarts) {
[10:26:12.092]                           name <- restart$name
[10:26:12.092]                           if (is.null(name)) 
[10:26:12.092]                             next
[10:26:12.092]                           if (!grepl(pattern, name)) 
[10:26:12.092]                             next
[10:26:12.092]                           invokeRestart(restart)
[10:26:12.092]                           muffled <- TRUE
[10:26:12.092]                           break
[10:26:12.092]                         }
[10:26:12.092]                       }
[10:26:12.092]                     }
[10:26:12.092]                     invisible(muffled)
[10:26:12.092]                   }
[10:26:12.092]                   muffleCondition(cond)
[10:26:12.092]                 })
[10:26:12.092]             }))
[10:26:12.092]             future::FutureResult(value = ...future.value$value, 
[10:26:12.092]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.092]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.092]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.092]                     ...future.globalenv.names))
[10:26:12.092]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.092]         }, condition = base::local({
[10:26:12.092]             c <- base::c
[10:26:12.092]             inherits <- base::inherits
[10:26:12.092]             invokeRestart <- base::invokeRestart
[10:26:12.092]             length <- base::length
[10:26:12.092]             list <- base::list
[10:26:12.092]             seq.int <- base::seq.int
[10:26:12.092]             signalCondition <- base::signalCondition
[10:26:12.092]             sys.calls <- base::sys.calls
[10:26:12.092]             `[[` <- base::`[[`
[10:26:12.092]             `+` <- base::`+`
[10:26:12.092]             `<<-` <- base::`<<-`
[10:26:12.092]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.092]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.092]                   3L)]
[10:26:12.092]             }
[10:26:12.092]             function(cond) {
[10:26:12.092]                 is_error <- inherits(cond, "error")
[10:26:12.092]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.092]                   NULL)
[10:26:12.092]                 if (is_error) {
[10:26:12.092]                   sessionInformation <- function() {
[10:26:12.092]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.092]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.092]                       search = base::search(), system = base::Sys.info())
[10:26:12.092]                   }
[10:26:12.092]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.092]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.092]                     cond$call), session = sessionInformation(), 
[10:26:12.092]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.092]                   signalCondition(cond)
[10:26:12.092]                 }
[10:26:12.092]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.092]                 "immediateCondition"))) {
[10:26:12.092]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.092]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.092]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.092]                   if (TRUE && !signal) {
[10:26:12.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.092]                     {
[10:26:12.092]                       inherits <- base::inherits
[10:26:12.092]                       invokeRestart <- base::invokeRestart
[10:26:12.092]                       is.null <- base::is.null
[10:26:12.092]                       muffled <- FALSE
[10:26:12.092]                       if (inherits(cond, "message")) {
[10:26:12.092]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.092]                         if (muffled) 
[10:26:12.092]                           invokeRestart("muffleMessage")
[10:26:12.092]                       }
[10:26:12.092]                       else if (inherits(cond, "warning")) {
[10:26:12.092]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.092]                         if (muffled) 
[10:26:12.092]                           invokeRestart("muffleWarning")
[10:26:12.092]                       }
[10:26:12.092]                       else if (inherits(cond, "condition")) {
[10:26:12.092]                         if (!is.null(pattern)) {
[10:26:12.092]                           computeRestarts <- base::computeRestarts
[10:26:12.092]                           grepl <- base::grepl
[10:26:12.092]                           restarts <- computeRestarts(cond)
[10:26:12.092]                           for (restart in restarts) {
[10:26:12.092]                             name <- restart$name
[10:26:12.092]                             if (is.null(name)) 
[10:26:12.092]                               next
[10:26:12.092]                             if (!grepl(pattern, name)) 
[10:26:12.092]                               next
[10:26:12.092]                             invokeRestart(restart)
[10:26:12.092]                             muffled <- TRUE
[10:26:12.092]                             break
[10:26:12.092]                           }
[10:26:12.092]                         }
[10:26:12.092]                       }
[10:26:12.092]                       invisible(muffled)
[10:26:12.092]                     }
[10:26:12.092]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.092]                   }
[10:26:12.092]                 }
[10:26:12.092]                 else {
[10:26:12.092]                   if (TRUE) {
[10:26:12.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.092]                     {
[10:26:12.092]                       inherits <- base::inherits
[10:26:12.092]                       invokeRestart <- base::invokeRestart
[10:26:12.092]                       is.null <- base::is.null
[10:26:12.092]                       muffled <- FALSE
[10:26:12.092]                       if (inherits(cond, "message")) {
[10:26:12.092]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.092]                         if (muffled) 
[10:26:12.092]                           invokeRestart("muffleMessage")
[10:26:12.092]                       }
[10:26:12.092]                       else if (inherits(cond, "warning")) {
[10:26:12.092]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.092]                         if (muffled) 
[10:26:12.092]                           invokeRestart("muffleWarning")
[10:26:12.092]                       }
[10:26:12.092]                       else if (inherits(cond, "condition")) {
[10:26:12.092]                         if (!is.null(pattern)) {
[10:26:12.092]                           computeRestarts <- base::computeRestarts
[10:26:12.092]                           grepl <- base::grepl
[10:26:12.092]                           restarts <- computeRestarts(cond)
[10:26:12.092]                           for (restart in restarts) {
[10:26:12.092]                             name <- restart$name
[10:26:12.092]                             if (is.null(name)) 
[10:26:12.092]                               next
[10:26:12.092]                             if (!grepl(pattern, name)) 
[10:26:12.092]                               next
[10:26:12.092]                             invokeRestart(restart)
[10:26:12.092]                             muffled <- TRUE
[10:26:12.092]                             break
[10:26:12.092]                           }
[10:26:12.092]                         }
[10:26:12.092]                       }
[10:26:12.092]                       invisible(muffled)
[10:26:12.092]                     }
[10:26:12.092]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.092]                   }
[10:26:12.092]                 }
[10:26:12.092]             }
[10:26:12.092]         }))
[10:26:12.092]     }, error = function(ex) {
[10:26:12.092]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.092]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.092]                 ...future.rng), started = ...future.startTime, 
[10:26:12.092]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.092]             version = "1.8"), class = "FutureResult")
[10:26:12.092]     }, finally = {
[10:26:12.092]         if (!identical(...future.workdir, getwd())) 
[10:26:12.092]             setwd(...future.workdir)
[10:26:12.092]         {
[10:26:12.092]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.092]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.092]             }
[10:26:12.092]             base::options(...future.oldOptions)
[10:26:12.092]             if (.Platform$OS.type == "windows") {
[10:26:12.092]                 old_names <- names(...future.oldEnvVars)
[10:26:12.092]                 envs <- base::Sys.getenv()
[10:26:12.092]                 names <- names(envs)
[10:26:12.092]                 common <- intersect(names, old_names)
[10:26:12.092]                 added <- setdiff(names, old_names)
[10:26:12.092]                 removed <- setdiff(old_names, names)
[10:26:12.092]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.092]                   envs[common]]
[10:26:12.092]                 NAMES <- toupper(changed)
[10:26:12.092]                 args <- list()
[10:26:12.092]                 for (kk in seq_along(NAMES)) {
[10:26:12.092]                   name <- changed[[kk]]
[10:26:12.092]                   NAME <- NAMES[[kk]]
[10:26:12.092]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.092]                     next
[10:26:12.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.092]                 }
[10:26:12.092]                 NAMES <- toupper(added)
[10:26:12.092]                 for (kk in seq_along(NAMES)) {
[10:26:12.092]                   name <- added[[kk]]
[10:26:12.092]                   NAME <- NAMES[[kk]]
[10:26:12.092]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.092]                     next
[10:26:12.092]                   args[[name]] <- ""
[10:26:12.092]                 }
[10:26:12.092]                 NAMES <- toupper(removed)
[10:26:12.092]                 for (kk in seq_along(NAMES)) {
[10:26:12.092]                   name <- removed[[kk]]
[10:26:12.092]                   NAME <- NAMES[[kk]]
[10:26:12.092]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.092]                     next
[10:26:12.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.092]                 }
[10:26:12.092]                 if (length(args) > 0) 
[10:26:12.092]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.092]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.092]             }
[10:26:12.092]             else {
[10:26:12.092]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.092]             }
[10:26:12.092]             {
[10:26:12.092]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.092]                   0L) {
[10:26:12.092]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.092]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.092]                   base::options(opts)
[10:26:12.092]                 }
[10:26:12.092]                 {
[10:26:12.092]                   {
[10:26:12.092]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.092]                     NULL
[10:26:12.092]                   }
[10:26:12.092]                   options(future.plan = NULL)
[10:26:12.092]                   if (is.na(NA_character_)) 
[10:26:12.092]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.092]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.092]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.092]                     envir = parent.frame()) 
[10:26:12.092]                   {
[10:26:12.092]                     default_workers <- missing(workers)
[10:26:12.092]                     if (is.function(workers)) 
[10:26:12.092]                       workers <- workers()
[10:26:12.092]                     workers <- structure(as.integer(workers), 
[10:26:12.092]                       class = class(workers))
[10:26:12.092]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.092]                       1L)
[10:26:12.092]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.092]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.092]                       if (default_workers) 
[10:26:12.092]                         supportsMulticore(warn = TRUE)
[10:26:12.092]                       return(sequential(..., envir = envir))
[10:26:12.092]                     }
[10:26:12.092]                     oopts <- options(mc.cores = workers)
[10:26:12.092]                     on.exit(options(oopts))
[10:26:12.092]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.092]                       envir = envir)
[10:26:12.092]                     if (!future$lazy) 
[10:26:12.092]                       future <- run(future)
[10:26:12.092]                     invisible(future)
[10:26:12.092]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.092]                 }
[10:26:12.092]             }
[10:26:12.092]         }
[10:26:12.092]     })
[10:26:12.092]     if (TRUE) {
[10:26:12.092]         base::sink(type = "output", split = FALSE)
[10:26:12.092]         if (TRUE) {
[10:26:12.092]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.092]         }
[10:26:12.092]         else {
[10:26:12.092]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.092]         }
[10:26:12.092]         base::close(...future.stdout)
[10:26:12.092]         ...future.stdout <- NULL
[10:26:12.092]     }
[10:26:12.092]     ...future.result$conditions <- ...future.conditions
[10:26:12.092]     ...future.result$finished <- base::Sys.time()
[10:26:12.092]     ...future.result
[10:26:12.092] }
[10:26:12.095] requestCore(): workers = 2
[10:26:12.097] MulticoreFuture started
[10:26:12.097] - Launch lazy future ... done
[10:26:12.097] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.098] getGlobalsAndPackages() ...
[10:26:12.098] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.098] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:12.098] List of future strategies:
[10:26:12.098] 1. sequential:
[10:26:12.098]    - args: function (..., envir = parent.frame())
[10:26:12.098]    - tweaked: FALSE
[10:26:12.098]    - call: NULL
[10:26:12.099] plan(): nbrOfWorkers() = 1
[10:26:12.100] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:12.101] Searching for globals ... DONE
[10:26:12.101] Resolving globals: TRUE
[10:26:12.101] plan(): Setting new future strategy stack:
[10:26:12.101] Resolving any globals that are futures ...
[10:26:12.101] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:12.101] Resolving any globals that are futures ... DONE
[10:26:12.101] List of future strategies:
[10:26:12.101] 1. multicore:
[10:26:12.101]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.101]    - tweaked: FALSE
[10:26:12.101]    - call: plan(strategy)
[10:26:12.102] Resolving futures part of globals (recursively) ...
[10:26:12.103] resolve() on list ...
[10:26:12.103]  recursive: 99
[10:26:12.103]  length: 1
[10:26:12.103]  elements: ‘a’
[10:26:12.106] plan(): nbrOfWorkers() = 2
[10:26:12.106] Future #1
[10:26:12.107] result() for MulticoreFuture ...
[10:26:12.107] result() for MulticoreFuture ...
[10:26:12.108] result() for MulticoreFuture ... done
[10:26:12.108] result() for MulticoreFuture ... done
[10:26:12.108] result() for MulticoreFuture ...
[10:26:12.108] result() for MulticoreFuture ... done
[10:26:12.108] A MulticoreFuture was resolved
[10:26:12.109]  length: 0 (resolved future 1)
[10:26:12.109] resolve() on list ... DONE
[10:26:12.109] - globals: [1] ‘a’
[10:26:12.109] Resolving futures part of globals (recursively) ... DONE
[10:26:12.110] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[10:26:12.111] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[10:26:12.111] - globals: [1] ‘a’
[10:26:12.111] - packages: [1] ‘future’
[10:26:12.111] getGlobalsAndPackages() ... DONE
[10:26:12.111] run() for ‘Future’ ...
[10:26:12.112] - state: ‘created’
[10:26:12.112] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.116] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.116] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.116]   - Field: ‘label’
[10:26:12.116]   - Field: ‘local’
[10:26:12.116]   - Field: ‘owner’
[10:26:12.116]   - Field: ‘envir’
[10:26:12.117]   - Field: ‘workers’
[10:26:12.117]   - Field: ‘packages’
[10:26:12.117]   - Field: ‘gc’
[10:26:12.117]   - Field: ‘job’
[10:26:12.117]   - Field: ‘conditions’
[10:26:12.117]   - Field: ‘expr’
[10:26:12.117]   - Field: ‘uuid’
[10:26:12.117]   - Field: ‘seed’
[10:26:12.118]   - Field: ‘version’
[10:26:12.118]   - Field: ‘result’
[10:26:12.118]   - Field: ‘asynchronous’
[10:26:12.118]   - Field: ‘calls’
[10:26:12.118]   - Field: ‘globals’
[10:26:12.118]   - Field: ‘stdout’
[10:26:12.118]   - Field: ‘earlySignal’
[10:26:12.118]   - Field: ‘lazy’
[10:26:12.118]   - Field: ‘state’
[10:26:12.119] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.119] - Launch lazy future ...
[10:26:12.119] Packages needed by the future expression (n = 1): ‘future’
[10:26:12.119] Packages needed by future strategies (n = 0): <none>
[10:26:12.120] {
[10:26:12.120]     {
[10:26:12.120]         {
[10:26:12.120]             ...future.startTime <- base::Sys.time()
[10:26:12.120]             {
[10:26:12.120]                 {
[10:26:12.120]                   {
[10:26:12.120]                     {
[10:26:12.120]                       {
[10:26:12.120]                         base::local({
[10:26:12.120]                           has_future <- base::requireNamespace("future", 
[10:26:12.120]                             quietly = TRUE)
[10:26:12.120]                           if (has_future) {
[10:26:12.120]                             ns <- base::getNamespace("future")
[10:26:12.120]                             version <- ns[[".package"]][["version"]]
[10:26:12.120]                             if (is.null(version)) 
[10:26:12.120]                               version <- utils::packageVersion("future")
[10:26:12.120]                           }
[10:26:12.120]                           else {
[10:26:12.120]                             version <- NULL
[10:26:12.120]                           }
[10:26:12.120]                           if (!has_future || version < "1.8.0") {
[10:26:12.120]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.120]                               "", base::R.version$version.string), 
[10:26:12.120]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:12.120]                                 base::R.version$platform, 8 * 
[10:26:12.120]                                   base::.Machine$sizeof.pointer), 
[10:26:12.120]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.120]                                 "release", "version")], collapse = " "), 
[10:26:12.120]                               hostname = base::Sys.info()[["nodename"]])
[10:26:12.120]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.120]                               info)
[10:26:12.120]                             info <- base::paste(info, collapse = "; ")
[10:26:12.120]                             if (!has_future) {
[10:26:12.120]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.120]                                 info)
[10:26:12.120]                             }
[10:26:12.120]                             else {
[10:26:12.120]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.120]                                 info, version)
[10:26:12.120]                             }
[10:26:12.120]                             base::stop(msg)
[10:26:12.120]                           }
[10:26:12.120]                         })
[10:26:12.120]                       }
[10:26:12.120]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.120]                       base::options(mc.cores = 1L)
[10:26:12.120]                     }
[10:26:12.120]                     base::local({
[10:26:12.120]                       for (pkg in "future") {
[10:26:12.120]                         base::loadNamespace(pkg)
[10:26:12.120]                         base::library(pkg, character.only = TRUE)
[10:26:12.120]                       }
[10:26:12.120]                     })
[10:26:12.120]                   }
[10:26:12.120]                   options(future.plan = NULL)
[10:26:12.120]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.120]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.120]                 }
[10:26:12.120]                 ...future.workdir <- getwd()
[10:26:12.120]             }
[10:26:12.120]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.120]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.120]         }
[10:26:12.120]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.120]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:12.120]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.120]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.120]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.120]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.120]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.120]             base::names(...future.oldOptions))
[10:26:12.120]     }
[10:26:12.120]     if (FALSE) {
[10:26:12.120]     }
[10:26:12.120]     else {
[10:26:12.120]         if (TRUE) {
[10:26:12.120]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.120]                 open = "w")
[10:26:12.120]         }
[10:26:12.120]         else {
[10:26:12.120]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.120]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.120]         }
[10:26:12.120]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.120]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.120]             base::sink(type = "output", split = FALSE)
[10:26:12.120]             base::close(...future.stdout)
[10:26:12.120]         }, add = TRUE)
[10:26:12.120]     }
[10:26:12.120]     ...future.frame <- base::sys.nframe()
[10:26:12.120]     ...future.conditions <- base::list()
[10:26:12.120]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.120]     if (FALSE) {
[10:26:12.120]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.120]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.120]     }
[10:26:12.120]     ...future.result <- base::tryCatch({
[10:26:12.120]         base::withCallingHandlers({
[10:26:12.120]             ...future.value <- base::withVisible(base::local({
[10:26:12.120]                 withCallingHandlers({
[10:26:12.120]                   value(a) + 1
[10:26:12.120]                 }, immediateCondition = function(cond) {
[10:26:12.120]                   save_rds <- function (object, pathname, ...) 
[10:26:12.120]                   {
[10:26:12.120]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.120]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.120]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.120]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.120]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.120]                         fi_tmp[["mtime"]])
[10:26:12.120]                     }
[10:26:12.120]                     tryCatch({
[10:26:12.120]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.120]                     }, error = function(ex) {
[10:26:12.120]                       msg <- conditionMessage(ex)
[10:26:12.120]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.120]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.120]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.120]                         fi_tmp[["mtime"]], msg)
[10:26:12.120]                       ex$message <- msg
[10:26:12.120]                       stop(ex)
[10:26:12.120]                     })
[10:26:12.120]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.120]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.120]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.120]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.120]                       fi <- file.info(pathname)
[10:26:12.120]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.120]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.120]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.120]                         fi[["size"]], fi[["mtime"]])
[10:26:12.120]                       stop(msg)
[10:26:12.120]                     }
[10:26:12.120]                     invisible(pathname)
[10:26:12.120]                   }
[10:26:12.120]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.120]                     rootPath = tempdir()) 
[10:26:12.120]                   {
[10:26:12.120]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.120]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.120]                       tmpdir = path, fileext = ".rds")
[10:26:12.120]                     save_rds(obj, file)
[10:26:12.120]                   }
[10:26:12.120]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.120]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.120]                   {
[10:26:12.120]                     inherits <- base::inherits
[10:26:12.120]                     invokeRestart <- base::invokeRestart
[10:26:12.120]                     is.null <- base::is.null
[10:26:12.120]                     muffled <- FALSE
[10:26:12.120]                     if (inherits(cond, "message")) {
[10:26:12.120]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.120]                       if (muffled) 
[10:26:12.120]                         invokeRestart("muffleMessage")
[10:26:12.120]                     }
[10:26:12.120]                     else if (inherits(cond, "warning")) {
[10:26:12.120]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.120]                       if (muffled) 
[10:26:12.120]                         invokeRestart("muffleWarning")
[10:26:12.120]                     }
[10:26:12.120]                     else if (inherits(cond, "condition")) {
[10:26:12.120]                       if (!is.null(pattern)) {
[10:26:12.120]                         computeRestarts <- base::computeRestarts
[10:26:12.120]                         grepl <- base::grepl
[10:26:12.120]                         restarts <- computeRestarts(cond)
[10:26:12.120]                         for (restart in restarts) {
[10:26:12.120]                           name <- restart$name
[10:26:12.120]                           if (is.null(name)) 
[10:26:12.120]                             next
[10:26:12.120]                           if (!grepl(pattern, name)) 
[10:26:12.120]                             next
[10:26:12.120]                           invokeRestart(restart)
[10:26:12.120]                           muffled <- TRUE
[10:26:12.120]                           break
[10:26:12.120]                         }
[10:26:12.120]                       }
[10:26:12.120]                     }
[10:26:12.120]                     invisible(muffled)
[10:26:12.120]                   }
[10:26:12.120]                   muffleCondition(cond)
[10:26:12.120]                 })
[10:26:12.120]             }))
[10:26:12.120]             future::FutureResult(value = ...future.value$value, 
[10:26:12.120]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.120]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.120]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.120]                     ...future.globalenv.names))
[10:26:12.120]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.120]         }, condition = base::local({
[10:26:12.120]             c <- base::c
[10:26:12.120]             inherits <- base::inherits
[10:26:12.120]             invokeRestart <- base::invokeRestart
[10:26:12.120]             length <- base::length
[10:26:12.120]             list <- base::list
[10:26:12.120]             seq.int <- base::seq.int
[10:26:12.120]             signalCondition <- base::signalCondition
[10:26:12.120]             sys.calls <- base::sys.calls
[10:26:12.120]             `[[` <- base::`[[`
[10:26:12.120]             `+` <- base::`+`
[10:26:12.120]             `<<-` <- base::`<<-`
[10:26:12.120]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.120]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.120]                   3L)]
[10:26:12.120]             }
[10:26:12.120]             function(cond) {
[10:26:12.120]                 is_error <- inherits(cond, "error")
[10:26:12.120]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.120]                   NULL)
[10:26:12.120]                 if (is_error) {
[10:26:12.120]                   sessionInformation <- function() {
[10:26:12.120]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.120]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.120]                       search = base::search(), system = base::Sys.info())
[10:26:12.120]                   }
[10:26:12.120]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.120]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.120]                     cond$call), session = sessionInformation(), 
[10:26:12.120]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.120]                   signalCondition(cond)
[10:26:12.120]                 }
[10:26:12.120]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.120]                 "immediateCondition"))) {
[10:26:12.120]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.120]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.120]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.120]                   if (TRUE && !signal) {
[10:26:12.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.120]                     {
[10:26:12.120]                       inherits <- base::inherits
[10:26:12.120]                       invokeRestart <- base::invokeRestart
[10:26:12.120]                       is.null <- base::is.null
[10:26:12.120]                       muffled <- FALSE
[10:26:12.120]                       if (inherits(cond, "message")) {
[10:26:12.120]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.120]                         if (muffled) 
[10:26:12.120]                           invokeRestart("muffleMessage")
[10:26:12.120]                       }
[10:26:12.120]                       else if (inherits(cond, "warning")) {
[10:26:12.120]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.120]                         if (muffled) 
[10:26:12.120]                           invokeRestart("muffleWarning")
[10:26:12.120]                       }
[10:26:12.120]                       else if (inherits(cond, "condition")) {
[10:26:12.120]                         if (!is.null(pattern)) {
[10:26:12.120]                           computeRestarts <- base::computeRestarts
[10:26:12.120]                           grepl <- base::grepl
[10:26:12.120]                           restarts <- computeRestarts(cond)
[10:26:12.120]                           for (restart in restarts) {
[10:26:12.120]                             name <- restart$name
[10:26:12.120]                             if (is.null(name)) 
[10:26:12.120]                               next
[10:26:12.120]                             if (!grepl(pattern, name)) 
[10:26:12.120]                               next
[10:26:12.120]                             invokeRestart(restart)
[10:26:12.120]                             muffled <- TRUE
[10:26:12.120]                             break
[10:26:12.120]                           }
[10:26:12.120]                         }
[10:26:12.120]                       }
[10:26:12.120]                       invisible(muffled)
[10:26:12.120]                     }
[10:26:12.120]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.120]                   }
[10:26:12.120]                 }
[10:26:12.120]                 else {
[10:26:12.120]                   if (TRUE) {
[10:26:12.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.120]                     {
[10:26:12.120]                       inherits <- base::inherits
[10:26:12.120]                       invokeRestart <- base::invokeRestart
[10:26:12.120]                       is.null <- base::is.null
[10:26:12.120]                       muffled <- FALSE
[10:26:12.120]                       if (inherits(cond, "message")) {
[10:26:12.120]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.120]                         if (muffled) 
[10:26:12.120]                           invokeRestart("muffleMessage")
[10:26:12.120]                       }
[10:26:12.120]                       else if (inherits(cond, "warning")) {
[10:26:12.120]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.120]                         if (muffled) 
[10:26:12.120]                           invokeRestart("muffleWarning")
[10:26:12.120]                       }
[10:26:12.120]                       else if (inherits(cond, "condition")) {
[10:26:12.120]                         if (!is.null(pattern)) {
[10:26:12.120]                           computeRestarts <- base::computeRestarts
[10:26:12.120]                           grepl <- base::grepl
[10:26:12.120]                           restarts <- computeRestarts(cond)
[10:26:12.120]                           for (restart in restarts) {
[10:26:12.120]                             name <- restart$name
[10:26:12.120]                             if (is.null(name)) 
[10:26:12.120]                               next
[10:26:12.120]                             if (!grepl(pattern, name)) 
[10:26:12.120]                               next
[10:26:12.120]                             invokeRestart(restart)
[10:26:12.120]                             muffled <- TRUE
[10:26:12.120]                             break
[10:26:12.120]                           }
[10:26:12.120]                         }
[10:26:12.120]                       }
[10:26:12.120]                       invisible(muffled)
[10:26:12.120]                     }
[10:26:12.120]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.120]                   }
[10:26:12.120]                 }
[10:26:12.120]             }
[10:26:12.120]         }))
[10:26:12.120]     }, error = function(ex) {
[10:26:12.120]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.120]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.120]                 ...future.rng), started = ...future.startTime, 
[10:26:12.120]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.120]             version = "1.8"), class = "FutureResult")
[10:26:12.120]     }, finally = {
[10:26:12.120]         if (!identical(...future.workdir, getwd())) 
[10:26:12.120]             setwd(...future.workdir)
[10:26:12.120]         {
[10:26:12.120]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.120]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.120]             }
[10:26:12.120]             base::options(...future.oldOptions)
[10:26:12.120]             if (.Platform$OS.type == "windows") {
[10:26:12.120]                 old_names <- names(...future.oldEnvVars)
[10:26:12.120]                 envs <- base::Sys.getenv()
[10:26:12.120]                 names <- names(envs)
[10:26:12.120]                 common <- intersect(names, old_names)
[10:26:12.120]                 added <- setdiff(names, old_names)
[10:26:12.120]                 removed <- setdiff(old_names, names)
[10:26:12.120]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.120]                   envs[common]]
[10:26:12.120]                 NAMES <- toupper(changed)
[10:26:12.120]                 args <- list()
[10:26:12.120]                 for (kk in seq_along(NAMES)) {
[10:26:12.120]                   name <- changed[[kk]]
[10:26:12.120]                   NAME <- NAMES[[kk]]
[10:26:12.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.120]                     next
[10:26:12.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.120]                 }
[10:26:12.120]                 NAMES <- toupper(added)
[10:26:12.120]                 for (kk in seq_along(NAMES)) {
[10:26:12.120]                   name <- added[[kk]]
[10:26:12.120]                   NAME <- NAMES[[kk]]
[10:26:12.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.120]                     next
[10:26:12.120]                   args[[name]] <- ""
[10:26:12.120]                 }
[10:26:12.120]                 NAMES <- toupper(removed)
[10:26:12.120]                 for (kk in seq_along(NAMES)) {
[10:26:12.120]                   name <- removed[[kk]]
[10:26:12.120]                   NAME <- NAMES[[kk]]
[10:26:12.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.120]                     next
[10:26:12.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.120]                 }
[10:26:12.120]                 if (length(args) > 0) 
[10:26:12.120]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.120]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.120]             }
[10:26:12.120]             else {
[10:26:12.120]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.120]             }
[10:26:12.120]             {
[10:26:12.120]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.120]                   0L) {
[10:26:12.120]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.120]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.120]                   base::options(opts)
[10:26:12.120]                 }
[10:26:12.120]                 {
[10:26:12.120]                   {
[10:26:12.120]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.120]                     NULL
[10:26:12.120]                   }
[10:26:12.120]                   options(future.plan = NULL)
[10:26:12.120]                   if (is.na(NA_character_)) 
[10:26:12.120]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.120]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.120]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.120]                     envir = parent.frame()) 
[10:26:12.120]                   {
[10:26:12.120]                     default_workers <- missing(workers)
[10:26:12.120]                     if (is.function(workers)) 
[10:26:12.120]                       workers <- workers()
[10:26:12.120]                     workers <- structure(as.integer(workers), 
[10:26:12.120]                       class = class(workers))
[10:26:12.120]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.120]                       1L)
[10:26:12.120]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.120]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.120]                       if (default_workers) 
[10:26:12.120]                         supportsMulticore(warn = TRUE)
[10:26:12.120]                       return(sequential(..., envir = envir))
[10:26:12.120]                     }
[10:26:12.120]                     oopts <- options(mc.cores = workers)
[10:26:12.120]                     on.exit(options(oopts))
[10:26:12.120]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.120]                       envir = envir)
[10:26:12.120]                     if (!future$lazy) 
[10:26:12.120]                       future <- run(future)
[10:26:12.120]                     invisible(future)
[10:26:12.120]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.120]                 }
[10:26:12.120]             }
[10:26:12.120]         }
[10:26:12.120]     })
[10:26:12.120]     if (TRUE) {
[10:26:12.120]         base::sink(type = "output", split = FALSE)
[10:26:12.120]         if (TRUE) {
[10:26:12.120]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.120]         }
[10:26:12.120]         else {
[10:26:12.120]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.120]         }
[10:26:12.120]         base::close(...future.stdout)
[10:26:12.120]         ...future.stdout <- NULL
[10:26:12.120]     }
[10:26:12.120]     ...future.result$conditions <- ...future.conditions
[10:26:12.120]     ...future.result$finished <- base::Sys.time()
[10:26:12.120]     ...future.result
[10:26:12.120] }
[10:26:12.122] assign_globals() ...
[10:26:12.123] List of 1
[10:26:12.123]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a0226a5098> 
[10:26:12.123]  - attr(*, "where")=List of 1
[10:26:12.123]   ..$ a:<environment: R_EmptyEnv> 
[10:26:12.123]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:12.123]  - attr(*, "resolved")= logi TRUE
[10:26:12.123]  - attr(*, "total_size")= num 10816
[10:26:12.123]  - attr(*, "already-done")= logi TRUE
[10:26:12.128] - copied ‘a’ to environment
[10:26:12.128] assign_globals() ... done
[10:26:12.128] requestCore(): workers = 2
[10:26:12.130] MulticoreFuture started
[10:26:12.131] - Launch lazy future ... done
[10:26:12.132] run() for ‘MulticoreFuture’ ... done
[10:26:12.132] plan(): Setting new future strategy stack:
[10:26:12.132] result() for MulticoreFuture ...
[10:26:12.133] List of future strategies:
[10:26:12.133] 1. sequential:
[10:26:12.133]    - args: function (..., envir = parent.frame())
[10:26:12.133]    - tweaked: FALSE
[10:26:12.133]    - call: NULL
[10:26:12.134] plan(): nbrOfWorkers() = 1
[10:26:12.138] plan(): Setting new future strategy stack:
[10:26:12.138] List of future strategies:
[10:26:12.138] 1. multicore:
[10:26:12.138]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.138]    - tweaked: FALSE
[10:26:12.138]    - call: plan(strategy)
[10:26:12.143] plan(): nbrOfWorkers() = 2
[10:26:12.144] result() for MulticoreFuture ...
[10:26:12.144] result() for MulticoreFuture ... done
[10:26:12.145] signalConditions() ...
[10:26:12.145]  - include = ‘immediateCondition’
[10:26:12.145]  - exclude = 
[10:26:12.145]  - resignal = FALSE
[10:26:12.145]  - Number of conditions: 4
[10:26:12.145] signalConditions() ... done
[10:26:12.145] result() for MulticoreFuture ... done
[10:26:12.146] result() for MulticoreFuture ...
[10:26:12.146] result() for MulticoreFuture ... done
[10:26:12.146] signalConditions() ...
[10:26:12.146]  - include = ‘immediateCondition’
[10:26:12.146]  - exclude = 
[10:26:12.146]  - resignal = FALSE
[10:26:12.146]  - Number of conditions: 4
[10:26:12.147] signalConditions() ... done
[10:26:12.147] Future state: ‘finished’
[10:26:12.147] result() for MulticoreFuture ...
[10:26:12.147] result() for MulticoreFuture ... done
[10:26:12.147] signalConditions() ...
[10:26:12.147]  - include = ‘condition’
[10:26:12.147]  - exclude = ‘immediateCondition’
[10:26:12.148]  - resignal = TRUE
[10:26:12.148]  - Number of conditions: 4
[10:26:12.148]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.135] result() for MulticoreFuture ...
[10:26:12.148]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.136] result() for MulticoreFuture ... done
[10:26:12.148]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.136] result() for MulticoreFuture ...
[10:26:12.148]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.136] result() for MulticoreFuture ... done
[10:26:12.149] signalConditions() ... done
value(b) = 2
[10:26:12.149] result() for MulticoreFuture ...
[10:26:12.149] result() for MulticoreFuture ... done
[10:26:12.149] result() for MulticoreFuture ...
[10:26:12.149] result() for MulticoreFuture ... done
[10:26:12.149] signalConditions() ...
[10:26:12.149]  - include = ‘immediateCondition’
[10:26:12.150]  - exclude = 
[10:26:12.150]  - resignal = FALSE
[10:26:12.150]  - Number of conditions: 4
[10:26:12.150] signalConditions() ... done
[10:26:12.150] Future state: ‘finished’
[10:26:12.150] result() for MulticoreFuture ...
[10:26:12.150] result() for MulticoreFuture ... done
[10:26:12.150] signalConditions() ...
[10:26:12.150]  - include = ‘condition’
[10:26:12.151]  - exclude = ‘immediateCondition’
[10:26:12.151]  - resignal = TRUE
[10:26:12.151]  - Number of conditions: 4
[10:26:12.151]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.135] result() for MulticoreFuture ...
[10:26:12.151]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.136] result() for MulticoreFuture ... done
[10:26:12.151]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.136] result() for MulticoreFuture ...
[10:26:12.151]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.136] result() for MulticoreFuture ... done
[10:26:12.152] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.152] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.152] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:12.153] 
[10:26:12.153] Searching for globals ... DONE
[10:26:12.153] - globals: [0] <none>
[10:26:12.153] getGlobalsAndPackages() ... DONE
[10:26:12.154] run() for ‘Future’ ...
[10:26:12.154] - state: ‘created’
[10:26:12.154] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.158] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.158] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.158]   - Field: ‘label’
[10:26:12.158]   - Field: ‘local’
[10:26:12.158]   - Field: ‘owner’
[10:26:12.158]   - Field: ‘envir’
[10:26:12.159]   - Field: ‘workers’
[10:26:12.159]   - Field: ‘packages’
[10:26:12.159]   - Field: ‘gc’
[10:26:12.159]   - Field: ‘job’
[10:26:12.159]   - Field: ‘conditions’
[10:26:12.159]   - Field: ‘expr’
[10:26:12.159]   - Field: ‘uuid’
[10:26:12.159]   - Field: ‘seed’
[10:26:12.159]   - Field: ‘version’
[10:26:12.160]   - Field: ‘result’
[10:26:12.160]   - Field: ‘asynchronous’
[10:26:12.160]   - Field: ‘calls’
[10:26:12.160]   - Field: ‘globals’
[10:26:12.160]   - Field: ‘stdout’
[10:26:12.160]   - Field: ‘earlySignal’
[10:26:12.160]   - Field: ‘lazy’
[10:26:12.160]   - Field: ‘state’
[10:26:12.160] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.161] - Launch lazy future ...
[10:26:12.161] Packages needed by the future expression (n = 0): <none>
[10:26:12.161] Packages needed by future strategies (n = 0): <none>
[10:26:12.162] {
[10:26:12.162]     {
[10:26:12.162]         {
[10:26:12.162]             ...future.startTime <- base::Sys.time()
[10:26:12.162]             {
[10:26:12.162]                 {
[10:26:12.162]                   {
[10:26:12.162]                     {
[10:26:12.162]                       base::local({
[10:26:12.162]                         has_future <- base::requireNamespace("future", 
[10:26:12.162]                           quietly = TRUE)
[10:26:12.162]                         if (has_future) {
[10:26:12.162]                           ns <- base::getNamespace("future")
[10:26:12.162]                           version <- ns[[".package"]][["version"]]
[10:26:12.162]                           if (is.null(version)) 
[10:26:12.162]                             version <- utils::packageVersion("future")
[10:26:12.162]                         }
[10:26:12.162]                         else {
[10:26:12.162]                           version <- NULL
[10:26:12.162]                         }
[10:26:12.162]                         if (!has_future || version < "1.8.0") {
[10:26:12.162]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.162]                             "", base::R.version$version.string), 
[10:26:12.162]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:12.162]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:12.162]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.162]                               "release", "version")], collapse = " "), 
[10:26:12.162]                             hostname = base::Sys.info()[["nodename"]])
[10:26:12.162]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.162]                             info)
[10:26:12.162]                           info <- base::paste(info, collapse = "; ")
[10:26:12.162]                           if (!has_future) {
[10:26:12.162]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.162]                               info)
[10:26:12.162]                           }
[10:26:12.162]                           else {
[10:26:12.162]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.162]                               info, version)
[10:26:12.162]                           }
[10:26:12.162]                           base::stop(msg)
[10:26:12.162]                         }
[10:26:12.162]                       })
[10:26:12.162]                     }
[10:26:12.162]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.162]                     base::options(mc.cores = 1L)
[10:26:12.162]                   }
[10:26:12.162]                   options(future.plan = NULL)
[10:26:12.162]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.162]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.162]                 }
[10:26:12.162]                 ...future.workdir <- getwd()
[10:26:12.162]             }
[10:26:12.162]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.162]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.162]         }
[10:26:12.162]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.162]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:12.162]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.162]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.162]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.162]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.162]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.162]             base::names(...future.oldOptions))
[10:26:12.162]     }
[10:26:12.162]     if (FALSE) {
[10:26:12.162]     }
[10:26:12.162]     else {
[10:26:12.162]         if (TRUE) {
[10:26:12.162]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.162]                 open = "w")
[10:26:12.162]         }
[10:26:12.162]         else {
[10:26:12.162]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.162]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.162]         }
[10:26:12.162]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.162]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.162]             base::sink(type = "output", split = FALSE)
[10:26:12.162]             base::close(...future.stdout)
[10:26:12.162]         }, add = TRUE)
[10:26:12.162]     }
[10:26:12.162]     ...future.frame <- base::sys.nframe()
[10:26:12.162]     ...future.conditions <- base::list()
[10:26:12.162]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.162]     if (FALSE) {
[10:26:12.162]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.162]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.162]     }
[10:26:12.162]     ...future.result <- base::tryCatch({
[10:26:12.162]         base::withCallingHandlers({
[10:26:12.162]             ...future.value <- base::withVisible(base::local({
[10:26:12.162]                 withCallingHandlers({
[10:26:12.162]                   1
[10:26:12.162]                 }, immediateCondition = function(cond) {
[10:26:12.162]                   save_rds <- function (object, pathname, ...) 
[10:26:12.162]                   {
[10:26:12.162]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.162]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.162]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.162]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.162]                         fi_tmp[["mtime"]])
[10:26:12.162]                     }
[10:26:12.162]                     tryCatch({
[10:26:12.162]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.162]                     }, error = function(ex) {
[10:26:12.162]                       msg <- conditionMessage(ex)
[10:26:12.162]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.162]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.162]                         fi_tmp[["mtime"]], msg)
[10:26:12.162]                       ex$message <- msg
[10:26:12.162]                       stop(ex)
[10:26:12.162]                     })
[10:26:12.162]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.162]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.162]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.162]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.162]                       fi <- file.info(pathname)
[10:26:12.162]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.162]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.162]                         fi[["size"]], fi[["mtime"]])
[10:26:12.162]                       stop(msg)
[10:26:12.162]                     }
[10:26:12.162]                     invisible(pathname)
[10:26:12.162]                   }
[10:26:12.162]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.162]                     rootPath = tempdir()) 
[10:26:12.162]                   {
[10:26:12.162]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.162]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.162]                       tmpdir = path, fileext = ".rds")
[10:26:12.162]                     save_rds(obj, file)
[10:26:12.162]                   }
[10:26:12.162]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.162]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.162]                   {
[10:26:12.162]                     inherits <- base::inherits
[10:26:12.162]                     invokeRestart <- base::invokeRestart
[10:26:12.162]                     is.null <- base::is.null
[10:26:12.162]                     muffled <- FALSE
[10:26:12.162]                     if (inherits(cond, "message")) {
[10:26:12.162]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.162]                       if (muffled) 
[10:26:12.162]                         invokeRestart("muffleMessage")
[10:26:12.162]                     }
[10:26:12.162]                     else if (inherits(cond, "warning")) {
[10:26:12.162]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.162]                       if (muffled) 
[10:26:12.162]                         invokeRestart("muffleWarning")
[10:26:12.162]                     }
[10:26:12.162]                     else if (inherits(cond, "condition")) {
[10:26:12.162]                       if (!is.null(pattern)) {
[10:26:12.162]                         computeRestarts <- base::computeRestarts
[10:26:12.162]                         grepl <- base::grepl
[10:26:12.162]                         restarts <- computeRestarts(cond)
[10:26:12.162]                         for (restart in restarts) {
[10:26:12.162]                           name <- restart$name
[10:26:12.162]                           if (is.null(name)) 
[10:26:12.162]                             next
[10:26:12.162]                           if (!grepl(pattern, name)) 
[10:26:12.162]                             next
[10:26:12.162]                           invokeRestart(restart)
[10:26:12.162]                           muffled <- TRUE
[10:26:12.162]                           break
[10:26:12.162]                         }
[10:26:12.162]                       }
[10:26:12.162]                     }
[10:26:12.162]                     invisible(muffled)
[10:26:12.162]                   }
[10:26:12.162]                   muffleCondition(cond)
[10:26:12.162]                 })
[10:26:12.162]             }))
[10:26:12.162]             future::FutureResult(value = ...future.value$value, 
[10:26:12.162]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.162]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.162]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.162]                     ...future.globalenv.names))
[10:26:12.162]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.162]         }, condition = base::local({
[10:26:12.162]             c <- base::c
[10:26:12.162]             inherits <- base::inherits
[10:26:12.162]             invokeRestart <- base::invokeRestart
[10:26:12.162]             length <- base::length
[10:26:12.162]             list <- base::list
[10:26:12.162]             seq.int <- base::seq.int
[10:26:12.162]             signalCondition <- base::signalCondition
[10:26:12.162]             sys.calls <- base::sys.calls
[10:26:12.162]             `[[` <- base::`[[`
[10:26:12.162]             `+` <- base::`+`
[10:26:12.162]             `<<-` <- base::`<<-`
[10:26:12.162]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.162]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.162]                   3L)]
[10:26:12.162]             }
[10:26:12.162]             function(cond) {
[10:26:12.162]                 is_error <- inherits(cond, "error")
[10:26:12.162]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.162]                   NULL)
[10:26:12.162]                 if (is_error) {
[10:26:12.162]                   sessionInformation <- function() {
[10:26:12.162]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.162]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.162]                       search = base::search(), system = base::Sys.info())
[10:26:12.162]                   }
[10:26:12.162]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.162]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.162]                     cond$call), session = sessionInformation(), 
[10:26:12.162]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.162]                   signalCondition(cond)
[10:26:12.162]                 }
[10:26:12.162]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.162]                 "immediateCondition"))) {
[10:26:12.162]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.162]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.162]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.162]                   if (TRUE && !signal) {
[10:26:12.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.162]                     {
[10:26:12.162]                       inherits <- base::inherits
[10:26:12.162]                       invokeRestart <- base::invokeRestart
[10:26:12.162]                       is.null <- base::is.null
[10:26:12.162]                       muffled <- FALSE
[10:26:12.162]                       if (inherits(cond, "message")) {
[10:26:12.162]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.162]                         if (muffled) 
[10:26:12.162]                           invokeRestart("muffleMessage")
[10:26:12.162]                       }
[10:26:12.162]                       else if (inherits(cond, "warning")) {
[10:26:12.162]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.162]                         if (muffled) 
[10:26:12.162]                           invokeRestart("muffleWarning")
[10:26:12.162]                       }
[10:26:12.162]                       else if (inherits(cond, "condition")) {
[10:26:12.162]                         if (!is.null(pattern)) {
[10:26:12.162]                           computeRestarts <- base::computeRestarts
[10:26:12.162]                           grepl <- base::grepl
[10:26:12.162]                           restarts <- computeRestarts(cond)
[10:26:12.162]                           for (restart in restarts) {
[10:26:12.162]                             name <- restart$name
[10:26:12.162]                             if (is.null(name)) 
[10:26:12.162]                               next
[10:26:12.162]                             if (!grepl(pattern, name)) 
[10:26:12.162]                               next
[10:26:12.162]                             invokeRestart(restart)
[10:26:12.162]                             muffled <- TRUE
[10:26:12.162]                             break
[10:26:12.162]                           }
[10:26:12.162]                         }
[10:26:12.162]                       }
[10:26:12.162]                       invisible(muffled)
[10:26:12.162]                     }
[10:26:12.162]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.162]                   }
[10:26:12.162]                 }
[10:26:12.162]                 else {
[10:26:12.162]                   if (TRUE) {
[10:26:12.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.162]                     {
[10:26:12.162]                       inherits <- base::inherits
[10:26:12.162]                       invokeRestart <- base::invokeRestart
[10:26:12.162]                       is.null <- base::is.null
[10:26:12.162]                       muffled <- FALSE
[10:26:12.162]                       if (inherits(cond, "message")) {
[10:26:12.162]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.162]                         if (muffled) 
[10:26:12.162]                           invokeRestart("muffleMessage")
[10:26:12.162]                       }
[10:26:12.162]                       else if (inherits(cond, "warning")) {
[10:26:12.162]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.162]                         if (muffled) 
[10:26:12.162]                           invokeRestart("muffleWarning")
[10:26:12.162]                       }
[10:26:12.162]                       else if (inherits(cond, "condition")) {
[10:26:12.162]                         if (!is.null(pattern)) {
[10:26:12.162]                           computeRestarts <- base::computeRestarts
[10:26:12.162]                           grepl <- base::grepl
[10:26:12.162]                           restarts <- computeRestarts(cond)
[10:26:12.162]                           for (restart in restarts) {
[10:26:12.162]                             name <- restart$name
[10:26:12.162]                             if (is.null(name)) 
[10:26:12.162]                               next
[10:26:12.162]                             if (!grepl(pattern, name)) 
[10:26:12.162]                               next
[10:26:12.162]                             invokeRestart(restart)
[10:26:12.162]                             muffled <- TRUE
[10:26:12.162]                             break
[10:26:12.162]                           }
[10:26:12.162]                         }
[10:26:12.162]                       }
[10:26:12.162]                       invisible(muffled)
[10:26:12.162]                     }
[10:26:12.162]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.162]                   }
[10:26:12.162]                 }
[10:26:12.162]             }
[10:26:12.162]         }))
[10:26:12.162]     }, error = function(ex) {
[10:26:12.162]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.162]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.162]                 ...future.rng), started = ...future.startTime, 
[10:26:12.162]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.162]             version = "1.8"), class = "FutureResult")
[10:26:12.162]     }, finally = {
[10:26:12.162]         if (!identical(...future.workdir, getwd())) 
[10:26:12.162]             setwd(...future.workdir)
[10:26:12.162]         {
[10:26:12.162]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.162]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.162]             }
[10:26:12.162]             base::options(...future.oldOptions)
[10:26:12.162]             if (.Platform$OS.type == "windows") {
[10:26:12.162]                 old_names <- names(...future.oldEnvVars)
[10:26:12.162]                 envs <- base::Sys.getenv()
[10:26:12.162]                 names <- names(envs)
[10:26:12.162]                 common <- intersect(names, old_names)
[10:26:12.162]                 added <- setdiff(names, old_names)
[10:26:12.162]                 removed <- setdiff(old_names, names)
[10:26:12.162]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.162]                   envs[common]]
[10:26:12.162]                 NAMES <- toupper(changed)
[10:26:12.162]                 args <- list()
[10:26:12.162]                 for (kk in seq_along(NAMES)) {
[10:26:12.162]                   name <- changed[[kk]]
[10:26:12.162]                   NAME <- NAMES[[kk]]
[10:26:12.162]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.162]                     next
[10:26:12.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.162]                 }
[10:26:12.162]                 NAMES <- toupper(added)
[10:26:12.162]                 for (kk in seq_along(NAMES)) {
[10:26:12.162]                   name <- added[[kk]]
[10:26:12.162]                   NAME <- NAMES[[kk]]
[10:26:12.162]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.162]                     next
[10:26:12.162]                   args[[name]] <- ""
[10:26:12.162]                 }
[10:26:12.162]                 NAMES <- toupper(removed)
[10:26:12.162]                 for (kk in seq_along(NAMES)) {
[10:26:12.162]                   name <- removed[[kk]]
[10:26:12.162]                   NAME <- NAMES[[kk]]
[10:26:12.162]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.162]                     next
[10:26:12.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.162]                 }
[10:26:12.162]                 if (length(args) > 0) 
[10:26:12.162]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.162]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.162]             }
[10:26:12.162]             else {
[10:26:12.162]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.162]             }
[10:26:12.162]             {
[10:26:12.162]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.162]                   0L) {
[10:26:12.162]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.162]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.162]                   base::options(opts)
[10:26:12.162]                 }
[10:26:12.162]                 {
[10:26:12.162]                   {
[10:26:12.162]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.162]                     NULL
[10:26:12.162]                   }
[10:26:12.162]                   options(future.plan = NULL)
[10:26:12.162]                   if (is.na(NA_character_)) 
[10:26:12.162]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.162]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.162]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.162]                     envir = parent.frame()) 
[10:26:12.162]                   {
[10:26:12.162]                     default_workers <- missing(workers)
[10:26:12.162]                     if (is.function(workers)) 
[10:26:12.162]                       workers <- workers()
[10:26:12.162]                     workers <- structure(as.integer(workers), 
[10:26:12.162]                       class = class(workers))
[10:26:12.162]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.162]                       1L)
[10:26:12.162]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.162]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.162]                       if (default_workers) 
[10:26:12.162]                         supportsMulticore(warn = TRUE)
[10:26:12.162]                       return(sequential(..., envir = envir))
[10:26:12.162]                     }
[10:26:12.162]                     oopts <- options(mc.cores = workers)
[10:26:12.162]                     on.exit(options(oopts))
[10:26:12.162]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.162]                       envir = envir)
[10:26:12.162]                     if (!future$lazy) 
[10:26:12.162]                       future <- run(future)
[10:26:12.162]                     invisible(future)
[10:26:12.162]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.162]                 }
[10:26:12.162]             }
[10:26:12.162]         }
[10:26:12.162]     })
[10:26:12.162]     if (TRUE) {
[10:26:12.162]         base::sink(type = "output", split = FALSE)
[10:26:12.162]         if (TRUE) {
[10:26:12.162]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.162]         }
[10:26:12.162]         else {
[10:26:12.162]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.162]         }
[10:26:12.162]         base::close(...future.stdout)
[10:26:12.162]         ...future.stdout <- NULL
[10:26:12.162]     }
[10:26:12.162]     ...future.result$conditions <- ...future.conditions
[10:26:12.162]     ...future.result$finished <- base::Sys.time()
[10:26:12.162]     ...future.result
[10:26:12.162] }
[10:26:12.164] requestCore(): workers = 2
[10:26:12.166] MulticoreFuture started
[10:26:12.167] - Launch lazy future ... done
[10:26:12.167] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.167] getGlobalsAndPackages() ...
[10:26:12.167] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.168] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:12.168] List of future strategies:
[10:26:12.168] 1. sequential:
[10:26:12.168]    - args: function (..., envir = parent.frame())
[10:26:12.168]    - tweaked: FALSE
[10:26:12.168]    - call: NULL
[10:26:12.168] plan(): nbrOfWorkers() = 1
[10:26:12.170] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:12.170] Searching for globals ... DONE
[10:26:12.170] Resolving globals: TRUE
[10:26:12.170] Resolving any globals that are futures ...
[10:26:12.170] plan(): Setting new future strategy stack:
[10:26:12.170] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:12.171] Resolving any globals that are futures ... DONE
[10:26:12.171] List of future strategies:
[10:26:12.171] 1. multicore:
[10:26:12.171]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.171]    - tweaked: FALSE
[10:26:12.171]    - call: plan(strategy)
[10:26:12.171] Resolving futures part of globals (recursively) ...
[10:26:12.172] resolve() on list ...
[10:26:12.172]  recursive: 99
[10:26:12.172]  length: 1
[10:26:12.172]  elements: ‘a’
[10:26:12.175] plan(): nbrOfWorkers() = 2
[10:26:12.176] Future #1
[10:26:12.176] result() for MulticoreFuture ...
[10:26:12.181] result() for MulticoreFuture ...
[10:26:12.181] result() for MulticoreFuture ... done
[10:26:12.182] result() for MulticoreFuture ... done
[10:26:12.182] result() for MulticoreFuture ...
[10:26:12.182] result() for MulticoreFuture ... done
[10:26:12.182] A MulticoreFuture was resolved
[10:26:12.183]  length: 0 (resolved future 1)
[10:26:12.183] resolve() on list ... DONE
[10:26:12.183] - globals: [1] ‘a’
[10:26:12.183] Resolving futures part of globals (recursively) ... DONE
[10:26:12.185] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[10:26:12.185] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[10:26:12.185] - globals: [1] ‘a’
[10:26:12.185] - packages: [1] ‘future’
[10:26:12.186] getGlobalsAndPackages() ... DONE
[10:26:12.186] run() for ‘Future’ ...
[10:26:12.186] - state: ‘created’
[10:26:12.186] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.190] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.190] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.191]   - Field: ‘label’
[10:26:12.191]   - Field: ‘local’
[10:26:12.191]   - Field: ‘owner’
[10:26:12.191]   - Field: ‘envir’
[10:26:12.191]   - Field: ‘workers’
[10:26:12.191]   - Field: ‘packages’
[10:26:12.191]   - Field: ‘gc’
[10:26:12.191]   - Field: ‘job’
[10:26:12.192]   - Field: ‘conditions’
[10:26:12.192]   - Field: ‘expr’
[10:26:12.192]   - Field: ‘uuid’
[10:26:12.192]   - Field: ‘seed’
[10:26:12.192]   - Field: ‘version’
[10:26:12.192]   - Field: ‘result’
[10:26:12.192]   - Field: ‘asynchronous’
[10:26:12.192]   - Field: ‘calls’
[10:26:12.192]   - Field: ‘globals’
[10:26:12.193]   - Field: ‘stdout’
[10:26:12.193]   - Field: ‘earlySignal’
[10:26:12.193]   - Field: ‘lazy’
[10:26:12.193]   - Field: ‘state’
[10:26:12.193] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.193] - Launch lazy future ...
[10:26:12.193] Packages needed by the future expression (n = 1): ‘future’
[10:26:12.194] Packages needed by future strategies (n = 0): <none>
[10:26:12.194] {
[10:26:12.194]     {
[10:26:12.194]         {
[10:26:12.194]             ...future.startTime <- base::Sys.time()
[10:26:12.194]             {
[10:26:12.194]                 {
[10:26:12.194]                   {
[10:26:12.194]                     {
[10:26:12.194]                       {
[10:26:12.194]                         base::local({
[10:26:12.194]                           has_future <- base::requireNamespace("future", 
[10:26:12.194]                             quietly = TRUE)
[10:26:12.194]                           if (has_future) {
[10:26:12.194]                             ns <- base::getNamespace("future")
[10:26:12.194]                             version <- ns[[".package"]][["version"]]
[10:26:12.194]                             if (is.null(version)) 
[10:26:12.194]                               version <- utils::packageVersion("future")
[10:26:12.194]                           }
[10:26:12.194]                           else {
[10:26:12.194]                             version <- NULL
[10:26:12.194]                           }
[10:26:12.194]                           if (!has_future || version < "1.8.0") {
[10:26:12.194]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.194]                               "", base::R.version$version.string), 
[10:26:12.194]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:12.194]                                 base::R.version$platform, 8 * 
[10:26:12.194]                                   base::.Machine$sizeof.pointer), 
[10:26:12.194]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.194]                                 "release", "version")], collapse = " "), 
[10:26:12.194]                               hostname = base::Sys.info()[["nodename"]])
[10:26:12.194]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.194]                               info)
[10:26:12.194]                             info <- base::paste(info, collapse = "; ")
[10:26:12.194]                             if (!has_future) {
[10:26:12.194]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.194]                                 info)
[10:26:12.194]                             }
[10:26:12.194]                             else {
[10:26:12.194]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.194]                                 info, version)
[10:26:12.194]                             }
[10:26:12.194]                             base::stop(msg)
[10:26:12.194]                           }
[10:26:12.194]                         })
[10:26:12.194]                       }
[10:26:12.194]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.194]                       base::options(mc.cores = 1L)
[10:26:12.194]                     }
[10:26:12.194]                     base::local({
[10:26:12.194]                       for (pkg in "future") {
[10:26:12.194]                         base::loadNamespace(pkg)
[10:26:12.194]                         base::library(pkg, character.only = TRUE)
[10:26:12.194]                       }
[10:26:12.194]                     })
[10:26:12.194]                   }
[10:26:12.194]                   options(future.plan = NULL)
[10:26:12.194]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.194]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.194]                 }
[10:26:12.194]                 ...future.workdir <- getwd()
[10:26:12.194]             }
[10:26:12.194]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.194]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.194]         }
[10:26:12.194]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.194]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:12.194]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.194]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.194]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.194]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.194]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.194]             base::names(...future.oldOptions))
[10:26:12.194]     }
[10:26:12.194]     if (FALSE) {
[10:26:12.194]     }
[10:26:12.194]     else {
[10:26:12.194]         if (TRUE) {
[10:26:12.194]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.194]                 open = "w")
[10:26:12.194]         }
[10:26:12.194]         else {
[10:26:12.194]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.194]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.194]         }
[10:26:12.194]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.194]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.194]             base::sink(type = "output", split = FALSE)
[10:26:12.194]             base::close(...future.stdout)
[10:26:12.194]         }, add = TRUE)
[10:26:12.194]     }
[10:26:12.194]     ...future.frame <- base::sys.nframe()
[10:26:12.194]     ...future.conditions <- base::list()
[10:26:12.194]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.194]     if (FALSE) {
[10:26:12.194]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.194]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.194]     }
[10:26:12.194]     ...future.result <- base::tryCatch({
[10:26:12.194]         base::withCallingHandlers({
[10:26:12.194]             ...future.value <- base::withVisible(base::local({
[10:26:12.194]                 withCallingHandlers({
[10:26:12.194]                   value(a) + 1
[10:26:12.194]                 }, immediateCondition = function(cond) {
[10:26:12.194]                   save_rds <- function (object, pathname, ...) 
[10:26:12.194]                   {
[10:26:12.194]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.194]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.194]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.194]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.194]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.194]                         fi_tmp[["mtime"]])
[10:26:12.194]                     }
[10:26:12.194]                     tryCatch({
[10:26:12.194]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.194]                     }, error = function(ex) {
[10:26:12.194]                       msg <- conditionMessage(ex)
[10:26:12.194]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.194]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.194]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.194]                         fi_tmp[["mtime"]], msg)
[10:26:12.194]                       ex$message <- msg
[10:26:12.194]                       stop(ex)
[10:26:12.194]                     })
[10:26:12.194]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.194]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.194]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.194]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.194]                       fi <- file.info(pathname)
[10:26:12.194]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.194]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.194]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.194]                         fi[["size"]], fi[["mtime"]])
[10:26:12.194]                       stop(msg)
[10:26:12.194]                     }
[10:26:12.194]                     invisible(pathname)
[10:26:12.194]                   }
[10:26:12.194]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.194]                     rootPath = tempdir()) 
[10:26:12.194]                   {
[10:26:12.194]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.194]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.194]                       tmpdir = path, fileext = ".rds")
[10:26:12.194]                     save_rds(obj, file)
[10:26:12.194]                   }
[10:26:12.194]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.194]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.194]                   {
[10:26:12.194]                     inherits <- base::inherits
[10:26:12.194]                     invokeRestart <- base::invokeRestart
[10:26:12.194]                     is.null <- base::is.null
[10:26:12.194]                     muffled <- FALSE
[10:26:12.194]                     if (inherits(cond, "message")) {
[10:26:12.194]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.194]                       if (muffled) 
[10:26:12.194]                         invokeRestart("muffleMessage")
[10:26:12.194]                     }
[10:26:12.194]                     else if (inherits(cond, "warning")) {
[10:26:12.194]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.194]                       if (muffled) 
[10:26:12.194]                         invokeRestart("muffleWarning")
[10:26:12.194]                     }
[10:26:12.194]                     else if (inherits(cond, "condition")) {
[10:26:12.194]                       if (!is.null(pattern)) {
[10:26:12.194]                         computeRestarts <- base::computeRestarts
[10:26:12.194]                         grepl <- base::grepl
[10:26:12.194]                         restarts <- computeRestarts(cond)
[10:26:12.194]                         for (restart in restarts) {
[10:26:12.194]                           name <- restart$name
[10:26:12.194]                           if (is.null(name)) 
[10:26:12.194]                             next
[10:26:12.194]                           if (!grepl(pattern, name)) 
[10:26:12.194]                             next
[10:26:12.194]                           invokeRestart(restart)
[10:26:12.194]                           muffled <- TRUE
[10:26:12.194]                           break
[10:26:12.194]                         }
[10:26:12.194]                       }
[10:26:12.194]                     }
[10:26:12.194]                     invisible(muffled)
[10:26:12.194]                   }
[10:26:12.194]                   muffleCondition(cond)
[10:26:12.194]                 })
[10:26:12.194]             }))
[10:26:12.194]             future::FutureResult(value = ...future.value$value, 
[10:26:12.194]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.194]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.194]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.194]                     ...future.globalenv.names))
[10:26:12.194]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.194]         }, condition = base::local({
[10:26:12.194]             c <- base::c
[10:26:12.194]             inherits <- base::inherits
[10:26:12.194]             invokeRestart <- base::invokeRestart
[10:26:12.194]             length <- base::length
[10:26:12.194]             list <- base::list
[10:26:12.194]             seq.int <- base::seq.int
[10:26:12.194]             signalCondition <- base::signalCondition
[10:26:12.194]             sys.calls <- base::sys.calls
[10:26:12.194]             `[[` <- base::`[[`
[10:26:12.194]             `+` <- base::`+`
[10:26:12.194]             `<<-` <- base::`<<-`
[10:26:12.194]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.194]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.194]                   3L)]
[10:26:12.194]             }
[10:26:12.194]             function(cond) {
[10:26:12.194]                 is_error <- inherits(cond, "error")
[10:26:12.194]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.194]                   NULL)
[10:26:12.194]                 if (is_error) {
[10:26:12.194]                   sessionInformation <- function() {
[10:26:12.194]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.194]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.194]                       search = base::search(), system = base::Sys.info())
[10:26:12.194]                   }
[10:26:12.194]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.194]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.194]                     cond$call), session = sessionInformation(), 
[10:26:12.194]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.194]                   signalCondition(cond)
[10:26:12.194]                 }
[10:26:12.194]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.194]                 "immediateCondition"))) {
[10:26:12.194]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.194]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.194]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.194]                   if (TRUE && !signal) {
[10:26:12.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.194]                     {
[10:26:12.194]                       inherits <- base::inherits
[10:26:12.194]                       invokeRestart <- base::invokeRestart
[10:26:12.194]                       is.null <- base::is.null
[10:26:12.194]                       muffled <- FALSE
[10:26:12.194]                       if (inherits(cond, "message")) {
[10:26:12.194]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.194]                         if (muffled) 
[10:26:12.194]                           invokeRestart("muffleMessage")
[10:26:12.194]                       }
[10:26:12.194]                       else if (inherits(cond, "warning")) {
[10:26:12.194]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.194]                         if (muffled) 
[10:26:12.194]                           invokeRestart("muffleWarning")
[10:26:12.194]                       }
[10:26:12.194]                       else if (inherits(cond, "condition")) {
[10:26:12.194]                         if (!is.null(pattern)) {
[10:26:12.194]                           computeRestarts <- base::computeRestarts
[10:26:12.194]                           grepl <- base::grepl
[10:26:12.194]                           restarts <- computeRestarts(cond)
[10:26:12.194]                           for (restart in restarts) {
[10:26:12.194]                             name <- restart$name
[10:26:12.194]                             if (is.null(name)) 
[10:26:12.194]                               next
[10:26:12.194]                             if (!grepl(pattern, name)) 
[10:26:12.194]                               next
[10:26:12.194]                             invokeRestart(restart)
[10:26:12.194]                             muffled <- TRUE
[10:26:12.194]                             break
[10:26:12.194]                           }
[10:26:12.194]                         }
[10:26:12.194]                       }
[10:26:12.194]                       invisible(muffled)
[10:26:12.194]                     }
[10:26:12.194]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.194]                   }
[10:26:12.194]                 }
[10:26:12.194]                 else {
[10:26:12.194]                   if (TRUE) {
[10:26:12.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.194]                     {
[10:26:12.194]                       inherits <- base::inherits
[10:26:12.194]                       invokeRestart <- base::invokeRestart
[10:26:12.194]                       is.null <- base::is.null
[10:26:12.194]                       muffled <- FALSE
[10:26:12.194]                       if (inherits(cond, "message")) {
[10:26:12.194]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.194]                         if (muffled) 
[10:26:12.194]                           invokeRestart("muffleMessage")
[10:26:12.194]                       }
[10:26:12.194]                       else if (inherits(cond, "warning")) {
[10:26:12.194]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.194]                         if (muffled) 
[10:26:12.194]                           invokeRestart("muffleWarning")
[10:26:12.194]                       }
[10:26:12.194]                       else if (inherits(cond, "condition")) {
[10:26:12.194]                         if (!is.null(pattern)) {
[10:26:12.194]                           computeRestarts <- base::computeRestarts
[10:26:12.194]                           grepl <- base::grepl
[10:26:12.194]                           restarts <- computeRestarts(cond)
[10:26:12.194]                           for (restart in restarts) {
[10:26:12.194]                             name <- restart$name
[10:26:12.194]                             if (is.null(name)) 
[10:26:12.194]                               next
[10:26:12.194]                             if (!grepl(pattern, name)) 
[10:26:12.194]                               next
[10:26:12.194]                             invokeRestart(restart)
[10:26:12.194]                             muffled <- TRUE
[10:26:12.194]                             break
[10:26:12.194]                           }
[10:26:12.194]                         }
[10:26:12.194]                       }
[10:26:12.194]                       invisible(muffled)
[10:26:12.194]                     }
[10:26:12.194]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.194]                   }
[10:26:12.194]                 }
[10:26:12.194]             }
[10:26:12.194]         }))
[10:26:12.194]     }, error = function(ex) {
[10:26:12.194]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.194]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.194]                 ...future.rng), started = ...future.startTime, 
[10:26:12.194]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.194]             version = "1.8"), class = "FutureResult")
[10:26:12.194]     }, finally = {
[10:26:12.194]         if (!identical(...future.workdir, getwd())) 
[10:26:12.194]             setwd(...future.workdir)
[10:26:12.194]         {
[10:26:12.194]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.194]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.194]             }
[10:26:12.194]             base::options(...future.oldOptions)
[10:26:12.194]             if (.Platform$OS.type == "windows") {
[10:26:12.194]                 old_names <- names(...future.oldEnvVars)
[10:26:12.194]                 envs <- base::Sys.getenv()
[10:26:12.194]                 names <- names(envs)
[10:26:12.194]                 common <- intersect(names, old_names)
[10:26:12.194]                 added <- setdiff(names, old_names)
[10:26:12.194]                 removed <- setdiff(old_names, names)
[10:26:12.194]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.194]                   envs[common]]
[10:26:12.194]                 NAMES <- toupper(changed)
[10:26:12.194]                 args <- list()
[10:26:12.194]                 for (kk in seq_along(NAMES)) {
[10:26:12.194]                   name <- changed[[kk]]
[10:26:12.194]                   NAME <- NAMES[[kk]]
[10:26:12.194]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.194]                     next
[10:26:12.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.194]                 }
[10:26:12.194]                 NAMES <- toupper(added)
[10:26:12.194]                 for (kk in seq_along(NAMES)) {
[10:26:12.194]                   name <- added[[kk]]
[10:26:12.194]                   NAME <- NAMES[[kk]]
[10:26:12.194]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.194]                     next
[10:26:12.194]                   args[[name]] <- ""
[10:26:12.194]                 }
[10:26:12.194]                 NAMES <- toupper(removed)
[10:26:12.194]                 for (kk in seq_along(NAMES)) {
[10:26:12.194]                   name <- removed[[kk]]
[10:26:12.194]                   NAME <- NAMES[[kk]]
[10:26:12.194]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.194]                     next
[10:26:12.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.194]                 }
[10:26:12.194]                 if (length(args) > 0) 
[10:26:12.194]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.194]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.194]             }
[10:26:12.194]             else {
[10:26:12.194]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.194]             }
[10:26:12.194]             {
[10:26:12.194]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.194]                   0L) {
[10:26:12.194]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.194]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.194]                   base::options(opts)
[10:26:12.194]                 }
[10:26:12.194]                 {
[10:26:12.194]                   {
[10:26:12.194]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.194]                     NULL
[10:26:12.194]                   }
[10:26:12.194]                   options(future.plan = NULL)
[10:26:12.194]                   if (is.na(NA_character_)) 
[10:26:12.194]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.194]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.194]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.194]                     envir = parent.frame()) 
[10:26:12.194]                   {
[10:26:12.194]                     default_workers <- missing(workers)
[10:26:12.194]                     if (is.function(workers)) 
[10:26:12.194]                       workers <- workers()
[10:26:12.194]                     workers <- structure(as.integer(workers), 
[10:26:12.194]                       class = class(workers))
[10:26:12.194]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.194]                       1L)
[10:26:12.194]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.194]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.194]                       if (default_workers) 
[10:26:12.194]                         supportsMulticore(warn = TRUE)
[10:26:12.194]                       return(sequential(..., envir = envir))
[10:26:12.194]                     }
[10:26:12.194]                     oopts <- options(mc.cores = workers)
[10:26:12.194]                     on.exit(options(oopts))
[10:26:12.194]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.194]                       envir = envir)
[10:26:12.194]                     if (!future$lazy) 
[10:26:12.194]                       future <- run(future)
[10:26:12.194]                     invisible(future)
[10:26:12.194]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.194]                 }
[10:26:12.194]             }
[10:26:12.194]         }
[10:26:12.194]     })
[10:26:12.194]     if (TRUE) {
[10:26:12.194]         base::sink(type = "output", split = FALSE)
[10:26:12.194]         if (TRUE) {
[10:26:12.194]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.194]         }
[10:26:12.194]         else {
[10:26:12.194]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.194]         }
[10:26:12.194]         base::close(...future.stdout)
[10:26:12.194]         ...future.stdout <- NULL
[10:26:12.194]     }
[10:26:12.194]     ...future.result$conditions <- ...future.conditions
[10:26:12.194]     ...future.result$finished <- base::Sys.time()
[10:26:12.194]     ...future.result
[10:26:12.194] }
[10:26:12.197] assign_globals() ...
[10:26:12.197] List of 1
[10:26:12.197]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a021bde158> 
[10:26:12.197]  - attr(*, "where")=List of 1
[10:26:12.197]   ..$ a:<environment: R_EmptyEnv> 
[10:26:12.197]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:12.197]  - attr(*, "resolved")= logi TRUE
[10:26:12.197]  - attr(*, "total_size")= num 10816
[10:26:12.197]  - attr(*, "already-done")= logi TRUE
[10:26:12.200] - copied ‘a’ to environment
[10:26:12.200] assign_globals() ... done
[10:26:12.200] requestCore(): workers = 2
[10:26:12.202] MulticoreFuture started
[10:26:12.202] - Launch lazy future ... done
[10:26:12.202] run() for ‘MulticoreFuture’ ... done
[10:26:12.202] result() for MulticoreFuture ...
[10:26:12.203] plan(): Setting new future strategy stack:
[10:26:12.203] List of future strategies:
[10:26:12.203] 1. sequential:
[10:26:12.203]    - args: function (..., envir = parent.frame())
[10:26:12.203]    - tweaked: FALSE
[10:26:12.203]    - call: NULL
[10:26:12.204] plan(): nbrOfWorkers() = 1
[10:26:12.208] plan(): Setting new future strategy stack:
[10:26:12.208] List of future strategies:
[10:26:12.208] 1. multicore:
[10:26:12.208]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.208]    - tweaked: FALSE
[10:26:12.208]    - call: plan(strategy)
[10:26:12.213] plan(): nbrOfWorkers() = 2
[10:26:12.214] result() for MulticoreFuture ...
[10:26:12.214] result() for MulticoreFuture ... done
[10:26:12.214] signalConditions() ...
[10:26:12.214]  - include = ‘immediateCondition’
[10:26:12.214]  - exclude = 
[10:26:12.214]  - resignal = FALSE
[10:26:12.215]  - Number of conditions: 4
[10:26:12.215] signalConditions() ... done
[10:26:12.215] result() for MulticoreFuture ... done
[10:26:12.215] result() for MulticoreFuture ...
[10:26:12.215] result() for MulticoreFuture ... done
[10:26:12.216] signalConditions() ...
[10:26:12.216]  - include = ‘immediateCondition’
[10:26:12.216]  - exclude = 
[10:26:12.216]  - resignal = FALSE
[10:26:12.216]  - Number of conditions: 4
[10:26:12.216] signalConditions() ... done
[10:26:12.216] Future state: ‘finished’
[10:26:12.216] result() for MulticoreFuture ...
[10:26:12.217] result() for MulticoreFuture ... done
[10:26:12.217] signalConditions() ...
[10:26:12.217]  - include = ‘condition’
[10:26:12.217]  - exclude = ‘immediateCondition’
[10:26:12.217]  - resignal = TRUE
[10:26:12.217]  - Number of conditions: 4
[10:26:12.217]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.205] result() for MulticoreFuture ...
[10:26:12.217]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.206] result() for MulticoreFuture ... done
[10:26:12.218]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.206] result() for MulticoreFuture ...
[10:26:12.218]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.206] result() for MulticoreFuture ... done
[10:26:12.218] signalConditions() ... done
value(b) = 2
[10:26:12.218] result() for MulticoreFuture ...
[10:26:12.218] result() for MulticoreFuture ... done
[10:26:12.218] result() for MulticoreFuture ...
[10:26:12.219] result() for MulticoreFuture ... done
[10:26:12.219] signalConditions() ...
[10:26:12.219]  - include = ‘immediateCondition’
[10:26:12.219]  - exclude = 
[10:26:12.219]  - resignal = FALSE
[10:26:12.219]  - Number of conditions: 4
[10:26:12.219] signalConditions() ... done
[10:26:12.219] Future state: ‘finished’
[10:26:12.219] result() for MulticoreFuture ...
[10:26:12.220] result() for MulticoreFuture ... done
[10:26:12.220] signalConditions() ...
[10:26:12.220]  - include = ‘condition’
[10:26:12.220]  - exclude = ‘immediateCondition’
[10:26:12.220]  - resignal = TRUE
[10:26:12.220]  - Number of conditions: 4
[10:26:12.220]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.205] result() for MulticoreFuture ...
[10:26:12.220]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.206] result() for MulticoreFuture ... done
[10:26:12.221]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.206] result() for MulticoreFuture ...
[10:26:12.223]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.206] result() for MulticoreFuture ... done
[10:26:12.223] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.224] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.224] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:12.225] 
[10:26:12.225] Searching for globals ... DONE
[10:26:12.226] - globals: [0] <none>
[10:26:12.226] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.226] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.226] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:12.228] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:12.228] Searching for globals ... DONE
[10:26:12.228] Resolving globals: TRUE
[10:26:12.228] Resolving any globals that are futures ...
[10:26:12.228] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:12.228] Resolving any globals that are futures ... DONE
[10:26:12.229] Resolving futures part of globals (recursively) ...
[10:26:12.229] resolve() on list ...
[10:26:12.229]  recursive: 99
[10:26:12.229]  length: 1
[10:26:12.229]  elements: ‘a’
[10:26:12.230] run() for ‘Future’ ...
[10:26:12.230] - state: ‘created’
[10:26:12.230] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.234] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.234] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.234]   - Field: ‘label’
[10:26:12.234]   - Field: ‘local’
[10:26:12.234]   - Field: ‘owner’
[10:26:12.234]   - Field: ‘envir’
[10:26:12.234]   - Field: ‘workers’
[10:26:12.234]   - Field: ‘packages’
[10:26:12.235]   - Field: ‘gc’
[10:26:12.235]   - Field: ‘job’
[10:26:12.235]   - Field: ‘conditions’
[10:26:12.235]   - Field: ‘expr’
[10:26:12.235]   - Field: ‘uuid’
[10:26:12.235]   - Field: ‘seed’
[10:26:12.235]   - Field: ‘version’
[10:26:12.235]   - Field: ‘result’
[10:26:12.235]   - Field: ‘asynchronous’
[10:26:12.235]   - Field: ‘calls’
[10:26:12.236]   - Field: ‘globals’
[10:26:12.236]   - Field: ‘stdout’
[10:26:12.236]   - Field: ‘earlySignal’
[10:26:12.236]   - Field: ‘lazy’
[10:26:12.236]   - Field: ‘state’
[10:26:12.236] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.236] - Launch lazy future ...
[10:26:12.237] Packages needed by the future expression (n = 0): <none>
[10:26:12.237] Packages needed by future strategies (n = 0): <none>
[10:26:12.237] {
[10:26:12.237]     {
[10:26:12.237]         {
[10:26:12.237]             ...future.startTime <- base::Sys.time()
[10:26:12.237]             {
[10:26:12.237]                 {
[10:26:12.237]                   {
[10:26:12.237]                     {
[10:26:12.237]                       base::local({
[10:26:12.237]                         has_future <- base::requireNamespace("future", 
[10:26:12.237]                           quietly = TRUE)
[10:26:12.237]                         if (has_future) {
[10:26:12.237]                           ns <- base::getNamespace("future")
[10:26:12.237]                           version <- ns[[".package"]][["version"]]
[10:26:12.237]                           if (is.null(version)) 
[10:26:12.237]                             version <- utils::packageVersion("future")
[10:26:12.237]                         }
[10:26:12.237]                         else {
[10:26:12.237]                           version <- NULL
[10:26:12.237]                         }
[10:26:12.237]                         if (!has_future || version < "1.8.0") {
[10:26:12.237]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.237]                             "", base::R.version$version.string), 
[10:26:12.237]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:12.237]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:12.237]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.237]                               "release", "version")], collapse = " "), 
[10:26:12.237]                             hostname = base::Sys.info()[["nodename"]])
[10:26:12.237]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.237]                             info)
[10:26:12.237]                           info <- base::paste(info, collapse = "; ")
[10:26:12.237]                           if (!has_future) {
[10:26:12.237]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.237]                               info)
[10:26:12.237]                           }
[10:26:12.237]                           else {
[10:26:12.237]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.237]                               info, version)
[10:26:12.237]                           }
[10:26:12.237]                           base::stop(msg)
[10:26:12.237]                         }
[10:26:12.237]                       })
[10:26:12.237]                     }
[10:26:12.237]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.237]                     base::options(mc.cores = 1L)
[10:26:12.237]                   }
[10:26:12.237]                   options(future.plan = NULL)
[10:26:12.237]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.237]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.237]                 }
[10:26:12.237]                 ...future.workdir <- getwd()
[10:26:12.237]             }
[10:26:12.237]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.237]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.237]         }
[10:26:12.237]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.237]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:12.237]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.237]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.237]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.237]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.237]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.237]             base::names(...future.oldOptions))
[10:26:12.237]     }
[10:26:12.237]     if (FALSE) {
[10:26:12.237]     }
[10:26:12.237]     else {
[10:26:12.237]         if (TRUE) {
[10:26:12.237]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.237]                 open = "w")
[10:26:12.237]         }
[10:26:12.237]         else {
[10:26:12.237]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.237]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.237]         }
[10:26:12.237]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.237]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.237]             base::sink(type = "output", split = FALSE)
[10:26:12.237]             base::close(...future.stdout)
[10:26:12.237]         }, add = TRUE)
[10:26:12.237]     }
[10:26:12.237]     ...future.frame <- base::sys.nframe()
[10:26:12.237]     ...future.conditions <- base::list()
[10:26:12.237]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.237]     if (FALSE) {
[10:26:12.237]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.237]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.237]     }
[10:26:12.237]     ...future.result <- base::tryCatch({
[10:26:12.237]         base::withCallingHandlers({
[10:26:12.237]             ...future.value <- base::withVisible(base::local({
[10:26:12.237]                 withCallingHandlers({
[10:26:12.237]                   1
[10:26:12.237]                 }, immediateCondition = function(cond) {
[10:26:12.237]                   save_rds <- function (object, pathname, ...) 
[10:26:12.237]                   {
[10:26:12.237]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.237]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.237]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.237]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.237]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.237]                         fi_tmp[["mtime"]])
[10:26:12.237]                     }
[10:26:12.237]                     tryCatch({
[10:26:12.237]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.237]                     }, error = function(ex) {
[10:26:12.237]                       msg <- conditionMessage(ex)
[10:26:12.237]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.237]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.237]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.237]                         fi_tmp[["mtime"]], msg)
[10:26:12.237]                       ex$message <- msg
[10:26:12.237]                       stop(ex)
[10:26:12.237]                     })
[10:26:12.237]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.237]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.237]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.237]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.237]                       fi <- file.info(pathname)
[10:26:12.237]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.237]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.237]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.237]                         fi[["size"]], fi[["mtime"]])
[10:26:12.237]                       stop(msg)
[10:26:12.237]                     }
[10:26:12.237]                     invisible(pathname)
[10:26:12.237]                   }
[10:26:12.237]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.237]                     rootPath = tempdir()) 
[10:26:12.237]                   {
[10:26:12.237]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.237]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.237]                       tmpdir = path, fileext = ".rds")
[10:26:12.237]                     save_rds(obj, file)
[10:26:12.237]                   }
[10:26:12.237]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.237]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.237]                   {
[10:26:12.237]                     inherits <- base::inherits
[10:26:12.237]                     invokeRestart <- base::invokeRestart
[10:26:12.237]                     is.null <- base::is.null
[10:26:12.237]                     muffled <- FALSE
[10:26:12.237]                     if (inherits(cond, "message")) {
[10:26:12.237]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.237]                       if (muffled) 
[10:26:12.237]                         invokeRestart("muffleMessage")
[10:26:12.237]                     }
[10:26:12.237]                     else if (inherits(cond, "warning")) {
[10:26:12.237]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.237]                       if (muffled) 
[10:26:12.237]                         invokeRestart("muffleWarning")
[10:26:12.237]                     }
[10:26:12.237]                     else if (inherits(cond, "condition")) {
[10:26:12.237]                       if (!is.null(pattern)) {
[10:26:12.237]                         computeRestarts <- base::computeRestarts
[10:26:12.237]                         grepl <- base::grepl
[10:26:12.237]                         restarts <- computeRestarts(cond)
[10:26:12.237]                         for (restart in restarts) {
[10:26:12.237]                           name <- restart$name
[10:26:12.237]                           if (is.null(name)) 
[10:26:12.237]                             next
[10:26:12.237]                           if (!grepl(pattern, name)) 
[10:26:12.237]                             next
[10:26:12.237]                           invokeRestart(restart)
[10:26:12.237]                           muffled <- TRUE
[10:26:12.237]                           break
[10:26:12.237]                         }
[10:26:12.237]                       }
[10:26:12.237]                     }
[10:26:12.237]                     invisible(muffled)
[10:26:12.237]                   }
[10:26:12.237]                   muffleCondition(cond)
[10:26:12.237]                 })
[10:26:12.237]             }))
[10:26:12.237]             future::FutureResult(value = ...future.value$value, 
[10:26:12.237]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.237]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.237]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.237]                     ...future.globalenv.names))
[10:26:12.237]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.237]         }, condition = base::local({
[10:26:12.237]             c <- base::c
[10:26:12.237]             inherits <- base::inherits
[10:26:12.237]             invokeRestart <- base::invokeRestart
[10:26:12.237]             length <- base::length
[10:26:12.237]             list <- base::list
[10:26:12.237]             seq.int <- base::seq.int
[10:26:12.237]             signalCondition <- base::signalCondition
[10:26:12.237]             sys.calls <- base::sys.calls
[10:26:12.237]             `[[` <- base::`[[`
[10:26:12.237]             `+` <- base::`+`
[10:26:12.237]             `<<-` <- base::`<<-`
[10:26:12.237]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.237]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.237]                   3L)]
[10:26:12.237]             }
[10:26:12.237]             function(cond) {
[10:26:12.237]                 is_error <- inherits(cond, "error")
[10:26:12.237]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.237]                   NULL)
[10:26:12.237]                 if (is_error) {
[10:26:12.237]                   sessionInformation <- function() {
[10:26:12.237]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.237]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.237]                       search = base::search(), system = base::Sys.info())
[10:26:12.237]                   }
[10:26:12.237]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.237]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.237]                     cond$call), session = sessionInformation(), 
[10:26:12.237]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.237]                   signalCondition(cond)
[10:26:12.237]                 }
[10:26:12.237]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.237]                 "immediateCondition"))) {
[10:26:12.237]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.237]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.237]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.237]                   if (TRUE && !signal) {
[10:26:12.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.237]                     {
[10:26:12.237]                       inherits <- base::inherits
[10:26:12.237]                       invokeRestart <- base::invokeRestart
[10:26:12.237]                       is.null <- base::is.null
[10:26:12.237]                       muffled <- FALSE
[10:26:12.237]                       if (inherits(cond, "message")) {
[10:26:12.237]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.237]                         if (muffled) 
[10:26:12.237]                           invokeRestart("muffleMessage")
[10:26:12.237]                       }
[10:26:12.237]                       else if (inherits(cond, "warning")) {
[10:26:12.237]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.237]                         if (muffled) 
[10:26:12.237]                           invokeRestart("muffleWarning")
[10:26:12.237]                       }
[10:26:12.237]                       else if (inherits(cond, "condition")) {
[10:26:12.237]                         if (!is.null(pattern)) {
[10:26:12.237]                           computeRestarts <- base::computeRestarts
[10:26:12.237]                           grepl <- base::grepl
[10:26:12.237]                           restarts <- computeRestarts(cond)
[10:26:12.237]                           for (restart in restarts) {
[10:26:12.237]                             name <- restart$name
[10:26:12.237]                             if (is.null(name)) 
[10:26:12.237]                               next
[10:26:12.237]                             if (!grepl(pattern, name)) 
[10:26:12.237]                               next
[10:26:12.237]                             invokeRestart(restart)
[10:26:12.237]                             muffled <- TRUE
[10:26:12.237]                             break
[10:26:12.237]                           }
[10:26:12.237]                         }
[10:26:12.237]                       }
[10:26:12.237]                       invisible(muffled)
[10:26:12.237]                     }
[10:26:12.237]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.237]                   }
[10:26:12.237]                 }
[10:26:12.237]                 else {
[10:26:12.237]                   if (TRUE) {
[10:26:12.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.237]                     {
[10:26:12.237]                       inherits <- base::inherits
[10:26:12.237]                       invokeRestart <- base::invokeRestart
[10:26:12.237]                       is.null <- base::is.null
[10:26:12.237]                       muffled <- FALSE
[10:26:12.237]                       if (inherits(cond, "message")) {
[10:26:12.237]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.237]                         if (muffled) 
[10:26:12.237]                           invokeRestart("muffleMessage")
[10:26:12.237]                       }
[10:26:12.237]                       else if (inherits(cond, "warning")) {
[10:26:12.237]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.237]                         if (muffled) 
[10:26:12.237]                           invokeRestart("muffleWarning")
[10:26:12.237]                       }
[10:26:12.237]                       else if (inherits(cond, "condition")) {
[10:26:12.237]                         if (!is.null(pattern)) {
[10:26:12.237]                           computeRestarts <- base::computeRestarts
[10:26:12.237]                           grepl <- base::grepl
[10:26:12.237]                           restarts <- computeRestarts(cond)
[10:26:12.237]                           for (restart in restarts) {
[10:26:12.237]                             name <- restart$name
[10:26:12.237]                             if (is.null(name)) 
[10:26:12.237]                               next
[10:26:12.237]                             if (!grepl(pattern, name)) 
[10:26:12.237]                               next
[10:26:12.237]                             invokeRestart(restart)
[10:26:12.237]                             muffled <- TRUE
[10:26:12.237]                             break
[10:26:12.237]                           }
[10:26:12.237]                         }
[10:26:12.237]                       }
[10:26:12.237]                       invisible(muffled)
[10:26:12.237]                     }
[10:26:12.237]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.237]                   }
[10:26:12.237]                 }
[10:26:12.237]             }
[10:26:12.237]         }))
[10:26:12.237]     }, error = function(ex) {
[10:26:12.237]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.237]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.237]                 ...future.rng), started = ...future.startTime, 
[10:26:12.237]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.237]             version = "1.8"), class = "FutureResult")
[10:26:12.237]     }, finally = {
[10:26:12.237]         if (!identical(...future.workdir, getwd())) 
[10:26:12.237]             setwd(...future.workdir)
[10:26:12.237]         {
[10:26:12.237]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.237]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.237]             }
[10:26:12.237]             base::options(...future.oldOptions)
[10:26:12.237]             if (.Platform$OS.type == "windows") {
[10:26:12.237]                 old_names <- names(...future.oldEnvVars)
[10:26:12.237]                 envs <- base::Sys.getenv()
[10:26:12.237]                 names <- names(envs)
[10:26:12.237]                 common <- intersect(names, old_names)
[10:26:12.237]                 added <- setdiff(names, old_names)
[10:26:12.237]                 removed <- setdiff(old_names, names)
[10:26:12.237]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.237]                   envs[common]]
[10:26:12.237]                 NAMES <- toupper(changed)
[10:26:12.237]                 args <- list()
[10:26:12.237]                 for (kk in seq_along(NAMES)) {
[10:26:12.237]                   name <- changed[[kk]]
[10:26:12.237]                   NAME <- NAMES[[kk]]
[10:26:12.237]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.237]                     next
[10:26:12.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.237]                 }
[10:26:12.237]                 NAMES <- toupper(added)
[10:26:12.237]                 for (kk in seq_along(NAMES)) {
[10:26:12.237]                   name <- added[[kk]]
[10:26:12.237]                   NAME <- NAMES[[kk]]
[10:26:12.237]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.237]                     next
[10:26:12.237]                   args[[name]] <- ""
[10:26:12.237]                 }
[10:26:12.237]                 NAMES <- toupper(removed)
[10:26:12.237]                 for (kk in seq_along(NAMES)) {
[10:26:12.237]                   name <- removed[[kk]]
[10:26:12.237]                   NAME <- NAMES[[kk]]
[10:26:12.237]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.237]                     next
[10:26:12.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.237]                 }
[10:26:12.237]                 if (length(args) > 0) 
[10:26:12.237]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.237]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.237]             }
[10:26:12.237]             else {
[10:26:12.237]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.237]             }
[10:26:12.237]             {
[10:26:12.237]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.237]                   0L) {
[10:26:12.237]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.237]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.237]                   base::options(opts)
[10:26:12.237]                 }
[10:26:12.237]                 {
[10:26:12.237]                   {
[10:26:12.237]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.237]                     NULL
[10:26:12.237]                   }
[10:26:12.237]                   options(future.plan = NULL)
[10:26:12.237]                   if (is.na(NA_character_)) 
[10:26:12.237]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.237]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.237]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.237]                     envir = parent.frame()) 
[10:26:12.237]                   {
[10:26:12.237]                     default_workers <- missing(workers)
[10:26:12.237]                     if (is.function(workers)) 
[10:26:12.237]                       workers <- workers()
[10:26:12.237]                     workers <- structure(as.integer(workers), 
[10:26:12.237]                       class = class(workers))
[10:26:12.237]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.237]                       1L)
[10:26:12.237]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.237]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.237]                       if (default_workers) 
[10:26:12.237]                         supportsMulticore(warn = TRUE)
[10:26:12.237]                       return(sequential(..., envir = envir))
[10:26:12.237]                     }
[10:26:12.237]                     oopts <- options(mc.cores = workers)
[10:26:12.237]                     on.exit(options(oopts))
[10:26:12.237]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.237]                       envir = envir)
[10:26:12.237]                     if (!future$lazy) 
[10:26:12.237]                       future <- run(future)
[10:26:12.237]                     invisible(future)
[10:26:12.237]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.237]                 }
[10:26:12.237]             }
[10:26:12.237]         }
[10:26:12.237]     })
[10:26:12.237]     if (TRUE) {
[10:26:12.237]         base::sink(type = "output", split = FALSE)
[10:26:12.237]         if (TRUE) {
[10:26:12.237]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.237]         }
[10:26:12.237]         else {
[10:26:12.237]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.237]         }
[10:26:12.237]         base::close(...future.stdout)
[10:26:12.237]         ...future.stdout <- NULL
[10:26:12.237]     }
[10:26:12.237]     ...future.result$conditions <- ...future.conditions
[10:26:12.237]     ...future.result$finished <- base::Sys.time()
[10:26:12.237]     ...future.result
[10:26:12.237] }
[10:26:12.240] requestCore(): workers = 2
[10:26:12.241] MulticoreFuture started
[10:26:12.242] - Launch lazy future ... done
[10:26:12.242] run() for ‘MulticoreFuture’ ... done
[10:26:12.243] plan(): Setting new future strategy stack:
[10:26:12.243] List of future strategies:
[10:26:12.243] 1. sequential:
[10:26:12.243]    - args: function (..., envir = parent.frame())
[10:26:12.243]    - tweaked: FALSE
[10:26:12.243]    - call: NULL
[10:26:12.244] plan(): nbrOfWorkers() = 1
[10:26:12.246] plan(): Setting new future strategy stack:
[10:26:12.246] List of future strategies:
[10:26:12.246] 1. multicore:
[10:26:12.246]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.246]    - tweaked: FALSE
[10:26:12.246]    - call: plan(strategy)
[10:26:12.251] plan(): nbrOfWorkers() = 2
[10:26:12.252] Future #1
[10:26:12.252] result() for MulticoreFuture ...
[10:26:12.253] result() for MulticoreFuture ...
[10:26:12.253] result() for MulticoreFuture ... done
[10:26:12.253] result() for MulticoreFuture ... done
[10:26:12.253] result() for MulticoreFuture ...
[10:26:12.253] result() for MulticoreFuture ... done
[10:26:12.254] A MulticoreFuture was resolved
[10:26:12.254]  length: 0 (resolved future 1)
[10:26:12.254] resolve() on list ... DONE
[10:26:12.254] - globals: [1] ‘a’
[10:26:12.254] Resolving futures part of globals (recursively) ... DONE
[10:26:12.255] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[10:26:12.256] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[10:26:12.256] - globals: [1] ‘a’
[10:26:12.256] - packages: [1] ‘future’
[10:26:12.256] getGlobalsAndPackages() ... DONE
[10:26:12.257] run() for ‘Future’ ...
[10:26:12.257] - state: ‘created’
[10:26:12.257] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.261] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.261] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.262]   - Field: ‘label’
[10:26:12.262]   - Field: ‘local’
[10:26:12.262]   - Field: ‘owner’
[10:26:12.262]   - Field: ‘envir’
[10:26:12.262]   - Field: ‘workers’
[10:26:12.262]   - Field: ‘packages’
[10:26:12.262]   - Field: ‘gc’
[10:26:12.262]   - Field: ‘job’
[10:26:12.262]   - Field: ‘conditions’
[10:26:12.263]   - Field: ‘expr’
[10:26:12.263]   - Field: ‘uuid’
[10:26:12.263]   - Field: ‘seed’
[10:26:12.263]   - Field: ‘version’
[10:26:12.263]   - Field: ‘result’
[10:26:12.263]   - Field: ‘asynchronous’
[10:26:12.263]   - Field: ‘calls’
[10:26:12.263]   - Field: ‘globals’
[10:26:12.264]   - Field: ‘stdout’
[10:26:12.264]   - Field: ‘earlySignal’
[10:26:12.264]   - Field: ‘lazy’
[10:26:12.264]   - Field: ‘state’
[10:26:12.264] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.266] - Launch lazy future ...
[10:26:12.267] Packages needed by the future expression (n = 1): ‘future’
[10:26:12.267] Packages needed by future strategies (n = 0): <none>
[10:26:12.268] {
[10:26:12.268]     {
[10:26:12.268]         {
[10:26:12.268]             ...future.startTime <- base::Sys.time()
[10:26:12.268]             {
[10:26:12.268]                 {
[10:26:12.268]                   {
[10:26:12.268]                     {
[10:26:12.268]                       {
[10:26:12.268]                         base::local({
[10:26:12.268]                           has_future <- base::requireNamespace("future", 
[10:26:12.268]                             quietly = TRUE)
[10:26:12.268]                           if (has_future) {
[10:26:12.268]                             ns <- base::getNamespace("future")
[10:26:12.268]                             version <- ns[[".package"]][["version"]]
[10:26:12.268]                             if (is.null(version)) 
[10:26:12.268]                               version <- utils::packageVersion("future")
[10:26:12.268]                           }
[10:26:12.268]                           else {
[10:26:12.268]                             version <- NULL
[10:26:12.268]                           }
[10:26:12.268]                           if (!has_future || version < "1.8.0") {
[10:26:12.268]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.268]                               "", base::R.version$version.string), 
[10:26:12.268]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:12.268]                                 base::R.version$platform, 8 * 
[10:26:12.268]                                   base::.Machine$sizeof.pointer), 
[10:26:12.268]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.268]                                 "release", "version")], collapse = " "), 
[10:26:12.268]                               hostname = base::Sys.info()[["nodename"]])
[10:26:12.268]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.268]                               info)
[10:26:12.268]                             info <- base::paste(info, collapse = "; ")
[10:26:12.268]                             if (!has_future) {
[10:26:12.268]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.268]                                 info)
[10:26:12.268]                             }
[10:26:12.268]                             else {
[10:26:12.268]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.268]                                 info, version)
[10:26:12.268]                             }
[10:26:12.268]                             base::stop(msg)
[10:26:12.268]                           }
[10:26:12.268]                         })
[10:26:12.268]                       }
[10:26:12.268]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.268]                       base::options(mc.cores = 1L)
[10:26:12.268]                     }
[10:26:12.268]                     base::local({
[10:26:12.268]                       for (pkg in "future") {
[10:26:12.268]                         base::loadNamespace(pkg)
[10:26:12.268]                         base::library(pkg, character.only = TRUE)
[10:26:12.268]                       }
[10:26:12.268]                     })
[10:26:12.268]                   }
[10:26:12.268]                   options(future.plan = NULL)
[10:26:12.268]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.268]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.268]                 }
[10:26:12.268]                 ...future.workdir <- getwd()
[10:26:12.268]             }
[10:26:12.268]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.268]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.268]         }
[10:26:12.268]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.268]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:12.268]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.268]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.268]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.268]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.268]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.268]             base::names(...future.oldOptions))
[10:26:12.268]     }
[10:26:12.268]     if (FALSE) {
[10:26:12.268]     }
[10:26:12.268]     else {
[10:26:12.268]         if (TRUE) {
[10:26:12.268]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.268]                 open = "w")
[10:26:12.268]         }
[10:26:12.268]         else {
[10:26:12.268]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.268]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.268]         }
[10:26:12.268]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.268]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.268]             base::sink(type = "output", split = FALSE)
[10:26:12.268]             base::close(...future.stdout)
[10:26:12.268]         }, add = TRUE)
[10:26:12.268]     }
[10:26:12.268]     ...future.frame <- base::sys.nframe()
[10:26:12.268]     ...future.conditions <- base::list()
[10:26:12.268]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.268]     if (FALSE) {
[10:26:12.268]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.268]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.268]     }
[10:26:12.268]     ...future.result <- base::tryCatch({
[10:26:12.268]         base::withCallingHandlers({
[10:26:12.268]             ...future.value <- base::withVisible(base::local({
[10:26:12.268]                 withCallingHandlers({
[10:26:12.268]                   value(a) + 1
[10:26:12.268]                 }, immediateCondition = function(cond) {
[10:26:12.268]                   save_rds <- function (object, pathname, ...) 
[10:26:12.268]                   {
[10:26:12.268]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.268]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.268]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.268]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.268]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.268]                         fi_tmp[["mtime"]])
[10:26:12.268]                     }
[10:26:12.268]                     tryCatch({
[10:26:12.268]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.268]                     }, error = function(ex) {
[10:26:12.268]                       msg <- conditionMessage(ex)
[10:26:12.268]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.268]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.268]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.268]                         fi_tmp[["mtime"]], msg)
[10:26:12.268]                       ex$message <- msg
[10:26:12.268]                       stop(ex)
[10:26:12.268]                     })
[10:26:12.268]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.268]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.268]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.268]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.268]                       fi <- file.info(pathname)
[10:26:12.268]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.268]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.268]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.268]                         fi[["size"]], fi[["mtime"]])
[10:26:12.268]                       stop(msg)
[10:26:12.268]                     }
[10:26:12.268]                     invisible(pathname)
[10:26:12.268]                   }
[10:26:12.268]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.268]                     rootPath = tempdir()) 
[10:26:12.268]                   {
[10:26:12.268]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.268]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.268]                       tmpdir = path, fileext = ".rds")
[10:26:12.268]                     save_rds(obj, file)
[10:26:12.268]                   }
[10:26:12.268]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.268]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.268]                   {
[10:26:12.268]                     inherits <- base::inherits
[10:26:12.268]                     invokeRestart <- base::invokeRestart
[10:26:12.268]                     is.null <- base::is.null
[10:26:12.268]                     muffled <- FALSE
[10:26:12.268]                     if (inherits(cond, "message")) {
[10:26:12.268]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.268]                       if (muffled) 
[10:26:12.268]                         invokeRestart("muffleMessage")
[10:26:12.268]                     }
[10:26:12.268]                     else if (inherits(cond, "warning")) {
[10:26:12.268]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.268]                       if (muffled) 
[10:26:12.268]                         invokeRestart("muffleWarning")
[10:26:12.268]                     }
[10:26:12.268]                     else if (inherits(cond, "condition")) {
[10:26:12.268]                       if (!is.null(pattern)) {
[10:26:12.268]                         computeRestarts <- base::computeRestarts
[10:26:12.268]                         grepl <- base::grepl
[10:26:12.268]                         restarts <- computeRestarts(cond)
[10:26:12.268]                         for (restart in restarts) {
[10:26:12.268]                           name <- restart$name
[10:26:12.268]                           if (is.null(name)) 
[10:26:12.268]                             next
[10:26:12.268]                           if (!grepl(pattern, name)) 
[10:26:12.268]                             next
[10:26:12.268]                           invokeRestart(restart)
[10:26:12.268]                           muffled <- TRUE
[10:26:12.268]                           break
[10:26:12.268]                         }
[10:26:12.268]                       }
[10:26:12.268]                     }
[10:26:12.268]                     invisible(muffled)
[10:26:12.268]                   }
[10:26:12.268]                   muffleCondition(cond)
[10:26:12.268]                 })
[10:26:12.268]             }))
[10:26:12.268]             future::FutureResult(value = ...future.value$value, 
[10:26:12.268]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.268]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.268]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.268]                     ...future.globalenv.names))
[10:26:12.268]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.268]         }, condition = base::local({
[10:26:12.268]             c <- base::c
[10:26:12.268]             inherits <- base::inherits
[10:26:12.268]             invokeRestart <- base::invokeRestart
[10:26:12.268]             length <- base::length
[10:26:12.268]             list <- base::list
[10:26:12.268]             seq.int <- base::seq.int
[10:26:12.268]             signalCondition <- base::signalCondition
[10:26:12.268]             sys.calls <- base::sys.calls
[10:26:12.268]             `[[` <- base::`[[`
[10:26:12.268]             `+` <- base::`+`
[10:26:12.268]             `<<-` <- base::`<<-`
[10:26:12.268]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.268]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.268]                   3L)]
[10:26:12.268]             }
[10:26:12.268]             function(cond) {
[10:26:12.268]                 is_error <- inherits(cond, "error")
[10:26:12.268]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.268]                   NULL)
[10:26:12.268]                 if (is_error) {
[10:26:12.268]                   sessionInformation <- function() {
[10:26:12.268]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.268]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.268]                       search = base::search(), system = base::Sys.info())
[10:26:12.268]                   }
[10:26:12.268]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.268]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.268]                     cond$call), session = sessionInformation(), 
[10:26:12.268]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.268]                   signalCondition(cond)
[10:26:12.268]                 }
[10:26:12.268]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.268]                 "immediateCondition"))) {
[10:26:12.268]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.268]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.268]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.268]                   if (TRUE && !signal) {
[10:26:12.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.268]                     {
[10:26:12.268]                       inherits <- base::inherits
[10:26:12.268]                       invokeRestart <- base::invokeRestart
[10:26:12.268]                       is.null <- base::is.null
[10:26:12.268]                       muffled <- FALSE
[10:26:12.268]                       if (inherits(cond, "message")) {
[10:26:12.268]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.268]                         if (muffled) 
[10:26:12.268]                           invokeRestart("muffleMessage")
[10:26:12.268]                       }
[10:26:12.268]                       else if (inherits(cond, "warning")) {
[10:26:12.268]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.268]                         if (muffled) 
[10:26:12.268]                           invokeRestart("muffleWarning")
[10:26:12.268]                       }
[10:26:12.268]                       else if (inherits(cond, "condition")) {
[10:26:12.268]                         if (!is.null(pattern)) {
[10:26:12.268]                           computeRestarts <- base::computeRestarts
[10:26:12.268]                           grepl <- base::grepl
[10:26:12.268]                           restarts <- computeRestarts(cond)
[10:26:12.268]                           for (restart in restarts) {
[10:26:12.268]                             name <- restart$name
[10:26:12.268]                             if (is.null(name)) 
[10:26:12.268]                               next
[10:26:12.268]                             if (!grepl(pattern, name)) 
[10:26:12.268]                               next
[10:26:12.268]                             invokeRestart(restart)
[10:26:12.268]                             muffled <- TRUE
[10:26:12.268]                             break
[10:26:12.268]                           }
[10:26:12.268]                         }
[10:26:12.268]                       }
[10:26:12.268]                       invisible(muffled)
[10:26:12.268]                     }
[10:26:12.268]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.268]                   }
[10:26:12.268]                 }
[10:26:12.268]                 else {
[10:26:12.268]                   if (TRUE) {
[10:26:12.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.268]                     {
[10:26:12.268]                       inherits <- base::inherits
[10:26:12.268]                       invokeRestart <- base::invokeRestart
[10:26:12.268]                       is.null <- base::is.null
[10:26:12.268]                       muffled <- FALSE
[10:26:12.268]                       if (inherits(cond, "message")) {
[10:26:12.268]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.268]                         if (muffled) 
[10:26:12.268]                           invokeRestart("muffleMessage")
[10:26:12.268]                       }
[10:26:12.268]                       else if (inherits(cond, "warning")) {
[10:26:12.268]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.268]                         if (muffled) 
[10:26:12.268]                           invokeRestart("muffleWarning")
[10:26:12.268]                       }
[10:26:12.268]                       else if (inherits(cond, "condition")) {
[10:26:12.268]                         if (!is.null(pattern)) {
[10:26:12.268]                           computeRestarts <- base::computeRestarts
[10:26:12.268]                           grepl <- base::grepl
[10:26:12.268]                           restarts <- computeRestarts(cond)
[10:26:12.268]                           for (restart in restarts) {
[10:26:12.268]                             name <- restart$name
[10:26:12.268]                             if (is.null(name)) 
[10:26:12.268]                               next
[10:26:12.268]                             if (!grepl(pattern, name)) 
[10:26:12.268]                               next
[10:26:12.268]                             invokeRestart(restart)
[10:26:12.268]                             muffled <- TRUE
[10:26:12.268]                             break
[10:26:12.268]                           }
[10:26:12.268]                         }
[10:26:12.268]                       }
[10:26:12.268]                       invisible(muffled)
[10:26:12.268]                     }
[10:26:12.268]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.268]                   }
[10:26:12.268]                 }
[10:26:12.268]             }
[10:26:12.268]         }))
[10:26:12.268]     }, error = function(ex) {
[10:26:12.268]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.268]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.268]                 ...future.rng), started = ...future.startTime, 
[10:26:12.268]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.268]             version = "1.8"), class = "FutureResult")
[10:26:12.268]     }, finally = {
[10:26:12.268]         if (!identical(...future.workdir, getwd())) 
[10:26:12.268]             setwd(...future.workdir)
[10:26:12.268]         {
[10:26:12.268]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.268]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.268]             }
[10:26:12.268]             base::options(...future.oldOptions)
[10:26:12.268]             if (.Platform$OS.type == "windows") {
[10:26:12.268]                 old_names <- names(...future.oldEnvVars)
[10:26:12.268]                 envs <- base::Sys.getenv()
[10:26:12.268]                 names <- names(envs)
[10:26:12.268]                 common <- intersect(names, old_names)
[10:26:12.268]                 added <- setdiff(names, old_names)
[10:26:12.268]                 removed <- setdiff(old_names, names)
[10:26:12.268]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.268]                   envs[common]]
[10:26:12.268]                 NAMES <- toupper(changed)
[10:26:12.268]                 args <- list()
[10:26:12.268]                 for (kk in seq_along(NAMES)) {
[10:26:12.268]                   name <- changed[[kk]]
[10:26:12.268]                   NAME <- NAMES[[kk]]
[10:26:12.268]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.268]                     next
[10:26:12.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.268]                 }
[10:26:12.268]                 NAMES <- toupper(added)
[10:26:12.268]                 for (kk in seq_along(NAMES)) {
[10:26:12.268]                   name <- added[[kk]]
[10:26:12.268]                   NAME <- NAMES[[kk]]
[10:26:12.268]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.268]                     next
[10:26:12.268]                   args[[name]] <- ""
[10:26:12.268]                 }
[10:26:12.268]                 NAMES <- toupper(removed)
[10:26:12.268]                 for (kk in seq_along(NAMES)) {
[10:26:12.268]                   name <- removed[[kk]]
[10:26:12.268]                   NAME <- NAMES[[kk]]
[10:26:12.268]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.268]                     next
[10:26:12.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.268]                 }
[10:26:12.268]                 if (length(args) > 0) 
[10:26:12.268]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.268]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.268]             }
[10:26:12.268]             else {
[10:26:12.268]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.268]             }
[10:26:12.268]             {
[10:26:12.268]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.268]                   0L) {
[10:26:12.268]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.268]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.268]                   base::options(opts)
[10:26:12.268]                 }
[10:26:12.268]                 {
[10:26:12.268]                   {
[10:26:12.268]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.268]                     NULL
[10:26:12.268]                   }
[10:26:12.268]                   options(future.plan = NULL)
[10:26:12.268]                   if (is.na(NA_character_)) 
[10:26:12.268]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.268]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.268]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.268]                     envir = parent.frame()) 
[10:26:12.268]                   {
[10:26:12.268]                     default_workers <- missing(workers)
[10:26:12.268]                     if (is.function(workers)) 
[10:26:12.268]                       workers <- workers()
[10:26:12.268]                     workers <- structure(as.integer(workers), 
[10:26:12.268]                       class = class(workers))
[10:26:12.268]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.268]                       1L)
[10:26:12.268]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.268]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.268]                       if (default_workers) 
[10:26:12.268]                         supportsMulticore(warn = TRUE)
[10:26:12.268]                       return(sequential(..., envir = envir))
[10:26:12.268]                     }
[10:26:12.268]                     oopts <- options(mc.cores = workers)
[10:26:12.268]                     on.exit(options(oopts))
[10:26:12.268]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.268]                       envir = envir)
[10:26:12.268]                     if (!future$lazy) 
[10:26:12.268]                       future <- run(future)
[10:26:12.268]                     invisible(future)
[10:26:12.268]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.268]                 }
[10:26:12.268]             }
[10:26:12.268]         }
[10:26:12.268]     })
[10:26:12.268]     if (TRUE) {
[10:26:12.268]         base::sink(type = "output", split = FALSE)
[10:26:12.268]         if (TRUE) {
[10:26:12.268]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.268]         }
[10:26:12.268]         else {
[10:26:12.268]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.268]         }
[10:26:12.268]         base::close(...future.stdout)
[10:26:12.268]         ...future.stdout <- NULL
[10:26:12.268]     }
[10:26:12.268]     ...future.result$conditions <- ...future.conditions
[10:26:12.268]     ...future.result$finished <- base::Sys.time()
[10:26:12.268]     ...future.result
[10:26:12.268] }
[10:26:12.270] assign_globals() ...
[10:26:12.271] List of 1
[10:26:12.271]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a0226853e0> 
[10:26:12.271]  - attr(*, "where")=List of 1
[10:26:12.271]   ..$ a:<environment: R_EmptyEnv> 
[10:26:12.271]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:12.271]  - attr(*, "resolved")= logi TRUE
[10:26:12.271]  - attr(*, "total_size")= num 10984
[10:26:12.271]  - attr(*, "already-done")= logi TRUE
[10:26:12.274] - copied ‘a’ to environment
[10:26:12.274] assign_globals() ... done
[10:26:12.274] requestCore(): workers = 2
[10:26:12.276] MulticoreFuture started
[10:26:12.277] - Launch lazy future ... done
[10:26:12.277] run() for ‘MulticoreFuture’ ... done
[10:26:12.278] result() for MulticoreFuture ...
[10:26:12.278] plan(): Setting new future strategy stack:
[10:26:12.278] List of future strategies:
[10:26:12.278] 1. sequential:
[10:26:12.278]    - args: function (..., envir = parent.frame())
[10:26:12.278]    - tweaked: FALSE
[10:26:12.278]    - call: NULL
[10:26:12.279] plan(): nbrOfWorkers() = 1
[10:26:12.283] plan(): Setting new future strategy stack:
[10:26:12.283] List of future strategies:
[10:26:12.283] 1. multicore:
[10:26:12.283]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.283]    - tweaked: FALSE
[10:26:12.283]    - call: plan(strategy)
[10:26:12.288] plan(): nbrOfWorkers() = 2
[10:26:12.289] result() for MulticoreFuture ...
[10:26:12.289] result() for MulticoreFuture ... done
[10:26:12.289] signalConditions() ...
[10:26:12.289]  - include = ‘immediateCondition’
[10:26:12.289]  - exclude = 
[10:26:12.289]  - resignal = FALSE
[10:26:12.289]  - Number of conditions: 4
[10:26:12.290] signalConditions() ... done
[10:26:12.290] result() for MulticoreFuture ... done
[10:26:12.290] result() for MulticoreFuture ...
[10:26:12.290] result() for MulticoreFuture ... done
[10:26:12.290] signalConditions() ...
[10:26:12.290]  - include = ‘immediateCondition’
[10:26:12.290]  - exclude = 
[10:26:12.291]  - resignal = FALSE
[10:26:12.291]  - Number of conditions: 4
[10:26:12.291] signalConditions() ... done
[10:26:12.291] Future state: ‘finished’
[10:26:12.291] result() for MulticoreFuture ...
[10:26:12.291] result() for MulticoreFuture ... done
[10:26:12.291] signalConditions() ...
[10:26:12.291]  - include = ‘condition’
[10:26:12.292]  - exclude = ‘immediateCondition’
[10:26:12.292]  - resignal = TRUE
[10:26:12.292]  - Number of conditions: 4
[10:26:12.292]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.281] result() for MulticoreFuture ...
[10:26:12.292]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.281] result() for MulticoreFuture ... done
[10:26:12.292]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.281] result() for MulticoreFuture ...
[10:26:12.292]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.281] result() for MulticoreFuture ... done
[10:26:12.293] signalConditions() ... done
value(b) = 2
[10:26:12.293] result() for MulticoreFuture ...
[10:26:12.293] result() for MulticoreFuture ... done
[10:26:12.293] result() for MulticoreFuture ...
[10:26:12.293] result() for MulticoreFuture ... done
[10:26:12.293] signalConditions() ...
[10:26:12.293]  - include = ‘immediateCondition’
[10:26:12.293]  - exclude = 
[10:26:12.294]  - resignal = FALSE
[10:26:12.294]  - Number of conditions: 4
[10:26:12.294] signalConditions() ... done
[10:26:12.294] Future state: ‘finished’
[10:26:12.294] result() for MulticoreFuture ...
[10:26:12.294] result() for MulticoreFuture ... done
[10:26:12.294] signalConditions() ...
[10:26:12.294]  - include = ‘condition’
[10:26:12.294]  - exclude = ‘immediateCondition’
[10:26:12.295]  - resignal = TRUE
[10:26:12.295]  - Number of conditions: 4
[10:26:12.295]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.281] result() for MulticoreFuture ...
[10:26:12.295]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.281] result() for MulticoreFuture ... done
[10:26:12.295]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.281] result() for MulticoreFuture ...
[10:26:12.295]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.281] result() for MulticoreFuture ... done
[10:26:12.296] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.296] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.296] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:12.297] 
[10:26:12.297] Searching for globals ... DONE
[10:26:12.297] - globals: [0] <none>
[10:26:12.297] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.298] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.298] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:12.299] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:12.299] Searching for globals ... DONE
[10:26:12.299] Resolving globals: TRUE
[10:26:12.299] Resolving any globals that are futures ...
[10:26:12.299] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:12.300] Resolving any globals that are futures ... DONE
[10:26:12.300] Resolving futures part of globals (recursively) ...
[10:26:12.300] resolve() on list ...
[10:26:12.300]  recursive: 99
[10:26:12.301]  length: 1
[10:26:12.301]  elements: ‘a’
[10:26:12.301] run() for ‘Future’ ...
[10:26:12.301] - state: ‘created’
[10:26:12.301] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.305] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.305] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.305]   - Field: ‘label’
[10:26:12.305]   - Field: ‘local’
[10:26:12.306]   - Field: ‘owner’
[10:26:12.306]   - Field: ‘envir’
[10:26:12.306]   - Field: ‘workers’
[10:26:12.306]   - Field: ‘packages’
[10:26:12.306]   - Field: ‘gc’
[10:26:12.306]   - Field: ‘job’
[10:26:12.309]   - Field: ‘conditions’
[10:26:12.309]   - Field: ‘expr’
[10:26:12.309]   - Field: ‘uuid’
[10:26:12.309]   - Field: ‘seed’
[10:26:12.309]   - Field: ‘version’
[10:26:12.309]   - Field: ‘result’
[10:26:12.310]   - Field: ‘asynchronous’
[10:26:12.310]   - Field: ‘calls’
[10:26:12.310]   - Field: ‘globals’
[10:26:12.310]   - Field: ‘stdout’
[10:26:12.310]   - Field: ‘earlySignal’
[10:26:12.310]   - Field: ‘lazy’
[10:26:12.311]   - Field: ‘state’
[10:26:12.311] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.311] - Launch lazy future ...
[10:26:12.311] Packages needed by the future expression (n = 0): <none>
[10:26:12.311] Packages needed by future strategies (n = 0): <none>
[10:26:12.312] {
[10:26:12.312]     {
[10:26:12.312]         {
[10:26:12.312]             ...future.startTime <- base::Sys.time()
[10:26:12.312]             {
[10:26:12.312]                 {
[10:26:12.312]                   {
[10:26:12.312]                     {
[10:26:12.312]                       base::local({
[10:26:12.312]                         has_future <- base::requireNamespace("future", 
[10:26:12.312]                           quietly = TRUE)
[10:26:12.312]                         if (has_future) {
[10:26:12.312]                           ns <- base::getNamespace("future")
[10:26:12.312]                           version <- ns[[".package"]][["version"]]
[10:26:12.312]                           if (is.null(version)) 
[10:26:12.312]                             version <- utils::packageVersion("future")
[10:26:12.312]                         }
[10:26:12.312]                         else {
[10:26:12.312]                           version <- NULL
[10:26:12.312]                         }
[10:26:12.312]                         if (!has_future || version < "1.8.0") {
[10:26:12.312]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.312]                             "", base::R.version$version.string), 
[10:26:12.312]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:12.312]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:12.312]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.312]                               "release", "version")], collapse = " "), 
[10:26:12.312]                             hostname = base::Sys.info()[["nodename"]])
[10:26:12.312]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.312]                             info)
[10:26:12.312]                           info <- base::paste(info, collapse = "; ")
[10:26:12.312]                           if (!has_future) {
[10:26:12.312]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.312]                               info)
[10:26:12.312]                           }
[10:26:12.312]                           else {
[10:26:12.312]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.312]                               info, version)
[10:26:12.312]                           }
[10:26:12.312]                           base::stop(msg)
[10:26:12.312]                         }
[10:26:12.312]                       })
[10:26:12.312]                     }
[10:26:12.312]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.312]                     base::options(mc.cores = 1L)
[10:26:12.312]                   }
[10:26:12.312]                   options(future.plan = NULL)
[10:26:12.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.312]                 }
[10:26:12.312]                 ...future.workdir <- getwd()
[10:26:12.312]             }
[10:26:12.312]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.312]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.312]         }
[10:26:12.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.312]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:12.312]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.312]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.312]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.312]             base::names(...future.oldOptions))
[10:26:12.312]     }
[10:26:12.312]     if (FALSE) {
[10:26:12.312]     }
[10:26:12.312]     else {
[10:26:12.312]         if (TRUE) {
[10:26:12.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.312]                 open = "w")
[10:26:12.312]         }
[10:26:12.312]         else {
[10:26:12.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.312]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.312]         }
[10:26:12.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.312]             base::sink(type = "output", split = FALSE)
[10:26:12.312]             base::close(...future.stdout)
[10:26:12.312]         }, add = TRUE)
[10:26:12.312]     }
[10:26:12.312]     ...future.frame <- base::sys.nframe()
[10:26:12.312]     ...future.conditions <- base::list()
[10:26:12.312]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.312]     if (FALSE) {
[10:26:12.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.312]     }
[10:26:12.312]     ...future.result <- base::tryCatch({
[10:26:12.312]         base::withCallingHandlers({
[10:26:12.312]             ...future.value <- base::withVisible(base::local({
[10:26:12.312]                 withCallingHandlers({
[10:26:12.312]                   1
[10:26:12.312]                 }, immediateCondition = function(cond) {
[10:26:12.312]                   save_rds <- function (object, pathname, ...) 
[10:26:12.312]                   {
[10:26:12.312]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.312]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.312]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.312]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.312]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.312]                         fi_tmp[["mtime"]])
[10:26:12.312]                     }
[10:26:12.312]                     tryCatch({
[10:26:12.312]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.312]                     }, error = function(ex) {
[10:26:12.312]                       msg <- conditionMessage(ex)
[10:26:12.312]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.312]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.312]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.312]                         fi_tmp[["mtime"]], msg)
[10:26:12.312]                       ex$message <- msg
[10:26:12.312]                       stop(ex)
[10:26:12.312]                     })
[10:26:12.312]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.312]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.312]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.312]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.312]                       fi <- file.info(pathname)
[10:26:12.312]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.312]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.312]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.312]                         fi[["size"]], fi[["mtime"]])
[10:26:12.312]                       stop(msg)
[10:26:12.312]                     }
[10:26:12.312]                     invisible(pathname)
[10:26:12.312]                   }
[10:26:12.312]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.312]                     rootPath = tempdir()) 
[10:26:12.312]                   {
[10:26:12.312]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.312]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.312]                       tmpdir = path, fileext = ".rds")
[10:26:12.312]                     save_rds(obj, file)
[10:26:12.312]                   }
[10:26:12.312]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.312]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.312]                   {
[10:26:12.312]                     inherits <- base::inherits
[10:26:12.312]                     invokeRestart <- base::invokeRestart
[10:26:12.312]                     is.null <- base::is.null
[10:26:12.312]                     muffled <- FALSE
[10:26:12.312]                     if (inherits(cond, "message")) {
[10:26:12.312]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.312]                       if (muffled) 
[10:26:12.312]                         invokeRestart("muffleMessage")
[10:26:12.312]                     }
[10:26:12.312]                     else if (inherits(cond, "warning")) {
[10:26:12.312]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.312]                       if (muffled) 
[10:26:12.312]                         invokeRestart("muffleWarning")
[10:26:12.312]                     }
[10:26:12.312]                     else if (inherits(cond, "condition")) {
[10:26:12.312]                       if (!is.null(pattern)) {
[10:26:12.312]                         computeRestarts <- base::computeRestarts
[10:26:12.312]                         grepl <- base::grepl
[10:26:12.312]                         restarts <- computeRestarts(cond)
[10:26:12.312]                         for (restart in restarts) {
[10:26:12.312]                           name <- restart$name
[10:26:12.312]                           if (is.null(name)) 
[10:26:12.312]                             next
[10:26:12.312]                           if (!grepl(pattern, name)) 
[10:26:12.312]                             next
[10:26:12.312]                           invokeRestart(restart)
[10:26:12.312]                           muffled <- TRUE
[10:26:12.312]                           break
[10:26:12.312]                         }
[10:26:12.312]                       }
[10:26:12.312]                     }
[10:26:12.312]                     invisible(muffled)
[10:26:12.312]                   }
[10:26:12.312]                   muffleCondition(cond)
[10:26:12.312]                 })
[10:26:12.312]             }))
[10:26:12.312]             future::FutureResult(value = ...future.value$value, 
[10:26:12.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.312]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.312]                     ...future.globalenv.names))
[10:26:12.312]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.312]         }, condition = base::local({
[10:26:12.312]             c <- base::c
[10:26:12.312]             inherits <- base::inherits
[10:26:12.312]             invokeRestart <- base::invokeRestart
[10:26:12.312]             length <- base::length
[10:26:12.312]             list <- base::list
[10:26:12.312]             seq.int <- base::seq.int
[10:26:12.312]             signalCondition <- base::signalCondition
[10:26:12.312]             sys.calls <- base::sys.calls
[10:26:12.312]             `[[` <- base::`[[`
[10:26:12.312]             `+` <- base::`+`
[10:26:12.312]             `<<-` <- base::`<<-`
[10:26:12.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.312]                   3L)]
[10:26:12.312]             }
[10:26:12.312]             function(cond) {
[10:26:12.312]                 is_error <- inherits(cond, "error")
[10:26:12.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.312]                   NULL)
[10:26:12.312]                 if (is_error) {
[10:26:12.312]                   sessionInformation <- function() {
[10:26:12.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.312]                       search = base::search(), system = base::Sys.info())
[10:26:12.312]                   }
[10:26:12.312]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.312]                     cond$call), session = sessionInformation(), 
[10:26:12.312]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.312]                   signalCondition(cond)
[10:26:12.312]                 }
[10:26:12.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.312]                 "immediateCondition"))) {
[10:26:12.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.312]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.312]                   if (TRUE && !signal) {
[10:26:12.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.312]                     {
[10:26:12.312]                       inherits <- base::inherits
[10:26:12.312]                       invokeRestart <- base::invokeRestart
[10:26:12.312]                       is.null <- base::is.null
[10:26:12.312]                       muffled <- FALSE
[10:26:12.312]                       if (inherits(cond, "message")) {
[10:26:12.312]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.312]                         if (muffled) 
[10:26:12.312]                           invokeRestart("muffleMessage")
[10:26:12.312]                       }
[10:26:12.312]                       else if (inherits(cond, "warning")) {
[10:26:12.312]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.312]                         if (muffled) 
[10:26:12.312]                           invokeRestart("muffleWarning")
[10:26:12.312]                       }
[10:26:12.312]                       else if (inherits(cond, "condition")) {
[10:26:12.312]                         if (!is.null(pattern)) {
[10:26:12.312]                           computeRestarts <- base::computeRestarts
[10:26:12.312]                           grepl <- base::grepl
[10:26:12.312]                           restarts <- computeRestarts(cond)
[10:26:12.312]                           for (restart in restarts) {
[10:26:12.312]                             name <- restart$name
[10:26:12.312]                             if (is.null(name)) 
[10:26:12.312]                               next
[10:26:12.312]                             if (!grepl(pattern, name)) 
[10:26:12.312]                               next
[10:26:12.312]                             invokeRestart(restart)
[10:26:12.312]                             muffled <- TRUE
[10:26:12.312]                             break
[10:26:12.312]                           }
[10:26:12.312]                         }
[10:26:12.312]                       }
[10:26:12.312]                       invisible(muffled)
[10:26:12.312]                     }
[10:26:12.312]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.312]                   }
[10:26:12.312]                 }
[10:26:12.312]                 else {
[10:26:12.312]                   if (TRUE) {
[10:26:12.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.312]                     {
[10:26:12.312]                       inherits <- base::inherits
[10:26:12.312]                       invokeRestart <- base::invokeRestart
[10:26:12.312]                       is.null <- base::is.null
[10:26:12.312]                       muffled <- FALSE
[10:26:12.312]                       if (inherits(cond, "message")) {
[10:26:12.312]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.312]                         if (muffled) 
[10:26:12.312]                           invokeRestart("muffleMessage")
[10:26:12.312]                       }
[10:26:12.312]                       else if (inherits(cond, "warning")) {
[10:26:12.312]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.312]                         if (muffled) 
[10:26:12.312]                           invokeRestart("muffleWarning")
[10:26:12.312]                       }
[10:26:12.312]                       else if (inherits(cond, "condition")) {
[10:26:12.312]                         if (!is.null(pattern)) {
[10:26:12.312]                           computeRestarts <- base::computeRestarts
[10:26:12.312]                           grepl <- base::grepl
[10:26:12.312]                           restarts <- computeRestarts(cond)
[10:26:12.312]                           for (restart in restarts) {
[10:26:12.312]                             name <- restart$name
[10:26:12.312]                             if (is.null(name)) 
[10:26:12.312]                               next
[10:26:12.312]                             if (!grepl(pattern, name)) 
[10:26:12.312]                               next
[10:26:12.312]                             invokeRestart(restart)
[10:26:12.312]                             muffled <- TRUE
[10:26:12.312]                             break
[10:26:12.312]                           }
[10:26:12.312]                         }
[10:26:12.312]                       }
[10:26:12.312]                       invisible(muffled)
[10:26:12.312]                     }
[10:26:12.312]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.312]                   }
[10:26:12.312]                 }
[10:26:12.312]             }
[10:26:12.312]         }))
[10:26:12.312]     }, error = function(ex) {
[10:26:12.312]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.312]                 ...future.rng), started = ...future.startTime, 
[10:26:12.312]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.312]             version = "1.8"), class = "FutureResult")
[10:26:12.312]     }, finally = {
[10:26:12.312]         if (!identical(...future.workdir, getwd())) 
[10:26:12.312]             setwd(...future.workdir)
[10:26:12.312]         {
[10:26:12.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.312]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.312]             }
[10:26:12.312]             base::options(...future.oldOptions)
[10:26:12.312]             if (.Platform$OS.type == "windows") {
[10:26:12.312]                 old_names <- names(...future.oldEnvVars)
[10:26:12.312]                 envs <- base::Sys.getenv()
[10:26:12.312]                 names <- names(envs)
[10:26:12.312]                 common <- intersect(names, old_names)
[10:26:12.312]                 added <- setdiff(names, old_names)
[10:26:12.312]                 removed <- setdiff(old_names, names)
[10:26:12.312]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.312]                   envs[common]]
[10:26:12.312]                 NAMES <- toupper(changed)
[10:26:12.312]                 args <- list()
[10:26:12.312]                 for (kk in seq_along(NAMES)) {
[10:26:12.312]                   name <- changed[[kk]]
[10:26:12.312]                   NAME <- NAMES[[kk]]
[10:26:12.312]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.312]                     next
[10:26:12.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.312]                 }
[10:26:12.312]                 NAMES <- toupper(added)
[10:26:12.312]                 for (kk in seq_along(NAMES)) {
[10:26:12.312]                   name <- added[[kk]]
[10:26:12.312]                   NAME <- NAMES[[kk]]
[10:26:12.312]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.312]                     next
[10:26:12.312]                   args[[name]] <- ""
[10:26:12.312]                 }
[10:26:12.312]                 NAMES <- toupper(removed)
[10:26:12.312]                 for (kk in seq_along(NAMES)) {
[10:26:12.312]                   name <- removed[[kk]]
[10:26:12.312]                   NAME <- NAMES[[kk]]
[10:26:12.312]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.312]                     next
[10:26:12.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.312]                 }
[10:26:12.312]                 if (length(args) > 0) 
[10:26:12.312]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.312]             }
[10:26:12.312]             else {
[10:26:12.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.312]             }
[10:26:12.312]             {
[10:26:12.312]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.312]                   0L) {
[10:26:12.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.312]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.312]                   base::options(opts)
[10:26:12.312]                 }
[10:26:12.312]                 {
[10:26:12.312]                   {
[10:26:12.312]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.312]                     NULL
[10:26:12.312]                   }
[10:26:12.312]                   options(future.plan = NULL)
[10:26:12.312]                   if (is.na(NA_character_)) 
[10:26:12.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.312]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.312]                     envir = parent.frame()) 
[10:26:12.312]                   {
[10:26:12.312]                     default_workers <- missing(workers)
[10:26:12.312]                     if (is.function(workers)) 
[10:26:12.312]                       workers <- workers()
[10:26:12.312]                     workers <- structure(as.integer(workers), 
[10:26:12.312]                       class = class(workers))
[10:26:12.312]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.312]                       1L)
[10:26:12.312]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.312]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.312]                       if (default_workers) 
[10:26:12.312]                         supportsMulticore(warn = TRUE)
[10:26:12.312]                       return(sequential(..., envir = envir))
[10:26:12.312]                     }
[10:26:12.312]                     oopts <- options(mc.cores = workers)
[10:26:12.312]                     on.exit(options(oopts))
[10:26:12.312]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.312]                       envir = envir)
[10:26:12.312]                     if (!future$lazy) 
[10:26:12.312]                       future <- run(future)
[10:26:12.312]                     invisible(future)
[10:26:12.312]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.312]                 }
[10:26:12.312]             }
[10:26:12.312]         }
[10:26:12.312]     })
[10:26:12.312]     if (TRUE) {
[10:26:12.312]         base::sink(type = "output", split = FALSE)
[10:26:12.312]         if (TRUE) {
[10:26:12.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.312]         }
[10:26:12.312]         else {
[10:26:12.312]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.312]         }
[10:26:12.312]         base::close(...future.stdout)
[10:26:12.312]         ...future.stdout <- NULL
[10:26:12.312]     }
[10:26:12.312]     ...future.result$conditions <- ...future.conditions
[10:26:12.312]     ...future.result$finished <- base::Sys.time()
[10:26:12.312]     ...future.result
[10:26:12.312] }
[10:26:12.314] requestCore(): workers = 2
[10:26:12.316] MulticoreFuture started
[10:26:12.317] - Launch lazy future ... done
[10:26:12.317] run() for ‘MulticoreFuture’ ... done
[10:26:12.318] plan(): Setting new future strategy stack:
[10:26:12.318] List of future strategies:
[10:26:12.318] 1. sequential:
[10:26:12.318]    - args: function (..., envir = parent.frame())
[10:26:12.318]    - tweaked: FALSE
[10:26:12.318]    - call: NULL
[10:26:12.319] plan(): nbrOfWorkers() = 1
[10:26:12.321] plan(): Setting new future strategy stack:
[10:26:12.322] List of future strategies:
[10:26:12.322] 1. multicore:
[10:26:12.322]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.322]    - tweaked: FALSE
[10:26:12.322]    - call: plan(strategy)
[10:26:12.327] plan(): nbrOfWorkers() = 2
[10:26:12.327] Future #1
[10:26:12.328] result() for MulticoreFuture ...
[10:26:12.329] result() for MulticoreFuture ...
[10:26:12.329] result() for MulticoreFuture ... done
[10:26:12.329] result() for MulticoreFuture ... done
[10:26:12.329] result() for MulticoreFuture ...
[10:26:12.330] result() for MulticoreFuture ... done
[10:26:12.330] A MulticoreFuture was resolved
[10:26:12.330]  length: 0 (resolved future 1)
[10:26:12.330] resolve() on list ... DONE
[10:26:12.331] - globals: [1] ‘a’
[10:26:12.331] Resolving futures part of globals (recursively) ... DONE
[10:26:12.332] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[10:26:12.333] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[10:26:12.333] - globals: [1] ‘a’
[10:26:12.333] - packages: [1] ‘future’
[10:26:12.333] getGlobalsAndPackages() ... DONE
[10:26:12.334] run() for ‘Future’ ...
[10:26:12.334] - state: ‘created’
[10:26:12.334] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.339] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.339] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.339]   - Field: ‘label’
[10:26:12.339]   - Field: ‘local’
[10:26:12.339]   - Field: ‘owner’
[10:26:12.339]   - Field: ‘envir’
[10:26:12.340]   - Field: ‘workers’
[10:26:12.340]   - Field: ‘packages’
[10:26:12.340]   - Field: ‘gc’
[10:26:12.340]   - Field: ‘job’
[10:26:12.340]   - Field: ‘conditions’
[10:26:12.340]   - Field: ‘expr’
[10:26:12.340]   - Field: ‘uuid’
[10:26:12.340]   - Field: ‘seed’
[10:26:12.341]   - Field: ‘version’
[10:26:12.341]   - Field: ‘result’
[10:26:12.341]   - Field: ‘asynchronous’
[10:26:12.341]   - Field: ‘calls’
[10:26:12.341]   - Field: ‘globals’
[10:26:12.341]   - Field: ‘stdout’
[10:26:12.341]   - Field: ‘earlySignal’
[10:26:12.341]   - Field: ‘lazy’
[10:26:12.342]   - Field: ‘state’
[10:26:12.342] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.342] - Launch lazy future ...
[10:26:12.342] Packages needed by the future expression (n = 1): ‘future’
[10:26:12.342] Packages needed by future strategies (n = 0): <none>
[10:26:12.343] {
[10:26:12.343]     {
[10:26:12.343]         {
[10:26:12.343]             ...future.startTime <- base::Sys.time()
[10:26:12.343]             {
[10:26:12.343]                 {
[10:26:12.343]                   {
[10:26:12.343]                     {
[10:26:12.343]                       {
[10:26:12.343]                         base::local({
[10:26:12.343]                           has_future <- base::requireNamespace("future", 
[10:26:12.343]                             quietly = TRUE)
[10:26:12.343]                           if (has_future) {
[10:26:12.343]                             ns <- base::getNamespace("future")
[10:26:12.343]                             version <- ns[[".package"]][["version"]]
[10:26:12.343]                             if (is.null(version)) 
[10:26:12.343]                               version <- utils::packageVersion("future")
[10:26:12.343]                           }
[10:26:12.343]                           else {
[10:26:12.343]                             version <- NULL
[10:26:12.343]                           }
[10:26:12.343]                           if (!has_future || version < "1.8.0") {
[10:26:12.343]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.343]                               "", base::R.version$version.string), 
[10:26:12.343]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:12.343]                                 base::R.version$platform, 8 * 
[10:26:12.343]                                   base::.Machine$sizeof.pointer), 
[10:26:12.343]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.343]                                 "release", "version")], collapse = " "), 
[10:26:12.343]                               hostname = base::Sys.info()[["nodename"]])
[10:26:12.343]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.343]                               info)
[10:26:12.343]                             info <- base::paste(info, collapse = "; ")
[10:26:12.343]                             if (!has_future) {
[10:26:12.343]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.343]                                 info)
[10:26:12.343]                             }
[10:26:12.343]                             else {
[10:26:12.343]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.343]                                 info, version)
[10:26:12.343]                             }
[10:26:12.343]                             base::stop(msg)
[10:26:12.343]                           }
[10:26:12.343]                         })
[10:26:12.343]                       }
[10:26:12.343]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.343]                       base::options(mc.cores = 1L)
[10:26:12.343]                     }
[10:26:12.343]                     base::local({
[10:26:12.343]                       for (pkg in "future") {
[10:26:12.343]                         base::loadNamespace(pkg)
[10:26:12.343]                         base::library(pkg, character.only = TRUE)
[10:26:12.343]                       }
[10:26:12.343]                     })
[10:26:12.343]                   }
[10:26:12.343]                   options(future.plan = NULL)
[10:26:12.343]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.343]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.343]                 }
[10:26:12.343]                 ...future.workdir <- getwd()
[10:26:12.343]             }
[10:26:12.343]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.343]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.343]         }
[10:26:12.343]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.343]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:12.343]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.343]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.343]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.343]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.343]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.343]             base::names(...future.oldOptions))
[10:26:12.343]     }
[10:26:12.343]     if (FALSE) {
[10:26:12.343]     }
[10:26:12.343]     else {
[10:26:12.343]         if (TRUE) {
[10:26:12.343]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.343]                 open = "w")
[10:26:12.343]         }
[10:26:12.343]         else {
[10:26:12.343]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.343]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.343]         }
[10:26:12.343]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.343]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.343]             base::sink(type = "output", split = FALSE)
[10:26:12.343]             base::close(...future.stdout)
[10:26:12.343]         }, add = TRUE)
[10:26:12.343]     }
[10:26:12.343]     ...future.frame <- base::sys.nframe()
[10:26:12.343]     ...future.conditions <- base::list()
[10:26:12.343]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.343]     if (FALSE) {
[10:26:12.343]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.343]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.343]     }
[10:26:12.343]     ...future.result <- base::tryCatch({
[10:26:12.343]         base::withCallingHandlers({
[10:26:12.343]             ...future.value <- base::withVisible(base::local({
[10:26:12.343]                 withCallingHandlers({
[10:26:12.343]                   value(a) + 1
[10:26:12.343]                 }, immediateCondition = function(cond) {
[10:26:12.343]                   save_rds <- function (object, pathname, ...) 
[10:26:12.343]                   {
[10:26:12.343]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.343]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.343]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.343]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.343]                         fi_tmp[["mtime"]])
[10:26:12.343]                     }
[10:26:12.343]                     tryCatch({
[10:26:12.343]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.343]                     }, error = function(ex) {
[10:26:12.343]                       msg <- conditionMessage(ex)
[10:26:12.343]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.343]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.343]                         fi_tmp[["mtime"]], msg)
[10:26:12.343]                       ex$message <- msg
[10:26:12.343]                       stop(ex)
[10:26:12.343]                     })
[10:26:12.343]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.343]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.343]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.343]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.343]                       fi <- file.info(pathname)
[10:26:12.343]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.343]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.343]                         fi[["size"]], fi[["mtime"]])
[10:26:12.343]                       stop(msg)
[10:26:12.343]                     }
[10:26:12.343]                     invisible(pathname)
[10:26:12.343]                   }
[10:26:12.343]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.343]                     rootPath = tempdir()) 
[10:26:12.343]                   {
[10:26:12.343]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.343]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.343]                       tmpdir = path, fileext = ".rds")
[10:26:12.343]                     save_rds(obj, file)
[10:26:12.343]                   }
[10:26:12.343]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.343]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.343]                   {
[10:26:12.343]                     inherits <- base::inherits
[10:26:12.343]                     invokeRestart <- base::invokeRestart
[10:26:12.343]                     is.null <- base::is.null
[10:26:12.343]                     muffled <- FALSE
[10:26:12.343]                     if (inherits(cond, "message")) {
[10:26:12.343]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.343]                       if (muffled) 
[10:26:12.343]                         invokeRestart("muffleMessage")
[10:26:12.343]                     }
[10:26:12.343]                     else if (inherits(cond, "warning")) {
[10:26:12.343]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.343]                       if (muffled) 
[10:26:12.343]                         invokeRestart("muffleWarning")
[10:26:12.343]                     }
[10:26:12.343]                     else if (inherits(cond, "condition")) {
[10:26:12.343]                       if (!is.null(pattern)) {
[10:26:12.343]                         computeRestarts <- base::computeRestarts
[10:26:12.343]                         grepl <- base::grepl
[10:26:12.343]                         restarts <- computeRestarts(cond)
[10:26:12.343]                         for (restart in restarts) {
[10:26:12.343]                           name <- restart$name
[10:26:12.343]                           if (is.null(name)) 
[10:26:12.343]                             next
[10:26:12.343]                           if (!grepl(pattern, name)) 
[10:26:12.343]                             next
[10:26:12.343]                           invokeRestart(restart)
[10:26:12.343]                           muffled <- TRUE
[10:26:12.343]                           break
[10:26:12.343]                         }
[10:26:12.343]                       }
[10:26:12.343]                     }
[10:26:12.343]                     invisible(muffled)
[10:26:12.343]                   }
[10:26:12.343]                   muffleCondition(cond)
[10:26:12.343]                 })
[10:26:12.343]             }))
[10:26:12.343]             future::FutureResult(value = ...future.value$value, 
[10:26:12.343]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.343]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.343]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.343]                     ...future.globalenv.names))
[10:26:12.343]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.343]         }, condition = base::local({
[10:26:12.343]             c <- base::c
[10:26:12.343]             inherits <- base::inherits
[10:26:12.343]             invokeRestart <- base::invokeRestart
[10:26:12.343]             length <- base::length
[10:26:12.343]             list <- base::list
[10:26:12.343]             seq.int <- base::seq.int
[10:26:12.343]             signalCondition <- base::signalCondition
[10:26:12.343]             sys.calls <- base::sys.calls
[10:26:12.343]             `[[` <- base::`[[`
[10:26:12.343]             `+` <- base::`+`
[10:26:12.343]             `<<-` <- base::`<<-`
[10:26:12.343]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.343]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.343]                   3L)]
[10:26:12.343]             }
[10:26:12.343]             function(cond) {
[10:26:12.343]                 is_error <- inherits(cond, "error")
[10:26:12.343]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.343]                   NULL)
[10:26:12.343]                 if (is_error) {
[10:26:12.343]                   sessionInformation <- function() {
[10:26:12.343]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.343]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.343]                       search = base::search(), system = base::Sys.info())
[10:26:12.343]                   }
[10:26:12.343]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.343]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.343]                     cond$call), session = sessionInformation(), 
[10:26:12.343]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.343]                   signalCondition(cond)
[10:26:12.343]                 }
[10:26:12.343]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.343]                 "immediateCondition"))) {
[10:26:12.343]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.343]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.343]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.343]                   if (TRUE && !signal) {
[10:26:12.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.343]                     {
[10:26:12.343]                       inherits <- base::inherits
[10:26:12.343]                       invokeRestart <- base::invokeRestart
[10:26:12.343]                       is.null <- base::is.null
[10:26:12.343]                       muffled <- FALSE
[10:26:12.343]                       if (inherits(cond, "message")) {
[10:26:12.343]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.343]                         if (muffled) 
[10:26:12.343]                           invokeRestart("muffleMessage")
[10:26:12.343]                       }
[10:26:12.343]                       else if (inherits(cond, "warning")) {
[10:26:12.343]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.343]                         if (muffled) 
[10:26:12.343]                           invokeRestart("muffleWarning")
[10:26:12.343]                       }
[10:26:12.343]                       else if (inherits(cond, "condition")) {
[10:26:12.343]                         if (!is.null(pattern)) {
[10:26:12.343]                           computeRestarts <- base::computeRestarts
[10:26:12.343]                           grepl <- base::grepl
[10:26:12.343]                           restarts <- computeRestarts(cond)
[10:26:12.343]                           for (restart in restarts) {
[10:26:12.343]                             name <- restart$name
[10:26:12.343]                             if (is.null(name)) 
[10:26:12.343]                               next
[10:26:12.343]                             if (!grepl(pattern, name)) 
[10:26:12.343]                               next
[10:26:12.343]                             invokeRestart(restart)
[10:26:12.343]                             muffled <- TRUE
[10:26:12.343]                             break
[10:26:12.343]                           }
[10:26:12.343]                         }
[10:26:12.343]                       }
[10:26:12.343]                       invisible(muffled)
[10:26:12.343]                     }
[10:26:12.343]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.343]                   }
[10:26:12.343]                 }
[10:26:12.343]                 else {
[10:26:12.343]                   if (TRUE) {
[10:26:12.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.343]                     {
[10:26:12.343]                       inherits <- base::inherits
[10:26:12.343]                       invokeRestart <- base::invokeRestart
[10:26:12.343]                       is.null <- base::is.null
[10:26:12.343]                       muffled <- FALSE
[10:26:12.343]                       if (inherits(cond, "message")) {
[10:26:12.343]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.343]                         if (muffled) 
[10:26:12.343]                           invokeRestart("muffleMessage")
[10:26:12.343]                       }
[10:26:12.343]                       else if (inherits(cond, "warning")) {
[10:26:12.343]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.343]                         if (muffled) 
[10:26:12.343]                           invokeRestart("muffleWarning")
[10:26:12.343]                       }
[10:26:12.343]                       else if (inherits(cond, "condition")) {
[10:26:12.343]                         if (!is.null(pattern)) {
[10:26:12.343]                           computeRestarts <- base::computeRestarts
[10:26:12.343]                           grepl <- base::grepl
[10:26:12.343]                           restarts <- computeRestarts(cond)
[10:26:12.343]                           for (restart in restarts) {
[10:26:12.343]                             name <- restart$name
[10:26:12.343]                             if (is.null(name)) 
[10:26:12.343]                               next
[10:26:12.343]                             if (!grepl(pattern, name)) 
[10:26:12.343]                               next
[10:26:12.343]                             invokeRestart(restart)
[10:26:12.343]                             muffled <- TRUE
[10:26:12.343]                             break
[10:26:12.343]                           }
[10:26:12.343]                         }
[10:26:12.343]                       }
[10:26:12.343]                       invisible(muffled)
[10:26:12.343]                     }
[10:26:12.343]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.343]                   }
[10:26:12.343]                 }
[10:26:12.343]             }
[10:26:12.343]         }))
[10:26:12.343]     }, error = function(ex) {
[10:26:12.343]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.343]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.343]                 ...future.rng), started = ...future.startTime, 
[10:26:12.343]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.343]             version = "1.8"), class = "FutureResult")
[10:26:12.343]     }, finally = {
[10:26:12.343]         if (!identical(...future.workdir, getwd())) 
[10:26:12.343]             setwd(...future.workdir)
[10:26:12.343]         {
[10:26:12.343]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.343]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.343]             }
[10:26:12.343]             base::options(...future.oldOptions)
[10:26:12.343]             if (.Platform$OS.type == "windows") {
[10:26:12.343]                 old_names <- names(...future.oldEnvVars)
[10:26:12.343]                 envs <- base::Sys.getenv()
[10:26:12.343]                 names <- names(envs)
[10:26:12.343]                 common <- intersect(names, old_names)
[10:26:12.343]                 added <- setdiff(names, old_names)
[10:26:12.343]                 removed <- setdiff(old_names, names)
[10:26:12.343]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.343]                   envs[common]]
[10:26:12.343]                 NAMES <- toupper(changed)
[10:26:12.343]                 args <- list()
[10:26:12.343]                 for (kk in seq_along(NAMES)) {
[10:26:12.343]                   name <- changed[[kk]]
[10:26:12.343]                   NAME <- NAMES[[kk]]
[10:26:12.343]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.343]                     next
[10:26:12.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.343]                 }
[10:26:12.343]                 NAMES <- toupper(added)
[10:26:12.343]                 for (kk in seq_along(NAMES)) {
[10:26:12.343]                   name <- added[[kk]]
[10:26:12.343]                   NAME <- NAMES[[kk]]
[10:26:12.343]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.343]                     next
[10:26:12.343]                   args[[name]] <- ""
[10:26:12.343]                 }
[10:26:12.343]                 NAMES <- toupper(removed)
[10:26:12.343]                 for (kk in seq_along(NAMES)) {
[10:26:12.343]                   name <- removed[[kk]]
[10:26:12.343]                   NAME <- NAMES[[kk]]
[10:26:12.343]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.343]                     next
[10:26:12.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.343]                 }
[10:26:12.343]                 if (length(args) > 0) 
[10:26:12.343]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.343]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.343]             }
[10:26:12.343]             else {
[10:26:12.343]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.343]             }
[10:26:12.343]             {
[10:26:12.343]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.343]                   0L) {
[10:26:12.343]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.343]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.343]                   base::options(opts)
[10:26:12.343]                 }
[10:26:12.343]                 {
[10:26:12.343]                   {
[10:26:12.343]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.343]                     NULL
[10:26:12.343]                   }
[10:26:12.343]                   options(future.plan = NULL)
[10:26:12.343]                   if (is.na(NA_character_)) 
[10:26:12.343]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.343]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.343]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.343]                     envir = parent.frame()) 
[10:26:12.343]                   {
[10:26:12.343]                     default_workers <- missing(workers)
[10:26:12.343]                     if (is.function(workers)) 
[10:26:12.343]                       workers <- workers()
[10:26:12.343]                     workers <- structure(as.integer(workers), 
[10:26:12.343]                       class = class(workers))
[10:26:12.343]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.343]                       1L)
[10:26:12.343]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.343]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.343]                       if (default_workers) 
[10:26:12.343]                         supportsMulticore(warn = TRUE)
[10:26:12.343]                       return(sequential(..., envir = envir))
[10:26:12.343]                     }
[10:26:12.343]                     oopts <- options(mc.cores = workers)
[10:26:12.343]                     on.exit(options(oopts))
[10:26:12.343]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.343]                       envir = envir)
[10:26:12.343]                     if (!future$lazy) 
[10:26:12.343]                       future <- run(future)
[10:26:12.343]                     invisible(future)
[10:26:12.343]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.343]                 }
[10:26:12.343]             }
[10:26:12.343]         }
[10:26:12.343]     })
[10:26:12.343]     if (TRUE) {
[10:26:12.343]         base::sink(type = "output", split = FALSE)
[10:26:12.343]         if (TRUE) {
[10:26:12.343]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.343]         }
[10:26:12.343]         else {
[10:26:12.343]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.343]         }
[10:26:12.343]         base::close(...future.stdout)
[10:26:12.343]         ...future.stdout <- NULL
[10:26:12.343]     }
[10:26:12.343]     ...future.result$conditions <- ...future.conditions
[10:26:12.343]     ...future.result$finished <- base::Sys.time()
[10:26:12.343]     ...future.result
[10:26:12.343] }
[10:26:12.346] assign_globals() ...
[10:26:12.346] List of 1
[10:26:12.346]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a022000c78> 
[10:26:12.346]  - attr(*, "where")=List of 1
[10:26:12.346]   ..$ a:<environment: R_EmptyEnv> 
[10:26:12.346]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:12.346]  - attr(*, "resolved")= logi TRUE
[10:26:12.346]  - attr(*, "total_size")= num 10984
[10:26:12.346]  - attr(*, "already-done")= logi TRUE
[10:26:12.349] - copied ‘a’ to environment
[10:26:12.349] assign_globals() ... done
[10:26:12.349] requestCore(): workers = 2
[10:26:12.351] MulticoreFuture started
[10:26:12.351] - Launch lazy future ... done
[10:26:12.352] run() for ‘MulticoreFuture’ ... done
[10:26:12.352] result() for MulticoreFuture ...
[10:26:12.352] plan(): Setting new future strategy stack:
[10:26:12.353] List of future strategies:
[10:26:12.353] 1. sequential:
[10:26:12.353]    - args: function (..., envir = parent.frame())
[10:26:12.353]    - tweaked: FALSE
[10:26:12.353]    - call: NULL
[10:26:12.353] plan(): nbrOfWorkers() = 1
[10:26:12.357] plan(): Setting new future strategy stack:
[10:26:12.357] List of future strategies:
[10:26:12.357] 1. multicore:
[10:26:12.357]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.357]    - tweaked: FALSE
[10:26:12.357]    - call: plan(strategy)
[10:26:12.367] plan(): nbrOfWorkers() = 2
[10:26:12.369] result() for MulticoreFuture ...
[10:26:12.369] result() for MulticoreFuture ... done
[10:26:12.369] signalConditions() ...
[10:26:12.369]  - include = ‘immediateCondition’
[10:26:12.369]  - exclude = 
[10:26:12.369]  - resignal = FALSE
[10:26:12.370]  - Number of conditions: 4
[10:26:12.370] signalConditions() ... done
[10:26:12.370] result() for MulticoreFuture ... done
[10:26:12.370] result() for MulticoreFuture ...
[10:26:12.370] result() for MulticoreFuture ... done
[10:26:12.370] signalConditions() ...
[10:26:12.371]  - include = ‘immediateCondition’
[10:26:12.371]  - exclude = 
[10:26:12.371]  - resignal = FALSE
[10:26:12.371]  - Number of conditions: 4
[10:26:12.371] signalConditions() ... done
[10:26:12.374] Future state: ‘finished’
[10:26:12.374] result() for MulticoreFuture ...
[10:26:12.375] result() for MulticoreFuture ... done
[10:26:12.375] signalConditions() ...
[10:26:12.375]  - include = ‘condition’
[10:26:12.375]  - exclude = ‘immediateCondition’
[10:26:12.375]  - resignal = TRUE
[10:26:12.375]  - Number of conditions: 4
[10:26:12.376]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.355] result() for MulticoreFuture ...
[10:26:12.376]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.355] result() for MulticoreFuture ... done
[10:26:12.376]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.355] result() for MulticoreFuture ...
[10:26:12.376]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.356] result() for MulticoreFuture ... done
[10:26:12.377] signalConditions() ... done
value(b) = 2
[10:26:12.377] result() for MulticoreFuture ...
[10:26:12.377] result() for MulticoreFuture ... done
[10:26:12.378] result() for MulticoreFuture ...
[10:26:12.378] result() for MulticoreFuture ... done
[10:26:12.378] signalConditions() ...
[10:26:12.378]  - include = ‘immediateCondition’
[10:26:12.378]  - exclude = 
[10:26:12.378]  - resignal = FALSE
[10:26:12.378]  - Number of conditions: 4
[10:26:12.378] signalConditions() ... done
[10:26:12.378] Future state: ‘finished’
[10:26:12.379] result() for MulticoreFuture ...
[10:26:12.379] result() for MulticoreFuture ... done
[10:26:12.379] signalConditions() ...
[10:26:12.379]  - include = ‘condition’
[10:26:12.379]  - exclude = ‘immediateCondition’
[10:26:12.379]  - resignal = TRUE
[10:26:12.379]  - Number of conditions: 4
[10:26:12.379]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.355] result() for MulticoreFuture ...
[10:26:12.380]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.355] result() for MulticoreFuture ... done
[10:26:12.380]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.355] result() for MulticoreFuture ...
[10:26:12.380]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.356] result() for MulticoreFuture ... done
[10:26:12.380] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.380] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.381] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:12.382] - globals found: [2] ‘{’, ‘pkg’
[10:26:12.382] Searching for globals ... DONE
[10:26:12.382] Resolving globals: TRUE
[10:26:12.382] Resolving any globals that are futures ...
[10:26:12.382] - globals: [2] ‘{’, ‘pkg’
[10:26:12.383] Resolving any globals that are futures ... DONE
[10:26:12.383] Resolving futures part of globals (recursively) ...
[10:26:12.383] resolve() on list ...
[10:26:12.383]  recursive: 99
[10:26:12.383]  length: 1
[10:26:12.383]  elements: ‘pkg’
[10:26:12.384]  length: 0 (resolved future 1)
[10:26:12.384] resolve() on list ... DONE
[10:26:12.384] - globals: [1] ‘pkg’
[10:26:12.384] Resolving futures part of globals (recursively) ... DONE
[10:26:12.384] The total size of the 1 globals is 112 bytes (112 bytes)
[10:26:12.385] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[10:26:12.385] - globals: [1] ‘pkg’
[10:26:12.385] 
[10:26:12.385] getGlobalsAndPackages() ... DONE
[10:26:12.385] Packages needed by the future expression (n = 0): <none>
[10:26:12.385] Packages needed by future strategies (n = 0): <none>
[10:26:12.386] {
[10:26:12.386]     {
[10:26:12.386]         {
[10:26:12.386]             ...future.startTime <- base::Sys.time()
[10:26:12.386]             {
[10:26:12.386]                 {
[10:26:12.386]                   {
[10:26:12.386]                     base::local({
[10:26:12.386]                       has_future <- base::requireNamespace("future", 
[10:26:12.386]                         quietly = TRUE)
[10:26:12.386]                       if (has_future) {
[10:26:12.386]                         ns <- base::getNamespace("future")
[10:26:12.386]                         version <- ns[[".package"]][["version"]]
[10:26:12.386]                         if (is.null(version)) 
[10:26:12.386]                           version <- utils::packageVersion("future")
[10:26:12.386]                       }
[10:26:12.386]                       else {
[10:26:12.386]                         version <- NULL
[10:26:12.386]                       }
[10:26:12.386]                       if (!has_future || version < "1.8.0") {
[10:26:12.386]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.386]                           "", base::R.version$version.string), 
[10:26:12.386]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:12.386]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:12.386]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.386]                             "release", "version")], collapse = " "), 
[10:26:12.386]                           hostname = base::Sys.info()[["nodename"]])
[10:26:12.386]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.386]                           info)
[10:26:12.386]                         info <- base::paste(info, collapse = "; ")
[10:26:12.386]                         if (!has_future) {
[10:26:12.386]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.386]                             info)
[10:26:12.386]                         }
[10:26:12.386]                         else {
[10:26:12.386]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.386]                             info, version)
[10:26:12.386]                         }
[10:26:12.386]                         base::stop(msg)
[10:26:12.386]                       }
[10:26:12.386]                     })
[10:26:12.386]                   }
[10:26:12.386]                   options(future.plan = NULL)
[10:26:12.386]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.386]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.386]                 }
[10:26:12.386]                 ...future.workdir <- getwd()
[10:26:12.386]             }
[10:26:12.386]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.386]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.386]         }
[10:26:12.386]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.386]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:12.386]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.386]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.386]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.386]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.386]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.386]             base::names(...future.oldOptions))
[10:26:12.386]     }
[10:26:12.386]     if (FALSE) {
[10:26:12.386]     }
[10:26:12.386]     else {
[10:26:12.386]         if (TRUE) {
[10:26:12.386]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.386]                 open = "w")
[10:26:12.386]         }
[10:26:12.386]         else {
[10:26:12.386]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.386]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.386]         }
[10:26:12.386]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.386]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.386]             base::sink(type = "output", split = FALSE)
[10:26:12.386]             base::close(...future.stdout)
[10:26:12.386]         }, add = TRUE)
[10:26:12.386]     }
[10:26:12.386]     ...future.frame <- base::sys.nframe()
[10:26:12.386]     ...future.conditions <- base::list()
[10:26:12.386]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.386]     if (FALSE) {
[10:26:12.386]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.386]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.386]     }
[10:26:12.386]     ...future.result <- base::tryCatch({
[10:26:12.386]         base::withCallingHandlers({
[10:26:12.386]             ...future.value <- base::withVisible(base::local({
[10:26:12.386]                 pkg
[10:26:12.386]             }))
[10:26:12.386]             future::FutureResult(value = ...future.value$value, 
[10:26:12.386]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.386]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.386]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.386]                     ...future.globalenv.names))
[10:26:12.386]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.386]         }, condition = base::local({
[10:26:12.386]             c <- base::c
[10:26:12.386]             inherits <- base::inherits
[10:26:12.386]             invokeRestart <- base::invokeRestart
[10:26:12.386]             length <- base::length
[10:26:12.386]             list <- base::list
[10:26:12.386]             seq.int <- base::seq.int
[10:26:12.386]             signalCondition <- base::signalCondition
[10:26:12.386]             sys.calls <- base::sys.calls
[10:26:12.386]             `[[` <- base::`[[`
[10:26:12.386]             `+` <- base::`+`
[10:26:12.386]             `<<-` <- base::`<<-`
[10:26:12.386]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.386]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.386]                   3L)]
[10:26:12.386]             }
[10:26:12.386]             function(cond) {
[10:26:12.386]                 is_error <- inherits(cond, "error")
[10:26:12.386]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.386]                   NULL)
[10:26:12.386]                 if (is_error) {
[10:26:12.386]                   sessionInformation <- function() {
[10:26:12.386]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.386]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.386]                       search = base::search(), system = base::Sys.info())
[10:26:12.386]                   }
[10:26:12.386]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.386]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.386]                     cond$call), session = sessionInformation(), 
[10:26:12.386]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.386]                   signalCondition(cond)
[10:26:12.386]                 }
[10:26:12.386]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.386]                 "immediateCondition"))) {
[10:26:12.386]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.386]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.386]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.386]                   if (TRUE && !signal) {
[10:26:12.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.386]                     {
[10:26:12.386]                       inherits <- base::inherits
[10:26:12.386]                       invokeRestart <- base::invokeRestart
[10:26:12.386]                       is.null <- base::is.null
[10:26:12.386]                       muffled <- FALSE
[10:26:12.386]                       if (inherits(cond, "message")) {
[10:26:12.386]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.386]                         if (muffled) 
[10:26:12.386]                           invokeRestart("muffleMessage")
[10:26:12.386]                       }
[10:26:12.386]                       else if (inherits(cond, "warning")) {
[10:26:12.386]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.386]                         if (muffled) 
[10:26:12.386]                           invokeRestart("muffleWarning")
[10:26:12.386]                       }
[10:26:12.386]                       else if (inherits(cond, "condition")) {
[10:26:12.386]                         if (!is.null(pattern)) {
[10:26:12.386]                           computeRestarts <- base::computeRestarts
[10:26:12.386]                           grepl <- base::grepl
[10:26:12.386]                           restarts <- computeRestarts(cond)
[10:26:12.386]                           for (restart in restarts) {
[10:26:12.386]                             name <- restart$name
[10:26:12.386]                             if (is.null(name)) 
[10:26:12.386]                               next
[10:26:12.386]                             if (!grepl(pattern, name)) 
[10:26:12.386]                               next
[10:26:12.386]                             invokeRestart(restart)
[10:26:12.386]                             muffled <- TRUE
[10:26:12.386]                             break
[10:26:12.386]                           }
[10:26:12.386]                         }
[10:26:12.386]                       }
[10:26:12.386]                       invisible(muffled)
[10:26:12.386]                     }
[10:26:12.386]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.386]                   }
[10:26:12.386]                 }
[10:26:12.386]                 else {
[10:26:12.386]                   if (TRUE) {
[10:26:12.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.386]                     {
[10:26:12.386]                       inherits <- base::inherits
[10:26:12.386]                       invokeRestart <- base::invokeRestart
[10:26:12.386]                       is.null <- base::is.null
[10:26:12.386]                       muffled <- FALSE
[10:26:12.386]                       if (inherits(cond, "message")) {
[10:26:12.386]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.386]                         if (muffled) 
[10:26:12.386]                           invokeRestart("muffleMessage")
[10:26:12.386]                       }
[10:26:12.386]                       else if (inherits(cond, "warning")) {
[10:26:12.386]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.386]                         if (muffled) 
[10:26:12.386]                           invokeRestart("muffleWarning")
[10:26:12.386]                       }
[10:26:12.386]                       else if (inherits(cond, "condition")) {
[10:26:12.386]                         if (!is.null(pattern)) {
[10:26:12.386]                           computeRestarts <- base::computeRestarts
[10:26:12.386]                           grepl <- base::grepl
[10:26:12.386]                           restarts <- computeRestarts(cond)
[10:26:12.386]                           for (restart in restarts) {
[10:26:12.386]                             name <- restart$name
[10:26:12.386]                             if (is.null(name)) 
[10:26:12.386]                               next
[10:26:12.386]                             if (!grepl(pattern, name)) 
[10:26:12.386]                               next
[10:26:12.386]                             invokeRestart(restart)
[10:26:12.386]                             muffled <- TRUE
[10:26:12.386]                             break
[10:26:12.386]                           }
[10:26:12.386]                         }
[10:26:12.386]                       }
[10:26:12.386]                       invisible(muffled)
[10:26:12.386]                     }
[10:26:12.386]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.386]                   }
[10:26:12.386]                 }
[10:26:12.386]             }
[10:26:12.386]         }))
[10:26:12.386]     }, error = function(ex) {
[10:26:12.386]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.386]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.386]                 ...future.rng), started = ...future.startTime, 
[10:26:12.386]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.386]             version = "1.8"), class = "FutureResult")
[10:26:12.386]     }, finally = {
[10:26:12.386]         if (!identical(...future.workdir, getwd())) 
[10:26:12.386]             setwd(...future.workdir)
[10:26:12.386]         {
[10:26:12.386]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.386]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.386]             }
[10:26:12.386]             base::options(...future.oldOptions)
[10:26:12.386]             if (.Platform$OS.type == "windows") {
[10:26:12.386]                 old_names <- names(...future.oldEnvVars)
[10:26:12.386]                 envs <- base::Sys.getenv()
[10:26:12.386]                 names <- names(envs)
[10:26:12.386]                 common <- intersect(names, old_names)
[10:26:12.386]                 added <- setdiff(names, old_names)
[10:26:12.386]                 removed <- setdiff(old_names, names)
[10:26:12.386]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.386]                   envs[common]]
[10:26:12.386]                 NAMES <- toupper(changed)
[10:26:12.386]                 args <- list()
[10:26:12.386]                 for (kk in seq_along(NAMES)) {
[10:26:12.386]                   name <- changed[[kk]]
[10:26:12.386]                   NAME <- NAMES[[kk]]
[10:26:12.386]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.386]                     next
[10:26:12.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.386]                 }
[10:26:12.386]                 NAMES <- toupper(added)
[10:26:12.386]                 for (kk in seq_along(NAMES)) {
[10:26:12.386]                   name <- added[[kk]]
[10:26:12.386]                   NAME <- NAMES[[kk]]
[10:26:12.386]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.386]                     next
[10:26:12.386]                   args[[name]] <- ""
[10:26:12.386]                 }
[10:26:12.386]                 NAMES <- toupper(removed)
[10:26:12.386]                 for (kk in seq_along(NAMES)) {
[10:26:12.386]                   name <- removed[[kk]]
[10:26:12.386]                   NAME <- NAMES[[kk]]
[10:26:12.386]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.386]                     next
[10:26:12.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.386]                 }
[10:26:12.386]                 if (length(args) > 0) 
[10:26:12.386]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.386]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.386]             }
[10:26:12.386]             else {
[10:26:12.386]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.386]             }
[10:26:12.386]             {
[10:26:12.386]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.386]                   0L) {
[10:26:12.386]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.386]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.386]                   base::options(opts)
[10:26:12.386]                 }
[10:26:12.386]                 {
[10:26:12.386]                   {
[10:26:12.386]                     NULL
[10:26:12.386]                     RNGkind("Mersenne-Twister")
[10:26:12.386]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:12.386]                       inherits = FALSE)
[10:26:12.386]                   }
[10:26:12.386]                   options(future.plan = NULL)
[10:26:12.386]                   if (is.na(NA_character_)) 
[10:26:12.386]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.386]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.386]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.386]                     envir = parent.frame()) 
[10:26:12.386]                   {
[10:26:12.386]                     default_workers <- missing(workers)
[10:26:12.386]                     if (is.function(workers)) 
[10:26:12.386]                       workers <- workers()
[10:26:12.386]                     workers <- structure(as.integer(workers), 
[10:26:12.386]                       class = class(workers))
[10:26:12.386]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.386]                       1L)
[10:26:12.386]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.386]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.386]                       if (default_workers) 
[10:26:12.386]                         supportsMulticore(warn = TRUE)
[10:26:12.386]                       return(sequential(..., envir = envir))
[10:26:12.386]                     }
[10:26:12.386]                     oopts <- options(mc.cores = workers)
[10:26:12.386]                     on.exit(options(oopts))
[10:26:12.386]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.386]                       envir = envir)
[10:26:12.386]                     if (!future$lazy) 
[10:26:12.386]                       future <- run(future)
[10:26:12.386]                     invisible(future)
[10:26:12.386]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.386]                 }
[10:26:12.386]             }
[10:26:12.386]         }
[10:26:12.386]     })
[10:26:12.386]     if (TRUE) {
[10:26:12.386]         base::sink(type = "output", split = FALSE)
[10:26:12.386]         if (TRUE) {
[10:26:12.386]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.386]         }
[10:26:12.386]         else {
[10:26:12.386]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.386]         }
[10:26:12.386]         base::close(...future.stdout)
[10:26:12.386]         ...future.stdout <- NULL
[10:26:12.386]     }
[10:26:12.386]     ...future.result$conditions <- ...future.conditions
[10:26:12.386]     ...future.result$finished <- base::Sys.time()
[10:26:12.386]     ...future.result
[10:26:12.386] }
[10:26:12.388] assign_globals() ...
[10:26:12.388] List of 1
[10:26:12.388]  $ pkg: chr "foo"
[10:26:12.388]  - attr(*, "where")=List of 1
[10:26:12.388]   ..$ pkg:<environment: R_EmptyEnv> 
[10:26:12.388]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:12.388]  - attr(*, "resolved")= logi TRUE
[10:26:12.388]  - attr(*, "total_size")= num 112
[10:26:12.391] - copied ‘pkg’ to environment
[10:26:12.391] assign_globals() ... done
[10:26:12.391] plan(): Setting new future strategy stack:
[10:26:12.391] List of future strategies:
[10:26:12.391] 1. sequential:
[10:26:12.391]    - args: function (..., envir = parent.frame())
[10:26:12.391]    - tweaked: FALSE
[10:26:12.391]    - call: NULL
[10:26:12.391] plan(): nbrOfWorkers() = 1
[10:26:12.392] plan(): Setting new future strategy stack:
[10:26:12.392] List of future strategies:
[10:26:12.392] 1. multicore:
[10:26:12.392]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.392]    - tweaked: FALSE
[10:26:12.392]    - call: plan(strategy)
[10:26:12.396] plan(): nbrOfWorkers() = 2
[10:26:12.396] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.397] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.397] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:12.404] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:26:12.404] Searching for globals ... DONE
[10:26:12.404] Resolving globals: TRUE
[10:26:12.404] Resolving any globals that are futures ...
[10:26:12.404] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:26:12.404] Resolving any globals that are futures ... DONE
[10:26:12.405] Resolving futures part of globals (recursively) ...
[10:26:12.405] resolve() on list ...
[10:26:12.405]  recursive: 99
[10:26:12.405]  length: 1
[10:26:12.405]  elements: ‘a’
[10:26:12.405]  length: 0 (resolved future 1)
[10:26:12.405] resolve() on list ... DONE
[10:26:12.405] - globals: [1] ‘a’
[10:26:12.406] Resolving futures part of globals (recursively) ... DONE
[10:26:12.406] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:12.406] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:26:12.406] - globals: [1] ‘a’
[10:26:12.406] 
[10:26:12.406] getGlobalsAndPackages() ... DONE
[10:26:12.407] run() for ‘Future’ ...
[10:26:12.407] - state: ‘created’
[10:26:12.407] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.410] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.410] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.411]   - Field: ‘label’
[10:26:12.411]   - Field: ‘local’
[10:26:12.411]   - Field: ‘owner’
[10:26:12.411]   - Field: ‘envir’
[10:26:12.411]   - Field: ‘workers’
[10:26:12.411]   - Field: ‘packages’
[10:26:12.411]   - Field: ‘gc’
[10:26:12.411]   - Field: ‘job’
[10:26:12.411]   - Field: ‘conditions’
[10:26:12.411]   - Field: ‘expr’
[10:26:12.411]   - Field: ‘uuid’
[10:26:12.412]   - Field: ‘seed’
[10:26:12.412]   - Field: ‘version’
[10:26:12.412]   - Field: ‘result’
[10:26:12.412]   - Field: ‘asynchronous’
[10:26:12.412]   - Field: ‘calls’
[10:26:12.412]   - Field: ‘globals’
[10:26:12.412]   - Field: ‘stdout’
[10:26:12.412]   - Field: ‘earlySignal’
[10:26:12.412]   - Field: ‘lazy’
[10:26:12.412]   - Field: ‘state’
[10:26:12.413] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.413] - Launch lazy future ...
[10:26:12.413] Packages needed by the future expression (n = 0): <none>
[10:26:12.413] Packages needed by future strategies (n = 0): <none>
[10:26:12.413] {
[10:26:12.413]     {
[10:26:12.413]         {
[10:26:12.413]             ...future.startTime <- base::Sys.time()
[10:26:12.413]             {
[10:26:12.413]                 {
[10:26:12.413]                   {
[10:26:12.413]                     {
[10:26:12.413]                       base::local({
[10:26:12.413]                         has_future <- base::requireNamespace("future", 
[10:26:12.413]                           quietly = TRUE)
[10:26:12.413]                         if (has_future) {
[10:26:12.413]                           ns <- base::getNamespace("future")
[10:26:12.413]                           version <- ns[[".package"]][["version"]]
[10:26:12.413]                           if (is.null(version)) 
[10:26:12.413]                             version <- utils::packageVersion("future")
[10:26:12.413]                         }
[10:26:12.413]                         else {
[10:26:12.413]                           version <- NULL
[10:26:12.413]                         }
[10:26:12.413]                         if (!has_future || version < "1.8.0") {
[10:26:12.413]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.413]                             "", base::R.version$version.string), 
[10:26:12.413]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:12.413]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:12.413]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.413]                               "release", "version")], collapse = " "), 
[10:26:12.413]                             hostname = base::Sys.info()[["nodename"]])
[10:26:12.413]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.413]                             info)
[10:26:12.413]                           info <- base::paste(info, collapse = "; ")
[10:26:12.413]                           if (!has_future) {
[10:26:12.413]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.413]                               info)
[10:26:12.413]                           }
[10:26:12.413]                           else {
[10:26:12.413]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.413]                               info, version)
[10:26:12.413]                           }
[10:26:12.413]                           base::stop(msg)
[10:26:12.413]                         }
[10:26:12.413]                       })
[10:26:12.413]                     }
[10:26:12.413]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.413]                     base::options(mc.cores = 1L)
[10:26:12.413]                   }
[10:26:12.413]                   options(future.plan = NULL)
[10:26:12.413]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.413]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.413]                 }
[10:26:12.413]                 ...future.workdir <- getwd()
[10:26:12.413]             }
[10:26:12.413]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.413]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.413]         }
[10:26:12.413]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.413]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:12.413]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.413]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.413]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.413]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.413]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.413]             base::names(...future.oldOptions))
[10:26:12.413]     }
[10:26:12.413]     if (FALSE) {
[10:26:12.413]     }
[10:26:12.413]     else {
[10:26:12.413]         if (TRUE) {
[10:26:12.413]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.413]                 open = "w")
[10:26:12.413]         }
[10:26:12.413]         else {
[10:26:12.413]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.413]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.413]         }
[10:26:12.413]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.413]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.413]             base::sink(type = "output", split = FALSE)
[10:26:12.413]             base::close(...future.stdout)
[10:26:12.413]         }, add = TRUE)
[10:26:12.413]     }
[10:26:12.413]     ...future.frame <- base::sys.nframe()
[10:26:12.413]     ...future.conditions <- base::list()
[10:26:12.413]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.413]     if (FALSE) {
[10:26:12.413]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.413]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.413]     }
[10:26:12.413]     ...future.result <- base::tryCatch({
[10:26:12.413]         base::withCallingHandlers({
[10:26:12.413]             ...future.value <- base::withVisible(base::local({
[10:26:12.413]                 withCallingHandlers({
[10:26:12.413]                   {
[10:26:12.413]                     b <- a
[10:26:12.413]                     a <- 2
[10:26:12.413]                     a * b
[10:26:12.413]                   }
[10:26:12.413]                 }, immediateCondition = function(cond) {
[10:26:12.413]                   save_rds <- function (object, pathname, ...) 
[10:26:12.413]                   {
[10:26:12.413]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.413]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.413]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.413]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.413]                         fi_tmp[["mtime"]])
[10:26:12.413]                     }
[10:26:12.413]                     tryCatch({
[10:26:12.413]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.413]                     }, error = function(ex) {
[10:26:12.413]                       msg <- conditionMessage(ex)
[10:26:12.413]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.413]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.413]                         fi_tmp[["mtime"]], msg)
[10:26:12.413]                       ex$message <- msg
[10:26:12.413]                       stop(ex)
[10:26:12.413]                     })
[10:26:12.413]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.413]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.413]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.413]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.413]                       fi <- file.info(pathname)
[10:26:12.413]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.413]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.413]                         fi[["size"]], fi[["mtime"]])
[10:26:12.413]                       stop(msg)
[10:26:12.413]                     }
[10:26:12.413]                     invisible(pathname)
[10:26:12.413]                   }
[10:26:12.413]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.413]                     rootPath = tempdir()) 
[10:26:12.413]                   {
[10:26:12.413]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.413]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.413]                       tmpdir = path, fileext = ".rds")
[10:26:12.413]                     save_rds(obj, file)
[10:26:12.413]                   }
[10:26:12.413]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.413]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.413]                   {
[10:26:12.413]                     inherits <- base::inherits
[10:26:12.413]                     invokeRestart <- base::invokeRestart
[10:26:12.413]                     is.null <- base::is.null
[10:26:12.413]                     muffled <- FALSE
[10:26:12.413]                     if (inherits(cond, "message")) {
[10:26:12.413]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.413]                       if (muffled) 
[10:26:12.413]                         invokeRestart("muffleMessage")
[10:26:12.413]                     }
[10:26:12.413]                     else if (inherits(cond, "warning")) {
[10:26:12.413]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.413]                       if (muffled) 
[10:26:12.413]                         invokeRestart("muffleWarning")
[10:26:12.413]                     }
[10:26:12.413]                     else if (inherits(cond, "condition")) {
[10:26:12.413]                       if (!is.null(pattern)) {
[10:26:12.413]                         computeRestarts <- base::computeRestarts
[10:26:12.413]                         grepl <- base::grepl
[10:26:12.413]                         restarts <- computeRestarts(cond)
[10:26:12.413]                         for (restart in restarts) {
[10:26:12.413]                           name <- restart$name
[10:26:12.413]                           if (is.null(name)) 
[10:26:12.413]                             next
[10:26:12.413]                           if (!grepl(pattern, name)) 
[10:26:12.413]                             next
[10:26:12.413]                           invokeRestart(restart)
[10:26:12.413]                           muffled <- TRUE
[10:26:12.413]                           break
[10:26:12.413]                         }
[10:26:12.413]                       }
[10:26:12.413]                     }
[10:26:12.413]                     invisible(muffled)
[10:26:12.413]                   }
[10:26:12.413]                   muffleCondition(cond)
[10:26:12.413]                 })
[10:26:12.413]             }))
[10:26:12.413]             future::FutureResult(value = ...future.value$value, 
[10:26:12.413]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.413]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.413]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.413]                     ...future.globalenv.names))
[10:26:12.413]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.413]         }, condition = base::local({
[10:26:12.413]             c <- base::c
[10:26:12.413]             inherits <- base::inherits
[10:26:12.413]             invokeRestart <- base::invokeRestart
[10:26:12.413]             length <- base::length
[10:26:12.413]             list <- base::list
[10:26:12.413]             seq.int <- base::seq.int
[10:26:12.413]             signalCondition <- base::signalCondition
[10:26:12.413]             sys.calls <- base::sys.calls
[10:26:12.413]             `[[` <- base::`[[`
[10:26:12.413]             `+` <- base::`+`
[10:26:12.413]             `<<-` <- base::`<<-`
[10:26:12.413]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.413]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.413]                   3L)]
[10:26:12.413]             }
[10:26:12.413]             function(cond) {
[10:26:12.413]                 is_error <- inherits(cond, "error")
[10:26:12.413]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.413]                   NULL)
[10:26:12.413]                 if (is_error) {
[10:26:12.413]                   sessionInformation <- function() {
[10:26:12.413]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.413]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.413]                       search = base::search(), system = base::Sys.info())
[10:26:12.413]                   }
[10:26:12.413]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.413]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.413]                     cond$call), session = sessionInformation(), 
[10:26:12.413]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.413]                   signalCondition(cond)
[10:26:12.413]                 }
[10:26:12.413]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.413]                 "immediateCondition"))) {
[10:26:12.413]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.413]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.413]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.413]                   if (TRUE && !signal) {
[10:26:12.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.413]                     {
[10:26:12.413]                       inherits <- base::inherits
[10:26:12.413]                       invokeRestart <- base::invokeRestart
[10:26:12.413]                       is.null <- base::is.null
[10:26:12.413]                       muffled <- FALSE
[10:26:12.413]                       if (inherits(cond, "message")) {
[10:26:12.413]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.413]                         if (muffled) 
[10:26:12.413]                           invokeRestart("muffleMessage")
[10:26:12.413]                       }
[10:26:12.413]                       else if (inherits(cond, "warning")) {
[10:26:12.413]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.413]                         if (muffled) 
[10:26:12.413]                           invokeRestart("muffleWarning")
[10:26:12.413]                       }
[10:26:12.413]                       else if (inherits(cond, "condition")) {
[10:26:12.413]                         if (!is.null(pattern)) {
[10:26:12.413]                           computeRestarts <- base::computeRestarts
[10:26:12.413]                           grepl <- base::grepl
[10:26:12.413]                           restarts <- computeRestarts(cond)
[10:26:12.413]                           for (restart in restarts) {
[10:26:12.413]                             name <- restart$name
[10:26:12.413]                             if (is.null(name)) 
[10:26:12.413]                               next
[10:26:12.413]                             if (!grepl(pattern, name)) 
[10:26:12.413]                               next
[10:26:12.413]                             invokeRestart(restart)
[10:26:12.413]                             muffled <- TRUE
[10:26:12.413]                             break
[10:26:12.413]                           }
[10:26:12.413]                         }
[10:26:12.413]                       }
[10:26:12.413]                       invisible(muffled)
[10:26:12.413]                     }
[10:26:12.413]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.413]                   }
[10:26:12.413]                 }
[10:26:12.413]                 else {
[10:26:12.413]                   if (TRUE) {
[10:26:12.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.413]                     {
[10:26:12.413]                       inherits <- base::inherits
[10:26:12.413]                       invokeRestart <- base::invokeRestart
[10:26:12.413]                       is.null <- base::is.null
[10:26:12.413]                       muffled <- FALSE
[10:26:12.413]                       if (inherits(cond, "message")) {
[10:26:12.413]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.413]                         if (muffled) 
[10:26:12.413]                           invokeRestart("muffleMessage")
[10:26:12.413]                       }
[10:26:12.413]                       else if (inherits(cond, "warning")) {
[10:26:12.413]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.413]                         if (muffled) 
[10:26:12.413]                           invokeRestart("muffleWarning")
[10:26:12.413]                       }
[10:26:12.413]                       else if (inherits(cond, "condition")) {
[10:26:12.413]                         if (!is.null(pattern)) {
[10:26:12.413]                           computeRestarts <- base::computeRestarts
[10:26:12.413]                           grepl <- base::grepl
[10:26:12.413]                           restarts <- computeRestarts(cond)
[10:26:12.413]                           for (restart in restarts) {
[10:26:12.413]                             name <- restart$name
[10:26:12.413]                             if (is.null(name)) 
[10:26:12.413]                               next
[10:26:12.413]                             if (!grepl(pattern, name)) 
[10:26:12.413]                               next
[10:26:12.413]                             invokeRestart(restart)
[10:26:12.413]                             muffled <- TRUE
[10:26:12.413]                             break
[10:26:12.413]                           }
[10:26:12.413]                         }
[10:26:12.413]                       }
[10:26:12.413]                       invisible(muffled)
[10:26:12.413]                     }
[10:26:12.413]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.413]                   }
[10:26:12.413]                 }
[10:26:12.413]             }
[10:26:12.413]         }))
[10:26:12.413]     }, error = function(ex) {
[10:26:12.413]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.413]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.413]                 ...future.rng), started = ...future.startTime, 
[10:26:12.413]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.413]             version = "1.8"), class = "FutureResult")
[10:26:12.413]     }, finally = {
[10:26:12.413]         if (!identical(...future.workdir, getwd())) 
[10:26:12.413]             setwd(...future.workdir)
[10:26:12.413]         {
[10:26:12.413]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.413]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.413]             }
[10:26:12.413]             base::options(...future.oldOptions)
[10:26:12.413]             if (.Platform$OS.type == "windows") {
[10:26:12.413]                 old_names <- names(...future.oldEnvVars)
[10:26:12.413]                 envs <- base::Sys.getenv()
[10:26:12.413]                 names <- names(envs)
[10:26:12.413]                 common <- intersect(names, old_names)
[10:26:12.413]                 added <- setdiff(names, old_names)
[10:26:12.413]                 removed <- setdiff(old_names, names)
[10:26:12.413]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.413]                   envs[common]]
[10:26:12.413]                 NAMES <- toupper(changed)
[10:26:12.413]                 args <- list()
[10:26:12.413]                 for (kk in seq_along(NAMES)) {
[10:26:12.413]                   name <- changed[[kk]]
[10:26:12.413]                   NAME <- NAMES[[kk]]
[10:26:12.413]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.413]                     next
[10:26:12.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.413]                 }
[10:26:12.413]                 NAMES <- toupper(added)
[10:26:12.413]                 for (kk in seq_along(NAMES)) {
[10:26:12.413]                   name <- added[[kk]]
[10:26:12.413]                   NAME <- NAMES[[kk]]
[10:26:12.413]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.413]                     next
[10:26:12.413]                   args[[name]] <- ""
[10:26:12.413]                 }
[10:26:12.413]                 NAMES <- toupper(removed)
[10:26:12.413]                 for (kk in seq_along(NAMES)) {
[10:26:12.413]                   name <- removed[[kk]]
[10:26:12.413]                   NAME <- NAMES[[kk]]
[10:26:12.413]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.413]                     next
[10:26:12.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.413]                 }
[10:26:12.413]                 if (length(args) > 0) 
[10:26:12.413]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.413]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.413]             }
[10:26:12.413]             else {
[10:26:12.413]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.413]             }
[10:26:12.413]             {
[10:26:12.413]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.413]                   0L) {
[10:26:12.413]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.413]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.413]                   base::options(opts)
[10:26:12.413]                 }
[10:26:12.413]                 {
[10:26:12.413]                   {
[10:26:12.413]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.413]                     NULL
[10:26:12.413]                   }
[10:26:12.413]                   options(future.plan = NULL)
[10:26:12.413]                   if (is.na(NA_character_)) 
[10:26:12.413]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.413]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.413]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.413]                     envir = parent.frame()) 
[10:26:12.413]                   {
[10:26:12.413]                     default_workers <- missing(workers)
[10:26:12.413]                     if (is.function(workers)) 
[10:26:12.413]                       workers <- workers()
[10:26:12.413]                     workers <- structure(as.integer(workers), 
[10:26:12.413]                       class = class(workers))
[10:26:12.413]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.413]                       1L)
[10:26:12.413]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.413]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.413]                       if (default_workers) 
[10:26:12.413]                         supportsMulticore(warn = TRUE)
[10:26:12.413]                       return(sequential(..., envir = envir))
[10:26:12.413]                     }
[10:26:12.413]                     oopts <- options(mc.cores = workers)
[10:26:12.413]                     on.exit(options(oopts))
[10:26:12.413]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.413]                       envir = envir)
[10:26:12.413]                     if (!future$lazy) 
[10:26:12.413]                       future <- run(future)
[10:26:12.413]                     invisible(future)
[10:26:12.413]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.413]                 }
[10:26:12.413]             }
[10:26:12.413]         }
[10:26:12.413]     })
[10:26:12.413]     if (TRUE) {
[10:26:12.413]         base::sink(type = "output", split = FALSE)
[10:26:12.413]         if (TRUE) {
[10:26:12.413]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.413]         }
[10:26:12.413]         else {
[10:26:12.413]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.413]         }
[10:26:12.413]         base::close(...future.stdout)
[10:26:12.413]         ...future.stdout <- NULL
[10:26:12.413]     }
[10:26:12.413]     ...future.result$conditions <- ...future.conditions
[10:26:12.413]     ...future.result$finished <- base::Sys.time()
[10:26:12.413]     ...future.result
[10:26:12.413] }
[10:26:12.416] assign_globals() ...
[10:26:12.416] List of 1
[10:26:12.416]  $ a: num 3
[10:26:12.416]  - attr(*, "where")=List of 1
[10:26:12.416]   ..$ a:<environment: R_EmptyEnv> 
[10:26:12.416]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:12.416]  - attr(*, "resolved")= logi TRUE
[10:26:12.416]  - attr(*, "total_size")= num 56
[10:26:12.416]  - attr(*, "already-done")= logi TRUE
[10:26:12.418] - copied ‘a’ to environment
[10:26:12.418] assign_globals() ... done
[10:26:12.418] requestCore(): workers = 2
[10:26:12.420] MulticoreFuture started
[10:26:12.421] - Launch lazy future ... done
[10:26:12.421] run() for ‘MulticoreFuture’ ... done
[10:26:12.422] result() for MulticoreFuture ...
[10:26:12.422] plan(): Setting new future strategy stack:
[10:26:12.422] List of future strategies:
[10:26:12.422] 1. sequential:
[10:26:12.422]    - args: function (..., envir = parent.frame())
[10:26:12.422]    - tweaked: FALSE
[10:26:12.422]    - call: NULL
[10:26:12.423] plan(): nbrOfWorkers() = 1
[10:26:12.425] plan(): Setting new future strategy stack:
[10:26:12.425] List of future strategies:
[10:26:12.425] 1. multicore:
[10:26:12.425]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.425]    - tweaked: FALSE
[10:26:12.425]    - call: plan(strategy)
[10:26:12.430] plan(): nbrOfWorkers() = 2
[10:26:12.431] result() for MulticoreFuture ...
[10:26:12.431] result() for MulticoreFuture ... done
[10:26:12.431] result() for MulticoreFuture ... done
[10:26:12.431] result() for MulticoreFuture ...
[10:26:12.432] result() for MulticoreFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.432] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.433] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:12.435] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:26:12.435] Searching for globals ... DONE
[10:26:12.435] Resolving globals: TRUE
[10:26:12.436] Resolving any globals that are futures ...
[10:26:12.436] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:26:12.436] Resolving any globals that are futures ... DONE
[10:26:12.436] Resolving futures part of globals (recursively) ...
[10:26:12.437] resolve() on list ...
[10:26:12.437]  recursive: 99
[10:26:12.437]  length: 1
[10:26:12.437]  elements: ‘a’
[10:26:12.437]  length: 0 (resolved future 1)
[10:26:12.437] resolve() on list ... DONE
[10:26:12.437] - globals: [1] ‘a’
[10:26:12.437] Resolving futures part of globals (recursively) ... DONE
[10:26:12.438] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:12.438] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:26:12.438] - globals: [1] ‘a’
[10:26:12.438] 
[10:26:12.438] getGlobalsAndPackages() ... DONE
[10:26:12.439] run() for ‘Future’ ...
[10:26:12.439] - state: ‘created’
[10:26:12.439] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.443] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.443] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.444]   - Field: ‘label’
[10:26:12.444]   - Field: ‘local’
[10:26:12.446]   - Field: ‘owner’
[10:26:12.446]   - Field: ‘envir’
[10:26:12.446]   - Field: ‘workers’
[10:26:12.446]   - Field: ‘packages’
[10:26:12.447]   - Field: ‘gc’
[10:26:12.447]   - Field: ‘job’
[10:26:12.447]   - Field: ‘conditions’
[10:26:12.447]   - Field: ‘expr’
[10:26:12.447]   - Field: ‘uuid’
[10:26:12.447]   - Field: ‘seed’
[10:26:12.447]   - Field: ‘version’
[10:26:12.448]   - Field: ‘result’
[10:26:12.448]   - Field: ‘asynchronous’
[10:26:12.448]   - Field: ‘calls’
[10:26:12.448]   - Field: ‘globals’
[10:26:12.448]   - Field: ‘stdout’
[10:26:12.448]   - Field: ‘earlySignal’
[10:26:12.448]   - Field: ‘lazy’
[10:26:12.448]   - Field: ‘state’
[10:26:12.449] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.449] - Launch lazy future ...
[10:26:12.449] Packages needed by the future expression (n = 0): <none>
[10:26:12.449] Packages needed by future strategies (n = 0): <none>
[10:26:12.450] {
[10:26:12.450]     {
[10:26:12.450]         {
[10:26:12.450]             ...future.startTime <- base::Sys.time()
[10:26:12.450]             {
[10:26:12.450]                 {
[10:26:12.450]                   {
[10:26:12.450]                     {
[10:26:12.450]                       base::local({
[10:26:12.450]                         has_future <- base::requireNamespace("future", 
[10:26:12.450]                           quietly = TRUE)
[10:26:12.450]                         if (has_future) {
[10:26:12.450]                           ns <- base::getNamespace("future")
[10:26:12.450]                           version <- ns[[".package"]][["version"]]
[10:26:12.450]                           if (is.null(version)) 
[10:26:12.450]                             version <- utils::packageVersion("future")
[10:26:12.450]                         }
[10:26:12.450]                         else {
[10:26:12.450]                           version <- NULL
[10:26:12.450]                         }
[10:26:12.450]                         if (!has_future || version < "1.8.0") {
[10:26:12.450]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.450]                             "", base::R.version$version.string), 
[10:26:12.450]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:12.450]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:12.450]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.450]                               "release", "version")], collapse = " "), 
[10:26:12.450]                             hostname = base::Sys.info()[["nodename"]])
[10:26:12.450]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.450]                             info)
[10:26:12.450]                           info <- base::paste(info, collapse = "; ")
[10:26:12.450]                           if (!has_future) {
[10:26:12.450]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.450]                               info)
[10:26:12.450]                           }
[10:26:12.450]                           else {
[10:26:12.450]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.450]                               info, version)
[10:26:12.450]                           }
[10:26:12.450]                           base::stop(msg)
[10:26:12.450]                         }
[10:26:12.450]                       })
[10:26:12.450]                     }
[10:26:12.450]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.450]                     base::options(mc.cores = 1L)
[10:26:12.450]                   }
[10:26:12.450]                   options(future.plan = NULL)
[10:26:12.450]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.450]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.450]                 }
[10:26:12.450]                 ...future.workdir <- getwd()
[10:26:12.450]             }
[10:26:12.450]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.450]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.450]         }
[10:26:12.450]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.450]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:12.450]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.450]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.450]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.450]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.450]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.450]             base::names(...future.oldOptions))
[10:26:12.450]     }
[10:26:12.450]     if (FALSE) {
[10:26:12.450]     }
[10:26:12.450]     else {
[10:26:12.450]         if (TRUE) {
[10:26:12.450]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.450]                 open = "w")
[10:26:12.450]         }
[10:26:12.450]         else {
[10:26:12.450]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.450]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.450]         }
[10:26:12.450]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.450]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.450]             base::sink(type = "output", split = FALSE)
[10:26:12.450]             base::close(...future.stdout)
[10:26:12.450]         }, add = TRUE)
[10:26:12.450]     }
[10:26:12.450]     ...future.frame <- base::sys.nframe()
[10:26:12.450]     ...future.conditions <- base::list()
[10:26:12.450]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.450]     if (FALSE) {
[10:26:12.450]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.450]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.450]     }
[10:26:12.450]     ...future.result <- base::tryCatch({
[10:26:12.450]         base::withCallingHandlers({
[10:26:12.450]             ...future.value <- base::withVisible(base::local({
[10:26:12.450]                 withCallingHandlers({
[10:26:12.450]                   {
[10:26:12.450]                     b <- a
[10:26:12.450]                     a <- 2
[10:26:12.450]                     a * b
[10:26:12.450]                   }
[10:26:12.450]                 }, immediateCondition = function(cond) {
[10:26:12.450]                   save_rds <- function (object, pathname, ...) 
[10:26:12.450]                   {
[10:26:12.450]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.450]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.450]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.450]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.450]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.450]                         fi_tmp[["mtime"]])
[10:26:12.450]                     }
[10:26:12.450]                     tryCatch({
[10:26:12.450]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.450]                     }, error = function(ex) {
[10:26:12.450]                       msg <- conditionMessage(ex)
[10:26:12.450]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.450]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.450]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.450]                         fi_tmp[["mtime"]], msg)
[10:26:12.450]                       ex$message <- msg
[10:26:12.450]                       stop(ex)
[10:26:12.450]                     })
[10:26:12.450]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.450]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.450]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.450]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.450]                       fi <- file.info(pathname)
[10:26:12.450]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.450]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.450]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.450]                         fi[["size"]], fi[["mtime"]])
[10:26:12.450]                       stop(msg)
[10:26:12.450]                     }
[10:26:12.450]                     invisible(pathname)
[10:26:12.450]                   }
[10:26:12.450]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.450]                     rootPath = tempdir()) 
[10:26:12.450]                   {
[10:26:12.450]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.450]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.450]                       tmpdir = path, fileext = ".rds")
[10:26:12.450]                     save_rds(obj, file)
[10:26:12.450]                   }
[10:26:12.450]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.450]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.450]                   {
[10:26:12.450]                     inherits <- base::inherits
[10:26:12.450]                     invokeRestart <- base::invokeRestart
[10:26:12.450]                     is.null <- base::is.null
[10:26:12.450]                     muffled <- FALSE
[10:26:12.450]                     if (inherits(cond, "message")) {
[10:26:12.450]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.450]                       if (muffled) 
[10:26:12.450]                         invokeRestart("muffleMessage")
[10:26:12.450]                     }
[10:26:12.450]                     else if (inherits(cond, "warning")) {
[10:26:12.450]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.450]                       if (muffled) 
[10:26:12.450]                         invokeRestart("muffleWarning")
[10:26:12.450]                     }
[10:26:12.450]                     else if (inherits(cond, "condition")) {
[10:26:12.450]                       if (!is.null(pattern)) {
[10:26:12.450]                         computeRestarts <- base::computeRestarts
[10:26:12.450]                         grepl <- base::grepl
[10:26:12.450]                         restarts <- computeRestarts(cond)
[10:26:12.450]                         for (restart in restarts) {
[10:26:12.450]                           name <- restart$name
[10:26:12.450]                           if (is.null(name)) 
[10:26:12.450]                             next
[10:26:12.450]                           if (!grepl(pattern, name)) 
[10:26:12.450]                             next
[10:26:12.450]                           invokeRestart(restart)
[10:26:12.450]                           muffled <- TRUE
[10:26:12.450]                           break
[10:26:12.450]                         }
[10:26:12.450]                       }
[10:26:12.450]                     }
[10:26:12.450]                     invisible(muffled)
[10:26:12.450]                   }
[10:26:12.450]                   muffleCondition(cond)
[10:26:12.450]                 })
[10:26:12.450]             }))
[10:26:12.450]             future::FutureResult(value = ...future.value$value, 
[10:26:12.450]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.450]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.450]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.450]                     ...future.globalenv.names))
[10:26:12.450]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.450]         }, condition = base::local({
[10:26:12.450]             c <- base::c
[10:26:12.450]             inherits <- base::inherits
[10:26:12.450]             invokeRestart <- base::invokeRestart
[10:26:12.450]             length <- base::length
[10:26:12.450]             list <- base::list
[10:26:12.450]             seq.int <- base::seq.int
[10:26:12.450]             signalCondition <- base::signalCondition
[10:26:12.450]             sys.calls <- base::sys.calls
[10:26:12.450]             `[[` <- base::`[[`
[10:26:12.450]             `+` <- base::`+`
[10:26:12.450]             `<<-` <- base::`<<-`
[10:26:12.450]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.450]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.450]                   3L)]
[10:26:12.450]             }
[10:26:12.450]             function(cond) {
[10:26:12.450]                 is_error <- inherits(cond, "error")
[10:26:12.450]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.450]                   NULL)
[10:26:12.450]                 if (is_error) {
[10:26:12.450]                   sessionInformation <- function() {
[10:26:12.450]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.450]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.450]                       search = base::search(), system = base::Sys.info())
[10:26:12.450]                   }
[10:26:12.450]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.450]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.450]                     cond$call), session = sessionInformation(), 
[10:26:12.450]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.450]                   signalCondition(cond)
[10:26:12.450]                 }
[10:26:12.450]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.450]                 "immediateCondition"))) {
[10:26:12.450]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.450]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.450]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.450]                   if (TRUE && !signal) {
[10:26:12.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.450]                     {
[10:26:12.450]                       inherits <- base::inherits
[10:26:12.450]                       invokeRestart <- base::invokeRestart
[10:26:12.450]                       is.null <- base::is.null
[10:26:12.450]                       muffled <- FALSE
[10:26:12.450]                       if (inherits(cond, "message")) {
[10:26:12.450]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.450]                         if (muffled) 
[10:26:12.450]                           invokeRestart("muffleMessage")
[10:26:12.450]                       }
[10:26:12.450]                       else if (inherits(cond, "warning")) {
[10:26:12.450]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.450]                         if (muffled) 
[10:26:12.450]                           invokeRestart("muffleWarning")
[10:26:12.450]                       }
[10:26:12.450]                       else if (inherits(cond, "condition")) {
[10:26:12.450]                         if (!is.null(pattern)) {
[10:26:12.450]                           computeRestarts <- base::computeRestarts
[10:26:12.450]                           grepl <- base::grepl
[10:26:12.450]                           restarts <- computeRestarts(cond)
[10:26:12.450]                           for (restart in restarts) {
[10:26:12.450]                             name <- restart$name
[10:26:12.450]                             if (is.null(name)) 
[10:26:12.450]                               next
[10:26:12.450]                             if (!grepl(pattern, name)) 
[10:26:12.450]                               next
[10:26:12.450]                             invokeRestart(restart)
[10:26:12.450]                             muffled <- TRUE
[10:26:12.450]                             break
[10:26:12.450]                           }
[10:26:12.450]                         }
[10:26:12.450]                       }
[10:26:12.450]                       invisible(muffled)
[10:26:12.450]                     }
[10:26:12.450]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.450]                   }
[10:26:12.450]                 }
[10:26:12.450]                 else {
[10:26:12.450]                   if (TRUE) {
[10:26:12.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.450]                     {
[10:26:12.450]                       inherits <- base::inherits
[10:26:12.450]                       invokeRestart <- base::invokeRestart
[10:26:12.450]                       is.null <- base::is.null
[10:26:12.450]                       muffled <- FALSE
[10:26:12.450]                       if (inherits(cond, "message")) {
[10:26:12.450]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.450]                         if (muffled) 
[10:26:12.450]                           invokeRestart("muffleMessage")
[10:26:12.450]                       }
[10:26:12.450]                       else if (inherits(cond, "warning")) {
[10:26:12.450]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.450]                         if (muffled) 
[10:26:12.450]                           invokeRestart("muffleWarning")
[10:26:12.450]                       }
[10:26:12.450]                       else if (inherits(cond, "condition")) {
[10:26:12.450]                         if (!is.null(pattern)) {
[10:26:12.450]                           computeRestarts <- base::computeRestarts
[10:26:12.450]                           grepl <- base::grepl
[10:26:12.450]                           restarts <- computeRestarts(cond)
[10:26:12.450]                           for (restart in restarts) {
[10:26:12.450]                             name <- restart$name
[10:26:12.450]                             if (is.null(name)) 
[10:26:12.450]                               next
[10:26:12.450]                             if (!grepl(pattern, name)) 
[10:26:12.450]                               next
[10:26:12.450]                             invokeRestart(restart)
[10:26:12.450]                             muffled <- TRUE
[10:26:12.450]                             break
[10:26:12.450]                           }
[10:26:12.450]                         }
[10:26:12.450]                       }
[10:26:12.450]                       invisible(muffled)
[10:26:12.450]                     }
[10:26:12.450]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.450]                   }
[10:26:12.450]                 }
[10:26:12.450]             }
[10:26:12.450]         }))
[10:26:12.450]     }, error = function(ex) {
[10:26:12.450]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.450]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.450]                 ...future.rng), started = ...future.startTime, 
[10:26:12.450]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.450]             version = "1.8"), class = "FutureResult")
[10:26:12.450]     }, finally = {
[10:26:12.450]         if (!identical(...future.workdir, getwd())) 
[10:26:12.450]             setwd(...future.workdir)
[10:26:12.450]         {
[10:26:12.450]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.450]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.450]             }
[10:26:12.450]             base::options(...future.oldOptions)
[10:26:12.450]             if (.Platform$OS.type == "windows") {
[10:26:12.450]                 old_names <- names(...future.oldEnvVars)
[10:26:12.450]                 envs <- base::Sys.getenv()
[10:26:12.450]                 names <- names(envs)
[10:26:12.450]                 common <- intersect(names, old_names)
[10:26:12.450]                 added <- setdiff(names, old_names)
[10:26:12.450]                 removed <- setdiff(old_names, names)
[10:26:12.450]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.450]                   envs[common]]
[10:26:12.450]                 NAMES <- toupper(changed)
[10:26:12.450]                 args <- list()
[10:26:12.450]                 for (kk in seq_along(NAMES)) {
[10:26:12.450]                   name <- changed[[kk]]
[10:26:12.450]                   NAME <- NAMES[[kk]]
[10:26:12.450]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.450]                     next
[10:26:12.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.450]                 }
[10:26:12.450]                 NAMES <- toupper(added)
[10:26:12.450]                 for (kk in seq_along(NAMES)) {
[10:26:12.450]                   name <- added[[kk]]
[10:26:12.450]                   NAME <- NAMES[[kk]]
[10:26:12.450]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.450]                     next
[10:26:12.450]                   args[[name]] <- ""
[10:26:12.450]                 }
[10:26:12.450]                 NAMES <- toupper(removed)
[10:26:12.450]                 for (kk in seq_along(NAMES)) {
[10:26:12.450]                   name <- removed[[kk]]
[10:26:12.450]                   NAME <- NAMES[[kk]]
[10:26:12.450]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.450]                     next
[10:26:12.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.450]                 }
[10:26:12.450]                 if (length(args) > 0) 
[10:26:12.450]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.450]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.450]             }
[10:26:12.450]             else {
[10:26:12.450]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.450]             }
[10:26:12.450]             {
[10:26:12.450]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.450]                   0L) {
[10:26:12.450]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.450]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.450]                   base::options(opts)
[10:26:12.450]                 }
[10:26:12.450]                 {
[10:26:12.450]                   {
[10:26:12.450]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.450]                     NULL
[10:26:12.450]                   }
[10:26:12.450]                   options(future.plan = NULL)
[10:26:12.450]                   if (is.na(NA_character_)) 
[10:26:12.450]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.450]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.450]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.450]                     envir = parent.frame()) 
[10:26:12.450]                   {
[10:26:12.450]                     default_workers <- missing(workers)
[10:26:12.450]                     if (is.function(workers)) 
[10:26:12.450]                       workers <- workers()
[10:26:12.450]                     workers <- structure(as.integer(workers), 
[10:26:12.450]                       class = class(workers))
[10:26:12.450]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.450]                       1L)
[10:26:12.450]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.450]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.450]                       if (default_workers) 
[10:26:12.450]                         supportsMulticore(warn = TRUE)
[10:26:12.450]                       return(sequential(..., envir = envir))
[10:26:12.450]                     }
[10:26:12.450]                     oopts <- options(mc.cores = workers)
[10:26:12.450]                     on.exit(options(oopts))
[10:26:12.450]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.450]                       envir = envir)
[10:26:12.450]                     if (!future$lazy) 
[10:26:12.450]                       future <- run(future)
[10:26:12.450]                     invisible(future)
[10:26:12.450]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.450]                 }
[10:26:12.450]             }
[10:26:12.450]         }
[10:26:12.450]     })
[10:26:12.450]     if (TRUE) {
[10:26:12.450]         base::sink(type = "output", split = FALSE)
[10:26:12.450]         if (TRUE) {
[10:26:12.450]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.450]         }
[10:26:12.450]         else {
[10:26:12.450]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.450]         }
[10:26:12.450]         base::close(...future.stdout)
[10:26:12.450]         ...future.stdout <- NULL
[10:26:12.450]     }
[10:26:12.450]     ...future.result$conditions <- ...future.conditions
[10:26:12.450]     ...future.result$finished <- base::Sys.time()
[10:26:12.450]     ...future.result
[10:26:12.450] }
[10:26:12.452] assign_globals() ...
[10:26:12.453] List of 1
[10:26:12.453]  $ a: num 3
[10:26:12.453]  - attr(*, "where")=List of 1
[10:26:12.453]   ..$ a:<environment: R_EmptyEnv> 
[10:26:12.453]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:12.453]  - attr(*, "resolved")= logi TRUE
[10:26:12.453]  - attr(*, "total_size")= num 56
[10:26:12.453]  - attr(*, "already-done")= logi TRUE
[10:26:12.456] - copied ‘a’ to environment
[10:26:12.456] assign_globals() ... done
[10:26:12.456] requestCore(): workers = 2
[10:26:12.458] MulticoreFuture started
[10:26:12.459] - Launch lazy future ... done
[10:26:12.459] run() for ‘MulticoreFuture’ ... done
[10:26:12.459] result() for MulticoreFuture ...
[10:26:12.459] plan(): Setting new future strategy stack:
[10:26:12.460] List of future strategies:
[10:26:12.460] 1. sequential:
[10:26:12.460]    - args: function (..., envir = parent.frame())
[10:26:12.460]    - tweaked: FALSE
[10:26:12.460]    - call: NULL
[10:26:12.460] plan(): nbrOfWorkers() = 1
[10:26:12.463] plan(): Setting new future strategy stack:
[10:26:12.463] List of future strategies:
[10:26:12.463] 1. multicore:
[10:26:12.463]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.463]    - tweaked: FALSE
[10:26:12.463]    - call: plan(strategy)
[10:26:12.468] plan(): nbrOfWorkers() = 2
[10:26:12.469] result() for MulticoreFuture ...
[10:26:12.469] result() for MulticoreFuture ... done
[10:26:12.470] result() for MulticoreFuture ... done
[10:26:12.470] result() for MulticoreFuture ...
[10:26:12.470] result() for MulticoreFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.471] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.472] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:12.474] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:12.474] Searching for globals ... DONE
[10:26:12.475] Resolving globals: TRUE
[10:26:12.475] Resolving any globals that are futures ...
[10:26:12.475] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:12.475] Resolving any globals that are futures ... DONE
[10:26:12.475] Resolving futures part of globals (recursively) ...
[10:26:12.476] resolve() on list ...
[10:26:12.476]  recursive: 99
[10:26:12.476]  length: 2
[10:26:12.476]  elements: ‘a’, ‘ii’
[10:26:12.476]  length: 1 (resolved future 1)
[10:26:12.476]  length: 0 (resolved future 2)
[10:26:12.477] resolve() on list ... DONE
[10:26:12.477] - globals: [2] ‘a’, ‘ii’
[10:26:12.477] Resolving futures part of globals (recursively) ... DONE
[10:26:12.477] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:12.477] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:26:12.478] - globals: [2] ‘a’, ‘ii’
[10:26:12.478] 
[10:26:12.478] getGlobalsAndPackages() ... DONE
[10:26:12.478] run() for ‘Future’ ...
[10:26:12.478] - state: ‘created’
[10:26:12.478] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.482] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.483] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.483]   - Field: ‘label’
[10:26:12.483]   - Field: ‘local’
[10:26:12.483]   - Field: ‘owner’
[10:26:12.483]   - Field: ‘envir’
[10:26:12.483]   - Field: ‘workers’
[10:26:12.483]   - Field: ‘packages’
[10:26:12.483]   - Field: ‘gc’
[10:26:12.484]   - Field: ‘job’
[10:26:12.484]   - Field: ‘conditions’
[10:26:12.484]   - Field: ‘expr’
[10:26:12.484]   - Field: ‘uuid’
[10:26:12.484]   - Field: ‘seed’
[10:26:12.484]   - Field: ‘version’
[10:26:12.484]   - Field: ‘result’
[10:26:12.484]   - Field: ‘asynchronous’
[10:26:12.484]   - Field: ‘calls’
[10:26:12.485]   - Field: ‘globals’
[10:26:12.485]   - Field: ‘stdout’
[10:26:12.485]   - Field: ‘earlySignal’
[10:26:12.485]   - Field: ‘lazy’
[10:26:12.485]   - Field: ‘state’
[10:26:12.485] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.485] - Launch lazy future ...
[10:26:12.486] Packages needed by the future expression (n = 0): <none>
[10:26:12.486] Packages needed by future strategies (n = 0): <none>
[10:26:12.486] {
[10:26:12.486]     {
[10:26:12.486]         {
[10:26:12.486]             ...future.startTime <- base::Sys.time()
[10:26:12.486]             {
[10:26:12.486]                 {
[10:26:12.486]                   {
[10:26:12.486]                     {
[10:26:12.486]                       base::local({
[10:26:12.486]                         has_future <- base::requireNamespace("future", 
[10:26:12.486]                           quietly = TRUE)
[10:26:12.486]                         if (has_future) {
[10:26:12.486]                           ns <- base::getNamespace("future")
[10:26:12.486]                           version <- ns[[".package"]][["version"]]
[10:26:12.486]                           if (is.null(version)) 
[10:26:12.486]                             version <- utils::packageVersion("future")
[10:26:12.486]                         }
[10:26:12.486]                         else {
[10:26:12.486]                           version <- NULL
[10:26:12.486]                         }
[10:26:12.486]                         if (!has_future || version < "1.8.0") {
[10:26:12.486]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.486]                             "", base::R.version$version.string), 
[10:26:12.486]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:12.486]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:12.486]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.486]                               "release", "version")], collapse = " "), 
[10:26:12.486]                             hostname = base::Sys.info()[["nodename"]])
[10:26:12.486]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.486]                             info)
[10:26:12.486]                           info <- base::paste(info, collapse = "; ")
[10:26:12.486]                           if (!has_future) {
[10:26:12.486]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.486]                               info)
[10:26:12.486]                           }
[10:26:12.486]                           else {
[10:26:12.486]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.486]                               info, version)
[10:26:12.486]                           }
[10:26:12.486]                           base::stop(msg)
[10:26:12.486]                         }
[10:26:12.486]                       })
[10:26:12.486]                     }
[10:26:12.486]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.486]                     base::options(mc.cores = 1L)
[10:26:12.486]                   }
[10:26:12.486]                   options(future.plan = NULL)
[10:26:12.486]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.486]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.486]                 }
[10:26:12.486]                 ...future.workdir <- getwd()
[10:26:12.486]             }
[10:26:12.486]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.486]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.486]         }
[10:26:12.486]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.486]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:12.486]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.486]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.486]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.486]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.486]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.486]             base::names(...future.oldOptions))
[10:26:12.486]     }
[10:26:12.486]     if (FALSE) {
[10:26:12.486]     }
[10:26:12.486]     else {
[10:26:12.486]         if (TRUE) {
[10:26:12.486]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.486]                 open = "w")
[10:26:12.486]         }
[10:26:12.486]         else {
[10:26:12.486]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.486]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.486]         }
[10:26:12.486]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.486]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.486]             base::sink(type = "output", split = FALSE)
[10:26:12.486]             base::close(...future.stdout)
[10:26:12.486]         }, add = TRUE)
[10:26:12.486]     }
[10:26:12.486]     ...future.frame <- base::sys.nframe()
[10:26:12.486]     ...future.conditions <- base::list()
[10:26:12.486]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.486]     if (FALSE) {
[10:26:12.486]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.486]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.486]     }
[10:26:12.486]     ...future.result <- base::tryCatch({
[10:26:12.486]         base::withCallingHandlers({
[10:26:12.486]             ...future.value <- base::withVisible(base::local({
[10:26:12.486]                 withCallingHandlers({
[10:26:12.486]                   {
[10:26:12.486]                     b <- a * ii
[10:26:12.486]                     a <- 0
[10:26:12.486]                     b
[10:26:12.486]                   }
[10:26:12.486]                 }, immediateCondition = function(cond) {
[10:26:12.486]                   save_rds <- function (object, pathname, ...) 
[10:26:12.486]                   {
[10:26:12.486]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.486]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.486]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.486]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.486]                         fi_tmp[["mtime"]])
[10:26:12.486]                     }
[10:26:12.486]                     tryCatch({
[10:26:12.486]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.486]                     }, error = function(ex) {
[10:26:12.486]                       msg <- conditionMessage(ex)
[10:26:12.486]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.486]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.486]                         fi_tmp[["mtime"]], msg)
[10:26:12.486]                       ex$message <- msg
[10:26:12.486]                       stop(ex)
[10:26:12.486]                     })
[10:26:12.486]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.486]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.486]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.486]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.486]                       fi <- file.info(pathname)
[10:26:12.486]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.486]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.486]                         fi[["size"]], fi[["mtime"]])
[10:26:12.486]                       stop(msg)
[10:26:12.486]                     }
[10:26:12.486]                     invisible(pathname)
[10:26:12.486]                   }
[10:26:12.486]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.486]                     rootPath = tempdir()) 
[10:26:12.486]                   {
[10:26:12.486]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.486]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.486]                       tmpdir = path, fileext = ".rds")
[10:26:12.486]                     save_rds(obj, file)
[10:26:12.486]                   }
[10:26:12.486]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.486]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.486]                   {
[10:26:12.486]                     inherits <- base::inherits
[10:26:12.486]                     invokeRestart <- base::invokeRestart
[10:26:12.486]                     is.null <- base::is.null
[10:26:12.486]                     muffled <- FALSE
[10:26:12.486]                     if (inherits(cond, "message")) {
[10:26:12.486]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.486]                       if (muffled) 
[10:26:12.486]                         invokeRestart("muffleMessage")
[10:26:12.486]                     }
[10:26:12.486]                     else if (inherits(cond, "warning")) {
[10:26:12.486]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.486]                       if (muffled) 
[10:26:12.486]                         invokeRestart("muffleWarning")
[10:26:12.486]                     }
[10:26:12.486]                     else if (inherits(cond, "condition")) {
[10:26:12.486]                       if (!is.null(pattern)) {
[10:26:12.486]                         computeRestarts <- base::computeRestarts
[10:26:12.486]                         grepl <- base::grepl
[10:26:12.486]                         restarts <- computeRestarts(cond)
[10:26:12.486]                         for (restart in restarts) {
[10:26:12.486]                           name <- restart$name
[10:26:12.486]                           if (is.null(name)) 
[10:26:12.486]                             next
[10:26:12.486]                           if (!grepl(pattern, name)) 
[10:26:12.486]                             next
[10:26:12.486]                           invokeRestart(restart)
[10:26:12.486]                           muffled <- TRUE
[10:26:12.486]                           break
[10:26:12.486]                         }
[10:26:12.486]                       }
[10:26:12.486]                     }
[10:26:12.486]                     invisible(muffled)
[10:26:12.486]                   }
[10:26:12.486]                   muffleCondition(cond)
[10:26:12.486]                 })
[10:26:12.486]             }))
[10:26:12.486]             future::FutureResult(value = ...future.value$value, 
[10:26:12.486]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.486]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.486]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.486]                     ...future.globalenv.names))
[10:26:12.486]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.486]         }, condition = base::local({
[10:26:12.486]             c <- base::c
[10:26:12.486]             inherits <- base::inherits
[10:26:12.486]             invokeRestart <- base::invokeRestart
[10:26:12.486]             length <- base::length
[10:26:12.486]             list <- base::list
[10:26:12.486]             seq.int <- base::seq.int
[10:26:12.486]             signalCondition <- base::signalCondition
[10:26:12.486]             sys.calls <- base::sys.calls
[10:26:12.486]             `[[` <- base::`[[`
[10:26:12.486]             `+` <- base::`+`
[10:26:12.486]             `<<-` <- base::`<<-`
[10:26:12.486]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.486]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.486]                   3L)]
[10:26:12.486]             }
[10:26:12.486]             function(cond) {
[10:26:12.486]                 is_error <- inherits(cond, "error")
[10:26:12.486]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.486]                   NULL)
[10:26:12.486]                 if (is_error) {
[10:26:12.486]                   sessionInformation <- function() {
[10:26:12.486]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.486]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.486]                       search = base::search(), system = base::Sys.info())
[10:26:12.486]                   }
[10:26:12.486]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.486]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.486]                     cond$call), session = sessionInformation(), 
[10:26:12.486]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.486]                   signalCondition(cond)
[10:26:12.486]                 }
[10:26:12.486]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.486]                 "immediateCondition"))) {
[10:26:12.486]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.486]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.486]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.486]                   if (TRUE && !signal) {
[10:26:12.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.486]                     {
[10:26:12.486]                       inherits <- base::inherits
[10:26:12.486]                       invokeRestart <- base::invokeRestart
[10:26:12.486]                       is.null <- base::is.null
[10:26:12.486]                       muffled <- FALSE
[10:26:12.486]                       if (inherits(cond, "message")) {
[10:26:12.486]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.486]                         if (muffled) 
[10:26:12.486]                           invokeRestart("muffleMessage")
[10:26:12.486]                       }
[10:26:12.486]                       else if (inherits(cond, "warning")) {
[10:26:12.486]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.486]                         if (muffled) 
[10:26:12.486]                           invokeRestart("muffleWarning")
[10:26:12.486]                       }
[10:26:12.486]                       else if (inherits(cond, "condition")) {
[10:26:12.486]                         if (!is.null(pattern)) {
[10:26:12.486]                           computeRestarts <- base::computeRestarts
[10:26:12.486]                           grepl <- base::grepl
[10:26:12.486]                           restarts <- computeRestarts(cond)
[10:26:12.486]                           for (restart in restarts) {
[10:26:12.486]                             name <- restart$name
[10:26:12.486]                             if (is.null(name)) 
[10:26:12.486]                               next
[10:26:12.486]                             if (!grepl(pattern, name)) 
[10:26:12.486]                               next
[10:26:12.486]                             invokeRestart(restart)
[10:26:12.486]                             muffled <- TRUE
[10:26:12.486]                             break
[10:26:12.486]                           }
[10:26:12.486]                         }
[10:26:12.486]                       }
[10:26:12.486]                       invisible(muffled)
[10:26:12.486]                     }
[10:26:12.486]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.486]                   }
[10:26:12.486]                 }
[10:26:12.486]                 else {
[10:26:12.486]                   if (TRUE) {
[10:26:12.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.486]                     {
[10:26:12.486]                       inherits <- base::inherits
[10:26:12.486]                       invokeRestart <- base::invokeRestart
[10:26:12.486]                       is.null <- base::is.null
[10:26:12.486]                       muffled <- FALSE
[10:26:12.486]                       if (inherits(cond, "message")) {
[10:26:12.486]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.486]                         if (muffled) 
[10:26:12.486]                           invokeRestart("muffleMessage")
[10:26:12.486]                       }
[10:26:12.486]                       else if (inherits(cond, "warning")) {
[10:26:12.486]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.486]                         if (muffled) 
[10:26:12.486]                           invokeRestart("muffleWarning")
[10:26:12.486]                       }
[10:26:12.486]                       else if (inherits(cond, "condition")) {
[10:26:12.486]                         if (!is.null(pattern)) {
[10:26:12.486]                           computeRestarts <- base::computeRestarts
[10:26:12.486]                           grepl <- base::grepl
[10:26:12.486]                           restarts <- computeRestarts(cond)
[10:26:12.486]                           for (restart in restarts) {
[10:26:12.486]                             name <- restart$name
[10:26:12.486]                             if (is.null(name)) 
[10:26:12.486]                               next
[10:26:12.486]                             if (!grepl(pattern, name)) 
[10:26:12.486]                               next
[10:26:12.486]                             invokeRestart(restart)
[10:26:12.486]                             muffled <- TRUE
[10:26:12.486]                             break
[10:26:12.486]                           }
[10:26:12.486]                         }
[10:26:12.486]                       }
[10:26:12.486]                       invisible(muffled)
[10:26:12.486]                     }
[10:26:12.486]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.486]                   }
[10:26:12.486]                 }
[10:26:12.486]             }
[10:26:12.486]         }))
[10:26:12.486]     }, error = function(ex) {
[10:26:12.486]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.486]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.486]                 ...future.rng), started = ...future.startTime, 
[10:26:12.486]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.486]             version = "1.8"), class = "FutureResult")
[10:26:12.486]     }, finally = {
[10:26:12.486]         if (!identical(...future.workdir, getwd())) 
[10:26:12.486]             setwd(...future.workdir)
[10:26:12.486]         {
[10:26:12.486]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.486]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.486]             }
[10:26:12.486]             base::options(...future.oldOptions)
[10:26:12.486]             if (.Platform$OS.type == "windows") {
[10:26:12.486]                 old_names <- names(...future.oldEnvVars)
[10:26:12.486]                 envs <- base::Sys.getenv()
[10:26:12.486]                 names <- names(envs)
[10:26:12.486]                 common <- intersect(names, old_names)
[10:26:12.486]                 added <- setdiff(names, old_names)
[10:26:12.486]                 removed <- setdiff(old_names, names)
[10:26:12.486]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.486]                   envs[common]]
[10:26:12.486]                 NAMES <- toupper(changed)
[10:26:12.486]                 args <- list()
[10:26:12.486]                 for (kk in seq_along(NAMES)) {
[10:26:12.486]                   name <- changed[[kk]]
[10:26:12.486]                   NAME <- NAMES[[kk]]
[10:26:12.486]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.486]                     next
[10:26:12.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.486]                 }
[10:26:12.486]                 NAMES <- toupper(added)
[10:26:12.486]                 for (kk in seq_along(NAMES)) {
[10:26:12.486]                   name <- added[[kk]]
[10:26:12.486]                   NAME <- NAMES[[kk]]
[10:26:12.486]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.486]                     next
[10:26:12.486]                   args[[name]] <- ""
[10:26:12.486]                 }
[10:26:12.486]                 NAMES <- toupper(removed)
[10:26:12.486]                 for (kk in seq_along(NAMES)) {
[10:26:12.486]                   name <- removed[[kk]]
[10:26:12.486]                   NAME <- NAMES[[kk]]
[10:26:12.486]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.486]                     next
[10:26:12.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.486]                 }
[10:26:12.486]                 if (length(args) > 0) 
[10:26:12.486]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.486]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.486]             }
[10:26:12.486]             else {
[10:26:12.486]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.486]             }
[10:26:12.486]             {
[10:26:12.486]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.486]                   0L) {
[10:26:12.486]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.486]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.486]                   base::options(opts)
[10:26:12.486]                 }
[10:26:12.486]                 {
[10:26:12.486]                   {
[10:26:12.486]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.486]                     NULL
[10:26:12.486]                   }
[10:26:12.486]                   options(future.plan = NULL)
[10:26:12.486]                   if (is.na(NA_character_)) 
[10:26:12.486]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.486]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.486]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.486]                     envir = parent.frame()) 
[10:26:12.486]                   {
[10:26:12.486]                     default_workers <- missing(workers)
[10:26:12.486]                     if (is.function(workers)) 
[10:26:12.486]                       workers <- workers()
[10:26:12.486]                     workers <- structure(as.integer(workers), 
[10:26:12.486]                       class = class(workers))
[10:26:12.486]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.486]                       1L)
[10:26:12.486]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.486]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.486]                       if (default_workers) 
[10:26:12.486]                         supportsMulticore(warn = TRUE)
[10:26:12.486]                       return(sequential(..., envir = envir))
[10:26:12.486]                     }
[10:26:12.486]                     oopts <- options(mc.cores = workers)
[10:26:12.486]                     on.exit(options(oopts))
[10:26:12.486]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.486]                       envir = envir)
[10:26:12.486]                     if (!future$lazy) 
[10:26:12.486]                       future <- run(future)
[10:26:12.486]                     invisible(future)
[10:26:12.486]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.486]                 }
[10:26:12.486]             }
[10:26:12.486]         }
[10:26:12.486]     })
[10:26:12.486]     if (TRUE) {
[10:26:12.486]         base::sink(type = "output", split = FALSE)
[10:26:12.486]         if (TRUE) {
[10:26:12.486]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.486]         }
[10:26:12.486]         else {
[10:26:12.486]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.486]         }
[10:26:12.486]         base::close(...future.stdout)
[10:26:12.486]         ...future.stdout <- NULL
[10:26:12.486]     }
[10:26:12.486]     ...future.result$conditions <- ...future.conditions
[10:26:12.486]     ...future.result$finished <- base::Sys.time()
[10:26:12.486]     ...future.result
[10:26:12.486] }
[10:26:12.489] assign_globals() ...
[10:26:12.489] List of 2
[10:26:12.489]  $ a : num 1
[10:26:12.489]  $ ii: int 1
[10:26:12.489]  - attr(*, "where")=List of 2
[10:26:12.489]   ..$ a :<environment: R_EmptyEnv> 
[10:26:12.489]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:12.489]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:12.489]  - attr(*, "resolved")= logi TRUE
[10:26:12.489]  - attr(*, "total_size")= num 112
[10:26:12.489]  - attr(*, "already-done")= logi TRUE
[10:26:12.495] - copied ‘a’ to environment
[10:26:12.495] - copied ‘ii’ to environment
[10:26:12.496] assign_globals() ... done
[10:26:12.496] requestCore(): workers = 2
[10:26:12.498] MulticoreFuture started
[10:26:12.498] - Launch lazy future ... done
[10:26:12.499] run() for ‘MulticoreFuture’ ... done
[10:26:12.499] plan(): Setting new future strategy stack:
[10:26:12.499] List of future strategies:
[10:26:12.499] 1. sequential:
[10:26:12.499]    - args: function (..., envir = parent.frame())
[10:26:12.499]    - tweaked: FALSE
[10:26:12.499]    - call: NULL
[10:26:12.501] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.501] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.502] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:12.503] plan(): Setting new future strategy stack:
[10:26:12.503] List of future strategies:
[10:26:12.503] 1. multicore:
[10:26:12.503]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.503]    - tweaked: FALSE
[10:26:12.503]    - call: plan(strategy)
[10:26:12.507] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:12.507] Searching for globals ... DONE
[10:26:12.508] Resolving globals: TRUE
[10:26:12.508] Resolving any globals that are futures ...
[10:26:12.508] plan(): nbrOfWorkers() = 2
[10:26:12.508] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:12.508] Resolving any globals that are futures ... DONE
[10:26:12.509] Resolving futures part of globals (recursively) ...
[10:26:12.510] resolve() on list ...
[10:26:12.510]  recursive: 99
[10:26:12.510]  length: 2
[10:26:12.510]  elements: ‘a’, ‘ii’
[10:26:12.511]  length: 1 (resolved future 1)
[10:26:12.511]  length: 0 (resolved future 2)
[10:26:12.511] resolve() on list ... DONE
[10:26:12.511] - globals: [2] ‘a’, ‘ii’
[10:26:12.511] Resolving futures part of globals (recursively) ... DONE
[10:26:12.512] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:12.512] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:26:12.512] - globals: [2] ‘a’, ‘ii’
[10:26:12.513] 
[10:26:12.513] getGlobalsAndPackages() ... DONE
[10:26:12.513] run() for ‘Future’ ...
[10:26:12.513] - state: ‘created’
[10:26:12.514] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.518] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.518] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.518]   - Field: ‘label’
[10:26:12.518]   - Field: ‘local’
[10:26:12.518]   - Field: ‘owner’
[10:26:12.518]   - Field: ‘envir’
[10:26:12.518]   - Field: ‘workers’
[10:26:12.519]   - Field: ‘packages’
[10:26:12.519]   - Field: ‘gc’
[10:26:12.519]   - Field: ‘job’
[10:26:12.519]   - Field: ‘conditions’
[10:26:12.519]   - Field: ‘expr’
[10:26:12.519]   - Field: ‘uuid’
[10:26:12.519]   - Field: ‘seed’
[10:26:12.520]   - Field: ‘version’
[10:26:12.520]   - Field: ‘result’
[10:26:12.520]   - Field: ‘asynchronous’
[10:26:12.520]   - Field: ‘calls’
[10:26:12.520]   - Field: ‘globals’
[10:26:12.520]   - Field: ‘stdout’
[10:26:12.520]   - Field: ‘earlySignal’
[10:26:12.520]   - Field: ‘lazy’
[10:26:12.521]   - Field: ‘state’
[10:26:12.521] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.521] - Launch lazy future ...
[10:26:12.521] Packages needed by the future expression (n = 0): <none>
[10:26:12.521] Packages needed by future strategies (n = 0): <none>
[10:26:12.522] {
[10:26:12.522]     {
[10:26:12.522]         {
[10:26:12.522]             ...future.startTime <- base::Sys.time()
[10:26:12.522]             {
[10:26:12.522]                 {
[10:26:12.522]                   {
[10:26:12.522]                     {
[10:26:12.522]                       base::local({
[10:26:12.522]                         has_future <- base::requireNamespace("future", 
[10:26:12.522]                           quietly = TRUE)
[10:26:12.522]                         if (has_future) {
[10:26:12.522]                           ns <- base::getNamespace("future")
[10:26:12.522]                           version <- ns[[".package"]][["version"]]
[10:26:12.522]                           if (is.null(version)) 
[10:26:12.522]                             version <- utils::packageVersion("future")
[10:26:12.522]                         }
[10:26:12.522]                         else {
[10:26:12.522]                           version <- NULL
[10:26:12.522]                         }
[10:26:12.522]                         if (!has_future || version < "1.8.0") {
[10:26:12.522]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.522]                             "", base::R.version$version.string), 
[10:26:12.522]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:12.522]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:12.522]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.522]                               "release", "version")], collapse = " "), 
[10:26:12.522]                             hostname = base::Sys.info()[["nodename"]])
[10:26:12.522]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.522]                             info)
[10:26:12.522]                           info <- base::paste(info, collapse = "; ")
[10:26:12.522]                           if (!has_future) {
[10:26:12.522]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.522]                               info)
[10:26:12.522]                           }
[10:26:12.522]                           else {
[10:26:12.522]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.522]                               info, version)
[10:26:12.522]                           }
[10:26:12.522]                           base::stop(msg)
[10:26:12.522]                         }
[10:26:12.522]                       })
[10:26:12.522]                     }
[10:26:12.522]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.522]                     base::options(mc.cores = 1L)
[10:26:12.522]                   }
[10:26:12.522]                   options(future.plan = NULL)
[10:26:12.522]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.522]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.522]                 }
[10:26:12.522]                 ...future.workdir <- getwd()
[10:26:12.522]             }
[10:26:12.522]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.522]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.522]         }
[10:26:12.522]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.522]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:12.522]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.522]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.522]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.522]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.522]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.522]             base::names(...future.oldOptions))
[10:26:12.522]     }
[10:26:12.522]     if (FALSE) {
[10:26:12.522]     }
[10:26:12.522]     else {
[10:26:12.522]         if (TRUE) {
[10:26:12.522]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.522]                 open = "w")
[10:26:12.522]         }
[10:26:12.522]         else {
[10:26:12.522]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.522]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.522]         }
[10:26:12.522]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.522]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.522]             base::sink(type = "output", split = FALSE)
[10:26:12.522]             base::close(...future.stdout)
[10:26:12.522]         }, add = TRUE)
[10:26:12.522]     }
[10:26:12.522]     ...future.frame <- base::sys.nframe()
[10:26:12.522]     ...future.conditions <- base::list()
[10:26:12.522]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.522]     if (FALSE) {
[10:26:12.522]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.522]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.522]     }
[10:26:12.522]     ...future.result <- base::tryCatch({
[10:26:12.522]         base::withCallingHandlers({
[10:26:12.522]             ...future.value <- base::withVisible(base::local({
[10:26:12.522]                 withCallingHandlers({
[10:26:12.522]                   {
[10:26:12.522]                     b <- a * ii
[10:26:12.522]                     a <- 0
[10:26:12.522]                     b
[10:26:12.522]                   }
[10:26:12.522]                 }, immediateCondition = function(cond) {
[10:26:12.522]                   save_rds <- function (object, pathname, ...) 
[10:26:12.522]                   {
[10:26:12.522]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.522]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.522]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.522]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.522]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.522]                         fi_tmp[["mtime"]])
[10:26:12.522]                     }
[10:26:12.522]                     tryCatch({
[10:26:12.522]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.522]                     }, error = function(ex) {
[10:26:12.522]                       msg <- conditionMessage(ex)
[10:26:12.522]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.522]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.522]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.522]                         fi_tmp[["mtime"]], msg)
[10:26:12.522]                       ex$message <- msg
[10:26:12.522]                       stop(ex)
[10:26:12.522]                     })
[10:26:12.522]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.522]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.522]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.522]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.522]                       fi <- file.info(pathname)
[10:26:12.522]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.522]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.522]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.522]                         fi[["size"]], fi[["mtime"]])
[10:26:12.522]                       stop(msg)
[10:26:12.522]                     }
[10:26:12.522]                     invisible(pathname)
[10:26:12.522]                   }
[10:26:12.522]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.522]                     rootPath = tempdir()) 
[10:26:12.522]                   {
[10:26:12.522]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.522]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.522]                       tmpdir = path, fileext = ".rds")
[10:26:12.522]                     save_rds(obj, file)
[10:26:12.522]                   }
[10:26:12.522]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.522]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.522]                   {
[10:26:12.522]                     inherits <- base::inherits
[10:26:12.522]                     invokeRestart <- base::invokeRestart
[10:26:12.522]                     is.null <- base::is.null
[10:26:12.522]                     muffled <- FALSE
[10:26:12.522]                     if (inherits(cond, "message")) {
[10:26:12.522]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.522]                       if (muffled) 
[10:26:12.522]                         invokeRestart("muffleMessage")
[10:26:12.522]                     }
[10:26:12.522]                     else if (inherits(cond, "warning")) {
[10:26:12.522]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.522]                       if (muffled) 
[10:26:12.522]                         invokeRestart("muffleWarning")
[10:26:12.522]                     }
[10:26:12.522]                     else if (inherits(cond, "condition")) {
[10:26:12.522]                       if (!is.null(pattern)) {
[10:26:12.522]                         computeRestarts <- base::computeRestarts
[10:26:12.522]                         grepl <- base::grepl
[10:26:12.522]                         restarts <- computeRestarts(cond)
[10:26:12.522]                         for (restart in restarts) {
[10:26:12.522]                           name <- restart$name
[10:26:12.522]                           if (is.null(name)) 
[10:26:12.522]                             next
[10:26:12.522]                           if (!grepl(pattern, name)) 
[10:26:12.522]                             next
[10:26:12.522]                           invokeRestart(restart)
[10:26:12.522]                           muffled <- TRUE
[10:26:12.522]                           break
[10:26:12.522]                         }
[10:26:12.522]                       }
[10:26:12.522]                     }
[10:26:12.522]                     invisible(muffled)
[10:26:12.522]                   }
[10:26:12.522]                   muffleCondition(cond)
[10:26:12.522]                 })
[10:26:12.522]             }))
[10:26:12.522]             future::FutureResult(value = ...future.value$value, 
[10:26:12.522]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.522]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.522]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.522]                     ...future.globalenv.names))
[10:26:12.522]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.522]         }, condition = base::local({
[10:26:12.522]             c <- base::c
[10:26:12.522]             inherits <- base::inherits
[10:26:12.522]             invokeRestart <- base::invokeRestart
[10:26:12.522]             length <- base::length
[10:26:12.522]             list <- base::list
[10:26:12.522]             seq.int <- base::seq.int
[10:26:12.522]             signalCondition <- base::signalCondition
[10:26:12.522]             sys.calls <- base::sys.calls
[10:26:12.522]             `[[` <- base::`[[`
[10:26:12.522]             `+` <- base::`+`
[10:26:12.522]             `<<-` <- base::`<<-`
[10:26:12.522]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.522]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.522]                   3L)]
[10:26:12.522]             }
[10:26:12.522]             function(cond) {
[10:26:12.522]                 is_error <- inherits(cond, "error")
[10:26:12.522]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.522]                   NULL)
[10:26:12.522]                 if (is_error) {
[10:26:12.522]                   sessionInformation <- function() {
[10:26:12.522]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.522]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.522]                       search = base::search(), system = base::Sys.info())
[10:26:12.522]                   }
[10:26:12.522]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.522]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.522]                     cond$call), session = sessionInformation(), 
[10:26:12.522]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.522]                   signalCondition(cond)
[10:26:12.522]                 }
[10:26:12.522]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.522]                 "immediateCondition"))) {
[10:26:12.522]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.522]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.522]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.522]                   if (TRUE && !signal) {
[10:26:12.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.522]                     {
[10:26:12.522]                       inherits <- base::inherits
[10:26:12.522]                       invokeRestart <- base::invokeRestart
[10:26:12.522]                       is.null <- base::is.null
[10:26:12.522]                       muffled <- FALSE
[10:26:12.522]                       if (inherits(cond, "message")) {
[10:26:12.522]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.522]                         if (muffled) 
[10:26:12.522]                           invokeRestart("muffleMessage")
[10:26:12.522]                       }
[10:26:12.522]                       else if (inherits(cond, "warning")) {
[10:26:12.522]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.522]                         if (muffled) 
[10:26:12.522]                           invokeRestart("muffleWarning")
[10:26:12.522]                       }
[10:26:12.522]                       else if (inherits(cond, "condition")) {
[10:26:12.522]                         if (!is.null(pattern)) {
[10:26:12.522]                           computeRestarts <- base::computeRestarts
[10:26:12.522]                           grepl <- base::grepl
[10:26:12.522]                           restarts <- computeRestarts(cond)
[10:26:12.522]                           for (restart in restarts) {
[10:26:12.522]                             name <- restart$name
[10:26:12.522]                             if (is.null(name)) 
[10:26:12.522]                               next
[10:26:12.522]                             if (!grepl(pattern, name)) 
[10:26:12.522]                               next
[10:26:12.522]                             invokeRestart(restart)
[10:26:12.522]                             muffled <- TRUE
[10:26:12.522]                             break
[10:26:12.522]                           }
[10:26:12.522]                         }
[10:26:12.522]                       }
[10:26:12.522]                       invisible(muffled)
[10:26:12.522]                     }
[10:26:12.522]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.522]                   }
[10:26:12.522]                 }
[10:26:12.522]                 else {
[10:26:12.522]                   if (TRUE) {
[10:26:12.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.522]                     {
[10:26:12.522]                       inherits <- base::inherits
[10:26:12.522]                       invokeRestart <- base::invokeRestart
[10:26:12.522]                       is.null <- base::is.null
[10:26:12.522]                       muffled <- FALSE
[10:26:12.522]                       if (inherits(cond, "message")) {
[10:26:12.522]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.522]                         if (muffled) 
[10:26:12.522]                           invokeRestart("muffleMessage")
[10:26:12.522]                       }
[10:26:12.522]                       else if (inherits(cond, "warning")) {
[10:26:12.522]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.522]                         if (muffled) 
[10:26:12.522]                           invokeRestart("muffleWarning")
[10:26:12.522]                       }
[10:26:12.522]                       else if (inherits(cond, "condition")) {
[10:26:12.522]                         if (!is.null(pattern)) {
[10:26:12.522]                           computeRestarts <- base::computeRestarts
[10:26:12.522]                           grepl <- base::grepl
[10:26:12.522]                           restarts <- computeRestarts(cond)
[10:26:12.522]                           for (restart in restarts) {
[10:26:12.522]                             name <- restart$name
[10:26:12.522]                             if (is.null(name)) 
[10:26:12.522]                               next
[10:26:12.522]                             if (!grepl(pattern, name)) 
[10:26:12.522]                               next
[10:26:12.522]                             invokeRestart(restart)
[10:26:12.522]                             muffled <- TRUE
[10:26:12.522]                             break
[10:26:12.522]                           }
[10:26:12.522]                         }
[10:26:12.522]                       }
[10:26:12.522]                       invisible(muffled)
[10:26:12.522]                     }
[10:26:12.522]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.522]                   }
[10:26:12.522]                 }
[10:26:12.522]             }
[10:26:12.522]         }))
[10:26:12.522]     }, error = function(ex) {
[10:26:12.522]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.522]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.522]                 ...future.rng), started = ...future.startTime, 
[10:26:12.522]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.522]             version = "1.8"), class = "FutureResult")
[10:26:12.522]     }, finally = {
[10:26:12.522]         if (!identical(...future.workdir, getwd())) 
[10:26:12.522]             setwd(...future.workdir)
[10:26:12.522]         {
[10:26:12.522]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.522]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.522]             }
[10:26:12.522]             base::options(...future.oldOptions)
[10:26:12.522]             if (.Platform$OS.type == "windows") {
[10:26:12.522]                 old_names <- names(...future.oldEnvVars)
[10:26:12.522]                 envs <- base::Sys.getenv()
[10:26:12.522]                 names <- names(envs)
[10:26:12.522]                 common <- intersect(names, old_names)
[10:26:12.522]                 added <- setdiff(names, old_names)
[10:26:12.522]                 removed <- setdiff(old_names, names)
[10:26:12.522]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.522]                   envs[common]]
[10:26:12.522]                 NAMES <- toupper(changed)
[10:26:12.522]                 args <- list()
[10:26:12.522]                 for (kk in seq_along(NAMES)) {
[10:26:12.522]                   name <- changed[[kk]]
[10:26:12.522]                   NAME <- NAMES[[kk]]
[10:26:12.522]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.522]                     next
[10:26:12.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.522]                 }
[10:26:12.522]                 NAMES <- toupper(added)
[10:26:12.522]                 for (kk in seq_along(NAMES)) {
[10:26:12.522]                   name <- added[[kk]]
[10:26:12.522]                   NAME <- NAMES[[kk]]
[10:26:12.522]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.522]                     next
[10:26:12.522]                   args[[name]] <- ""
[10:26:12.522]                 }
[10:26:12.522]                 NAMES <- toupper(removed)
[10:26:12.522]                 for (kk in seq_along(NAMES)) {
[10:26:12.522]                   name <- removed[[kk]]
[10:26:12.522]                   NAME <- NAMES[[kk]]
[10:26:12.522]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.522]                     next
[10:26:12.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.522]                 }
[10:26:12.522]                 if (length(args) > 0) 
[10:26:12.522]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.522]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.522]             }
[10:26:12.522]             else {
[10:26:12.522]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.522]             }
[10:26:12.522]             {
[10:26:12.522]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.522]                   0L) {
[10:26:12.522]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.522]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.522]                   base::options(opts)
[10:26:12.522]                 }
[10:26:12.522]                 {
[10:26:12.522]                   {
[10:26:12.522]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.522]                     NULL
[10:26:12.522]                   }
[10:26:12.522]                   options(future.plan = NULL)
[10:26:12.522]                   if (is.na(NA_character_)) 
[10:26:12.522]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.522]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.522]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.522]                     envir = parent.frame()) 
[10:26:12.522]                   {
[10:26:12.522]                     default_workers <- missing(workers)
[10:26:12.522]                     if (is.function(workers)) 
[10:26:12.522]                       workers <- workers()
[10:26:12.522]                     workers <- structure(as.integer(workers), 
[10:26:12.522]                       class = class(workers))
[10:26:12.522]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.522]                       1L)
[10:26:12.522]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.522]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.522]                       if (default_workers) 
[10:26:12.522]                         supportsMulticore(warn = TRUE)
[10:26:12.522]                       return(sequential(..., envir = envir))
[10:26:12.522]                     }
[10:26:12.522]                     oopts <- options(mc.cores = workers)
[10:26:12.522]                     on.exit(options(oopts))
[10:26:12.522]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.522]                       envir = envir)
[10:26:12.522]                     if (!future$lazy) 
[10:26:12.522]                       future <- run(future)
[10:26:12.522]                     invisible(future)
[10:26:12.522]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.522]                 }
[10:26:12.522]             }
[10:26:12.522]         }
[10:26:12.522]     })
[10:26:12.522]     if (TRUE) {
[10:26:12.522]         base::sink(type = "output", split = FALSE)
[10:26:12.522]         if (TRUE) {
[10:26:12.522]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.522]         }
[10:26:12.522]         else {
[10:26:12.522]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.522]         }
[10:26:12.522]         base::close(...future.stdout)
[10:26:12.522]         ...future.stdout <- NULL
[10:26:12.522]     }
[10:26:12.522]     ...future.result$conditions <- ...future.conditions
[10:26:12.522]     ...future.result$finished <- base::Sys.time()
[10:26:12.522]     ...future.result
[10:26:12.522] }
[10:26:12.525] assign_globals() ...
[10:26:12.525] List of 2
[10:26:12.525]  $ a : num 1
[10:26:12.525]  $ ii: int 2
[10:26:12.525]  - attr(*, "where")=List of 2
[10:26:12.525]   ..$ a :<environment: R_EmptyEnv> 
[10:26:12.525]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:12.525]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:12.525]  - attr(*, "resolved")= logi TRUE
[10:26:12.525]  - attr(*, "total_size")= num 112
[10:26:12.525]  - attr(*, "already-done")= logi TRUE
[10:26:12.530] - copied ‘a’ to environment
[10:26:12.530] - copied ‘ii’ to environment
[10:26:12.530] assign_globals() ... done
[10:26:12.530] requestCore(): workers = 2
[10:26:12.532] MulticoreFuture started
[10:26:12.533] - Launch lazy future ... done
[10:26:12.533] run() for ‘MulticoreFuture’ ... done
[10:26:12.533] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.534] getGlobalsAndPackages() ...
[10:26:12.534] List of future strategies:
[10:26:12.534] 1. sequential:
[10:26:12.534]    - args: function (..., envir = parent.frame())
[10:26:12.534]    - tweaked: FALSE
[10:26:12.534]    - call: NULL
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.535] Searching for globals...
[10:26:12.535] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:12.540] plan(): Setting new future strategy stack:
[10:26:12.540] List of future strategies:
[10:26:12.540] 1. multicore:
[10:26:12.540]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.540]    - tweaked: FALSE
[10:26:12.540]    - call: plan(strategy)
[10:26:12.545] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:12.545] Searching for globals ... DONE
[10:26:12.545] Resolving globals: TRUE
[10:26:12.546] Resolving any globals that are futures ...
[10:26:12.546] plan(): nbrOfWorkers() = 2
[10:26:12.546] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:12.546] Resolving any globals that are futures ... DONE
[10:26:12.547] Resolving futures part of globals (recursively) ...
[10:26:12.548] resolve() on list ...
[10:26:12.548]  recursive: 99
[10:26:12.548]  length: 2
[10:26:12.548]  elements: ‘a’, ‘ii’
[10:26:12.548]  length: 1 (resolved future 1)
[10:26:12.549]  length: 0 (resolved future 2)
[10:26:12.549] resolve() on list ... DONE
[10:26:12.549] - globals: [2] ‘a’, ‘ii’
[10:26:12.549] Resolving futures part of globals (recursively) ... DONE
[10:26:12.550] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:12.550] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:26:12.551] - globals: [2] ‘a’, ‘ii’
[10:26:12.551] 
[10:26:12.551] getGlobalsAndPackages() ... DONE
[10:26:12.551] run() for ‘Future’ ...
[10:26:12.551] - state: ‘created’
[10:26:12.552] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.556] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.556] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.556]   - Field: ‘label’
[10:26:12.556]   - Field: ‘local’
[10:26:12.557]   - Field: ‘owner’
[10:26:12.557]   - Field: ‘envir’
[10:26:12.557]   - Field: ‘workers’
[10:26:12.557]   - Field: ‘packages’
[10:26:12.557]   - Field: ‘gc’
[10:26:12.557]   - Field: ‘job’
[10:26:12.557]   - Field: ‘conditions’
[10:26:12.558]   - Field: ‘expr’
[10:26:12.558]   - Field: ‘uuid’
[10:26:12.558]   - Field: ‘seed’
[10:26:12.558]   - Field: ‘version’
[10:26:12.558]   - Field: ‘result’
[10:26:12.558]   - Field: ‘asynchronous’
[10:26:12.558]   - Field: ‘calls’
[10:26:12.559]   - Field: ‘globals’
[10:26:12.559]   - Field: ‘stdout’
[10:26:12.559]   - Field: ‘earlySignal’
[10:26:12.559]   - Field: ‘lazy’
[10:26:12.559]   - Field: ‘state’
[10:26:12.559] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.559] - Launch lazy future ...
[10:26:12.560] Packages needed by the future expression (n = 0): <none>
[10:26:12.560] Packages needed by future strategies (n = 0): <none>
[10:26:12.560] {
[10:26:12.560]     {
[10:26:12.560]         {
[10:26:12.560]             ...future.startTime <- base::Sys.time()
[10:26:12.560]             {
[10:26:12.560]                 {
[10:26:12.560]                   {
[10:26:12.560]                     {
[10:26:12.560]                       base::local({
[10:26:12.560]                         has_future <- base::requireNamespace("future", 
[10:26:12.560]                           quietly = TRUE)
[10:26:12.560]                         if (has_future) {
[10:26:12.560]                           ns <- base::getNamespace("future")
[10:26:12.560]                           version <- ns[[".package"]][["version"]]
[10:26:12.560]                           if (is.null(version)) 
[10:26:12.560]                             version <- utils::packageVersion("future")
[10:26:12.560]                         }
[10:26:12.560]                         else {
[10:26:12.560]                           version <- NULL
[10:26:12.560]                         }
[10:26:12.560]                         if (!has_future || version < "1.8.0") {
[10:26:12.560]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.560]                             "", base::R.version$version.string), 
[10:26:12.560]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:12.560]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:12.560]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.560]                               "release", "version")], collapse = " "), 
[10:26:12.560]                             hostname = base::Sys.info()[["nodename"]])
[10:26:12.560]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.560]                             info)
[10:26:12.560]                           info <- base::paste(info, collapse = "; ")
[10:26:12.560]                           if (!has_future) {
[10:26:12.560]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.560]                               info)
[10:26:12.560]                           }
[10:26:12.560]                           else {
[10:26:12.560]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.560]                               info, version)
[10:26:12.560]                           }
[10:26:12.560]                           base::stop(msg)
[10:26:12.560]                         }
[10:26:12.560]                       })
[10:26:12.560]                     }
[10:26:12.560]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.560]                     base::options(mc.cores = 1L)
[10:26:12.560]                   }
[10:26:12.560]                   options(future.plan = NULL)
[10:26:12.560]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.560]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.560]                 }
[10:26:12.560]                 ...future.workdir <- getwd()
[10:26:12.560]             }
[10:26:12.560]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.560]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.560]         }
[10:26:12.560]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.560]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:12.560]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.560]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.560]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.560]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.560]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.560]             base::names(...future.oldOptions))
[10:26:12.560]     }
[10:26:12.560]     if (FALSE) {
[10:26:12.560]     }
[10:26:12.560]     else {
[10:26:12.560]         if (TRUE) {
[10:26:12.560]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.560]                 open = "w")
[10:26:12.560]         }
[10:26:12.560]         else {
[10:26:12.560]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.560]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.560]         }
[10:26:12.560]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.560]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.560]             base::sink(type = "output", split = FALSE)
[10:26:12.560]             base::close(...future.stdout)
[10:26:12.560]         }, add = TRUE)
[10:26:12.560]     }
[10:26:12.560]     ...future.frame <- base::sys.nframe()
[10:26:12.560]     ...future.conditions <- base::list()
[10:26:12.560]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.560]     if (FALSE) {
[10:26:12.560]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.560]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.560]     }
[10:26:12.560]     ...future.result <- base::tryCatch({
[10:26:12.560]         base::withCallingHandlers({
[10:26:12.560]             ...future.value <- base::withVisible(base::local({
[10:26:12.560]                 withCallingHandlers({
[10:26:12.560]                   {
[10:26:12.560]                     b <- a * ii
[10:26:12.560]                     a <- 0
[10:26:12.560]                     b
[10:26:12.560]                   }
[10:26:12.560]                 }, immediateCondition = function(cond) {
[10:26:12.560]                   save_rds <- function (object, pathname, ...) 
[10:26:12.560]                   {
[10:26:12.560]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.560]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.560]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.560]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.560]                         fi_tmp[["mtime"]])
[10:26:12.560]                     }
[10:26:12.560]                     tryCatch({
[10:26:12.560]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.560]                     }, error = function(ex) {
[10:26:12.560]                       msg <- conditionMessage(ex)
[10:26:12.560]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.560]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.560]                         fi_tmp[["mtime"]], msg)
[10:26:12.560]                       ex$message <- msg
[10:26:12.560]                       stop(ex)
[10:26:12.560]                     })
[10:26:12.560]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.560]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.560]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.560]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.560]                       fi <- file.info(pathname)
[10:26:12.560]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.560]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.560]                         fi[["size"]], fi[["mtime"]])
[10:26:12.560]                       stop(msg)
[10:26:12.560]                     }
[10:26:12.560]                     invisible(pathname)
[10:26:12.560]                   }
[10:26:12.560]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.560]                     rootPath = tempdir()) 
[10:26:12.560]                   {
[10:26:12.560]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.560]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.560]                       tmpdir = path, fileext = ".rds")
[10:26:12.560]                     save_rds(obj, file)
[10:26:12.560]                   }
[10:26:12.560]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.560]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.560]                   {
[10:26:12.560]                     inherits <- base::inherits
[10:26:12.560]                     invokeRestart <- base::invokeRestart
[10:26:12.560]                     is.null <- base::is.null
[10:26:12.560]                     muffled <- FALSE
[10:26:12.560]                     if (inherits(cond, "message")) {
[10:26:12.560]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.560]                       if (muffled) 
[10:26:12.560]                         invokeRestart("muffleMessage")
[10:26:12.560]                     }
[10:26:12.560]                     else if (inherits(cond, "warning")) {
[10:26:12.560]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.560]                       if (muffled) 
[10:26:12.560]                         invokeRestart("muffleWarning")
[10:26:12.560]                     }
[10:26:12.560]                     else if (inherits(cond, "condition")) {
[10:26:12.560]                       if (!is.null(pattern)) {
[10:26:12.560]                         computeRestarts <- base::computeRestarts
[10:26:12.560]                         grepl <- base::grepl
[10:26:12.560]                         restarts <- computeRestarts(cond)
[10:26:12.560]                         for (restart in restarts) {
[10:26:12.560]                           name <- restart$name
[10:26:12.560]                           if (is.null(name)) 
[10:26:12.560]                             next
[10:26:12.560]                           if (!grepl(pattern, name)) 
[10:26:12.560]                             next
[10:26:12.560]                           invokeRestart(restart)
[10:26:12.560]                           muffled <- TRUE
[10:26:12.560]                           break
[10:26:12.560]                         }
[10:26:12.560]                       }
[10:26:12.560]                     }
[10:26:12.560]                     invisible(muffled)
[10:26:12.560]                   }
[10:26:12.560]                   muffleCondition(cond)
[10:26:12.560]                 })
[10:26:12.560]             }))
[10:26:12.560]             future::FutureResult(value = ...future.value$value, 
[10:26:12.560]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.560]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.560]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.560]                     ...future.globalenv.names))
[10:26:12.560]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.560]         }, condition = base::local({
[10:26:12.560]             c <- base::c
[10:26:12.560]             inherits <- base::inherits
[10:26:12.560]             invokeRestart <- base::invokeRestart
[10:26:12.560]             length <- base::length
[10:26:12.560]             list <- base::list
[10:26:12.560]             seq.int <- base::seq.int
[10:26:12.560]             signalCondition <- base::signalCondition
[10:26:12.560]             sys.calls <- base::sys.calls
[10:26:12.560]             `[[` <- base::`[[`
[10:26:12.560]             `+` <- base::`+`
[10:26:12.560]             `<<-` <- base::`<<-`
[10:26:12.560]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.560]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.560]                   3L)]
[10:26:12.560]             }
[10:26:12.560]             function(cond) {
[10:26:12.560]                 is_error <- inherits(cond, "error")
[10:26:12.560]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.560]                   NULL)
[10:26:12.560]                 if (is_error) {
[10:26:12.560]                   sessionInformation <- function() {
[10:26:12.560]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.560]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.560]                       search = base::search(), system = base::Sys.info())
[10:26:12.560]                   }
[10:26:12.560]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.560]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.560]                     cond$call), session = sessionInformation(), 
[10:26:12.560]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.560]                   signalCondition(cond)
[10:26:12.560]                 }
[10:26:12.560]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.560]                 "immediateCondition"))) {
[10:26:12.560]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.560]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.560]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.560]                   if (TRUE && !signal) {
[10:26:12.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.560]                     {
[10:26:12.560]                       inherits <- base::inherits
[10:26:12.560]                       invokeRestart <- base::invokeRestart
[10:26:12.560]                       is.null <- base::is.null
[10:26:12.560]                       muffled <- FALSE
[10:26:12.560]                       if (inherits(cond, "message")) {
[10:26:12.560]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.560]                         if (muffled) 
[10:26:12.560]                           invokeRestart("muffleMessage")
[10:26:12.560]                       }
[10:26:12.560]                       else if (inherits(cond, "warning")) {
[10:26:12.560]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.560]                         if (muffled) 
[10:26:12.560]                           invokeRestart("muffleWarning")
[10:26:12.560]                       }
[10:26:12.560]                       else if (inherits(cond, "condition")) {
[10:26:12.560]                         if (!is.null(pattern)) {
[10:26:12.560]                           computeRestarts <- base::computeRestarts
[10:26:12.560]                           grepl <- base::grepl
[10:26:12.560]                           restarts <- computeRestarts(cond)
[10:26:12.560]                           for (restart in restarts) {
[10:26:12.560]                             name <- restart$name
[10:26:12.560]                             if (is.null(name)) 
[10:26:12.560]                               next
[10:26:12.560]                             if (!grepl(pattern, name)) 
[10:26:12.560]                               next
[10:26:12.560]                             invokeRestart(restart)
[10:26:12.560]                             muffled <- TRUE
[10:26:12.560]                             break
[10:26:12.560]                           }
[10:26:12.560]                         }
[10:26:12.560]                       }
[10:26:12.560]                       invisible(muffled)
[10:26:12.560]                     }
[10:26:12.560]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.560]                   }
[10:26:12.560]                 }
[10:26:12.560]                 else {
[10:26:12.560]                   if (TRUE) {
[10:26:12.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.560]                     {
[10:26:12.560]                       inherits <- base::inherits
[10:26:12.560]                       invokeRestart <- base::invokeRestart
[10:26:12.560]                       is.null <- base::is.null
[10:26:12.560]                       muffled <- FALSE
[10:26:12.560]                       if (inherits(cond, "message")) {
[10:26:12.560]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.560]                         if (muffled) 
[10:26:12.560]                           invokeRestart("muffleMessage")
[10:26:12.560]                       }
[10:26:12.560]                       else if (inherits(cond, "warning")) {
[10:26:12.560]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.560]                         if (muffled) 
[10:26:12.560]                           invokeRestart("muffleWarning")
[10:26:12.560]                       }
[10:26:12.560]                       else if (inherits(cond, "condition")) {
[10:26:12.560]                         if (!is.null(pattern)) {
[10:26:12.560]                           computeRestarts <- base::computeRestarts
[10:26:12.560]                           grepl <- base::grepl
[10:26:12.560]                           restarts <- computeRestarts(cond)
[10:26:12.560]                           for (restart in restarts) {
[10:26:12.560]                             name <- restart$name
[10:26:12.560]                             if (is.null(name)) 
[10:26:12.560]                               next
[10:26:12.560]                             if (!grepl(pattern, name)) 
[10:26:12.560]                               next
[10:26:12.560]                             invokeRestart(restart)
[10:26:12.560]                             muffled <- TRUE
[10:26:12.560]                             break
[10:26:12.560]                           }
[10:26:12.560]                         }
[10:26:12.560]                       }
[10:26:12.560]                       invisible(muffled)
[10:26:12.560]                     }
[10:26:12.560]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.560]                   }
[10:26:12.560]                 }
[10:26:12.560]             }
[10:26:12.560]         }))
[10:26:12.560]     }, error = function(ex) {
[10:26:12.560]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.560]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.560]                 ...future.rng), started = ...future.startTime, 
[10:26:12.560]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.560]             version = "1.8"), class = "FutureResult")
[10:26:12.560]     }, finally = {
[10:26:12.560]         if (!identical(...future.workdir, getwd())) 
[10:26:12.560]             setwd(...future.workdir)
[10:26:12.560]         {
[10:26:12.560]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.560]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.560]             }
[10:26:12.560]             base::options(...future.oldOptions)
[10:26:12.560]             if (.Platform$OS.type == "windows") {
[10:26:12.560]                 old_names <- names(...future.oldEnvVars)
[10:26:12.560]                 envs <- base::Sys.getenv()
[10:26:12.560]                 names <- names(envs)
[10:26:12.560]                 common <- intersect(names, old_names)
[10:26:12.560]                 added <- setdiff(names, old_names)
[10:26:12.560]                 removed <- setdiff(old_names, names)
[10:26:12.560]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.560]                   envs[common]]
[10:26:12.560]                 NAMES <- toupper(changed)
[10:26:12.560]                 args <- list()
[10:26:12.560]                 for (kk in seq_along(NAMES)) {
[10:26:12.560]                   name <- changed[[kk]]
[10:26:12.560]                   NAME <- NAMES[[kk]]
[10:26:12.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.560]                     next
[10:26:12.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.560]                 }
[10:26:12.560]                 NAMES <- toupper(added)
[10:26:12.560]                 for (kk in seq_along(NAMES)) {
[10:26:12.560]                   name <- added[[kk]]
[10:26:12.560]                   NAME <- NAMES[[kk]]
[10:26:12.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.560]                     next
[10:26:12.560]                   args[[name]] <- ""
[10:26:12.560]                 }
[10:26:12.560]                 NAMES <- toupper(removed)
[10:26:12.560]                 for (kk in seq_along(NAMES)) {
[10:26:12.560]                   name <- removed[[kk]]
[10:26:12.560]                   NAME <- NAMES[[kk]]
[10:26:12.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.560]                     next
[10:26:12.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.560]                 }
[10:26:12.560]                 if (length(args) > 0) 
[10:26:12.560]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.560]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.560]             }
[10:26:12.560]             else {
[10:26:12.560]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.560]             }
[10:26:12.560]             {
[10:26:12.560]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.560]                   0L) {
[10:26:12.560]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.560]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.560]                   base::options(opts)
[10:26:12.560]                 }
[10:26:12.560]                 {
[10:26:12.560]                   {
[10:26:12.560]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.560]                     NULL
[10:26:12.560]                   }
[10:26:12.560]                   options(future.plan = NULL)
[10:26:12.560]                   if (is.na(NA_character_)) 
[10:26:12.560]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.560]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.560]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.560]                     envir = parent.frame()) 
[10:26:12.560]                   {
[10:26:12.560]                     default_workers <- missing(workers)
[10:26:12.560]                     if (is.function(workers)) 
[10:26:12.560]                       workers <- workers()
[10:26:12.560]                     workers <- structure(as.integer(workers), 
[10:26:12.560]                       class = class(workers))
[10:26:12.560]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.560]                       1L)
[10:26:12.560]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.560]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.560]                       if (default_workers) 
[10:26:12.560]                         supportsMulticore(warn = TRUE)
[10:26:12.560]                       return(sequential(..., envir = envir))
[10:26:12.560]                     }
[10:26:12.560]                     oopts <- options(mc.cores = workers)
[10:26:12.560]                     on.exit(options(oopts))
[10:26:12.560]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.560]                       envir = envir)
[10:26:12.560]                     if (!future$lazy) 
[10:26:12.560]                       future <- run(future)
[10:26:12.560]                     invisible(future)
[10:26:12.560]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.560]                 }
[10:26:12.560]             }
[10:26:12.560]         }
[10:26:12.560]     })
[10:26:12.560]     if (TRUE) {
[10:26:12.560]         base::sink(type = "output", split = FALSE)
[10:26:12.560]         if (TRUE) {
[10:26:12.560]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.560]         }
[10:26:12.560]         else {
[10:26:12.560]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.560]         }
[10:26:12.560]         base::close(...future.stdout)
[10:26:12.560]         ...future.stdout <- NULL
[10:26:12.560]     }
[10:26:12.560]     ...future.result$conditions <- ...future.conditions
[10:26:12.560]     ...future.result$finished <- base::Sys.time()
[10:26:12.560]     ...future.result
[10:26:12.560] }
[10:26:12.563] assign_globals() ...
[10:26:12.563] List of 2
[10:26:12.563]  $ a : num 1
[10:26:12.563]  $ ii: int 3
[10:26:12.563]  - attr(*, "where")=List of 2
[10:26:12.563]   ..$ a :<environment: R_EmptyEnv> 
[10:26:12.563]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:12.563]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:12.563]  - attr(*, "resolved")= logi TRUE
[10:26:12.563]  - attr(*, "total_size")= num 112
[10:26:12.563]  - attr(*, "already-done")= logi TRUE
[10:26:12.567] - copied ‘a’ to environment
[10:26:12.567] - copied ‘ii’ to environment
[10:26:12.567] assign_globals() ... done
[10:26:12.567] requestCore(): workers = 2
[10:26:12.568] Poll #1 (0): usedCores() = 2, workers = 2
[10:26:12.589] result() for MulticoreFuture ...
[10:26:12.589] result() for MulticoreFuture ...
[10:26:12.590] result() for MulticoreFuture ... done
[10:26:12.590] result() for MulticoreFuture ... done
[10:26:12.590] result() for MulticoreFuture ...
[10:26:12.590] result() for MulticoreFuture ... done
[10:26:12.592] MulticoreFuture started
[10:26:12.593] - Launch lazy future ... done
[10:26:12.593] run() for ‘MulticoreFuture’ ... done
[10:26:12.594] plan(): Setting new future strategy stack:
[10:26:12.594] result() for MulticoreFuture ...
[10:26:12.595] result() for MulticoreFuture ... done
[10:26:12.594] List of future strategies:
[10:26:12.594] 1. sequential:
[10:26:12.594]    - args: function (..., envir = parent.frame())
[10:26:12.594]    - tweaked: FALSE
[10:26:12.594]    - call: NULL
[10:26:12.595] result() for MulticoreFuture ...
[10:26:12.595] plan(): nbrOfWorkers() = 1
[10:26:12.595] result() for MulticoreFuture ... done
[10:26:12.596] result() for MulticoreFuture ...
[10:26:12.597] result() for MulticoreFuture ...
[10:26:12.598] result() for MulticoreFuture ... done
[10:26:12.598] result() for MulticoreFuture ... done
[10:26:12.598] plan(): Setting new future strategy stack:
[10:26:12.598] result() for MulticoreFuture ...
[10:26:12.598] result() for MulticoreFuture ... done
[10:26:12.598] List of future strategies:
[10:26:12.598] 1. multicore:
[10:26:12.598]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.598]    - tweaked: FALSE
[10:26:12.598]    - call: plan(strategy)
[10:26:12.599] result() for MulticoreFuture ...
[10:26:12.604] plan(): nbrOfWorkers() = 2
[10:26:12.604] result() for MulticoreFuture ...
[10:26:12.604] result() for MulticoreFuture ... done
[10:26:12.605] result() for MulticoreFuture ... done
[10:26:12.605] result() for MulticoreFuture ...
[10:26:12.605] result() for MulticoreFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.606] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.607] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:12.609] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:12.609] Searching for globals ... DONE
[10:26:12.610] Resolving globals: TRUE
[10:26:12.610] Resolving any globals that are futures ...
[10:26:12.610] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:12.610] Resolving any globals that are futures ... DONE
[10:26:12.610] Resolving futures part of globals (recursively) ...
[10:26:12.611] resolve() on list ...
[10:26:12.611]  recursive: 99
[10:26:12.611]  length: 2
[10:26:12.611]  elements: ‘a’, ‘ii’
[10:26:12.611]  length: 1 (resolved future 1)
[10:26:12.611]  length: 0 (resolved future 2)
[10:26:12.611] resolve() on list ... DONE
[10:26:12.612] - globals: [2] ‘a’, ‘ii’
[10:26:12.612] Resolving futures part of globals (recursively) ... DONE
[10:26:12.612] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:12.612] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:26:12.613] - globals: [2] ‘a’, ‘ii’
[10:26:12.613] 
[10:26:12.613] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.614] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.614] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:12.616] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:12.616] Searching for globals ... DONE
[10:26:12.616] Resolving globals: TRUE
[10:26:12.616] Resolving any globals that are futures ...
[10:26:12.616] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:12.617] Resolving any globals that are futures ... DONE
[10:26:12.617] Resolving futures part of globals (recursively) ...
[10:26:12.619] resolve() on list ...
[10:26:12.619]  recursive: 99
[10:26:12.619]  length: 2
[10:26:12.620]  elements: ‘a’, ‘ii’
[10:26:12.620]  length: 1 (resolved future 1)
[10:26:12.620]  length: 0 (resolved future 2)
[10:26:12.620] resolve() on list ... DONE
[10:26:12.620] - globals: [2] ‘a’, ‘ii’
[10:26:12.620] Resolving futures part of globals (recursively) ... DONE
[10:26:12.621] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:12.621] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:26:12.621] - globals: [2] ‘a’, ‘ii’
[10:26:12.621] 
[10:26:12.622] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.622] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.622] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:12.625] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:12.625] Searching for globals ... DONE
[10:26:12.625] Resolving globals: TRUE
[10:26:12.626] Resolving any globals that are futures ...
[10:26:12.626] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:12.626] Resolving any globals that are futures ... DONE
[10:26:12.626] Resolving futures part of globals (recursively) ...
[10:26:12.626] resolve() on list ...
[10:26:12.627]  recursive: 99
[10:26:12.627]  length: 2
[10:26:12.627]  elements: ‘a’, ‘ii’
[10:26:12.627]  length: 1 (resolved future 1)
[10:26:12.627]  length: 0 (resolved future 2)
[10:26:12.627] resolve() on list ... DONE
[10:26:12.627] - globals: [2] ‘a’, ‘ii’
[10:26:12.627] Resolving futures part of globals (recursively) ... DONE
[10:26:12.627] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:12.628] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:26:12.628] - globals: [2] ‘a’, ‘ii’
[10:26:12.628] 
[10:26:12.628] getGlobalsAndPackages() ... DONE
[10:26:12.628] run() for ‘Future’ ...
[10:26:12.629] - state: ‘created’
[10:26:12.629] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.632] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.633] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.633]   - Field: ‘label’
[10:26:12.633]   - Field: ‘local’
[10:26:12.633]   - Field: ‘owner’
[10:26:12.633]   - Field: ‘envir’
[10:26:12.633]   - Field: ‘workers’
[10:26:12.633]   - Field: ‘packages’
[10:26:12.633]   - Field: ‘gc’
[10:26:12.633]   - Field: ‘job’
[10:26:12.634]   - Field: ‘conditions’
[10:26:12.634]   - Field: ‘expr’
[10:26:12.634]   - Field: ‘uuid’
[10:26:12.634]   - Field: ‘seed’
[10:26:12.634]   - Field: ‘version’
[10:26:12.634]   - Field: ‘result’
[10:26:12.634]   - Field: ‘asynchronous’
[10:26:12.634]   - Field: ‘calls’
[10:26:12.634]   - Field: ‘globals’
[10:26:12.634]   - Field: ‘stdout’
[10:26:12.634]   - Field: ‘earlySignal’
[10:26:12.635]   - Field: ‘lazy’
[10:26:12.635]   - Field: ‘state’
[10:26:12.635] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.635] - Launch lazy future ...
[10:26:12.635] Packages needed by the future expression (n = 0): <none>
[10:26:12.635] Packages needed by future strategies (n = 0): <none>
[10:26:12.636] {
[10:26:12.636]     {
[10:26:12.636]         {
[10:26:12.636]             ...future.startTime <- base::Sys.time()
[10:26:12.636]             {
[10:26:12.636]                 {
[10:26:12.636]                   {
[10:26:12.636]                     {
[10:26:12.636]                       base::local({
[10:26:12.636]                         has_future <- base::requireNamespace("future", 
[10:26:12.636]                           quietly = TRUE)
[10:26:12.636]                         if (has_future) {
[10:26:12.636]                           ns <- base::getNamespace("future")
[10:26:12.636]                           version <- ns[[".package"]][["version"]]
[10:26:12.636]                           if (is.null(version)) 
[10:26:12.636]                             version <- utils::packageVersion("future")
[10:26:12.636]                         }
[10:26:12.636]                         else {
[10:26:12.636]                           version <- NULL
[10:26:12.636]                         }
[10:26:12.636]                         if (!has_future || version < "1.8.0") {
[10:26:12.636]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.636]                             "", base::R.version$version.string), 
[10:26:12.636]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:12.636]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:12.636]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.636]                               "release", "version")], collapse = " "), 
[10:26:12.636]                             hostname = base::Sys.info()[["nodename"]])
[10:26:12.636]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.636]                             info)
[10:26:12.636]                           info <- base::paste(info, collapse = "; ")
[10:26:12.636]                           if (!has_future) {
[10:26:12.636]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.636]                               info)
[10:26:12.636]                           }
[10:26:12.636]                           else {
[10:26:12.636]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.636]                               info, version)
[10:26:12.636]                           }
[10:26:12.636]                           base::stop(msg)
[10:26:12.636]                         }
[10:26:12.636]                       })
[10:26:12.636]                     }
[10:26:12.636]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.636]                     base::options(mc.cores = 1L)
[10:26:12.636]                   }
[10:26:12.636]                   options(future.plan = NULL)
[10:26:12.636]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.636]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.636]                 }
[10:26:12.636]                 ...future.workdir <- getwd()
[10:26:12.636]             }
[10:26:12.636]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.636]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.636]         }
[10:26:12.636]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.636]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:12.636]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.636]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.636]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.636]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.636]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.636]             base::names(...future.oldOptions))
[10:26:12.636]     }
[10:26:12.636]     if (FALSE) {
[10:26:12.636]     }
[10:26:12.636]     else {
[10:26:12.636]         if (TRUE) {
[10:26:12.636]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.636]                 open = "w")
[10:26:12.636]         }
[10:26:12.636]         else {
[10:26:12.636]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.636]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.636]         }
[10:26:12.636]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.636]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.636]             base::sink(type = "output", split = FALSE)
[10:26:12.636]             base::close(...future.stdout)
[10:26:12.636]         }, add = TRUE)
[10:26:12.636]     }
[10:26:12.636]     ...future.frame <- base::sys.nframe()
[10:26:12.636]     ...future.conditions <- base::list()
[10:26:12.636]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.636]     if (FALSE) {
[10:26:12.636]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.636]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.636]     }
[10:26:12.636]     ...future.result <- base::tryCatch({
[10:26:12.636]         base::withCallingHandlers({
[10:26:12.636]             ...future.value <- base::withVisible(base::local({
[10:26:12.636]                 withCallingHandlers({
[10:26:12.636]                   {
[10:26:12.636]                     b <- a * ii
[10:26:12.636]                     a <- 0
[10:26:12.636]                     b
[10:26:12.636]                   }
[10:26:12.636]                 }, immediateCondition = function(cond) {
[10:26:12.636]                   save_rds <- function (object, pathname, ...) 
[10:26:12.636]                   {
[10:26:12.636]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.636]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.636]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.636]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.636]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.636]                         fi_tmp[["mtime"]])
[10:26:12.636]                     }
[10:26:12.636]                     tryCatch({
[10:26:12.636]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.636]                     }, error = function(ex) {
[10:26:12.636]                       msg <- conditionMessage(ex)
[10:26:12.636]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.636]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.636]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.636]                         fi_tmp[["mtime"]], msg)
[10:26:12.636]                       ex$message <- msg
[10:26:12.636]                       stop(ex)
[10:26:12.636]                     })
[10:26:12.636]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.636]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.636]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.636]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.636]                       fi <- file.info(pathname)
[10:26:12.636]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.636]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.636]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.636]                         fi[["size"]], fi[["mtime"]])
[10:26:12.636]                       stop(msg)
[10:26:12.636]                     }
[10:26:12.636]                     invisible(pathname)
[10:26:12.636]                   }
[10:26:12.636]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.636]                     rootPath = tempdir()) 
[10:26:12.636]                   {
[10:26:12.636]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.636]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.636]                       tmpdir = path, fileext = ".rds")
[10:26:12.636]                     save_rds(obj, file)
[10:26:12.636]                   }
[10:26:12.636]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.636]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.636]                   {
[10:26:12.636]                     inherits <- base::inherits
[10:26:12.636]                     invokeRestart <- base::invokeRestart
[10:26:12.636]                     is.null <- base::is.null
[10:26:12.636]                     muffled <- FALSE
[10:26:12.636]                     if (inherits(cond, "message")) {
[10:26:12.636]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.636]                       if (muffled) 
[10:26:12.636]                         invokeRestart("muffleMessage")
[10:26:12.636]                     }
[10:26:12.636]                     else if (inherits(cond, "warning")) {
[10:26:12.636]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.636]                       if (muffled) 
[10:26:12.636]                         invokeRestart("muffleWarning")
[10:26:12.636]                     }
[10:26:12.636]                     else if (inherits(cond, "condition")) {
[10:26:12.636]                       if (!is.null(pattern)) {
[10:26:12.636]                         computeRestarts <- base::computeRestarts
[10:26:12.636]                         grepl <- base::grepl
[10:26:12.636]                         restarts <- computeRestarts(cond)
[10:26:12.636]                         for (restart in restarts) {
[10:26:12.636]                           name <- restart$name
[10:26:12.636]                           if (is.null(name)) 
[10:26:12.636]                             next
[10:26:12.636]                           if (!grepl(pattern, name)) 
[10:26:12.636]                             next
[10:26:12.636]                           invokeRestart(restart)
[10:26:12.636]                           muffled <- TRUE
[10:26:12.636]                           break
[10:26:12.636]                         }
[10:26:12.636]                       }
[10:26:12.636]                     }
[10:26:12.636]                     invisible(muffled)
[10:26:12.636]                   }
[10:26:12.636]                   muffleCondition(cond)
[10:26:12.636]                 })
[10:26:12.636]             }))
[10:26:12.636]             future::FutureResult(value = ...future.value$value, 
[10:26:12.636]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.636]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.636]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.636]                     ...future.globalenv.names))
[10:26:12.636]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.636]         }, condition = base::local({
[10:26:12.636]             c <- base::c
[10:26:12.636]             inherits <- base::inherits
[10:26:12.636]             invokeRestart <- base::invokeRestart
[10:26:12.636]             length <- base::length
[10:26:12.636]             list <- base::list
[10:26:12.636]             seq.int <- base::seq.int
[10:26:12.636]             signalCondition <- base::signalCondition
[10:26:12.636]             sys.calls <- base::sys.calls
[10:26:12.636]             `[[` <- base::`[[`
[10:26:12.636]             `+` <- base::`+`
[10:26:12.636]             `<<-` <- base::`<<-`
[10:26:12.636]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.636]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.636]                   3L)]
[10:26:12.636]             }
[10:26:12.636]             function(cond) {
[10:26:12.636]                 is_error <- inherits(cond, "error")
[10:26:12.636]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.636]                   NULL)
[10:26:12.636]                 if (is_error) {
[10:26:12.636]                   sessionInformation <- function() {
[10:26:12.636]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.636]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.636]                       search = base::search(), system = base::Sys.info())
[10:26:12.636]                   }
[10:26:12.636]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.636]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.636]                     cond$call), session = sessionInformation(), 
[10:26:12.636]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.636]                   signalCondition(cond)
[10:26:12.636]                 }
[10:26:12.636]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.636]                 "immediateCondition"))) {
[10:26:12.636]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.636]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.636]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.636]                   if (TRUE && !signal) {
[10:26:12.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.636]                     {
[10:26:12.636]                       inherits <- base::inherits
[10:26:12.636]                       invokeRestart <- base::invokeRestart
[10:26:12.636]                       is.null <- base::is.null
[10:26:12.636]                       muffled <- FALSE
[10:26:12.636]                       if (inherits(cond, "message")) {
[10:26:12.636]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.636]                         if (muffled) 
[10:26:12.636]                           invokeRestart("muffleMessage")
[10:26:12.636]                       }
[10:26:12.636]                       else if (inherits(cond, "warning")) {
[10:26:12.636]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.636]                         if (muffled) 
[10:26:12.636]                           invokeRestart("muffleWarning")
[10:26:12.636]                       }
[10:26:12.636]                       else if (inherits(cond, "condition")) {
[10:26:12.636]                         if (!is.null(pattern)) {
[10:26:12.636]                           computeRestarts <- base::computeRestarts
[10:26:12.636]                           grepl <- base::grepl
[10:26:12.636]                           restarts <- computeRestarts(cond)
[10:26:12.636]                           for (restart in restarts) {
[10:26:12.636]                             name <- restart$name
[10:26:12.636]                             if (is.null(name)) 
[10:26:12.636]                               next
[10:26:12.636]                             if (!grepl(pattern, name)) 
[10:26:12.636]                               next
[10:26:12.636]                             invokeRestart(restart)
[10:26:12.636]                             muffled <- TRUE
[10:26:12.636]                             break
[10:26:12.636]                           }
[10:26:12.636]                         }
[10:26:12.636]                       }
[10:26:12.636]                       invisible(muffled)
[10:26:12.636]                     }
[10:26:12.636]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.636]                   }
[10:26:12.636]                 }
[10:26:12.636]                 else {
[10:26:12.636]                   if (TRUE) {
[10:26:12.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.636]                     {
[10:26:12.636]                       inherits <- base::inherits
[10:26:12.636]                       invokeRestart <- base::invokeRestart
[10:26:12.636]                       is.null <- base::is.null
[10:26:12.636]                       muffled <- FALSE
[10:26:12.636]                       if (inherits(cond, "message")) {
[10:26:12.636]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.636]                         if (muffled) 
[10:26:12.636]                           invokeRestart("muffleMessage")
[10:26:12.636]                       }
[10:26:12.636]                       else if (inherits(cond, "warning")) {
[10:26:12.636]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.636]                         if (muffled) 
[10:26:12.636]                           invokeRestart("muffleWarning")
[10:26:12.636]                       }
[10:26:12.636]                       else if (inherits(cond, "condition")) {
[10:26:12.636]                         if (!is.null(pattern)) {
[10:26:12.636]                           computeRestarts <- base::computeRestarts
[10:26:12.636]                           grepl <- base::grepl
[10:26:12.636]                           restarts <- computeRestarts(cond)
[10:26:12.636]                           for (restart in restarts) {
[10:26:12.636]                             name <- restart$name
[10:26:12.636]                             if (is.null(name)) 
[10:26:12.636]                               next
[10:26:12.636]                             if (!grepl(pattern, name)) 
[10:26:12.636]                               next
[10:26:12.636]                             invokeRestart(restart)
[10:26:12.636]                             muffled <- TRUE
[10:26:12.636]                             break
[10:26:12.636]                           }
[10:26:12.636]                         }
[10:26:12.636]                       }
[10:26:12.636]                       invisible(muffled)
[10:26:12.636]                     }
[10:26:12.636]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.636]                   }
[10:26:12.636]                 }
[10:26:12.636]             }
[10:26:12.636]         }))
[10:26:12.636]     }, error = function(ex) {
[10:26:12.636]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.636]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.636]                 ...future.rng), started = ...future.startTime, 
[10:26:12.636]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.636]             version = "1.8"), class = "FutureResult")
[10:26:12.636]     }, finally = {
[10:26:12.636]         if (!identical(...future.workdir, getwd())) 
[10:26:12.636]             setwd(...future.workdir)
[10:26:12.636]         {
[10:26:12.636]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.636]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.636]             }
[10:26:12.636]             base::options(...future.oldOptions)
[10:26:12.636]             if (.Platform$OS.type == "windows") {
[10:26:12.636]                 old_names <- names(...future.oldEnvVars)
[10:26:12.636]                 envs <- base::Sys.getenv()
[10:26:12.636]                 names <- names(envs)
[10:26:12.636]                 common <- intersect(names, old_names)
[10:26:12.636]                 added <- setdiff(names, old_names)
[10:26:12.636]                 removed <- setdiff(old_names, names)
[10:26:12.636]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.636]                   envs[common]]
[10:26:12.636]                 NAMES <- toupper(changed)
[10:26:12.636]                 args <- list()
[10:26:12.636]                 for (kk in seq_along(NAMES)) {
[10:26:12.636]                   name <- changed[[kk]]
[10:26:12.636]                   NAME <- NAMES[[kk]]
[10:26:12.636]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.636]                     next
[10:26:12.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.636]                 }
[10:26:12.636]                 NAMES <- toupper(added)
[10:26:12.636]                 for (kk in seq_along(NAMES)) {
[10:26:12.636]                   name <- added[[kk]]
[10:26:12.636]                   NAME <- NAMES[[kk]]
[10:26:12.636]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.636]                     next
[10:26:12.636]                   args[[name]] <- ""
[10:26:12.636]                 }
[10:26:12.636]                 NAMES <- toupper(removed)
[10:26:12.636]                 for (kk in seq_along(NAMES)) {
[10:26:12.636]                   name <- removed[[kk]]
[10:26:12.636]                   NAME <- NAMES[[kk]]
[10:26:12.636]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.636]                     next
[10:26:12.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.636]                 }
[10:26:12.636]                 if (length(args) > 0) 
[10:26:12.636]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.636]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.636]             }
[10:26:12.636]             else {
[10:26:12.636]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.636]             }
[10:26:12.636]             {
[10:26:12.636]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.636]                   0L) {
[10:26:12.636]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.636]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.636]                   base::options(opts)
[10:26:12.636]                 }
[10:26:12.636]                 {
[10:26:12.636]                   {
[10:26:12.636]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.636]                     NULL
[10:26:12.636]                   }
[10:26:12.636]                   options(future.plan = NULL)
[10:26:12.636]                   if (is.na(NA_character_)) 
[10:26:12.636]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.636]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.636]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.636]                     envir = parent.frame()) 
[10:26:12.636]                   {
[10:26:12.636]                     default_workers <- missing(workers)
[10:26:12.636]                     if (is.function(workers)) 
[10:26:12.636]                       workers <- workers()
[10:26:12.636]                     workers <- structure(as.integer(workers), 
[10:26:12.636]                       class = class(workers))
[10:26:12.636]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.636]                       1L)
[10:26:12.636]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.636]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.636]                       if (default_workers) 
[10:26:12.636]                         supportsMulticore(warn = TRUE)
[10:26:12.636]                       return(sequential(..., envir = envir))
[10:26:12.636]                     }
[10:26:12.636]                     oopts <- options(mc.cores = workers)
[10:26:12.636]                     on.exit(options(oopts))
[10:26:12.636]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.636]                       envir = envir)
[10:26:12.636]                     if (!future$lazy) 
[10:26:12.636]                       future <- run(future)
[10:26:12.636]                     invisible(future)
[10:26:12.636]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.636]                 }
[10:26:12.636]             }
[10:26:12.636]         }
[10:26:12.636]     })
[10:26:12.636]     if (TRUE) {
[10:26:12.636]         base::sink(type = "output", split = FALSE)
[10:26:12.636]         if (TRUE) {
[10:26:12.636]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.636]         }
[10:26:12.636]         else {
[10:26:12.636]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.636]         }
[10:26:12.636]         base::close(...future.stdout)
[10:26:12.636]         ...future.stdout <- NULL
[10:26:12.636]     }
[10:26:12.636]     ...future.result$conditions <- ...future.conditions
[10:26:12.636]     ...future.result$finished <- base::Sys.time()
[10:26:12.636]     ...future.result
[10:26:12.636] }
[10:26:12.638] assign_globals() ...
[10:26:12.638] List of 2
[10:26:12.638]  $ a : num 1
[10:26:12.638]  $ ii: int 1
[10:26:12.638]  - attr(*, "where")=List of 2
[10:26:12.638]   ..$ a :<environment: R_EmptyEnv> 
[10:26:12.638]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:12.638]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:12.638]  - attr(*, "resolved")= logi TRUE
[10:26:12.638]  - attr(*, "total_size")= num 112
[10:26:12.638]  - attr(*, "already-done")= logi TRUE
[10:26:12.641] - copied ‘a’ to environment
[10:26:12.642] - copied ‘ii’ to environment
[10:26:12.642] assign_globals() ... done
[10:26:12.642] requestCore(): workers = 2
[10:26:12.644] MulticoreFuture started
[10:26:12.644] - Launch lazy future ... done
[10:26:12.644] run() for ‘MulticoreFuture’ ... done
[10:26:12.644] result() for MulticoreFuture ...
[10:26:12.645] plan(): Setting new future strategy stack:
[10:26:12.645] List of future strategies:
[10:26:12.645] 1. sequential:
[10:26:12.645]    - args: function (..., envir = parent.frame())
[10:26:12.645]    - tweaked: FALSE
[10:26:12.645]    - call: NULL
[10:26:12.646] plan(): nbrOfWorkers() = 1
[10:26:12.648] plan(): Setting new future strategy stack:
[10:26:12.648] List of future strategies:
[10:26:12.648] 1. multicore:
[10:26:12.648]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.648]    - tweaked: FALSE
[10:26:12.648]    - call: plan(strategy)
[10:26:12.658] plan(): nbrOfWorkers() = 2
[10:26:12.659] result() for MulticoreFuture ...
[10:26:12.659] result() for MulticoreFuture ... done
[10:26:12.659] result() for MulticoreFuture ... done
[10:26:12.659] result() for MulticoreFuture ...
[10:26:12.659] result() for MulticoreFuture ... done
[10:26:12.660] run() for ‘Future’ ...
[10:26:12.660] - state: ‘created’
[10:26:12.660] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.667] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.667] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.667]   - Field: ‘label’
[10:26:12.667]   - Field: ‘local’
[10:26:12.668]   - Field: ‘owner’
[10:26:12.668]   - Field: ‘envir’
[10:26:12.668]   - Field: ‘workers’
[10:26:12.668]   - Field: ‘packages’
[10:26:12.668]   - Field: ‘gc’
[10:26:12.668]   - Field: ‘job’
[10:26:12.669]   - Field: ‘conditions’
[10:26:12.669]   - Field: ‘expr’
[10:26:12.669]   - Field: ‘uuid’
[10:26:12.669]   - Field: ‘seed’
[10:26:12.669]   - Field: ‘version’
[10:26:12.669]   - Field: ‘result’
[10:26:12.669]   - Field: ‘asynchronous’
[10:26:12.670]   - Field: ‘calls’
[10:26:12.670]   - Field: ‘globals’
[10:26:12.670]   - Field: ‘stdout’
[10:26:12.670]   - Field: ‘earlySignal’
[10:26:12.670]   - Field: ‘lazy’
[10:26:12.670]   - Field: ‘state’
[10:26:12.671] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.671] - Launch lazy future ...
[10:26:12.671] Packages needed by the future expression (n = 0): <none>
[10:26:12.671] Packages needed by future strategies (n = 0): <none>
[10:26:12.672] {
[10:26:12.672]     {
[10:26:12.672]         {
[10:26:12.672]             ...future.startTime <- base::Sys.time()
[10:26:12.672]             {
[10:26:12.672]                 {
[10:26:12.672]                   {
[10:26:12.672]                     {
[10:26:12.672]                       base::local({
[10:26:12.672]                         has_future <- base::requireNamespace("future", 
[10:26:12.672]                           quietly = TRUE)
[10:26:12.672]                         if (has_future) {
[10:26:12.672]                           ns <- base::getNamespace("future")
[10:26:12.672]                           version <- ns[[".package"]][["version"]]
[10:26:12.672]                           if (is.null(version)) 
[10:26:12.672]                             version <- utils::packageVersion("future")
[10:26:12.672]                         }
[10:26:12.672]                         else {
[10:26:12.672]                           version <- NULL
[10:26:12.672]                         }
[10:26:12.672]                         if (!has_future || version < "1.8.0") {
[10:26:12.672]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.672]                             "", base::R.version$version.string), 
[10:26:12.672]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:12.672]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:12.672]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.672]                               "release", "version")], collapse = " "), 
[10:26:12.672]                             hostname = base::Sys.info()[["nodename"]])
[10:26:12.672]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.672]                             info)
[10:26:12.672]                           info <- base::paste(info, collapse = "; ")
[10:26:12.672]                           if (!has_future) {
[10:26:12.672]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.672]                               info)
[10:26:12.672]                           }
[10:26:12.672]                           else {
[10:26:12.672]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.672]                               info, version)
[10:26:12.672]                           }
[10:26:12.672]                           base::stop(msg)
[10:26:12.672]                         }
[10:26:12.672]                       })
[10:26:12.672]                     }
[10:26:12.672]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.672]                     base::options(mc.cores = 1L)
[10:26:12.672]                   }
[10:26:12.672]                   options(future.plan = NULL)
[10:26:12.672]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.672]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.672]                 }
[10:26:12.672]                 ...future.workdir <- getwd()
[10:26:12.672]             }
[10:26:12.672]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.672]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.672]         }
[10:26:12.672]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.672]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:12.672]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.672]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.672]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.672]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.672]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.672]             base::names(...future.oldOptions))
[10:26:12.672]     }
[10:26:12.672]     if (FALSE) {
[10:26:12.672]     }
[10:26:12.672]     else {
[10:26:12.672]         if (TRUE) {
[10:26:12.672]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.672]                 open = "w")
[10:26:12.672]         }
[10:26:12.672]         else {
[10:26:12.672]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.672]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.672]         }
[10:26:12.672]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.672]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.672]             base::sink(type = "output", split = FALSE)
[10:26:12.672]             base::close(...future.stdout)
[10:26:12.672]         }, add = TRUE)
[10:26:12.672]     }
[10:26:12.672]     ...future.frame <- base::sys.nframe()
[10:26:12.672]     ...future.conditions <- base::list()
[10:26:12.672]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.672]     if (FALSE) {
[10:26:12.672]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.672]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.672]     }
[10:26:12.672]     ...future.result <- base::tryCatch({
[10:26:12.672]         base::withCallingHandlers({
[10:26:12.672]             ...future.value <- base::withVisible(base::local({
[10:26:12.672]                 withCallingHandlers({
[10:26:12.672]                   {
[10:26:12.672]                     b <- a * ii
[10:26:12.672]                     a <- 0
[10:26:12.672]                     b
[10:26:12.672]                   }
[10:26:12.672]                 }, immediateCondition = function(cond) {
[10:26:12.672]                   save_rds <- function (object, pathname, ...) 
[10:26:12.672]                   {
[10:26:12.672]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.672]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.672]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.672]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.672]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.672]                         fi_tmp[["mtime"]])
[10:26:12.672]                     }
[10:26:12.672]                     tryCatch({
[10:26:12.672]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.672]                     }, error = function(ex) {
[10:26:12.672]                       msg <- conditionMessage(ex)
[10:26:12.672]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.672]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.672]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.672]                         fi_tmp[["mtime"]], msg)
[10:26:12.672]                       ex$message <- msg
[10:26:12.672]                       stop(ex)
[10:26:12.672]                     })
[10:26:12.672]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.672]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.672]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.672]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.672]                       fi <- file.info(pathname)
[10:26:12.672]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.672]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.672]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.672]                         fi[["size"]], fi[["mtime"]])
[10:26:12.672]                       stop(msg)
[10:26:12.672]                     }
[10:26:12.672]                     invisible(pathname)
[10:26:12.672]                   }
[10:26:12.672]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.672]                     rootPath = tempdir()) 
[10:26:12.672]                   {
[10:26:12.672]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.672]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.672]                       tmpdir = path, fileext = ".rds")
[10:26:12.672]                     save_rds(obj, file)
[10:26:12.672]                   }
[10:26:12.672]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.672]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.672]                   {
[10:26:12.672]                     inherits <- base::inherits
[10:26:12.672]                     invokeRestart <- base::invokeRestart
[10:26:12.672]                     is.null <- base::is.null
[10:26:12.672]                     muffled <- FALSE
[10:26:12.672]                     if (inherits(cond, "message")) {
[10:26:12.672]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.672]                       if (muffled) 
[10:26:12.672]                         invokeRestart("muffleMessage")
[10:26:12.672]                     }
[10:26:12.672]                     else if (inherits(cond, "warning")) {
[10:26:12.672]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.672]                       if (muffled) 
[10:26:12.672]                         invokeRestart("muffleWarning")
[10:26:12.672]                     }
[10:26:12.672]                     else if (inherits(cond, "condition")) {
[10:26:12.672]                       if (!is.null(pattern)) {
[10:26:12.672]                         computeRestarts <- base::computeRestarts
[10:26:12.672]                         grepl <- base::grepl
[10:26:12.672]                         restarts <- computeRestarts(cond)
[10:26:12.672]                         for (restart in restarts) {
[10:26:12.672]                           name <- restart$name
[10:26:12.672]                           if (is.null(name)) 
[10:26:12.672]                             next
[10:26:12.672]                           if (!grepl(pattern, name)) 
[10:26:12.672]                             next
[10:26:12.672]                           invokeRestart(restart)
[10:26:12.672]                           muffled <- TRUE
[10:26:12.672]                           break
[10:26:12.672]                         }
[10:26:12.672]                       }
[10:26:12.672]                     }
[10:26:12.672]                     invisible(muffled)
[10:26:12.672]                   }
[10:26:12.672]                   muffleCondition(cond)
[10:26:12.672]                 })
[10:26:12.672]             }))
[10:26:12.672]             future::FutureResult(value = ...future.value$value, 
[10:26:12.672]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.672]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.672]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.672]                     ...future.globalenv.names))
[10:26:12.672]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.672]         }, condition = base::local({
[10:26:12.672]             c <- base::c
[10:26:12.672]             inherits <- base::inherits
[10:26:12.672]             invokeRestart <- base::invokeRestart
[10:26:12.672]             length <- base::length
[10:26:12.672]             list <- base::list
[10:26:12.672]             seq.int <- base::seq.int
[10:26:12.672]             signalCondition <- base::signalCondition
[10:26:12.672]             sys.calls <- base::sys.calls
[10:26:12.672]             `[[` <- base::`[[`
[10:26:12.672]             `+` <- base::`+`
[10:26:12.672]             `<<-` <- base::`<<-`
[10:26:12.672]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.672]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.672]                   3L)]
[10:26:12.672]             }
[10:26:12.672]             function(cond) {
[10:26:12.672]                 is_error <- inherits(cond, "error")
[10:26:12.672]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.672]                   NULL)
[10:26:12.672]                 if (is_error) {
[10:26:12.672]                   sessionInformation <- function() {
[10:26:12.672]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.672]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.672]                       search = base::search(), system = base::Sys.info())
[10:26:12.672]                   }
[10:26:12.672]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.672]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.672]                     cond$call), session = sessionInformation(), 
[10:26:12.672]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.672]                   signalCondition(cond)
[10:26:12.672]                 }
[10:26:12.672]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.672]                 "immediateCondition"))) {
[10:26:12.672]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.672]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.672]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.672]                   if (TRUE && !signal) {
[10:26:12.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.672]                     {
[10:26:12.672]                       inherits <- base::inherits
[10:26:12.672]                       invokeRestart <- base::invokeRestart
[10:26:12.672]                       is.null <- base::is.null
[10:26:12.672]                       muffled <- FALSE
[10:26:12.672]                       if (inherits(cond, "message")) {
[10:26:12.672]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.672]                         if (muffled) 
[10:26:12.672]                           invokeRestart("muffleMessage")
[10:26:12.672]                       }
[10:26:12.672]                       else if (inherits(cond, "warning")) {
[10:26:12.672]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.672]                         if (muffled) 
[10:26:12.672]                           invokeRestart("muffleWarning")
[10:26:12.672]                       }
[10:26:12.672]                       else if (inherits(cond, "condition")) {
[10:26:12.672]                         if (!is.null(pattern)) {
[10:26:12.672]                           computeRestarts <- base::computeRestarts
[10:26:12.672]                           grepl <- base::grepl
[10:26:12.672]                           restarts <- computeRestarts(cond)
[10:26:12.672]                           for (restart in restarts) {
[10:26:12.672]                             name <- restart$name
[10:26:12.672]                             if (is.null(name)) 
[10:26:12.672]                               next
[10:26:12.672]                             if (!grepl(pattern, name)) 
[10:26:12.672]                               next
[10:26:12.672]                             invokeRestart(restart)
[10:26:12.672]                             muffled <- TRUE
[10:26:12.672]                             break
[10:26:12.672]                           }
[10:26:12.672]                         }
[10:26:12.672]                       }
[10:26:12.672]                       invisible(muffled)
[10:26:12.672]                     }
[10:26:12.672]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.672]                   }
[10:26:12.672]                 }
[10:26:12.672]                 else {
[10:26:12.672]                   if (TRUE) {
[10:26:12.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.672]                     {
[10:26:12.672]                       inherits <- base::inherits
[10:26:12.672]                       invokeRestart <- base::invokeRestart
[10:26:12.672]                       is.null <- base::is.null
[10:26:12.672]                       muffled <- FALSE
[10:26:12.672]                       if (inherits(cond, "message")) {
[10:26:12.672]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.672]                         if (muffled) 
[10:26:12.672]                           invokeRestart("muffleMessage")
[10:26:12.672]                       }
[10:26:12.672]                       else if (inherits(cond, "warning")) {
[10:26:12.672]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.672]                         if (muffled) 
[10:26:12.672]                           invokeRestart("muffleWarning")
[10:26:12.672]                       }
[10:26:12.672]                       else if (inherits(cond, "condition")) {
[10:26:12.672]                         if (!is.null(pattern)) {
[10:26:12.672]                           computeRestarts <- base::computeRestarts
[10:26:12.672]                           grepl <- base::grepl
[10:26:12.672]                           restarts <- computeRestarts(cond)
[10:26:12.672]                           for (restart in restarts) {
[10:26:12.672]                             name <- restart$name
[10:26:12.672]                             if (is.null(name)) 
[10:26:12.672]                               next
[10:26:12.672]                             if (!grepl(pattern, name)) 
[10:26:12.672]                               next
[10:26:12.672]                             invokeRestart(restart)
[10:26:12.672]                             muffled <- TRUE
[10:26:12.672]                             break
[10:26:12.672]                           }
[10:26:12.672]                         }
[10:26:12.672]                       }
[10:26:12.672]                       invisible(muffled)
[10:26:12.672]                     }
[10:26:12.672]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.672]                   }
[10:26:12.672]                 }
[10:26:12.672]             }
[10:26:12.672]         }))
[10:26:12.672]     }, error = function(ex) {
[10:26:12.672]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.672]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.672]                 ...future.rng), started = ...future.startTime, 
[10:26:12.672]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.672]             version = "1.8"), class = "FutureResult")
[10:26:12.672]     }, finally = {
[10:26:12.672]         if (!identical(...future.workdir, getwd())) 
[10:26:12.672]             setwd(...future.workdir)
[10:26:12.672]         {
[10:26:12.672]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.672]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.672]             }
[10:26:12.672]             base::options(...future.oldOptions)
[10:26:12.672]             if (.Platform$OS.type == "windows") {
[10:26:12.672]                 old_names <- names(...future.oldEnvVars)
[10:26:12.672]                 envs <- base::Sys.getenv()
[10:26:12.672]                 names <- names(envs)
[10:26:12.672]                 common <- intersect(names, old_names)
[10:26:12.672]                 added <- setdiff(names, old_names)
[10:26:12.672]                 removed <- setdiff(old_names, names)
[10:26:12.672]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.672]                   envs[common]]
[10:26:12.672]                 NAMES <- toupper(changed)
[10:26:12.672]                 args <- list()
[10:26:12.672]                 for (kk in seq_along(NAMES)) {
[10:26:12.672]                   name <- changed[[kk]]
[10:26:12.672]                   NAME <- NAMES[[kk]]
[10:26:12.672]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.672]                     next
[10:26:12.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.672]                 }
[10:26:12.672]                 NAMES <- toupper(added)
[10:26:12.672]                 for (kk in seq_along(NAMES)) {
[10:26:12.672]                   name <- added[[kk]]
[10:26:12.672]                   NAME <- NAMES[[kk]]
[10:26:12.672]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.672]                     next
[10:26:12.672]                   args[[name]] <- ""
[10:26:12.672]                 }
[10:26:12.672]                 NAMES <- toupper(removed)
[10:26:12.672]                 for (kk in seq_along(NAMES)) {
[10:26:12.672]                   name <- removed[[kk]]
[10:26:12.672]                   NAME <- NAMES[[kk]]
[10:26:12.672]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.672]                     next
[10:26:12.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.672]                 }
[10:26:12.672]                 if (length(args) > 0) 
[10:26:12.672]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.672]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.672]             }
[10:26:12.672]             else {
[10:26:12.672]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.672]             }
[10:26:12.672]             {
[10:26:12.672]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.672]                   0L) {
[10:26:12.672]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.672]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.672]                   base::options(opts)
[10:26:12.672]                 }
[10:26:12.672]                 {
[10:26:12.672]                   {
[10:26:12.672]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.672]                     NULL
[10:26:12.672]                   }
[10:26:12.672]                   options(future.plan = NULL)
[10:26:12.672]                   if (is.na(NA_character_)) 
[10:26:12.672]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.672]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.672]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.672]                     envir = parent.frame()) 
[10:26:12.672]                   {
[10:26:12.672]                     default_workers <- missing(workers)
[10:26:12.672]                     if (is.function(workers)) 
[10:26:12.672]                       workers <- workers()
[10:26:12.672]                     workers <- structure(as.integer(workers), 
[10:26:12.672]                       class = class(workers))
[10:26:12.672]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.672]                       1L)
[10:26:12.672]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.672]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.672]                       if (default_workers) 
[10:26:12.672]                         supportsMulticore(warn = TRUE)
[10:26:12.672]                       return(sequential(..., envir = envir))
[10:26:12.672]                     }
[10:26:12.672]                     oopts <- options(mc.cores = workers)
[10:26:12.672]                     on.exit(options(oopts))
[10:26:12.672]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.672]                       envir = envir)
[10:26:12.672]                     if (!future$lazy) 
[10:26:12.672]                       future <- run(future)
[10:26:12.672]                     invisible(future)
[10:26:12.672]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.672]                 }
[10:26:12.672]             }
[10:26:12.672]         }
[10:26:12.672]     })
[10:26:12.672]     if (TRUE) {
[10:26:12.672]         base::sink(type = "output", split = FALSE)
[10:26:12.672]         if (TRUE) {
[10:26:12.672]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.672]         }
[10:26:12.672]         else {
[10:26:12.672]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.672]         }
[10:26:12.672]         base::close(...future.stdout)
[10:26:12.672]         ...future.stdout <- NULL
[10:26:12.672]     }
[10:26:12.672]     ...future.result$conditions <- ...future.conditions
[10:26:12.672]     ...future.result$finished <- base::Sys.time()
[10:26:12.672]     ...future.result
[10:26:12.672] }
[10:26:12.675] assign_globals() ...
[10:26:12.675] List of 2
[10:26:12.675]  $ a : num 1
[10:26:12.675]  $ ii: int 2
[10:26:12.675]  - attr(*, "where")=List of 2
[10:26:12.675]   ..$ a :<environment: R_EmptyEnv> 
[10:26:12.675]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:12.675]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:12.675]  - attr(*, "resolved")= logi TRUE
[10:26:12.675]  - attr(*, "total_size")= num 112
[10:26:12.675]  - attr(*, "already-done")= logi TRUE
[10:26:12.679] - copied ‘a’ to environment
[10:26:12.679] - copied ‘ii’ to environment
[10:26:12.679] assign_globals() ... done
[10:26:12.679] requestCore(): workers = 2
[10:26:12.681] MulticoreFuture started
[10:26:12.681] - Launch lazy future ... done
[10:26:12.682] run() for ‘MulticoreFuture’ ... done
[10:26:12.682] result() for MulticoreFuture ...
[10:26:12.682] plan(): Setting new future strategy stack:
[10:26:12.682] List of future strategies:
[10:26:12.682] 1. sequential:
[10:26:12.682]    - args: function (..., envir = parent.frame())
[10:26:12.682]    - tweaked: FALSE
[10:26:12.682]    - call: NULL
[10:26:12.683] plan(): nbrOfWorkers() = 1
[10:26:12.685] plan(): Setting new future strategy stack:
[10:26:12.685] List of future strategies:
[10:26:12.685] 1. multicore:
[10:26:12.685]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.685]    - tweaked: FALSE
[10:26:12.685]    - call: plan(strategy)
[10:26:12.691] plan(): nbrOfWorkers() = 2
[10:26:12.692] result() for MulticoreFuture ...
[10:26:12.692] result() for MulticoreFuture ... done
[10:26:12.692] result() for MulticoreFuture ... done
[10:26:12.692] result() for MulticoreFuture ...
[10:26:12.692] result() for MulticoreFuture ... done
[10:26:12.693] run() for ‘Future’ ...
[10:26:12.693] - state: ‘created’
[10:26:12.693] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.698] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.698] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.698]   - Field: ‘label’
[10:26:12.698]   - Field: ‘local’
[10:26:12.698]   - Field: ‘owner’
[10:26:12.698]   - Field: ‘envir’
[10:26:12.698]   - Field: ‘workers’
[10:26:12.699]   - Field: ‘packages’
[10:26:12.699]   - Field: ‘gc’
[10:26:12.699]   - Field: ‘job’
[10:26:12.699]   - Field: ‘conditions’
[10:26:12.699]   - Field: ‘expr’
[10:26:12.699]   - Field: ‘uuid’
[10:26:12.699]   - Field: ‘seed’
[10:26:12.699]   - Field: ‘version’
[10:26:12.699]   - Field: ‘result’
[10:26:12.700]   - Field: ‘asynchronous’
[10:26:12.700]   - Field: ‘calls’
[10:26:12.700]   - Field: ‘globals’
[10:26:12.700]   - Field: ‘stdout’
[10:26:12.700]   - Field: ‘earlySignal’
[10:26:12.700]   - Field: ‘lazy’
[10:26:12.700]   - Field: ‘state’
[10:26:12.700] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.701] - Launch lazy future ...
[10:26:12.701] Packages needed by the future expression (n = 0): <none>
[10:26:12.701] Packages needed by future strategies (n = 0): <none>
[10:26:12.702] {
[10:26:12.702]     {
[10:26:12.702]         {
[10:26:12.702]             ...future.startTime <- base::Sys.time()
[10:26:12.702]             {
[10:26:12.702]                 {
[10:26:12.702]                   {
[10:26:12.702]                     {
[10:26:12.702]                       base::local({
[10:26:12.702]                         has_future <- base::requireNamespace("future", 
[10:26:12.702]                           quietly = TRUE)
[10:26:12.702]                         if (has_future) {
[10:26:12.702]                           ns <- base::getNamespace("future")
[10:26:12.702]                           version <- ns[[".package"]][["version"]]
[10:26:12.702]                           if (is.null(version)) 
[10:26:12.702]                             version <- utils::packageVersion("future")
[10:26:12.702]                         }
[10:26:12.702]                         else {
[10:26:12.702]                           version <- NULL
[10:26:12.702]                         }
[10:26:12.702]                         if (!has_future || version < "1.8.0") {
[10:26:12.702]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.702]                             "", base::R.version$version.string), 
[10:26:12.702]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:12.702]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:12.702]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.702]                               "release", "version")], collapse = " "), 
[10:26:12.702]                             hostname = base::Sys.info()[["nodename"]])
[10:26:12.702]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.702]                             info)
[10:26:12.702]                           info <- base::paste(info, collapse = "; ")
[10:26:12.702]                           if (!has_future) {
[10:26:12.702]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.702]                               info)
[10:26:12.702]                           }
[10:26:12.702]                           else {
[10:26:12.702]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.702]                               info, version)
[10:26:12.702]                           }
[10:26:12.702]                           base::stop(msg)
[10:26:12.702]                         }
[10:26:12.702]                       })
[10:26:12.702]                     }
[10:26:12.702]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.702]                     base::options(mc.cores = 1L)
[10:26:12.702]                   }
[10:26:12.702]                   options(future.plan = NULL)
[10:26:12.702]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.702]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.702]                 }
[10:26:12.702]                 ...future.workdir <- getwd()
[10:26:12.702]             }
[10:26:12.702]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.702]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.702]         }
[10:26:12.702]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.702]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:12.702]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.702]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.702]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.702]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.702]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.702]             base::names(...future.oldOptions))
[10:26:12.702]     }
[10:26:12.702]     if (FALSE) {
[10:26:12.702]     }
[10:26:12.702]     else {
[10:26:12.702]         if (TRUE) {
[10:26:12.702]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.702]                 open = "w")
[10:26:12.702]         }
[10:26:12.702]         else {
[10:26:12.702]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.702]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.702]         }
[10:26:12.702]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.702]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.702]             base::sink(type = "output", split = FALSE)
[10:26:12.702]             base::close(...future.stdout)
[10:26:12.702]         }, add = TRUE)
[10:26:12.702]     }
[10:26:12.702]     ...future.frame <- base::sys.nframe()
[10:26:12.702]     ...future.conditions <- base::list()
[10:26:12.702]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.702]     if (FALSE) {
[10:26:12.702]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.702]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.702]     }
[10:26:12.702]     ...future.result <- base::tryCatch({
[10:26:12.702]         base::withCallingHandlers({
[10:26:12.702]             ...future.value <- base::withVisible(base::local({
[10:26:12.702]                 withCallingHandlers({
[10:26:12.702]                   {
[10:26:12.702]                     b <- a * ii
[10:26:12.702]                     a <- 0
[10:26:12.702]                     b
[10:26:12.702]                   }
[10:26:12.702]                 }, immediateCondition = function(cond) {
[10:26:12.702]                   save_rds <- function (object, pathname, ...) 
[10:26:12.702]                   {
[10:26:12.702]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.702]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.702]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.702]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.702]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.702]                         fi_tmp[["mtime"]])
[10:26:12.702]                     }
[10:26:12.702]                     tryCatch({
[10:26:12.702]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.702]                     }, error = function(ex) {
[10:26:12.702]                       msg <- conditionMessage(ex)
[10:26:12.702]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.702]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.702]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.702]                         fi_tmp[["mtime"]], msg)
[10:26:12.702]                       ex$message <- msg
[10:26:12.702]                       stop(ex)
[10:26:12.702]                     })
[10:26:12.702]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.702]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.702]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.702]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.702]                       fi <- file.info(pathname)
[10:26:12.702]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.702]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.702]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.702]                         fi[["size"]], fi[["mtime"]])
[10:26:12.702]                       stop(msg)
[10:26:12.702]                     }
[10:26:12.702]                     invisible(pathname)
[10:26:12.702]                   }
[10:26:12.702]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.702]                     rootPath = tempdir()) 
[10:26:12.702]                   {
[10:26:12.702]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.702]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.702]                       tmpdir = path, fileext = ".rds")
[10:26:12.702]                     save_rds(obj, file)
[10:26:12.702]                   }
[10:26:12.702]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.702]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.702]                   {
[10:26:12.702]                     inherits <- base::inherits
[10:26:12.702]                     invokeRestart <- base::invokeRestart
[10:26:12.702]                     is.null <- base::is.null
[10:26:12.702]                     muffled <- FALSE
[10:26:12.702]                     if (inherits(cond, "message")) {
[10:26:12.702]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.702]                       if (muffled) 
[10:26:12.702]                         invokeRestart("muffleMessage")
[10:26:12.702]                     }
[10:26:12.702]                     else if (inherits(cond, "warning")) {
[10:26:12.702]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.702]                       if (muffled) 
[10:26:12.702]                         invokeRestart("muffleWarning")
[10:26:12.702]                     }
[10:26:12.702]                     else if (inherits(cond, "condition")) {
[10:26:12.702]                       if (!is.null(pattern)) {
[10:26:12.702]                         computeRestarts <- base::computeRestarts
[10:26:12.702]                         grepl <- base::grepl
[10:26:12.702]                         restarts <- computeRestarts(cond)
[10:26:12.702]                         for (restart in restarts) {
[10:26:12.702]                           name <- restart$name
[10:26:12.702]                           if (is.null(name)) 
[10:26:12.702]                             next
[10:26:12.702]                           if (!grepl(pattern, name)) 
[10:26:12.702]                             next
[10:26:12.702]                           invokeRestart(restart)
[10:26:12.702]                           muffled <- TRUE
[10:26:12.702]                           break
[10:26:12.702]                         }
[10:26:12.702]                       }
[10:26:12.702]                     }
[10:26:12.702]                     invisible(muffled)
[10:26:12.702]                   }
[10:26:12.702]                   muffleCondition(cond)
[10:26:12.702]                 })
[10:26:12.702]             }))
[10:26:12.702]             future::FutureResult(value = ...future.value$value, 
[10:26:12.702]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.702]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.702]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.702]                     ...future.globalenv.names))
[10:26:12.702]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.702]         }, condition = base::local({
[10:26:12.702]             c <- base::c
[10:26:12.702]             inherits <- base::inherits
[10:26:12.702]             invokeRestart <- base::invokeRestart
[10:26:12.702]             length <- base::length
[10:26:12.702]             list <- base::list
[10:26:12.702]             seq.int <- base::seq.int
[10:26:12.702]             signalCondition <- base::signalCondition
[10:26:12.702]             sys.calls <- base::sys.calls
[10:26:12.702]             `[[` <- base::`[[`
[10:26:12.702]             `+` <- base::`+`
[10:26:12.702]             `<<-` <- base::`<<-`
[10:26:12.702]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.702]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.702]                   3L)]
[10:26:12.702]             }
[10:26:12.702]             function(cond) {
[10:26:12.702]                 is_error <- inherits(cond, "error")
[10:26:12.702]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.702]                   NULL)
[10:26:12.702]                 if (is_error) {
[10:26:12.702]                   sessionInformation <- function() {
[10:26:12.702]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.702]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.702]                       search = base::search(), system = base::Sys.info())
[10:26:12.702]                   }
[10:26:12.702]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.702]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.702]                     cond$call), session = sessionInformation(), 
[10:26:12.702]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.702]                   signalCondition(cond)
[10:26:12.702]                 }
[10:26:12.702]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.702]                 "immediateCondition"))) {
[10:26:12.702]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.702]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.702]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.702]                   if (TRUE && !signal) {
[10:26:12.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.702]                     {
[10:26:12.702]                       inherits <- base::inherits
[10:26:12.702]                       invokeRestart <- base::invokeRestart
[10:26:12.702]                       is.null <- base::is.null
[10:26:12.702]                       muffled <- FALSE
[10:26:12.702]                       if (inherits(cond, "message")) {
[10:26:12.702]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.702]                         if (muffled) 
[10:26:12.702]                           invokeRestart("muffleMessage")
[10:26:12.702]                       }
[10:26:12.702]                       else if (inherits(cond, "warning")) {
[10:26:12.702]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.702]                         if (muffled) 
[10:26:12.702]                           invokeRestart("muffleWarning")
[10:26:12.702]                       }
[10:26:12.702]                       else if (inherits(cond, "condition")) {
[10:26:12.702]                         if (!is.null(pattern)) {
[10:26:12.702]                           computeRestarts <- base::computeRestarts
[10:26:12.702]                           grepl <- base::grepl
[10:26:12.702]                           restarts <- computeRestarts(cond)
[10:26:12.702]                           for (restart in restarts) {
[10:26:12.702]                             name <- restart$name
[10:26:12.702]                             if (is.null(name)) 
[10:26:12.702]                               next
[10:26:12.702]                             if (!grepl(pattern, name)) 
[10:26:12.702]                               next
[10:26:12.702]                             invokeRestart(restart)
[10:26:12.702]                             muffled <- TRUE
[10:26:12.702]                             break
[10:26:12.702]                           }
[10:26:12.702]                         }
[10:26:12.702]                       }
[10:26:12.702]                       invisible(muffled)
[10:26:12.702]                     }
[10:26:12.702]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.702]                   }
[10:26:12.702]                 }
[10:26:12.702]                 else {
[10:26:12.702]                   if (TRUE) {
[10:26:12.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.702]                     {
[10:26:12.702]                       inherits <- base::inherits
[10:26:12.702]                       invokeRestart <- base::invokeRestart
[10:26:12.702]                       is.null <- base::is.null
[10:26:12.702]                       muffled <- FALSE
[10:26:12.702]                       if (inherits(cond, "message")) {
[10:26:12.702]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.702]                         if (muffled) 
[10:26:12.702]                           invokeRestart("muffleMessage")
[10:26:12.702]                       }
[10:26:12.702]                       else if (inherits(cond, "warning")) {
[10:26:12.702]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.702]                         if (muffled) 
[10:26:12.702]                           invokeRestart("muffleWarning")
[10:26:12.702]                       }
[10:26:12.702]                       else if (inherits(cond, "condition")) {
[10:26:12.702]                         if (!is.null(pattern)) {
[10:26:12.702]                           computeRestarts <- base::computeRestarts
[10:26:12.702]                           grepl <- base::grepl
[10:26:12.702]                           restarts <- computeRestarts(cond)
[10:26:12.702]                           for (restart in restarts) {
[10:26:12.702]                             name <- restart$name
[10:26:12.702]                             if (is.null(name)) 
[10:26:12.702]                               next
[10:26:12.702]                             if (!grepl(pattern, name)) 
[10:26:12.702]                               next
[10:26:12.702]                             invokeRestart(restart)
[10:26:12.702]                             muffled <- TRUE
[10:26:12.702]                             break
[10:26:12.702]                           }
[10:26:12.702]                         }
[10:26:12.702]                       }
[10:26:12.702]                       invisible(muffled)
[10:26:12.702]                     }
[10:26:12.702]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.702]                   }
[10:26:12.702]                 }
[10:26:12.702]             }
[10:26:12.702]         }))
[10:26:12.702]     }, error = function(ex) {
[10:26:12.702]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.702]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.702]                 ...future.rng), started = ...future.startTime, 
[10:26:12.702]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.702]             version = "1.8"), class = "FutureResult")
[10:26:12.702]     }, finally = {
[10:26:12.702]         if (!identical(...future.workdir, getwd())) 
[10:26:12.702]             setwd(...future.workdir)
[10:26:12.702]         {
[10:26:12.702]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.702]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.702]             }
[10:26:12.702]             base::options(...future.oldOptions)
[10:26:12.702]             if (.Platform$OS.type == "windows") {
[10:26:12.702]                 old_names <- names(...future.oldEnvVars)
[10:26:12.702]                 envs <- base::Sys.getenv()
[10:26:12.702]                 names <- names(envs)
[10:26:12.702]                 common <- intersect(names, old_names)
[10:26:12.702]                 added <- setdiff(names, old_names)
[10:26:12.702]                 removed <- setdiff(old_names, names)
[10:26:12.702]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.702]                   envs[common]]
[10:26:12.702]                 NAMES <- toupper(changed)
[10:26:12.702]                 args <- list()
[10:26:12.702]                 for (kk in seq_along(NAMES)) {
[10:26:12.702]                   name <- changed[[kk]]
[10:26:12.702]                   NAME <- NAMES[[kk]]
[10:26:12.702]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.702]                     next
[10:26:12.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.702]                 }
[10:26:12.702]                 NAMES <- toupper(added)
[10:26:12.702]                 for (kk in seq_along(NAMES)) {
[10:26:12.702]                   name <- added[[kk]]
[10:26:12.702]                   NAME <- NAMES[[kk]]
[10:26:12.702]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.702]                     next
[10:26:12.702]                   args[[name]] <- ""
[10:26:12.702]                 }
[10:26:12.702]                 NAMES <- toupper(removed)
[10:26:12.702]                 for (kk in seq_along(NAMES)) {
[10:26:12.702]                   name <- removed[[kk]]
[10:26:12.702]                   NAME <- NAMES[[kk]]
[10:26:12.702]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.702]                     next
[10:26:12.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.702]                 }
[10:26:12.702]                 if (length(args) > 0) 
[10:26:12.702]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.702]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.702]             }
[10:26:12.702]             else {
[10:26:12.702]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.702]             }
[10:26:12.702]             {
[10:26:12.702]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.702]                   0L) {
[10:26:12.702]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.702]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.702]                   base::options(opts)
[10:26:12.702]                 }
[10:26:12.702]                 {
[10:26:12.702]                   {
[10:26:12.702]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.702]                     NULL
[10:26:12.702]                   }
[10:26:12.702]                   options(future.plan = NULL)
[10:26:12.702]                   if (is.na(NA_character_)) 
[10:26:12.702]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.702]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.702]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.702]                     envir = parent.frame()) 
[10:26:12.702]                   {
[10:26:12.702]                     default_workers <- missing(workers)
[10:26:12.702]                     if (is.function(workers)) 
[10:26:12.702]                       workers <- workers()
[10:26:12.702]                     workers <- structure(as.integer(workers), 
[10:26:12.702]                       class = class(workers))
[10:26:12.702]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.702]                       1L)
[10:26:12.702]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.702]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.702]                       if (default_workers) 
[10:26:12.702]                         supportsMulticore(warn = TRUE)
[10:26:12.702]                       return(sequential(..., envir = envir))
[10:26:12.702]                     }
[10:26:12.702]                     oopts <- options(mc.cores = workers)
[10:26:12.702]                     on.exit(options(oopts))
[10:26:12.702]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.702]                       envir = envir)
[10:26:12.702]                     if (!future$lazy) 
[10:26:12.702]                       future <- run(future)
[10:26:12.702]                     invisible(future)
[10:26:12.702]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.702]                 }
[10:26:12.702]             }
[10:26:12.702]         }
[10:26:12.702]     })
[10:26:12.702]     if (TRUE) {
[10:26:12.702]         base::sink(type = "output", split = FALSE)
[10:26:12.702]         if (TRUE) {
[10:26:12.702]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.702]         }
[10:26:12.702]         else {
[10:26:12.702]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.702]         }
[10:26:12.702]         base::close(...future.stdout)
[10:26:12.702]         ...future.stdout <- NULL
[10:26:12.702]     }
[10:26:12.702]     ...future.result$conditions <- ...future.conditions
[10:26:12.702]     ...future.result$finished <- base::Sys.time()
[10:26:12.702]     ...future.result
[10:26:12.702] }
[10:26:12.705] assign_globals() ...
[10:26:12.705] List of 2
[10:26:12.705]  $ a : num 1
[10:26:12.705]  $ ii: int 3
[10:26:12.705]  - attr(*, "where")=List of 2
[10:26:12.705]   ..$ a :<environment: R_EmptyEnv> 
[10:26:12.705]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:12.705]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:12.705]  - attr(*, "resolved")= logi TRUE
[10:26:12.705]  - attr(*, "total_size")= num 112
[10:26:12.705]  - attr(*, "already-done")= logi TRUE
[10:26:12.708] - copied ‘a’ to environment
[10:26:12.709] - copied ‘ii’ to environment
[10:26:12.709] assign_globals() ... done
[10:26:12.709] requestCore(): workers = 2
[10:26:12.711] MulticoreFuture started
[10:26:12.711] - Launch lazy future ... done
[10:26:12.711] run() for ‘MulticoreFuture’ ... done
[10:26:12.711] result() for MulticoreFuture ...
[10:26:12.712] plan(): Setting new future strategy stack:
[10:26:12.712] List of future strategies:
[10:26:12.712] 1. sequential:
[10:26:12.712]    - args: function (..., envir = parent.frame())
[10:26:12.712]    - tweaked: FALSE
[10:26:12.712]    - call: NULL
[10:26:12.713] plan(): nbrOfWorkers() = 1
[10:26:12.721] plan(): Setting new future strategy stack:
[10:26:12.721] List of future strategies:
[10:26:12.721] 1. multicore:
[10:26:12.721]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.721]    - tweaked: FALSE
[10:26:12.721]    - call: plan(strategy)
[10:26:12.726] plan(): nbrOfWorkers() = 2
[10:26:12.730] result() for MulticoreFuture ...
[10:26:12.730] result() for MulticoreFuture ... done
[10:26:12.730] result() for MulticoreFuture ... done
[10:26:12.731] result() for MulticoreFuture ...
[10:26:12.731] result() for MulticoreFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.732] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.732] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:12.733] 
[10:26:12.733] Searching for globals ... DONE
[10:26:12.733] - globals: [0] <none>
[10:26:12.733] getGlobalsAndPackages() ... DONE
[10:26:12.734] run() for ‘Future’ ...
[10:26:12.734] - state: ‘created’
[10:26:12.734] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.738] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.739] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.739]   - Field: ‘label’
[10:26:12.739]   - Field: ‘local’
[10:26:12.739]   - Field: ‘owner’
[10:26:12.739]   - Field: ‘envir’
[10:26:12.739]   - Field: ‘workers’
[10:26:12.739]   - Field: ‘packages’
[10:26:12.740]   - Field: ‘gc’
[10:26:12.740]   - Field: ‘job’
[10:26:12.740]   - Field: ‘conditions’
[10:26:12.740]   - Field: ‘expr’
[10:26:12.740]   - Field: ‘uuid’
[10:26:12.740]   - Field: ‘seed’
[10:26:12.741]   - Field: ‘version’
[10:26:12.741]   - Field: ‘result’
[10:26:12.741]   - Field: ‘asynchronous’
[10:26:12.741]   - Field: ‘calls’
[10:26:12.741]   - Field: ‘globals’
[10:26:12.741]   - Field: ‘stdout’
[10:26:12.741]   - Field: ‘earlySignal’
[10:26:12.741]   - Field: ‘lazy’
[10:26:12.741]   - Field: ‘state’
[10:26:12.742] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.742] - Launch lazy future ...
[10:26:12.742] Packages needed by the future expression (n = 0): <none>
[10:26:12.742] Packages needed by future strategies (n = 0): <none>
[10:26:12.743] {
[10:26:12.743]     {
[10:26:12.743]         {
[10:26:12.743]             ...future.startTime <- base::Sys.time()
[10:26:12.743]             {
[10:26:12.743]                 {
[10:26:12.743]                   {
[10:26:12.743]                     {
[10:26:12.743]                       base::local({
[10:26:12.743]                         has_future <- base::requireNamespace("future", 
[10:26:12.743]                           quietly = TRUE)
[10:26:12.743]                         if (has_future) {
[10:26:12.743]                           ns <- base::getNamespace("future")
[10:26:12.743]                           version <- ns[[".package"]][["version"]]
[10:26:12.743]                           if (is.null(version)) 
[10:26:12.743]                             version <- utils::packageVersion("future")
[10:26:12.743]                         }
[10:26:12.743]                         else {
[10:26:12.743]                           version <- NULL
[10:26:12.743]                         }
[10:26:12.743]                         if (!has_future || version < "1.8.0") {
[10:26:12.743]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.743]                             "", base::R.version$version.string), 
[10:26:12.743]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:12.743]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:12.743]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.743]                               "release", "version")], collapse = " "), 
[10:26:12.743]                             hostname = base::Sys.info()[["nodename"]])
[10:26:12.743]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.743]                             info)
[10:26:12.743]                           info <- base::paste(info, collapse = "; ")
[10:26:12.743]                           if (!has_future) {
[10:26:12.743]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.743]                               info)
[10:26:12.743]                           }
[10:26:12.743]                           else {
[10:26:12.743]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.743]                               info, version)
[10:26:12.743]                           }
[10:26:12.743]                           base::stop(msg)
[10:26:12.743]                         }
[10:26:12.743]                       })
[10:26:12.743]                     }
[10:26:12.743]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.743]                     base::options(mc.cores = 1L)
[10:26:12.743]                   }
[10:26:12.743]                   options(future.plan = NULL)
[10:26:12.743]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.743]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.743]                 }
[10:26:12.743]                 ...future.workdir <- getwd()
[10:26:12.743]             }
[10:26:12.743]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.743]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.743]         }
[10:26:12.743]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.743]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:12.743]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.743]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.743]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.743]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.743]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.743]             base::names(...future.oldOptions))
[10:26:12.743]     }
[10:26:12.743]     if (FALSE) {
[10:26:12.743]     }
[10:26:12.743]     else {
[10:26:12.743]         if (TRUE) {
[10:26:12.743]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.743]                 open = "w")
[10:26:12.743]         }
[10:26:12.743]         else {
[10:26:12.743]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.743]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.743]         }
[10:26:12.743]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.743]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.743]             base::sink(type = "output", split = FALSE)
[10:26:12.743]             base::close(...future.stdout)
[10:26:12.743]         }, add = TRUE)
[10:26:12.743]     }
[10:26:12.743]     ...future.frame <- base::sys.nframe()
[10:26:12.743]     ...future.conditions <- base::list()
[10:26:12.743]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.743]     if (FALSE) {
[10:26:12.743]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.743]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.743]     }
[10:26:12.743]     ...future.result <- base::tryCatch({
[10:26:12.743]         base::withCallingHandlers({
[10:26:12.743]             ...future.value <- base::withVisible(base::local({
[10:26:12.743]                 withCallingHandlers({
[10:26:12.743]                   1
[10:26:12.743]                 }, immediateCondition = function(cond) {
[10:26:12.743]                   save_rds <- function (object, pathname, ...) 
[10:26:12.743]                   {
[10:26:12.743]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.743]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.743]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.743]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.743]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.743]                         fi_tmp[["mtime"]])
[10:26:12.743]                     }
[10:26:12.743]                     tryCatch({
[10:26:12.743]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.743]                     }, error = function(ex) {
[10:26:12.743]                       msg <- conditionMessage(ex)
[10:26:12.743]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.743]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.743]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.743]                         fi_tmp[["mtime"]], msg)
[10:26:12.743]                       ex$message <- msg
[10:26:12.743]                       stop(ex)
[10:26:12.743]                     })
[10:26:12.743]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.743]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.743]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.743]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.743]                       fi <- file.info(pathname)
[10:26:12.743]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.743]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.743]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.743]                         fi[["size"]], fi[["mtime"]])
[10:26:12.743]                       stop(msg)
[10:26:12.743]                     }
[10:26:12.743]                     invisible(pathname)
[10:26:12.743]                   }
[10:26:12.743]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.743]                     rootPath = tempdir()) 
[10:26:12.743]                   {
[10:26:12.743]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.743]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.743]                       tmpdir = path, fileext = ".rds")
[10:26:12.743]                     save_rds(obj, file)
[10:26:12.743]                   }
[10:26:12.743]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.743]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.743]                   {
[10:26:12.743]                     inherits <- base::inherits
[10:26:12.743]                     invokeRestart <- base::invokeRestart
[10:26:12.743]                     is.null <- base::is.null
[10:26:12.743]                     muffled <- FALSE
[10:26:12.743]                     if (inherits(cond, "message")) {
[10:26:12.743]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.743]                       if (muffled) 
[10:26:12.743]                         invokeRestart("muffleMessage")
[10:26:12.743]                     }
[10:26:12.743]                     else if (inherits(cond, "warning")) {
[10:26:12.743]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.743]                       if (muffled) 
[10:26:12.743]                         invokeRestart("muffleWarning")
[10:26:12.743]                     }
[10:26:12.743]                     else if (inherits(cond, "condition")) {
[10:26:12.743]                       if (!is.null(pattern)) {
[10:26:12.743]                         computeRestarts <- base::computeRestarts
[10:26:12.743]                         grepl <- base::grepl
[10:26:12.743]                         restarts <- computeRestarts(cond)
[10:26:12.743]                         for (restart in restarts) {
[10:26:12.743]                           name <- restart$name
[10:26:12.743]                           if (is.null(name)) 
[10:26:12.743]                             next
[10:26:12.743]                           if (!grepl(pattern, name)) 
[10:26:12.743]                             next
[10:26:12.743]                           invokeRestart(restart)
[10:26:12.743]                           muffled <- TRUE
[10:26:12.743]                           break
[10:26:12.743]                         }
[10:26:12.743]                       }
[10:26:12.743]                     }
[10:26:12.743]                     invisible(muffled)
[10:26:12.743]                   }
[10:26:12.743]                   muffleCondition(cond)
[10:26:12.743]                 })
[10:26:12.743]             }))
[10:26:12.743]             future::FutureResult(value = ...future.value$value, 
[10:26:12.743]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.743]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.743]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.743]                     ...future.globalenv.names))
[10:26:12.743]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.743]         }, condition = base::local({
[10:26:12.743]             c <- base::c
[10:26:12.743]             inherits <- base::inherits
[10:26:12.743]             invokeRestart <- base::invokeRestart
[10:26:12.743]             length <- base::length
[10:26:12.743]             list <- base::list
[10:26:12.743]             seq.int <- base::seq.int
[10:26:12.743]             signalCondition <- base::signalCondition
[10:26:12.743]             sys.calls <- base::sys.calls
[10:26:12.743]             `[[` <- base::`[[`
[10:26:12.743]             `+` <- base::`+`
[10:26:12.743]             `<<-` <- base::`<<-`
[10:26:12.743]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.743]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.743]                   3L)]
[10:26:12.743]             }
[10:26:12.743]             function(cond) {
[10:26:12.743]                 is_error <- inherits(cond, "error")
[10:26:12.743]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.743]                   NULL)
[10:26:12.743]                 if (is_error) {
[10:26:12.743]                   sessionInformation <- function() {
[10:26:12.743]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.743]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.743]                       search = base::search(), system = base::Sys.info())
[10:26:12.743]                   }
[10:26:12.743]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.743]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.743]                     cond$call), session = sessionInformation(), 
[10:26:12.743]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.743]                   signalCondition(cond)
[10:26:12.743]                 }
[10:26:12.743]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.743]                 "immediateCondition"))) {
[10:26:12.743]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.743]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.743]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.743]                   if (TRUE && !signal) {
[10:26:12.743]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.743]                     {
[10:26:12.743]                       inherits <- base::inherits
[10:26:12.743]                       invokeRestart <- base::invokeRestart
[10:26:12.743]                       is.null <- base::is.null
[10:26:12.743]                       muffled <- FALSE
[10:26:12.743]                       if (inherits(cond, "message")) {
[10:26:12.743]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.743]                         if (muffled) 
[10:26:12.743]                           invokeRestart("muffleMessage")
[10:26:12.743]                       }
[10:26:12.743]                       else if (inherits(cond, "warning")) {
[10:26:12.743]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.743]                         if (muffled) 
[10:26:12.743]                           invokeRestart("muffleWarning")
[10:26:12.743]                       }
[10:26:12.743]                       else if (inherits(cond, "condition")) {
[10:26:12.743]                         if (!is.null(pattern)) {
[10:26:12.743]                           computeRestarts <- base::computeRestarts
[10:26:12.743]                           grepl <- base::grepl
[10:26:12.743]                           restarts <- computeRestarts(cond)
[10:26:12.743]                           for (restart in restarts) {
[10:26:12.743]                             name <- restart$name
[10:26:12.743]                             if (is.null(name)) 
[10:26:12.743]                               next
[10:26:12.743]                             if (!grepl(pattern, name)) 
[10:26:12.743]                               next
[10:26:12.743]                             invokeRestart(restart)
[10:26:12.743]                             muffled <- TRUE
[10:26:12.743]                             break
[10:26:12.743]                           }
[10:26:12.743]                         }
[10:26:12.743]                       }
[10:26:12.743]                       invisible(muffled)
[10:26:12.743]                     }
[10:26:12.743]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.743]                   }
[10:26:12.743]                 }
[10:26:12.743]                 else {
[10:26:12.743]                   if (TRUE) {
[10:26:12.743]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.743]                     {
[10:26:12.743]                       inherits <- base::inherits
[10:26:12.743]                       invokeRestart <- base::invokeRestart
[10:26:12.743]                       is.null <- base::is.null
[10:26:12.743]                       muffled <- FALSE
[10:26:12.743]                       if (inherits(cond, "message")) {
[10:26:12.743]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.743]                         if (muffled) 
[10:26:12.743]                           invokeRestart("muffleMessage")
[10:26:12.743]                       }
[10:26:12.743]                       else if (inherits(cond, "warning")) {
[10:26:12.743]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.743]                         if (muffled) 
[10:26:12.743]                           invokeRestart("muffleWarning")
[10:26:12.743]                       }
[10:26:12.743]                       else if (inherits(cond, "condition")) {
[10:26:12.743]                         if (!is.null(pattern)) {
[10:26:12.743]                           computeRestarts <- base::computeRestarts
[10:26:12.743]                           grepl <- base::grepl
[10:26:12.743]                           restarts <- computeRestarts(cond)
[10:26:12.743]                           for (restart in restarts) {
[10:26:12.743]                             name <- restart$name
[10:26:12.743]                             if (is.null(name)) 
[10:26:12.743]                               next
[10:26:12.743]                             if (!grepl(pattern, name)) 
[10:26:12.743]                               next
[10:26:12.743]                             invokeRestart(restart)
[10:26:12.743]                             muffled <- TRUE
[10:26:12.743]                             break
[10:26:12.743]                           }
[10:26:12.743]                         }
[10:26:12.743]                       }
[10:26:12.743]                       invisible(muffled)
[10:26:12.743]                     }
[10:26:12.743]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.743]                   }
[10:26:12.743]                 }
[10:26:12.743]             }
[10:26:12.743]         }))
[10:26:12.743]     }, error = function(ex) {
[10:26:12.743]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.743]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.743]                 ...future.rng), started = ...future.startTime, 
[10:26:12.743]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.743]             version = "1.8"), class = "FutureResult")
[10:26:12.743]     }, finally = {
[10:26:12.743]         if (!identical(...future.workdir, getwd())) 
[10:26:12.743]             setwd(...future.workdir)
[10:26:12.743]         {
[10:26:12.743]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.743]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.743]             }
[10:26:12.743]             base::options(...future.oldOptions)
[10:26:12.743]             if (.Platform$OS.type == "windows") {
[10:26:12.743]                 old_names <- names(...future.oldEnvVars)
[10:26:12.743]                 envs <- base::Sys.getenv()
[10:26:12.743]                 names <- names(envs)
[10:26:12.743]                 common <- intersect(names, old_names)
[10:26:12.743]                 added <- setdiff(names, old_names)
[10:26:12.743]                 removed <- setdiff(old_names, names)
[10:26:12.743]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.743]                   envs[common]]
[10:26:12.743]                 NAMES <- toupper(changed)
[10:26:12.743]                 args <- list()
[10:26:12.743]                 for (kk in seq_along(NAMES)) {
[10:26:12.743]                   name <- changed[[kk]]
[10:26:12.743]                   NAME <- NAMES[[kk]]
[10:26:12.743]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.743]                     next
[10:26:12.743]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.743]                 }
[10:26:12.743]                 NAMES <- toupper(added)
[10:26:12.743]                 for (kk in seq_along(NAMES)) {
[10:26:12.743]                   name <- added[[kk]]
[10:26:12.743]                   NAME <- NAMES[[kk]]
[10:26:12.743]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.743]                     next
[10:26:12.743]                   args[[name]] <- ""
[10:26:12.743]                 }
[10:26:12.743]                 NAMES <- toupper(removed)
[10:26:12.743]                 for (kk in seq_along(NAMES)) {
[10:26:12.743]                   name <- removed[[kk]]
[10:26:12.743]                   NAME <- NAMES[[kk]]
[10:26:12.743]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.743]                     next
[10:26:12.743]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.743]                 }
[10:26:12.743]                 if (length(args) > 0) 
[10:26:12.743]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.743]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.743]             }
[10:26:12.743]             else {
[10:26:12.743]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.743]             }
[10:26:12.743]             {
[10:26:12.743]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.743]                   0L) {
[10:26:12.743]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.743]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.743]                   base::options(opts)
[10:26:12.743]                 }
[10:26:12.743]                 {
[10:26:12.743]                   {
[10:26:12.743]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.743]                     NULL
[10:26:12.743]                   }
[10:26:12.743]                   options(future.plan = NULL)
[10:26:12.743]                   if (is.na(NA_character_)) 
[10:26:12.743]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.743]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.743]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.743]                     envir = parent.frame()) 
[10:26:12.743]                   {
[10:26:12.743]                     default_workers <- missing(workers)
[10:26:12.743]                     if (is.function(workers)) 
[10:26:12.743]                       workers <- workers()
[10:26:12.743]                     workers <- structure(as.integer(workers), 
[10:26:12.743]                       class = class(workers))
[10:26:12.743]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.743]                       1L)
[10:26:12.743]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.743]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.743]                       if (default_workers) 
[10:26:12.743]                         supportsMulticore(warn = TRUE)
[10:26:12.743]                       return(sequential(..., envir = envir))
[10:26:12.743]                     }
[10:26:12.743]                     oopts <- options(mc.cores = workers)
[10:26:12.743]                     on.exit(options(oopts))
[10:26:12.743]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.743]                       envir = envir)
[10:26:12.743]                     if (!future$lazy) 
[10:26:12.743]                       future <- run(future)
[10:26:12.743]                     invisible(future)
[10:26:12.743]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.743]                 }
[10:26:12.743]             }
[10:26:12.743]         }
[10:26:12.743]     })
[10:26:12.743]     if (TRUE) {
[10:26:12.743]         base::sink(type = "output", split = FALSE)
[10:26:12.743]         if (TRUE) {
[10:26:12.743]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.743]         }
[10:26:12.743]         else {
[10:26:12.743]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.743]         }
[10:26:12.743]         base::close(...future.stdout)
[10:26:12.743]         ...future.stdout <- NULL
[10:26:12.743]     }
[10:26:12.743]     ...future.result$conditions <- ...future.conditions
[10:26:12.743]     ...future.result$finished <- base::Sys.time()
[10:26:12.743]     ...future.result
[10:26:12.743] }
[10:26:12.745] requestCore(): workers = 2
[10:26:12.747] MulticoreFuture started
[10:26:12.748] - Launch lazy future ... done
[10:26:12.748] run() for ‘MulticoreFuture’ ... done
[10:26:12.748] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.748] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.749] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:12.748] List of future strategies:
[10:26:12.748] 1. sequential:
[10:26:12.748]    - args: function (..., envir = parent.frame())
[10:26:12.748]    - tweaked: FALSE
[10:26:12.748]    - call: NULL
[10:26:12.749] plan(): nbrOfWorkers() = 1
[10:26:12.751] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:12.751] Searching for globals ... DONE
[10:26:12.751] Resolving globals: TRUE
[10:26:12.751] plan(): Setting new future strategy stack:
[10:26:12.751] Resolving any globals that are futures ...
[10:26:12.751] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:12.752] Resolving any globals that are futures ... DONE
[10:26:12.751] List of future strategies:
[10:26:12.751] 1. multicore:
[10:26:12.751]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.751]    - tweaked: FALSE
[10:26:12.751]    - call: plan(strategy)
[10:26:12.752] Resolving futures part of globals (recursively) ...
[10:26:12.753] resolve() on list ...
[10:26:12.753]  recursive: 99
[10:26:12.753]  length: 1
[10:26:12.753]  elements: ‘a’
[10:26:12.756] plan(): nbrOfWorkers() = 2
[10:26:12.756] Future #1
[10:26:12.757] result() for MulticoreFuture ...
[10:26:12.758] result() for MulticoreFuture ...
[10:26:12.758] result() for MulticoreFuture ... done
[10:26:12.758] result() for MulticoreFuture ... done
[10:26:12.758] result() for MulticoreFuture ...
[10:26:12.758] result() for MulticoreFuture ... done
[10:26:12.758] A MulticoreFuture was resolved
[10:26:12.759]  length: 0 (resolved future 1)
[10:26:12.759] resolve() on list ... DONE
[10:26:12.759] - globals: [1] ‘a’
[10:26:12.759] Resolving futures part of globals (recursively) ... DONE
[10:26:12.762] The total size of the 1 globals is 1.57 MiB (1641120 bytes)
[10:26:12.762] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[10:26:12.762] - globals: [1] ‘a’
[10:26:12.763] - packages: [1] ‘future’
[10:26:12.763] getGlobalsAndPackages() ... DONE
[10:26:12.763] run() for ‘Future’ ...
[10:26:12.763] - state: ‘created’
[10:26:12.763] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.767] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.768] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.768]   - Field: ‘label’
[10:26:12.768]   - Field: ‘local’
[10:26:12.768]   - Field: ‘owner’
[10:26:12.768]   - Field: ‘envir’
[10:26:12.768]   - Field: ‘workers’
[10:26:12.768]   - Field: ‘packages’
[10:26:12.769]   - Field: ‘gc’
[10:26:12.769]   - Field: ‘job’
[10:26:12.769]   - Field: ‘conditions’
[10:26:12.769]   - Field: ‘expr’
[10:26:12.769]   - Field: ‘uuid’
[10:26:12.769]   - Field: ‘seed’
[10:26:12.769]   - Field: ‘version’
[10:26:12.769]   - Field: ‘result’
[10:26:12.769]   - Field: ‘asynchronous’
[10:26:12.770]   - Field: ‘calls’
[10:26:12.770]   - Field: ‘globals’
[10:26:12.770]   - Field: ‘stdout’
[10:26:12.770]   - Field: ‘earlySignal’
[10:26:12.770]   - Field: ‘lazy’
[10:26:12.770]   - Field: ‘state’
[10:26:12.772] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.773] - Launch lazy future ...
[10:26:12.773] Packages needed by the future expression (n = 1): ‘future’
[10:26:12.773] Packages needed by future strategies (n = 0): <none>
[10:26:12.774] {
[10:26:12.774]     {
[10:26:12.774]         {
[10:26:12.774]             ...future.startTime <- base::Sys.time()
[10:26:12.774]             {
[10:26:12.774]                 {
[10:26:12.774]                   {
[10:26:12.774]                     {
[10:26:12.774]                       {
[10:26:12.774]                         base::local({
[10:26:12.774]                           has_future <- base::requireNamespace("future", 
[10:26:12.774]                             quietly = TRUE)
[10:26:12.774]                           if (has_future) {
[10:26:12.774]                             ns <- base::getNamespace("future")
[10:26:12.774]                             version <- ns[[".package"]][["version"]]
[10:26:12.774]                             if (is.null(version)) 
[10:26:12.774]                               version <- utils::packageVersion("future")
[10:26:12.774]                           }
[10:26:12.774]                           else {
[10:26:12.774]                             version <- NULL
[10:26:12.774]                           }
[10:26:12.774]                           if (!has_future || version < "1.8.0") {
[10:26:12.774]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.774]                               "", base::R.version$version.string), 
[10:26:12.774]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:12.774]                                 base::R.version$platform, 8 * 
[10:26:12.774]                                   base::.Machine$sizeof.pointer), 
[10:26:12.774]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.774]                                 "release", "version")], collapse = " "), 
[10:26:12.774]                               hostname = base::Sys.info()[["nodename"]])
[10:26:12.774]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.774]                               info)
[10:26:12.774]                             info <- base::paste(info, collapse = "; ")
[10:26:12.774]                             if (!has_future) {
[10:26:12.774]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.774]                                 info)
[10:26:12.774]                             }
[10:26:12.774]                             else {
[10:26:12.774]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.774]                                 info, version)
[10:26:12.774]                             }
[10:26:12.774]                             base::stop(msg)
[10:26:12.774]                           }
[10:26:12.774]                         })
[10:26:12.774]                       }
[10:26:12.774]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.774]                       base::options(mc.cores = 1L)
[10:26:12.774]                     }
[10:26:12.774]                     base::local({
[10:26:12.774]                       for (pkg in "future") {
[10:26:12.774]                         base::loadNamespace(pkg)
[10:26:12.774]                         base::library(pkg, character.only = TRUE)
[10:26:12.774]                       }
[10:26:12.774]                     })
[10:26:12.774]                   }
[10:26:12.774]                   options(future.plan = NULL)
[10:26:12.774]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.774]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.774]                 }
[10:26:12.774]                 ...future.workdir <- getwd()
[10:26:12.774]             }
[10:26:12.774]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.774]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.774]         }
[10:26:12.774]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.774]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:12.774]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.774]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.774]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.774]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.774]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.774]             base::names(...future.oldOptions))
[10:26:12.774]     }
[10:26:12.774]     if (FALSE) {
[10:26:12.774]     }
[10:26:12.774]     else {
[10:26:12.774]         if (TRUE) {
[10:26:12.774]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.774]                 open = "w")
[10:26:12.774]         }
[10:26:12.774]         else {
[10:26:12.774]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.774]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.774]         }
[10:26:12.774]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.774]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.774]             base::sink(type = "output", split = FALSE)
[10:26:12.774]             base::close(...future.stdout)
[10:26:12.774]         }, add = TRUE)
[10:26:12.774]     }
[10:26:12.774]     ...future.frame <- base::sys.nframe()
[10:26:12.774]     ...future.conditions <- base::list()
[10:26:12.774]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.774]     if (FALSE) {
[10:26:12.774]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.774]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.774]     }
[10:26:12.774]     ...future.result <- base::tryCatch({
[10:26:12.774]         base::withCallingHandlers({
[10:26:12.774]             ...future.value <- base::withVisible(base::local({
[10:26:12.774]                 withCallingHandlers({
[10:26:12.774]                   value(a) + 1
[10:26:12.774]                 }, immediateCondition = function(cond) {
[10:26:12.774]                   save_rds <- function (object, pathname, ...) 
[10:26:12.774]                   {
[10:26:12.774]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.774]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.774]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.774]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.774]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.774]                         fi_tmp[["mtime"]])
[10:26:12.774]                     }
[10:26:12.774]                     tryCatch({
[10:26:12.774]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.774]                     }, error = function(ex) {
[10:26:12.774]                       msg <- conditionMessage(ex)
[10:26:12.774]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.774]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.774]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.774]                         fi_tmp[["mtime"]], msg)
[10:26:12.774]                       ex$message <- msg
[10:26:12.774]                       stop(ex)
[10:26:12.774]                     })
[10:26:12.774]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.774]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.774]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.774]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.774]                       fi <- file.info(pathname)
[10:26:12.774]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.774]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.774]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.774]                         fi[["size"]], fi[["mtime"]])
[10:26:12.774]                       stop(msg)
[10:26:12.774]                     }
[10:26:12.774]                     invisible(pathname)
[10:26:12.774]                   }
[10:26:12.774]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.774]                     rootPath = tempdir()) 
[10:26:12.774]                   {
[10:26:12.774]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.774]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.774]                       tmpdir = path, fileext = ".rds")
[10:26:12.774]                     save_rds(obj, file)
[10:26:12.774]                   }
[10:26:12.774]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.774]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.774]                   {
[10:26:12.774]                     inherits <- base::inherits
[10:26:12.774]                     invokeRestart <- base::invokeRestart
[10:26:12.774]                     is.null <- base::is.null
[10:26:12.774]                     muffled <- FALSE
[10:26:12.774]                     if (inherits(cond, "message")) {
[10:26:12.774]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.774]                       if (muffled) 
[10:26:12.774]                         invokeRestart("muffleMessage")
[10:26:12.774]                     }
[10:26:12.774]                     else if (inherits(cond, "warning")) {
[10:26:12.774]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.774]                       if (muffled) 
[10:26:12.774]                         invokeRestart("muffleWarning")
[10:26:12.774]                     }
[10:26:12.774]                     else if (inherits(cond, "condition")) {
[10:26:12.774]                       if (!is.null(pattern)) {
[10:26:12.774]                         computeRestarts <- base::computeRestarts
[10:26:12.774]                         grepl <- base::grepl
[10:26:12.774]                         restarts <- computeRestarts(cond)
[10:26:12.774]                         for (restart in restarts) {
[10:26:12.774]                           name <- restart$name
[10:26:12.774]                           if (is.null(name)) 
[10:26:12.774]                             next
[10:26:12.774]                           if (!grepl(pattern, name)) 
[10:26:12.774]                             next
[10:26:12.774]                           invokeRestart(restart)
[10:26:12.774]                           muffled <- TRUE
[10:26:12.774]                           break
[10:26:12.774]                         }
[10:26:12.774]                       }
[10:26:12.774]                     }
[10:26:12.774]                     invisible(muffled)
[10:26:12.774]                   }
[10:26:12.774]                   muffleCondition(cond)
[10:26:12.774]                 })
[10:26:12.774]             }))
[10:26:12.774]             future::FutureResult(value = ...future.value$value, 
[10:26:12.774]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.774]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.774]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.774]                     ...future.globalenv.names))
[10:26:12.774]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.774]         }, condition = base::local({
[10:26:12.774]             c <- base::c
[10:26:12.774]             inherits <- base::inherits
[10:26:12.774]             invokeRestart <- base::invokeRestart
[10:26:12.774]             length <- base::length
[10:26:12.774]             list <- base::list
[10:26:12.774]             seq.int <- base::seq.int
[10:26:12.774]             signalCondition <- base::signalCondition
[10:26:12.774]             sys.calls <- base::sys.calls
[10:26:12.774]             `[[` <- base::`[[`
[10:26:12.774]             `+` <- base::`+`
[10:26:12.774]             `<<-` <- base::`<<-`
[10:26:12.774]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.774]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.774]                   3L)]
[10:26:12.774]             }
[10:26:12.774]             function(cond) {
[10:26:12.774]                 is_error <- inherits(cond, "error")
[10:26:12.774]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.774]                   NULL)
[10:26:12.774]                 if (is_error) {
[10:26:12.774]                   sessionInformation <- function() {
[10:26:12.774]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.774]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.774]                       search = base::search(), system = base::Sys.info())
[10:26:12.774]                   }
[10:26:12.774]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.774]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.774]                     cond$call), session = sessionInformation(), 
[10:26:12.774]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.774]                   signalCondition(cond)
[10:26:12.774]                 }
[10:26:12.774]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.774]                 "immediateCondition"))) {
[10:26:12.774]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.774]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.774]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.774]                   if (TRUE && !signal) {
[10:26:12.774]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.774]                     {
[10:26:12.774]                       inherits <- base::inherits
[10:26:12.774]                       invokeRestart <- base::invokeRestart
[10:26:12.774]                       is.null <- base::is.null
[10:26:12.774]                       muffled <- FALSE
[10:26:12.774]                       if (inherits(cond, "message")) {
[10:26:12.774]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.774]                         if (muffled) 
[10:26:12.774]                           invokeRestart("muffleMessage")
[10:26:12.774]                       }
[10:26:12.774]                       else if (inherits(cond, "warning")) {
[10:26:12.774]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.774]                         if (muffled) 
[10:26:12.774]                           invokeRestart("muffleWarning")
[10:26:12.774]                       }
[10:26:12.774]                       else if (inherits(cond, "condition")) {
[10:26:12.774]                         if (!is.null(pattern)) {
[10:26:12.774]                           computeRestarts <- base::computeRestarts
[10:26:12.774]                           grepl <- base::grepl
[10:26:12.774]                           restarts <- computeRestarts(cond)
[10:26:12.774]                           for (restart in restarts) {
[10:26:12.774]                             name <- restart$name
[10:26:12.774]                             if (is.null(name)) 
[10:26:12.774]                               next
[10:26:12.774]                             if (!grepl(pattern, name)) 
[10:26:12.774]                               next
[10:26:12.774]                             invokeRestart(restart)
[10:26:12.774]                             muffled <- TRUE
[10:26:12.774]                             break
[10:26:12.774]                           }
[10:26:12.774]                         }
[10:26:12.774]                       }
[10:26:12.774]                       invisible(muffled)
[10:26:12.774]                     }
[10:26:12.774]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.774]                   }
[10:26:12.774]                 }
[10:26:12.774]                 else {
[10:26:12.774]                   if (TRUE) {
[10:26:12.774]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.774]                     {
[10:26:12.774]                       inherits <- base::inherits
[10:26:12.774]                       invokeRestart <- base::invokeRestart
[10:26:12.774]                       is.null <- base::is.null
[10:26:12.774]                       muffled <- FALSE
[10:26:12.774]                       if (inherits(cond, "message")) {
[10:26:12.774]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.774]                         if (muffled) 
[10:26:12.774]                           invokeRestart("muffleMessage")
[10:26:12.774]                       }
[10:26:12.774]                       else if (inherits(cond, "warning")) {
[10:26:12.774]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.774]                         if (muffled) 
[10:26:12.774]                           invokeRestart("muffleWarning")
[10:26:12.774]                       }
[10:26:12.774]                       else if (inherits(cond, "condition")) {
[10:26:12.774]                         if (!is.null(pattern)) {
[10:26:12.774]                           computeRestarts <- base::computeRestarts
[10:26:12.774]                           grepl <- base::grepl
[10:26:12.774]                           restarts <- computeRestarts(cond)
[10:26:12.774]                           for (restart in restarts) {
[10:26:12.774]                             name <- restart$name
[10:26:12.774]                             if (is.null(name)) 
[10:26:12.774]                               next
[10:26:12.774]                             if (!grepl(pattern, name)) 
[10:26:12.774]                               next
[10:26:12.774]                             invokeRestart(restart)
[10:26:12.774]                             muffled <- TRUE
[10:26:12.774]                             break
[10:26:12.774]                           }
[10:26:12.774]                         }
[10:26:12.774]                       }
[10:26:12.774]                       invisible(muffled)
[10:26:12.774]                     }
[10:26:12.774]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.774]                   }
[10:26:12.774]                 }
[10:26:12.774]             }
[10:26:12.774]         }))
[10:26:12.774]     }, error = function(ex) {
[10:26:12.774]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.774]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.774]                 ...future.rng), started = ...future.startTime, 
[10:26:12.774]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.774]             version = "1.8"), class = "FutureResult")
[10:26:12.774]     }, finally = {
[10:26:12.774]         if (!identical(...future.workdir, getwd())) 
[10:26:12.774]             setwd(...future.workdir)
[10:26:12.774]         {
[10:26:12.774]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.774]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.774]             }
[10:26:12.774]             base::options(...future.oldOptions)
[10:26:12.774]             if (.Platform$OS.type == "windows") {
[10:26:12.774]                 old_names <- names(...future.oldEnvVars)
[10:26:12.774]                 envs <- base::Sys.getenv()
[10:26:12.774]                 names <- names(envs)
[10:26:12.774]                 common <- intersect(names, old_names)
[10:26:12.774]                 added <- setdiff(names, old_names)
[10:26:12.774]                 removed <- setdiff(old_names, names)
[10:26:12.774]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.774]                   envs[common]]
[10:26:12.774]                 NAMES <- toupper(changed)
[10:26:12.774]                 args <- list()
[10:26:12.774]                 for (kk in seq_along(NAMES)) {
[10:26:12.774]                   name <- changed[[kk]]
[10:26:12.774]                   NAME <- NAMES[[kk]]
[10:26:12.774]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.774]                     next
[10:26:12.774]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.774]                 }
[10:26:12.774]                 NAMES <- toupper(added)
[10:26:12.774]                 for (kk in seq_along(NAMES)) {
[10:26:12.774]                   name <- added[[kk]]
[10:26:12.774]                   NAME <- NAMES[[kk]]
[10:26:12.774]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.774]                     next
[10:26:12.774]                   args[[name]] <- ""
[10:26:12.774]                 }
[10:26:12.774]                 NAMES <- toupper(removed)
[10:26:12.774]                 for (kk in seq_along(NAMES)) {
[10:26:12.774]                   name <- removed[[kk]]
[10:26:12.774]                   NAME <- NAMES[[kk]]
[10:26:12.774]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.774]                     next
[10:26:12.774]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.774]                 }
[10:26:12.774]                 if (length(args) > 0) 
[10:26:12.774]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.774]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.774]             }
[10:26:12.774]             else {
[10:26:12.774]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.774]             }
[10:26:12.774]             {
[10:26:12.774]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.774]                   0L) {
[10:26:12.774]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.774]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.774]                   base::options(opts)
[10:26:12.774]                 }
[10:26:12.774]                 {
[10:26:12.774]                   {
[10:26:12.774]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.774]                     NULL
[10:26:12.774]                   }
[10:26:12.774]                   options(future.plan = NULL)
[10:26:12.774]                   if (is.na(NA_character_)) 
[10:26:12.774]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.774]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.774]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.774]                     envir = parent.frame()) 
[10:26:12.774]                   {
[10:26:12.774]                     default_workers <- missing(workers)
[10:26:12.774]                     if (is.function(workers)) 
[10:26:12.774]                       workers <- workers()
[10:26:12.774]                     workers <- structure(as.integer(workers), 
[10:26:12.774]                       class = class(workers))
[10:26:12.774]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.774]                       1L)
[10:26:12.774]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.774]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.774]                       if (default_workers) 
[10:26:12.774]                         supportsMulticore(warn = TRUE)
[10:26:12.774]                       return(sequential(..., envir = envir))
[10:26:12.774]                     }
[10:26:12.774]                     oopts <- options(mc.cores = workers)
[10:26:12.774]                     on.exit(options(oopts))
[10:26:12.774]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.774]                       envir = envir)
[10:26:12.774]                     if (!future$lazy) 
[10:26:12.774]                       future <- run(future)
[10:26:12.774]                     invisible(future)
[10:26:12.774]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.774]                 }
[10:26:12.774]             }
[10:26:12.774]         }
[10:26:12.774]     })
[10:26:12.774]     if (TRUE) {
[10:26:12.774]         base::sink(type = "output", split = FALSE)
[10:26:12.774]         if (TRUE) {
[10:26:12.774]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.774]         }
[10:26:12.774]         else {
[10:26:12.774]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.774]         }
[10:26:12.774]         base::close(...future.stdout)
[10:26:12.774]         ...future.stdout <- NULL
[10:26:12.774]     }
[10:26:12.774]     ...future.result$conditions <- ...future.conditions
[10:26:12.774]     ...future.result$finished <- base::Sys.time()
[10:26:12.774]     ...future.result
[10:26:12.774] }
[10:26:12.777] assign_globals() ...
[10:26:12.777] List of 1
[10:26:12.777]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a021eac4e8> 
[10:26:12.777]  - attr(*, "where")=List of 1
[10:26:12.777]   ..$ a:<environment: R_EmptyEnv> 
[10:26:12.777]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:12.777]  - attr(*, "resolved")= logi TRUE
[10:26:12.777]  - attr(*, "total_size")= num 1641120
[10:26:12.777]  - attr(*, "already-done")= logi TRUE
[10:26:12.780] - copied ‘a’ to environment
[10:26:12.780] assign_globals() ... done
[10:26:12.781] requestCore(): workers = 2
[10:26:12.783] MulticoreFuture started
[10:26:12.783] - Launch lazy future ... done
[10:26:12.784] run() for ‘MulticoreFuture’ ... done
[10:26:12.784] result() for MulticoreFuture ...
[10:26:12.784] plan(): Setting new future strategy stack:
[10:26:12.785] List of future strategies:
[10:26:12.785] 1. sequential:
[10:26:12.785]    - args: function (..., envir = parent.frame())
[10:26:12.785]    - tweaked: FALSE
[10:26:12.785]    - call: NULL
[10:26:12.786] plan(): nbrOfWorkers() = 1
[10:26:12.789] plan(): Setting new future strategy stack:
[10:26:12.790] List of future strategies:
[10:26:12.790] 1. multicore:
[10:26:12.790]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.790]    - tweaked: FALSE
[10:26:12.790]    - call: plan(strategy)
[10:26:12.795] plan(): nbrOfWorkers() = 2
[10:26:12.796] result() for MulticoreFuture ...
[10:26:12.796] result() for MulticoreFuture ... done
[10:26:12.796] signalConditions() ...
[10:26:12.796]  - include = ‘immediateCondition’
[10:26:12.796]  - exclude = 
[10:26:12.797]  - resignal = FALSE
[10:26:12.797]  - Number of conditions: 4
[10:26:12.797] signalConditions() ... done
[10:26:12.797] result() for MulticoreFuture ... done
[10:26:12.797] result() for MulticoreFuture ...
[10:26:12.797] result() for MulticoreFuture ... done
[10:26:12.798] signalConditions() ...
[10:26:12.798]  - include = ‘immediateCondition’
[10:26:12.798]  - exclude = 
[10:26:12.798]  - resignal = FALSE
[10:26:12.798]  - Number of conditions: 4
[10:26:12.798] signalConditions() ... done
[10:26:12.798] Future state: ‘finished’
[10:26:12.799] result() for MulticoreFuture ...
[10:26:12.799] result() for MulticoreFuture ... done
[10:26:12.799] signalConditions() ...
[10:26:12.799]  - include = ‘condition’
[10:26:12.799]  - exclude = ‘immediateCondition’
[10:26:12.799]  - resignal = TRUE
[10:26:12.799]  - Number of conditions: 4
[10:26:12.799]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.787] result() for MulticoreFuture ...
[10:26:12.800]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.788] result() for MulticoreFuture ... done
[10:26:12.800]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.788] result() for MulticoreFuture ...
[10:26:12.800]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.788] result() for MulticoreFuture ... done
[10:26:12.800] signalConditions() ... done
value(b) = 2
[10:26:12.800] result() for MulticoreFuture ...
[10:26:12.800] result() for MulticoreFuture ... done
[10:26:12.801] result() for MulticoreFuture ...
[10:26:12.801] result() for MulticoreFuture ... done
[10:26:12.801] signalConditions() ...
[10:26:12.801]  - include = ‘immediateCondition’
[10:26:12.801]  - exclude = 
[10:26:12.801]  - resignal = FALSE
[10:26:12.801]  - Number of conditions: 4
[10:26:12.801] signalConditions() ... done
[10:26:12.801] Future state: ‘finished’
[10:26:12.802] result() for MulticoreFuture ...
[10:26:12.802] result() for MulticoreFuture ... done
[10:26:12.802] signalConditions() ...
[10:26:12.802]  - include = ‘condition’
[10:26:12.802]  - exclude = ‘immediateCondition’
[10:26:12.802]  - resignal = TRUE
[10:26:12.802]  - Number of conditions: 4
[10:26:12.802]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.787] result() for MulticoreFuture ...
[10:26:12.802]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.788] result() for MulticoreFuture ... done
[10:26:12.803]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.788] result() for MulticoreFuture ...
[10:26:12.803]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.788] result() for MulticoreFuture ... done
[10:26:12.803] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.803] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.804] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:12.804] 
[10:26:12.804] Searching for globals ... DONE
[10:26:12.804] - globals: [0] <none>
[10:26:12.804] getGlobalsAndPackages() ... DONE
[10:26:12.805] run() for ‘Future’ ...
[10:26:12.805] - state: ‘created’
[10:26:12.805] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.809] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.809] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.809]   - Field: ‘label’
[10:26:12.809]   - Field: ‘local’
[10:26:12.809]   - Field: ‘owner’
[10:26:12.810]   - Field: ‘envir’
[10:26:12.810]   - Field: ‘workers’
[10:26:12.810]   - Field: ‘packages’
[10:26:12.810]   - Field: ‘gc’
[10:26:12.810]   - Field: ‘job’
[10:26:12.810]   - Field: ‘conditions’
[10:26:12.810]   - Field: ‘expr’
[10:26:12.810]   - Field: ‘uuid’
[10:26:12.810]   - Field: ‘seed’
[10:26:12.811]   - Field: ‘version’
[10:26:12.811]   - Field: ‘result’
[10:26:12.811]   - Field: ‘asynchronous’
[10:26:12.811]   - Field: ‘calls’
[10:26:12.811]   - Field: ‘globals’
[10:26:12.811]   - Field: ‘stdout’
[10:26:12.811]   - Field: ‘earlySignal’
[10:26:12.811]   - Field: ‘lazy’
[10:26:12.811]   - Field: ‘state’
[10:26:12.812] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.812] - Launch lazy future ...
[10:26:12.812] Packages needed by the future expression (n = 0): <none>
[10:26:12.812] Packages needed by future strategies (n = 0): <none>
[10:26:12.813] {
[10:26:12.813]     {
[10:26:12.813]         {
[10:26:12.813]             ...future.startTime <- base::Sys.time()
[10:26:12.813]             {
[10:26:12.813]                 {
[10:26:12.813]                   {
[10:26:12.813]                     {
[10:26:12.813]                       base::local({
[10:26:12.813]                         has_future <- base::requireNamespace("future", 
[10:26:12.813]                           quietly = TRUE)
[10:26:12.813]                         if (has_future) {
[10:26:12.813]                           ns <- base::getNamespace("future")
[10:26:12.813]                           version <- ns[[".package"]][["version"]]
[10:26:12.813]                           if (is.null(version)) 
[10:26:12.813]                             version <- utils::packageVersion("future")
[10:26:12.813]                         }
[10:26:12.813]                         else {
[10:26:12.813]                           version <- NULL
[10:26:12.813]                         }
[10:26:12.813]                         if (!has_future || version < "1.8.0") {
[10:26:12.813]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.813]                             "", base::R.version$version.string), 
[10:26:12.813]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:12.813]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:12.813]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.813]                               "release", "version")], collapse = " "), 
[10:26:12.813]                             hostname = base::Sys.info()[["nodename"]])
[10:26:12.813]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.813]                             info)
[10:26:12.813]                           info <- base::paste(info, collapse = "; ")
[10:26:12.813]                           if (!has_future) {
[10:26:12.813]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.813]                               info)
[10:26:12.813]                           }
[10:26:12.813]                           else {
[10:26:12.813]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.813]                               info, version)
[10:26:12.813]                           }
[10:26:12.813]                           base::stop(msg)
[10:26:12.813]                         }
[10:26:12.813]                       })
[10:26:12.813]                     }
[10:26:12.813]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.813]                     base::options(mc.cores = 1L)
[10:26:12.813]                   }
[10:26:12.813]                   options(future.plan = NULL)
[10:26:12.813]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.813]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.813]                 }
[10:26:12.813]                 ...future.workdir <- getwd()
[10:26:12.813]             }
[10:26:12.813]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.813]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.813]         }
[10:26:12.813]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.813]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:12.813]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.813]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.813]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.813]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.813]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.813]             base::names(...future.oldOptions))
[10:26:12.813]     }
[10:26:12.813]     if (FALSE) {
[10:26:12.813]     }
[10:26:12.813]     else {
[10:26:12.813]         if (TRUE) {
[10:26:12.813]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.813]                 open = "w")
[10:26:12.813]         }
[10:26:12.813]         else {
[10:26:12.813]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.813]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.813]         }
[10:26:12.813]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.813]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.813]             base::sink(type = "output", split = FALSE)
[10:26:12.813]             base::close(...future.stdout)
[10:26:12.813]         }, add = TRUE)
[10:26:12.813]     }
[10:26:12.813]     ...future.frame <- base::sys.nframe()
[10:26:12.813]     ...future.conditions <- base::list()
[10:26:12.813]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.813]     if (FALSE) {
[10:26:12.813]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.813]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.813]     }
[10:26:12.813]     ...future.result <- base::tryCatch({
[10:26:12.813]         base::withCallingHandlers({
[10:26:12.813]             ...future.value <- base::withVisible(base::local({
[10:26:12.813]                 withCallingHandlers({
[10:26:12.813]                   1
[10:26:12.813]                 }, immediateCondition = function(cond) {
[10:26:12.813]                   save_rds <- function (object, pathname, ...) 
[10:26:12.813]                   {
[10:26:12.813]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.813]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.813]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.813]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.813]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.813]                         fi_tmp[["mtime"]])
[10:26:12.813]                     }
[10:26:12.813]                     tryCatch({
[10:26:12.813]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.813]                     }, error = function(ex) {
[10:26:12.813]                       msg <- conditionMessage(ex)
[10:26:12.813]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.813]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.813]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.813]                         fi_tmp[["mtime"]], msg)
[10:26:12.813]                       ex$message <- msg
[10:26:12.813]                       stop(ex)
[10:26:12.813]                     })
[10:26:12.813]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.813]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.813]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.813]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.813]                       fi <- file.info(pathname)
[10:26:12.813]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.813]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.813]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.813]                         fi[["size"]], fi[["mtime"]])
[10:26:12.813]                       stop(msg)
[10:26:12.813]                     }
[10:26:12.813]                     invisible(pathname)
[10:26:12.813]                   }
[10:26:12.813]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.813]                     rootPath = tempdir()) 
[10:26:12.813]                   {
[10:26:12.813]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.813]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.813]                       tmpdir = path, fileext = ".rds")
[10:26:12.813]                     save_rds(obj, file)
[10:26:12.813]                   }
[10:26:12.813]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.813]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.813]                   {
[10:26:12.813]                     inherits <- base::inherits
[10:26:12.813]                     invokeRestart <- base::invokeRestart
[10:26:12.813]                     is.null <- base::is.null
[10:26:12.813]                     muffled <- FALSE
[10:26:12.813]                     if (inherits(cond, "message")) {
[10:26:12.813]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.813]                       if (muffled) 
[10:26:12.813]                         invokeRestart("muffleMessage")
[10:26:12.813]                     }
[10:26:12.813]                     else if (inherits(cond, "warning")) {
[10:26:12.813]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.813]                       if (muffled) 
[10:26:12.813]                         invokeRestart("muffleWarning")
[10:26:12.813]                     }
[10:26:12.813]                     else if (inherits(cond, "condition")) {
[10:26:12.813]                       if (!is.null(pattern)) {
[10:26:12.813]                         computeRestarts <- base::computeRestarts
[10:26:12.813]                         grepl <- base::grepl
[10:26:12.813]                         restarts <- computeRestarts(cond)
[10:26:12.813]                         for (restart in restarts) {
[10:26:12.813]                           name <- restart$name
[10:26:12.813]                           if (is.null(name)) 
[10:26:12.813]                             next
[10:26:12.813]                           if (!grepl(pattern, name)) 
[10:26:12.813]                             next
[10:26:12.813]                           invokeRestart(restart)
[10:26:12.813]                           muffled <- TRUE
[10:26:12.813]                           break
[10:26:12.813]                         }
[10:26:12.813]                       }
[10:26:12.813]                     }
[10:26:12.813]                     invisible(muffled)
[10:26:12.813]                   }
[10:26:12.813]                   muffleCondition(cond)
[10:26:12.813]                 })
[10:26:12.813]             }))
[10:26:12.813]             future::FutureResult(value = ...future.value$value, 
[10:26:12.813]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.813]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.813]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.813]                     ...future.globalenv.names))
[10:26:12.813]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.813]         }, condition = base::local({
[10:26:12.813]             c <- base::c
[10:26:12.813]             inherits <- base::inherits
[10:26:12.813]             invokeRestart <- base::invokeRestart
[10:26:12.813]             length <- base::length
[10:26:12.813]             list <- base::list
[10:26:12.813]             seq.int <- base::seq.int
[10:26:12.813]             signalCondition <- base::signalCondition
[10:26:12.813]             sys.calls <- base::sys.calls
[10:26:12.813]             `[[` <- base::`[[`
[10:26:12.813]             `+` <- base::`+`
[10:26:12.813]             `<<-` <- base::`<<-`
[10:26:12.813]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.813]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.813]                   3L)]
[10:26:12.813]             }
[10:26:12.813]             function(cond) {
[10:26:12.813]                 is_error <- inherits(cond, "error")
[10:26:12.813]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.813]                   NULL)
[10:26:12.813]                 if (is_error) {
[10:26:12.813]                   sessionInformation <- function() {
[10:26:12.813]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.813]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.813]                       search = base::search(), system = base::Sys.info())
[10:26:12.813]                   }
[10:26:12.813]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.813]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.813]                     cond$call), session = sessionInformation(), 
[10:26:12.813]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.813]                   signalCondition(cond)
[10:26:12.813]                 }
[10:26:12.813]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.813]                 "immediateCondition"))) {
[10:26:12.813]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.813]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.813]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.813]                   if (TRUE && !signal) {
[10:26:12.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.813]                     {
[10:26:12.813]                       inherits <- base::inherits
[10:26:12.813]                       invokeRestart <- base::invokeRestart
[10:26:12.813]                       is.null <- base::is.null
[10:26:12.813]                       muffled <- FALSE
[10:26:12.813]                       if (inherits(cond, "message")) {
[10:26:12.813]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.813]                         if (muffled) 
[10:26:12.813]                           invokeRestart("muffleMessage")
[10:26:12.813]                       }
[10:26:12.813]                       else if (inherits(cond, "warning")) {
[10:26:12.813]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.813]                         if (muffled) 
[10:26:12.813]                           invokeRestart("muffleWarning")
[10:26:12.813]                       }
[10:26:12.813]                       else if (inherits(cond, "condition")) {
[10:26:12.813]                         if (!is.null(pattern)) {
[10:26:12.813]                           computeRestarts <- base::computeRestarts
[10:26:12.813]                           grepl <- base::grepl
[10:26:12.813]                           restarts <- computeRestarts(cond)
[10:26:12.813]                           for (restart in restarts) {
[10:26:12.813]                             name <- restart$name
[10:26:12.813]                             if (is.null(name)) 
[10:26:12.813]                               next
[10:26:12.813]                             if (!grepl(pattern, name)) 
[10:26:12.813]                               next
[10:26:12.813]                             invokeRestart(restart)
[10:26:12.813]                             muffled <- TRUE
[10:26:12.813]                             break
[10:26:12.813]                           }
[10:26:12.813]                         }
[10:26:12.813]                       }
[10:26:12.813]                       invisible(muffled)
[10:26:12.813]                     }
[10:26:12.813]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.813]                   }
[10:26:12.813]                 }
[10:26:12.813]                 else {
[10:26:12.813]                   if (TRUE) {
[10:26:12.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.813]                     {
[10:26:12.813]                       inherits <- base::inherits
[10:26:12.813]                       invokeRestart <- base::invokeRestart
[10:26:12.813]                       is.null <- base::is.null
[10:26:12.813]                       muffled <- FALSE
[10:26:12.813]                       if (inherits(cond, "message")) {
[10:26:12.813]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.813]                         if (muffled) 
[10:26:12.813]                           invokeRestart("muffleMessage")
[10:26:12.813]                       }
[10:26:12.813]                       else if (inherits(cond, "warning")) {
[10:26:12.813]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.813]                         if (muffled) 
[10:26:12.813]                           invokeRestart("muffleWarning")
[10:26:12.813]                       }
[10:26:12.813]                       else if (inherits(cond, "condition")) {
[10:26:12.813]                         if (!is.null(pattern)) {
[10:26:12.813]                           computeRestarts <- base::computeRestarts
[10:26:12.813]                           grepl <- base::grepl
[10:26:12.813]                           restarts <- computeRestarts(cond)
[10:26:12.813]                           for (restart in restarts) {
[10:26:12.813]                             name <- restart$name
[10:26:12.813]                             if (is.null(name)) 
[10:26:12.813]                               next
[10:26:12.813]                             if (!grepl(pattern, name)) 
[10:26:12.813]                               next
[10:26:12.813]                             invokeRestart(restart)
[10:26:12.813]                             muffled <- TRUE
[10:26:12.813]                             break
[10:26:12.813]                           }
[10:26:12.813]                         }
[10:26:12.813]                       }
[10:26:12.813]                       invisible(muffled)
[10:26:12.813]                     }
[10:26:12.813]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.813]                   }
[10:26:12.813]                 }
[10:26:12.813]             }
[10:26:12.813]         }))
[10:26:12.813]     }, error = function(ex) {
[10:26:12.813]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.813]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.813]                 ...future.rng), started = ...future.startTime, 
[10:26:12.813]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.813]             version = "1.8"), class = "FutureResult")
[10:26:12.813]     }, finally = {
[10:26:12.813]         if (!identical(...future.workdir, getwd())) 
[10:26:12.813]             setwd(...future.workdir)
[10:26:12.813]         {
[10:26:12.813]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.813]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.813]             }
[10:26:12.813]             base::options(...future.oldOptions)
[10:26:12.813]             if (.Platform$OS.type == "windows") {
[10:26:12.813]                 old_names <- names(...future.oldEnvVars)
[10:26:12.813]                 envs <- base::Sys.getenv()
[10:26:12.813]                 names <- names(envs)
[10:26:12.813]                 common <- intersect(names, old_names)
[10:26:12.813]                 added <- setdiff(names, old_names)
[10:26:12.813]                 removed <- setdiff(old_names, names)
[10:26:12.813]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.813]                   envs[common]]
[10:26:12.813]                 NAMES <- toupper(changed)
[10:26:12.813]                 args <- list()
[10:26:12.813]                 for (kk in seq_along(NAMES)) {
[10:26:12.813]                   name <- changed[[kk]]
[10:26:12.813]                   NAME <- NAMES[[kk]]
[10:26:12.813]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.813]                     next
[10:26:12.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.813]                 }
[10:26:12.813]                 NAMES <- toupper(added)
[10:26:12.813]                 for (kk in seq_along(NAMES)) {
[10:26:12.813]                   name <- added[[kk]]
[10:26:12.813]                   NAME <- NAMES[[kk]]
[10:26:12.813]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.813]                     next
[10:26:12.813]                   args[[name]] <- ""
[10:26:12.813]                 }
[10:26:12.813]                 NAMES <- toupper(removed)
[10:26:12.813]                 for (kk in seq_along(NAMES)) {
[10:26:12.813]                   name <- removed[[kk]]
[10:26:12.813]                   NAME <- NAMES[[kk]]
[10:26:12.813]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.813]                     next
[10:26:12.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.813]                 }
[10:26:12.813]                 if (length(args) > 0) 
[10:26:12.813]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.813]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.813]             }
[10:26:12.813]             else {
[10:26:12.813]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.813]             }
[10:26:12.813]             {
[10:26:12.813]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.813]                   0L) {
[10:26:12.813]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.813]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.813]                   base::options(opts)
[10:26:12.813]                 }
[10:26:12.813]                 {
[10:26:12.813]                   {
[10:26:12.813]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.813]                     NULL
[10:26:12.813]                   }
[10:26:12.813]                   options(future.plan = NULL)
[10:26:12.813]                   if (is.na(NA_character_)) 
[10:26:12.813]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.813]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.813]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.813]                     envir = parent.frame()) 
[10:26:12.813]                   {
[10:26:12.813]                     default_workers <- missing(workers)
[10:26:12.813]                     if (is.function(workers)) 
[10:26:12.813]                       workers <- workers()
[10:26:12.813]                     workers <- structure(as.integer(workers), 
[10:26:12.813]                       class = class(workers))
[10:26:12.813]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.813]                       1L)
[10:26:12.813]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.813]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.813]                       if (default_workers) 
[10:26:12.813]                         supportsMulticore(warn = TRUE)
[10:26:12.813]                       return(sequential(..., envir = envir))
[10:26:12.813]                     }
[10:26:12.813]                     oopts <- options(mc.cores = workers)
[10:26:12.813]                     on.exit(options(oopts))
[10:26:12.813]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.813]                       envir = envir)
[10:26:12.813]                     if (!future$lazy) 
[10:26:12.813]                       future <- run(future)
[10:26:12.813]                     invisible(future)
[10:26:12.813]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.813]                 }
[10:26:12.813]             }
[10:26:12.813]         }
[10:26:12.813]     })
[10:26:12.813]     if (TRUE) {
[10:26:12.813]         base::sink(type = "output", split = FALSE)
[10:26:12.813]         if (TRUE) {
[10:26:12.813]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.813]         }
[10:26:12.813]         else {
[10:26:12.813]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.813]         }
[10:26:12.813]         base::close(...future.stdout)
[10:26:12.813]         ...future.stdout <- NULL
[10:26:12.813]     }
[10:26:12.813]     ...future.result$conditions <- ...future.conditions
[10:26:12.813]     ...future.result$finished <- base::Sys.time()
[10:26:12.813]     ...future.result
[10:26:12.813] }
[10:26:12.815] requestCore(): workers = 2
[10:26:12.817] MulticoreFuture started
[10:26:12.818] - Launch lazy future ... done
[10:26:12.818] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.818] getGlobalsAndPackages() ...
Warning:[10:26:12.818] plan(): Setting new future strategy stack:
 R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.819] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:12.819] List of future strategies:
[10:26:12.819] 1. sequential:
[10:26:12.819]    - args: function (..., envir = parent.frame())
[10:26:12.819]    - tweaked: FALSE
[10:26:12.819]    - call: NULL
[10:26:12.820] plan(): nbrOfWorkers() = 1
[10:26:12.822] plan(): Setting new future strategy stack:
[10:26:12.824] List of future strategies:
[10:26:12.824] 1. multicore:
[10:26:12.824]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.824]    - tweaked: FALSE
[10:26:12.824]    - call: plan(strategy)
[10:26:12.825] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:12.826] Searching for globals ... DONE
[10:26:12.826] Resolving globals: TRUE
[10:26:12.826] Resolving any globals that are futures ...
[10:26:12.827] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:12.827] Resolving any globals that are futures ... DONE
[10:26:12.828] Resolving futures part of globals (recursively) ...
[10:26:12.828] resolve() on list ...
[10:26:12.828]  recursive: 99
[10:26:12.829]  length: 1
[10:26:12.829]  elements: ‘a’
[10:26:12.830] plan(): nbrOfWorkers() = 2
[10:26:12.830] Future #1
[10:26:12.831] result() for MulticoreFuture ...
[10:26:12.831] result() for MulticoreFuture ...
[10:26:12.832] result() for MulticoreFuture ... done
[10:26:12.832] result() for MulticoreFuture ... done
[10:26:12.832] result() for MulticoreFuture ...
[10:26:12.832] result() for MulticoreFuture ... done
[10:26:12.833] A MulticoreFuture was resolved
[10:26:12.833]  length: 0 (resolved future 1)
[10:26:12.833] resolve() on list ... DONE
[10:26:12.833] - globals: [1] ‘a’
[10:26:12.833] Resolving futures part of globals (recursively) ... DONE
[10:26:12.837] The total size of the 1 globals is 1.57 MiB (1641120 bytes)
[10:26:12.837] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[10:26:12.837] - globals: [1] ‘a’
[10:26:12.837] - packages: [1] ‘future’
[10:26:12.837] getGlobalsAndPackages() ... DONE
[10:26:12.838] run() for ‘Future’ ...
[10:26:12.838] - state: ‘created’
[10:26:12.838] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.842] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.842] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.842]   - Field: ‘label’
[10:26:12.842]   - Field: ‘local’
[10:26:12.843]   - Field: ‘owner’
[10:26:12.843]   - Field: ‘envir’
[10:26:12.843]   - Field: ‘workers’
[10:26:12.843]   - Field: ‘packages’
[10:26:12.843]   - Field: ‘gc’
[10:26:12.843]   - Field: ‘job’
[10:26:12.843]   - Field: ‘conditions’
[10:26:12.843]   - Field: ‘expr’
[10:26:12.843]   - Field: ‘uuid’
[10:26:12.844]   - Field: ‘seed’
[10:26:12.844]   - Field: ‘version’
[10:26:12.844]   - Field: ‘result’
[10:26:12.844]   - Field: ‘asynchronous’
[10:26:12.844]   - Field: ‘calls’
[10:26:12.844]   - Field: ‘globals’
[10:26:12.844]   - Field: ‘stdout’
[10:26:12.844]   - Field: ‘earlySignal’
[10:26:12.844]   - Field: ‘lazy’
[10:26:12.844]   - Field: ‘state’
[10:26:12.845] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.845] - Launch lazy future ...
[10:26:12.845] Packages needed by the future expression (n = 1): ‘future’
[10:26:12.845] Packages needed by future strategies (n = 0): <none>
[10:26:12.846] {
[10:26:12.846]     {
[10:26:12.846]         {
[10:26:12.846]             ...future.startTime <- base::Sys.time()
[10:26:12.846]             {
[10:26:12.846]                 {
[10:26:12.846]                   {
[10:26:12.846]                     {
[10:26:12.846]                       {
[10:26:12.846]                         base::local({
[10:26:12.846]                           has_future <- base::requireNamespace("future", 
[10:26:12.846]                             quietly = TRUE)
[10:26:12.846]                           if (has_future) {
[10:26:12.846]                             ns <- base::getNamespace("future")
[10:26:12.846]                             version <- ns[[".package"]][["version"]]
[10:26:12.846]                             if (is.null(version)) 
[10:26:12.846]                               version <- utils::packageVersion("future")
[10:26:12.846]                           }
[10:26:12.846]                           else {
[10:26:12.846]                             version <- NULL
[10:26:12.846]                           }
[10:26:12.846]                           if (!has_future || version < "1.8.0") {
[10:26:12.846]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.846]                               "", base::R.version$version.string), 
[10:26:12.846]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:12.846]                                 base::R.version$platform, 8 * 
[10:26:12.846]                                   base::.Machine$sizeof.pointer), 
[10:26:12.846]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.846]                                 "release", "version")], collapse = " "), 
[10:26:12.846]                               hostname = base::Sys.info()[["nodename"]])
[10:26:12.846]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.846]                               info)
[10:26:12.846]                             info <- base::paste(info, collapse = "; ")
[10:26:12.846]                             if (!has_future) {
[10:26:12.846]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.846]                                 info)
[10:26:12.846]                             }
[10:26:12.846]                             else {
[10:26:12.846]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.846]                                 info, version)
[10:26:12.846]                             }
[10:26:12.846]                             base::stop(msg)
[10:26:12.846]                           }
[10:26:12.846]                         })
[10:26:12.846]                       }
[10:26:12.846]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.846]                       base::options(mc.cores = 1L)
[10:26:12.846]                     }
[10:26:12.846]                     base::local({
[10:26:12.846]                       for (pkg in "future") {
[10:26:12.846]                         base::loadNamespace(pkg)
[10:26:12.846]                         base::library(pkg, character.only = TRUE)
[10:26:12.846]                       }
[10:26:12.846]                     })
[10:26:12.846]                   }
[10:26:12.846]                   options(future.plan = NULL)
[10:26:12.846]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.846]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.846]                 }
[10:26:12.846]                 ...future.workdir <- getwd()
[10:26:12.846]             }
[10:26:12.846]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.846]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.846]         }
[10:26:12.846]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.846]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:12.846]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.846]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.846]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.846]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.846]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.846]             base::names(...future.oldOptions))
[10:26:12.846]     }
[10:26:12.846]     if (FALSE) {
[10:26:12.846]     }
[10:26:12.846]     else {
[10:26:12.846]         if (TRUE) {
[10:26:12.846]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.846]                 open = "w")
[10:26:12.846]         }
[10:26:12.846]         else {
[10:26:12.846]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.846]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.846]         }
[10:26:12.846]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.846]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.846]             base::sink(type = "output", split = FALSE)
[10:26:12.846]             base::close(...future.stdout)
[10:26:12.846]         }, add = TRUE)
[10:26:12.846]     }
[10:26:12.846]     ...future.frame <- base::sys.nframe()
[10:26:12.846]     ...future.conditions <- base::list()
[10:26:12.846]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.846]     if (FALSE) {
[10:26:12.846]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.846]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.846]     }
[10:26:12.846]     ...future.result <- base::tryCatch({
[10:26:12.846]         base::withCallingHandlers({
[10:26:12.846]             ...future.value <- base::withVisible(base::local({
[10:26:12.846]                 withCallingHandlers({
[10:26:12.846]                   value(a) + 1
[10:26:12.846]                 }, immediateCondition = function(cond) {
[10:26:12.846]                   save_rds <- function (object, pathname, ...) 
[10:26:12.846]                   {
[10:26:12.846]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.846]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.846]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.846]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.846]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.846]                         fi_tmp[["mtime"]])
[10:26:12.846]                     }
[10:26:12.846]                     tryCatch({
[10:26:12.846]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.846]                     }, error = function(ex) {
[10:26:12.846]                       msg <- conditionMessage(ex)
[10:26:12.846]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.846]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.846]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.846]                         fi_tmp[["mtime"]], msg)
[10:26:12.846]                       ex$message <- msg
[10:26:12.846]                       stop(ex)
[10:26:12.846]                     })
[10:26:12.846]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.846]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.846]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.846]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.846]                       fi <- file.info(pathname)
[10:26:12.846]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.846]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.846]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.846]                         fi[["size"]], fi[["mtime"]])
[10:26:12.846]                       stop(msg)
[10:26:12.846]                     }
[10:26:12.846]                     invisible(pathname)
[10:26:12.846]                   }
[10:26:12.846]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.846]                     rootPath = tempdir()) 
[10:26:12.846]                   {
[10:26:12.846]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.846]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.846]                       tmpdir = path, fileext = ".rds")
[10:26:12.846]                     save_rds(obj, file)
[10:26:12.846]                   }
[10:26:12.846]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.846]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.846]                   {
[10:26:12.846]                     inherits <- base::inherits
[10:26:12.846]                     invokeRestart <- base::invokeRestart
[10:26:12.846]                     is.null <- base::is.null
[10:26:12.846]                     muffled <- FALSE
[10:26:12.846]                     if (inherits(cond, "message")) {
[10:26:12.846]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.846]                       if (muffled) 
[10:26:12.846]                         invokeRestart("muffleMessage")
[10:26:12.846]                     }
[10:26:12.846]                     else if (inherits(cond, "warning")) {
[10:26:12.846]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.846]                       if (muffled) 
[10:26:12.846]                         invokeRestart("muffleWarning")
[10:26:12.846]                     }
[10:26:12.846]                     else if (inherits(cond, "condition")) {
[10:26:12.846]                       if (!is.null(pattern)) {
[10:26:12.846]                         computeRestarts <- base::computeRestarts
[10:26:12.846]                         grepl <- base::grepl
[10:26:12.846]                         restarts <- computeRestarts(cond)
[10:26:12.846]                         for (restart in restarts) {
[10:26:12.846]                           name <- restart$name
[10:26:12.846]                           if (is.null(name)) 
[10:26:12.846]                             next
[10:26:12.846]                           if (!grepl(pattern, name)) 
[10:26:12.846]                             next
[10:26:12.846]                           invokeRestart(restart)
[10:26:12.846]                           muffled <- TRUE
[10:26:12.846]                           break
[10:26:12.846]                         }
[10:26:12.846]                       }
[10:26:12.846]                     }
[10:26:12.846]                     invisible(muffled)
[10:26:12.846]                   }
[10:26:12.846]                   muffleCondition(cond)
[10:26:12.846]                 })
[10:26:12.846]             }))
[10:26:12.846]             future::FutureResult(value = ...future.value$value, 
[10:26:12.846]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.846]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.846]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.846]                     ...future.globalenv.names))
[10:26:12.846]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.846]         }, condition = base::local({
[10:26:12.846]             c <- base::c
[10:26:12.846]             inherits <- base::inherits
[10:26:12.846]             invokeRestart <- base::invokeRestart
[10:26:12.846]             length <- base::length
[10:26:12.846]             list <- base::list
[10:26:12.846]             seq.int <- base::seq.int
[10:26:12.846]             signalCondition <- base::signalCondition
[10:26:12.846]             sys.calls <- base::sys.calls
[10:26:12.846]             `[[` <- base::`[[`
[10:26:12.846]             `+` <- base::`+`
[10:26:12.846]             `<<-` <- base::`<<-`
[10:26:12.846]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.846]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.846]                   3L)]
[10:26:12.846]             }
[10:26:12.846]             function(cond) {
[10:26:12.846]                 is_error <- inherits(cond, "error")
[10:26:12.846]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.846]                   NULL)
[10:26:12.846]                 if (is_error) {
[10:26:12.846]                   sessionInformation <- function() {
[10:26:12.846]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.846]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.846]                       search = base::search(), system = base::Sys.info())
[10:26:12.846]                   }
[10:26:12.846]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.846]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.846]                     cond$call), session = sessionInformation(), 
[10:26:12.846]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.846]                   signalCondition(cond)
[10:26:12.846]                 }
[10:26:12.846]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.846]                 "immediateCondition"))) {
[10:26:12.846]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.846]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.846]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.846]                   if (TRUE && !signal) {
[10:26:12.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.846]                     {
[10:26:12.846]                       inherits <- base::inherits
[10:26:12.846]                       invokeRestart <- base::invokeRestart
[10:26:12.846]                       is.null <- base::is.null
[10:26:12.846]                       muffled <- FALSE
[10:26:12.846]                       if (inherits(cond, "message")) {
[10:26:12.846]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.846]                         if (muffled) 
[10:26:12.846]                           invokeRestart("muffleMessage")
[10:26:12.846]                       }
[10:26:12.846]                       else if (inherits(cond, "warning")) {
[10:26:12.846]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.846]                         if (muffled) 
[10:26:12.846]                           invokeRestart("muffleWarning")
[10:26:12.846]                       }
[10:26:12.846]                       else if (inherits(cond, "condition")) {
[10:26:12.846]                         if (!is.null(pattern)) {
[10:26:12.846]                           computeRestarts <- base::computeRestarts
[10:26:12.846]                           grepl <- base::grepl
[10:26:12.846]                           restarts <- computeRestarts(cond)
[10:26:12.846]                           for (restart in restarts) {
[10:26:12.846]                             name <- restart$name
[10:26:12.846]                             if (is.null(name)) 
[10:26:12.846]                               next
[10:26:12.846]                             if (!grepl(pattern, name)) 
[10:26:12.846]                               next
[10:26:12.846]                             invokeRestart(restart)
[10:26:12.846]                             muffled <- TRUE
[10:26:12.846]                             break
[10:26:12.846]                           }
[10:26:12.846]                         }
[10:26:12.846]                       }
[10:26:12.846]                       invisible(muffled)
[10:26:12.846]                     }
[10:26:12.846]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.846]                   }
[10:26:12.846]                 }
[10:26:12.846]                 else {
[10:26:12.846]                   if (TRUE) {
[10:26:12.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.846]                     {
[10:26:12.846]                       inherits <- base::inherits
[10:26:12.846]                       invokeRestart <- base::invokeRestart
[10:26:12.846]                       is.null <- base::is.null
[10:26:12.846]                       muffled <- FALSE
[10:26:12.846]                       if (inherits(cond, "message")) {
[10:26:12.846]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.846]                         if (muffled) 
[10:26:12.846]                           invokeRestart("muffleMessage")
[10:26:12.846]                       }
[10:26:12.846]                       else if (inherits(cond, "warning")) {
[10:26:12.846]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.846]                         if (muffled) 
[10:26:12.846]                           invokeRestart("muffleWarning")
[10:26:12.846]                       }
[10:26:12.846]                       else if (inherits(cond, "condition")) {
[10:26:12.846]                         if (!is.null(pattern)) {
[10:26:12.846]                           computeRestarts <- base::computeRestarts
[10:26:12.846]                           grepl <- base::grepl
[10:26:12.846]                           restarts <- computeRestarts(cond)
[10:26:12.846]                           for (restart in restarts) {
[10:26:12.846]                             name <- restart$name
[10:26:12.846]                             if (is.null(name)) 
[10:26:12.846]                               next
[10:26:12.846]                             if (!grepl(pattern, name)) 
[10:26:12.846]                               next
[10:26:12.846]                             invokeRestart(restart)
[10:26:12.846]                             muffled <- TRUE
[10:26:12.846]                             break
[10:26:12.846]                           }
[10:26:12.846]                         }
[10:26:12.846]                       }
[10:26:12.846]                       invisible(muffled)
[10:26:12.846]                     }
[10:26:12.846]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.846]                   }
[10:26:12.846]                 }
[10:26:12.846]             }
[10:26:12.846]         }))
[10:26:12.846]     }, error = function(ex) {
[10:26:12.846]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.846]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.846]                 ...future.rng), started = ...future.startTime, 
[10:26:12.846]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.846]             version = "1.8"), class = "FutureResult")
[10:26:12.846]     }, finally = {
[10:26:12.846]         if (!identical(...future.workdir, getwd())) 
[10:26:12.846]             setwd(...future.workdir)
[10:26:12.846]         {
[10:26:12.846]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.846]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.846]             }
[10:26:12.846]             base::options(...future.oldOptions)
[10:26:12.846]             if (.Platform$OS.type == "windows") {
[10:26:12.846]                 old_names <- names(...future.oldEnvVars)
[10:26:12.846]                 envs <- base::Sys.getenv()
[10:26:12.846]                 names <- names(envs)
[10:26:12.846]                 common <- intersect(names, old_names)
[10:26:12.846]                 added <- setdiff(names, old_names)
[10:26:12.846]                 removed <- setdiff(old_names, names)
[10:26:12.846]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.846]                   envs[common]]
[10:26:12.846]                 NAMES <- toupper(changed)
[10:26:12.846]                 args <- list()
[10:26:12.846]                 for (kk in seq_along(NAMES)) {
[10:26:12.846]                   name <- changed[[kk]]
[10:26:12.846]                   NAME <- NAMES[[kk]]
[10:26:12.846]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.846]                     next
[10:26:12.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.846]                 }
[10:26:12.846]                 NAMES <- toupper(added)
[10:26:12.846]                 for (kk in seq_along(NAMES)) {
[10:26:12.846]                   name <- added[[kk]]
[10:26:12.846]                   NAME <- NAMES[[kk]]
[10:26:12.846]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.846]                     next
[10:26:12.846]                   args[[name]] <- ""
[10:26:12.846]                 }
[10:26:12.846]                 NAMES <- toupper(removed)
[10:26:12.846]                 for (kk in seq_along(NAMES)) {
[10:26:12.846]                   name <- removed[[kk]]
[10:26:12.846]                   NAME <- NAMES[[kk]]
[10:26:12.846]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.846]                     next
[10:26:12.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.846]                 }
[10:26:12.846]                 if (length(args) > 0) 
[10:26:12.846]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.846]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.846]             }
[10:26:12.846]             else {
[10:26:12.846]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.846]             }
[10:26:12.846]             {
[10:26:12.846]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.846]                   0L) {
[10:26:12.846]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.846]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.846]                   base::options(opts)
[10:26:12.846]                 }
[10:26:12.846]                 {
[10:26:12.846]                   {
[10:26:12.846]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.846]                     NULL
[10:26:12.846]                   }
[10:26:12.846]                   options(future.plan = NULL)
[10:26:12.846]                   if (is.na(NA_character_)) 
[10:26:12.846]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.846]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.846]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.846]                     envir = parent.frame()) 
[10:26:12.846]                   {
[10:26:12.846]                     default_workers <- missing(workers)
[10:26:12.846]                     if (is.function(workers)) 
[10:26:12.846]                       workers <- workers()
[10:26:12.846]                     workers <- structure(as.integer(workers), 
[10:26:12.846]                       class = class(workers))
[10:26:12.846]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.846]                       1L)
[10:26:12.846]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.846]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.846]                       if (default_workers) 
[10:26:12.846]                         supportsMulticore(warn = TRUE)
[10:26:12.846]                       return(sequential(..., envir = envir))
[10:26:12.846]                     }
[10:26:12.846]                     oopts <- options(mc.cores = workers)
[10:26:12.846]                     on.exit(options(oopts))
[10:26:12.846]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.846]                       envir = envir)
[10:26:12.846]                     if (!future$lazy) 
[10:26:12.846]                       future <- run(future)
[10:26:12.846]                     invisible(future)
[10:26:12.846]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.846]                 }
[10:26:12.846]             }
[10:26:12.846]         }
[10:26:12.846]     })
[10:26:12.846]     if (TRUE) {
[10:26:12.846]         base::sink(type = "output", split = FALSE)
[10:26:12.846]         if (TRUE) {
[10:26:12.846]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.846]         }
[10:26:12.846]         else {
[10:26:12.846]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.846]         }
[10:26:12.846]         base::close(...future.stdout)
[10:26:12.846]         ...future.stdout <- NULL
[10:26:12.846]     }
[10:26:12.846]     ...future.result$conditions <- ...future.conditions
[10:26:12.846]     ...future.result$finished <- base::Sys.time()
[10:26:12.846]     ...future.result
[10:26:12.846] }
[10:26:12.848] assign_globals() ...
[10:26:12.848] List of 1
[10:26:12.848]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a021c12c38> 
[10:26:12.848]  - attr(*, "where")=List of 1
[10:26:12.848]   ..$ a:<environment: R_EmptyEnv> 
[10:26:12.848]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:12.848]  - attr(*, "resolved")= logi TRUE
[10:26:12.848]  - attr(*, "total_size")= num 1641120
[10:26:12.848]  - attr(*, "already-done")= logi TRUE
[10:26:12.851] - copied ‘a’ to environment
[10:26:12.851] assign_globals() ... done
[10:26:12.851] requestCore(): workers = 2
[10:26:12.853] MulticoreFuture started
[10:26:12.853] - Launch lazy future ... done
[10:26:12.854] run() for ‘MulticoreFuture’ ... done
[10:26:12.854] result() for MulticoreFuture ...
[10:26:12.855] plan(): Setting new future strategy stack:
[10:26:12.855] List of future strategies:
[10:26:12.855] 1. sequential:
[10:26:12.855]    - args: function (..., envir = parent.frame())
[10:26:12.855]    - tweaked: FALSE
[10:26:12.855]    - call: NULL
[10:26:12.856] plan(): nbrOfWorkers() = 1
[10:26:12.859] plan(): Setting new future strategy stack:
[10:26:12.859] List of future strategies:
[10:26:12.859] 1. multicore:
[10:26:12.859]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.859]    - tweaked: FALSE
[10:26:12.859]    - call: plan(strategy)
[10:26:12.864] plan(): nbrOfWorkers() = 2
[10:26:12.865] result() for MulticoreFuture ...
[10:26:12.865] result() for MulticoreFuture ... done
[10:26:12.865] signalConditions() ...
[10:26:12.865]  - include = ‘immediateCondition’
[10:26:12.866]  - exclude = 
[10:26:12.866]  - resignal = FALSE
[10:26:12.866]  - Number of conditions: 4
[10:26:12.866] signalConditions() ... done
[10:26:12.866] result() for MulticoreFuture ... done
[10:26:12.867] result() for MulticoreFuture ...
[10:26:12.867] result() for MulticoreFuture ... done
[10:26:12.867] signalConditions() ...
[10:26:12.867]  - include = ‘immediateCondition’
[10:26:12.867]  - exclude = 
[10:26:12.867]  - resignal = FALSE
[10:26:12.867]  - Number of conditions: 4
[10:26:12.867] signalConditions() ... done
[10:26:12.868] Future state: ‘finished’
[10:26:12.868] result() for MulticoreFuture ...
[10:26:12.868] result() for MulticoreFuture ... done
[10:26:12.868] signalConditions() ...
[10:26:12.868]  - include = ‘condition’
[10:26:12.868]  - exclude = ‘immediateCondition’
[10:26:12.868]  - resignal = TRUE
[10:26:12.868]  - Number of conditions: 4
[10:26:12.869]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.857] result() for MulticoreFuture ...
[10:26:12.869]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.858] result() for MulticoreFuture ... done
[10:26:12.869]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.858] result() for MulticoreFuture ...
[10:26:12.872]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.858] result() for MulticoreFuture ... done
[10:26:12.872] signalConditions() ... done
value(b) = 2
[10:26:12.872] result() for MulticoreFuture ...
[10:26:12.873] result() for MulticoreFuture ... done
[10:26:12.873] result() for MulticoreFuture ...
[10:26:12.873] result() for MulticoreFuture ... done
[10:26:12.873] signalConditions() ...
[10:26:12.873]  - include = ‘immediateCondition’
[10:26:12.873]  - exclude = 
[10:26:12.873]  - resignal = FALSE
[10:26:12.874]  - Number of conditions: 4
[10:26:12.874] signalConditions() ... done
[10:26:12.874] Future state: ‘finished’
[10:26:12.874] result() for MulticoreFuture ...
[10:26:12.874] result() for MulticoreFuture ... done
[10:26:12.874] signalConditions() ...
[10:26:12.874]  - include = ‘condition’
[10:26:12.875]  - exclude = ‘immediateCondition’
[10:26:12.875]  - resignal = TRUE
[10:26:12.875]  - Number of conditions: 4
[10:26:12.875]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.857] result() for MulticoreFuture ...
[10:26:12.875]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.858] result() for MulticoreFuture ... done
[10:26:12.875]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.858] result() for MulticoreFuture ...
[10:26:12.876]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.858] result() for MulticoreFuture ... done
[10:26:12.876] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.876] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.877] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:12.877] 
[10:26:12.877] Searching for globals ... DONE
[10:26:12.878] - globals: [0] <none>
[10:26:12.878] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.878] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.878] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:12.879] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:12.880] Searching for globals ... DONE
[10:26:12.880] Resolving globals: TRUE
[10:26:12.880] Resolving any globals that are futures ...
[10:26:12.880] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:12.880] Resolving any globals that are futures ... DONE
[10:26:12.880] Resolving futures part of globals (recursively) ...
[10:26:12.881] resolve() on list ...
[10:26:12.881]  recursive: 99
[10:26:12.881]  length: 1
[10:26:12.881]  elements: ‘a’
[10:26:12.881] run() for ‘Future’ ...
[10:26:12.881] - state: ‘created’
[10:26:12.882] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.885] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.885] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.886]   - Field: ‘label’
[10:26:12.886]   - Field: ‘local’
[10:26:12.886]   - Field: ‘owner’
[10:26:12.886]   - Field: ‘envir’
[10:26:12.886]   - Field: ‘workers’
[10:26:12.886]   - Field: ‘packages’
[10:26:12.886]   - Field: ‘gc’
[10:26:12.886]   - Field: ‘job’
[10:26:12.886]   - Field: ‘conditions’
[10:26:12.887]   - Field: ‘expr’
[10:26:12.887]   - Field: ‘uuid’
[10:26:12.887]   - Field: ‘seed’
[10:26:12.887]   - Field: ‘version’
[10:26:12.887]   - Field: ‘result’
[10:26:12.887]   - Field: ‘asynchronous’
[10:26:12.887]   - Field: ‘calls’
[10:26:12.887]   - Field: ‘globals’
[10:26:12.887]   - Field: ‘stdout’
[10:26:12.887]   - Field: ‘earlySignal’
[10:26:12.888]   - Field: ‘lazy’
[10:26:12.888]   - Field: ‘state’
[10:26:12.888] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.888] - Launch lazy future ...
[10:26:12.888] Packages needed by the future expression (n = 0): <none>
[10:26:12.888] Packages needed by future strategies (n = 0): <none>
[10:26:12.889] {
[10:26:12.889]     {
[10:26:12.889]         {
[10:26:12.889]             ...future.startTime <- base::Sys.time()
[10:26:12.889]             {
[10:26:12.889]                 {
[10:26:12.889]                   {
[10:26:12.889]                     {
[10:26:12.889]                       base::local({
[10:26:12.889]                         has_future <- base::requireNamespace("future", 
[10:26:12.889]                           quietly = TRUE)
[10:26:12.889]                         if (has_future) {
[10:26:12.889]                           ns <- base::getNamespace("future")
[10:26:12.889]                           version <- ns[[".package"]][["version"]]
[10:26:12.889]                           if (is.null(version)) 
[10:26:12.889]                             version <- utils::packageVersion("future")
[10:26:12.889]                         }
[10:26:12.889]                         else {
[10:26:12.889]                           version <- NULL
[10:26:12.889]                         }
[10:26:12.889]                         if (!has_future || version < "1.8.0") {
[10:26:12.889]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.889]                             "", base::R.version$version.string), 
[10:26:12.889]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:12.889]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:12.889]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.889]                               "release", "version")], collapse = " "), 
[10:26:12.889]                             hostname = base::Sys.info()[["nodename"]])
[10:26:12.889]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.889]                             info)
[10:26:12.889]                           info <- base::paste(info, collapse = "; ")
[10:26:12.889]                           if (!has_future) {
[10:26:12.889]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.889]                               info)
[10:26:12.889]                           }
[10:26:12.889]                           else {
[10:26:12.889]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.889]                               info, version)
[10:26:12.889]                           }
[10:26:12.889]                           base::stop(msg)
[10:26:12.889]                         }
[10:26:12.889]                       })
[10:26:12.889]                     }
[10:26:12.889]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.889]                     base::options(mc.cores = 1L)
[10:26:12.889]                   }
[10:26:12.889]                   options(future.plan = NULL)
[10:26:12.889]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.889]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.889]                 }
[10:26:12.889]                 ...future.workdir <- getwd()
[10:26:12.889]             }
[10:26:12.889]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.889]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.889]         }
[10:26:12.889]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.889]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:12.889]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.889]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.889]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.889]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.889]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.889]             base::names(...future.oldOptions))
[10:26:12.889]     }
[10:26:12.889]     if (FALSE) {
[10:26:12.889]     }
[10:26:12.889]     else {
[10:26:12.889]         if (TRUE) {
[10:26:12.889]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.889]                 open = "w")
[10:26:12.889]         }
[10:26:12.889]         else {
[10:26:12.889]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.889]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.889]         }
[10:26:12.889]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.889]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.889]             base::sink(type = "output", split = FALSE)
[10:26:12.889]             base::close(...future.stdout)
[10:26:12.889]         }, add = TRUE)
[10:26:12.889]     }
[10:26:12.889]     ...future.frame <- base::sys.nframe()
[10:26:12.889]     ...future.conditions <- base::list()
[10:26:12.889]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.889]     if (FALSE) {
[10:26:12.889]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.889]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.889]     }
[10:26:12.889]     ...future.result <- base::tryCatch({
[10:26:12.889]         base::withCallingHandlers({
[10:26:12.889]             ...future.value <- base::withVisible(base::local({
[10:26:12.889]                 withCallingHandlers({
[10:26:12.889]                   1
[10:26:12.889]                 }, immediateCondition = function(cond) {
[10:26:12.889]                   save_rds <- function (object, pathname, ...) 
[10:26:12.889]                   {
[10:26:12.889]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.889]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.889]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.889]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.889]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.889]                         fi_tmp[["mtime"]])
[10:26:12.889]                     }
[10:26:12.889]                     tryCatch({
[10:26:12.889]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.889]                     }, error = function(ex) {
[10:26:12.889]                       msg <- conditionMessage(ex)
[10:26:12.889]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.889]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.889]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.889]                         fi_tmp[["mtime"]], msg)
[10:26:12.889]                       ex$message <- msg
[10:26:12.889]                       stop(ex)
[10:26:12.889]                     })
[10:26:12.889]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.889]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.889]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.889]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.889]                       fi <- file.info(pathname)
[10:26:12.889]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.889]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.889]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.889]                         fi[["size"]], fi[["mtime"]])
[10:26:12.889]                       stop(msg)
[10:26:12.889]                     }
[10:26:12.889]                     invisible(pathname)
[10:26:12.889]                   }
[10:26:12.889]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.889]                     rootPath = tempdir()) 
[10:26:12.889]                   {
[10:26:12.889]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.889]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.889]                       tmpdir = path, fileext = ".rds")
[10:26:12.889]                     save_rds(obj, file)
[10:26:12.889]                   }
[10:26:12.889]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.889]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.889]                   {
[10:26:12.889]                     inherits <- base::inherits
[10:26:12.889]                     invokeRestart <- base::invokeRestart
[10:26:12.889]                     is.null <- base::is.null
[10:26:12.889]                     muffled <- FALSE
[10:26:12.889]                     if (inherits(cond, "message")) {
[10:26:12.889]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.889]                       if (muffled) 
[10:26:12.889]                         invokeRestart("muffleMessage")
[10:26:12.889]                     }
[10:26:12.889]                     else if (inherits(cond, "warning")) {
[10:26:12.889]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.889]                       if (muffled) 
[10:26:12.889]                         invokeRestart("muffleWarning")
[10:26:12.889]                     }
[10:26:12.889]                     else if (inherits(cond, "condition")) {
[10:26:12.889]                       if (!is.null(pattern)) {
[10:26:12.889]                         computeRestarts <- base::computeRestarts
[10:26:12.889]                         grepl <- base::grepl
[10:26:12.889]                         restarts <- computeRestarts(cond)
[10:26:12.889]                         for (restart in restarts) {
[10:26:12.889]                           name <- restart$name
[10:26:12.889]                           if (is.null(name)) 
[10:26:12.889]                             next
[10:26:12.889]                           if (!grepl(pattern, name)) 
[10:26:12.889]                             next
[10:26:12.889]                           invokeRestart(restart)
[10:26:12.889]                           muffled <- TRUE
[10:26:12.889]                           break
[10:26:12.889]                         }
[10:26:12.889]                       }
[10:26:12.889]                     }
[10:26:12.889]                     invisible(muffled)
[10:26:12.889]                   }
[10:26:12.889]                   muffleCondition(cond)
[10:26:12.889]                 })
[10:26:12.889]             }))
[10:26:12.889]             future::FutureResult(value = ...future.value$value, 
[10:26:12.889]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.889]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.889]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.889]                     ...future.globalenv.names))
[10:26:12.889]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.889]         }, condition = base::local({
[10:26:12.889]             c <- base::c
[10:26:12.889]             inherits <- base::inherits
[10:26:12.889]             invokeRestart <- base::invokeRestart
[10:26:12.889]             length <- base::length
[10:26:12.889]             list <- base::list
[10:26:12.889]             seq.int <- base::seq.int
[10:26:12.889]             signalCondition <- base::signalCondition
[10:26:12.889]             sys.calls <- base::sys.calls
[10:26:12.889]             `[[` <- base::`[[`
[10:26:12.889]             `+` <- base::`+`
[10:26:12.889]             `<<-` <- base::`<<-`
[10:26:12.889]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.889]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.889]                   3L)]
[10:26:12.889]             }
[10:26:12.889]             function(cond) {
[10:26:12.889]                 is_error <- inherits(cond, "error")
[10:26:12.889]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.889]                   NULL)
[10:26:12.889]                 if (is_error) {
[10:26:12.889]                   sessionInformation <- function() {
[10:26:12.889]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.889]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.889]                       search = base::search(), system = base::Sys.info())
[10:26:12.889]                   }
[10:26:12.889]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.889]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.889]                     cond$call), session = sessionInformation(), 
[10:26:12.889]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.889]                   signalCondition(cond)
[10:26:12.889]                 }
[10:26:12.889]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.889]                 "immediateCondition"))) {
[10:26:12.889]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.889]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.889]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.889]                   if (TRUE && !signal) {
[10:26:12.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.889]                     {
[10:26:12.889]                       inherits <- base::inherits
[10:26:12.889]                       invokeRestart <- base::invokeRestart
[10:26:12.889]                       is.null <- base::is.null
[10:26:12.889]                       muffled <- FALSE
[10:26:12.889]                       if (inherits(cond, "message")) {
[10:26:12.889]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.889]                         if (muffled) 
[10:26:12.889]                           invokeRestart("muffleMessage")
[10:26:12.889]                       }
[10:26:12.889]                       else if (inherits(cond, "warning")) {
[10:26:12.889]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.889]                         if (muffled) 
[10:26:12.889]                           invokeRestart("muffleWarning")
[10:26:12.889]                       }
[10:26:12.889]                       else if (inherits(cond, "condition")) {
[10:26:12.889]                         if (!is.null(pattern)) {
[10:26:12.889]                           computeRestarts <- base::computeRestarts
[10:26:12.889]                           grepl <- base::grepl
[10:26:12.889]                           restarts <- computeRestarts(cond)
[10:26:12.889]                           for (restart in restarts) {
[10:26:12.889]                             name <- restart$name
[10:26:12.889]                             if (is.null(name)) 
[10:26:12.889]                               next
[10:26:12.889]                             if (!grepl(pattern, name)) 
[10:26:12.889]                               next
[10:26:12.889]                             invokeRestart(restart)
[10:26:12.889]                             muffled <- TRUE
[10:26:12.889]                             break
[10:26:12.889]                           }
[10:26:12.889]                         }
[10:26:12.889]                       }
[10:26:12.889]                       invisible(muffled)
[10:26:12.889]                     }
[10:26:12.889]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.889]                   }
[10:26:12.889]                 }
[10:26:12.889]                 else {
[10:26:12.889]                   if (TRUE) {
[10:26:12.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.889]                     {
[10:26:12.889]                       inherits <- base::inherits
[10:26:12.889]                       invokeRestart <- base::invokeRestart
[10:26:12.889]                       is.null <- base::is.null
[10:26:12.889]                       muffled <- FALSE
[10:26:12.889]                       if (inherits(cond, "message")) {
[10:26:12.889]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.889]                         if (muffled) 
[10:26:12.889]                           invokeRestart("muffleMessage")
[10:26:12.889]                       }
[10:26:12.889]                       else if (inherits(cond, "warning")) {
[10:26:12.889]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.889]                         if (muffled) 
[10:26:12.889]                           invokeRestart("muffleWarning")
[10:26:12.889]                       }
[10:26:12.889]                       else if (inherits(cond, "condition")) {
[10:26:12.889]                         if (!is.null(pattern)) {
[10:26:12.889]                           computeRestarts <- base::computeRestarts
[10:26:12.889]                           grepl <- base::grepl
[10:26:12.889]                           restarts <- computeRestarts(cond)
[10:26:12.889]                           for (restart in restarts) {
[10:26:12.889]                             name <- restart$name
[10:26:12.889]                             if (is.null(name)) 
[10:26:12.889]                               next
[10:26:12.889]                             if (!grepl(pattern, name)) 
[10:26:12.889]                               next
[10:26:12.889]                             invokeRestart(restart)
[10:26:12.889]                             muffled <- TRUE
[10:26:12.889]                             break
[10:26:12.889]                           }
[10:26:12.889]                         }
[10:26:12.889]                       }
[10:26:12.889]                       invisible(muffled)
[10:26:12.889]                     }
[10:26:12.889]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.889]                   }
[10:26:12.889]                 }
[10:26:12.889]             }
[10:26:12.889]         }))
[10:26:12.889]     }, error = function(ex) {
[10:26:12.889]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.889]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.889]                 ...future.rng), started = ...future.startTime, 
[10:26:12.889]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.889]             version = "1.8"), class = "FutureResult")
[10:26:12.889]     }, finally = {
[10:26:12.889]         if (!identical(...future.workdir, getwd())) 
[10:26:12.889]             setwd(...future.workdir)
[10:26:12.889]         {
[10:26:12.889]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.889]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.889]             }
[10:26:12.889]             base::options(...future.oldOptions)
[10:26:12.889]             if (.Platform$OS.type == "windows") {
[10:26:12.889]                 old_names <- names(...future.oldEnvVars)
[10:26:12.889]                 envs <- base::Sys.getenv()
[10:26:12.889]                 names <- names(envs)
[10:26:12.889]                 common <- intersect(names, old_names)
[10:26:12.889]                 added <- setdiff(names, old_names)
[10:26:12.889]                 removed <- setdiff(old_names, names)
[10:26:12.889]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.889]                   envs[common]]
[10:26:12.889]                 NAMES <- toupper(changed)
[10:26:12.889]                 args <- list()
[10:26:12.889]                 for (kk in seq_along(NAMES)) {
[10:26:12.889]                   name <- changed[[kk]]
[10:26:12.889]                   NAME <- NAMES[[kk]]
[10:26:12.889]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.889]                     next
[10:26:12.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.889]                 }
[10:26:12.889]                 NAMES <- toupper(added)
[10:26:12.889]                 for (kk in seq_along(NAMES)) {
[10:26:12.889]                   name <- added[[kk]]
[10:26:12.889]                   NAME <- NAMES[[kk]]
[10:26:12.889]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.889]                     next
[10:26:12.889]                   args[[name]] <- ""
[10:26:12.889]                 }
[10:26:12.889]                 NAMES <- toupper(removed)
[10:26:12.889]                 for (kk in seq_along(NAMES)) {
[10:26:12.889]                   name <- removed[[kk]]
[10:26:12.889]                   NAME <- NAMES[[kk]]
[10:26:12.889]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.889]                     next
[10:26:12.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.889]                 }
[10:26:12.889]                 if (length(args) > 0) 
[10:26:12.889]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.889]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.889]             }
[10:26:12.889]             else {
[10:26:12.889]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.889]             }
[10:26:12.889]             {
[10:26:12.889]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.889]                   0L) {
[10:26:12.889]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.889]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.889]                   base::options(opts)
[10:26:12.889]                 }
[10:26:12.889]                 {
[10:26:12.889]                   {
[10:26:12.889]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.889]                     NULL
[10:26:12.889]                   }
[10:26:12.889]                   options(future.plan = NULL)
[10:26:12.889]                   if (is.na(NA_character_)) 
[10:26:12.889]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.889]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.889]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.889]                     envir = parent.frame()) 
[10:26:12.889]                   {
[10:26:12.889]                     default_workers <- missing(workers)
[10:26:12.889]                     if (is.function(workers)) 
[10:26:12.889]                       workers <- workers()
[10:26:12.889]                     workers <- structure(as.integer(workers), 
[10:26:12.889]                       class = class(workers))
[10:26:12.889]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.889]                       1L)
[10:26:12.889]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.889]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.889]                       if (default_workers) 
[10:26:12.889]                         supportsMulticore(warn = TRUE)
[10:26:12.889]                       return(sequential(..., envir = envir))
[10:26:12.889]                     }
[10:26:12.889]                     oopts <- options(mc.cores = workers)
[10:26:12.889]                     on.exit(options(oopts))
[10:26:12.889]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.889]                       envir = envir)
[10:26:12.889]                     if (!future$lazy) 
[10:26:12.889]                       future <- run(future)
[10:26:12.889]                     invisible(future)
[10:26:12.889]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.889]                 }
[10:26:12.889]             }
[10:26:12.889]         }
[10:26:12.889]     })
[10:26:12.889]     if (TRUE) {
[10:26:12.889]         base::sink(type = "output", split = FALSE)
[10:26:12.889]         if (TRUE) {
[10:26:12.889]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.889]         }
[10:26:12.889]         else {
[10:26:12.889]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.889]         }
[10:26:12.889]         base::close(...future.stdout)
[10:26:12.889]         ...future.stdout <- NULL
[10:26:12.889]     }
[10:26:12.889]     ...future.result$conditions <- ...future.conditions
[10:26:12.889]     ...future.result$finished <- base::Sys.time()
[10:26:12.889]     ...future.result
[10:26:12.889] }
[10:26:12.891] requestCore(): workers = 2
[10:26:12.893] MulticoreFuture started
[10:26:12.893] - Launch lazy future ... done
[10:26:12.894] run() for ‘MulticoreFuture’ ... done
[10:26:12.894] plan(): Setting new future strategy stack:
[10:26:12.895] List of future strategies:
[10:26:12.895] 1. sequential:
[10:26:12.895]    - args: function (..., envir = parent.frame())
[10:26:12.895]    - tweaked: FALSE
[10:26:12.895]    - call: NULL
[10:26:12.895] plan(): nbrOfWorkers() = 1
[10:26:12.897] plan(): Setting new future strategy stack:
[10:26:12.898] List of future strategies:
[10:26:12.898] 1. multicore:
[10:26:12.898]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.898]    - tweaked: FALSE
[10:26:12.898]    - call: plan(strategy)
[10:26:12.903] plan(): nbrOfWorkers() = 2
[10:26:12.903] Future #1
[10:26:12.903] result() for MulticoreFuture ...
[10:26:12.904] result() for MulticoreFuture ...
[10:26:12.905] result() for MulticoreFuture ... done
[10:26:12.905] result() for MulticoreFuture ... done
[10:26:12.905] result() for MulticoreFuture ...
[10:26:12.905] result() for MulticoreFuture ... done
[10:26:12.905] A MulticoreFuture was resolved
[10:26:12.905]  length: 0 (resolved future 1)
[10:26:12.905] resolve() on list ... DONE
[10:26:12.906] - globals: [1] ‘a’
[10:26:12.906] Resolving futures part of globals (recursively) ... DONE
[10:26:12.909] The total size of the 1 globals is 1.57 MiB (1641288 bytes)
[10:26:12.909] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[10:26:12.909] - globals: [1] ‘a’
[10:26:12.910] - packages: [1] ‘future’
[10:26:12.910] getGlobalsAndPackages() ... DONE
[10:26:12.910] run() for ‘Future’ ...
[10:26:12.910] - state: ‘created’
[10:26:12.910] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.917] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.917] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.917]   - Field: ‘label’
[10:26:12.918]   - Field: ‘local’
[10:26:12.918]   - Field: ‘owner’
[10:26:12.918]   - Field: ‘envir’
[10:26:12.918]   - Field: ‘workers’
[10:26:12.918]   - Field: ‘packages’
[10:26:12.918]   - Field: ‘gc’
[10:26:12.918]   - Field: ‘job’
[10:26:12.918]   - Field: ‘conditions’
[10:26:12.919]   - Field: ‘expr’
[10:26:12.919]   - Field: ‘uuid’
[10:26:12.919]   - Field: ‘seed’
[10:26:12.919]   - Field: ‘version’
[10:26:12.919]   - Field: ‘result’
[10:26:12.919]   - Field: ‘asynchronous’
[10:26:12.919]   - Field: ‘calls’
[10:26:12.919]   - Field: ‘globals’
[10:26:12.920]   - Field: ‘stdout’
[10:26:12.920]   - Field: ‘earlySignal’
[10:26:12.920]   - Field: ‘lazy’
[10:26:12.920]   - Field: ‘state’
[10:26:12.920] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.920] - Launch lazy future ...
[10:26:12.921] Packages needed by the future expression (n = 1): ‘future’
[10:26:12.921] Packages needed by future strategies (n = 0): <none>
[10:26:12.922] {
[10:26:12.922]     {
[10:26:12.922]         {
[10:26:12.922]             ...future.startTime <- base::Sys.time()
[10:26:12.922]             {
[10:26:12.922]                 {
[10:26:12.922]                   {
[10:26:12.922]                     {
[10:26:12.922]                       {
[10:26:12.922]                         base::local({
[10:26:12.922]                           has_future <- base::requireNamespace("future", 
[10:26:12.922]                             quietly = TRUE)
[10:26:12.922]                           if (has_future) {
[10:26:12.922]                             ns <- base::getNamespace("future")
[10:26:12.922]                             version <- ns[[".package"]][["version"]]
[10:26:12.922]                             if (is.null(version)) 
[10:26:12.922]                               version <- utils::packageVersion("future")
[10:26:12.922]                           }
[10:26:12.922]                           else {
[10:26:12.922]                             version <- NULL
[10:26:12.922]                           }
[10:26:12.922]                           if (!has_future || version < "1.8.0") {
[10:26:12.922]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.922]                               "", base::R.version$version.string), 
[10:26:12.922]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:12.922]                                 base::R.version$platform, 8 * 
[10:26:12.922]                                   base::.Machine$sizeof.pointer), 
[10:26:12.922]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.922]                                 "release", "version")], collapse = " "), 
[10:26:12.922]                               hostname = base::Sys.info()[["nodename"]])
[10:26:12.922]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.922]                               info)
[10:26:12.922]                             info <- base::paste(info, collapse = "; ")
[10:26:12.922]                             if (!has_future) {
[10:26:12.922]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.922]                                 info)
[10:26:12.922]                             }
[10:26:12.922]                             else {
[10:26:12.922]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.922]                                 info, version)
[10:26:12.922]                             }
[10:26:12.922]                             base::stop(msg)
[10:26:12.922]                           }
[10:26:12.922]                         })
[10:26:12.922]                       }
[10:26:12.922]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.922]                       base::options(mc.cores = 1L)
[10:26:12.922]                     }
[10:26:12.922]                     base::local({
[10:26:12.922]                       for (pkg in "future") {
[10:26:12.922]                         base::loadNamespace(pkg)
[10:26:12.922]                         base::library(pkg, character.only = TRUE)
[10:26:12.922]                       }
[10:26:12.922]                     })
[10:26:12.922]                   }
[10:26:12.922]                   options(future.plan = NULL)
[10:26:12.922]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.922]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.922]                 }
[10:26:12.922]                 ...future.workdir <- getwd()
[10:26:12.922]             }
[10:26:12.922]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.922]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.922]         }
[10:26:12.922]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.922]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:12.922]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.922]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.922]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.922]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.922]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.922]             base::names(...future.oldOptions))
[10:26:12.922]     }
[10:26:12.922]     if (FALSE) {
[10:26:12.922]     }
[10:26:12.922]     else {
[10:26:12.922]         if (TRUE) {
[10:26:12.922]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.922]                 open = "w")
[10:26:12.922]         }
[10:26:12.922]         else {
[10:26:12.922]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.922]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.922]         }
[10:26:12.922]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.922]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.922]             base::sink(type = "output", split = FALSE)
[10:26:12.922]             base::close(...future.stdout)
[10:26:12.922]         }, add = TRUE)
[10:26:12.922]     }
[10:26:12.922]     ...future.frame <- base::sys.nframe()
[10:26:12.922]     ...future.conditions <- base::list()
[10:26:12.922]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.922]     if (FALSE) {
[10:26:12.922]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.922]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.922]     }
[10:26:12.922]     ...future.result <- base::tryCatch({
[10:26:12.922]         base::withCallingHandlers({
[10:26:12.922]             ...future.value <- base::withVisible(base::local({
[10:26:12.922]                 withCallingHandlers({
[10:26:12.922]                   value(a) + 1
[10:26:12.922]                 }, immediateCondition = function(cond) {
[10:26:12.922]                   save_rds <- function (object, pathname, ...) 
[10:26:12.922]                   {
[10:26:12.922]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.922]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.922]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.922]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.922]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.922]                         fi_tmp[["mtime"]])
[10:26:12.922]                     }
[10:26:12.922]                     tryCatch({
[10:26:12.922]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.922]                     }, error = function(ex) {
[10:26:12.922]                       msg <- conditionMessage(ex)
[10:26:12.922]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.922]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.922]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.922]                         fi_tmp[["mtime"]], msg)
[10:26:12.922]                       ex$message <- msg
[10:26:12.922]                       stop(ex)
[10:26:12.922]                     })
[10:26:12.922]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.922]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.922]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.922]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.922]                       fi <- file.info(pathname)
[10:26:12.922]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.922]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.922]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.922]                         fi[["size"]], fi[["mtime"]])
[10:26:12.922]                       stop(msg)
[10:26:12.922]                     }
[10:26:12.922]                     invisible(pathname)
[10:26:12.922]                   }
[10:26:12.922]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.922]                     rootPath = tempdir()) 
[10:26:12.922]                   {
[10:26:12.922]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.922]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.922]                       tmpdir = path, fileext = ".rds")
[10:26:12.922]                     save_rds(obj, file)
[10:26:12.922]                   }
[10:26:12.922]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.922]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.922]                   {
[10:26:12.922]                     inherits <- base::inherits
[10:26:12.922]                     invokeRestart <- base::invokeRestart
[10:26:12.922]                     is.null <- base::is.null
[10:26:12.922]                     muffled <- FALSE
[10:26:12.922]                     if (inherits(cond, "message")) {
[10:26:12.922]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.922]                       if (muffled) 
[10:26:12.922]                         invokeRestart("muffleMessage")
[10:26:12.922]                     }
[10:26:12.922]                     else if (inherits(cond, "warning")) {
[10:26:12.922]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.922]                       if (muffled) 
[10:26:12.922]                         invokeRestart("muffleWarning")
[10:26:12.922]                     }
[10:26:12.922]                     else if (inherits(cond, "condition")) {
[10:26:12.922]                       if (!is.null(pattern)) {
[10:26:12.922]                         computeRestarts <- base::computeRestarts
[10:26:12.922]                         grepl <- base::grepl
[10:26:12.922]                         restarts <- computeRestarts(cond)
[10:26:12.922]                         for (restart in restarts) {
[10:26:12.922]                           name <- restart$name
[10:26:12.922]                           if (is.null(name)) 
[10:26:12.922]                             next
[10:26:12.922]                           if (!grepl(pattern, name)) 
[10:26:12.922]                             next
[10:26:12.922]                           invokeRestart(restart)
[10:26:12.922]                           muffled <- TRUE
[10:26:12.922]                           break
[10:26:12.922]                         }
[10:26:12.922]                       }
[10:26:12.922]                     }
[10:26:12.922]                     invisible(muffled)
[10:26:12.922]                   }
[10:26:12.922]                   muffleCondition(cond)
[10:26:12.922]                 })
[10:26:12.922]             }))
[10:26:12.922]             future::FutureResult(value = ...future.value$value, 
[10:26:12.922]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.922]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.922]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.922]                     ...future.globalenv.names))
[10:26:12.922]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.922]         }, condition = base::local({
[10:26:12.922]             c <- base::c
[10:26:12.922]             inherits <- base::inherits
[10:26:12.922]             invokeRestart <- base::invokeRestart
[10:26:12.922]             length <- base::length
[10:26:12.922]             list <- base::list
[10:26:12.922]             seq.int <- base::seq.int
[10:26:12.922]             signalCondition <- base::signalCondition
[10:26:12.922]             sys.calls <- base::sys.calls
[10:26:12.922]             `[[` <- base::`[[`
[10:26:12.922]             `+` <- base::`+`
[10:26:12.922]             `<<-` <- base::`<<-`
[10:26:12.922]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.922]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.922]                   3L)]
[10:26:12.922]             }
[10:26:12.922]             function(cond) {
[10:26:12.922]                 is_error <- inherits(cond, "error")
[10:26:12.922]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.922]                   NULL)
[10:26:12.922]                 if (is_error) {
[10:26:12.922]                   sessionInformation <- function() {
[10:26:12.922]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.922]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.922]                       search = base::search(), system = base::Sys.info())
[10:26:12.922]                   }
[10:26:12.922]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.922]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.922]                     cond$call), session = sessionInformation(), 
[10:26:12.922]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.922]                   signalCondition(cond)
[10:26:12.922]                 }
[10:26:12.922]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.922]                 "immediateCondition"))) {
[10:26:12.922]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.922]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.922]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.922]                   if (TRUE && !signal) {
[10:26:12.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.922]                     {
[10:26:12.922]                       inherits <- base::inherits
[10:26:12.922]                       invokeRestart <- base::invokeRestart
[10:26:12.922]                       is.null <- base::is.null
[10:26:12.922]                       muffled <- FALSE
[10:26:12.922]                       if (inherits(cond, "message")) {
[10:26:12.922]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.922]                         if (muffled) 
[10:26:12.922]                           invokeRestart("muffleMessage")
[10:26:12.922]                       }
[10:26:12.922]                       else if (inherits(cond, "warning")) {
[10:26:12.922]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.922]                         if (muffled) 
[10:26:12.922]                           invokeRestart("muffleWarning")
[10:26:12.922]                       }
[10:26:12.922]                       else if (inherits(cond, "condition")) {
[10:26:12.922]                         if (!is.null(pattern)) {
[10:26:12.922]                           computeRestarts <- base::computeRestarts
[10:26:12.922]                           grepl <- base::grepl
[10:26:12.922]                           restarts <- computeRestarts(cond)
[10:26:12.922]                           for (restart in restarts) {
[10:26:12.922]                             name <- restart$name
[10:26:12.922]                             if (is.null(name)) 
[10:26:12.922]                               next
[10:26:12.922]                             if (!grepl(pattern, name)) 
[10:26:12.922]                               next
[10:26:12.922]                             invokeRestart(restart)
[10:26:12.922]                             muffled <- TRUE
[10:26:12.922]                             break
[10:26:12.922]                           }
[10:26:12.922]                         }
[10:26:12.922]                       }
[10:26:12.922]                       invisible(muffled)
[10:26:12.922]                     }
[10:26:12.922]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.922]                   }
[10:26:12.922]                 }
[10:26:12.922]                 else {
[10:26:12.922]                   if (TRUE) {
[10:26:12.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.922]                     {
[10:26:12.922]                       inherits <- base::inherits
[10:26:12.922]                       invokeRestart <- base::invokeRestart
[10:26:12.922]                       is.null <- base::is.null
[10:26:12.922]                       muffled <- FALSE
[10:26:12.922]                       if (inherits(cond, "message")) {
[10:26:12.922]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.922]                         if (muffled) 
[10:26:12.922]                           invokeRestart("muffleMessage")
[10:26:12.922]                       }
[10:26:12.922]                       else if (inherits(cond, "warning")) {
[10:26:12.922]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.922]                         if (muffled) 
[10:26:12.922]                           invokeRestart("muffleWarning")
[10:26:12.922]                       }
[10:26:12.922]                       else if (inherits(cond, "condition")) {
[10:26:12.922]                         if (!is.null(pattern)) {
[10:26:12.922]                           computeRestarts <- base::computeRestarts
[10:26:12.922]                           grepl <- base::grepl
[10:26:12.922]                           restarts <- computeRestarts(cond)
[10:26:12.922]                           for (restart in restarts) {
[10:26:12.922]                             name <- restart$name
[10:26:12.922]                             if (is.null(name)) 
[10:26:12.922]                               next
[10:26:12.922]                             if (!grepl(pattern, name)) 
[10:26:12.922]                               next
[10:26:12.922]                             invokeRestart(restart)
[10:26:12.922]                             muffled <- TRUE
[10:26:12.922]                             break
[10:26:12.922]                           }
[10:26:12.922]                         }
[10:26:12.922]                       }
[10:26:12.922]                       invisible(muffled)
[10:26:12.922]                     }
[10:26:12.922]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.922]                   }
[10:26:12.922]                 }
[10:26:12.922]             }
[10:26:12.922]         }))
[10:26:12.922]     }, error = function(ex) {
[10:26:12.922]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.922]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.922]                 ...future.rng), started = ...future.startTime, 
[10:26:12.922]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.922]             version = "1.8"), class = "FutureResult")
[10:26:12.922]     }, finally = {
[10:26:12.922]         if (!identical(...future.workdir, getwd())) 
[10:26:12.922]             setwd(...future.workdir)
[10:26:12.922]         {
[10:26:12.922]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.922]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.922]             }
[10:26:12.922]             base::options(...future.oldOptions)
[10:26:12.922]             if (.Platform$OS.type == "windows") {
[10:26:12.922]                 old_names <- names(...future.oldEnvVars)
[10:26:12.922]                 envs <- base::Sys.getenv()
[10:26:12.922]                 names <- names(envs)
[10:26:12.922]                 common <- intersect(names, old_names)
[10:26:12.922]                 added <- setdiff(names, old_names)
[10:26:12.922]                 removed <- setdiff(old_names, names)
[10:26:12.922]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.922]                   envs[common]]
[10:26:12.922]                 NAMES <- toupper(changed)
[10:26:12.922]                 args <- list()
[10:26:12.922]                 for (kk in seq_along(NAMES)) {
[10:26:12.922]                   name <- changed[[kk]]
[10:26:12.922]                   NAME <- NAMES[[kk]]
[10:26:12.922]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.922]                     next
[10:26:12.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.922]                 }
[10:26:12.922]                 NAMES <- toupper(added)
[10:26:12.922]                 for (kk in seq_along(NAMES)) {
[10:26:12.922]                   name <- added[[kk]]
[10:26:12.922]                   NAME <- NAMES[[kk]]
[10:26:12.922]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.922]                     next
[10:26:12.922]                   args[[name]] <- ""
[10:26:12.922]                 }
[10:26:12.922]                 NAMES <- toupper(removed)
[10:26:12.922]                 for (kk in seq_along(NAMES)) {
[10:26:12.922]                   name <- removed[[kk]]
[10:26:12.922]                   NAME <- NAMES[[kk]]
[10:26:12.922]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.922]                     next
[10:26:12.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.922]                 }
[10:26:12.922]                 if (length(args) > 0) 
[10:26:12.922]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.922]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.922]             }
[10:26:12.922]             else {
[10:26:12.922]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.922]             }
[10:26:12.922]             {
[10:26:12.922]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.922]                   0L) {
[10:26:12.922]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.922]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.922]                   base::options(opts)
[10:26:12.922]                 }
[10:26:12.922]                 {
[10:26:12.922]                   {
[10:26:12.922]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.922]                     NULL
[10:26:12.922]                   }
[10:26:12.922]                   options(future.plan = NULL)
[10:26:12.922]                   if (is.na(NA_character_)) 
[10:26:12.922]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.922]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.922]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.922]                     envir = parent.frame()) 
[10:26:12.922]                   {
[10:26:12.922]                     default_workers <- missing(workers)
[10:26:12.922]                     if (is.function(workers)) 
[10:26:12.922]                       workers <- workers()
[10:26:12.922]                     workers <- structure(as.integer(workers), 
[10:26:12.922]                       class = class(workers))
[10:26:12.922]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.922]                       1L)
[10:26:12.922]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.922]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.922]                       if (default_workers) 
[10:26:12.922]                         supportsMulticore(warn = TRUE)
[10:26:12.922]                       return(sequential(..., envir = envir))
[10:26:12.922]                     }
[10:26:12.922]                     oopts <- options(mc.cores = workers)
[10:26:12.922]                     on.exit(options(oopts))
[10:26:12.922]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.922]                       envir = envir)
[10:26:12.922]                     if (!future$lazy) 
[10:26:12.922]                       future <- run(future)
[10:26:12.922]                     invisible(future)
[10:26:12.922]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.922]                 }
[10:26:12.922]             }
[10:26:12.922]         }
[10:26:12.922]     })
[10:26:12.922]     if (TRUE) {
[10:26:12.922]         base::sink(type = "output", split = FALSE)
[10:26:12.922]         if (TRUE) {
[10:26:12.922]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.922]         }
[10:26:12.922]         else {
[10:26:12.922]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.922]         }
[10:26:12.922]         base::close(...future.stdout)
[10:26:12.922]         ...future.stdout <- NULL
[10:26:12.922]     }
[10:26:12.922]     ...future.result$conditions <- ...future.conditions
[10:26:12.922]     ...future.result$finished <- base::Sys.time()
[10:26:12.922]     ...future.result
[10:26:12.922] }
[10:26:12.924] assign_globals() ...
[10:26:12.924] List of 1
[10:26:12.924]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a0222acd50> 
[10:26:12.924]  - attr(*, "where")=List of 1
[10:26:12.924]   ..$ a:<environment: R_EmptyEnv> 
[10:26:12.924]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:12.924]  - attr(*, "resolved")= logi TRUE
[10:26:12.924]  - attr(*, "total_size")= num 1641288
[10:26:12.924]  - attr(*, "already-done")= logi TRUE
[10:26:12.928] - copied ‘a’ to environment
[10:26:12.928] assign_globals() ... done
[10:26:12.928] requestCore(): workers = 2
[10:26:12.930] MulticoreFuture started
[10:26:12.930] - Launch lazy future ... done
[10:26:12.930] run() for ‘MulticoreFuture’ ... done
[10:26:12.931] result() for MulticoreFuture ...
[10:26:12.931] plan(): Setting new future strategy stack:
[10:26:12.931] List of future strategies:
[10:26:12.931] 1. sequential:
[10:26:12.931]    - args: function (..., envir = parent.frame())
[10:26:12.931]    - tweaked: FALSE
[10:26:12.931]    - call: NULL
[10:26:12.932] plan(): nbrOfWorkers() = 1
[10:26:12.936] plan(): Setting new future strategy stack:
[10:26:12.936] List of future strategies:
[10:26:12.936] 1. multicore:
[10:26:12.936]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.936]    - tweaked: FALSE
[10:26:12.936]    - call: plan(strategy)
[10:26:12.941] plan(): nbrOfWorkers() = 2
[10:26:12.942] result() for MulticoreFuture ...
[10:26:12.942] result() for MulticoreFuture ... done
[10:26:12.942] signalConditions() ...
[10:26:12.942]  - include = ‘immediateCondition’
[10:26:12.943]  - exclude = 
[10:26:12.943]  - resignal = FALSE
[10:26:12.943]  - Number of conditions: 4
[10:26:12.943] signalConditions() ... done
[10:26:12.943] result() for MulticoreFuture ... done
[10:26:12.943] result() for MulticoreFuture ...
[10:26:12.944] result() for MulticoreFuture ... done
[10:26:12.944] signalConditions() ...
[10:26:12.944]  - include = ‘immediateCondition’
[10:26:12.944]  - exclude = 
[10:26:12.944]  - resignal = FALSE
[10:26:12.944]  - Number of conditions: 4
[10:26:12.944] signalConditions() ... done
[10:26:12.945] Future state: ‘finished’
[10:26:12.945] result() for MulticoreFuture ...
[10:26:12.945] result() for MulticoreFuture ... done
[10:26:12.945] signalConditions() ...
[10:26:12.945]  - include = ‘condition’
[10:26:12.945]  - exclude = ‘immediateCondition’
[10:26:12.945]  - resignal = TRUE
[10:26:12.945]  - Number of conditions: 4
[10:26:12.945]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.934] result() for MulticoreFuture ...
[10:26:12.946]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.934] result() for MulticoreFuture ... done
[10:26:12.946]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.934] result() for MulticoreFuture ...
[10:26:12.946]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.935] result() for MulticoreFuture ... done
[10:26:12.946] signalConditions() ... done
value(b) = 2
[10:26:12.946] result() for MulticoreFuture ...
[10:26:12.947] result() for MulticoreFuture ... done
[10:26:12.947] result() for MulticoreFuture ...
[10:26:12.947] result() for MulticoreFuture ... done
[10:26:12.947] signalConditions() ...
[10:26:12.947]  - include = ‘immediateCondition’
[10:26:12.947]  - exclude = 
[10:26:12.947]  - resignal = FALSE
[10:26:12.947]  - Number of conditions: 4
[10:26:12.947] signalConditions() ... done
[10:26:12.948] Future state: ‘finished’
[10:26:12.948] result() for MulticoreFuture ...
[10:26:12.948] result() for MulticoreFuture ... done
[10:26:12.948] signalConditions() ...
[10:26:12.948]  - include = ‘condition’
[10:26:12.948]  - exclude = ‘immediateCondition’
[10:26:12.948]  - resignal = TRUE
[10:26:12.948]  - Number of conditions: 4
[10:26:12.948]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.934] result() for MulticoreFuture ...
[10:26:12.949]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.934] result() for MulticoreFuture ... done
[10:26:12.949]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.934] result() for MulticoreFuture ...
[10:26:12.949]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:12.935] result() for MulticoreFuture ... done
[10:26:12.949] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.949] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.950] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:12.950] 
[10:26:12.950] Searching for globals ... DONE
[10:26:12.951] - globals: [0] <none>
[10:26:12.951] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:12.951] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:12.951] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:12.952] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:12.952] Searching for globals ... DONE
[10:26:12.953] Resolving globals: TRUE
[10:26:12.953] Resolving any globals that are futures ...
[10:26:12.953] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:12.953] Resolving any globals that are futures ... DONE
[10:26:12.953] Resolving futures part of globals (recursively) ...
[10:26:12.954] resolve() on list ...
[10:26:12.954]  recursive: 99
[10:26:12.954]  length: 1
[10:26:12.954]  elements: ‘a’
[10:26:12.954] run() for ‘Future’ ...
[10:26:12.954] - state: ‘created’
[10:26:12.954] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.961] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.961] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.961]   - Field: ‘label’
[10:26:12.962]   - Field: ‘local’
[10:26:12.962]   - Field: ‘owner’
[10:26:12.962]   - Field: ‘envir’
[10:26:12.962]   - Field: ‘workers’
[10:26:12.962]   - Field: ‘packages’
[10:26:12.962]   - Field: ‘gc’
[10:26:12.962]   - Field: ‘job’
[10:26:12.962]   - Field: ‘conditions’
[10:26:12.963]   - Field: ‘expr’
[10:26:12.963]   - Field: ‘uuid’
[10:26:12.963]   - Field: ‘seed’
[10:26:12.963]   - Field: ‘version’
[10:26:12.963]   - Field: ‘result’
[10:26:12.963]   - Field: ‘asynchronous’
[10:26:12.963]   - Field: ‘calls’
[10:26:12.963]   - Field: ‘globals’
[10:26:12.964]   - Field: ‘stdout’
[10:26:12.964]   - Field: ‘earlySignal’
[10:26:12.964]   - Field: ‘lazy’
[10:26:12.964]   - Field: ‘state’
[10:26:12.964] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.964] - Launch lazy future ...
[10:26:12.965] Packages needed by the future expression (n = 0): <none>
[10:26:12.965] Packages needed by future strategies (n = 0): <none>
[10:26:12.965] {
[10:26:12.965]     {
[10:26:12.965]         {
[10:26:12.965]             ...future.startTime <- base::Sys.time()
[10:26:12.965]             {
[10:26:12.965]                 {
[10:26:12.965]                   {
[10:26:12.965]                     {
[10:26:12.965]                       base::local({
[10:26:12.965]                         has_future <- base::requireNamespace("future", 
[10:26:12.965]                           quietly = TRUE)
[10:26:12.965]                         if (has_future) {
[10:26:12.965]                           ns <- base::getNamespace("future")
[10:26:12.965]                           version <- ns[[".package"]][["version"]]
[10:26:12.965]                           if (is.null(version)) 
[10:26:12.965]                             version <- utils::packageVersion("future")
[10:26:12.965]                         }
[10:26:12.965]                         else {
[10:26:12.965]                           version <- NULL
[10:26:12.965]                         }
[10:26:12.965]                         if (!has_future || version < "1.8.0") {
[10:26:12.965]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.965]                             "", base::R.version$version.string), 
[10:26:12.965]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:12.965]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:12.965]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.965]                               "release", "version")], collapse = " "), 
[10:26:12.965]                             hostname = base::Sys.info()[["nodename"]])
[10:26:12.965]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.965]                             info)
[10:26:12.965]                           info <- base::paste(info, collapse = "; ")
[10:26:12.965]                           if (!has_future) {
[10:26:12.965]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.965]                               info)
[10:26:12.965]                           }
[10:26:12.965]                           else {
[10:26:12.965]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.965]                               info, version)
[10:26:12.965]                           }
[10:26:12.965]                           base::stop(msg)
[10:26:12.965]                         }
[10:26:12.965]                       })
[10:26:12.965]                     }
[10:26:12.965]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.965]                     base::options(mc.cores = 1L)
[10:26:12.965]                   }
[10:26:12.965]                   options(future.plan = NULL)
[10:26:12.965]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.965]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.965]                 }
[10:26:12.965]                 ...future.workdir <- getwd()
[10:26:12.965]             }
[10:26:12.965]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.965]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.965]         }
[10:26:12.965]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.965]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:12.965]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.965]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.965]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.965]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.965]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.965]             base::names(...future.oldOptions))
[10:26:12.965]     }
[10:26:12.965]     if (FALSE) {
[10:26:12.965]     }
[10:26:12.965]     else {
[10:26:12.965]         if (TRUE) {
[10:26:12.965]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.965]                 open = "w")
[10:26:12.965]         }
[10:26:12.965]         else {
[10:26:12.965]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.965]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.965]         }
[10:26:12.965]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.965]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.965]             base::sink(type = "output", split = FALSE)
[10:26:12.965]             base::close(...future.stdout)
[10:26:12.965]         }, add = TRUE)
[10:26:12.965]     }
[10:26:12.965]     ...future.frame <- base::sys.nframe()
[10:26:12.965]     ...future.conditions <- base::list()
[10:26:12.965]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.965]     if (FALSE) {
[10:26:12.965]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.965]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.965]     }
[10:26:12.965]     ...future.result <- base::tryCatch({
[10:26:12.965]         base::withCallingHandlers({
[10:26:12.965]             ...future.value <- base::withVisible(base::local({
[10:26:12.965]                 withCallingHandlers({
[10:26:12.965]                   1
[10:26:12.965]                 }, immediateCondition = function(cond) {
[10:26:12.965]                   save_rds <- function (object, pathname, ...) 
[10:26:12.965]                   {
[10:26:12.965]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.965]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.965]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.965]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.965]                         fi_tmp[["mtime"]])
[10:26:12.965]                     }
[10:26:12.965]                     tryCatch({
[10:26:12.965]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.965]                     }, error = function(ex) {
[10:26:12.965]                       msg <- conditionMessage(ex)
[10:26:12.965]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.965]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.965]                         fi_tmp[["mtime"]], msg)
[10:26:12.965]                       ex$message <- msg
[10:26:12.965]                       stop(ex)
[10:26:12.965]                     })
[10:26:12.965]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.965]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.965]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.965]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.965]                       fi <- file.info(pathname)
[10:26:12.965]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.965]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.965]                         fi[["size"]], fi[["mtime"]])
[10:26:12.965]                       stop(msg)
[10:26:12.965]                     }
[10:26:12.965]                     invisible(pathname)
[10:26:12.965]                   }
[10:26:12.965]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.965]                     rootPath = tempdir()) 
[10:26:12.965]                   {
[10:26:12.965]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.965]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.965]                       tmpdir = path, fileext = ".rds")
[10:26:12.965]                     save_rds(obj, file)
[10:26:12.965]                   }
[10:26:12.965]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.965]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.965]                   {
[10:26:12.965]                     inherits <- base::inherits
[10:26:12.965]                     invokeRestart <- base::invokeRestart
[10:26:12.965]                     is.null <- base::is.null
[10:26:12.965]                     muffled <- FALSE
[10:26:12.965]                     if (inherits(cond, "message")) {
[10:26:12.965]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.965]                       if (muffled) 
[10:26:12.965]                         invokeRestart("muffleMessage")
[10:26:12.965]                     }
[10:26:12.965]                     else if (inherits(cond, "warning")) {
[10:26:12.965]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.965]                       if (muffled) 
[10:26:12.965]                         invokeRestart("muffleWarning")
[10:26:12.965]                     }
[10:26:12.965]                     else if (inherits(cond, "condition")) {
[10:26:12.965]                       if (!is.null(pattern)) {
[10:26:12.965]                         computeRestarts <- base::computeRestarts
[10:26:12.965]                         grepl <- base::grepl
[10:26:12.965]                         restarts <- computeRestarts(cond)
[10:26:12.965]                         for (restart in restarts) {
[10:26:12.965]                           name <- restart$name
[10:26:12.965]                           if (is.null(name)) 
[10:26:12.965]                             next
[10:26:12.965]                           if (!grepl(pattern, name)) 
[10:26:12.965]                             next
[10:26:12.965]                           invokeRestart(restart)
[10:26:12.965]                           muffled <- TRUE
[10:26:12.965]                           break
[10:26:12.965]                         }
[10:26:12.965]                       }
[10:26:12.965]                     }
[10:26:12.965]                     invisible(muffled)
[10:26:12.965]                   }
[10:26:12.965]                   muffleCondition(cond)
[10:26:12.965]                 })
[10:26:12.965]             }))
[10:26:12.965]             future::FutureResult(value = ...future.value$value, 
[10:26:12.965]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.965]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.965]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.965]                     ...future.globalenv.names))
[10:26:12.965]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.965]         }, condition = base::local({
[10:26:12.965]             c <- base::c
[10:26:12.965]             inherits <- base::inherits
[10:26:12.965]             invokeRestart <- base::invokeRestart
[10:26:12.965]             length <- base::length
[10:26:12.965]             list <- base::list
[10:26:12.965]             seq.int <- base::seq.int
[10:26:12.965]             signalCondition <- base::signalCondition
[10:26:12.965]             sys.calls <- base::sys.calls
[10:26:12.965]             `[[` <- base::`[[`
[10:26:12.965]             `+` <- base::`+`
[10:26:12.965]             `<<-` <- base::`<<-`
[10:26:12.965]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.965]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.965]                   3L)]
[10:26:12.965]             }
[10:26:12.965]             function(cond) {
[10:26:12.965]                 is_error <- inherits(cond, "error")
[10:26:12.965]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.965]                   NULL)
[10:26:12.965]                 if (is_error) {
[10:26:12.965]                   sessionInformation <- function() {
[10:26:12.965]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.965]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.965]                       search = base::search(), system = base::Sys.info())
[10:26:12.965]                   }
[10:26:12.965]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.965]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.965]                     cond$call), session = sessionInformation(), 
[10:26:12.965]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.965]                   signalCondition(cond)
[10:26:12.965]                 }
[10:26:12.965]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.965]                 "immediateCondition"))) {
[10:26:12.965]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.965]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.965]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.965]                   if (TRUE && !signal) {
[10:26:12.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.965]                     {
[10:26:12.965]                       inherits <- base::inherits
[10:26:12.965]                       invokeRestart <- base::invokeRestart
[10:26:12.965]                       is.null <- base::is.null
[10:26:12.965]                       muffled <- FALSE
[10:26:12.965]                       if (inherits(cond, "message")) {
[10:26:12.965]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.965]                         if (muffled) 
[10:26:12.965]                           invokeRestart("muffleMessage")
[10:26:12.965]                       }
[10:26:12.965]                       else if (inherits(cond, "warning")) {
[10:26:12.965]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.965]                         if (muffled) 
[10:26:12.965]                           invokeRestart("muffleWarning")
[10:26:12.965]                       }
[10:26:12.965]                       else if (inherits(cond, "condition")) {
[10:26:12.965]                         if (!is.null(pattern)) {
[10:26:12.965]                           computeRestarts <- base::computeRestarts
[10:26:12.965]                           grepl <- base::grepl
[10:26:12.965]                           restarts <- computeRestarts(cond)
[10:26:12.965]                           for (restart in restarts) {
[10:26:12.965]                             name <- restart$name
[10:26:12.965]                             if (is.null(name)) 
[10:26:12.965]                               next
[10:26:12.965]                             if (!grepl(pattern, name)) 
[10:26:12.965]                               next
[10:26:12.965]                             invokeRestart(restart)
[10:26:12.965]                             muffled <- TRUE
[10:26:12.965]                             break
[10:26:12.965]                           }
[10:26:12.965]                         }
[10:26:12.965]                       }
[10:26:12.965]                       invisible(muffled)
[10:26:12.965]                     }
[10:26:12.965]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.965]                   }
[10:26:12.965]                 }
[10:26:12.965]                 else {
[10:26:12.965]                   if (TRUE) {
[10:26:12.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.965]                     {
[10:26:12.965]                       inherits <- base::inherits
[10:26:12.965]                       invokeRestart <- base::invokeRestart
[10:26:12.965]                       is.null <- base::is.null
[10:26:12.965]                       muffled <- FALSE
[10:26:12.965]                       if (inherits(cond, "message")) {
[10:26:12.965]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.965]                         if (muffled) 
[10:26:12.965]                           invokeRestart("muffleMessage")
[10:26:12.965]                       }
[10:26:12.965]                       else if (inherits(cond, "warning")) {
[10:26:12.965]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.965]                         if (muffled) 
[10:26:12.965]                           invokeRestart("muffleWarning")
[10:26:12.965]                       }
[10:26:12.965]                       else if (inherits(cond, "condition")) {
[10:26:12.965]                         if (!is.null(pattern)) {
[10:26:12.965]                           computeRestarts <- base::computeRestarts
[10:26:12.965]                           grepl <- base::grepl
[10:26:12.965]                           restarts <- computeRestarts(cond)
[10:26:12.965]                           for (restart in restarts) {
[10:26:12.965]                             name <- restart$name
[10:26:12.965]                             if (is.null(name)) 
[10:26:12.965]                               next
[10:26:12.965]                             if (!grepl(pattern, name)) 
[10:26:12.965]                               next
[10:26:12.965]                             invokeRestart(restart)
[10:26:12.965]                             muffled <- TRUE
[10:26:12.965]                             break
[10:26:12.965]                           }
[10:26:12.965]                         }
[10:26:12.965]                       }
[10:26:12.965]                       invisible(muffled)
[10:26:12.965]                     }
[10:26:12.965]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.965]                   }
[10:26:12.965]                 }
[10:26:12.965]             }
[10:26:12.965]         }))
[10:26:12.965]     }, error = function(ex) {
[10:26:12.965]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.965]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.965]                 ...future.rng), started = ...future.startTime, 
[10:26:12.965]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.965]             version = "1.8"), class = "FutureResult")
[10:26:12.965]     }, finally = {
[10:26:12.965]         if (!identical(...future.workdir, getwd())) 
[10:26:12.965]             setwd(...future.workdir)
[10:26:12.965]         {
[10:26:12.965]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.965]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.965]             }
[10:26:12.965]             base::options(...future.oldOptions)
[10:26:12.965]             if (.Platform$OS.type == "windows") {
[10:26:12.965]                 old_names <- names(...future.oldEnvVars)
[10:26:12.965]                 envs <- base::Sys.getenv()
[10:26:12.965]                 names <- names(envs)
[10:26:12.965]                 common <- intersect(names, old_names)
[10:26:12.965]                 added <- setdiff(names, old_names)
[10:26:12.965]                 removed <- setdiff(old_names, names)
[10:26:12.965]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.965]                   envs[common]]
[10:26:12.965]                 NAMES <- toupper(changed)
[10:26:12.965]                 args <- list()
[10:26:12.965]                 for (kk in seq_along(NAMES)) {
[10:26:12.965]                   name <- changed[[kk]]
[10:26:12.965]                   NAME <- NAMES[[kk]]
[10:26:12.965]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.965]                     next
[10:26:12.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.965]                 }
[10:26:12.965]                 NAMES <- toupper(added)
[10:26:12.965]                 for (kk in seq_along(NAMES)) {
[10:26:12.965]                   name <- added[[kk]]
[10:26:12.965]                   NAME <- NAMES[[kk]]
[10:26:12.965]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.965]                     next
[10:26:12.965]                   args[[name]] <- ""
[10:26:12.965]                 }
[10:26:12.965]                 NAMES <- toupper(removed)
[10:26:12.965]                 for (kk in seq_along(NAMES)) {
[10:26:12.965]                   name <- removed[[kk]]
[10:26:12.965]                   NAME <- NAMES[[kk]]
[10:26:12.965]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.965]                     next
[10:26:12.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.965]                 }
[10:26:12.965]                 if (length(args) > 0) 
[10:26:12.965]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.965]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.965]             }
[10:26:12.965]             else {
[10:26:12.965]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.965]             }
[10:26:12.965]             {
[10:26:12.965]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.965]                   0L) {
[10:26:12.965]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.965]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.965]                   base::options(opts)
[10:26:12.965]                 }
[10:26:12.965]                 {
[10:26:12.965]                   {
[10:26:12.965]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.965]                     NULL
[10:26:12.965]                   }
[10:26:12.965]                   options(future.plan = NULL)
[10:26:12.965]                   if (is.na(NA_character_)) 
[10:26:12.965]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.965]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.965]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.965]                     envir = parent.frame()) 
[10:26:12.965]                   {
[10:26:12.965]                     default_workers <- missing(workers)
[10:26:12.965]                     if (is.function(workers)) 
[10:26:12.965]                       workers <- workers()
[10:26:12.965]                     workers <- structure(as.integer(workers), 
[10:26:12.965]                       class = class(workers))
[10:26:12.965]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.965]                       1L)
[10:26:12.965]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.965]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.965]                       if (default_workers) 
[10:26:12.965]                         supportsMulticore(warn = TRUE)
[10:26:12.965]                       return(sequential(..., envir = envir))
[10:26:12.965]                     }
[10:26:12.965]                     oopts <- options(mc.cores = workers)
[10:26:12.965]                     on.exit(options(oopts))
[10:26:12.965]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.965]                       envir = envir)
[10:26:12.965]                     if (!future$lazy) 
[10:26:12.965]                       future <- run(future)
[10:26:12.965]                     invisible(future)
[10:26:12.965]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.965]                 }
[10:26:12.965]             }
[10:26:12.965]         }
[10:26:12.965]     })
[10:26:12.965]     if (TRUE) {
[10:26:12.965]         base::sink(type = "output", split = FALSE)
[10:26:12.965]         if (TRUE) {
[10:26:12.965]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.965]         }
[10:26:12.965]         else {
[10:26:12.965]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.965]         }
[10:26:12.965]         base::close(...future.stdout)
[10:26:12.965]         ...future.stdout <- NULL
[10:26:12.965]     }
[10:26:12.965]     ...future.result$conditions <- ...future.conditions
[10:26:12.965]     ...future.result$finished <- base::Sys.time()
[10:26:12.965]     ...future.result
[10:26:12.965] }
[10:26:12.968] requestCore(): workers = 2
[10:26:12.970] MulticoreFuture started
[10:26:12.971] - Launch lazy future ... done
[10:26:12.971] run() for ‘MulticoreFuture’ ... done
[10:26:12.971] plan(): Setting new future strategy stack:
[10:26:12.972] List of future strategies:
[10:26:12.972] 1. sequential:
[10:26:12.972]    - args: function (..., envir = parent.frame())
[10:26:12.972]    - tweaked: FALSE
[10:26:12.972]    - call: NULL
[10:26:12.973] plan(): nbrOfWorkers() = 1
[10:26:12.975] plan(): Setting new future strategy stack:
[10:26:12.976] List of future strategies:
[10:26:12.976] 1. multicore:
[10:26:12.976]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:12.976]    - tweaked: FALSE
[10:26:12.976]    - call: plan(strategy)
[10:26:12.981] plan(): nbrOfWorkers() = 2
[10:26:12.982] Future #1
[10:26:12.982] result() for MulticoreFuture ...
[10:26:12.983] result() for MulticoreFuture ...
[10:26:12.983] result() for MulticoreFuture ... done
[10:26:12.983] result() for MulticoreFuture ... done
[10:26:12.983] result() for MulticoreFuture ...
[10:26:12.983] result() for MulticoreFuture ... done
[10:26:12.984] A MulticoreFuture was resolved
[10:26:12.984]  length: 0 (resolved future 1)
[10:26:12.984] resolve() on list ... DONE
[10:26:12.984] - globals: [1] ‘a’
[10:26:12.984] Resolving futures part of globals (recursively) ... DONE
[10:26:12.987] The total size of the 1 globals is 1.57 MiB (1641288 bytes)
[10:26:12.988] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[10:26:12.988] - globals: [1] ‘a’
[10:26:12.988] - packages: [1] ‘future’
[10:26:12.988] getGlobalsAndPackages() ... DONE
[10:26:12.989] run() for ‘Future’ ...
[10:26:12.989] - state: ‘created’
[10:26:12.989] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:12.993] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:12.993] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:12.993]   - Field: ‘label’
[10:26:12.993]   - Field: ‘local’
[10:26:12.994]   - Field: ‘owner’
[10:26:12.994]   - Field: ‘envir’
[10:26:12.994]   - Field: ‘workers’
[10:26:12.994]   - Field: ‘packages’
[10:26:12.994]   - Field: ‘gc’
[10:26:12.994]   - Field: ‘job’
[10:26:12.994]   - Field: ‘conditions’
[10:26:12.994]   - Field: ‘expr’
[10:26:12.994]   - Field: ‘uuid’
[10:26:12.995]   - Field: ‘seed’
[10:26:12.995]   - Field: ‘version’
[10:26:12.995]   - Field: ‘result’
[10:26:12.995]   - Field: ‘asynchronous’
[10:26:12.995]   - Field: ‘calls’
[10:26:12.995]   - Field: ‘globals’
[10:26:12.995]   - Field: ‘stdout’
[10:26:12.995]   - Field: ‘earlySignal’
[10:26:12.995]   - Field: ‘lazy’
[10:26:12.996]   - Field: ‘state’
[10:26:12.996] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:12.996] - Launch lazy future ...
[10:26:12.996] Packages needed by the future expression (n = 1): ‘future’
[10:26:12.996] Packages needed by future strategies (n = 0): <none>
[10:26:12.997] {
[10:26:12.997]     {
[10:26:12.997]         {
[10:26:12.997]             ...future.startTime <- base::Sys.time()
[10:26:12.997]             {
[10:26:12.997]                 {
[10:26:12.997]                   {
[10:26:12.997]                     {
[10:26:12.997]                       {
[10:26:12.997]                         base::local({
[10:26:12.997]                           has_future <- base::requireNamespace("future", 
[10:26:12.997]                             quietly = TRUE)
[10:26:12.997]                           if (has_future) {
[10:26:12.997]                             ns <- base::getNamespace("future")
[10:26:12.997]                             version <- ns[[".package"]][["version"]]
[10:26:12.997]                             if (is.null(version)) 
[10:26:12.997]                               version <- utils::packageVersion("future")
[10:26:12.997]                           }
[10:26:12.997]                           else {
[10:26:12.997]                             version <- NULL
[10:26:12.997]                           }
[10:26:12.997]                           if (!has_future || version < "1.8.0") {
[10:26:12.997]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:12.997]                               "", base::R.version$version.string), 
[10:26:12.997]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:12.997]                                 base::R.version$platform, 8 * 
[10:26:12.997]                                   base::.Machine$sizeof.pointer), 
[10:26:12.997]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:12.997]                                 "release", "version")], collapse = " "), 
[10:26:12.997]                               hostname = base::Sys.info()[["nodename"]])
[10:26:12.997]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:12.997]                               info)
[10:26:12.997]                             info <- base::paste(info, collapse = "; ")
[10:26:12.997]                             if (!has_future) {
[10:26:12.997]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:12.997]                                 info)
[10:26:12.997]                             }
[10:26:12.997]                             else {
[10:26:12.997]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:12.997]                                 info, version)
[10:26:12.997]                             }
[10:26:12.997]                             base::stop(msg)
[10:26:12.997]                           }
[10:26:12.997]                         })
[10:26:12.997]                       }
[10:26:12.997]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:12.997]                       base::options(mc.cores = 1L)
[10:26:12.997]                     }
[10:26:12.997]                     base::local({
[10:26:12.997]                       for (pkg in "future") {
[10:26:12.997]                         base::loadNamespace(pkg)
[10:26:12.997]                         base::library(pkg, character.only = TRUE)
[10:26:12.997]                       }
[10:26:12.997]                     })
[10:26:12.997]                   }
[10:26:12.997]                   options(future.plan = NULL)
[10:26:12.997]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.997]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:12.997]                 }
[10:26:12.997]                 ...future.workdir <- getwd()
[10:26:12.997]             }
[10:26:12.997]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:12.997]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:12.997]         }
[10:26:12.997]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:12.997]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:12.997]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:12.997]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:12.997]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:12.997]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:12.997]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:12.997]             base::names(...future.oldOptions))
[10:26:12.997]     }
[10:26:12.997]     if (FALSE) {
[10:26:12.997]     }
[10:26:12.997]     else {
[10:26:12.997]         if (TRUE) {
[10:26:12.997]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:12.997]                 open = "w")
[10:26:12.997]         }
[10:26:12.997]         else {
[10:26:12.997]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:12.997]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:12.997]         }
[10:26:12.997]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:12.997]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:12.997]             base::sink(type = "output", split = FALSE)
[10:26:12.997]             base::close(...future.stdout)
[10:26:12.997]         }, add = TRUE)
[10:26:12.997]     }
[10:26:12.997]     ...future.frame <- base::sys.nframe()
[10:26:12.997]     ...future.conditions <- base::list()
[10:26:12.997]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:12.997]     if (FALSE) {
[10:26:12.997]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:12.997]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:12.997]     }
[10:26:12.997]     ...future.result <- base::tryCatch({
[10:26:12.997]         base::withCallingHandlers({
[10:26:12.997]             ...future.value <- base::withVisible(base::local({
[10:26:12.997]                 withCallingHandlers({
[10:26:12.997]                   value(a) + 1
[10:26:12.997]                 }, immediateCondition = function(cond) {
[10:26:12.997]                   save_rds <- function (object, pathname, ...) 
[10:26:12.997]                   {
[10:26:12.997]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:12.997]                     if (file_test("-f", pathname_tmp)) {
[10:26:12.997]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.997]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:12.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.997]                         fi_tmp[["mtime"]])
[10:26:12.997]                     }
[10:26:12.997]                     tryCatch({
[10:26:12.997]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:12.997]                     }, error = function(ex) {
[10:26:12.997]                       msg <- conditionMessage(ex)
[10:26:12.997]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.997]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:12.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.997]                         fi_tmp[["mtime"]], msg)
[10:26:12.997]                       ex$message <- msg
[10:26:12.997]                       stop(ex)
[10:26:12.997]                     })
[10:26:12.997]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:12.997]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:12.997]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:12.997]                       fi_tmp <- file.info(pathname_tmp)
[10:26:12.997]                       fi <- file.info(pathname)
[10:26:12.997]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:12.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:12.997]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:12.997]                         fi[["size"]], fi[["mtime"]])
[10:26:12.997]                       stop(msg)
[10:26:12.997]                     }
[10:26:12.997]                     invisible(pathname)
[10:26:12.997]                   }
[10:26:12.997]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:12.997]                     rootPath = tempdir()) 
[10:26:12.997]                   {
[10:26:12.997]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:12.997]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:12.997]                       tmpdir = path, fileext = ".rds")
[10:26:12.997]                     save_rds(obj, file)
[10:26:12.997]                   }
[10:26:12.997]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:12.997]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.997]                   {
[10:26:12.997]                     inherits <- base::inherits
[10:26:12.997]                     invokeRestart <- base::invokeRestart
[10:26:12.997]                     is.null <- base::is.null
[10:26:12.997]                     muffled <- FALSE
[10:26:12.997]                     if (inherits(cond, "message")) {
[10:26:12.997]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:12.997]                       if (muffled) 
[10:26:12.997]                         invokeRestart("muffleMessage")
[10:26:12.997]                     }
[10:26:12.997]                     else if (inherits(cond, "warning")) {
[10:26:12.997]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:12.997]                       if (muffled) 
[10:26:12.997]                         invokeRestart("muffleWarning")
[10:26:12.997]                     }
[10:26:12.997]                     else if (inherits(cond, "condition")) {
[10:26:12.997]                       if (!is.null(pattern)) {
[10:26:12.997]                         computeRestarts <- base::computeRestarts
[10:26:12.997]                         grepl <- base::grepl
[10:26:12.997]                         restarts <- computeRestarts(cond)
[10:26:12.997]                         for (restart in restarts) {
[10:26:12.997]                           name <- restart$name
[10:26:12.997]                           if (is.null(name)) 
[10:26:12.997]                             next
[10:26:12.997]                           if (!grepl(pattern, name)) 
[10:26:12.997]                             next
[10:26:12.997]                           invokeRestart(restart)
[10:26:12.997]                           muffled <- TRUE
[10:26:12.997]                           break
[10:26:12.997]                         }
[10:26:12.997]                       }
[10:26:12.997]                     }
[10:26:12.997]                     invisible(muffled)
[10:26:12.997]                   }
[10:26:12.997]                   muffleCondition(cond)
[10:26:12.997]                 })
[10:26:12.997]             }))
[10:26:12.997]             future::FutureResult(value = ...future.value$value, 
[10:26:12.997]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.997]                   ...future.rng), globalenv = if (FALSE) 
[10:26:12.997]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:12.997]                     ...future.globalenv.names))
[10:26:12.997]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:12.997]         }, condition = base::local({
[10:26:12.997]             c <- base::c
[10:26:12.997]             inherits <- base::inherits
[10:26:12.997]             invokeRestart <- base::invokeRestart
[10:26:12.997]             length <- base::length
[10:26:12.997]             list <- base::list
[10:26:12.997]             seq.int <- base::seq.int
[10:26:12.997]             signalCondition <- base::signalCondition
[10:26:12.997]             sys.calls <- base::sys.calls
[10:26:12.997]             `[[` <- base::`[[`
[10:26:12.997]             `+` <- base::`+`
[10:26:12.997]             `<<-` <- base::`<<-`
[10:26:12.997]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:12.997]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:12.997]                   3L)]
[10:26:12.997]             }
[10:26:12.997]             function(cond) {
[10:26:12.997]                 is_error <- inherits(cond, "error")
[10:26:12.997]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:12.997]                   NULL)
[10:26:12.997]                 if (is_error) {
[10:26:12.997]                   sessionInformation <- function() {
[10:26:12.997]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:12.997]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:12.997]                       search = base::search(), system = base::Sys.info())
[10:26:12.997]                   }
[10:26:12.997]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.997]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:12.997]                     cond$call), session = sessionInformation(), 
[10:26:12.997]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:12.997]                   signalCondition(cond)
[10:26:12.997]                 }
[10:26:12.997]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:12.997]                 "immediateCondition"))) {
[10:26:12.997]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:12.997]                   ...future.conditions[[length(...future.conditions) + 
[10:26:12.997]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:12.997]                   if (TRUE && !signal) {
[10:26:12.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.997]                     {
[10:26:12.997]                       inherits <- base::inherits
[10:26:12.997]                       invokeRestart <- base::invokeRestart
[10:26:12.997]                       is.null <- base::is.null
[10:26:12.997]                       muffled <- FALSE
[10:26:12.997]                       if (inherits(cond, "message")) {
[10:26:12.997]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.997]                         if (muffled) 
[10:26:12.997]                           invokeRestart("muffleMessage")
[10:26:12.997]                       }
[10:26:12.997]                       else if (inherits(cond, "warning")) {
[10:26:12.997]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.997]                         if (muffled) 
[10:26:12.997]                           invokeRestart("muffleWarning")
[10:26:12.997]                       }
[10:26:12.997]                       else if (inherits(cond, "condition")) {
[10:26:12.997]                         if (!is.null(pattern)) {
[10:26:12.997]                           computeRestarts <- base::computeRestarts
[10:26:12.997]                           grepl <- base::grepl
[10:26:12.997]                           restarts <- computeRestarts(cond)
[10:26:12.997]                           for (restart in restarts) {
[10:26:12.997]                             name <- restart$name
[10:26:12.997]                             if (is.null(name)) 
[10:26:12.997]                               next
[10:26:12.997]                             if (!grepl(pattern, name)) 
[10:26:12.997]                               next
[10:26:12.997]                             invokeRestart(restart)
[10:26:12.997]                             muffled <- TRUE
[10:26:12.997]                             break
[10:26:12.997]                           }
[10:26:12.997]                         }
[10:26:12.997]                       }
[10:26:12.997]                       invisible(muffled)
[10:26:12.997]                     }
[10:26:12.997]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.997]                   }
[10:26:12.997]                 }
[10:26:12.997]                 else {
[10:26:12.997]                   if (TRUE) {
[10:26:12.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:12.997]                     {
[10:26:12.997]                       inherits <- base::inherits
[10:26:12.997]                       invokeRestart <- base::invokeRestart
[10:26:12.997]                       is.null <- base::is.null
[10:26:12.997]                       muffled <- FALSE
[10:26:12.997]                       if (inherits(cond, "message")) {
[10:26:12.997]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:12.997]                         if (muffled) 
[10:26:12.997]                           invokeRestart("muffleMessage")
[10:26:12.997]                       }
[10:26:12.997]                       else if (inherits(cond, "warning")) {
[10:26:12.997]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:12.997]                         if (muffled) 
[10:26:12.997]                           invokeRestart("muffleWarning")
[10:26:12.997]                       }
[10:26:12.997]                       else if (inherits(cond, "condition")) {
[10:26:12.997]                         if (!is.null(pattern)) {
[10:26:12.997]                           computeRestarts <- base::computeRestarts
[10:26:12.997]                           grepl <- base::grepl
[10:26:12.997]                           restarts <- computeRestarts(cond)
[10:26:12.997]                           for (restart in restarts) {
[10:26:12.997]                             name <- restart$name
[10:26:12.997]                             if (is.null(name)) 
[10:26:12.997]                               next
[10:26:12.997]                             if (!grepl(pattern, name)) 
[10:26:12.997]                               next
[10:26:12.997]                             invokeRestart(restart)
[10:26:12.997]                             muffled <- TRUE
[10:26:12.997]                             break
[10:26:12.997]                           }
[10:26:12.997]                         }
[10:26:12.997]                       }
[10:26:12.997]                       invisible(muffled)
[10:26:12.997]                     }
[10:26:12.997]                     muffleCondition(cond, pattern = "^muffle")
[10:26:12.997]                   }
[10:26:12.997]                 }
[10:26:12.997]             }
[10:26:12.997]         }))
[10:26:12.997]     }, error = function(ex) {
[10:26:12.997]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:12.997]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:12.997]                 ...future.rng), started = ...future.startTime, 
[10:26:12.997]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:12.997]             version = "1.8"), class = "FutureResult")
[10:26:12.997]     }, finally = {
[10:26:12.997]         if (!identical(...future.workdir, getwd())) 
[10:26:12.997]             setwd(...future.workdir)
[10:26:12.997]         {
[10:26:12.997]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:12.997]                 ...future.oldOptions$nwarnings <- NULL
[10:26:12.997]             }
[10:26:12.997]             base::options(...future.oldOptions)
[10:26:12.997]             if (.Platform$OS.type == "windows") {
[10:26:12.997]                 old_names <- names(...future.oldEnvVars)
[10:26:12.997]                 envs <- base::Sys.getenv()
[10:26:12.997]                 names <- names(envs)
[10:26:12.997]                 common <- intersect(names, old_names)
[10:26:12.997]                 added <- setdiff(names, old_names)
[10:26:12.997]                 removed <- setdiff(old_names, names)
[10:26:12.997]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:12.997]                   envs[common]]
[10:26:12.997]                 NAMES <- toupper(changed)
[10:26:12.997]                 args <- list()
[10:26:12.997]                 for (kk in seq_along(NAMES)) {
[10:26:12.997]                   name <- changed[[kk]]
[10:26:12.997]                   NAME <- NAMES[[kk]]
[10:26:12.997]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.997]                     next
[10:26:12.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.997]                 }
[10:26:12.997]                 NAMES <- toupper(added)
[10:26:12.997]                 for (kk in seq_along(NAMES)) {
[10:26:12.997]                   name <- added[[kk]]
[10:26:12.997]                   NAME <- NAMES[[kk]]
[10:26:12.997]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.997]                     next
[10:26:12.997]                   args[[name]] <- ""
[10:26:12.997]                 }
[10:26:12.997]                 NAMES <- toupper(removed)
[10:26:12.997]                 for (kk in seq_along(NAMES)) {
[10:26:12.997]                   name <- removed[[kk]]
[10:26:12.997]                   NAME <- NAMES[[kk]]
[10:26:12.997]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:12.997]                     next
[10:26:12.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:12.997]                 }
[10:26:12.997]                 if (length(args) > 0) 
[10:26:12.997]                   base::do.call(base::Sys.setenv, args = args)
[10:26:12.997]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:12.997]             }
[10:26:12.997]             else {
[10:26:12.997]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:12.997]             }
[10:26:12.997]             {
[10:26:12.997]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:12.997]                   0L) {
[10:26:12.997]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:12.997]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:12.997]                   base::options(opts)
[10:26:12.997]                 }
[10:26:12.997]                 {
[10:26:12.997]                   {
[10:26:12.997]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:12.997]                     NULL
[10:26:12.997]                   }
[10:26:12.997]                   options(future.plan = NULL)
[10:26:12.997]                   if (is.na(NA_character_)) 
[10:26:12.997]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:12.997]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:12.997]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:12.997]                     envir = parent.frame()) 
[10:26:12.997]                   {
[10:26:12.997]                     default_workers <- missing(workers)
[10:26:12.997]                     if (is.function(workers)) 
[10:26:12.997]                       workers <- workers()
[10:26:12.997]                     workers <- structure(as.integer(workers), 
[10:26:12.997]                       class = class(workers))
[10:26:12.997]                     stop_if_not(is.finite(workers), workers >= 
[10:26:12.997]                       1L)
[10:26:12.997]                     if ((workers == 1L && !inherits(workers, 
[10:26:12.997]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:12.997]                       if (default_workers) 
[10:26:12.997]                         supportsMulticore(warn = TRUE)
[10:26:12.997]                       return(sequential(..., envir = envir))
[10:26:12.997]                     }
[10:26:12.997]                     oopts <- options(mc.cores = workers)
[10:26:12.997]                     on.exit(options(oopts))
[10:26:12.997]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:12.997]                       envir = envir)
[10:26:12.997]                     if (!future$lazy) 
[10:26:12.997]                       future <- run(future)
[10:26:12.997]                     invisible(future)
[10:26:12.997]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:12.997]                 }
[10:26:12.997]             }
[10:26:12.997]         }
[10:26:12.997]     })
[10:26:12.997]     if (TRUE) {
[10:26:12.997]         base::sink(type = "output", split = FALSE)
[10:26:12.997]         if (TRUE) {
[10:26:12.997]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:12.997]         }
[10:26:12.997]         else {
[10:26:12.997]             ...future.result["stdout"] <- base::list(NULL)
[10:26:12.997]         }
[10:26:12.997]         base::close(...future.stdout)
[10:26:12.997]         ...future.stdout <- NULL
[10:26:12.997]     }
[10:26:12.997]     ...future.result$conditions <- ...future.conditions
[10:26:12.997]     ...future.result$finished <- base::Sys.time()
[10:26:12.997]     ...future.result
[10:26:12.997] }
[10:26:13.000] assign_globals() ...
[10:26:13.000] List of 1
[10:26:13.000]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a02202ac40> 
[10:26:13.000]  - attr(*, "where")=List of 1
[10:26:13.000]   ..$ a:<environment: R_EmptyEnv> 
[10:26:13.000]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:13.000]  - attr(*, "resolved")= logi TRUE
[10:26:13.000]  - attr(*, "total_size")= num 1641288
[10:26:13.000]  - attr(*, "already-done")= logi TRUE
[10:26:13.003] - copied ‘a’ to environment
[10:26:13.003] assign_globals() ... done
[10:26:13.003] requestCore(): workers = 2
[10:26:13.005] MulticoreFuture started
[10:26:13.010] - Launch lazy future ... done
[10:26:13.011] run() for ‘MulticoreFuture’ ... done
[10:26:13.011] result() for MulticoreFuture ...
[10:26:13.011] plan(): Setting new future strategy stack:
[10:26:13.011] List of future strategies:
[10:26:13.011] 1. sequential:
[10:26:13.011]    - args: function (..., envir = parent.frame())
[10:26:13.011]    - tweaked: FALSE
[10:26:13.011]    - call: NULL
[10:26:13.013] plan(): nbrOfWorkers() = 1
[10:26:13.017] plan(): Setting new future strategy stack:
[10:26:13.017] List of future strategies:
[10:26:13.017] 1. multicore:
[10:26:13.017]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:13.017]    - tweaked: FALSE
[10:26:13.017]    - call: plan(strategy)
[10:26:13.023] plan(): nbrOfWorkers() = 2
[10:26:13.024] result() for MulticoreFuture ...
[10:26:13.024] result() for MulticoreFuture ... done
[10:26:13.024] signalConditions() ...
[10:26:13.024]  - include = ‘immediateCondition’
[10:26:13.024]  - exclude = 
[10:26:13.025]  - resignal = FALSE
[10:26:13.025]  - Number of conditions: 4
[10:26:13.025] signalConditions() ... done
[10:26:13.025] result() for MulticoreFuture ... done
[10:26:13.025] result() for MulticoreFuture ...
[10:26:13.025] result() for MulticoreFuture ... done
[10:26:13.026] signalConditions() ...
[10:26:13.026]  - include = ‘immediateCondition’
[10:26:13.026]  - exclude = 
[10:26:13.026]  - resignal = FALSE
[10:26:13.026]  - Number of conditions: 4
[10:26:13.026] signalConditions() ... done
[10:26:13.027] Future state: ‘finished’
[10:26:13.027] result() for MulticoreFuture ...
[10:26:13.027] result() for MulticoreFuture ... done
[10:26:13.027] signalConditions() ...
[10:26:13.027]  - include = ‘condition’
[10:26:13.027]  - exclude = ‘immediateCondition’
[10:26:13.028]  - resignal = TRUE
[10:26:13.028]  - Number of conditions: 4
[10:26:13.028]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:13.014] result() for MulticoreFuture ...
[10:26:13.028]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:13.015] result() for MulticoreFuture ... done
[10:26:13.028]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:13.015] result() for MulticoreFuture ...
[10:26:13.029]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:13.015] result() for MulticoreFuture ... done
[10:26:13.029] signalConditions() ... done
value(b) = 2
[10:26:13.029] result() for MulticoreFuture ...
[10:26:13.029] result() for MulticoreFuture ... done
[10:26:13.030] result() for MulticoreFuture ...
[10:26:13.030] result() for MulticoreFuture ... done
[10:26:13.030] signalConditions() ...
[10:26:13.030]  - include = ‘immediateCondition’
[10:26:13.030]  - exclude = 
[10:26:13.030]  - resignal = FALSE
[10:26:13.030]  - Number of conditions: 4
[10:26:13.031] signalConditions() ... done
[10:26:13.031] Future state: ‘finished’
[10:26:13.031] result() for MulticoreFuture ...
[10:26:13.031] result() for MulticoreFuture ... done
[10:26:13.031] signalConditions() ...
[10:26:13.031]  - include = ‘condition’
[10:26:13.031]  - exclude = ‘immediateCondition’
[10:26:13.031]  - resignal = TRUE
[10:26:13.031]  - Number of conditions: 4
[10:26:13.032]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:13.014] result() for MulticoreFuture ...
[10:26:13.032]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:13.015] result() for MulticoreFuture ... done
[10:26:13.032]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:13.015] result() for MulticoreFuture ...
[10:26:13.032]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:13.015] result() for MulticoreFuture ... done
[10:26:13.032] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:13.033] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:13.033] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:13.034] - globals found: [2] ‘{’, ‘pkg’
[10:26:13.034] Searching for globals ... DONE
[10:26:13.034] Resolving globals: TRUE
[10:26:13.034] Resolving any globals that are futures ...
[10:26:13.034] - globals: [2] ‘{’, ‘pkg’
[10:26:13.035] Resolving any globals that are futures ... DONE
[10:26:13.035] Resolving futures part of globals (recursively) ...
[10:26:13.035] resolve() on list ...
[10:26:13.035]  recursive: 99
[10:26:13.035]  length: 1
[10:26:13.035]  elements: ‘pkg’
[10:26:13.036]  length: 0 (resolved future 1)
[10:26:13.036] resolve() on list ... DONE
[10:26:13.036] - globals: [1] ‘pkg’
[10:26:13.036] Resolving futures part of globals (recursively) ... DONE
[10:26:13.036] The total size of the 1 globals is 112 bytes (112 bytes)
[10:26:13.037] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[10:26:13.037] - globals: [1] ‘pkg’
[10:26:13.037] 
[10:26:13.037] getGlobalsAndPackages() ... DONE
[10:26:13.037] Packages needed by the future expression (n = 0): <none>
[10:26:13.037] Packages needed by future strategies (n = 0): <none>
[10:26:13.038] {
[10:26:13.038]     {
[10:26:13.038]         {
[10:26:13.038]             ...future.startTime <- base::Sys.time()
[10:26:13.038]             {
[10:26:13.038]                 {
[10:26:13.038]                   {
[10:26:13.038]                     base::local({
[10:26:13.038]                       has_future <- base::requireNamespace("future", 
[10:26:13.038]                         quietly = TRUE)
[10:26:13.038]                       if (has_future) {
[10:26:13.038]                         ns <- base::getNamespace("future")
[10:26:13.038]                         version <- ns[[".package"]][["version"]]
[10:26:13.038]                         if (is.null(version)) 
[10:26:13.038]                           version <- utils::packageVersion("future")
[10:26:13.038]                       }
[10:26:13.038]                       else {
[10:26:13.038]                         version <- NULL
[10:26:13.038]                       }
[10:26:13.038]                       if (!has_future || version < "1.8.0") {
[10:26:13.038]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:13.038]                           "", base::R.version$version.string), 
[10:26:13.038]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:13.038]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:13.038]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:13.038]                             "release", "version")], collapse = " "), 
[10:26:13.038]                           hostname = base::Sys.info()[["nodename"]])
[10:26:13.038]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:13.038]                           info)
[10:26:13.038]                         info <- base::paste(info, collapse = "; ")
[10:26:13.038]                         if (!has_future) {
[10:26:13.038]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:13.038]                             info)
[10:26:13.038]                         }
[10:26:13.038]                         else {
[10:26:13.038]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:13.038]                             info, version)
[10:26:13.038]                         }
[10:26:13.038]                         base::stop(msg)
[10:26:13.038]                       }
[10:26:13.038]                     })
[10:26:13.038]                   }
[10:26:13.038]                   options(future.plan = NULL)
[10:26:13.038]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:13.038]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:13.038]                 }
[10:26:13.038]                 ...future.workdir <- getwd()
[10:26:13.038]             }
[10:26:13.038]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:13.038]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:13.038]         }
[10:26:13.038]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:13.038]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:13.038]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:13.038]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:13.038]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:13.038]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:13.038]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:13.038]             base::names(...future.oldOptions))
[10:26:13.038]     }
[10:26:13.038]     if (FALSE) {
[10:26:13.038]     }
[10:26:13.038]     else {
[10:26:13.038]         if (TRUE) {
[10:26:13.038]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:13.038]                 open = "w")
[10:26:13.038]         }
[10:26:13.038]         else {
[10:26:13.038]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:13.038]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:13.038]         }
[10:26:13.038]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:13.038]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:13.038]             base::sink(type = "output", split = FALSE)
[10:26:13.038]             base::close(...future.stdout)
[10:26:13.038]         }, add = TRUE)
[10:26:13.038]     }
[10:26:13.038]     ...future.frame <- base::sys.nframe()
[10:26:13.038]     ...future.conditions <- base::list()
[10:26:13.038]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:13.038]     if (FALSE) {
[10:26:13.038]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:13.038]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:13.038]     }
[10:26:13.038]     ...future.result <- base::tryCatch({
[10:26:13.038]         base::withCallingHandlers({
[10:26:13.038]             ...future.value <- base::withVisible(base::local({
[10:26:13.038]                 pkg
[10:26:13.038]             }))
[10:26:13.038]             future::FutureResult(value = ...future.value$value, 
[10:26:13.038]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:13.038]                   ...future.rng), globalenv = if (FALSE) 
[10:26:13.038]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:13.038]                     ...future.globalenv.names))
[10:26:13.038]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:13.038]         }, condition = base::local({
[10:26:13.038]             c <- base::c
[10:26:13.038]             inherits <- base::inherits
[10:26:13.038]             invokeRestart <- base::invokeRestart
[10:26:13.038]             length <- base::length
[10:26:13.038]             list <- base::list
[10:26:13.038]             seq.int <- base::seq.int
[10:26:13.038]             signalCondition <- base::signalCondition
[10:26:13.038]             sys.calls <- base::sys.calls
[10:26:13.038]             `[[` <- base::`[[`
[10:26:13.038]             `+` <- base::`+`
[10:26:13.038]             `<<-` <- base::`<<-`
[10:26:13.038]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:13.038]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:13.038]                   3L)]
[10:26:13.038]             }
[10:26:13.038]             function(cond) {
[10:26:13.038]                 is_error <- inherits(cond, "error")
[10:26:13.038]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:13.038]                   NULL)
[10:26:13.038]                 if (is_error) {
[10:26:13.038]                   sessionInformation <- function() {
[10:26:13.038]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:13.038]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:13.038]                       search = base::search(), system = base::Sys.info())
[10:26:13.038]                   }
[10:26:13.038]                   ...future.conditions[[length(...future.conditions) + 
[10:26:13.038]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:13.038]                     cond$call), session = sessionInformation(), 
[10:26:13.038]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:13.038]                   signalCondition(cond)
[10:26:13.038]                 }
[10:26:13.038]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:13.038]                 "immediateCondition"))) {
[10:26:13.038]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:13.038]                   ...future.conditions[[length(...future.conditions) + 
[10:26:13.038]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:13.038]                   if (TRUE && !signal) {
[10:26:13.038]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:13.038]                     {
[10:26:13.038]                       inherits <- base::inherits
[10:26:13.038]                       invokeRestart <- base::invokeRestart
[10:26:13.038]                       is.null <- base::is.null
[10:26:13.038]                       muffled <- FALSE
[10:26:13.038]                       if (inherits(cond, "message")) {
[10:26:13.038]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:13.038]                         if (muffled) 
[10:26:13.038]                           invokeRestart("muffleMessage")
[10:26:13.038]                       }
[10:26:13.038]                       else if (inherits(cond, "warning")) {
[10:26:13.038]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:13.038]                         if (muffled) 
[10:26:13.038]                           invokeRestart("muffleWarning")
[10:26:13.038]                       }
[10:26:13.038]                       else if (inherits(cond, "condition")) {
[10:26:13.038]                         if (!is.null(pattern)) {
[10:26:13.038]                           computeRestarts <- base::computeRestarts
[10:26:13.038]                           grepl <- base::grepl
[10:26:13.038]                           restarts <- computeRestarts(cond)
[10:26:13.038]                           for (restart in restarts) {
[10:26:13.038]                             name <- restart$name
[10:26:13.038]                             if (is.null(name)) 
[10:26:13.038]                               next
[10:26:13.038]                             if (!grepl(pattern, name)) 
[10:26:13.038]                               next
[10:26:13.038]                             invokeRestart(restart)
[10:26:13.038]                             muffled <- TRUE
[10:26:13.038]                             break
[10:26:13.038]                           }
[10:26:13.038]                         }
[10:26:13.038]                       }
[10:26:13.038]                       invisible(muffled)
[10:26:13.038]                     }
[10:26:13.038]                     muffleCondition(cond, pattern = "^muffle")
[10:26:13.038]                   }
[10:26:13.038]                 }
[10:26:13.038]                 else {
[10:26:13.038]                   if (TRUE) {
[10:26:13.038]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:13.038]                     {
[10:26:13.038]                       inherits <- base::inherits
[10:26:13.038]                       invokeRestart <- base::invokeRestart
[10:26:13.038]                       is.null <- base::is.null
[10:26:13.038]                       muffled <- FALSE
[10:26:13.038]                       if (inherits(cond, "message")) {
[10:26:13.038]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:13.038]                         if (muffled) 
[10:26:13.038]                           invokeRestart("muffleMessage")
[10:26:13.038]                       }
[10:26:13.038]                       else if (inherits(cond, "warning")) {
[10:26:13.038]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:13.038]                         if (muffled) 
[10:26:13.038]                           invokeRestart("muffleWarning")
[10:26:13.038]                       }
[10:26:13.038]                       else if (inherits(cond, "condition")) {
[10:26:13.038]                         if (!is.null(pattern)) {
[10:26:13.038]                           computeRestarts <- base::computeRestarts
[10:26:13.038]                           grepl <- base::grepl
[10:26:13.038]                           restarts <- computeRestarts(cond)
[10:26:13.038]                           for (restart in restarts) {
[10:26:13.038]                             name <- restart$name
[10:26:13.038]                             if (is.null(name)) 
[10:26:13.038]                               next
[10:26:13.038]                             if (!grepl(pattern, name)) 
[10:26:13.038]                               next
[10:26:13.038]                             invokeRestart(restart)
[10:26:13.038]                             muffled <- TRUE
[10:26:13.038]                             break
[10:26:13.038]                           }
[10:26:13.038]                         }
[10:26:13.038]                       }
[10:26:13.038]                       invisible(muffled)
[10:26:13.038]                     }
[10:26:13.038]                     muffleCondition(cond, pattern = "^muffle")
[10:26:13.038]                   }
[10:26:13.038]                 }
[10:26:13.038]             }
[10:26:13.038]         }))
[10:26:13.038]     }, error = function(ex) {
[10:26:13.038]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:13.038]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:13.038]                 ...future.rng), started = ...future.startTime, 
[10:26:13.038]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:13.038]             version = "1.8"), class = "FutureResult")
[10:26:13.038]     }, finally = {
[10:26:13.038]         if (!identical(...future.workdir, getwd())) 
[10:26:13.038]             setwd(...future.workdir)
[10:26:13.038]         {
[10:26:13.038]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:13.038]                 ...future.oldOptions$nwarnings <- NULL
[10:26:13.038]             }
[10:26:13.038]             base::options(...future.oldOptions)
[10:26:13.038]             if (.Platform$OS.type == "windows") {
[10:26:13.038]                 old_names <- names(...future.oldEnvVars)
[10:26:13.038]                 envs <- base::Sys.getenv()
[10:26:13.038]                 names <- names(envs)
[10:26:13.038]                 common <- intersect(names, old_names)
[10:26:13.038]                 added <- setdiff(names, old_names)
[10:26:13.038]                 removed <- setdiff(old_names, names)
[10:26:13.038]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:13.038]                   envs[common]]
[10:26:13.038]                 NAMES <- toupper(changed)
[10:26:13.038]                 args <- list()
[10:26:13.038]                 for (kk in seq_along(NAMES)) {
[10:26:13.038]                   name <- changed[[kk]]
[10:26:13.038]                   NAME <- NAMES[[kk]]
[10:26:13.038]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.038]                     next
[10:26:13.038]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:13.038]                 }
[10:26:13.038]                 NAMES <- toupper(added)
[10:26:13.038]                 for (kk in seq_along(NAMES)) {
[10:26:13.038]                   name <- added[[kk]]
[10:26:13.038]                   NAME <- NAMES[[kk]]
[10:26:13.038]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.038]                     next
[10:26:13.038]                   args[[name]] <- ""
[10:26:13.038]                 }
[10:26:13.038]                 NAMES <- toupper(removed)
[10:26:13.038]                 for (kk in seq_along(NAMES)) {
[10:26:13.038]                   name <- removed[[kk]]
[10:26:13.038]                   NAME <- NAMES[[kk]]
[10:26:13.038]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.038]                     next
[10:26:13.038]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:13.038]                 }
[10:26:13.038]                 if (length(args) > 0) 
[10:26:13.038]                   base::do.call(base::Sys.setenv, args = args)
[10:26:13.038]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:13.038]             }
[10:26:13.038]             else {
[10:26:13.038]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:13.038]             }
[10:26:13.038]             {
[10:26:13.038]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:13.038]                   0L) {
[10:26:13.038]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:13.038]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:13.038]                   base::options(opts)
[10:26:13.038]                 }
[10:26:13.038]                 {
[10:26:13.038]                   {
[10:26:13.038]                     NULL
[10:26:13.038]                     RNGkind("Mersenne-Twister")
[10:26:13.038]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:13.038]                       inherits = FALSE)
[10:26:13.038]                   }
[10:26:13.038]                   options(future.plan = NULL)
[10:26:13.038]                   if (is.na(NA_character_)) 
[10:26:13.038]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:13.038]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:13.038]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:13.038]                     envir = parent.frame()) 
[10:26:13.038]                   {
[10:26:13.038]                     default_workers <- missing(workers)
[10:26:13.038]                     if (is.function(workers)) 
[10:26:13.038]                       workers <- workers()
[10:26:13.038]                     workers <- structure(as.integer(workers), 
[10:26:13.038]                       class = class(workers))
[10:26:13.038]                     stop_if_not(is.finite(workers), workers >= 
[10:26:13.038]                       1L)
[10:26:13.038]                     if ((workers == 1L && !inherits(workers, 
[10:26:13.038]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:13.038]                       if (default_workers) 
[10:26:13.038]                         supportsMulticore(warn = TRUE)
[10:26:13.038]                       return(sequential(..., envir = envir))
[10:26:13.038]                     }
[10:26:13.038]                     oopts <- options(mc.cores = workers)
[10:26:13.038]                     on.exit(options(oopts))
[10:26:13.038]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:13.038]                       envir = envir)
[10:26:13.038]                     if (!future$lazy) 
[10:26:13.038]                       future <- run(future)
[10:26:13.038]                     invisible(future)
[10:26:13.038]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:13.038]                 }
[10:26:13.038]             }
[10:26:13.038]         }
[10:26:13.038]     })
[10:26:13.038]     if (TRUE) {
[10:26:13.038]         base::sink(type = "output", split = FALSE)
[10:26:13.038]         if (TRUE) {
[10:26:13.038]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:13.038]         }
[10:26:13.038]         else {
[10:26:13.038]             ...future.result["stdout"] <- base::list(NULL)
[10:26:13.038]         }
[10:26:13.038]         base::close(...future.stdout)
[10:26:13.038]         ...future.stdout <- NULL
[10:26:13.038]     }
[10:26:13.038]     ...future.result$conditions <- ...future.conditions
[10:26:13.038]     ...future.result$finished <- base::Sys.time()
[10:26:13.038]     ...future.result
[10:26:13.038] }
[10:26:13.040] assign_globals() ...
[10:26:13.040] List of 1
[10:26:13.040]  $ pkg: chr "foo"
[10:26:13.040]  - attr(*, "where")=List of 1
[10:26:13.040]   ..$ pkg:<environment: R_EmptyEnv> 
[10:26:13.040]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:13.040]  - attr(*, "resolved")= logi TRUE
[10:26:13.040]  - attr(*, "total_size")= num 112
[10:26:13.042] - copied ‘pkg’ to environment
[10:26:13.043] assign_globals() ... done
[10:26:13.043] plan(): Setting new future strategy stack:
[10:26:13.043] List of future strategies:
[10:26:13.043] 1. sequential:
[10:26:13.043]    - args: function (..., envir = parent.frame())
[10:26:13.043]    - tweaked: FALSE
[10:26:13.043]    - call: NULL
[10:26:13.043] plan(): nbrOfWorkers() = 1
[10:26:13.044] plan(): Setting new future strategy stack:
[10:26:13.044] List of future strategies:
[10:26:13.044] 1. multicore:
[10:26:13.044]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:13.044]    - tweaked: FALSE
[10:26:13.044]    - call: plan(strategy)
[10:26:13.049] plan(): nbrOfWorkers() = 2
[10:26:13.049] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:13.049] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:13.050] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:13.054] - globals found: [3] ‘{’, ‘<-’, ‘+’
[10:26:13.054] Searching for globals ... DONE
[10:26:13.054] Resolving globals: TRUE
[10:26:13.054] Resolving any globals that are futures ...
[10:26:13.054] - globals: [3] ‘{’, ‘<-’, ‘+’
[10:26:13.054] Resolving any globals that are futures ... DONE
[10:26:13.055] 
[10:26:13.055] 
[10:26:13.055] getGlobalsAndPackages() ... DONE
[10:26:13.055] run() for ‘Future’ ...
[10:26:13.055] - state: ‘created’
[10:26:13.055] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:13.059] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:13.059] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:13.059]   - Field: ‘label’
[10:26:13.059]   - Field: ‘local’
[10:26:13.059]   - Field: ‘owner’
[10:26:13.060]   - Field: ‘envir’
[10:26:13.060]   - Field: ‘workers’
[10:26:13.060]   - Field: ‘packages’
[10:26:13.060]   - Field: ‘gc’
[10:26:13.060]   - Field: ‘job’
[10:26:13.060]   - Field: ‘conditions’
[10:26:13.060]   - Field: ‘expr’
[10:26:13.060]   - Field: ‘uuid’
[10:26:13.060]   - Field: ‘seed’
[10:26:13.060]   - Field: ‘version’
[10:26:13.061]   - Field: ‘result’
[10:26:13.061]   - Field: ‘asynchronous’
[10:26:13.061]   - Field: ‘calls’
[10:26:13.061]   - Field: ‘globals’
[10:26:13.061]   - Field: ‘stdout’
[10:26:13.061]   - Field: ‘earlySignal’
[10:26:13.061]   - Field: ‘lazy’
[10:26:13.061]   - Field: ‘state’
[10:26:13.061] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:13.062] - Launch lazy future ...
[10:26:13.062] Packages needed by the future expression (n = 0): <none>
[10:26:13.062] Packages needed by future strategies (n = 0): <none>
[10:26:13.062] {
[10:26:13.062]     {
[10:26:13.062]         {
[10:26:13.062]             ...future.startTime <- base::Sys.time()
[10:26:13.062]             {
[10:26:13.062]                 {
[10:26:13.062]                   {
[10:26:13.062]                     {
[10:26:13.062]                       base::local({
[10:26:13.062]                         has_future <- base::requireNamespace("future", 
[10:26:13.062]                           quietly = TRUE)
[10:26:13.062]                         if (has_future) {
[10:26:13.062]                           ns <- base::getNamespace("future")
[10:26:13.062]                           version <- ns[[".package"]][["version"]]
[10:26:13.062]                           if (is.null(version)) 
[10:26:13.062]                             version <- utils::packageVersion("future")
[10:26:13.062]                         }
[10:26:13.062]                         else {
[10:26:13.062]                           version <- NULL
[10:26:13.062]                         }
[10:26:13.062]                         if (!has_future || version < "1.8.0") {
[10:26:13.062]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:13.062]                             "", base::R.version$version.string), 
[10:26:13.062]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:13.062]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:13.062]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:13.062]                               "release", "version")], collapse = " "), 
[10:26:13.062]                             hostname = base::Sys.info()[["nodename"]])
[10:26:13.062]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:13.062]                             info)
[10:26:13.062]                           info <- base::paste(info, collapse = "; ")
[10:26:13.062]                           if (!has_future) {
[10:26:13.062]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:13.062]                               info)
[10:26:13.062]                           }
[10:26:13.062]                           else {
[10:26:13.062]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:13.062]                               info, version)
[10:26:13.062]                           }
[10:26:13.062]                           base::stop(msg)
[10:26:13.062]                         }
[10:26:13.062]                       })
[10:26:13.062]                     }
[10:26:13.062]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:13.062]                     base::options(mc.cores = 1L)
[10:26:13.062]                   }
[10:26:13.062]                   options(future.plan = NULL)
[10:26:13.062]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:13.062]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:13.062]                 }
[10:26:13.062]                 ...future.workdir <- getwd()
[10:26:13.062]             }
[10:26:13.062]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:13.062]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:13.062]         }
[10:26:13.062]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:13.062]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:13.062]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:13.062]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:13.062]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:13.062]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:13.062]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:13.062]             base::names(...future.oldOptions))
[10:26:13.062]     }
[10:26:13.062]     if (FALSE) {
[10:26:13.062]     }
[10:26:13.062]     else {
[10:26:13.062]         if (TRUE) {
[10:26:13.062]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:13.062]                 open = "w")
[10:26:13.062]         }
[10:26:13.062]         else {
[10:26:13.062]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:13.062]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:13.062]         }
[10:26:13.062]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:13.062]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:13.062]             base::sink(type = "output", split = FALSE)
[10:26:13.062]             base::close(...future.stdout)
[10:26:13.062]         }, add = TRUE)
[10:26:13.062]     }
[10:26:13.062]     ...future.frame <- base::sys.nframe()
[10:26:13.062]     ...future.conditions <- base::list()
[10:26:13.062]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:13.062]     if (FALSE) {
[10:26:13.062]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:13.062]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:13.062]     }
[10:26:13.062]     ...future.result <- base::tryCatch({
[10:26:13.062]         base::withCallingHandlers({
[10:26:13.062]             ...future.value <- base::withVisible(base::local({
[10:26:13.062]                 withCallingHandlers({
[10:26:13.062]                   {
[10:26:13.062]                     x <- 0
[10:26:13.062]                     x <- x + 1
[10:26:13.062]                     x
[10:26:13.062]                   }
[10:26:13.062]                 }, immediateCondition = function(cond) {
[10:26:13.062]                   save_rds <- function (object, pathname, ...) 
[10:26:13.062]                   {
[10:26:13.062]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:13.062]                     if (file_test("-f", pathname_tmp)) {
[10:26:13.062]                       fi_tmp <- file.info(pathname_tmp)
[10:26:13.062]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:13.062]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:13.062]                         fi_tmp[["mtime"]])
[10:26:13.062]                     }
[10:26:13.062]                     tryCatch({
[10:26:13.062]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:13.062]                     }, error = function(ex) {
[10:26:13.062]                       msg <- conditionMessage(ex)
[10:26:13.062]                       fi_tmp <- file.info(pathname_tmp)
[10:26:13.062]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:13.062]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:13.062]                         fi_tmp[["mtime"]], msg)
[10:26:13.062]                       ex$message <- msg
[10:26:13.062]                       stop(ex)
[10:26:13.062]                     })
[10:26:13.062]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:13.062]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:13.062]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:13.062]                       fi_tmp <- file.info(pathname_tmp)
[10:26:13.062]                       fi <- file.info(pathname)
[10:26:13.062]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:13.062]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:13.062]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:13.062]                         fi[["size"]], fi[["mtime"]])
[10:26:13.062]                       stop(msg)
[10:26:13.062]                     }
[10:26:13.062]                     invisible(pathname)
[10:26:13.062]                   }
[10:26:13.062]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:13.062]                     rootPath = tempdir()) 
[10:26:13.062]                   {
[10:26:13.062]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:13.062]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:13.062]                       tmpdir = path, fileext = ".rds")
[10:26:13.062]                     save_rds(obj, file)
[10:26:13.062]                   }
[10:26:13.062]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:13.062]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:13.062]                   {
[10:26:13.062]                     inherits <- base::inherits
[10:26:13.062]                     invokeRestart <- base::invokeRestart
[10:26:13.062]                     is.null <- base::is.null
[10:26:13.062]                     muffled <- FALSE
[10:26:13.062]                     if (inherits(cond, "message")) {
[10:26:13.062]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:13.062]                       if (muffled) 
[10:26:13.062]                         invokeRestart("muffleMessage")
[10:26:13.062]                     }
[10:26:13.062]                     else if (inherits(cond, "warning")) {
[10:26:13.062]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:13.062]                       if (muffled) 
[10:26:13.062]                         invokeRestart("muffleWarning")
[10:26:13.062]                     }
[10:26:13.062]                     else if (inherits(cond, "condition")) {
[10:26:13.062]                       if (!is.null(pattern)) {
[10:26:13.062]                         computeRestarts <- base::computeRestarts
[10:26:13.062]                         grepl <- base::grepl
[10:26:13.062]                         restarts <- computeRestarts(cond)
[10:26:13.062]                         for (restart in restarts) {
[10:26:13.062]                           name <- restart$name
[10:26:13.062]                           if (is.null(name)) 
[10:26:13.062]                             next
[10:26:13.062]                           if (!grepl(pattern, name)) 
[10:26:13.062]                             next
[10:26:13.062]                           invokeRestart(restart)
[10:26:13.062]                           muffled <- TRUE
[10:26:13.062]                           break
[10:26:13.062]                         }
[10:26:13.062]                       }
[10:26:13.062]                     }
[10:26:13.062]                     invisible(muffled)
[10:26:13.062]                   }
[10:26:13.062]                   muffleCondition(cond)
[10:26:13.062]                 })
[10:26:13.062]             }))
[10:26:13.062]             future::FutureResult(value = ...future.value$value, 
[10:26:13.062]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:13.062]                   ...future.rng), globalenv = if (FALSE) 
[10:26:13.062]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:13.062]                     ...future.globalenv.names))
[10:26:13.062]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:13.062]         }, condition = base::local({
[10:26:13.062]             c <- base::c
[10:26:13.062]             inherits <- base::inherits
[10:26:13.062]             invokeRestart <- base::invokeRestart
[10:26:13.062]             length <- base::length
[10:26:13.062]             list <- base::list
[10:26:13.062]             seq.int <- base::seq.int
[10:26:13.062]             signalCondition <- base::signalCondition
[10:26:13.062]             sys.calls <- base::sys.calls
[10:26:13.062]             `[[` <- base::`[[`
[10:26:13.062]             `+` <- base::`+`
[10:26:13.062]             `<<-` <- base::`<<-`
[10:26:13.062]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:13.062]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:13.062]                   3L)]
[10:26:13.062]             }
[10:26:13.062]             function(cond) {
[10:26:13.062]                 is_error <- inherits(cond, "error")
[10:26:13.062]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:13.062]                   NULL)
[10:26:13.062]                 if (is_error) {
[10:26:13.062]                   sessionInformation <- function() {
[10:26:13.062]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:13.062]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:13.062]                       search = base::search(), system = base::Sys.info())
[10:26:13.062]                   }
[10:26:13.062]                   ...future.conditions[[length(...future.conditions) + 
[10:26:13.062]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:13.062]                     cond$call), session = sessionInformation(), 
[10:26:13.062]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:13.062]                   signalCondition(cond)
[10:26:13.062]                 }
[10:26:13.062]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:13.062]                 "immediateCondition"))) {
[10:26:13.062]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:13.062]                   ...future.conditions[[length(...future.conditions) + 
[10:26:13.062]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:13.062]                   if (TRUE && !signal) {
[10:26:13.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:13.062]                     {
[10:26:13.062]                       inherits <- base::inherits
[10:26:13.062]                       invokeRestart <- base::invokeRestart
[10:26:13.062]                       is.null <- base::is.null
[10:26:13.062]                       muffled <- FALSE
[10:26:13.062]                       if (inherits(cond, "message")) {
[10:26:13.062]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:13.062]                         if (muffled) 
[10:26:13.062]                           invokeRestart("muffleMessage")
[10:26:13.062]                       }
[10:26:13.062]                       else if (inherits(cond, "warning")) {
[10:26:13.062]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:13.062]                         if (muffled) 
[10:26:13.062]                           invokeRestart("muffleWarning")
[10:26:13.062]                       }
[10:26:13.062]                       else if (inherits(cond, "condition")) {
[10:26:13.062]                         if (!is.null(pattern)) {
[10:26:13.062]                           computeRestarts <- base::computeRestarts
[10:26:13.062]                           grepl <- base::grepl
[10:26:13.062]                           restarts <- computeRestarts(cond)
[10:26:13.062]                           for (restart in restarts) {
[10:26:13.062]                             name <- restart$name
[10:26:13.062]                             if (is.null(name)) 
[10:26:13.062]                               next
[10:26:13.062]                             if (!grepl(pattern, name)) 
[10:26:13.062]                               next
[10:26:13.062]                             invokeRestart(restart)
[10:26:13.062]                             muffled <- TRUE
[10:26:13.062]                             break
[10:26:13.062]                           }
[10:26:13.062]                         }
[10:26:13.062]                       }
[10:26:13.062]                       invisible(muffled)
[10:26:13.062]                     }
[10:26:13.062]                     muffleCondition(cond, pattern = "^muffle")
[10:26:13.062]                   }
[10:26:13.062]                 }
[10:26:13.062]                 else {
[10:26:13.062]                   if (TRUE) {
[10:26:13.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:13.062]                     {
[10:26:13.062]                       inherits <- base::inherits
[10:26:13.062]                       invokeRestart <- base::invokeRestart
[10:26:13.062]                       is.null <- base::is.null
[10:26:13.062]                       muffled <- FALSE
[10:26:13.062]                       if (inherits(cond, "message")) {
[10:26:13.062]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:13.062]                         if (muffled) 
[10:26:13.062]                           invokeRestart("muffleMessage")
[10:26:13.062]                       }
[10:26:13.062]                       else if (inherits(cond, "warning")) {
[10:26:13.062]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:13.062]                         if (muffled) 
[10:26:13.062]                           invokeRestart("muffleWarning")
[10:26:13.062]                       }
[10:26:13.062]                       else if (inherits(cond, "condition")) {
[10:26:13.062]                         if (!is.null(pattern)) {
[10:26:13.062]                           computeRestarts <- base::computeRestarts
[10:26:13.062]                           grepl <- base::grepl
[10:26:13.062]                           restarts <- computeRestarts(cond)
[10:26:13.062]                           for (restart in restarts) {
[10:26:13.062]                             name <- restart$name
[10:26:13.062]                             if (is.null(name)) 
[10:26:13.062]                               next
[10:26:13.062]                             if (!grepl(pattern, name)) 
[10:26:13.062]                               next
[10:26:13.062]                             invokeRestart(restart)
[10:26:13.062]                             muffled <- TRUE
[10:26:13.062]                             break
[10:26:13.062]                           }
[10:26:13.062]                         }
[10:26:13.062]                       }
[10:26:13.062]                       invisible(muffled)
[10:26:13.062]                     }
[10:26:13.062]                     muffleCondition(cond, pattern = "^muffle")
[10:26:13.062]                   }
[10:26:13.062]                 }
[10:26:13.062]             }
[10:26:13.062]         }))
[10:26:13.062]     }, error = function(ex) {
[10:26:13.062]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:13.062]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:13.062]                 ...future.rng), started = ...future.startTime, 
[10:26:13.062]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:13.062]             version = "1.8"), class = "FutureResult")
[10:26:13.062]     }, finally = {
[10:26:13.062]         if (!identical(...future.workdir, getwd())) 
[10:26:13.062]             setwd(...future.workdir)
[10:26:13.062]         {
[10:26:13.062]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:13.062]                 ...future.oldOptions$nwarnings <- NULL
[10:26:13.062]             }
[10:26:13.062]             base::options(...future.oldOptions)
[10:26:13.062]             if (.Platform$OS.type == "windows") {
[10:26:13.062]                 old_names <- names(...future.oldEnvVars)
[10:26:13.062]                 envs <- base::Sys.getenv()
[10:26:13.062]                 names <- names(envs)
[10:26:13.062]                 common <- intersect(names, old_names)
[10:26:13.062]                 added <- setdiff(names, old_names)
[10:26:13.062]                 removed <- setdiff(old_names, names)
[10:26:13.062]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:13.062]                   envs[common]]
[10:26:13.062]                 NAMES <- toupper(changed)
[10:26:13.062]                 args <- list()
[10:26:13.062]                 for (kk in seq_along(NAMES)) {
[10:26:13.062]                   name <- changed[[kk]]
[10:26:13.062]                   NAME <- NAMES[[kk]]
[10:26:13.062]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.062]                     next
[10:26:13.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:13.062]                 }
[10:26:13.062]                 NAMES <- toupper(added)
[10:26:13.062]                 for (kk in seq_along(NAMES)) {
[10:26:13.062]                   name <- added[[kk]]
[10:26:13.062]                   NAME <- NAMES[[kk]]
[10:26:13.062]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.062]                     next
[10:26:13.062]                   args[[name]] <- ""
[10:26:13.062]                 }
[10:26:13.062]                 NAMES <- toupper(removed)
[10:26:13.062]                 for (kk in seq_along(NAMES)) {
[10:26:13.062]                   name <- removed[[kk]]
[10:26:13.062]                   NAME <- NAMES[[kk]]
[10:26:13.062]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.062]                     next
[10:26:13.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:13.062]                 }
[10:26:13.062]                 if (length(args) > 0) 
[10:26:13.062]                   base::do.call(base::Sys.setenv, args = args)
[10:26:13.062]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:13.062]             }
[10:26:13.062]             else {
[10:26:13.062]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:13.062]             }
[10:26:13.062]             {
[10:26:13.062]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:13.062]                   0L) {
[10:26:13.062]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:13.062]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:13.062]                   base::options(opts)
[10:26:13.062]                 }
[10:26:13.062]                 {
[10:26:13.062]                   {
[10:26:13.062]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:13.062]                     NULL
[10:26:13.062]                   }
[10:26:13.062]                   options(future.plan = NULL)
[10:26:13.062]                   if (is.na(NA_character_)) 
[10:26:13.062]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:13.062]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:13.062]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:13.062]                     envir = parent.frame()) 
[10:26:13.062]                   {
[10:26:13.062]                     default_workers <- missing(workers)
[10:26:13.062]                     if (is.function(workers)) 
[10:26:13.062]                       workers <- workers()
[10:26:13.062]                     workers <- structure(as.integer(workers), 
[10:26:13.062]                       class = class(workers))
[10:26:13.062]                     stop_if_not(is.finite(workers), workers >= 
[10:26:13.062]                       1L)
[10:26:13.062]                     if ((workers == 1L && !inherits(workers, 
[10:26:13.062]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:13.062]                       if (default_workers) 
[10:26:13.062]                         supportsMulticore(warn = TRUE)
[10:26:13.062]                       return(sequential(..., envir = envir))
[10:26:13.062]                     }
[10:26:13.062]                     oopts <- options(mc.cores = workers)
[10:26:13.062]                     on.exit(options(oopts))
[10:26:13.062]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:13.062]                       envir = envir)
[10:26:13.062]                     if (!future$lazy) 
[10:26:13.062]                       future <- run(future)
[10:26:13.062]                     invisible(future)
[10:26:13.062]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:13.062]                 }
[10:26:13.062]             }
[10:26:13.062]         }
[10:26:13.062]     })
[10:26:13.062]     if (TRUE) {
[10:26:13.062]         base::sink(type = "output", split = FALSE)
[10:26:13.062]         if (TRUE) {
[10:26:13.062]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:13.062]         }
[10:26:13.062]         else {
[10:26:13.062]             ...future.result["stdout"] <- base::list(NULL)
[10:26:13.062]         }
[10:26:13.062]         base::close(...future.stdout)
[10:26:13.062]         ...future.stdout <- NULL
[10:26:13.062]     }
[10:26:13.062]     ...future.result$conditions <- ...future.conditions
[10:26:13.062]     ...future.result$finished <- base::Sys.time()
[10:26:13.062]     ...future.result
[10:26:13.062] }
[10:26:13.065] requestCore(): workers = 2
[10:26:13.067] MulticoreFuture started
[10:26:13.067] - Launch lazy future ... done
[10:26:13.067] run() for ‘MulticoreFuture’ ... done
[10:26:13.068] result() for MulticoreFuture ...
[10:26:13.068] plan(): Setting new future strategy stack:
[10:26:13.068] List of future strategies:
[10:26:13.068] 1. sequential:
[10:26:13.068]    - args: function (..., envir = parent.frame())
[10:26:13.068]    - tweaked: FALSE
[10:26:13.068]    - call: NULL
[10:26:13.069] plan(): nbrOfWorkers() = 1
[10:26:13.071] plan(): Setting new future strategy stack:
[10:26:13.071] List of future strategies:
[10:26:13.071] 1. multicore:
[10:26:13.071]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:13.071]    - tweaked: FALSE
[10:26:13.071]    - call: plan(strategy)
[10:26:13.076] plan(): nbrOfWorkers() = 2
[10:26:13.077] result() for MulticoreFuture ...
[10:26:13.077] result() for MulticoreFuture ... done
[10:26:13.077] result() for MulticoreFuture ... done
[10:26:13.078] result() for MulticoreFuture ...
[10:26:13.078] result() for MulticoreFuture ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:13.078] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:13.078] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:13.080] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[10:26:13.081] Searching for globals ... DONE
[10:26:13.081] Resolving globals: TRUE
[10:26:13.081] Resolving any globals that are futures ...
[10:26:13.081] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[10:26:13.081] Resolving any globals that are futures ... DONE
[10:26:13.082] Resolving futures part of globals (recursively) ...
[10:26:13.082] resolve() on list ...
[10:26:13.082]  recursive: 99
[10:26:13.082]  length: 1
[10:26:13.082]  elements: ‘x’
[10:26:13.083]  length: 0 (resolved future 1)
[10:26:13.083] resolve() on list ... DONE
[10:26:13.083] - globals: [1] ‘x’
[10:26:13.083] Resolving futures part of globals (recursively) ... DONE
[10:26:13.083] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:13.084] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[10:26:13.084] - globals: [1] ‘x’
[10:26:13.084] 
[10:26:13.084] getGlobalsAndPackages() ... DONE
[10:26:13.084] run() for ‘Future’ ...
[10:26:13.084] - state: ‘created’
[10:26:13.085] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:13.089] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:13.089] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:13.089]   - Field: ‘label’
[10:26:13.089]   - Field: ‘local’
[10:26:13.089]   - Field: ‘owner’
[10:26:13.089]   - Field: ‘envir’
[10:26:13.090]   - Field: ‘workers’
[10:26:13.090]   - Field: ‘packages’
[10:26:13.090]   - Field: ‘gc’
[10:26:13.090]   - Field: ‘job’
[10:26:13.090]   - Field: ‘conditions’
[10:26:13.090]   - Field: ‘expr’
[10:26:13.090]   - Field: ‘uuid’
[10:26:13.090]   - Field: ‘seed’
[10:26:13.090]   - Field: ‘version’
[10:26:13.091]   - Field: ‘result’
[10:26:13.091]   - Field: ‘asynchronous’
[10:26:13.091]   - Field: ‘calls’
[10:26:13.091]   - Field: ‘globals’
[10:26:13.091]   - Field: ‘stdout’
[10:26:13.091]   - Field: ‘earlySignal’
[10:26:13.091]   - Field: ‘lazy’
[10:26:13.091]   - Field: ‘state’
[10:26:13.091] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:13.094] - Launch lazy future ...
[10:26:13.095] Packages needed by the future expression (n = 0): <none>
[10:26:13.095] Packages needed by future strategies (n = 0): <none>
[10:26:13.096] {
[10:26:13.096]     {
[10:26:13.096]         {
[10:26:13.096]             ...future.startTime <- base::Sys.time()
[10:26:13.096]             {
[10:26:13.096]                 {
[10:26:13.096]                   {
[10:26:13.096]                     {
[10:26:13.096]                       base::local({
[10:26:13.096]                         has_future <- base::requireNamespace("future", 
[10:26:13.096]                           quietly = TRUE)
[10:26:13.096]                         if (has_future) {
[10:26:13.096]                           ns <- base::getNamespace("future")
[10:26:13.096]                           version <- ns[[".package"]][["version"]]
[10:26:13.096]                           if (is.null(version)) 
[10:26:13.096]                             version <- utils::packageVersion("future")
[10:26:13.096]                         }
[10:26:13.096]                         else {
[10:26:13.096]                           version <- NULL
[10:26:13.096]                         }
[10:26:13.096]                         if (!has_future || version < "1.8.0") {
[10:26:13.096]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:13.096]                             "", base::R.version$version.string), 
[10:26:13.096]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:13.096]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:13.096]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:13.096]                               "release", "version")], collapse = " "), 
[10:26:13.096]                             hostname = base::Sys.info()[["nodename"]])
[10:26:13.096]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:13.096]                             info)
[10:26:13.096]                           info <- base::paste(info, collapse = "; ")
[10:26:13.096]                           if (!has_future) {
[10:26:13.096]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:13.096]                               info)
[10:26:13.096]                           }
[10:26:13.096]                           else {
[10:26:13.096]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:13.096]                               info, version)
[10:26:13.096]                           }
[10:26:13.096]                           base::stop(msg)
[10:26:13.096]                         }
[10:26:13.096]                       })
[10:26:13.096]                     }
[10:26:13.096]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:13.096]                     base::options(mc.cores = 1L)
[10:26:13.096]                   }
[10:26:13.096]                   options(future.plan = NULL)
[10:26:13.096]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:13.096]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:13.096]                 }
[10:26:13.096]                 ...future.workdir <- getwd()
[10:26:13.096]             }
[10:26:13.096]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:13.096]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:13.096]         }
[10:26:13.096]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:13.096]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:13.096]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:13.096]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:13.096]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:13.096]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:13.096]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:13.096]             base::names(...future.oldOptions))
[10:26:13.096]     }
[10:26:13.096]     if (FALSE) {
[10:26:13.096]     }
[10:26:13.096]     else {
[10:26:13.096]         if (TRUE) {
[10:26:13.096]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:13.096]                 open = "w")
[10:26:13.096]         }
[10:26:13.096]         else {
[10:26:13.096]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:13.096]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:13.096]         }
[10:26:13.096]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:13.096]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:13.096]             base::sink(type = "output", split = FALSE)
[10:26:13.096]             base::close(...future.stdout)
[10:26:13.096]         }, add = TRUE)
[10:26:13.096]     }
[10:26:13.096]     ...future.frame <- base::sys.nframe()
[10:26:13.096]     ...future.conditions <- base::list()
[10:26:13.096]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:13.096]     if (FALSE) {
[10:26:13.096]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:13.096]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:13.096]     }
[10:26:13.096]     ...future.result <- base::tryCatch({
[10:26:13.096]         base::withCallingHandlers({
[10:26:13.096]             ...future.value <- base::withVisible(base::local({
[10:26:13.096]                 withCallingHandlers({
[10:26:13.096]                   {
[10:26:13.096]                     x <- x + 1
[10:26:13.096]                     x
[10:26:13.096]                   }
[10:26:13.096]                 }, immediateCondition = function(cond) {
[10:26:13.096]                   save_rds <- function (object, pathname, ...) 
[10:26:13.096]                   {
[10:26:13.096]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:13.096]                     if (file_test("-f", pathname_tmp)) {
[10:26:13.096]                       fi_tmp <- file.info(pathname_tmp)
[10:26:13.096]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:13.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:13.096]                         fi_tmp[["mtime"]])
[10:26:13.096]                     }
[10:26:13.096]                     tryCatch({
[10:26:13.096]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:13.096]                     }, error = function(ex) {
[10:26:13.096]                       msg <- conditionMessage(ex)
[10:26:13.096]                       fi_tmp <- file.info(pathname_tmp)
[10:26:13.096]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:13.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:13.096]                         fi_tmp[["mtime"]], msg)
[10:26:13.096]                       ex$message <- msg
[10:26:13.096]                       stop(ex)
[10:26:13.096]                     })
[10:26:13.096]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:13.096]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:13.096]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:13.096]                       fi_tmp <- file.info(pathname_tmp)
[10:26:13.096]                       fi <- file.info(pathname)
[10:26:13.096]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:13.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:13.096]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:13.096]                         fi[["size"]], fi[["mtime"]])
[10:26:13.096]                       stop(msg)
[10:26:13.096]                     }
[10:26:13.096]                     invisible(pathname)
[10:26:13.096]                   }
[10:26:13.096]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:13.096]                     rootPath = tempdir()) 
[10:26:13.096]                   {
[10:26:13.096]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:13.096]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:13.096]                       tmpdir = path, fileext = ".rds")
[10:26:13.096]                     save_rds(obj, file)
[10:26:13.096]                   }
[10:26:13.096]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:13.096]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:13.096]                   {
[10:26:13.096]                     inherits <- base::inherits
[10:26:13.096]                     invokeRestart <- base::invokeRestart
[10:26:13.096]                     is.null <- base::is.null
[10:26:13.096]                     muffled <- FALSE
[10:26:13.096]                     if (inherits(cond, "message")) {
[10:26:13.096]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:13.096]                       if (muffled) 
[10:26:13.096]                         invokeRestart("muffleMessage")
[10:26:13.096]                     }
[10:26:13.096]                     else if (inherits(cond, "warning")) {
[10:26:13.096]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:13.096]                       if (muffled) 
[10:26:13.096]                         invokeRestart("muffleWarning")
[10:26:13.096]                     }
[10:26:13.096]                     else if (inherits(cond, "condition")) {
[10:26:13.096]                       if (!is.null(pattern)) {
[10:26:13.096]                         computeRestarts <- base::computeRestarts
[10:26:13.096]                         grepl <- base::grepl
[10:26:13.096]                         restarts <- computeRestarts(cond)
[10:26:13.096]                         for (restart in restarts) {
[10:26:13.096]                           name <- restart$name
[10:26:13.096]                           if (is.null(name)) 
[10:26:13.096]                             next
[10:26:13.096]                           if (!grepl(pattern, name)) 
[10:26:13.096]                             next
[10:26:13.096]                           invokeRestart(restart)
[10:26:13.096]                           muffled <- TRUE
[10:26:13.096]                           break
[10:26:13.096]                         }
[10:26:13.096]                       }
[10:26:13.096]                     }
[10:26:13.096]                     invisible(muffled)
[10:26:13.096]                   }
[10:26:13.096]                   muffleCondition(cond)
[10:26:13.096]                 })
[10:26:13.096]             }))
[10:26:13.096]             future::FutureResult(value = ...future.value$value, 
[10:26:13.096]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:13.096]                   ...future.rng), globalenv = if (FALSE) 
[10:26:13.096]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:13.096]                     ...future.globalenv.names))
[10:26:13.096]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:13.096]         }, condition = base::local({
[10:26:13.096]             c <- base::c
[10:26:13.096]             inherits <- base::inherits
[10:26:13.096]             invokeRestart <- base::invokeRestart
[10:26:13.096]             length <- base::length
[10:26:13.096]             list <- base::list
[10:26:13.096]             seq.int <- base::seq.int
[10:26:13.096]             signalCondition <- base::signalCondition
[10:26:13.096]             sys.calls <- base::sys.calls
[10:26:13.096]             `[[` <- base::`[[`
[10:26:13.096]             `+` <- base::`+`
[10:26:13.096]             `<<-` <- base::`<<-`
[10:26:13.096]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:13.096]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:13.096]                   3L)]
[10:26:13.096]             }
[10:26:13.096]             function(cond) {
[10:26:13.096]                 is_error <- inherits(cond, "error")
[10:26:13.096]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:13.096]                   NULL)
[10:26:13.096]                 if (is_error) {
[10:26:13.096]                   sessionInformation <- function() {
[10:26:13.096]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:13.096]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:13.096]                       search = base::search(), system = base::Sys.info())
[10:26:13.096]                   }
[10:26:13.096]                   ...future.conditions[[length(...future.conditions) + 
[10:26:13.096]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:13.096]                     cond$call), session = sessionInformation(), 
[10:26:13.096]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:13.096]                   signalCondition(cond)
[10:26:13.096]                 }
[10:26:13.096]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:13.096]                 "immediateCondition"))) {
[10:26:13.096]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:13.096]                   ...future.conditions[[length(...future.conditions) + 
[10:26:13.096]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:13.096]                   if (TRUE && !signal) {
[10:26:13.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:13.096]                     {
[10:26:13.096]                       inherits <- base::inherits
[10:26:13.096]                       invokeRestart <- base::invokeRestart
[10:26:13.096]                       is.null <- base::is.null
[10:26:13.096]                       muffled <- FALSE
[10:26:13.096]                       if (inherits(cond, "message")) {
[10:26:13.096]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:13.096]                         if (muffled) 
[10:26:13.096]                           invokeRestart("muffleMessage")
[10:26:13.096]                       }
[10:26:13.096]                       else if (inherits(cond, "warning")) {
[10:26:13.096]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:13.096]                         if (muffled) 
[10:26:13.096]                           invokeRestart("muffleWarning")
[10:26:13.096]                       }
[10:26:13.096]                       else if (inherits(cond, "condition")) {
[10:26:13.096]                         if (!is.null(pattern)) {
[10:26:13.096]                           computeRestarts <- base::computeRestarts
[10:26:13.096]                           grepl <- base::grepl
[10:26:13.096]                           restarts <- computeRestarts(cond)
[10:26:13.096]                           for (restart in restarts) {
[10:26:13.096]                             name <- restart$name
[10:26:13.096]                             if (is.null(name)) 
[10:26:13.096]                               next
[10:26:13.096]                             if (!grepl(pattern, name)) 
[10:26:13.096]                               next
[10:26:13.096]                             invokeRestart(restart)
[10:26:13.096]                             muffled <- TRUE
[10:26:13.096]                             break
[10:26:13.096]                           }
[10:26:13.096]                         }
[10:26:13.096]                       }
[10:26:13.096]                       invisible(muffled)
[10:26:13.096]                     }
[10:26:13.096]                     muffleCondition(cond, pattern = "^muffle")
[10:26:13.096]                   }
[10:26:13.096]                 }
[10:26:13.096]                 else {
[10:26:13.096]                   if (TRUE) {
[10:26:13.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:13.096]                     {
[10:26:13.096]                       inherits <- base::inherits
[10:26:13.096]                       invokeRestart <- base::invokeRestart
[10:26:13.096]                       is.null <- base::is.null
[10:26:13.096]                       muffled <- FALSE
[10:26:13.096]                       if (inherits(cond, "message")) {
[10:26:13.096]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:13.096]                         if (muffled) 
[10:26:13.096]                           invokeRestart("muffleMessage")
[10:26:13.096]                       }
[10:26:13.096]                       else if (inherits(cond, "warning")) {
[10:26:13.096]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:13.096]                         if (muffled) 
[10:26:13.096]                           invokeRestart("muffleWarning")
[10:26:13.096]                       }
[10:26:13.096]                       else if (inherits(cond, "condition")) {
[10:26:13.096]                         if (!is.null(pattern)) {
[10:26:13.096]                           computeRestarts <- base::computeRestarts
[10:26:13.096]                           grepl <- base::grepl
[10:26:13.096]                           restarts <- computeRestarts(cond)
[10:26:13.096]                           for (restart in restarts) {
[10:26:13.096]                             name <- restart$name
[10:26:13.096]                             if (is.null(name)) 
[10:26:13.096]                               next
[10:26:13.096]                             if (!grepl(pattern, name)) 
[10:26:13.096]                               next
[10:26:13.096]                             invokeRestart(restart)
[10:26:13.096]                             muffled <- TRUE
[10:26:13.096]                             break
[10:26:13.096]                           }
[10:26:13.096]                         }
[10:26:13.096]                       }
[10:26:13.096]                       invisible(muffled)
[10:26:13.096]                     }
[10:26:13.096]                     muffleCondition(cond, pattern = "^muffle")
[10:26:13.096]                   }
[10:26:13.096]                 }
[10:26:13.096]             }
[10:26:13.096]         }))
[10:26:13.096]     }, error = function(ex) {
[10:26:13.096]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:13.096]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:13.096]                 ...future.rng), started = ...future.startTime, 
[10:26:13.096]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:13.096]             version = "1.8"), class = "FutureResult")
[10:26:13.096]     }, finally = {
[10:26:13.096]         if (!identical(...future.workdir, getwd())) 
[10:26:13.096]             setwd(...future.workdir)
[10:26:13.096]         {
[10:26:13.096]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:13.096]                 ...future.oldOptions$nwarnings <- NULL
[10:26:13.096]             }
[10:26:13.096]             base::options(...future.oldOptions)
[10:26:13.096]             if (.Platform$OS.type == "windows") {
[10:26:13.096]                 old_names <- names(...future.oldEnvVars)
[10:26:13.096]                 envs <- base::Sys.getenv()
[10:26:13.096]                 names <- names(envs)
[10:26:13.096]                 common <- intersect(names, old_names)
[10:26:13.096]                 added <- setdiff(names, old_names)
[10:26:13.096]                 removed <- setdiff(old_names, names)
[10:26:13.096]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:13.096]                   envs[common]]
[10:26:13.096]                 NAMES <- toupper(changed)
[10:26:13.096]                 args <- list()
[10:26:13.096]                 for (kk in seq_along(NAMES)) {
[10:26:13.096]                   name <- changed[[kk]]
[10:26:13.096]                   NAME <- NAMES[[kk]]
[10:26:13.096]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.096]                     next
[10:26:13.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:13.096]                 }
[10:26:13.096]                 NAMES <- toupper(added)
[10:26:13.096]                 for (kk in seq_along(NAMES)) {
[10:26:13.096]                   name <- added[[kk]]
[10:26:13.096]                   NAME <- NAMES[[kk]]
[10:26:13.096]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.096]                     next
[10:26:13.096]                   args[[name]] <- ""
[10:26:13.096]                 }
[10:26:13.096]                 NAMES <- toupper(removed)
[10:26:13.096]                 for (kk in seq_along(NAMES)) {
[10:26:13.096]                   name <- removed[[kk]]
[10:26:13.096]                   NAME <- NAMES[[kk]]
[10:26:13.096]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.096]                     next
[10:26:13.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:13.096]                 }
[10:26:13.096]                 if (length(args) > 0) 
[10:26:13.096]                   base::do.call(base::Sys.setenv, args = args)
[10:26:13.096]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:13.096]             }
[10:26:13.096]             else {
[10:26:13.096]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:13.096]             }
[10:26:13.096]             {
[10:26:13.096]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:13.096]                   0L) {
[10:26:13.096]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:13.096]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:13.096]                   base::options(opts)
[10:26:13.096]                 }
[10:26:13.096]                 {
[10:26:13.096]                   {
[10:26:13.096]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:13.096]                     NULL
[10:26:13.096]                   }
[10:26:13.096]                   options(future.plan = NULL)
[10:26:13.096]                   if (is.na(NA_character_)) 
[10:26:13.096]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:13.096]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:13.096]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:13.096]                     envir = parent.frame()) 
[10:26:13.096]                   {
[10:26:13.096]                     default_workers <- missing(workers)
[10:26:13.096]                     if (is.function(workers)) 
[10:26:13.096]                       workers <- workers()
[10:26:13.096]                     workers <- structure(as.integer(workers), 
[10:26:13.096]                       class = class(workers))
[10:26:13.096]                     stop_if_not(is.finite(workers), workers >= 
[10:26:13.096]                       1L)
[10:26:13.096]                     if ((workers == 1L && !inherits(workers, 
[10:26:13.096]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:13.096]                       if (default_workers) 
[10:26:13.096]                         supportsMulticore(warn = TRUE)
[10:26:13.096]                       return(sequential(..., envir = envir))
[10:26:13.096]                     }
[10:26:13.096]                     oopts <- options(mc.cores = workers)
[10:26:13.096]                     on.exit(options(oopts))
[10:26:13.096]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:13.096]                       envir = envir)
[10:26:13.096]                     if (!future$lazy) 
[10:26:13.096]                       future <- run(future)
[10:26:13.096]                     invisible(future)
[10:26:13.096]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:13.096]                 }
[10:26:13.096]             }
[10:26:13.096]         }
[10:26:13.096]     })
[10:26:13.096]     if (TRUE) {
[10:26:13.096]         base::sink(type = "output", split = FALSE)
[10:26:13.096]         if (TRUE) {
[10:26:13.096]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:13.096]         }
[10:26:13.096]         else {
[10:26:13.096]             ...future.result["stdout"] <- base::list(NULL)
[10:26:13.096]         }
[10:26:13.096]         base::close(...future.stdout)
[10:26:13.096]         ...future.stdout <- NULL
[10:26:13.096]     }
[10:26:13.096]     ...future.result$conditions <- ...future.conditions
[10:26:13.096]     ...future.result$finished <- base::Sys.time()
[10:26:13.096]     ...future.result
[10:26:13.096] }
[10:26:13.098] assign_globals() ...
[10:26:13.099] List of 1
[10:26:13.099]  $ x: num 1
[10:26:13.099]  - attr(*, "where")=List of 1
[10:26:13.099]   ..$ x:<environment: R_EmptyEnv> 
[10:26:13.099]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:13.099]  - attr(*, "resolved")= logi TRUE
[10:26:13.099]  - attr(*, "total_size")= num 56
[10:26:13.099]  - attr(*, "already-done")= logi TRUE
[10:26:13.102] - copied ‘x’ to environment
[10:26:13.102] assign_globals() ... done
[10:26:13.103] requestCore(): workers = 2
[10:26:13.105] MulticoreFuture started
[10:26:13.105] - Launch lazy future ... done
[10:26:13.106] run() for ‘MulticoreFuture’ ... done
[10:26:13.106] plan(): Setting new future strategy stack:
[10:26:13.107] result() for MulticoreFuture ...
[10:26:13.107] List of future strategies:
[10:26:13.107] 1. sequential:
[10:26:13.107]    - args: function (..., envir = parent.frame())
[10:26:13.107]    - tweaked: FALSE
[10:26:13.107]    - call: NULL
[10:26:13.108] plan(): nbrOfWorkers() = 1
[10:26:13.110] plan(): Setting new future strategy stack:
[10:26:13.110] List of future strategies:
[10:26:13.110] 1. multicore:
[10:26:13.110]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:13.110]    - tweaked: FALSE
[10:26:13.110]    - call: plan(strategy)
[10:26:13.116] plan(): nbrOfWorkers() = 2
[10:26:13.117] result() for MulticoreFuture ...
[10:26:13.117] result() for MulticoreFuture ... done
[10:26:13.117] result() for MulticoreFuture ... done
[10:26:13.117] result() for MulticoreFuture ...
[10:26:13.117] result() for MulticoreFuture ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:13.118] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:13.118] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:13.121] - globals found: [3] ‘{’, ‘<-’, ‘x’
[10:26:13.121] Searching for globals ... DONE
[10:26:13.121] Resolving globals: TRUE
[10:26:13.121] Resolving any globals that are futures ...
[10:26:13.122] - globals: [3] ‘{’, ‘<-’, ‘x’
[10:26:13.122] Resolving any globals that are futures ... DONE
[10:26:13.122] Resolving futures part of globals (recursively) ...
[10:26:13.122] resolve() on list ...
[10:26:13.123]  recursive: 99
[10:26:13.123]  length: 1
[10:26:13.123]  elements: ‘x’
[10:26:13.123]  length: 0 (resolved future 1)
[10:26:13.123] resolve() on list ... DONE
[10:26:13.123] - globals: [1] ‘x’
[10:26:13.123] Resolving futures part of globals (recursively) ... DONE
[10:26:13.124] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[10:26:13.124] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[10:26:13.124] - globals: [1] ‘x’
[10:26:13.124] 
[10:26:13.124] getGlobalsAndPackages() ... DONE
[10:26:13.125] run() for ‘Future’ ...
[10:26:13.125] - state: ‘created’
[10:26:13.125] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:13.129] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:13.129] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:13.129]   - Field: ‘label’
[10:26:13.129]   - Field: ‘local’
[10:26:13.130]   - Field: ‘owner’
[10:26:13.130]   - Field: ‘envir’
[10:26:13.130]   - Field: ‘workers’
[10:26:13.130]   - Field: ‘packages’
[10:26:13.130]   - Field: ‘gc’
[10:26:13.130]   - Field: ‘job’
[10:26:13.130]   - Field: ‘conditions’
[10:26:13.130]   - Field: ‘expr’
[10:26:13.130]   - Field: ‘uuid’
[10:26:13.131]   - Field: ‘seed’
[10:26:13.131]   - Field: ‘version’
[10:26:13.131]   - Field: ‘result’
[10:26:13.131]   - Field: ‘asynchronous’
[10:26:13.131]   - Field: ‘calls’
[10:26:13.131]   - Field: ‘globals’
[10:26:13.131]   - Field: ‘stdout’
[10:26:13.131]   - Field: ‘earlySignal’
[10:26:13.131]   - Field: ‘lazy’
[10:26:13.132]   - Field: ‘state’
[10:26:13.132] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:13.132] - Launch lazy future ...
[10:26:13.132] Packages needed by the future expression (n = 0): <none>
[10:26:13.132] Packages needed by future strategies (n = 0): <none>
[10:26:13.133] {
[10:26:13.133]     {
[10:26:13.133]         {
[10:26:13.133]             ...future.startTime <- base::Sys.time()
[10:26:13.133]             {
[10:26:13.133]                 {
[10:26:13.133]                   {
[10:26:13.133]                     {
[10:26:13.133]                       base::local({
[10:26:13.133]                         has_future <- base::requireNamespace("future", 
[10:26:13.133]                           quietly = TRUE)
[10:26:13.133]                         if (has_future) {
[10:26:13.133]                           ns <- base::getNamespace("future")
[10:26:13.133]                           version <- ns[[".package"]][["version"]]
[10:26:13.133]                           if (is.null(version)) 
[10:26:13.133]                             version <- utils::packageVersion("future")
[10:26:13.133]                         }
[10:26:13.133]                         else {
[10:26:13.133]                           version <- NULL
[10:26:13.133]                         }
[10:26:13.133]                         if (!has_future || version < "1.8.0") {
[10:26:13.133]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:13.133]                             "", base::R.version$version.string), 
[10:26:13.133]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:13.133]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:13.133]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:13.133]                               "release", "version")], collapse = " "), 
[10:26:13.133]                             hostname = base::Sys.info()[["nodename"]])
[10:26:13.133]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:13.133]                             info)
[10:26:13.133]                           info <- base::paste(info, collapse = "; ")
[10:26:13.133]                           if (!has_future) {
[10:26:13.133]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:13.133]                               info)
[10:26:13.133]                           }
[10:26:13.133]                           else {
[10:26:13.133]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:13.133]                               info, version)
[10:26:13.133]                           }
[10:26:13.133]                           base::stop(msg)
[10:26:13.133]                         }
[10:26:13.133]                       })
[10:26:13.133]                     }
[10:26:13.133]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:13.133]                     base::options(mc.cores = 1L)
[10:26:13.133]                   }
[10:26:13.133]                   options(future.plan = NULL)
[10:26:13.133]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:13.133]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:13.133]                 }
[10:26:13.133]                 ...future.workdir <- getwd()
[10:26:13.133]             }
[10:26:13.133]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:13.133]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:13.133]         }
[10:26:13.133]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:13.133]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:13.133]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:13.133]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:13.133]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:13.133]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:13.133]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:13.133]             base::names(...future.oldOptions))
[10:26:13.133]     }
[10:26:13.133]     if (FALSE) {
[10:26:13.133]     }
[10:26:13.133]     else {
[10:26:13.133]         if (TRUE) {
[10:26:13.133]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:13.133]                 open = "w")
[10:26:13.133]         }
[10:26:13.133]         else {
[10:26:13.133]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:13.133]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:13.133]         }
[10:26:13.133]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:13.133]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:13.133]             base::sink(type = "output", split = FALSE)
[10:26:13.133]             base::close(...future.stdout)
[10:26:13.133]         }, add = TRUE)
[10:26:13.133]     }
[10:26:13.133]     ...future.frame <- base::sys.nframe()
[10:26:13.133]     ...future.conditions <- base::list()
[10:26:13.133]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:13.133]     if (FALSE) {
[10:26:13.133]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:13.133]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:13.133]     }
[10:26:13.133]     ...future.result <- base::tryCatch({
[10:26:13.133]         base::withCallingHandlers({
[10:26:13.133]             ...future.value <- base::withVisible(base::local({
[10:26:13.133]                 withCallingHandlers({
[10:26:13.133]                   {
[10:26:13.133]                     x <- x()
[10:26:13.133]                     x
[10:26:13.133]                   }
[10:26:13.133]                 }, immediateCondition = function(cond) {
[10:26:13.133]                   save_rds <- function (object, pathname, ...) 
[10:26:13.133]                   {
[10:26:13.133]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:13.133]                     if (file_test("-f", pathname_tmp)) {
[10:26:13.133]                       fi_tmp <- file.info(pathname_tmp)
[10:26:13.133]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:13.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:13.133]                         fi_tmp[["mtime"]])
[10:26:13.133]                     }
[10:26:13.133]                     tryCatch({
[10:26:13.133]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:13.133]                     }, error = function(ex) {
[10:26:13.133]                       msg <- conditionMessage(ex)
[10:26:13.133]                       fi_tmp <- file.info(pathname_tmp)
[10:26:13.133]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:13.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:13.133]                         fi_tmp[["mtime"]], msg)
[10:26:13.133]                       ex$message <- msg
[10:26:13.133]                       stop(ex)
[10:26:13.133]                     })
[10:26:13.133]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:13.133]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:13.133]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:13.133]                       fi_tmp <- file.info(pathname_tmp)
[10:26:13.133]                       fi <- file.info(pathname)
[10:26:13.133]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:13.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:13.133]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:13.133]                         fi[["size"]], fi[["mtime"]])
[10:26:13.133]                       stop(msg)
[10:26:13.133]                     }
[10:26:13.133]                     invisible(pathname)
[10:26:13.133]                   }
[10:26:13.133]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:13.133]                     rootPath = tempdir()) 
[10:26:13.133]                   {
[10:26:13.133]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:13.133]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:13.133]                       tmpdir = path, fileext = ".rds")
[10:26:13.133]                     save_rds(obj, file)
[10:26:13.133]                   }
[10:26:13.133]                   saveImmediateCondition(cond, path = "/tmp/RtmpQkWp4a/.future/immediateConditions")
[10:26:13.133]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:13.133]                   {
[10:26:13.133]                     inherits <- base::inherits
[10:26:13.133]                     invokeRestart <- base::invokeRestart
[10:26:13.133]                     is.null <- base::is.null
[10:26:13.133]                     muffled <- FALSE
[10:26:13.133]                     if (inherits(cond, "message")) {
[10:26:13.133]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:13.133]                       if (muffled) 
[10:26:13.133]                         invokeRestart("muffleMessage")
[10:26:13.133]                     }
[10:26:13.133]                     else if (inherits(cond, "warning")) {
[10:26:13.133]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:13.133]                       if (muffled) 
[10:26:13.133]                         invokeRestart("muffleWarning")
[10:26:13.133]                     }
[10:26:13.133]                     else if (inherits(cond, "condition")) {
[10:26:13.133]                       if (!is.null(pattern)) {
[10:26:13.133]                         computeRestarts <- base::computeRestarts
[10:26:13.133]                         grepl <- base::grepl
[10:26:13.133]                         restarts <- computeRestarts(cond)
[10:26:13.133]                         for (restart in restarts) {
[10:26:13.133]                           name <- restart$name
[10:26:13.133]                           if (is.null(name)) 
[10:26:13.133]                             next
[10:26:13.133]                           if (!grepl(pattern, name)) 
[10:26:13.133]                             next
[10:26:13.133]                           invokeRestart(restart)
[10:26:13.133]                           muffled <- TRUE
[10:26:13.133]                           break
[10:26:13.133]                         }
[10:26:13.133]                       }
[10:26:13.133]                     }
[10:26:13.133]                     invisible(muffled)
[10:26:13.133]                   }
[10:26:13.133]                   muffleCondition(cond)
[10:26:13.133]                 })
[10:26:13.133]             }))
[10:26:13.133]             future::FutureResult(value = ...future.value$value, 
[10:26:13.133]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:13.133]                   ...future.rng), globalenv = if (FALSE) 
[10:26:13.133]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:13.133]                     ...future.globalenv.names))
[10:26:13.133]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:13.133]         }, condition = base::local({
[10:26:13.133]             c <- base::c
[10:26:13.133]             inherits <- base::inherits
[10:26:13.133]             invokeRestart <- base::invokeRestart
[10:26:13.133]             length <- base::length
[10:26:13.133]             list <- base::list
[10:26:13.133]             seq.int <- base::seq.int
[10:26:13.133]             signalCondition <- base::signalCondition
[10:26:13.133]             sys.calls <- base::sys.calls
[10:26:13.133]             `[[` <- base::`[[`
[10:26:13.133]             `+` <- base::`+`
[10:26:13.133]             `<<-` <- base::`<<-`
[10:26:13.133]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:13.133]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:13.133]                   3L)]
[10:26:13.133]             }
[10:26:13.133]             function(cond) {
[10:26:13.133]                 is_error <- inherits(cond, "error")
[10:26:13.133]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:13.133]                   NULL)
[10:26:13.133]                 if (is_error) {
[10:26:13.133]                   sessionInformation <- function() {
[10:26:13.133]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:13.133]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:13.133]                       search = base::search(), system = base::Sys.info())
[10:26:13.133]                   }
[10:26:13.133]                   ...future.conditions[[length(...future.conditions) + 
[10:26:13.133]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:13.133]                     cond$call), session = sessionInformation(), 
[10:26:13.133]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:13.133]                   signalCondition(cond)
[10:26:13.133]                 }
[10:26:13.133]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:13.133]                 "immediateCondition"))) {
[10:26:13.133]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:13.133]                   ...future.conditions[[length(...future.conditions) + 
[10:26:13.133]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:13.133]                   if (TRUE && !signal) {
[10:26:13.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:13.133]                     {
[10:26:13.133]                       inherits <- base::inherits
[10:26:13.133]                       invokeRestart <- base::invokeRestart
[10:26:13.133]                       is.null <- base::is.null
[10:26:13.133]                       muffled <- FALSE
[10:26:13.133]                       if (inherits(cond, "message")) {
[10:26:13.133]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:13.133]                         if (muffled) 
[10:26:13.133]                           invokeRestart("muffleMessage")
[10:26:13.133]                       }
[10:26:13.133]                       else if (inherits(cond, "warning")) {
[10:26:13.133]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:13.133]                         if (muffled) 
[10:26:13.133]                           invokeRestart("muffleWarning")
[10:26:13.133]                       }
[10:26:13.133]                       else if (inherits(cond, "condition")) {
[10:26:13.133]                         if (!is.null(pattern)) {
[10:26:13.133]                           computeRestarts <- base::computeRestarts
[10:26:13.133]                           grepl <- base::grepl
[10:26:13.133]                           restarts <- computeRestarts(cond)
[10:26:13.133]                           for (restart in restarts) {
[10:26:13.133]                             name <- restart$name
[10:26:13.133]                             if (is.null(name)) 
[10:26:13.133]                               next
[10:26:13.133]                             if (!grepl(pattern, name)) 
[10:26:13.133]                               next
[10:26:13.133]                             invokeRestart(restart)
[10:26:13.133]                             muffled <- TRUE
[10:26:13.133]                             break
[10:26:13.133]                           }
[10:26:13.133]                         }
[10:26:13.133]                       }
[10:26:13.133]                       invisible(muffled)
[10:26:13.133]                     }
[10:26:13.133]                     muffleCondition(cond, pattern = "^muffle")
[10:26:13.133]                   }
[10:26:13.133]                 }
[10:26:13.133]                 else {
[10:26:13.133]                   if (TRUE) {
[10:26:13.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:13.133]                     {
[10:26:13.133]                       inherits <- base::inherits
[10:26:13.133]                       invokeRestart <- base::invokeRestart
[10:26:13.133]                       is.null <- base::is.null
[10:26:13.133]                       muffled <- FALSE
[10:26:13.133]                       if (inherits(cond, "message")) {
[10:26:13.133]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:13.133]                         if (muffled) 
[10:26:13.133]                           invokeRestart("muffleMessage")
[10:26:13.133]                       }
[10:26:13.133]                       else if (inherits(cond, "warning")) {
[10:26:13.133]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:13.133]                         if (muffled) 
[10:26:13.133]                           invokeRestart("muffleWarning")
[10:26:13.133]                       }
[10:26:13.133]                       else if (inherits(cond, "condition")) {
[10:26:13.133]                         if (!is.null(pattern)) {
[10:26:13.133]                           computeRestarts <- base::computeRestarts
[10:26:13.133]                           grepl <- base::grepl
[10:26:13.133]                           restarts <- computeRestarts(cond)
[10:26:13.133]                           for (restart in restarts) {
[10:26:13.133]                             name <- restart$name
[10:26:13.133]                             if (is.null(name)) 
[10:26:13.133]                               next
[10:26:13.133]                             if (!grepl(pattern, name)) 
[10:26:13.133]                               next
[10:26:13.133]                             invokeRestart(restart)
[10:26:13.133]                             muffled <- TRUE
[10:26:13.133]                             break
[10:26:13.133]                           }
[10:26:13.133]                         }
[10:26:13.133]                       }
[10:26:13.133]                       invisible(muffled)
[10:26:13.133]                     }
[10:26:13.133]                     muffleCondition(cond, pattern = "^muffle")
[10:26:13.133]                   }
[10:26:13.133]                 }
[10:26:13.133]             }
[10:26:13.133]         }))
[10:26:13.133]     }, error = function(ex) {
[10:26:13.133]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:13.133]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:13.133]                 ...future.rng), started = ...future.startTime, 
[10:26:13.133]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:13.133]             version = "1.8"), class = "FutureResult")
[10:26:13.133]     }, finally = {
[10:26:13.133]         if (!identical(...future.workdir, getwd())) 
[10:26:13.133]             setwd(...future.workdir)
[10:26:13.133]         {
[10:26:13.133]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:13.133]                 ...future.oldOptions$nwarnings <- NULL
[10:26:13.133]             }
[10:26:13.133]             base::options(...future.oldOptions)
[10:26:13.133]             if (.Platform$OS.type == "windows") {
[10:26:13.133]                 old_names <- names(...future.oldEnvVars)
[10:26:13.133]                 envs <- base::Sys.getenv()
[10:26:13.133]                 names <- names(envs)
[10:26:13.133]                 common <- intersect(names, old_names)
[10:26:13.133]                 added <- setdiff(names, old_names)
[10:26:13.133]                 removed <- setdiff(old_names, names)
[10:26:13.133]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:13.133]                   envs[common]]
[10:26:13.133]                 NAMES <- toupper(changed)
[10:26:13.133]                 args <- list()
[10:26:13.133]                 for (kk in seq_along(NAMES)) {
[10:26:13.133]                   name <- changed[[kk]]
[10:26:13.133]                   NAME <- NAMES[[kk]]
[10:26:13.133]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.133]                     next
[10:26:13.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:13.133]                 }
[10:26:13.133]                 NAMES <- toupper(added)
[10:26:13.133]                 for (kk in seq_along(NAMES)) {
[10:26:13.133]                   name <- added[[kk]]
[10:26:13.133]                   NAME <- NAMES[[kk]]
[10:26:13.133]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.133]                     next
[10:26:13.133]                   args[[name]] <- ""
[10:26:13.133]                 }
[10:26:13.133]                 NAMES <- toupper(removed)
[10:26:13.133]                 for (kk in seq_along(NAMES)) {
[10:26:13.133]                   name <- removed[[kk]]
[10:26:13.133]                   NAME <- NAMES[[kk]]
[10:26:13.133]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.133]                     next
[10:26:13.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:13.133]                 }
[10:26:13.133]                 if (length(args) > 0) 
[10:26:13.133]                   base::do.call(base::Sys.setenv, args = args)
[10:26:13.133]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:13.133]             }
[10:26:13.133]             else {
[10:26:13.133]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:13.133]             }
[10:26:13.133]             {
[10:26:13.133]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:13.133]                   0L) {
[10:26:13.133]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:13.133]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:13.133]                   base::options(opts)
[10:26:13.133]                 }
[10:26:13.133]                 {
[10:26:13.133]                   {
[10:26:13.133]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:13.133]                     NULL
[10:26:13.133]                   }
[10:26:13.133]                   options(future.plan = NULL)
[10:26:13.133]                   if (is.na(NA_character_)) 
[10:26:13.133]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:13.133]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:13.133]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:13.133]                     envir = parent.frame()) 
[10:26:13.133]                   {
[10:26:13.133]                     default_workers <- missing(workers)
[10:26:13.133]                     if (is.function(workers)) 
[10:26:13.133]                       workers <- workers()
[10:26:13.133]                     workers <- structure(as.integer(workers), 
[10:26:13.133]                       class = class(workers))
[10:26:13.133]                     stop_if_not(is.finite(workers), workers >= 
[10:26:13.133]                       1L)
[10:26:13.133]                     if ((workers == 1L && !inherits(workers, 
[10:26:13.133]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:13.133]                       if (default_workers) 
[10:26:13.133]                         supportsMulticore(warn = TRUE)
[10:26:13.133]                       return(sequential(..., envir = envir))
[10:26:13.133]                     }
[10:26:13.133]                     oopts <- options(mc.cores = workers)
[10:26:13.133]                     on.exit(options(oopts))
[10:26:13.133]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:13.133]                       envir = envir)
[10:26:13.133]                     if (!future$lazy) 
[10:26:13.133]                       future <- run(future)
[10:26:13.133]                     invisible(future)
[10:26:13.133]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:13.133]                 }
[10:26:13.133]             }
[10:26:13.133]         }
[10:26:13.133]     })
[10:26:13.133]     if (TRUE) {
[10:26:13.133]         base::sink(type = "output", split = FALSE)
[10:26:13.133]         if (TRUE) {
[10:26:13.133]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:13.133]         }
[10:26:13.133]         else {
[10:26:13.133]             ...future.result["stdout"] <- base::list(NULL)
[10:26:13.133]         }
[10:26:13.133]         base::close(...future.stdout)
[10:26:13.133]         ...future.stdout <- NULL
[10:26:13.133]     }
[10:26:13.133]     ...future.result$conditions <- ...future.conditions
[10:26:13.133]     ...future.result$finished <- base::Sys.time()
[10:26:13.133]     ...future.result
[10:26:13.133] }
[10:26:13.136] assign_globals() ...
[10:26:13.136] List of 1
[10:26:13.136]  $ x:function ()  
[10:26:13.136]  - attr(*, "where")=List of 1
[10:26:13.136]   ..$ x:<environment: R_EmptyEnv> 
[10:26:13.136]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:13.136]  - attr(*, "resolved")= logi TRUE
[10:26:13.136]  - attr(*, "total_size")= num 1032
[10:26:13.136]  - attr(*, "already-done")= logi TRUE
[10:26:13.142] - reassign environment for ‘x’
[10:26:13.142] - copied ‘x’ to environment
[10:26:13.142] assign_globals() ... done
[10:26:13.142] requestCore(): workers = 2
[10:26:13.144] MulticoreFuture started
[10:26:13.145] - Launch lazy future ... done
[10:26:13.145] run() for ‘MulticoreFuture’ ... done
[10:26:13.145] plan(): Setting new future strategy stack:
[10:26:13.146] result() for MulticoreFuture ...
[10:26:13.146] List of future strategies:
[10:26:13.146] 1. sequential:
[10:26:13.146]    - args: function (..., envir = parent.frame())
[10:26:13.146]    - tweaked: FALSE
[10:26:13.146]    - call: NULL
[10:26:13.147] plan(): nbrOfWorkers() = 1
[10:26:13.149] plan(): Setting new future strategy stack:
[10:26:13.150] List of future strategies:
[10:26:13.150] 1. multicore:
[10:26:13.150]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:13.150]    - tweaked: FALSE
[10:26:13.150]    - call: plan(strategy)
[10:26:13.157] plan(): nbrOfWorkers() = 2
[10:26:13.158] result() for MulticoreFuture ...
[10:26:13.158] result() for MulticoreFuture ... done
[10:26:13.158] result() for MulticoreFuture ... done
[10:26:13.159] result() for MulticoreFuture ...
[10:26:13.159] result() for MulticoreFuture ... done
value(f) = ‘TRUE’
- plan('multisession') ...
[10:26:13.160] plan(): Setting new future strategy stack:
[10:26:13.160] List of future strategies:
[10:26:13.160] 1. multisession:
[10:26:13.160]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:13.160]    - tweaked: FALSE
[10:26:13.160]    - call: plan(strategy)
[10:26:13.161] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:26:13.161] multisession:
[10:26:13.161] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:13.161] - tweaked: FALSE
[10:26:13.161] - call: plan(strategy)
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:13.169] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:13.169] Not searching for globals
[10:26:13.169] - globals: [0] <none>
[10:26:13.170] getGlobalsAndPackages() ... DONE
[10:26:13.170] [local output] makeClusterPSOCK() ...
[10:26:13.215] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:26:13.217] [local output] Base port: 11345
[10:26:13.217] [local output] Getting setup options for 2 cluster nodes ...
[10:26:13.217] [local output]  - Node 1 of 2 ...
[10:26:13.217] [local output] localMachine=TRUE => revtunnel=FALSE

[10:26:13.218] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpQkWp4a/worker.rank=1.parallelly.parent=86465.151c1147a5cc5.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpQkWp4a/worker.rank=1.parallelly.parent=86465.151c1147a5cc5.pid")'’
[10:26:13.407] - Possible to infer worker's PID: TRUE
[10:26:13.408] [local output] Rscript port: 11345

[10:26:13.408] [local output]  - Node 2 of 2 ...
[10:26:13.408] [local output] localMachine=TRUE => revtunnel=FALSE

[10:26:13.409] [local output] Rscript port: 11345

[10:26:13.409] [local output] Getting setup options for 2 cluster nodes ... done
[10:26:13.409] [local output]  - Parallel setup requested for some PSOCK nodes
[10:26:13.410] [local output] Setting up PSOCK nodes in parallel
[10:26:13.410] List of 36
[10:26:13.410]  $ worker          : chr "localhost"
[10:26:13.410]   ..- attr(*, "localhost")= logi TRUE
[10:26:13.410]  $ master          : chr "localhost"
[10:26:13.410]  $ port            : int 11345
[10:26:13.410]  $ connectTimeout  : num 120
[10:26:13.410]  $ timeout         : num 2592000
[10:26:13.410]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:26:13.410]  $ homogeneous     : logi TRUE
[10:26:13.410]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:26:13.410]  $ rscript_envs    : NULL
[10:26:13.410]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:26:13.410]  $ rscript_startup : NULL
[10:26:13.410]  $ rscript_sh      : chr "sh"
[10:26:13.410]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:26:13.410]  $ methods         : logi TRUE
[10:26:13.410]  $ socketOptions   : chr "no-delay"
[10:26:13.410]  $ useXDR          : logi FALSE
[10:26:13.410]  $ outfile         : chr "/dev/null"
[10:26:13.410]  $ renice          : int NA
[10:26:13.410]  $ rshcmd          : NULL
[10:26:13.410]  $ user            : chr(0) 
[10:26:13.410]  $ revtunnel       : logi FALSE
[10:26:13.410]  $ rshlogfile      : NULL
[10:26:13.410]  $ rshopts         : chr(0) 
[10:26:13.410]  $ rank            : int 1
[10:26:13.410]  $ manual          : logi FALSE
[10:26:13.410]  $ dryrun          : logi FALSE
[10:26:13.410]  $ quiet           : logi FALSE
[10:26:13.410]  $ setup_strategy  : chr "parallel"
[10:26:13.410]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:26:13.410]  $ pidfile         : chr "/tmp/RtmpQkWp4a/worker.rank=1.parallelly.parent=86465.151c1147a5cc5.pid"
[10:26:13.410]  $ rshcmd_label    : NULL
[10:26:13.410]  $ rsh_call        : NULL
[10:26:13.410]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:26:13.410]  $ localMachine    : logi TRUE
[10:26:13.410]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:26:13.410]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:26:13.410]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:26:13.410]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:26:13.410]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:26:13.410]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:26:13.410]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:26:13.410]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:26:13.410]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:26:13.410]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:26:13.410]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:26:13.410]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:26:13.410]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:26:13.410]  $ arguments       :List of 28
[10:26:13.410]   ..$ worker          : chr "localhost"
[10:26:13.410]   ..$ master          : NULL
[10:26:13.410]   ..$ port            : int 11345
[10:26:13.410]   ..$ connectTimeout  : num 120
[10:26:13.410]   ..$ timeout         : num 2592000
[10:26:13.410]   ..$ rscript         : NULL
[10:26:13.410]   ..$ homogeneous     : NULL
[10:26:13.410]   ..$ rscript_args    : NULL
[10:26:13.410]   ..$ rscript_envs    : NULL
[10:26:13.410]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:26:13.410]   ..$ rscript_startup : NULL
[10:26:13.410]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:26:13.410]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:26:13.410]   ..$ methods         : logi TRUE
[10:26:13.410]   ..$ socketOptions   : chr "no-delay"
[10:26:13.410]   ..$ useXDR          : logi FALSE
[10:26:13.410]   ..$ outfile         : chr "/dev/null"
[10:26:13.410]   ..$ renice          : int NA
[10:26:13.410]   ..$ rshcmd          : NULL
[10:26:13.410]   ..$ user            : NULL
[10:26:13.410]   ..$ revtunnel       : logi NA
[10:26:13.410]   ..$ rshlogfile      : NULL
[10:26:13.410]   ..$ rshopts         : NULL
[10:26:13.410]   ..$ rank            : int 1
[10:26:13.410]   ..$ manual          : logi FALSE
[10:26:13.410]   ..$ dryrun          : logi FALSE
[10:26:13.410]   ..$ quiet           : logi FALSE
[10:26:13.410]   ..$ setup_strategy  : chr "parallel"
[10:26:13.410]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:26:13.427] [local output] System call to launch all workers:
[10:26:13.427] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpQkWp4a/worker.rank=1.parallelly.parent=86465.151c1147a5cc5.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11345 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:26:13.427] [local output] Starting PSOCK main server
[10:26:13.432] [local output] Workers launched
[10:26:13.433] [local output] Waiting for workers to connect back
[10:26:13.433]  - [local output] 0 workers out of 2 ready
[10:26:13.671]  - [local output] 0 workers out of 2 ready
[10:26:13.672]  - [local output] 1 workers out of 2 ready
[10:26:13.674]  - [local output] 1 workers out of 2 ready
[10:26:13.674]  - [local output] 2 workers out of 2 ready
[10:26:13.674] [local output] Launching of workers completed
[10:26:13.674] [local output] Collecting session information from workers
[10:26:13.675] [local output]  - Worker #1 of 2
[10:26:13.676] [local output]  - Worker #2 of 2
[10:26:13.676] [local output] makeClusterPSOCK() ... done
[10:26:13.687] Packages needed by the future expression (n = 0): <none>
[10:26:13.688] Packages needed by future strategies (n = 0): <none>
[10:26:13.688] {
[10:26:13.688]     {
[10:26:13.688]         {
[10:26:13.688]             ...future.startTime <- base::Sys.time()
[10:26:13.688]             {
[10:26:13.688]                 {
[10:26:13.688]                   {
[10:26:13.688]                     {
[10:26:13.688]                       base::local({
[10:26:13.688]                         has_future <- base::requireNamespace("future", 
[10:26:13.688]                           quietly = TRUE)
[10:26:13.688]                         if (has_future) {
[10:26:13.688]                           ns <- base::getNamespace("future")
[10:26:13.688]                           version <- ns[[".package"]][["version"]]
[10:26:13.688]                           if (is.null(version)) 
[10:26:13.688]                             version <- utils::packageVersion("future")
[10:26:13.688]                         }
[10:26:13.688]                         else {
[10:26:13.688]                           version <- NULL
[10:26:13.688]                         }
[10:26:13.688]                         if (!has_future || version < "1.8.0") {
[10:26:13.688]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:13.688]                             "", base::R.version$version.string), 
[10:26:13.688]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:13.688]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:13.688]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:13.688]                               "release", "version")], collapse = " "), 
[10:26:13.688]                             hostname = base::Sys.info()[["nodename"]])
[10:26:13.688]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:13.688]                             info)
[10:26:13.688]                           info <- base::paste(info, collapse = "; ")
[10:26:13.688]                           if (!has_future) {
[10:26:13.688]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:13.688]                               info)
[10:26:13.688]                           }
[10:26:13.688]                           else {
[10:26:13.688]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:13.688]                               info, version)
[10:26:13.688]                           }
[10:26:13.688]                           base::stop(msg)
[10:26:13.688]                         }
[10:26:13.688]                       })
[10:26:13.688]                     }
[10:26:13.688]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:13.688]                     base::options(mc.cores = 1L)
[10:26:13.688]                   }
[10:26:13.688]                   options(future.plan = NULL)
[10:26:13.688]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:13.688]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:13.688]                 }
[10:26:13.688]                 ...future.workdir <- getwd()
[10:26:13.688]             }
[10:26:13.688]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:13.688]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:13.688]         }
[10:26:13.688]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:13.688]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:13.688]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:13.688]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:13.688]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:13.688]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:13.688]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:13.688]             base::names(...future.oldOptions))
[10:26:13.688]     }
[10:26:13.688]     if (FALSE) {
[10:26:13.688]     }
[10:26:13.688]     else {
[10:26:13.688]         if (TRUE) {
[10:26:13.688]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:13.688]                 open = "w")
[10:26:13.688]         }
[10:26:13.688]         else {
[10:26:13.688]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:13.688]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:13.688]         }
[10:26:13.688]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:13.688]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:13.688]             base::sink(type = "output", split = FALSE)
[10:26:13.688]             base::close(...future.stdout)
[10:26:13.688]         }, add = TRUE)
[10:26:13.688]     }
[10:26:13.688]     ...future.frame <- base::sys.nframe()
[10:26:13.688]     ...future.conditions <- base::list()
[10:26:13.688]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:13.688]     if (FALSE) {
[10:26:13.688]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:13.688]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:13.688]     }
[10:26:13.688]     ...future.result <- base::tryCatch({
[10:26:13.688]         base::withCallingHandlers({
[10:26:13.688]             ...future.value <- base::withVisible(base::local({
[10:26:13.688]                 ...future.makeSendCondition <- base::local({
[10:26:13.688]                   sendCondition <- NULL
[10:26:13.688]                   function(frame = 1L) {
[10:26:13.688]                     if (is.function(sendCondition)) 
[10:26:13.688]                       return(sendCondition)
[10:26:13.688]                     ns <- getNamespace("parallel")
[10:26:13.688]                     if (exists("sendData", mode = "function", 
[10:26:13.688]                       envir = ns)) {
[10:26:13.688]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:13.688]                         envir = ns)
[10:26:13.688]                       envir <- sys.frame(frame)
[10:26:13.688]                       master <- NULL
[10:26:13.688]                       while (!identical(envir, .GlobalEnv) && 
[10:26:13.688]                         !identical(envir, emptyenv())) {
[10:26:13.688]                         if (exists("master", mode = "list", envir = envir, 
[10:26:13.688]                           inherits = FALSE)) {
[10:26:13.688]                           master <- get("master", mode = "list", 
[10:26:13.688]                             envir = envir, inherits = FALSE)
[10:26:13.688]                           if (inherits(master, c("SOCKnode", 
[10:26:13.688]                             "SOCK0node"))) {
[10:26:13.688]                             sendCondition <<- function(cond) {
[10:26:13.688]                               data <- list(type = "VALUE", value = cond, 
[10:26:13.688]                                 success = TRUE)
[10:26:13.688]                               parallel_sendData(master, data)
[10:26:13.688]                             }
[10:26:13.688]                             return(sendCondition)
[10:26:13.688]                           }
[10:26:13.688]                         }
[10:26:13.688]                         frame <- frame + 1L
[10:26:13.688]                         envir <- sys.frame(frame)
[10:26:13.688]                       }
[10:26:13.688]                     }
[10:26:13.688]                     sendCondition <<- function(cond) NULL
[10:26:13.688]                   }
[10:26:13.688]                 })
[10:26:13.688]                 withCallingHandlers({
[10:26:13.688]                   NA
[10:26:13.688]                 }, immediateCondition = function(cond) {
[10:26:13.688]                   sendCondition <- ...future.makeSendCondition()
[10:26:13.688]                   sendCondition(cond)
[10:26:13.688]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:13.688]                   {
[10:26:13.688]                     inherits <- base::inherits
[10:26:13.688]                     invokeRestart <- base::invokeRestart
[10:26:13.688]                     is.null <- base::is.null
[10:26:13.688]                     muffled <- FALSE
[10:26:13.688]                     if (inherits(cond, "message")) {
[10:26:13.688]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:13.688]                       if (muffled) 
[10:26:13.688]                         invokeRestart("muffleMessage")
[10:26:13.688]                     }
[10:26:13.688]                     else if (inherits(cond, "warning")) {
[10:26:13.688]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:13.688]                       if (muffled) 
[10:26:13.688]                         invokeRestart("muffleWarning")
[10:26:13.688]                     }
[10:26:13.688]                     else if (inherits(cond, "condition")) {
[10:26:13.688]                       if (!is.null(pattern)) {
[10:26:13.688]                         computeRestarts <- base::computeRestarts
[10:26:13.688]                         grepl <- base::grepl
[10:26:13.688]                         restarts <- computeRestarts(cond)
[10:26:13.688]                         for (restart in restarts) {
[10:26:13.688]                           name <- restart$name
[10:26:13.688]                           if (is.null(name)) 
[10:26:13.688]                             next
[10:26:13.688]                           if (!grepl(pattern, name)) 
[10:26:13.688]                             next
[10:26:13.688]                           invokeRestart(restart)
[10:26:13.688]                           muffled <- TRUE
[10:26:13.688]                           break
[10:26:13.688]                         }
[10:26:13.688]                       }
[10:26:13.688]                     }
[10:26:13.688]                     invisible(muffled)
[10:26:13.688]                   }
[10:26:13.688]                   muffleCondition(cond)
[10:26:13.688]                 })
[10:26:13.688]             }))
[10:26:13.688]             future::FutureResult(value = ...future.value$value, 
[10:26:13.688]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:13.688]                   ...future.rng), globalenv = if (FALSE) 
[10:26:13.688]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:13.688]                     ...future.globalenv.names))
[10:26:13.688]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:13.688]         }, condition = base::local({
[10:26:13.688]             c <- base::c
[10:26:13.688]             inherits <- base::inherits
[10:26:13.688]             invokeRestart <- base::invokeRestart
[10:26:13.688]             length <- base::length
[10:26:13.688]             list <- base::list
[10:26:13.688]             seq.int <- base::seq.int
[10:26:13.688]             signalCondition <- base::signalCondition
[10:26:13.688]             sys.calls <- base::sys.calls
[10:26:13.688]             `[[` <- base::`[[`
[10:26:13.688]             `+` <- base::`+`
[10:26:13.688]             `<<-` <- base::`<<-`
[10:26:13.688]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:13.688]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:13.688]                   3L)]
[10:26:13.688]             }
[10:26:13.688]             function(cond) {
[10:26:13.688]                 is_error <- inherits(cond, "error")
[10:26:13.688]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:13.688]                   NULL)
[10:26:13.688]                 if (is_error) {
[10:26:13.688]                   sessionInformation <- function() {
[10:26:13.688]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:13.688]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:13.688]                       search = base::search(), system = base::Sys.info())
[10:26:13.688]                   }
[10:26:13.688]                   ...future.conditions[[length(...future.conditions) + 
[10:26:13.688]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:13.688]                     cond$call), session = sessionInformation(), 
[10:26:13.688]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:13.688]                   signalCondition(cond)
[10:26:13.688]                 }
[10:26:13.688]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:13.688]                 "immediateCondition"))) {
[10:26:13.688]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:13.688]                   ...future.conditions[[length(...future.conditions) + 
[10:26:13.688]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:13.688]                   if (TRUE && !signal) {
[10:26:13.688]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:13.688]                     {
[10:26:13.688]                       inherits <- base::inherits
[10:26:13.688]                       invokeRestart <- base::invokeRestart
[10:26:13.688]                       is.null <- base::is.null
[10:26:13.688]                       muffled <- FALSE
[10:26:13.688]                       if (inherits(cond, "message")) {
[10:26:13.688]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:13.688]                         if (muffled) 
[10:26:13.688]                           invokeRestart("muffleMessage")
[10:26:13.688]                       }
[10:26:13.688]                       else if (inherits(cond, "warning")) {
[10:26:13.688]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:13.688]                         if (muffled) 
[10:26:13.688]                           invokeRestart("muffleWarning")
[10:26:13.688]                       }
[10:26:13.688]                       else if (inherits(cond, "condition")) {
[10:26:13.688]                         if (!is.null(pattern)) {
[10:26:13.688]                           computeRestarts <- base::computeRestarts
[10:26:13.688]                           grepl <- base::grepl
[10:26:13.688]                           restarts <- computeRestarts(cond)
[10:26:13.688]                           for (restart in restarts) {
[10:26:13.688]                             name <- restart$name
[10:26:13.688]                             if (is.null(name)) 
[10:26:13.688]                               next
[10:26:13.688]                             if (!grepl(pattern, name)) 
[10:26:13.688]                               next
[10:26:13.688]                             invokeRestart(restart)
[10:26:13.688]                             muffled <- TRUE
[10:26:13.688]                             break
[10:26:13.688]                           }
[10:26:13.688]                         }
[10:26:13.688]                       }
[10:26:13.688]                       invisible(muffled)
[10:26:13.688]                     }
[10:26:13.688]                     muffleCondition(cond, pattern = "^muffle")
[10:26:13.688]                   }
[10:26:13.688]                 }
[10:26:13.688]                 else {
[10:26:13.688]                   if (TRUE) {
[10:26:13.688]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:13.688]                     {
[10:26:13.688]                       inherits <- base::inherits
[10:26:13.688]                       invokeRestart <- base::invokeRestart
[10:26:13.688]                       is.null <- base::is.null
[10:26:13.688]                       muffled <- FALSE
[10:26:13.688]                       if (inherits(cond, "message")) {
[10:26:13.688]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:13.688]                         if (muffled) 
[10:26:13.688]                           invokeRestart("muffleMessage")
[10:26:13.688]                       }
[10:26:13.688]                       else if (inherits(cond, "warning")) {
[10:26:13.688]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:13.688]                         if (muffled) 
[10:26:13.688]                           invokeRestart("muffleWarning")
[10:26:13.688]                       }
[10:26:13.688]                       else if (inherits(cond, "condition")) {
[10:26:13.688]                         if (!is.null(pattern)) {
[10:26:13.688]                           computeRestarts <- base::computeRestarts
[10:26:13.688]                           grepl <- base::grepl
[10:26:13.688]                           restarts <- computeRestarts(cond)
[10:26:13.688]                           for (restart in restarts) {
[10:26:13.688]                             name <- restart$name
[10:26:13.688]                             if (is.null(name)) 
[10:26:13.688]                               next
[10:26:13.688]                             if (!grepl(pattern, name)) 
[10:26:13.688]                               next
[10:26:13.688]                             invokeRestart(restart)
[10:26:13.688]                             muffled <- TRUE
[10:26:13.688]                             break
[10:26:13.688]                           }
[10:26:13.688]                         }
[10:26:13.688]                       }
[10:26:13.688]                       invisible(muffled)
[10:26:13.688]                     }
[10:26:13.688]                     muffleCondition(cond, pattern = "^muffle")
[10:26:13.688]                   }
[10:26:13.688]                 }
[10:26:13.688]             }
[10:26:13.688]         }))
[10:26:13.688]     }, error = function(ex) {
[10:26:13.688]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:13.688]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:13.688]                 ...future.rng), started = ...future.startTime, 
[10:26:13.688]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:13.688]             version = "1.8"), class = "FutureResult")
[10:26:13.688]     }, finally = {
[10:26:13.688]         if (!identical(...future.workdir, getwd())) 
[10:26:13.688]             setwd(...future.workdir)
[10:26:13.688]         {
[10:26:13.688]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:13.688]                 ...future.oldOptions$nwarnings <- NULL
[10:26:13.688]             }
[10:26:13.688]             base::options(...future.oldOptions)
[10:26:13.688]             if (.Platform$OS.type == "windows") {
[10:26:13.688]                 old_names <- names(...future.oldEnvVars)
[10:26:13.688]                 envs <- base::Sys.getenv()
[10:26:13.688]                 names <- names(envs)
[10:26:13.688]                 common <- intersect(names, old_names)
[10:26:13.688]                 added <- setdiff(names, old_names)
[10:26:13.688]                 removed <- setdiff(old_names, names)
[10:26:13.688]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:13.688]                   envs[common]]
[10:26:13.688]                 NAMES <- toupper(changed)
[10:26:13.688]                 args <- list()
[10:26:13.688]                 for (kk in seq_along(NAMES)) {
[10:26:13.688]                   name <- changed[[kk]]
[10:26:13.688]                   NAME <- NAMES[[kk]]
[10:26:13.688]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.688]                     next
[10:26:13.688]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:13.688]                 }
[10:26:13.688]                 NAMES <- toupper(added)
[10:26:13.688]                 for (kk in seq_along(NAMES)) {
[10:26:13.688]                   name <- added[[kk]]
[10:26:13.688]                   NAME <- NAMES[[kk]]
[10:26:13.688]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.688]                     next
[10:26:13.688]                   args[[name]] <- ""
[10:26:13.688]                 }
[10:26:13.688]                 NAMES <- toupper(removed)
[10:26:13.688]                 for (kk in seq_along(NAMES)) {
[10:26:13.688]                   name <- removed[[kk]]
[10:26:13.688]                   NAME <- NAMES[[kk]]
[10:26:13.688]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.688]                     next
[10:26:13.688]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:13.688]                 }
[10:26:13.688]                 if (length(args) > 0) 
[10:26:13.688]                   base::do.call(base::Sys.setenv, args = args)
[10:26:13.688]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:13.688]             }
[10:26:13.688]             else {
[10:26:13.688]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:13.688]             }
[10:26:13.688]             {
[10:26:13.688]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:13.688]                   0L) {
[10:26:13.688]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:13.688]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:13.688]                   base::options(opts)
[10:26:13.688]                 }
[10:26:13.688]                 {
[10:26:13.688]                   {
[10:26:13.688]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:13.688]                     NULL
[10:26:13.688]                   }
[10:26:13.688]                   options(future.plan = NULL)
[10:26:13.688]                   if (is.na(NA_character_)) 
[10:26:13.688]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:13.688]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:13.688]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:13.688]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:13.688]                     envir = parent.frame()) 
[10:26:13.688]                   {
[10:26:13.688]                     if (is.function(workers)) 
[10:26:13.688]                       workers <- workers()
[10:26:13.688]                     workers <- structure(as.integer(workers), 
[10:26:13.688]                       class = class(workers))
[10:26:13.688]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:13.688]                       workers >= 1)
[10:26:13.688]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:13.688]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:13.688]                     }
[10:26:13.688]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:13.688]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:13.688]                       envir = envir)
[10:26:13.688]                     if (!future$lazy) 
[10:26:13.688]                       future <- run(future)
[10:26:13.688]                     invisible(future)
[10:26:13.688]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:13.688]                 }
[10:26:13.688]             }
[10:26:13.688]         }
[10:26:13.688]     })
[10:26:13.688]     if (TRUE) {
[10:26:13.688]         base::sink(type = "output", split = FALSE)
[10:26:13.688]         if (TRUE) {
[10:26:13.688]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:13.688]         }
[10:26:13.688]         else {
[10:26:13.688]             ...future.result["stdout"] <- base::list(NULL)
[10:26:13.688]         }
[10:26:13.688]         base::close(...future.stdout)
[10:26:13.688]         ...future.stdout <- NULL
[10:26:13.688]     }
[10:26:13.688]     ...future.result$conditions <- ...future.conditions
[10:26:13.688]     ...future.result$finished <- base::Sys.time()
[10:26:13.688]     ...future.result
[10:26:13.688] }
[10:26:13.741] MultisessionFuture started
[10:26:13.741] result() for ClusterFuture ...
[10:26:13.742] receiveMessageFromWorker() for ClusterFuture ...
[10:26:13.742] - Validating connection of MultisessionFuture
[10:26:13.784] - received message: FutureResult
[10:26:13.785] - Received FutureResult
[10:26:13.785] - Erased future from FutureRegistry
[10:26:13.785] result() for ClusterFuture ...
[10:26:13.785] - result already collected: FutureResult
[10:26:13.785] result() for ClusterFuture ... done
[10:26:13.785] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:13.785] result() for ClusterFuture ... done
[10:26:13.785] result() for ClusterFuture ...
[10:26:13.785] - result already collected: FutureResult
[10:26:13.786] result() for ClusterFuture ... done
[10:26:13.786] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:26:13.789] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:13.790] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:13.790] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:13.791] - globals found: [3] ‘{’, ‘<-’, ‘*’
[10:26:13.791] Searching for globals ... DONE
[10:26:13.792] Resolving globals: TRUE
[10:26:13.792] Resolving any globals that are futures ...
[10:26:13.792] - globals: [3] ‘{’, ‘<-’, ‘*’
[10:26:13.792] Resolving any globals that are futures ... DONE
[10:26:13.792] 
[10:26:13.792] 
[10:26:13.793] getGlobalsAndPackages() ... DONE
[10:26:13.793] run() for ‘Future’ ...
[10:26:13.793] - state: ‘created’
[10:26:13.793] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:13.808] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:13.808] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:13.808]   - Field: ‘node’
[10:26:13.808]   - Field: ‘label’
[10:26:13.808]   - Field: ‘local’
[10:26:13.808]   - Field: ‘owner’
[10:26:13.808]   - Field: ‘envir’
[10:26:13.808]   - Field: ‘workers’
[10:26:13.808]   - Field: ‘packages’
[10:26:13.808]   - Field: ‘gc’
[10:26:13.809]   - Field: ‘conditions’
[10:26:13.809]   - Field: ‘persistent’
[10:26:13.809]   - Field: ‘expr’
[10:26:13.809]   - Field: ‘uuid’
[10:26:13.809]   - Field: ‘seed’
[10:26:13.809]   - Field: ‘version’
[10:26:13.809]   - Field: ‘result’
[10:26:13.809]   - Field: ‘asynchronous’
[10:26:13.810]   - Field: ‘calls’
[10:26:13.810]   - Field: ‘globals’
[10:26:13.810]   - Field: ‘stdout’
[10:26:13.810]   - Field: ‘earlySignal’
[10:26:13.810]   - Field: ‘lazy’
[10:26:13.810]   - Field: ‘state’
[10:26:13.810] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:13.810] - Launch lazy future ...
[10:26:13.811] Packages needed by the future expression (n = 0): <none>
[10:26:13.811] Packages needed by future strategies (n = 0): <none>
[10:26:13.811] {
[10:26:13.811]     {
[10:26:13.811]         {
[10:26:13.811]             ...future.startTime <- base::Sys.time()
[10:26:13.811]             {
[10:26:13.811]                 {
[10:26:13.811]                   {
[10:26:13.811]                     {
[10:26:13.811]                       base::local({
[10:26:13.811]                         has_future <- base::requireNamespace("future", 
[10:26:13.811]                           quietly = TRUE)
[10:26:13.811]                         if (has_future) {
[10:26:13.811]                           ns <- base::getNamespace("future")
[10:26:13.811]                           version <- ns[[".package"]][["version"]]
[10:26:13.811]                           if (is.null(version)) 
[10:26:13.811]                             version <- utils::packageVersion("future")
[10:26:13.811]                         }
[10:26:13.811]                         else {
[10:26:13.811]                           version <- NULL
[10:26:13.811]                         }
[10:26:13.811]                         if (!has_future || version < "1.8.0") {
[10:26:13.811]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:13.811]                             "", base::R.version$version.string), 
[10:26:13.811]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:13.811]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:13.811]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:13.811]                               "release", "version")], collapse = " "), 
[10:26:13.811]                             hostname = base::Sys.info()[["nodename"]])
[10:26:13.811]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:13.811]                             info)
[10:26:13.811]                           info <- base::paste(info, collapse = "; ")
[10:26:13.811]                           if (!has_future) {
[10:26:13.811]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:13.811]                               info)
[10:26:13.811]                           }
[10:26:13.811]                           else {
[10:26:13.811]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:13.811]                               info, version)
[10:26:13.811]                           }
[10:26:13.811]                           base::stop(msg)
[10:26:13.811]                         }
[10:26:13.811]                       })
[10:26:13.811]                     }
[10:26:13.811]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:13.811]                     base::options(mc.cores = 1L)
[10:26:13.811]                   }
[10:26:13.811]                   options(future.plan = NULL)
[10:26:13.811]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:13.811]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:13.811]                 }
[10:26:13.811]                 ...future.workdir <- getwd()
[10:26:13.811]             }
[10:26:13.811]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:13.811]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:13.811]         }
[10:26:13.811]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:13.811]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:13.811]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:13.811]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:13.811]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:13.811]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:13.811]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:13.811]             base::names(...future.oldOptions))
[10:26:13.811]     }
[10:26:13.811]     if (FALSE) {
[10:26:13.811]     }
[10:26:13.811]     else {
[10:26:13.811]         if (TRUE) {
[10:26:13.811]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:13.811]                 open = "w")
[10:26:13.811]         }
[10:26:13.811]         else {
[10:26:13.811]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:13.811]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:13.811]         }
[10:26:13.811]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:13.811]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:13.811]             base::sink(type = "output", split = FALSE)
[10:26:13.811]             base::close(...future.stdout)
[10:26:13.811]         }, add = TRUE)
[10:26:13.811]     }
[10:26:13.811]     ...future.frame <- base::sys.nframe()
[10:26:13.811]     ...future.conditions <- base::list()
[10:26:13.811]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:13.811]     if (FALSE) {
[10:26:13.811]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:13.811]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:13.811]     }
[10:26:13.811]     ...future.result <- base::tryCatch({
[10:26:13.811]         base::withCallingHandlers({
[10:26:13.811]             ...future.value <- base::withVisible(base::local({
[10:26:13.811]                 ...future.makeSendCondition <- base::local({
[10:26:13.811]                   sendCondition <- NULL
[10:26:13.811]                   function(frame = 1L) {
[10:26:13.811]                     if (is.function(sendCondition)) 
[10:26:13.811]                       return(sendCondition)
[10:26:13.811]                     ns <- getNamespace("parallel")
[10:26:13.811]                     if (exists("sendData", mode = "function", 
[10:26:13.811]                       envir = ns)) {
[10:26:13.811]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:13.811]                         envir = ns)
[10:26:13.811]                       envir <- sys.frame(frame)
[10:26:13.811]                       master <- NULL
[10:26:13.811]                       while (!identical(envir, .GlobalEnv) && 
[10:26:13.811]                         !identical(envir, emptyenv())) {
[10:26:13.811]                         if (exists("master", mode = "list", envir = envir, 
[10:26:13.811]                           inherits = FALSE)) {
[10:26:13.811]                           master <- get("master", mode = "list", 
[10:26:13.811]                             envir = envir, inherits = FALSE)
[10:26:13.811]                           if (inherits(master, c("SOCKnode", 
[10:26:13.811]                             "SOCK0node"))) {
[10:26:13.811]                             sendCondition <<- function(cond) {
[10:26:13.811]                               data <- list(type = "VALUE", value = cond, 
[10:26:13.811]                                 success = TRUE)
[10:26:13.811]                               parallel_sendData(master, data)
[10:26:13.811]                             }
[10:26:13.811]                             return(sendCondition)
[10:26:13.811]                           }
[10:26:13.811]                         }
[10:26:13.811]                         frame <- frame + 1L
[10:26:13.811]                         envir <- sys.frame(frame)
[10:26:13.811]                       }
[10:26:13.811]                     }
[10:26:13.811]                     sendCondition <<- function(cond) NULL
[10:26:13.811]                   }
[10:26:13.811]                 })
[10:26:13.811]                 withCallingHandlers({
[10:26:13.811]                   {
[10:26:13.811]                     b <- a
[10:26:13.811]                     a <- 2
[10:26:13.811]                     a * b
[10:26:13.811]                   }
[10:26:13.811]                 }, immediateCondition = function(cond) {
[10:26:13.811]                   sendCondition <- ...future.makeSendCondition()
[10:26:13.811]                   sendCondition(cond)
[10:26:13.811]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:13.811]                   {
[10:26:13.811]                     inherits <- base::inherits
[10:26:13.811]                     invokeRestart <- base::invokeRestart
[10:26:13.811]                     is.null <- base::is.null
[10:26:13.811]                     muffled <- FALSE
[10:26:13.811]                     if (inherits(cond, "message")) {
[10:26:13.811]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:13.811]                       if (muffled) 
[10:26:13.811]                         invokeRestart("muffleMessage")
[10:26:13.811]                     }
[10:26:13.811]                     else if (inherits(cond, "warning")) {
[10:26:13.811]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:13.811]                       if (muffled) 
[10:26:13.811]                         invokeRestart("muffleWarning")
[10:26:13.811]                     }
[10:26:13.811]                     else if (inherits(cond, "condition")) {
[10:26:13.811]                       if (!is.null(pattern)) {
[10:26:13.811]                         computeRestarts <- base::computeRestarts
[10:26:13.811]                         grepl <- base::grepl
[10:26:13.811]                         restarts <- computeRestarts(cond)
[10:26:13.811]                         for (restart in restarts) {
[10:26:13.811]                           name <- restart$name
[10:26:13.811]                           if (is.null(name)) 
[10:26:13.811]                             next
[10:26:13.811]                           if (!grepl(pattern, name)) 
[10:26:13.811]                             next
[10:26:13.811]                           invokeRestart(restart)
[10:26:13.811]                           muffled <- TRUE
[10:26:13.811]                           break
[10:26:13.811]                         }
[10:26:13.811]                       }
[10:26:13.811]                     }
[10:26:13.811]                     invisible(muffled)
[10:26:13.811]                   }
[10:26:13.811]                   muffleCondition(cond)
[10:26:13.811]                 })
[10:26:13.811]             }))
[10:26:13.811]             future::FutureResult(value = ...future.value$value, 
[10:26:13.811]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:13.811]                   ...future.rng), globalenv = if (FALSE) 
[10:26:13.811]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:13.811]                     ...future.globalenv.names))
[10:26:13.811]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:13.811]         }, condition = base::local({
[10:26:13.811]             c <- base::c
[10:26:13.811]             inherits <- base::inherits
[10:26:13.811]             invokeRestart <- base::invokeRestart
[10:26:13.811]             length <- base::length
[10:26:13.811]             list <- base::list
[10:26:13.811]             seq.int <- base::seq.int
[10:26:13.811]             signalCondition <- base::signalCondition
[10:26:13.811]             sys.calls <- base::sys.calls
[10:26:13.811]             `[[` <- base::`[[`
[10:26:13.811]             `+` <- base::`+`
[10:26:13.811]             `<<-` <- base::`<<-`
[10:26:13.811]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:13.811]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:13.811]                   3L)]
[10:26:13.811]             }
[10:26:13.811]             function(cond) {
[10:26:13.811]                 is_error <- inherits(cond, "error")
[10:26:13.811]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:13.811]                   NULL)
[10:26:13.811]                 if (is_error) {
[10:26:13.811]                   sessionInformation <- function() {
[10:26:13.811]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:13.811]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:13.811]                       search = base::search(), system = base::Sys.info())
[10:26:13.811]                   }
[10:26:13.811]                   ...future.conditions[[length(...future.conditions) + 
[10:26:13.811]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:13.811]                     cond$call), session = sessionInformation(), 
[10:26:13.811]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:13.811]                   signalCondition(cond)
[10:26:13.811]                 }
[10:26:13.811]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:13.811]                 "immediateCondition"))) {
[10:26:13.811]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:13.811]                   ...future.conditions[[length(...future.conditions) + 
[10:26:13.811]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:13.811]                   if (TRUE && !signal) {
[10:26:13.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:13.811]                     {
[10:26:13.811]                       inherits <- base::inherits
[10:26:13.811]                       invokeRestart <- base::invokeRestart
[10:26:13.811]                       is.null <- base::is.null
[10:26:13.811]                       muffled <- FALSE
[10:26:13.811]                       if (inherits(cond, "message")) {
[10:26:13.811]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:13.811]                         if (muffled) 
[10:26:13.811]                           invokeRestart("muffleMessage")
[10:26:13.811]                       }
[10:26:13.811]                       else if (inherits(cond, "warning")) {
[10:26:13.811]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:13.811]                         if (muffled) 
[10:26:13.811]                           invokeRestart("muffleWarning")
[10:26:13.811]                       }
[10:26:13.811]                       else if (inherits(cond, "condition")) {
[10:26:13.811]                         if (!is.null(pattern)) {
[10:26:13.811]                           computeRestarts <- base::computeRestarts
[10:26:13.811]                           grepl <- base::grepl
[10:26:13.811]                           restarts <- computeRestarts(cond)
[10:26:13.811]                           for (restart in restarts) {
[10:26:13.811]                             name <- restart$name
[10:26:13.811]                             if (is.null(name)) 
[10:26:13.811]                               next
[10:26:13.811]                             if (!grepl(pattern, name)) 
[10:26:13.811]                               next
[10:26:13.811]                             invokeRestart(restart)
[10:26:13.811]                             muffled <- TRUE
[10:26:13.811]                             break
[10:26:13.811]                           }
[10:26:13.811]                         }
[10:26:13.811]                       }
[10:26:13.811]                       invisible(muffled)
[10:26:13.811]                     }
[10:26:13.811]                     muffleCondition(cond, pattern = "^muffle")
[10:26:13.811]                   }
[10:26:13.811]                 }
[10:26:13.811]                 else {
[10:26:13.811]                   if (TRUE) {
[10:26:13.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:13.811]                     {
[10:26:13.811]                       inherits <- base::inherits
[10:26:13.811]                       invokeRestart <- base::invokeRestart
[10:26:13.811]                       is.null <- base::is.null
[10:26:13.811]                       muffled <- FALSE
[10:26:13.811]                       if (inherits(cond, "message")) {
[10:26:13.811]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:13.811]                         if (muffled) 
[10:26:13.811]                           invokeRestart("muffleMessage")
[10:26:13.811]                       }
[10:26:13.811]                       else if (inherits(cond, "warning")) {
[10:26:13.811]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:13.811]                         if (muffled) 
[10:26:13.811]                           invokeRestart("muffleWarning")
[10:26:13.811]                       }
[10:26:13.811]                       else if (inherits(cond, "condition")) {
[10:26:13.811]                         if (!is.null(pattern)) {
[10:26:13.811]                           computeRestarts <- base::computeRestarts
[10:26:13.811]                           grepl <- base::grepl
[10:26:13.811]                           restarts <- computeRestarts(cond)
[10:26:13.811]                           for (restart in restarts) {
[10:26:13.811]                             name <- restart$name
[10:26:13.811]                             if (is.null(name)) 
[10:26:13.811]                               next
[10:26:13.811]                             if (!grepl(pattern, name)) 
[10:26:13.811]                               next
[10:26:13.811]                             invokeRestart(restart)
[10:26:13.811]                             muffled <- TRUE
[10:26:13.811]                             break
[10:26:13.811]                           }
[10:26:13.811]                         }
[10:26:13.811]                       }
[10:26:13.811]                       invisible(muffled)
[10:26:13.811]                     }
[10:26:13.811]                     muffleCondition(cond, pattern = "^muffle")
[10:26:13.811]                   }
[10:26:13.811]                 }
[10:26:13.811]             }
[10:26:13.811]         }))
[10:26:13.811]     }, error = function(ex) {
[10:26:13.811]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:13.811]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:13.811]                 ...future.rng), started = ...future.startTime, 
[10:26:13.811]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:13.811]             version = "1.8"), class = "FutureResult")
[10:26:13.811]     }, finally = {
[10:26:13.811]         if (!identical(...future.workdir, getwd())) 
[10:26:13.811]             setwd(...future.workdir)
[10:26:13.811]         {
[10:26:13.811]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:13.811]                 ...future.oldOptions$nwarnings <- NULL
[10:26:13.811]             }
[10:26:13.811]             base::options(...future.oldOptions)
[10:26:13.811]             if (.Platform$OS.type == "windows") {
[10:26:13.811]                 old_names <- names(...future.oldEnvVars)
[10:26:13.811]                 envs <- base::Sys.getenv()
[10:26:13.811]                 names <- names(envs)
[10:26:13.811]                 common <- intersect(names, old_names)
[10:26:13.811]                 added <- setdiff(names, old_names)
[10:26:13.811]                 removed <- setdiff(old_names, names)
[10:26:13.811]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:13.811]                   envs[common]]
[10:26:13.811]                 NAMES <- toupper(changed)
[10:26:13.811]                 args <- list()
[10:26:13.811]                 for (kk in seq_along(NAMES)) {
[10:26:13.811]                   name <- changed[[kk]]
[10:26:13.811]                   NAME <- NAMES[[kk]]
[10:26:13.811]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.811]                     next
[10:26:13.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:13.811]                 }
[10:26:13.811]                 NAMES <- toupper(added)
[10:26:13.811]                 for (kk in seq_along(NAMES)) {
[10:26:13.811]                   name <- added[[kk]]
[10:26:13.811]                   NAME <- NAMES[[kk]]
[10:26:13.811]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.811]                     next
[10:26:13.811]                   args[[name]] <- ""
[10:26:13.811]                 }
[10:26:13.811]                 NAMES <- toupper(removed)
[10:26:13.811]                 for (kk in seq_along(NAMES)) {
[10:26:13.811]                   name <- removed[[kk]]
[10:26:13.811]                   NAME <- NAMES[[kk]]
[10:26:13.811]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.811]                     next
[10:26:13.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:13.811]                 }
[10:26:13.811]                 if (length(args) > 0) 
[10:26:13.811]                   base::do.call(base::Sys.setenv, args = args)
[10:26:13.811]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:13.811]             }
[10:26:13.811]             else {
[10:26:13.811]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:13.811]             }
[10:26:13.811]             {
[10:26:13.811]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:13.811]                   0L) {
[10:26:13.811]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:13.811]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:13.811]                   base::options(opts)
[10:26:13.811]                 }
[10:26:13.811]                 {
[10:26:13.811]                   {
[10:26:13.811]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:13.811]                     NULL
[10:26:13.811]                   }
[10:26:13.811]                   options(future.plan = NULL)
[10:26:13.811]                   if (is.na(NA_character_)) 
[10:26:13.811]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:13.811]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:13.811]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:13.811]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:13.811]                     envir = parent.frame()) 
[10:26:13.811]                   {
[10:26:13.811]                     if (is.function(workers)) 
[10:26:13.811]                       workers <- workers()
[10:26:13.811]                     workers <- structure(as.integer(workers), 
[10:26:13.811]                       class = class(workers))
[10:26:13.811]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:13.811]                       workers >= 1)
[10:26:13.811]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:13.811]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:13.811]                     }
[10:26:13.811]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:13.811]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:13.811]                       envir = envir)
[10:26:13.811]                     if (!future$lazy) 
[10:26:13.811]                       future <- run(future)
[10:26:13.811]                     invisible(future)
[10:26:13.811]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:13.811]                 }
[10:26:13.811]             }
[10:26:13.811]         }
[10:26:13.811]     })
[10:26:13.811]     if (TRUE) {
[10:26:13.811]         base::sink(type = "output", split = FALSE)
[10:26:13.811]         if (TRUE) {
[10:26:13.811]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:13.811]         }
[10:26:13.811]         else {
[10:26:13.811]             ...future.result["stdout"] <- base::list(NULL)
[10:26:13.811]         }
[10:26:13.811]         base::close(...future.stdout)
[10:26:13.811]         ...future.stdout <- NULL
[10:26:13.811]     }
[10:26:13.811]     ...future.result$conditions <- ...future.conditions
[10:26:13.811]     ...future.result$finished <- base::Sys.time()
[10:26:13.811]     ...future.result
[10:26:13.811] }
[10:26:13.815] MultisessionFuture started
[10:26:13.815] - Launch lazy future ... done
[10:26:13.815] run() for ‘MultisessionFuture’ ... done
[10:26:13.815] result() for ClusterFuture ...
[10:26:13.816] receiveMessageFromWorker() for ClusterFuture ...
[10:26:13.816] - Validating connection of MultisessionFuture
[10:26:13.863] - received message: FutureResult
[10:26:13.863] - Received FutureResult
[10:26:13.863] - Erased future from FutureRegistry
[10:26:13.863] result() for ClusterFuture ...
[10:26:13.863] - result already collected: FutureResult
[10:26:13.863] result() for ClusterFuture ... done
[10:26:13.864] signalConditions() ...
[10:26:13.864]  - include = ‘immediateCondition’
[10:26:13.864]  - exclude = 
[10:26:13.864]  - resignal = FALSE
[10:26:13.864]  - Number of conditions: 1
[10:26:13.864] signalConditions() ... done
[10:26:13.864] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:13.864] result() for ClusterFuture ... done
[10:26:13.864] result() for ClusterFuture ...
[10:26:13.865] - result already collected: FutureResult
[10:26:13.865] result() for ClusterFuture ... done
[10:26:13.865] signalConditions() ...
[10:26:13.865]  - include = ‘immediateCondition’
[10:26:13.865]  - exclude = 
[10:26:13.865]  - resignal = FALSE
[10:26:13.865]  - Number of conditions: 1
[10:26:13.865] signalConditions() ... done
[10:26:13.866] Future state: ‘finished’
[10:26:13.866] result() for ClusterFuture ...
[10:26:13.866] - result already collected: FutureResult
[10:26:13.866] result() for ClusterFuture ... done
[10:26:13.866] signalConditions() ...
[10:26:13.866]  - include = ‘condition’
[10:26:13.866]  - exclude = ‘immediateCondition’
[10:26:13.866]  - resignal = TRUE
[10:26:13.866]  - Number of conditions: 1
[10:26:13.867]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:26:13.867] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3e863ac79bce" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 10:26:13"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:13.883] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:13.883] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:13.885] - globals found: [3] ‘{’, ‘<-’, ‘*’
[10:26:13.885] Searching for globals ... DONE
[10:26:13.885] Resolving globals: TRUE
[10:26:13.886] Resolving any globals that are futures ...
[10:26:13.886] - globals: [3] ‘{’, ‘<-’, ‘*’
[10:26:13.886] Resolving any globals that are futures ... DONE
[10:26:13.886] 
[10:26:13.886] 
[10:26:13.886] getGlobalsAndPackages() ... DONE
[10:26:13.887] run() for ‘Future’ ...
[10:26:13.887] - state: ‘created’
[10:26:13.887] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:13.901] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:13.901] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:13.902]   - Field: ‘node’
[10:26:13.902]   - Field: ‘label’
[10:26:13.902]   - Field: ‘local’
[10:26:13.902]   - Field: ‘owner’
[10:26:13.902]   - Field: ‘envir’
[10:26:13.902]   - Field: ‘workers’
[10:26:13.902]   - Field: ‘packages’
[10:26:13.902]   - Field: ‘gc’
[10:26:13.902]   - Field: ‘conditions’
[10:26:13.902]   - Field: ‘persistent’
[10:26:13.903]   - Field: ‘expr’
[10:26:13.903]   - Field: ‘uuid’
[10:26:13.903]   - Field: ‘seed’
[10:26:13.903]   - Field: ‘version’
[10:26:13.903]   - Field: ‘result’
[10:26:13.903]   - Field: ‘asynchronous’
[10:26:13.903]   - Field: ‘calls’
[10:26:13.903]   - Field: ‘globals’
[10:26:13.904]   - Field: ‘stdout’
[10:26:13.904]   - Field: ‘earlySignal’
[10:26:13.904]   - Field: ‘lazy’
[10:26:13.904]   - Field: ‘state’
[10:26:13.904] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:13.904] - Launch lazy future ...
[10:26:13.904] Packages needed by the future expression (n = 0): <none>
[10:26:13.905] Packages needed by future strategies (n = 0): <none>
[10:26:13.905] {
[10:26:13.905]     {
[10:26:13.905]         {
[10:26:13.905]             ...future.startTime <- base::Sys.time()
[10:26:13.905]             {
[10:26:13.905]                 {
[10:26:13.905]                   {
[10:26:13.905]                     {
[10:26:13.905]                       base::local({
[10:26:13.905]                         has_future <- base::requireNamespace("future", 
[10:26:13.905]                           quietly = TRUE)
[10:26:13.905]                         if (has_future) {
[10:26:13.905]                           ns <- base::getNamespace("future")
[10:26:13.905]                           version <- ns[[".package"]][["version"]]
[10:26:13.905]                           if (is.null(version)) 
[10:26:13.905]                             version <- utils::packageVersion("future")
[10:26:13.905]                         }
[10:26:13.905]                         else {
[10:26:13.905]                           version <- NULL
[10:26:13.905]                         }
[10:26:13.905]                         if (!has_future || version < "1.8.0") {
[10:26:13.905]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:13.905]                             "", base::R.version$version.string), 
[10:26:13.905]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:13.905]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:13.905]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:13.905]                               "release", "version")], collapse = " "), 
[10:26:13.905]                             hostname = base::Sys.info()[["nodename"]])
[10:26:13.905]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:13.905]                             info)
[10:26:13.905]                           info <- base::paste(info, collapse = "; ")
[10:26:13.905]                           if (!has_future) {
[10:26:13.905]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:13.905]                               info)
[10:26:13.905]                           }
[10:26:13.905]                           else {
[10:26:13.905]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:13.905]                               info, version)
[10:26:13.905]                           }
[10:26:13.905]                           base::stop(msg)
[10:26:13.905]                         }
[10:26:13.905]                       })
[10:26:13.905]                     }
[10:26:13.905]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:13.905]                     base::options(mc.cores = 1L)
[10:26:13.905]                   }
[10:26:13.905]                   options(future.plan = NULL)
[10:26:13.905]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:13.905]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:13.905]                 }
[10:26:13.905]                 ...future.workdir <- getwd()
[10:26:13.905]             }
[10:26:13.905]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:13.905]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:13.905]         }
[10:26:13.905]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:13.905]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:13.905]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:13.905]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:13.905]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:13.905]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:13.905]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:13.905]             base::names(...future.oldOptions))
[10:26:13.905]     }
[10:26:13.905]     if (FALSE) {
[10:26:13.905]     }
[10:26:13.905]     else {
[10:26:13.905]         if (TRUE) {
[10:26:13.905]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:13.905]                 open = "w")
[10:26:13.905]         }
[10:26:13.905]         else {
[10:26:13.905]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:13.905]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:13.905]         }
[10:26:13.905]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:13.905]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:13.905]             base::sink(type = "output", split = FALSE)
[10:26:13.905]             base::close(...future.stdout)
[10:26:13.905]         }, add = TRUE)
[10:26:13.905]     }
[10:26:13.905]     ...future.frame <- base::sys.nframe()
[10:26:13.905]     ...future.conditions <- base::list()
[10:26:13.905]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:13.905]     if (FALSE) {
[10:26:13.905]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:13.905]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:13.905]     }
[10:26:13.905]     ...future.result <- base::tryCatch({
[10:26:13.905]         base::withCallingHandlers({
[10:26:13.905]             ...future.value <- base::withVisible(base::local({
[10:26:13.905]                 ...future.makeSendCondition <- base::local({
[10:26:13.905]                   sendCondition <- NULL
[10:26:13.905]                   function(frame = 1L) {
[10:26:13.905]                     if (is.function(sendCondition)) 
[10:26:13.905]                       return(sendCondition)
[10:26:13.905]                     ns <- getNamespace("parallel")
[10:26:13.905]                     if (exists("sendData", mode = "function", 
[10:26:13.905]                       envir = ns)) {
[10:26:13.905]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:13.905]                         envir = ns)
[10:26:13.905]                       envir <- sys.frame(frame)
[10:26:13.905]                       master <- NULL
[10:26:13.905]                       while (!identical(envir, .GlobalEnv) && 
[10:26:13.905]                         !identical(envir, emptyenv())) {
[10:26:13.905]                         if (exists("master", mode = "list", envir = envir, 
[10:26:13.905]                           inherits = FALSE)) {
[10:26:13.905]                           master <- get("master", mode = "list", 
[10:26:13.905]                             envir = envir, inherits = FALSE)
[10:26:13.905]                           if (inherits(master, c("SOCKnode", 
[10:26:13.905]                             "SOCK0node"))) {
[10:26:13.905]                             sendCondition <<- function(cond) {
[10:26:13.905]                               data <- list(type = "VALUE", value = cond, 
[10:26:13.905]                                 success = TRUE)
[10:26:13.905]                               parallel_sendData(master, data)
[10:26:13.905]                             }
[10:26:13.905]                             return(sendCondition)
[10:26:13.905]                           }
[10:26:13.905]                         }
[10:26:13.905]                         frame <- frame + 1L
[10:26:13.905]                         envir <- sys.frame(frame)
[10:26:13.905]                       }
[10:26:13.905]                     }
[10:26:13.905]                     sendCondition <<- function(cond) NULL
[10:26:13.905]                   }
[10:26:13.905]                 })
[10:26:13.905]                 withCallingHandlers({
[10:26:13.905]                   {
[10:26:13.905]                     b <- a
[10:26:13.905]                     a <- 2
[10:26:13.905]                     a * b
[10:26:13.905]                   }
[10:26:13.905]                 }, immediateCondition = function(cond) {
[10:26:13.905]                   sendCondition <- ...future.makeSendCondition()
[10:26:13.905]                   sendCondition(cond)
[10:26:13.905]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:13.905]                   {
[10:26:13.905]                     inherits <- base::inherits
[10:26:13.905]                     invokeRestart <- base::invokeRestart
[10:26:13.905]                     is.null <- base::is.null
[10:26:13.905]                     muffled <- FALSE
[10:26:13.905]                     if (inherits(cond, "message")) {
[10:26:13.905]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:13.905]                       if (muffled) 
[10:26:13.905]                         invokeRestart("muffleMessage")
[10:26:13.905]                     }
[10:26:13.905]                     else if (inherits(cond, "warning")) {
[10:26:13.905]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:13.905]                       if (muffled) 
[10:26:13.905]                         invokeRestart("muffleWarning")
[10:26:13.905]                     }
[10:26:13.905]                     else if (inherits(cond, "condition")) {
[10:26:13.905]                       if (!is.null(pattern)) {
[10:26:13.905]                         computeRestarts <- base::computeRestarts
[10:26:13.905]                         grepl <- base::grepl
[10:26:13.905]                         restarts <- computeRestarts(cond)
[10:26:13.905]                         for (restart in restarts) {
[10:26:13.905]                           name <- restart$name
[10:26:13.905]                           if (is.null(name)) 
[10:26:13.905]                             next
[10:26:13.905]                           if (!grepl(pattern, name)) 
[10:26:13.905]                             next
[10:26:13.905]                           invokeRestart(restart)
[10:26:13.905]                           muffled <- TRUE
[10:26:13.905]                           break
[10:26:13.905]                         }
[10:26:13.905]                       }
[10:26:13.905]                     }
[10:26:13.905]                     invisible(muffled)
[10:26:13.905]                   }
[10:26:13.905]                   muffleCondition(cond)
[10:26:13.905]                 })
[10:26:13.905]             }))
[10:26:13.905]             future::FutureResult(value = ...future.value$value, 
[10:26:13.905]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:13.905]                   ...future.rng), globalenv = if (FALSE) 
[10:26:13.905]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:13.905]                     ...future.globalenv.names))
[10:26:13.905]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:13.905]         }, condition = base::local({
[10:26:13.905]             c <- base::c
[10:26:13.905]             inherits <- base::inherits
[10:26:13.905]             invokeRestart <- base::invokeRestart
[10:26:13.905]             length <- base::length
[10:26:13.905]             list <- base::list
[10:26:13.905]             seq.int <- base::seq.int
[10:26:13.905]             signalCondition <- base::signalCondition
[10:26:13.905]             sys.calls <- base::sys.calls
[10:26:13.905]             `[[` <- base::`[[`
[10:26:13.905]             `+` <- base::`+`
[10:26:13.905]             `<<-` <- base::`<<-`
[10:26:13.905]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:13.905]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:13.905]                   3L)]
[10:26:13.905]             }
[10:26:13.905]             function(cond) {
[10:26:13.905]                 is_error <- inherits(cond, "error")
[10:26:13.905]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:13.905]                   NULL)
[10:26:13.905]                 if (is_error) {
[10:26:13.905]                   sessionInformation <- function() {
[10:26:13.905]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:13.905]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:13.905]                       search = base::search(), system = base::Sys.info())
[10:26:13.905]                   }
[10:26:13.905]                   ...future.conditions[[length(...future.conditions) + 
[10:26:13.905]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:13.905]                     cond$call), session = sessionInformation(), 
[10:26:13.905]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:13.905]                   signalCondition(cond)
[10:26:13.905]                 }
[10:26:13.905]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:13.905]                 "immediateCondition"))) {
[10:26:13.905]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:13.905]                   ...future.conditions[[length(...future.conditions) + 
[10:26:13.905]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:13.905]                   if (TRUE && !signal) {
[10:26:13.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:13.905]                     {
[10:26:13.905]                       inherits <- base::inherits
[10:26:13.905]                       invokeRestart <- base::invokeRestart
[10:26:13.905]                       is.null <- base::is.null
[10:26:13.905]                       muffled <- FALSE
[10:26:13.905]                       if (inherits(cond, "message")) {
[10:26:13.905]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:13.905]                         if (muffled) 
[10:26:13.905]                           invokeRestart("muffleMessage")
[10:26:13.905]                       }
[10:26:13.905]                       else if (inherits(cond, "warning")) {
[10:26:13.905]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:13.905]                         if (muffled) 
[10:26:13.905]                           invokeRestart("muffleWarning")
[10:26:13.905]                       }
[10:26:13.905]                       else if (inherits(cond, "condition")) {
[10:26:13.905]                         if (!is.null(pattern)) {
[10:26:13.905]                           computeRestarts <- base::computeRestarts
[10:26:13.905]                           grepl <- base::grepl
[10:26:13.905]                           restarts <- computeRestarts(cond)
[10:26:13.905]                           for (restart in restarts) {
[10:26:13.905]                             name <- restart$name
[10:26:13.905]                             if (is.null(name)) 
[10:26:13.905]                               next
[10:26:13.905]                             if (!grepl(pattern, name)) 
[10:26:13.905]                               next
[10:26:13.905]                             invokeRestart(restart)
[10:26:13.905]                             muffled <- TRUE
[10:26:13.905]                             break
[10:26:13.905]                           }
[10:26:13.905]                         }
[10:26:13.905]                       }
[10:26:13.905]                       invisible(muffled)
[10:26:13.905]                     }
[10:26:13.905]                     muffleCondition(cond, pattern = "^muffle")
[10:26:13.905]                   }
[10:26:13.905]                 }
[10:26:13.905]                 else {
[10:26:13.905]                   if (TRUE) {
[10:26:13.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:13.905]                     {
[10:26:13.905]                       inherits <- base::inherits
[10:26:13.905]                       invokeRestart <- base::invokeRestart
[10:26:13.905]                       is.null <- base::is.null
[10:26:13.905]                       muffled <- FALSE
[10:26:13.905]                       if (inherits(cond, "message")) {
[10:26:13.905]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:13.905]                         if (muffled) 
[10:26:13.905]                           invokeRestart("muffleMessage")
[10:26:13.905]                       }
[10:26:13.905]                       else if (inherits(cond, "warning")) {
[10:26:13.905]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:13.905]                         if (muffled) 
[10:26:13.905]                           invokeRestart("muffleWarning")
[10:26:13.905]                       }
[10:26:13.905]                       else if (inherits(cond, "condition")) {
[10:26:13.905]                         if (!is.null(pattern)) {
[10:26:13.905]                           computeRestarts <- base::computeRestarts
[10:26:13.905]                           grepl <- base::grepl
[10:26:13.905]                           restarts <- computeRestarts(cond)
[10:26:13.905]                           for (restart in restarts) {
[10:26:13.905]                             name <- restart$name
[10:26:13.905]                             if (is.null(name)) 
[10:26:13.905]                               next
[10:26:13.905]                             if (!grepl(pattern, name)) 
[10:26:13.905]                               next
[10:26:13.905]                             invokeRestart(restart)
[10:26:13.905]                             muffled <- TRUE
[10:26:13.905]                             break
[10:26:13.905]                           }
[10:26:13.905]                         }
[10:26:13.905]                       }
[10:26:13.905]                       invisible(muffled)
[10:26:13.905]                     }
[10:26:13.905]                     muffleCondition(cond, pattern = "^muffle")
[10:26:13.905]                   }
[10:26:13.905]                 }
[10:26:13.905]             }
[10:26:13.905]         }))
[10:26:13.905]     }, error = function(ex) {
[10:26:13.905]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:13.905]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:13.905]                 ...future.rng), started = ...future.startTime, 
[10:26:13.905]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:13.905]             version = "1.8"), class = "FutureResult")
[10:26:13.905]     }, finally = {
[10:26:13.905]         if (!identical(...future.workdir, getwd())) 
[10:26:13.905]             setwd(...future.workdir)
[10:26:13.905]         {
[10:26:13.905]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:13.905]                 ...future.oldOptions$nwarnings <- NULL
[10:26:13.905]             }
[10:26:13.905]             base::options(...future.oldOptions)
[10:26:13.905]             if (.Platform$OS.type == "windows") {
[10:26:13.905]                 old_names <- names(...future.oldEnvVars)
[10:26:13.905]                 envs <- base::Sys.getenv()
[10:26:13.905]                 names <- names(envs)
[10:26:13.905]                 common <- intersect(names, old_names)
[10:26:13.905]                 added <- setdiff(names, old_names)
[10:26:13.905]                 removed <- setdiff(old_names, names)
[10:26:13.905]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:13.905]                   envs[common]]
[10:26:13.905]                 NAMES <- toupper(changed)
[10:26:13.905]                 args <- list()
[10:26:13.905]                 for (kk in seq_along(NAMES)) {
[10:26:13.905]                   name <- changed[[kk]]
[10:26:13.905]                   NAME <- NAMES[[kk]]
[10:26:13.905]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.905]                     next
[10:26:13.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:13.905]                 }
[10:26:13.905]                 NAMES <- toupper(added)
[10:26:13.905]                 for (kk in seq_along(NAMES)) {
[10:26:13.905]                   name <- added[[kk]]
[10:26:13.905]                   NAME <- NAMES[[kk]]
[10:26:13.905]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.905]                     next
[10:26:13.905]                   args[[name]] <- ""
[10:26:13.905]                 }
[10:26:13.905]                 NAMES <- toupper(removed)
[10:26:13.905]                 for (kk in seq_along(NAMES)) {
[10:26:13.905]                   name <- removed[[kk]]
[10:26:13.905]                   NAME <- NAMES[[kk]]
[10:26:13.905]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.905]                     next
[10:26:13.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:13.905]                 }
[10:26:13.905]                 if (length(args) > 0) 
[10:26:13.905]                   base::do.call(base::Sys.setenv, args = args)
[10:26:13.905]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:13.905]             }
[10:26:13.905]             else {
[10:26:13.905]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:13.905]             }
[10:26:13.905]             {
[10:26:13.905]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:13.905]                   0L) {
[10:26:13.905]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:13.905]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:13.905]                   base::options(opts)
[10:26:13.905]                 }
[10:26:13.905]                 {
[10:26:13.905]                   {
[10:26:13.905]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:13.905]                     NULL
[10:26:13.905]                   }
[10:26:13.905]                   options(future.plan = NULL)
[10:26:13.905]                   if (is.na(NA_character_)) 
[10:26:13.905]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:13.905]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:13.905]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:13.905]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:13.905]                     envir = parent.frame()) 
[10:26:13.905]                   {
[10:26:13.905]                     if (is.function(workers)) 
[10:26:13.905]                       workers <- workers()
[10:26:13.905]                     workers <- structure(as.integer(workers), 
[10:26:13.905]                       class = class(workers))
[10:26:13.905]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:13.905]                       workers >= 1)
[10:26:13.905]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:13.905]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:13.905]                     }
[10:26:13.905]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:13.905]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:13.905]                       envir = envir)
[10:26:13.905]                     if (!future$lazy) 
[10:26:13.905]                       future <- run(future)
[10:26:13.905]                     invisible(future)
[10:26:13.905]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:13.905]                 }
[10:26:13.905]             }
[10:26:13.905]         }
[10:26:13.905]     })
[10:26:13.905]     if (TRUE) {
[10:26:13.905]         base::sink(type = "output", split = FALSE)
[10:26:13.905]         if (TRUE) {
[10:26:13.905]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:13.905]         }
[10:26:13.905]         else {
[10:26:13.905]             ...future.result["stdout"] <- base::list(NULL)
[10:26:13.905]         }
[10:26:13.905]         base::close(...future.stdout)
[10:26:13.905]         ...future.stdout <- NULL
[10:26:13.905]     }
[10:26:13.905]     ...future.result$conditions <- ...future.conditions
[10:26:13.905]     ...future.result$finished <- base::Sys.time()
[10:26:13.905]     ...future.result
[10:26:13.905] }
[10:26:13.910] MultisessionFuture started
[10:26:13.911] - Launch lazy future ... done
[10:26:13.911] run() for ‘MultisessionFuture’ ... done
[10:26:13.911] result() for ClusterFuture ...
[10:26:13.911] receiveMessageFromWorker() for ClusterFuture ...
[10:26:13.911] - Validating connection of MultisessionFuture
[10:26:13.959] - received message: FutureResult
[10:26:13.959] - Received FutureResult
[10:26:13.959] - Erased future from FutureRegistry
[10:26:13.959] result() for ClusterFuture ...
[10:26:13.959] - result already collected: FutureResult
[10:26:13.959] result() for ClusterFuture ... done
[10:26:13.959] signalConditions() ...
[10:26:13.959]  - include = ‘immediateCondition’
[10:26:13.959]  - exclude = 
[10:26:13.960]  - resignal = FALSE
[10:26:13.960]  - Number of conditions: 1
[10:26:13.960] signalConditions() ... done
[10:26:13.960] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:13.960] result() for ClusterFuture ... done
[10:26:13.960] result() for ClusterFuture ...
[10:26:13.960] - result already collected: FutureResult
[10:26:13.960] result() for ClusterFuture ... done
[10:26:13.960] signalConditions() ...
[10:26:13.960]  - include = ‘immediateCondition’
[10:26:13.960]  - exclude = 
[10:26:13.960]  - resignal = FALSE
[10:26:13.961]  - Number of conditions: 1
[10:26:13.961] signalConditions() ... done
[10:26:13.961] Future state: ‘finished’
[10:26:13.961] result() for ClusterFuture ...
[10:26:13.961] - result already collected: FutureResult
[10:26:13.961] result() for ClusterFuture ... done
[10:26:13.961] signalConditions() ...
[10:26:13.961]  - include = ‘condition’
[10:26:13.961]  - exclude = ‘immediateCondition’
[10:26:13.961]  - resignal = TRUE
[10:26:13.962]  - Number of conditions: 1
[10:26:13.962]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:26:13.962] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3e863ac79bce" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 10:26:13"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:13.975] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:13.976] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:13.977] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:13.977] Searching for globals ... DONE
[10:26:13.977] Resolving globals: TRUE
[10:26:13.977] Resolving any globals that are futures ...
[10:26:13.977] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:13.977] Resolving any globals that are futures ... DONE
[10:26:13.978] Resolving futures part of globals (recursively) ...
[10:26:13.978] resolve() on list ...
[10:26:13.978]  recursive: 99
[10:26:13.978]  length: 1
[10:26:13.978]  elements: ‘ii’
[10:26:13.978]  length: 0 (resolved future 1)
[10:26:13.979] resolve() on list ... DONE
[10:26:13.979] - globals: [1] ‘ii’
[10:26:13.979] Resolving futures part of globals (recursively) ... DONE
[10:26:13.979] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:13.979] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:13.979] - globals: [1] ‘ii’
[10:26:13.979] 
[10:26:13.980] getGlobalsAndPackages() ... DONE
[10:26:13.980] run() for ‘Future’ ...
[10:26:13.980] - state: ‘created’
[10:26:13.980] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:13.994] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:13.994] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:13.994]   - Field: ‘node’
[10:26:13.994]   - Field: ‘label’
[10:26:13.994]   - Field: ‘local’
[10:26:13.994]   - Field: ‘owner’
[10:26:13.994]   - Field: ‘envir’
[10:26:13.994]   - Field: ‘workers’
[10:26:13.995]   - Field: ‘packages’
[10:26:13.995]   - Field: ‘gc’
[10:26:13.995]   - Field: ‘conditions’
[10:26:13.995]   - Field: ‘persistent’
[10:26:13.995]   - Field: ‘expr’
[10:26:13.995]   - Field: ‘uuid’
[10:26:13.995]   - Field: ‘seed’
[10:26:13.995]   - Field: ‘version’
[10:26:13.995]   - Field: ‘result’
[10:26:13.995]   - Field: ‘asynchronous’
[10:26:13.995]   - Field: ‘calls’
[10:26:13.995]   - Field: ‘globals’
[10:26:13.996]   - Field: ‘stdout’
[10:26:13.996]   - Field: ‘earlySignal’
[10:26:13.996]   - Field: ‘lazy’
[10:26:13.996]   - Field: ‘state’
[10:26:13.996] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:13.996] - Launch lazy future ...
[10:26:13.996] Packages needed by the future expression (n = 0): <none>
[10:26:13.996] Packages needed by future strategies (n = 0): <none>
[10:26:13.997] {
[10:26:13.997]     {
[10:26:13.997]         {
[10:26:13.997]             ...future.startTime <- base::Sys.time()
[10:26:13.997]             {
[10:26:13.997]                 {
[10:26:13.997]                   {
[10:26:13.997]                     {
[10:26:13.997]                       base::local({
[10:26:13.997]                         has_future <- base::requireNamespace("future", 
[10:26:13.997]                           quietly = TRUE)
[10:26:13.997]                         if (has_future) {
[10:26:13.997]                           ns <- base::getNamespace("future")
[10:26:13.997]                           version <- ns[[".package"]][["version"]]
[10:26:13.997]                           if (is.null(version)) 
[10:26:13.997]                             version <- utils::packageVersion("future")
[10:26:13.997]                         }
[10:26:13.997]                         else {
[10:26:13.997]                           version <- NULL
[10:26:13.997]                         }
[10:26:13.997]                         if (!has_future || version < "1.8.0") {
[10:26:13.997]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:13.997]                             "", base::R.version$version.string), 
[10:26:13.997]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:13.997]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:13.997]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:13.997]                               "release", "version")], collapse = " "), 
[10:26:13.997]                             hostname = base::Sys.info()[["nodename"]])
[10:26:13.997]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:13.997]                             info)
[10:26:13.997]                           info <- base::paste(info, collapse = "; ")
[10:26:13.997]                           if (!has_future) {
[10:26:13.997]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:13.997]                               info)
[10:26:13.997]                           }
[10:26:13.997]                           else {
[10:26:13.997]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:13.997]                               info, version)
[10:26:13.997]                           }
[10:26:13.997]                           base::stop(msg)
[10:26:13.997]                         }
[10:26:13.997]                       })
[10:26:13.997]                     }
[10:26:13.997]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:13.997]                     base::options(mc.cores = 1L)
[10:26:13.997]                   }
[10:26:13.997]                   options(future.plan = NULL)
[10:26:13.997]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:13.997]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:13.997]                 }
[10:26:13.997]                 ...future.workdir <- getwd()
[10:26:13.997]             }
[10:26:13.997]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:13.997]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:13.997]         }
[10:26:13.997]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:13.997]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:13.997]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:13.997]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:13.997]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:13.997]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:13.997]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:13.997]             base::names(...future.oldOptions))
[10:26:13.997]     }
[10:26:13.997]     if (FALSE) {
[10:26:13.997]     }
[10:26:13.997]     else {
[10:26:13.997]         if (TRUE) {
[10:26:13.997]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:13.997]                 open = "w")
[10:26:13.997]         }
[10:26:13.997]         else {
[10:26:13.997]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:13.997]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:13.997]         }
[10:26:13.997]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:13.997]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:13.997]             base::sink(type = "output", split = FALSE)
[10:26:13.997]             base::close(...future.stdout)
[10:26:13.997]         }, add = TRUE)
[10:26:13.997]     }
[10:26:13.997]     ...future.frame <- base::sys.nframe()
[10:26:13.997]     ...future.conditions <- base::list()
[10:26:13.997]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:13.997]     if (FALSE) {
[10:26:13.997]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:13.997]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:13.997]     }
[10:26:13.997]     ...future.result <- base::tryCatch({
[10:26:13.997]         base::withCallingHandlers({
[10:26:13.997]             ...future.value <- base::withVisible(base::local({
[10:26:13.997]                 ...future.makeSendCondition <- base::local({
[10:26:13.997]                   sendCondition <- NULL
[10:26:13.997]                   function(frame = 1L) {
[10:26:13.997]                     if (is.function(sendCondition)) 
[10:26:13.997]                       return(sendCondition)
[10:26:13.997]                     ns <- getNamespace("parallel")
[10:26:13.997]                     if (exists("sendData", mode = "function", 
[10:26:13.997]                       envir = ns)) {
[10:26:13.997]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:13.997]                         envir = ns)
[10:26:13.997]                       envir <- sys.frame(frame)
[10:26:13.997]                       master <- NULL
[10:26:13.997]                       while (!identical(envir, .GlobalEnv) && 
[10:26:13.997]                         !identical(envir, emptyenv())) {
[10:26:13.997]                         if (exists("master", mode = "list", envir = envir, 
[10:26:13.997]                           inherits = FALSE)) {
[10:26:13.997]                           master <- get("master", mode = "list", 
[10:26:13.997]                             envir = envir, inherits = FALSE)
[10:26:13.997]                           if (inherits(master, c("SOCKnode", 
[10:26:13.997]                             "SOCK0node"))) {
[10:26:13.997]                             sendCondition <<- function(cond) {
[10:26:13.997]                               data <- list(type = "VALUE", value = cond, 
[10:26:13.997]                                 success = TRUE)
[10:26:13.997]                               parallel_sendData(master, data)
[10:26:13.997]                             }
[10:26:13.997]                             return(sendCondition)
[10:26:13.997]                           }
[10:26:13.997]                         }
[10:26:13.997]                         frame <- frame + 1L
[10:26:13.997]                         envir <- sys.frame(frame)
[10:26:13.997]                       }
[10:26:13.997]                     }
[10:26:13.997]                     sendCondition <<- function(cond) NULL
[10:26:13.997]                   }
[10:26:13.997]                 })
[10:26:13.997]                 withCallingHandlers({
[10:26:13.997]                   {
[10:26:13.997]                     b <- a * ii
[10:26:13.997]                     a <- 0
[10:26:13.997]                     b
[10:26:13.997]                   }
[10:26:13.997]                 }, immediateCondition = function(cond) {
[10:26:13.997]                   sendCondition <- ...future.makeSendCondition()
[10:26:13.997]                   sendCondition(cond)
[10:26:13.997]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:13.997]                   {
[10:26:13.997]                     inherits <- base::inherits
[10:26:13.997]                     invokeRestart <- base::invokeRestart
[10:26:13.997]                     is.null <- base::is.null
[10:26:13.997]                     muffled <- FALSE
[10:26:13.997]                     if (inherits(cond, "message")) {
[10:26:13.997]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:13.997]                       if (muffled) 
[10:26:13.997]                         invokeRestart("muffleMessage")
[10:26:13.997]                     }
[10:26:13.997]                     else if (inherits(cond, "warning")) {
[10:26:13.997]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:13.997]                       if (muffled) 
[10:26:13.997]                         invokeRestart("muffleWarning")
[10:26:13.997]                     }
[10:26:13.997]                     else if (inherits(cond, "condition")) {
[10:26:13.997]                       if (!is.null(pattern)) {
[10:26:13.997]                         computeRestarts <- base::computeRestarts
[10:26:13.997]                         grepl <- base::grepl
[10:26:13.997]                         restarts <- computeRestarts(cond)
[10:26:13.997]                         for (restart in restarts) {
[10:26:13.997]                           name <- restart$name
[10:26:13.997]                           if (is.null(name)) 
[10:26:13.997]                             next
[10:26:13.997]                           if (!grepl(pattern, name)) 
[10:26:13.997]                             next
[10:26:13.997]                           invokeRestart(restart)
[10:26:13.997]                           muffled <- TRUE
[10:26:13.997]                           break
[10:26:13.997]                         }
[10:26:13.997]                       }
[10:26:13.997]                     }
[10:26:13.997]                     invisible(muffled)
[10:26:13.997]                   }
[10:26:13.997]                   muffleCondition(cond)
[10:26:13.997]                 })
[10:26:13.997]             }))
[10:26:13.997]             future::FutureResult(value = ...future.value$value, 
[10:26:13.997]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:13.997]                   ...future.rng), globalenv = if (FALSE) 
[10:26:13.997]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:13.997]                     ...future.globalenv.names))
[10:26:13.997]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:13.997]         }, condition = base::local({
[10:26:13.997]             c <- base::c
[10:26:13.997]             inherits <- base::inherits
[10:26:13.997]             invokeRestart <- base::invokeRestart
[10:26:13.997]             length <- base::length
[10:26:13.997]             list <- base::list
[10:26:13.997]             seq.int <- base::seq.int
[10:26:13.997]             signalCondition <- base::signalCondition
[10:26:13.997]             sys.calls <- base::sys.calls
[10:26:13.997]             `[[` <- base::`[[`
[10:26:13.997]             `+` <- base::`+`
[10:26:13.997]             `<<-` <- base::`<<-`
[10:26:13.997]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:13.997]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:13.997]                   3L)]
[10:26:13.997]             }
[10:26:13.997]             function(cond) {
[10:26:13.997]                 is_error <- inherits(cond, "error")
[10:26:13.997]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:13.997]                   NULL)
[10:26:13.997]                 if (is_error) {
[10:26:13.997]                   sessionInformation <- function() {
[10:26:13.997]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:13.997]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:13.997]                       search = base::search(), system = base::Sys.info())
[10:26:13.997]                   }
[10:26:13.997]                   ...future.conditions[[length(...future.conditions) + 
[10:26:13.997]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:13.997]                     cond$call), session = sessionInformation(), 
[10:26:13.997]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:13.997]                   signalCondition(cond)
[10:26:13.997]                 }
[10:26:13.997]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:13.997]                 "immediateCondition"))) {
[10:26:13.997]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:13.997]                   ...future.conditions[[length(...future.conditions) + 
[10:26:13.997]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:13.997]                   if (TRUE && !signal) {
[10:26:13.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:13.997]                     {
[10:26:13.997]                       inherits <- base::inherits
[10:26:13.997]                       invokeRestart <- base::invokeRestart
[10:26:13.997]                       is.null <- base::is.null
[10:26:13.997]                       muffled <- FALSE
[10:26:13.997]                       if (inherits(cond, "message")) {
[10:26:13.997]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:13.997]                         if (muffled) 
[10:26:13.997]                           invokeRestart("muffleMessage")
[10:26:13.997]                       }
[10:26:13.997]                       else if (inherits(cond, "warning")) {
[10:26:13.997]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:13.997]                         if (muffled) 
[10:26:13.997]                           invokeRestart("muffleWarning")
[10:26:13.997]                       }
[10:26:13.997]                       else if (inherits(cond, "condition")) {
[10:26:13.997]                         if (!is.null(pattern)) {
[10:26:13.997]                           computeRestarts <- base::computeRestarts
[10:26:13.997]                           grepl <- base::grepl
[10:26:13.997]                           restarts <- computeRestarts(cond)
[10:26:13.997]                           for (restart in restarts) {
[10:26:13.997]                             name <- restart$name
[10:26:13.997]                             if (is.null(name)) 
[10:26:13.997]                               next
[10:26:13.997]                             if (!grepl(pattern, name)) 
[10:26:13.997]                               next
[10:26:13.997]                             invokeRestart(restart)
[10:26:13.997]                             muffled <- TRUE
[10:26:13.997]                             break
[10:26:13.997]                           }
[10:26:13.997]                         }
[10:26:13.997]                       }
[10:26:13.997]                       invisible(muffled)
[10:26:13.997]                     }
[10:26:13.997]                     muffleCondition(cond, pattern = "^muffle")
[10:26:13.997]                   }
[10:26:13.997]                 }
[10:26:13.997]                 else {
[10:26:13.997]                   if (TRUE) {
[10:26:13.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:13.997]                     {
[10:26:13.997]                       inherits <- base::inherits
[10:26:13.997]                       invokeRestart <- base::invokeRestart
[10:26:13.997]                       is.null <- base::is.null
[10:26:13.997]                       muffled <- FALSE
[10:26:13.997]                       if (inherits(cond, "message")) {
[10:26:13.997]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:13.997]                         if (muffled) 
[10:26:13.997]                           invokeRestart("muffleMessage")
[10:26:13.997]                       }
[10:26:13.997]                       else if (inherits(cond, "warning")) {
[10:26:13.997]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:13.997]                         if (muffled) 
[10:26:13.997]                           invokeRestart("muffleWarning")
[10:26:13.997]                       }
[10:26:13.997]                       else if (inherits(cond, "condition")) {
[10:26:13.997]                         if (!is.null(pattern)) {
[10:26:13.997]                           computeRestarts <- base::computeRestarts
[10:26:13.997]                           grepl <- base::grepl
[10:26:13.997]                           restarts <- computeRestarts(cond)
[10:26:13.997]                           for (restart in restarts) {
[10:26:13.997]                             name <- restart$name
[10:26:13.997]                             if (is.null(name)) 
[10:26:13.997]                               next
[10:26:13.997]                             if (!grepl(pattern, name)) 
[10:26:13.997]                               next
[10:26:13.997]                             invokeRestart(restart)
[10:26:13.997]                             muffled <- TRUE
[10:26:13.997]                             break
[10:26:13.997]                           }
[10:26:13.997]                         }
[10:26:13.997]                       }
[10:26:13.997]                       invisible(muffled)
[10:26:13.997]                     }
[10:26:13.997]                     muffleCondition(cond, pattern = "^muffle")
[10:26:13.997]                   }
[10:26:13.997]                 }
[10:26:13.997]             }
[10:26:13.997]         }))
[10:26:13.997]     }, error = function(ex) {
[10:26:13.997]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:13.997]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:13.997]                 ...future.rng), started = ...future.startTime, 
[10:26:13.997]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:13.997]             version = "1.8"), class = "FutureResult")
[10:26:13.997]     }, finally = {
[10:26:13.997]         if (!identical(...future.workdir, getwd())) 
[10:26:13.997]             setwd(...future.workdir)
[10:26:13.997]         {
[10:26:13.997]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:13.997]                 ...future.oldOptions$nwarnings <- NULL
[10:26:13.997]             }
[10:26:13.997]             base::options(...future.oldOptions)
[10:26:13.997]             if (.Platform$OS.type == "windows") {
[10:26:13.997]                 old_names <- names(...future.oldEnvVars)
[10:26:13.997]                 envs <- base::Sys.getenv()
[10:26:13.997]                 names <- names(envs)
[10:26:13.997]                 common <- intersect(names, old_names)
[10:26:13.997]                 added <- setdiff(names, old_names)
[10:26:13.997]                 removed <- setdiff(old_names, names)
[10:26:13.997]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:13.997]                   envs[common]]
[10:26:13.997]                 NAMES <- toupper(changed)
[10:26:13.997]                 args <- list()
[10:26:13.997]                 for (kk in seq_along(NAMES)) {
[10:26:13.997]                   name <- changed[[kk]]
[10:26:13.997]                   NAME <- NAMES[[kk]]
[10:26:13.997]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.997]                     next
[10:26:13.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:13.997]                 }
[10:26:13.997]                 NAMES <- toupper(added)
[10:26:13.997]                 for (kk in seq_along(NAMES)) {
[10:26:13.997]                   name <- added[[kk]]
[10:26:13.997]                   NAME <- NAMES[[kk]]
[10:26:13.997]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.997]                     next
[10:26:13.997]                   args[[name]] <- ""
[10:26:13.997]                 }
[10:26:13.997]                 NAMES <- toupper(removed)
[10:26:13.997]                 for (kk in seq_along(NAMES)) {
[10:26:13.997]                   name <- removed[[kk]]
[10:26:13.997]                   NAME <- NAMES[[kk]]
[10:26:13.997]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:13.997]                     next
[10:26:13.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:13.997]                 }
[10:26:13.997]                 if (length(args) > 0) 
[10:26:13.997]                   base::do.call(base::Sys.setenv, args = args)
[10:26:13.997]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:13.997]             }
[10:26:13.997]             else {
[10:26:13.997]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:13.997]             }
[10:26:13.997]             {
[10:26:13.997]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:13.997]                   0L) {
[10:26:13.997]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:13.997]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:13.997]                   base::options(opts)
[10:26:13.997]                 }
[10:26:13.997]                 {
[10:26:13.997]                   {
[10:26:13.997]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:13.997]                     NULL
[10:26:13.997]                   }
[10:26:13.997]                   options(future.plan = NULL)
[10:26:13.997]                   if (is.na(NA_character_)) 
[10:26:13.997]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:13.997]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:13.997]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:13.997]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:13.997]                     envir = parent.frame()) 
[10:26:13.997]                   {
[10:26:13.997]                     if (is.function(workers)) 
[10:26:13.997]                       workers <- workers()
[10:26:13.997]                     workers <- structure(as.integer(workers), 
[10:26:13.997]                       class = class(workers))
[10:26:13.997]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:13.997]                       workers >= 1)
[10:26:13.997]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:13.997]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:13.997]                     }
[10:26:13.997]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:13.997]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:13.997]                       envir = envir)
[10:26:13.997]                     if (!future$lazy) 
[10:26:13.997]                       future <- run(future)
[10:26:13.997]                     invisible(future)
[10:26:13.997]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:13.997]                 }
[10:26:13.997]             }
[10:26:13.997]         }
[10:26:13.997]     })
[10:26:13.997]     if (TRUE) {
[10:26:13.997]         base::sink(type = "output", split = FALSE)
[10:26:13.997]         if (TRUE) {
[10:26:13.997]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:13.997]         }
[10:26:13.997]         else {
[10:26:13.997]             ...future.result["stdout"] <- base::list(NULL)
[10:26:13.997]         }
[10:26:13.997]         base::close(...future.stdout)
[10:26:13.997]         ...future.stdout <- NULL
[10:26:13.997]     }
[10:26:13.997]     ...future.result$conditions <- ...future.conditions
[10:26:13.997]     ...future.result$finished <- base::Sys.time()
[10:26:13.997]     ...future.result
[10:26:13.997] }
[10:26:13.999] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[10:26:14.000] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[10:26:14.000] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[10:26:14.000] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[10:26:14.001] MultisessionFuture started
[10:26:14.001] - Launch lazy future ... done
[10:26:14.001] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:14.002] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:14.002] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:14.003] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:14.003] Searching for globals ... DONE
[10:26:14.003] Resolving globals: TRUE
[10:26:14.003] Resolving any globals that are futures ...
[10:26:14.003] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:14.004] Resolving any globals that are futures ... DONE
[10:26:14.004] Resolving futures part of globals (recursively) ...
[10:26:14.004] resolve() on list ...
[10:26:14.004]  recursive: 99
[10:26:14.004]  length: 1
[10:26:14.004]  elements: ‘ii’
[10:26:14.004]  length: 0 (resolved future 1)
[10:26:14.005] resolve() on list ... DONE
[10:26:14.005] - globals: [1] ‘ii’
[10:26:14.005] Resolving futures part of globals (recursively) ... DONE
[10:26:14.005] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:14.005] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:14.005] - globals: [1] ‘ii’
[10:26:14.005] 
[10:26:14.006] getGlobalsAndPackages() ... DONE
[10:26:14.006] run() for ‘Future’ ...
[10:26:14.006] - state: ‘created’
[10:26:14.006] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:14.019] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:14.019] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:14.019]   - Field: ‘node’
[10:26:14.019]   - Field: ‘label’
[10:26:14.019]   - Field: ‘local’
[10:26:14.020]   - Field: ‘owner’
[10:26:14.020]   - Field: ‘envir’
[10:26:14.020]   - Field: ‘workers’
[10:26:14.020]   - Field: ‘packages’
[10:26:14.020]   - Field: ‘gc’
[10:26:14.020]   - Field: ‘conditions’
[10:26:14.020]   - Field: ‘persistent’
[10:26:14.020]   - Field: ‘expr’
[10:26:14.020]   - Field: ‘uuid’
[10:26:14.020]   - Field: ‘seed’
[10:26:14.020]   - Field: ‘version’
[10:26:14.021]   - Field: ‘result’
[10:26:14.021]   - Field: ‘asynchronous’
[10:26:14.021]   - Field: ‘calls’
[10:26:14.021]   - Field: ‘globals’
[10:26:14.021]   - Field: ‘stdout’
[10:26:14.021]   - Field: ‘earlySignal’
[10:26:14.021]   - Field: ‘lazy’
[10:26:14.021]   - Field: ‘state’
[10:26:14.021] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:14.021] - Launch lazy future ...
[10:26:14.022] Packages needed by the future expression (n = 0): <none>
[10:26:14.022] Packages needed by future strategies (n = 0): <none>
[10:26:14.022] {
[10:26:14.022]     {
[10:26:14.022]         {
[10:26:14.022]             ...future.startTime <- base::Sys.time()
[10:26:14.022]             {
[10:26:14.022]                 {
[10:26:14.022]                   {
[10:26:14.022]                     {
[10:26:14.022]                       base::local({
[10:26:14.022]                         has_future <- base::requireNamespace("future", 
[10:26:14.022]                           quietly = TRUE)
[10:26:14.022]                         if (has_future) {
[10:26:14.022]                           ns <- base::getNamespace("future")
[10:26:14.022]                           version <- ns[[".package"]][["version"]]
[10:26:14.022]                           if (is.null(version)) 
[10:26:14.022]                             version <- utils::packageVersion("future")
[10:26:14.022]                         }
[10:26:14.022]                         else {
[10:26:14.022]                           version <- NULL
[10:26:14.022]                         }
[10:26:14.022]                         if (!has_future || version < "1.8.0") {
[10:26:14.022]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:14.022]                             "", base::R.version$version.string), 
[10:26:14.022]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:14.022]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:14.022]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:14.022]                               "release", "version")], collapse = " "), 
[10:26:14.022]                             hostname = base::Sys.info()[["nodename"]])
[10:26:14.022]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:14.022]                             info)
[10:26:14.022]                           info <- base::paste(info, collapse = "; ")
[10:26:14.022]                           if (!has_future) {
[10:26:14.022]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:14.022]                               info)
[10:26:14.022]                           }
[10:26:14.022]                           else {
[10:26:14.022]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:14.022]                               info, version)
[10:26:14.022]                           }
[10:26:14.022]                           base::stop(msg)
[10:26:14.022]                         }
[10:26:14.022]                       })
[10:26:14.022]                     }
[10:26:14.022]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:14.022]                     base::options(mc.cores = 1L)
[10:26:14.022]                   }
[10:26:14.022]                   options(future.plan = NULL)
[10:26:14.022]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:14.022]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:14.022]                 }
[10:26:14.022]                 ...future.workdir <- getwd()
[10:26:14.022]             }
[10:26:14.022]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:14.022]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:14.022]         }
[10:26:14.022]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:14.022]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:14.022]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:14.022]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:14.022]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:14.022]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:14.022]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:14.022]             base::names(...future.oldOptions))
[10:26:14.022]     }
[10:26:14.022]     if (FALSE) {
[10:26:14.022]     }
[10:26:14.022]     else {
[10:26:14.022]         if (TRUE) {
[10:26:14.022]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:14.022]                 open = "w")
[10:26:14.022]         }
[10:26:14.022]         else {
[10:26:14.022]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:14.022]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:14.022]         }
[10:26:14.022]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:14.022]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:14.022]             base::sink(type = "output", split = FALSE)
[10:26:14.022]             base::close(...future.stdout)
[10:26:14.022]         }, add = TRUE)
[10:26:14.022]     }
[10:26:14.022]     ...future.frame <- base::sys.nframe()
[10:26:14.022]     ...future.conditions <- base::list()
[10:26:14.022]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:14.022]     if (FALSE) {
[10:26:14.022]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:14.022]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:14.022]     }
[10:26:14.022]     ...future.result <- base::tryCatch({
[10:26:14.022]         base::withCallingHandlers({
[10:26:14.022]             ...future.value <- base::withVisible(base::local({
[10:26:14.022]                 ...future.makeSendCondition <- base::local({
[10:26:14.022]                   sendCondition <- NULL
[10:26:14.022]                   function(frame = 1L) {
[10:26:14.022]                     if (is.function(sendCondition)) 
[10:26:14.022]                       return(sendCondition)
[10:26:14.022]                     ns <- getNamespace("parallel")
[10:26:14.022]                     if (exists("sendData", mode = "function", 
[10:26:14.022]                       envir = ns)) {
[10:26:14.022]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:14.022]                         envir = ns)
[10:26:14.022]                       envir <- sys.frame(frame)
[10:26:14.022]                       master <- NULL
[10:26:14.022]                       while (!identical(envir, .GlobalEnv) && 
[10:26:14.022]                         !identical(envir, emptyenv())) {
[10:26:14.022]                         if (exists("master", mode = "list", envir = envir, 
[10:26:14.022]                           inherits = FALSE)) {
[10:26:14.022]                           master <- get("master", mode = "list", 
[10:26:14.022]                             envir = envir, inherits = FALSE)
[10:26:14.022]                           if (inherits(master, c("SOCKnode", 
[10:26:14.022]                             "SOCK0node"))) {
[10:26:14.022]                             sendCondition <<- function(cond) {
[10:26:14.022]                               data <- list(type = "VALUE", value = cond, 
[10:26:14.022]                                 success = TRUE)
[10:26:14.022]                               parallel_sendData(master, data)
[10:26:14.022]                             }
[10:26:14.022]                             return(sendCondition)
[10:26:14.022]                           }
[10:26:14.022]                         }
[10:26:14.022]                         frame <- frame + 1L
[10:26:14.022]                         envir <- sys.frame(frame)
[10:26:14.022]                       }
[10:26:14.022]                     }
[10:26:14.022]                     sendCondition <<- function(cond) NULL
[10:26:14.022]                   }
[10:26:14.022]                 })
[10:26:14.022]                 withCallingHandlers({
[10:26:14.022]                   {
[10:26:14.022]                     b <- a * ii
[10:26:14.022]                     a <- 0
[10:26:14.022]                     b
[10:26:14.022]                   }
[10:26:14.022]                 }, immediateCondition = function(cond) {
[10:26:14.022]                   sendCondition <- ...future.makeSendCondition()
[10:26:14.022]                   sendCondition(cond)
[10:26:14.022]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.022]                   {
[10:26:14.022]                     inherits <- base::inherits
[10:26:14.022]                     invokeRestart <- base::invokeRestart
[10:26:14.022]                     is.null <- base::is.null
[10:26:14.022]                     muffled <- FALSE
[10:26:14.022]                     if (inherits(cond, "message")) {
[10:26:14.022]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:14.022]                       if (muffled) 
[10:26:14.022]                         invokeRestart("muffleMessage")
[10:26:14.022]                     }
[10:26:14.022]                     else if (inherits(cond, "warning")) {
[10:26:14.022]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:14.022]                       if (muffled) 
[10:26:14.022]                         invokeRestart("muffleWarning")
[10:26:14.022]                     }
[10:26:14.022]                     else if (inherits(cond, "condition")) {
[10:26:14.022]                       if (!is.null(pattern)) {
[10:26:14.022]                         computeRestarts <- base::computeRestarts
[10:26:14.022]                         grepl <- base::grepl
[10:26:14.022]                         restarts <- computeRestarts(cond)
[10:26:14.022]                         for (restart in restarts) {
[10:26:14.022]                           name <- restart$name
[10:26:14.022]                           if (is.null(name)) 
[10:26:14.022]                             next
[10:26:14.022]                           if (!grepl(pattern, name)) 
[10:26:14.022]                             next
[10:26:14.022]                           invokeRestart(restart)
[10:26:14.022]                           muffled <- TRUE
[10:26:14.022]                           break
[10:26:14.022]                         }
[10:26:14.022]                       }
[10:26:14.022]                     }
[10:26:14.022]                     invisible(muffled)
[10:26:14.022]                   }
[10:26:14.022]                   muffleCondition(cond)
[10:26:14.022]                 })
[10:26:14.022]             }))
[10:26:14.022]             future::FutureResult(value = ...future.value$value, 
[10:26:14.022]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:14.022]                   ...future.rng), globalenv = if (FALSE) 
[10:26:14.022]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:14.022]                     ...future.globalenv.names))
[10:26:14.022]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:14.022]         }, condition = base::local({
[10:26:14.022]             c <- base::c
[10:26:14.022]             inherits <- base::inherits
[10:26:14.022]             invokeRestart <- base::invokeRestart
[10:26:14.022]             length <- base::length
[10:26:14.022]             list <- base::list
[10:26:14.022]             seq.int <- base::seq.int
[10:26:14.022]             signalCondition <- base::signalCondition
[10:26:14.022]             sys.calls <- base::sys.calls
[10:26:14.022]             `[[` <- base::`[[`
[10:26:14.022]             `+` <- base::`+`
[10:26:14.022]             `<<-` <- base::`<<-`
[10:26:14.022]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:14.022]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:14.022]                   3L)]
[10:26:14.022]             }
[10:26:14.022]             function(cond) {
[10:26:14.022]                 is_error <- inherits(cond, "error")
[10:26:14.022]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:14.022]                   NULL)
[10:26:14.022]                 if (is_error) {
[10:26:14.022]                   sessionInformation <- function() {
[10:26:14.022]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:14.022]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:14.022]                       search = base::search(), system = base::Sys.info())
[10:26:14.022]                   }
[10:26:14.022]                   ...future.conditions[[length(...future.conditions) + 
[10:26:14.022]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:14.022]                     cond$call), session = sessionInformation(), 
[10:26:14.022]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:14.022]                   signalCondition(cond)
[10:26:14.022]                 }
[10:26:14.022]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:14.022]                 "immediateCondition"))) {
[10:26:14.022]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:14.022]                   ...future.conditions[[length(...future.conditions) + 
[10:26:14.022]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:14.022]                   if (TRUE && !signal) {
[10:26:14.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.022]                     {
[10:26:14.022]                       inherits <- base::inherits
[10:26:14.022]                       invokeRestart <- base::invokeRestart
[10:26:14.022]                       is.null <- base::is.null
[10:26:14.022]                       muffled <- FALSE
[10:26:14.022]                       if (inherits(cond, "message")) {
[10:26:14.022]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:14.022]                         if (muffled) 
[10:26:14.022]                           invokeRestart("muffleMessage")
[10:26:14.022]                       }
[10:26:14.022]                       else if (inherits(cond, "warning")) {
[10:26:14.022]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:14.022]                         if (muffled) 
[10:26:14.022]                           invokeRestart("muffleWarning")
[10:26:14.022]                       }
[10:26:14.022]                       else if (inherits(cond, "condition")) {
[10:26:14.022]                         if (!is.null(pattern)) {
[10:26:14.022]                           computeRestarts <- base::computeRestarts
[10:26:14.022]                           grepl <- base::grepl
[10:26:14.022]                           restarts <- computeRestarts(cond)
[10:26:14.022]                           for (restart in restarts) {
[10:26:14.022]                             name <- restart$name
[10:26:14.022]                             if (is.null(name)) 
[10:26:14.022]                               next
[10:26:14.022]                             if (!grepl(pattern, name)) 
[10:26:14.022]                               next
[10:26:14.022]                             invokeRestart(restart)
[10:26:14.022]                             muffled <- TRUE
[10:26:14.022]                             break
[10:26:14.022]                           }
[10:26:14.022]                         }
[10:26:14.022]                       }
[10:26:14.022]                       invisible(muffled)
[10:26:14.022]                     }
[10:26:14.022]                     muffleCondition(cond, pattern = "^muffle")
[10:26:14.022]                   }
[10:26:14.022]                 }
[10:26:14.022]                 else {
[10:26:14.022]                   if (TRUE) {
[10:26:14.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.022]                     {
[10:26:14.022]                       inherits <- base::inherits
[10:26:14.022]                       invokeRestart <- base::invokeRestart
[10:26:14.022]                       is.null <- base::is.null
[10:26:14.022]                       muffled <- FALSE
[10:26:14.022]                       if (inherits(cond, "message")) {
[10:26:14.022]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:14.022]                         if (muffled) 
[10:26:14.022]                           invokeRestart("muffleMessage")
[10:26:14.022]                       }
[10:26:14.022]                       else if (inherits(cond, "warning")) {
[10:26:14.022]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:14.022]                         if (muffled) 
[10:26:14.022]                           invokeRestart("muffleWarning")
[10:26:14.022]                       }
[10:26:14.022]                       else if (inherits(cond, "condition")) {
[10:26:14.022]                         if (!is.null(pattern)) {
[10:26:14.022]                           computeRestarts <- base::computeRestarts
[10:26:14.022]                           grepl <- base::grepl
[10:26:14.022]                           restarts <- computeRestarts(cond)
[10:26:14.022]                           for (restart in restarts) {
[10:26:14.022]                             name <- restart$name
[10:26:14.022]                             if (is.null(name)) 
[10:26:14.022]                               next
[10:26:14.022]                             if (!grepl(pattern, name)) 
[10:26:14.022]                               next
[10:26:14.022]                             invokeRestart(restart)
[10:26:14.022]                             muffled <- TRUE
[10:26:14.022]                             break
[10:26:14.022]                           }
[10:26:14.022]                         }
[10:26:14.022]                       }
[10:26:14.022]                       invisible(muffled)
[10:26:14.022]                     }
[10:26:14.022]                     muffleCondition(cond, pattern = "^muffle")
[10:26:14.022]                   }
[10:26:14.022]                 }
[10:26:14.022]             }
[10:26:14.022]         }))
[10:26:14.022]     }, error = function(ex) {
[10:26:14.022]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:14.022]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:14.022]                 ...future.rng), started = ...future.startTime, 
[10:26:14.022]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:14.022]             version = "1.8"), class = "FutureResult")
[10:26:14.022]     }, finally = {
[10:26:14.022]         if (!identical(...future.workdir, getwd())) 
[10:26:14.022]             setwd(...future.workdir)
[10:26:14.022]         {
[10:26:14.022]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:14.022]                 ...future.oldOptions$nwarnings <- NULL
[10:26:14.022]             }
[10:26:14.022]             base::options(...future.oldOptions)
[10:26:14.022]             if (.Platform$OS.type == "windows") {
[10:26:14.022]                 old_names <- names(...future.oldEnvVars)
[10:26:14.022]                 envs <- base::Sys.getenv()
[10:26:14.022]                 names <- names(envs)
[10:26:14.022]                 common <- intersect(names, old_names)
[10:26:14.022]                 added <- setdiff(names, old_names)
[10:26:14.022]                 removed <- setdiff(old_names, names)
[10:26:14.022]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:14.022]                   envs[common]]
[10:26:14.022]                 NAMES <- toupper(changed)
[10:26:14.022]                 args <- list()
[10:26:14.022]                 for (kk in seq_along(NAMES)) {
[10:26:14.022]                   name <- changed[[kk]]
[10:26:14.022]                   NAME <- NAMES[[kk]]
[10:26:14.022]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.022]                     next
[10:26:14.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:14.022]                 }
[10:26:14.022]                 NAMES <- toupper(added)
[10:26:14.022]                 for (kk in seq_along(NAMES)) {
[10:26:14.022]                   name <- added[[kk]]
[10:26:14.022]                   NAME <- NAMES[[kk]]
[10:26:14.022]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.022]                     next
[10:26:14.022]                   args[[name]] <- ""
[10:26:14.022]                 }
[10:26:14.022]                 NAMES <- toupper(removed)
[10:26:14.022]                 for (kk in seq_along(NAMES)) {
[10:26:14.022]                   name <- removed[[kk]]
[10:26:14.022]                   NAME <- NAMES[[kk]]
[10:26:14.022]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.022]                     next
[10:26:14.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:14.022]                 }
[10:26:14.022]                 if (length(args) > 0) 
[10:26:14.022]                   base::do.call(base::Sys.setenv, args = args)
[10:26:14.022]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:14.022]             }
[10:26:14.022]             else {
[10:26:14.022]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:14.022]             }
[10:26:14.022]             {
[10:26:14.022]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:14.022]                   0L) {
[10:26:14.022]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:14.022]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:14.022]                   base::options(opts)
[10:26:14.022]                 }
[10:26:14.022]                 {
[10:26:14.022]                   {
[10:26:14.022]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:14.022]                     NULL
[10:26:14.022]                   }
[10:26:14.022]                   options(future.plan = NULL)
[10:26:14.022]                   if (is.na(NA_character_)) 
[10:26:14.022]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:14.022]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:14.022]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:14.022]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:14.022]                     envir = parent.frame()) 
[10:26:14.022]                   {
[10:26:14.022]                     if (is.function(workers)) 
[10:26:14.022]                       workers <- workers()
[10:26:14.022]                     workers <- structure(as.integer(workers), 
[10:26:14.022]                       class = class(workers))
[10:26:14.022]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:14.022]                       workers >= 1)
[10:26:14.022]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:14.022]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:14.022]                     }
[10:26:14.022]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:14.022]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:14.022]                       envir = envir)
[10:26:14.022]                     if (!future$lazy) 
[10:26:14.022]                       future <- run(future)
[10:26:14.022]                     invisible(future)
[10:26:14.022]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:14.022]                 }
[10:26:14.022]             }
[10:26:14.022]         }
[10:26:14.022]     })
[10:26:14.022]     if (TRUE) {
[10:26:14.022]         base::sink(type = "output", split = FALSE)
[10:26:14.022]         if (TRUE) {
[10:26:14.022]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:14.022]         }
[10:26:14.022]         else {
[10:26:14.022]             ...future.result["stdout"] <- base::list(NULL)
[10:26:14.022]         }
[10:26:14.022]         base::close(...future.stdout)
[10:26:14.022]         ...future.stdout <- NULL
[10:26:14.022]     }
[10:26:14.022]     ...future.result$conditions <- ...future.conditions
[10:26:14.022]     ...future.result$finished <- base::Sys.time()
[10:26:14.022]     ...future.result
[10:26:14.022] }
[10:26:14.075] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[10:26:14.075] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[10:26:14.076] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[10:26:14.076] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[10:26:14.076] MultisessionFuture started
[10:26:14.076] - Launch lazy future ... done
[10:26:14.076] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:14.077] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:14.077] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:14.079] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:14.079] Searching for globals ... DONE
[10:26:14.079] Resolving globals: TRUE
[10:26:14.079] Resolving any globals that are futures ...
[10:26:14.079] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:14.079] Resolving any globals that are futures ... DONE
[10:26:14.079] Resolving futures part of globals (recursively) ...
[10:26:14.080] resolve() on list ...
[10:26:14.080]  recursive: 99
[10:26:14.080]  length: 1
[10:26:14.080]  elements: ‘ii’
[10:26:14.080]  length: 0 (resolved future 1)
[10:26:14.080] resolve() on list ... DONE
[10:26:14.080] - globals: [1] ‘ii’
[10:26:14.080] Resolving futures part of globals (recursively) ... DONE
[10:26:14.081] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:14.081] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:14.081] - globals: [1] ‘ii’
[10:26:14.081] 
[10:26:14.081] getGlobalsAndPackages() ... DONE
[10:26:14.082] run() for ‘Future’ ...
[10:26:14.082] - state: ‘created’
[10:26:14.082] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:14.095] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:14.096] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:14.096]   - Field: ‘node’
[10:26:14.096]   - Field: ‘label’
[10:26:14.096]   - Field: ‘local’
[10:26:14.096]   - Field: ‘owner’
[10:26:14.096]   - Field: ‘envir’
[10:26:14.096]   - Field: ‘workers’
[10:26:14.096]   - Field: ‘packages’
[10:26:14.096]   - Field: ‘gc’
[10:26:14.096]   - Field: ‘conditions’
[10:26:14.097]   - Field: ‘persistent’
[10:26:14.097]   - Field: ‘expr’
[10:26:14.097]   - Field: ‘uuid’
[10:26:14.097]   - Field: ‘seed’
[10:26:14.097]   - Field: ‘version’
[10:26:14.097]   - Field: ‘result’
[10:26:14.097]   - Field: ‘asynchronous’
[10:26:14.097]   - Field: ‘calls’
[10:26:14.097]   - Field: ‘globals’
[10:26:14.097]   - Field: ‘stdout’
[10:26:14.097]   - Field: ‘earlySignal’
[10:26:14.098]   - Field: ‘lazy’
[10:26:14.098]   - Field: ‘state’
[10:26:14.098] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:14.098] - Launch lazy future ...
[10:26:14.098] Packages needed by the future expression (n = 0): <none>
[10:26:14.098] Packages needed by future strategies (n = 0): <none>
[10:26:14.099] {
[10:26:14.099]     {
[10:26:14.099]         {
[10:26:14.099]             ...future.startTime <- base::Sys.time()
[10:26:14.099]             {
[10:26:14.099]                 {
[10:26:14.099]                   {
[10:26:14.099]                     {
[10:26:14.099]                       base::local({
[10:26:14.099]                         has_future <- base::requireNamespace("future", 
[10:26:14.099]                           quietly = TRUE)
[10:26:14.099]                         if (has_future) {
[10:26:14.099]                           ns <- base::getNamespace("future")
[10:26:14.099]                           version <- ns[[".package"]][["version"]]
[10:26:14.099]                           if (is.null(version)) 
[10:26:14.099]                             version <- utils::packageVersion("future")
[10:26:14.099]                         }
[10:26:14.099]                         else {
[10:26:14.099]                           version <- NULL
[10:26:14.099]                         }
[10:26:14.099]                         if (!has_future || version < "1.8.0") {
[10:26:14.099]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:14.099]                             "", base::R.version$version.string), 
[10:26:14.099]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:14.099]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:14.099]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:14.099]                               "release", "version")], collapse = " "), 
[10:26:14.099]                             hostname = base::Sys.info()[["nodename"]])
[10:26:14.099]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:14.099]                             info)
[10:26:14.099]                           info <- base::paste(info, collapse = "; ")
[10:26:14.099]                           if (!has_future) {
[10:26:14.099]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:14.099]                               info)
[10:26:14.099]                           }
[10:26:14.099]                           else {
[10:26:14.099]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:14.099]                               info, version)
[10:26:14.099]                           }
[10:26:14.099]                           base::stop(msg)
[10:26:14.099]                         }
[10:26:14.099]                       })
[10:26:14.099]                     }
[10:26:14.099]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:14.099]                     base::options(mc.cores = 1L)
[10:26:14.099]                   }
[10:26:14.099]                   options(future.plan = NULL)
[10:26:14.099]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:14.099]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:14.099]                 }
[10:26:14.099]                 ...future.workdir <- getwd()
[10:26:14.099]             }
[10:26:14.099]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:14.099]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:14.099]         }
[10:26:14.099]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:14.099]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:14.099]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:14.099]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:14.099]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:14.099]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:14.099]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:14.099]             base::names(...future.oldOptions))
[10:26:14.099]     }
[10:26:14.099]     if (FALSE) {
[10:26:14.099]     }
[10:26:14.099]     else {
[10:26:14.099]         if (TRUE) {
[10:26:14.099]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:14.099]                 open = "w")
[10:26:14.099]         }
[10:26:14.099]         else {
[10:26:14.099]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:14.099]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:14.099]         }
[10:26:14.099]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:14.099]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:14.099]             base::sink(type = "output", split = FALSE)
[10:26:14.099]             base::close(...future.stdout)
[10:26:14.099]         }, add = TRUE)
[10:26:14.099]     }
[10:26:14.099]     ...future.frame <- base::sys.nframe()
[10:26:14.099]     ...future.conditions <- base::list()
[10:26:14.099]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:14.099]     if (FALSE) {
[10:26:14.099]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:14.099]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:14.099]     }
[10:26:14.099]     ...future.result <- base::tryCatch({
[10:26:14.099]         base::withCallingHandlers({
[10:26:14.099]             ...future.value <- base::withVisible(base::local({
[10:26:14.099]                 ...future.makeSendCondition <- base::local({
[10:26:14.099]                   sendCondition <- NULL
[10:26:14.099]                   function(frame = 1L) {
[10:26:14.099]                     if (is.function(sendCondition)) 
[10:26:14.099]                       return(sendCondition)
[10:26:14.099]                     ns <- getNamespace("parallel")
[10:26:14.099]                     if (exists("sendData", mode = "function", 
[10:26:14.099]                       envir = ns)) {
[10:26:14.099]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:14.099]                         envir = ns)
[10:26:14.099]                       envir <- sys.frame(frame)
[10:26:14.099]                       master <- NULL
[10:26:14.099]                       while (!identical(envir, .GlobalEnv) && 
[10:26:14.099]                         !identical(envir, emptyenv())) {
[10:26:14.099]                         if (exists("master", mode = "list", envir = envir, 
[10:26:14.099]                           inherits = FALSE)) {
[10:26:14.099]                           master <- get("master", mode = "list", 
[10:26:14.099]                             envir = envir, inherits = FALSE)
[10:26:14.099]                           if (inherits(master, c("SOCKnode", 
[10:26:14.099]                             "SOCK0node"))) {
[10:26:14.099]                             sendCondition <<- function(cond) {
[10:26:14.099]                               data <- list(type = "VALUE", value = cond, 
[10:26:14.099]                                 success = TRUE)
[10:26:14.099]                               parallel_sendData(master, data)
[10:26:14.099]                             }
[10:26:14.099]                             return(sendCondition)
[10:26:14.099]                           }
[10:26:14.099]                         }
[10:26:14.099]                         frame <- frame + 1L
[10:26:14.099]                         envir <- sys.frame(frame)
[10:26:14.099]                       }
[10:26:14.099]                     }
[10:26:14.099]                     sendCondition <<- function(cond) NULL
[10:26:14.099]                   }
[10:26:14.099]                 })
[10:26:14.099]                 withCallingHandlers({
[10:26:14.099]                   {
[10:26:14.099]                     b <- a * ii
[10:26:14.099]                     a <- 0
[10:26:14.099]                     b
[10:26:14.099]                   }
[10:26:14.099]                 }, immediateCondition = function(cond) {
[10:26:14.099]                   sendCondition <- ...future.makeSendCondition()
[10:26:14.099]                   sendCondition(cond)
[10:26:14.099]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.099]                   {
[10:26:14.099]                     inherits <- base::inherits
[10:26:14.099]                     invokeRestart <- base::invokeRestart
[10:26:14.099]                     is.null <- base::is.null
[10:26:14.099]                     muffled <- FALSE
[10:26:14.099]                     if (inherits(cond, "message")) {
[10:26:14.099]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:14.099]                       if (muffled) 
[10:26:14.099]                         invokeRestart("muffleMessage")
[10:26:14.099]                     }
[10:26:14.099]                     else if (inherits(cond, "warning")) {
[10:26:14.099]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:14.099]                       if (muffled) 
[10:26:14.099]                         invokeRestart("muffleWarning")
[10:26:14.099]                     }
[10:26:14.099]                     else if (inherits(cond, "condition")) {
[10:26:14.099]                       if (!is.null(pattern)) {
[10:26:14.099]                         computeRestarts <- base::computeRestarts
[10:26:14.099]                         grepl <- base::grepl
[10:26:14.099]                         restarts <- computeRestarts(cond)
[10:26:14.099]                         for (restart in restarts) {
[10:26:14.099]                           name <- restart$name
[10:26:14.099]                           if (is.null(name)) 
[10:26:14.099]                             next
[10:26:14.099]                           if (!grepl(pattern, name)) 
[10:26:14.099]                             next
[10:26:14.099]                           invokeRestart(restart)
[10:26:14.099]                           muffled <- TRUE
[10:26:14.099]                           break
[10:26:14.099]                         }
[10:26:14.099]                       }
[10:26:14.099]                     }
[10:26:14.099]                     invisible(muffled)
[10:26:14.099]                   }
[10:26:14.099]                   muffleCondition(cond)
[10:26:14.099]                 })
[10:26:14.099]             }))
[10:26:14.099]             future::FutureResult(value = ...future.value$value, 
[10:26:14.099]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:14.099]                   ...future.rng), globalenv = if (FALSE) 
[10:26:14.099]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:14.099]                     ...future.globalenv.names))
[10:26:14.099]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:14.099]         }, condition = base::local({
[10:26:14.099]             c <- base::c
[10:26:14.099]             inherits <- base::inherits
[10:26:14.099]             invokeRestart <- base::invokeRestart
[10:26:14.099]             length <- base::length
[10:26:14.099]             list <- base::list
[10:26:14.099]             seq.int <- base::seq.int
[10:26:14.099]             signalCondition <- base::signalCondition
[10:26:14.099]             sys.calls <- base::sys.calls
[10:26:14.099]             `[[` <- base::`[[`
[10:26:14.099]             `+` <- base::`+`
[10:26:14.099]             `<<-` <- base::`<<-`
[10:26:14.099]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:14.099]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:14.099]                   3L)]
[10:26:14.099]             }
[10:26:14.099]             function(cond) {
[10:26:14.099]                 is_error <- inherits(cond, "error")
[10:26:14.099]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:14.099]                   NULL)
[10:26:14.099]                 if (is_error) {
[10:26:14.099]                   sessionInformation <- function() {
[10:26:14.099]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:14.099]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:14.099]                       search = base::search(), system = base::Sys.info())
[10:26:14.099]                   }
[10:26:14.099]                   ...future.conditions[[length(...future.conditions) + 
[10:26:14.099]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:14.099]                     cond$call), session = sessionInformation(), 
[10:26:14.099]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:14.099]                   signalCondition(cond)
[10:26:14.099]                 }
[10:26:14.099]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:14.099]                 "immediateCondition"))) {
[10:26:14.099]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:14.099]                   ...future.conditions[[length(...future.conditions) + 
[10:26:14.099]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:14.099]                   if (TRUE && !signal) {
[10:26:14.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.099]                     {
[10:26:14.099]                       inherits <- base::inherits
[10:26:14.099]                       invokeRestart <- base::invokeRestart
[10:26:14.099]                       is.null <- base::is.null
[10:26:14.099]                       muffled <- FALSE
[10:26:14.099]                       if (inherits(cond, "message")) {
[10:26:14.099]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:14.099]                         if (muffled) 
[10:26:14.099]                           invokeRestart("muffleMessage")
[10:26:14.099]                       }
[10:26:14.099]                       else if (inherits(cond, "warning")) {
[10:26:14.099]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:14.099]                         if (muffled) 
[10:26:14.099]                           invokeRestart("muffleWarning")
[10:26:14.099]                       }
[10:26:14.099]                       else if (inherits(cond, "condition")) {
[10:26:14.099]                         if (!is.null(pattern)) {
[10:26:14.099]                           computeRestarts <- base::computeRestarts
[10:26:14.099]                           grepl <- base::grepl
[10:26:14.099]                           restarts <- computeRestarts(cond)
[10:26:14.099]                           for (restart in restarts) {
[10:26:14.099]                             name <- restart$name
[10:26:14.099]                             if (is.null(name)) 
[10:26:14.099]                               next
[10:26:14.099]                             if (!grepl(pattern, name)) 
[10:26:14.099]                               next
[10:26:14.099]                             invokeRestart(restart)
[10:26:14.099]                             muffled <- TRUE
[10:26:14.099]                             break
[10:26:14.099]                           }
[10:26:14.099]                         }
[10:26:14.099]                       }
[10:26:14.099]                       invisible(muffled)
[10:26:14.099]                     }
[10:26:14.099]                     muffleCondition(cond, pattern = "^muffle")
[10:26:14.099]                   }
[10:26:14.099]                 }
[10:26:14.099]                 else {
[10:26:14.099]                   if (TRUE) {
[10:26:14.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.099]                     {
[10:26:14.099]                       inherits <- base::inherits
[10:26:14.099]                       invokeRestart <- base::invokeRestart
[10:26:14.099]                       is.null <- base::is.null
[10:26:14.099]                       muffled <- FALSE
[10:26:14.099]                       if (inherits(cond, "message")) {
[10:26:14.099]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:14.099]                         if (muffled) 
[10:26:14.099]                           invokeRestart("muffleMessage")
[10:26:14.099]                       }
[10:26:14.099]                       else if (inherits(cond, "warning")) {
[10:26:14.099]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:14.099]                         if (muffled) 
[10:26:14.099]                           invokeRestart("muffleWarning")
[10:26:14.099]                       }
[10:26:14.099]                       else if (inherits(cond, "condition")) {
[10:26:14.099]                         if (!is.null(pattern)) {
[10:26:14.099]                           computeRestarts <- base::computeRestarts
[10:26:14.099]                           grepl <- base::grepl
[10:26:14.099]                           restarts <- computeRestarts(cond)
[10:26:14.099]                           for (restart in restarts) {
[10:26:14.099]                             name <- restart$name
[10:26:14.099]                             if (is.null(name)) 
[10:26:14.099]                               next
[10:26:14.099]                             if (!grepl(pattern, name)) 
[10:26:14.099]                               next
[10:26:14.099]                             invokeRestart(restart)
[10:26:14.099]                             muffled <- TRUE
[10:26:14.099]                             break
[10:26:14.099]                           }
[10:26:14.099]                         }
[10:26:14.099]                       }
[10:26:14.099]                       invisible(muffled)
[10:26:14.099]                     }
[10:26:14.099]                     muffleCondition(cond, pattern = "^muffle")
[10:26:14.099]                   }
[10:26:14.099]                 }
[10:26:14.099]             }
[10:26:14.099]         }))
[10:26:14.099]     }, error = function(ex) {
[10:26:14.099]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:14.099]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:14.099]                 ...future.rng), started = ...future.startTime, 
[10:26:14.099]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:14.099]             version = "1.8"), class = "FutureResult")
[10:26:14.099]     }, finally = {
[10:26:14.099]         if (!identical(...future.workdir, getwd())) 
[10:26:14.099]             setwd(...future.workdir)
[10:26:14.099]         {
[10:26:14.099]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:14.099]                 ...future.oldOptions$nwarnings <- NULL
[10:26:14.099]             }
[10:26:14.099]             base::options(...future.oldOptions)
[10:26:14.099]             if (.Platform$OS.type == "windows") {
[10:26:14.099]                 old_names <- names(...future.oldEnvVars)
[10:26:14.099]                 envs <- base::Sys.getenv()
[10:26:14.099]                 names <- names(envs)
[10:26:14.099]                 common <- intersect(names, old_names)
[10:26:14.099]                 added <- setdiff(names, old_names)
[10:26:14.099]                 removed <- setdiff(old_names, names)
[10:26:14.099]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:14.099]                   envs[common]]
[10:26:14.099]                 NAMES <- toupper(changed)
[10:26:14.099]                 args <- list()
[10:26:14.099]                 for (kk in seq_along(NAMES)) {
[10:26:14.099]                   name <- changed[[kk]]
[10:26:14.099]                   NAME <- NAMES[[kk]]
[10:26:14.099]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.099]                     next
[10:26:14.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:14.099]                 }
[10:26:14.099]                 NAMES <- toupper(added)
[10:26:14.099]                 for (kk in seq_along(NAMES)) {
[10:26:14.099]                   name <- added[[kk]]
[10:26:14.099]                   NAME <- NAMES[[kk]]
[10:26:14.099]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.099]                     next
[10:26:14.099]                   args[[name]] <- ""
[10:26:14.099]                 }
[10:26:14.099]                 NAMES <- toupper(removed)
[10:26:14.099]                 for (kk in seq_along(NAMES)) {
[10:26:14.099]                   name <- removed[[kk]]
[10:26:14.099]                   NAME <- NAMES[[kk]]
[10:26:14.099]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.099]                     next
[10:26:14.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:14.099]                 }
[10:26:14.099]                 if (length(args) > 0) 
[10:26:14.099]                   base::do.call(base::Sys.setenv, args = args)
[10:26:14.099]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:14.099]             }
[10:26:14.099]             else {
[10:26:14.099]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:14.099]             }
[10:26:14.099]             {
[10:26:14.099]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:14.099]                   0L) {
[10:26:14.099]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:14.099]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:14.099]                   base::options(opts)
[10:26:14.099]                 }
[10:26:14.099]                 {
[10:26:14.099]                   {
[10:26:14.099]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:14.099]                     NULL
[10:26:14.099]                   }
[10:26:14.099]                   options(future.plan = NULL)
[10:26:14.099]                   if (is.na(NA_character_)) 
[10:26:14.099]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:14.099]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:14.099]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:14.099]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:14.099]                     envir = parent.frame()) 
[10:26:14.099]                   {
[10:26:14.099]                     if (is.function(workers)) 
[10:26:14.099]                       workers <- workers()
[10:26:14.099]                     workers <- structure(as.integer(workers), 
[10:26:14.099]                       class = class(workers))
[10:26:14.099]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:14.099]                       workers >= 1)
[10:26:14.099]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:14.099]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:14.099]                     }
[10:26:14.099]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:14.099]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:14.099]                       envir = envir)
[10:26:14.099]                     if (!future$lazy) 
[10:26:14.099]                       future <- run(future)
[10:26:14.099]                     invisible(future)
[10:26:14.099]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:14.099]                 }
[10:26:14.099]             }
[10:26:14.099]         }
[10:26:14.099]     })
[10:26:14.099]     if (TRUE) {
[10:26:14.099]         base::sink(type = "output", split = FALSE)
[10:26:14.099]         if (TRUE) {
[10:26:14.099]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:14.099]         }
[10:26:14.099]         else {
[10:26:14.099]             ...future.result["stdout"] <- base::list(NULL)
[10:26:14.099]         }
[10:26:14.099]         base::close(...future.stdout)
[10:26:14.099]         ...future.stdout <- NULL
[10:26:14.099]     }
[10:26:14.099]     ...future.result$conditions <- ...future.conditions
[10:26:14.099]     ...future.result$finished <- base::Sys.time()
[10:26:14.099]     ...future.result
[10:26:14.099] }
[10:26:14.101] Poll #1 (0): usedNodes() = 2, workers = 2
[10:26:14.112] receiveMessageFromWorker() for ClusterFuture ...
[10:26:14.112] - Validating connection of MultisessionFuture
[10:26:14.113] - received message: FutureResult
[10:26:14.113] - Received FutureResult
[10:26:14.113] - Erased future from FutureRegistry
[10:26:14.113] result() for ClusterFuture ...
[10:26:14.113] - result already collected: FutureResult
[10:26:14.113] result() for ClusterFuture ... done
[10:26:14.113] signalConditions() ...
[10:26:14.113]  - include = ‘immediateCondition’
[10:26:14.113]  - exclude = 
[10:26:14.113]  - resignal = FALSE
[10:26:14.114]  - Number of conditions: 1
[10:26:14.114] signalConditions() ... done
[10:26:14.114] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:14.114] result() for ClusterFuture ...
[10:26:14.114] - result already collected: FutureResult
[10:26:14.114] result() for ClusterFuture ... done
[10:26:14.114] result() for ClusterFuture ...
[10:26:14.114] - result already collected: FutureResult
[10:26:14.114] result() for ClusterFuture ... done
[10:26:14.114] signalConditions() ...
[10:26:14.115]  - include = ‘immediateCondition’
[10:26:14.115]  - exclude = 
[10:26:14.115]  - resignal = FALSE
[10:26:14.115]  - Number of conditions: 1
[10:26:14.115] signalConditions() ... done
[10:26:14.116] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[10:26:14.116] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[10:26:14.116] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[10:26:14.116] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[10:26:14.117] MultisessionFuture started
[10:26:14.117] - Launch lazy future ... done
[10:26:14.117] run() for ‘MultisessionFuture’ ... done
[10:26:14.117] result() for ClusterFuture ...
[10:26:14.118] - result already collected: FutureResult
[10:26:14.118] result() for ClusterFuture ... done
[10:26:14.118] result() for ClusterFuture ...
[10:26:14.118] - result already collected: FutureResult
[10:26:14.118] result() for ClusterFuture ... done
[10:26:14.118] signalConditions() ...
[10:26:14.118]  - include = ‘immediateCondition’
[10:26:14.118]  - exclude = 
[10:26:14.118]  - resignal = FALSE
[10:26:14.118]  - Number of conditions: 1
[10:26:14.118] signalConditions() ... done
[10:26:14.119] Future state: ‘finished’
[10:26:14.119] result() for ClusterFuture ...
[10:26:14.119] - result already collected: FutureResult
[10:26:14.119] result() for ClusterFuture ... done
[10:26:14.119] signalConditions() ...
[10:26:14.119]  - include = ‘condition’
[10:26:14.119]  - exclude = ‘immediateCondition’
[10:26:14.119]  - resignal = TRUE
[10:26:14.119]  - Number of conditions: 1
[10:26:14.119]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:26:14.119] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3e863ac79bce" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 10:26:14"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:14.135] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:14.135] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:14.136] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:14.136] Searching for globals ... DONE
[10:26:14.136] Resolving globals: TRUE
[10:26:14.137] Resolving any globals that are futures ...
[10:26:14.137] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:14.137] Resolving any globals that are futures ... DONE
[10:26:14.137] Resolving futures part of globals (recursively) ...
[10:26:14.137] resolve() on list ...
[10:26:14.137]  recursive: 99
[10:26:14.138]  length: 1
[10:26:14.138]  elements: ‘ii’
[10:26:14.138]  length: 0 (resolved future 1)
[10:26:14.138] resolve() on list ... DONE
[10:26:14.138] - globals: [1] ‘ii’
[10:26:14.138] Resolving futures part of globals (recursively) ... DONE
[10:26:14.138] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:14.139] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:14.139] - globals: [1] ‘ii’
[10:26:14.139] 
[10:26:14.139] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:14.139] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:14.140] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:14.141] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:14.141] Searching for globals ... DONE
[10:26:14.141] Resolving globals: TRUE
[10:26:14.141] Resolving any globals that are futures ...
[10:26:14.141] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:14.141] Resolving any globals that are futures ... DONE
[10:26:14.142] Resolving futures part of globals (recursively) ...
[10:26:14.142] resolve() on list ...
[10:26:14.142]  recursive: 99
[10:26:14.142]  length: 1
[10:26:14.142]  elements: ‘ii’
[10:26:14.142]  length: 0 (resolved future 1)
[10:26:14.142] resolve() on list ... DONE
[10:26:14.142] - globals: [1] ‘ii’
[10:26:14.142] Resolving futures part of globals (recursively) ... DONE
[10:26:14.143] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:14.143] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:14.143] - globals: [1] ‘ii’
[10:26:14.143] 
[10:26:14.143] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:14.144] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:14.144] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:14.145] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:14.145] Searching for globals ... DONE
[10:26:14.145] Resolving globals: TRUE
[10:26:14.145] Resolving any globals that are futures ...
[10:26:14.146] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:26:14.146] Resolving any globals that are futures ... DONE
[10:26:14.146] Resolving futures part of globals (recursively) ...
[10:26:14.146] resolve() on list ...
[10:26:14.146]  recursive: 99
[10:26:14.146]  length: 1
[10:26:14.146]  elements: ‘ii’
[10:26:14.147]  length: 0 (resolved future 1)
[10:26:14.147] resolve() on list ... DONE
[10:26:14.147] - globals: [1] ‘ii’
[10:26:14.147] Resolving futures part of globals (recursively) ... DONE
[10:26:14.147] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:14.147] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:14.147] - globals: [1] ‘ii’
[10:26:14.147] 
[10:26:14.148] getGlobalsAndPackages() ... DONE
[10:26:14.148] run() for ‘Future’ ...
[10:26:14.148] - state: ‘created’
[10:26:14.148] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:14.165] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:14.165] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:14.165]   - Field: ‘node’
[10:26:14.166]   - Field: ‘label’
[10:26:14.166]   - Field: ‘local’
[10:26:14.166]   - Field: ‘owner’
[10:26:14.166]   - Field: ‘envir’
[10:26:14.166]   - Field: ‘workers’
[10:26:14.166]   - Field: ‘packages’
[10:26:14.166]   - Field: ‘gc’
[10:26:14.167]   - Field: ‘conditions’
[10:26:14.167]   - Field: ‘persistent’
[10:26:14.167]   - Field: ‘expr’
[10:26:14.167]   - Field: ‘uuid’
[10:26:14.167]   - Field: ‘seed’
[10:26:14.167]   - Field: ‘version’
[10:26:14.168]   - Field: ‘result’
[10:26:14.168]   - Field: ‘asynchronous’
[10:26:14.168]   - Field: ‘calls’
[10:26:14.168]   - Field: ‘globals’
[10:26:14.168]   - Field: ‘stdout’
[10:26:14.168]   - Field: ‘earlySignal’
[10:26:14.168]   - Field: ‘lazy’
[10:26:14.168]   - Field: ‘state’
[10:26:14.169] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:14.169] - Launch lazy future ...
[10:26:14.169] Packages needed by the future expression (n = 0): <none>
[10:26:14.169] Packages needed by future strategies (n = 0): <none>
[10:26:14.170] {
[10:26:14.170]     {
[10:26:14.170]         {
[10:26:14.170]             ...future.startTime <- base::Sys.time()
[10:26:14.170]             {
[10:26:14.170]                 {
[10:26:14.170]                   {
[10:26:14.170]                     {
[10:26:14.170]                       base::local({
[10:26:14.170]                         has_future <- base::requireNamespace("future", 
[10:26:14.170]                           quietly = TRUE)
[10:26:14.170]                         if (has_future) {
[10:26:14.170]                           ns <- base::getNamespace("future")
[10:26:14.170]                           version <- ns[[".package"]][["version"]]
[10:26:14.170]                           if (is.null(version)) 
[10:26:14.170]                             version <- utils::packageVersion("future")
[10:26:14.170]                         }
[10:26:14.170]                         else {
[10:26:14.170]                           version <- NULL
[10:26:14.170]                         }
[10:26:14.170]                         if (!has_future || version < "1.8.0") {
[10:26:14.170]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:14.170]                             "", base::R.version$version.string), 
[10:26:14.170]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:14.170]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:14.170]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:14.170]                               "release", "version")], collapse = " "), 
[10:26:14.170]                             hostname = base::Sys.info()[["nodename"]])
[10:26:14.170]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:14.170]                             info)
[10:26:14.170]                           info <- base::paste(info, collapse = "; ")
[10:26:14.170]                           if (!has_future) {
[10:26:14.170]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:14.170]                               info)
[10:26:14.170]                           }
[10:26:14.170]                           else {
[10:26:14.170]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:14.170]                               info, version)
[10:26:14.170]                           }
[10:26:14.170]                           base::stop(msg)
[10:26:14.170]                         }
[10:26:14.170]                       })
[10:26:14.170]                     }
[10:26:14.170]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:14.170]                     base::options(mc.cores = 1L)
[10:26:14.170]                   }
[10:26:14.170]                   options(future.plan = NULL)
[10:26:14.170]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:14.170]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:14.170]                 }
[10:26:14.170]                 ...future.workdir <- getwd()
[10:26:14.170]             }
[10:26:14.170]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:14.170]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:14.170]         }
[10:26:14.170]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:14.170]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:14.170]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:14.170]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:14.170]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:14.170]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:14.170]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:14.170]             base::names(...future.oldOptions))
[10:26:14.170]     }
[10:26:14.170]     if (FALSE) {
[10:26:14.170]     }
[10:26:14.170]     else {
[10:26:14.170]         if (TRUE) {
[10:26:14.170]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:14.170]                 open = "w")
[10:26:14.170]         }
[10:26:14.170]         else {
[10:26:14.170]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:14.170]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:14.170]         }
[10:26:14.170]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:14.170]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:14.170]             base::sink(type = "output", split = FALSE)
[10:26:14.170]             base::close(...future.stdout)
[10:26:14.170]         }, add = TRUE)
[10:26:14.170]     }
[10:26:14.170]     ...future.frame <- base::sys.nframe()
[10:26:14.170]     ...future.conditions <- base::list()
[10:26:14.170]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:14.170]     if (FALSE) {
[10:26:14.170]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:14.170]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:14.170]     }
[10:26:14.170]     ...future.result <- base::tryCatch({
[10:26:14.170]         base::withCallingHandlers({
[10:26:14.170]             ...future.value <- base::withVisible(base::local({
[10:26:14.170]                 ...future.makeSendCondition <- base::local({
[10:26:14.170]                   sendCondition <- NULL
[10:26:14.170]                   function(frame = 1L) {
[10:26:14.170]                     if (is.function(sendCondition)) 
[10:26:14.170]                       return(sendCondition)
[10:26:14.170]                     ns <- getNamespace("parallel")
[10:26:14.170]                     if (exists("sendData", mode = "function", 
[10:26:14.170]                       envir = ns)) {
[10:26:14.170]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:14.170]                         envir = ns)
[10:26:14.170]                       envir <- sys.frame(frame)
[10:26:14.170]                       master <- NULL
[10:26:14.170]                       while (!identical(envir, .GlobalEnv) && 
[10:26:14.170]                         !identical(envir, emptyenv())) {
[10:26:14.170]                         if (exists("master", mode = "list", envir = envir, 
[10:26:14.170]                           inherits = FALSE)) {
[10:26:14.170]                           master <- get("master", mode = "list", 
[10:26:14.170]                             envir = envir, inherits = FALSE)
[10:26:14.170]                           if (inherits(master, c("SOCKnode", 
[10:26:14.170]                             "SOCK0node"))) {
[10:26:14.170]                             sendCondition <<- function(cond) {
[10:26:14.170]                               data <- list(type = "VALUE", value = cond, 
[10:26:14.170]                                 success = TRUE)
[10:26:14.170]                               parallel_sendData(master, data)
[10:26:14.170]                             }
[10:26:14.170]                             return(sendCondition)
[10:26:14.170]                           }
[10:26:14.170]                         }
[10:26:14.170]                         frame <- frame + 1L
[10:26:14.170]                         envir <- sys.frame(frame)
[10:26:14.170]                       }
[10:26:14.170]                     }
[10:26:14.170]                     sendCondition <<- function(cond) NULL
[10:26:14.170]                   }
[10:26:14.170]                 })
[10:26:14.170]                 withCallingHandlers({
[10:26:14.170]                   {
[10:26:14.170]                     b <- a * ii
[10:26:14.170]                     a <- 0
[10:26:14.170]                     b
[10:26:14.170]                   }
[10:26:14.170]                 }, immediateCondition = function(cond) {
[10:26:14.170]                   sendCondition <- ...future.makeSendCondition()
[10:26:14.170]                   sendCondition(cond)
[10:26:14.170]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.170]                   {
[10:26:14.170]                     inherits <- base::inherits
[10:26:14.170]                     invokeRestart <- base::invokeRestart
[10:26:14.170]                     is.null <- base::is.null
[10:26:14.170]                     muffled <- FALSE
[10:26:14.170]                     if (inherits(cond, "message")) {
[10:26:14.170]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:14.170]                       if (muffled) 
[10:26:14.170]                         invokeRestart("muffleMessage")
[10:26:14.170]                     }
[10:26:14.170]                     else if (inherits(cond, "warning")) {
[10:26:14.170]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:14.170]                       if (muffled) 
[10:26:14.170]                         invokeRestart("muffleWarning")
[10:26:14.170]                     }
[10:26:14.170]                     else if (inherits(cond, "condition")) {
[10:26:14.170]                       if (!is.null(pattern)) {
[10:26:14.170]                         computeRestarts <- base::computeRestarts
[10:26:14.170]                         grepl <- base::grepl
[10:26:14.170]                         restarts <- computeRestarts(cond)
[10:26:14.170]                         for (restart in restarts) {
[10:26:14.170]                           name <- restart$name
[10:26:14.170]                           if (is.null(name)) 
[10:26:14.170]                             next
[10:26:14.170]                           if (!grepl(pattern, name)) 
[10:26:14.170]                             next
[10:26:14.170]                           invokeRestart(restart)
[10:26:14.170]                           muffled <- TRUE
[10:26:14.170]                           break
[10:26:14.170]                         }
[10:26:14.170]                       }
[10:26:14.170]                     }
[10:26:14.170]                     invisible(muffled)
[10:26:14.170]                   }
[10:26:14.170]                   muffleCondition(cond)
[10:26:14.170]                 })
[10:26:14.170]             }))
[10:26:14.170]             future::FutureResult(value = ...future.value$value, 
[10:26:14.170]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:14.170]                   ...future.rng), globalenv = if (FALSE) 
[10:26:14.170]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:14.170]                     ...future.globalenv.names))
[10:26:14.170]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:14.170]         }, condition = base::local({
[10:26:14.170]             c <- base::c
[10:26:14.170]             inherits <- base::inherits
[10:26:14.170]             invokeRestart <- base::invokeRestart
[10:26:14.170]             length <- base::length
[10:26:14.170]             list <- base::list
[10:26:14.170]             seq.int <- base::seq.int
[10:26:14.170]             signalCondition <- base::signalCondition
[10:26:14.170]             sys.calls <- base::sys.calls
[10:26:14.170]             `[[` <- base::`[[`
[10:26:14.170]             `+` <- base::`+`
[10:26:14.170]             `<<-` <- base::`<<-`
[10:26:14.170]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:14.170]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:14.170]                   3L)]
[10:26:14.170]             }
[10:26:14.170]             function(cond) {
[10:26:14.170]                 is_error <- inherits(cond, "error")
[10:26:14.170]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:14.170]                   NULL)
[10:26:14.170]                 if (is_error) {
[10:26:14.170]                   sessionInformation <- function() {
[10:26:14.170]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:14.170]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:14.170]                       search = base::search(), system = base::Sys.info())
[10:26:14.170]                   }
[10:26:14.170]                   ...future.conditions[[length(...future.conditions) + 
[10:26:14.170]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:14.170]                     cond$call), session = sessionInformation(), 
[10:26:14.170]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:14.170]                   signalCondition(cond)
[10:26:14.170]                 }
[10:26:14.170]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:14.170]                 "immediateCondition"))) {
[10:26:14.170]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:14.170]                   ...future.conditions[[length(...future.conditions) + 
[10:26:14.170]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:14.170]                   if (TRUE && !signal) {
[10:26:14.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.170]                     {
[10:26:14.170]                       inherits <- base::inherits
[10:26:14.170]                       invokeRestart <- base::invokeRestart
[10:26:14.170]                       is.null <- base::is.null
[10:26:14.170]                       muffled <- FALSE
[10:26:14.170]                       if (inherits(cond, "message")) {
[10:26:14.170]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:14.170]                         if (muffled) 
[10:26:14.170]                           invokeRestart("muffleMessage")
[10:26:14.170]                       }
[10:26:14.170]                       else if (inherits(cond, "warning")) {
[10:26:14.170]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:14.170]                         if (muffled) 
[10:26:14.170]                           invokeRestart("muffleWarning")
[10:26:14.170]                       }
[10:26:14.170]                       else if (inherits(cond, "condition")) {
[10:26:14.170]                         if (!is.null(pattern)) {
[10:26:14.170]                           computeRestarts <- base::computeRestarts
[10:26:14.170]                           grepl <- base::grepl
[10:26:14.170]                           restarts <- computeRestarts(cond)
[10:26:14.170]                           for (restart in restarts) {
[10:26:14.170]                             name <- restart$name
[10:26:14.170]                             if (is.null(name)) 
[10:26:14.170]                               next
[10:26:14.170]                             if (!grepl(pattern, name)) 
[10:26:14.170]                               next
[10:26:14.170]                             invokeRestart(restart)
[10:26:14.170]                             muffled <- TRUE
[10:26:14.170]                             break
[10:26:14.170]                           }
[10:26:14.170]                         }
[10:26:14.170]                       }
[10:26:14.170]                       invisible(muffled)
[10:26:14.170]                     }
[10:26:14.170]                     muffleCondition(cond, pattern = "^muffle")
[10:26:14.170]                   }
[10:26:14.170]                 }
[10:26:14.170]                 else {
[10:26:14.170]                   if (TRUE) {
[10:26:14.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.170]                     {
[10:26:14.170]                       inherits <- base::inherits
[10:26:14.170]                       invokeRestart <- base::invokeRestart
[10:26:14.170]                       is.null <- base::is.null
[10:26:14.170]                       muffled <- FALSE
[10:26:14.170]                       if (inherits(cond, "message")) {
[10:26:14.170]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:14.170]                         if (muffled) 
[10:26:14.170]                           invokeRestart("muffleMessage")
[10:26:14.170]                       }
[10:26:14.170]                       else if (inherits(cond, "warning")) {
[10:26:14.170]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:14.170]                         if (muffled) 
[10:26:14.170]                           invokeRestart("muffleWarning")
[10:26:14.170]                       }
[10:26:14.170]                       else if (inherits(cond, "condition")) {
[10:26:14.170]                         if (!is.null(pattern)) {
[10:26:14.170]                           computeRestarts <- base::computeRestarts
[10:26:14.170]                           grepl <- base::grepl
[10:26:14.170]                           restarts <- computeRestarts(cond)
[10:26:14.170]                           for (restart in restarts) {
[10:26:14.170]                             name <- restart$name
[10:26:14.170]                             if (is.null(name)) 
[10:26:14.170]                               next
[10:26:14.170]                             if (!grepl(pattern, name)) 
[10:26:14.170]                               next
[10:26:14.170]                             invokeRestart(restart)
[10:26:14.170]                             muffled <- TRUE
[10:26:14.170]                             break
[10:26:14.170]                           }
[10:26:14.170]                         }
[10:26:14.170]                       }
[10:26:14.170]                       invisible(muffled)
[10:26:14.170]                     }
[10:26:14.170]                     muffleCondition(cond, pattern = "^muffle")
[10:26:14.170]                   }
[10:26:14.170]                 }
[10:26:14.170]             }
[10:26:14.170]         }))
[10:26:14.170]     }, error = function(ex) {
[10:26:14.170]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:14.170]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:14.170]                 ...future.rng), started = ...future.startTime, 
[10:26:14.170]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:14.170]             version = "1.8"), class = "FutureResult")
[10:26:14.170]     }, finally = {
[10:26:14.170]         if (!identical(...future.workdir, getwd())) 
[10:26:14.170]             setwd(...future.workdir)
[10:26:14.170]         {
[10:26:14.170]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:14.170]                 ...future.oldOptions$nwarnings <- NULL
[10:26:14.170]             }
[10:26:14.170]             base::options(...future.oldOptions)
[10:26:14.170]             if (.Platform$OS.type == "windows") {
[10:26:14.170]                 old_names <- names(...future.oldEnvVars)
[10:26:14.170]                 envs <- base::Sys.getenv()
[10:26:14.170]                 names <- names(envs)
[10:26:14.170]                 common <- intersect(names, old_names)
[10:26:14.170]                 added <- setdiff(names, old_names)
[10:26:14.170]                 removed <- setdiff(old_names, names)
[10:26:14.170]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:14.170]                   envs[common]]
[10:26:14.170]                 NAMES <- toupper(changed)
[10:26:14.170]                 args <- list()
[10:26:14.170]                 for (kk in seq_along(NAMES)) {
[10:26:14.170]                   name <- changed[[kk]]
[10:26:14.170]                   NAME <- NAMES[[kk]]
[10:26:14.170]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.170]                     next
[10:26:14.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:14.170]                 }
[10:26:14.170]                 NAMES <- toupper(added)
[10:26:14.170]                 for (kk in seq_along(NAMES)) {
[10:26:14.170]                   name <- added[[kk]]
[10:26:14.170]                   NAME <- NAMES[[kk]]
[10:26:14.170]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.170]                     next
[10:26:14.170]                   args[[name]] <- ""
[10:26:14.170]                 }
[10:26:14.170]                 NAMES <- toupper(removed)
[10:26:14.170]                 for (kk in seq_along(NAMES)) {
[10:26:14.170]                   name <- removed[[kk]]
[10:26:14.170]                   NAME <- NAMES[[kk]]
[10:26:14.170]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.170]                     next
[10:26:14.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:14.170]                 }
[10:26:14.170]                 if (length(args) > 0) 
[10:26:14.170]                   base::do.call(base::Sys.setenv, args = args)
[10:26:14.170]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:14.170]             }
[10:26:14.170]             else {
[10:26:14.170]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:14.170]             }
[10:26:14.170]             {
[10:26:14.170]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:14.170]                   0L) {
[10:26:14.170]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:14.170]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:14.170]                   base::options(opts)
[10:26:14.170]                 }
[10:26:14.170]                 {
[10:26:14.170]                   {
[10:26:14.170]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:14.170]                     NULL
[10:26:14.170]                   }
[10:26:14.170]                   options(future.plan = NULL)
[10:26:14.170]                   if (is.na(NA_character_)) 
[10:26:14.170]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:14.170]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:14.170]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:14.170]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:14.170]                     envir = parent.frame()) 
[10:26:14.170]                   {
[10:26:14.170]                     if (is.function(workers)) 
[10:26:14.170]                       workers <- workers()
[10:26:14.170]                     workers <- structure(as.integer(workers), 
[10:26:14.170]                       class = class(workers))
[10:26:14.170]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:14.170]                       workers >= 1)
[10:26:14.170]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:14.170]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:14.170]                     }
[10:26:14.170]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:14.170]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:14.170]                       envir = envir)
[10:26:14.170]                     if (!future$lazy) 
[10:26:14.170]                       future <- run(future)
[10:26:14.170]                     invisible(future)
[10:26:14.170]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:14.170]                 }
[10:26:14.170]             }
[10:26:14.170]         }
[10:26:14.170]     })
[10:26:14.170]     if (TRUE) {
[10:26:14.170]         base::sink(type = "output", split = FALSE)
[10:26:14.170]         if (TRUE) {
[10:26:14.170]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:14.170]         }
[10:26:14.170]         else {
[10:26:14.170]             ...future.result["stdout"] <- base::list(NULL)
[10:26:14.170]         }
[10:26:14.170]         base::close(...future.stdout)
[10:26:14.170]         ...future.stdout <- NULL
[10:26:14.170]     }
[10:26:14.170]     ...future.result$conditions <- ...future.conditions
[10:26:14.170]     ...future.result$finished <- base::Sys.time()
[10:26:14.170]     ...future.result
[10:26:14.170] }
[10:26:14.172] Poll #1 (0): usedNodes() = 2, workers = 2
[10:26:14.183] receiveMessageFromWorker() for ClusterFuture ...
[10:26:14.183] - Validating connection of MultisessionFuture
[10:26:14.183] - received message: FutureResult
[10:26:14.183] - Received FutureResult
[10:26:14.183] - Erased future from FutureRegistry
[10:26:14.184] result() for ClusterFuture ...
[10:26:14.184] - result already collected: FutureResult
[10:26:14.184] result() for ClusterFuture ... done
[10:26:14.184] signalConditions() ...
[10:26:14.184]  - include = ‘immediateCondition’
[10:26:14.184]  - exclude = 
[10:26:14.184]  - resignal = FALSE
[10:26:14.184]  - Number of conditions: 1
[10:26:14.184] signalConditions() ... done
[10:26:14.184] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:14.185] result() for ClusterFuture ...
[10:26:14.185] - result already collected: FutureResult
[10:26:14.185] result() for ClusterFuture ... done
[10:26:14.185] result() for ClusterFuture ...
[10:26:14.185] - result already collected: FutureResult
[10:26:14.185] result() for ClusterFuture ... done
[10:26:14.185] signalConditions() ...
[10:26:14.185]  - include = ‘immediateCondition’
[10:26:14.185]  - exclude = 
[10:26:14.185]  - resignal = FALSE
[10:26:14.185]  - Number of conditions: 1
[10:26:14.186] signalConditions() ... done
[10:26:14.186] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[10:26:14.186] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[10:26:14.187] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[10:26:14.187] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[10:26:14.187] MultisessionFuture started
[10:26:14.187] - Launch lazy future ... done
[10:26:14.188] run() for ‘MultisessionFuture’ ... done
[10:26:14.188] result() for ClusterFuture ...
[10:26:14.188] receiveMessageFromWorker() for ClusterFuture ...
[10:26:14.188] - Validating connection of MultisessionFuture
[10:26:14.235] - received message: FutureResult
[10:26:14.235] - Received FutureResult
[10:26:14.235] - Erased future from FutureRegistry
[10:26:14.235] result() for ClusterFuture ...
[10:26:14.235] - result already collected: FutureResult
[10:26:14.235] result() for ClusterFuture ... done
[10:26:14.235] signalConditions() ...
[10:26:14.236]  - include = ‘immediateCondition’
[10:26:14.236]  - exclude = 
[10:26:14.236]  - resignal = FALSE
[10:26:14.236]  - Number of conditions: 1
[10:26:14.236] signalConditions() ... done
[10:26:14.236] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:14.236] result() for ClusterFuture ... done
[10:26:14.236] result() for ClusterFuture ...
[10:26:14.236] - result already collected: FutureResult
[10:26:14.236] result() for ClusterFuture ... done
[10:26:14.236] signalConditions() ...
[10:26:14.237]  - include = ‘immediateCondition’
[10:26:14.237]  - exclude = 
[10:26:14.237]  - resignal = FALSE
[10:26:14.237]  - Number of conditions: 1
[10:26:14.237] signalConditions() ... done
[10:26:14.237] Future state: ‘finished’
[10:26:14.237] result() for ClusterFuture ...
[10:26:14.237] - result already collected: FutureResult
[10:26:14.237] result() for ClusterFuture ... done
[10:26:14.237] signalConditions() ...
[10:26:14.237]  - include = ‘condition’
[10:26:14.238]  - exclude = ‘immediateCondition’
[10:26:14.238]  - resignal = TRUE
[10:26:14.238]  - Number of conditions: 1
[10:26:14.238]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:26:14.238] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3e863ac79bce" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 10:26:14"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:14.252] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:14.252] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:14.252] 
[10:26:14.253] Searching for globals ... DONE
[10:26:14.253] - globals: [0] <none>
[10:26:14.253] getGlobalsAndPackages() ... DONE
[10:26:14.253] run() for ‘Future’ ...
[10:26:14.253] - state: ‘created’
[10:26:14.253] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:14.267] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:14.267] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:14.267]   - Field: ‘node’
[10:26:14.267]   - Field: ‘label’
[10:26:14.267]   - Field: ‘local’
[10:26:14.267]   - Field: ‘owner’
[10:26:14.268]   - Field: ‘envir’
[10:26:14.268]   - Field: ‘workers’
[10:26:14.268]   - Field: ‘packages’
[10:26:14.268]   - Field: ‘gc’
[10:26:14.268]   - Field: ‘conditions’
[10:26:14.268]   - Field: ‘persistent’
[10:26:14.268]   - Field: ‘expr’
[10:26:14.268]   - Field: ‘uuid’
[10:26:14.268]   - Field: ‘seed’
[10:26:14.268]   - Field: ‘version’
[10:26:14.268]   - Field: ‘result’
[10:26:14.269]   - Field: ‘asynchronous’
[10:26:14.269]   - Field: ‘calls’
[10:26:14.269]   - Field: ‘globals’
[10:26:14.269]   - Field: ‘stdout’
[10:26:14.269]   - Field: ‘earlySignal’
[10:26:14.269]   - Field: ‘lazy’
[10:26:14.269]   - Field: ‘state’
[10:26:14.269] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:14.269] - Launch lazy future ...
[10:26:14.270] Packages needed by the future expression (n = 0): <none>
[10:26:14.270] Packages needed by future strategies (n = 0): <none>
[10:26:14.270] {
[10:26:14.270]     {
[10:26:14.270]         {
[10:26:14.270]             ...future.startTime <- base::Sys.time()
[10:26:14.270]             {
[10:26:14.270]                 {
[10:26:14.270]                   {
[10:26:14.270]                     {
[10:26:14.270]                       base::local({
[10:26:14.270]                         has_future <- base::requireNamespace("future", 
[10:26:14.270]                           quietly = TRUE)
[10:26:14.270]                         if (has_future) {
[10:26:14.270]                           ns <- base::getNamespace("future")
[10:26:14.270]                           version <- ns[[".package"]][["version"]]
[10:26:14.270]                           if (is.null(version)) 
[10:26:14.270]                             version <- utils::packageVersion("future")
[10:26:14.270]                         }
[10:26:14.270]                         else {
[10:26:14.270]                           version <- NULL
[10:26:14.270]                         }
[10:26:14.270]                         if (!has_future || version < "1.8.0") {
[10:26:14.270]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:14.270]                             "", base::R.version$version.string), 
[10:26:14.270]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:14.270]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:14.270]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:14.270]                               "release", "version")], collapse = " "), 
[10:26:14.270]                             hostname = base::Sys.info()[["nodename"]])
[10:26:14.270]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:14.270]                             info)
[10:26:14.270]                           info <- base::paste(info, collapse = "; ")
[10:26:14.270]                           if (!has_future) {
[10:26:14.270]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:14.270]                               info)
[10:26:14.270]                           }
[10:26:14.270]                           else {
[10:26:14.270]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:14.270]                               info, version)
[10:26:14.270]                           }
[10:26:14.270]                           base::stop(msg)
[10:26:14.270]                         }
[10:26:14.270]                       })
[10:26:14.270]                     }
[10:26:14.270]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:14.270]                     base::options(mc.cores = 1L)
[10:26:14.270]                   }
[10:26:14.270]                   options(future.plan = NULL)
[10:26:14.270]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:14.270]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:14.270]                 }
[10:26:14.270]                 ...future.workdir <- getwd()
[10:26:14.270]             }
[10:26:14.270]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:14.270]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:14.270]         }
[10:26:14.270]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:14.270]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:14.270]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:14.270]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:14.270]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:14.270]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:14.270]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:14.270]             base::names(...future.oldOptions))
[10:26:14.270]     }
[10:26:14.270]     if (FALSE) {
[10:26:14.270]     }
[10:26:14.270]     else {
[10:26:14.270]         if (TRUE) {
[10:26:14.270]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:14.270]                 open = "w")
[10:26:14.270]         }
[10:26:14.270]         else {
[10:26:14.270]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:14.270]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:14.270]         }
[10:26:14.270]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:14.270]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:14.270]             base::sink(type = "output", split = FALSE)
[10:26:14.270]             base::close(...future.stdout)
[10:26:14.270]         }, add = TRUE)
[10:26:14.270]     }
[10:26:14.270]     ...future.frame <- base::sys.nframe()
[10:26:14.270]     ...future.conditions <- base::list()
[10:26:14.270]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:14.270]     if (FALSE) {
[10:26:14.270]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:14.270]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:14.270]     }
[10:26:14.270]     ...future.result <- base::tryCatch({
[10:26:14.270]         base::withCallingHandlers({
[10:26:14.270]             ...future.value <- base::withVisible(base::local({
[10:26:14.270]                 ...future.makeSendCondition <- base::local({
[10:26:14.270]                   sendCondition <- NULL
[10:26:14.270]                   function(frame = 1L) {
[10:26:14.270]                     if (is.function(sendCondition)) 
[10:26:14.270]                       return(sendCondition)
[10:26:14.270]                     ns <- getNamespace("parallel")
[10:26:14.270]                     if (exists("sendData", mode = "function", 
[10:26:14.270]                       envir = ns)) {
[10:26:14.270]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:14.270]                         envir = ns)
[10:26:14.270]                       envir <- sys.frame(frame)
[10:26:14.270]                       master <- NULL
[10:26:14.270]                       while (!identical(envir, .GlobalEnv) && 
[10:26:14.270]                         !identical(envir, emptyenv())) {
[10:26:14.270]                         if (exists("master", mode = "list", envir = envir, 
[10:26:14.270]                           inherits = FALSE)) {
[10:26:14.270]                           master <- get("master", mode = "list", 
[10:26:14.270]                             envir = envir, inherits = FALSE)
[10:26:14.270]                           if (inherits(master, c("SOCKnode", 
[10:26:14.270]                             "SOCK0node"))) {
[10:26:14.270]                             sendCondition <<- function(cond) {
[10:26:14.270]                               data <- list(type = "VALUE", value = cond, 
[10:26:14.270]                                 success = TRUE)
[10:26:14.270]                               parallel_sendData(master, data)
[10:26:14.270]                             }
[10:26:14.270]                             return(sendCondition)
[10:26:14.270]                           }
[10:26:14.270]                         }
[10:26:14.270]                         frame <- frame + 1L
[10:26:14.270]                         envir <- sys.frame(frame)
[10:26:14.270]                       }
[10:26:14.270]                     }
[10:26:14.270]                     sendCondition <<- function(cond) NULL
[10:26:14.270]                   }
[10:26:14.270]                 })
[10:26:14.270]                 withCallingHandlers({
[10:26:14.270]                   1
[10:26:14.270]                 }, immediateCondition = function(cond) {
[10:26:14.270]                   sendCondition <- ...future.makeSendCondition()
[10:26:14.270]                   sendCondition(cond)
[10:26:14.270]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.270]                   {
[10:26:14.270]                     inherits <- base::inherits
[10:26:14.270]                     invokeRestart <- base::invokeRestart
[10:26:14.270]                     is.null <- base::is.null
[10:26:14.270]                     muffled <- FALSE
[10:26:14.270]                     if (inherits(cond, "message")) {
[10:26:14.270]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:14.270]                       if (muffled) 
[10:26:14.270]                         invokeRestart("muffleMessage")
[10:26:14.270]                     }
[10:26:14.270]                     else if (inherits(cond, "warning")) {
[10:26:14.270]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:14.270]                       if (muffled) 
[10:26:14.270]                         invokeRestart("muffleWarning")
[10:26:14.270]                     }
[10:26:14.270]                     else if (inherits(cond, "condition")) {
[10:26:14.270]                       if (!is.null(pattern)) {
[10:26:14.270]                         computeRestarts <- base::computeRestarts
[10:26:14.270]                         grepl <- base::grepl
[10:26:14.270]                         restarts <- computeRestarts(cond)
[10:26:14.270]                         for (restart in restarts) {
[10:26:14.270]                           name <- restart$name
[10:26:14.270]                           if (is.null(name)) 
[10:26:14.270]                             next
[10:26:14.270]                           if (!grepl(pattern, name)) 
[10:26:14.270]                             next
[10:26:14.270]                           invokeRestart(restart)
[10:26:14.270]                           muffled <- TRUE
[10:26:14.270]                           break
[10:26:14.270]                         }
[10:26:14.270]                       }
[10:26:14.270]                     }
[10:26:14.270]                     invisible(muffled)
[10:26:14.270]                   }
[10:26:14.270]                   muffleCondition(cond)
[10:26:14.270]                 })
[10:26:14.270]             }))
[10:26:14.270]             future::FutureResult(value = ...future.value$value, 
[10:26:14.270]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:14.270]                   ...future.rng), globalenv = if (FALSE) 
[10:26:14.270]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:14.270]                     ...future.globalenv.names))
[10:26:14.270]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:14.270]         }, condition = base::local({
[10:26:14.270]             c <- base::c
[10:26:14.270]             inherits <- base::inherits
[10:26:14.270]             invokeRestart <- base::invokeRestart
[10:26:14.270]             length <- base::length
[10:26:14.270]             list <- base::list
[10:26:14.270]             seq.int <- base::seq.int
[10:26:14.270]             signalCondition <- base::signalCondition
[10:26:14.270]             sys.calls <- base::sys.calls
[10:26:14.270]             `[[` <- base::`[[`
[10:26:14.270]             `+` <- base::`+`
[10:26:14.270]             `<<-` <- base::`<<-`
[10:26:14.270]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:14.270]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:14.270]                   3L)]
[10:26:14.270]             }
[10:26:14.270]             function(cond) {
[10:26:14.270]                 is_error <- inherits(cond, "error")
[10:26:14.270]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:14.270]                   NULL)
[10:26:14.270]                 if (is_error) {
[10:26:14.270]                   sessionInformation <- function() {
[10:26:14.270]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:14.270]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:14.270]                       search = base::search(), system = base::Sys.info())
[10:26:14.270]                   }
[10:26:14.270]                   ...future.conditions[[length(...future.conditions) + 
[10:26:14.270]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:14.270]                     cond$call), session = sessionInformation(), 
[10:26:14.270]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:14.270]                   signalCondition(cond)
[10:26:14.270]                 }
[10:26:14.270]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:14.270]                 "immediateCondition"))) {
[10:26:14.270]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:14.270]                   ...future.conditions[[length(...future.conditions) + 
[10:26:14.270]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:14.270]                   if (TRUE && !signal) {
[10:26:14.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.270]                     {
[10:26:14.270]                       inherits <- base::inherits
[10:26:14.270]                       invokeRestart <- base::invokeRestart
[10:26:14.270]                       is.null <- base::is.null
[10:26:14.270]                       muffled <- FALSE
[10:26:14.270]                       if (inherits(cond, "message")) {
[10:26:14.270]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:14.270]                         if (muffled) 
[10:26:14.270]                           invokeRestart("muffleMessage")
[10:26:14.270]                       }
[10:26:14.270]                       else if (inherits(cond, "warning")) {
[10:26:14.270]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:14.270]                         if (muffled) 
[10:26:14.270]                           invokeRestart("muffleWarning")
[10:26:14.270]                       }
[10:26:14.270]                       else if (inherits(cond, "condition")) {
[10:26:14.270]                         if (!is.null(pattern)) {
[10:26:14.270]                           computeRestarts <- base::computeRestarts
[10:26:14.270]                           grepl <- base::grepl
[10:26:14.270]                           restarts <- computeRestarts(cond)
[10:26:14.270]                           for (restart in restarts) {
[10:26:14.270]                             name <- restart$name
[10:26:14.270]                             if (is.null(name)) 
[10:26:14.270]                               next
[10:26:14.270]                             if (!grepl(pattern, name)) 
[10:26:14.270]                               next
[10:26:14.270]                             invokeRestart(restart)
[10:26:14.270]                             muffled <- TRUE
[10:26:14.270]                             break
[10:26:14.270]                           }
[10:26:14.270]                         }
[10:26:14.270]                       }
[10:26:14.270]                       invisible(muffled)
[10:26:14.270]                     }
[10:26:14.270]                     muffleCondition(cond, pattern = "^muffle")
[10:26:14.270]                   }
[10:26:14.270]                 }
[10:26:14.270]                 else {
[10:26:14.270]                   if (TRUE) {
[10:26:14.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.270]                     {
[10:26:14.270]                       inherits <- base::inherits
[10:26:14.270]                       invokeRestart <- base::invokeRestart
[10:26:14.270]                       is.null <- base::is.null
[10:26:14.270]                       muffled <- FALSE
[10:26:14.270]                       if (inherits(cond, "message")) {
[10:26:14.270]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:14.270]                         if (muffled) 
[10:26:14.270]                           invokeRestart("muffleMessage")
[10:26:14.270]                       }
[10:26:14.270]                       else if (inherits(cond, "warning")) {
[10:26:14.270]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:14.270]                         if (muffled) 
[10:26:14.270]                           invokeRestart("muffleWarning")
[10:26:14.270]                       }
[10:26:14.270]                       else if (inherits(cond, "condition")) {
[10:26:14.270]                         if (!is.null(pattern)) {
[10:26:14.270]                           computeRestarts <- base::computeRestarts
[10:26:14.270]                           grepl <- base::grepl
[10:26:14.270]                           restarts <- computeRestarts(cond)
[10:26:14.270]                           for (restart in restarts) {
[10:26:14.270]                             name <- restart$name
[10:26:14.270]                             if (is.null(name)) 
[10:26:14.270]                               next
[10:26:14.270]                             if (!grepl(pattern, name)) 
[10:26:14.270]                               next
[10:26:14.270]                             invokeRestart(restart)
[10:26:14.270]                             muffled <- TRUE
[10:26:14.270]                             break
[10:26:14.270]                           }
[10:26:14.270]                         }
[10:26:14.270]                       }
[10:26:14.270]                       invisible(muffled)
[10:26:14.270]                     }
[10:26:14.270]                     muffleCondition(cond, pattern = "^muffle")
[10:26:14.270]                   }
[10:26:14.270]                 }
[10:26:14.270]             }
[10:26:14.270]         }))
[10:26:14.270]     }, error = function(ex) {
[10:26:14.270]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:14.270]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:14.270]                 ...future.rng), started = ...future.startTime, 
[10:26:14.270]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:14.270]             version = "1.8"), class = "FutureResult")
[10:26:14.270]     }, finally = {
[10:26:14.270]         if (!identical(...future.workdir, getwd())) 
[10:26:14.270]             setwd(...future.workdir)
[10:26:14.270]         {
[10:26:14.270]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:14.270]                 ...future.oldOptions$nwarnings <- NULL
[10:26:14.270]             }
[10:26:14.270]             base::options(...future.oldOptions)
[10:26:14.270]             if (.Platform$OS.type == "windows") {
[10:26:14.270]                 old_names <- names(...future.oldEnvVars)
[10:26:14.270]                 envs <- base::Sys.getenv()
[10:26:14.270]                 names <- names(envs)
[10:26:14.270]                 common <- intersect(names, old_names)
[10:26:14.270]                 added <- setdiff(names, old_names)
[10:26:14.270]                 removed <- setdiff(old_names, names)
[10:26:14.270]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:14.270]                   envs[common]]
[10:26:14.270]                 NAMES <- toupper(changed)
[10:26:14.270]                 args <- list()
[10:26:14.270]                 for (kk in seq_along(NAMES)) {
[10:26:14.270]                   name <- changed[[kk]]
[10:26:14.270]                   NAME <- NAMES[[kk]]
[10:26:14.270]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.270]                     next
[10:26:14.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:14.270]                 }
[10:26:14.270]                 NAMES <- toupper(added)
[10:26:14.270]                 for (kk in seq_along(NAMES)) {
[10:26:14.270]                   name <- added[[kk]]
[10:26:14.270]                   NAME <- NAMES[[kk]]
[10:26:14.270]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.270]                     next
[10:26:14.270]                   args[[name]] <- ""
[10:26:14.270]                 }
[10:26:14.270]                 NAMES <- toupper(removed)
[10:26:14.270]                 for (kk in seq_along(NAMES)) {
[10:26:14.270]                   name <- removed[[kk]]
[10:26:14.270]                   NAME <- NAMES[[kk]]
[10:26:14.270]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.270]                     next
[10:26:14.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:14.270]                 }
[10:26:14.270]                 if (length(args) > 0) 
[10:26:14.270]                   base::do.call(base::Sys.setenv, args = args)
[10:26:14.270]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:14.270]             }
[10:26:14.270]             else {
[10:26:14.270]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:14.270]             }
[10:26:14.270]             {
[10:26:14.270]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:14.270]                   0L) {
[10:26:14.270]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:14.270]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:14.270]                   base::options(opts)
[10:26:14.270]                 }
[10:26:14.270]                 {
[10:26:14.270]                   {
[10:26:14.270]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:14.270]                     NULL
[10:26:14.270]                   }
[10:26:14.270]                   options(future.plan = NULL)
[10:26:14.270]                   if (is.na(NA_character_)) 
[10:26:14.270]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:14.270]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:14.270]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:14.270]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:14.270]                     envir = parent.frame()) 
[10:26:14.270]                   {
[10:26:14.270]                     if (is.function(workers)) 
[10:26:14.270]                       workers <- workers()
[10:26:14.270]                     workers <- structure(as.integer(workers), 
[10:26:14.270]                       class = class(workers))
[10:26:14.270]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:14.270]                       workers >= 1)
[10:26:14.270]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:14.270]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:14.270]                     }
[10:26:14.270]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:14.270]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:14.270]                       envir = envir)
[10:26:14.270]                     if (!future$lazy) 
[10:26:14.270]                       future <- run(future)
[10:26:14.270]                     invisible(future)
[10:26:14.270]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:14.270]                 }
[10:26:14.270]             }
[10:26:14.270]         }
[10:26:14.270]     })
[10:26:14.270]     if (TRUE) {
[10:26:14.270]         base::sink(type = "output", split = FALSE)
[10:26:14.270]         if (TRUE) {
[10:26:14.270]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:14.270]         }
[10:26:14.270]         else {
[10:26:14.270]             ...future.result["stdout"] <- base::list(NULL)
[10:26:14.270]         }
[10:26:14.270]         base::close(...future.stdout)
[10:26:14.270]         ...future.stdout <- NULL
[10:26:14.270]     }
[10:26:14.270]     ...future.result$conditions <- ...future.conditions
[10:26:14.270]     ...future.result$finished <- base::Sys.time()
[10:26:14.270]     ...future.result
[10:26:14.270] }
[10:26:14.273] MultisessionFuture started
[10:26:14.273] - Launch lazy future ... done
[10:26:14.273] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:14.274] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:14.274] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:14.275] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:14.275] Searching for globals ... DONE
[10:26:14.275] Resolving globals: TRUE
[10:26:14.275] Resolving any globals that are futures ...
[10:26:14.275] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:14.275] Resolving any globals that are futures ... DONE
[10:26:14.275] Resolving futures part of globals (recursively) ...
[10:26:14.276] resolve() on list ...
[10:26:14.276]  recursive: 99
[10:26:14.276]  length: 1
[10:26:14.276]  elements: ‘a’
[10:26:14.318] receiveMessageFromWorker() for ClusterFuture ...
[10:26:14.318] - Validating connection of MultisessionFuture
[10:26:14.319] - received message: FutureResult
[10:26:14.319] - Received FutureResult
[10:26:14.319] - Erased future from FutureRegistry
[10:26:14.319] result() for ClusterFuture ...
[10:26:14.319] - result already collected: FutureResult
[10:26:14.319] result() for ClusterFuture ... done
[10:26:14.319] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:14.319] Future #1
[10:26:14.319] result() for ClusterFuture ...
[10:26:14.320] - result already collected: FutureResult
[10:26:14.320] result() for ClusterFuture ... done
[10:26:14.320] result() for ClusterFuture ...
[10:26:14.320] - result already collected: FutureResult
[10:26:14.320] result() for ClusterFuture ... done
[10:26:14.320] A MultisessionFuture was resolved
[10:26:14.320]  length: 0 (resolved future 1)
[10:26:14.320] resolve() on list ... DONE
[10:26:14.320] - globals: [1] ‘a’
[10:26:14.320] Resolving futures part of globals (recursively) ... DONE
[10:26:14.321] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[10:26:14.322] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[10:26:14.322] - globals: [1] ‘a’
[10:26:14.322] - packages: [1] ‘future’
[10:26:14.322] getGlobalsAndPackages() ... DONE
[10:26:14.322] run() for ‘Future’ ...
[10:26:14.322] - state: ‘created’
[10:26:14.323] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:14.336] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:14.336] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:14.337]   - Field: ‘node’
[10:26:14.337]   - Field: ‘label’
[10:26:14.337]   - Field: ‘local’
[10:26:14.337]   - Field: ‘owner’
[10:26:14.339]   - Field: ‘envir’
[10:26:14.339]   - Field: ‘workers’
[10:26:14.339]   - Field: ‘packages’
[10:26:14.339]   - Field: ‘gc’
[10:26:14.339]   - Field: ‘conditions’
[10:26:14.339]   - Field: ‘persistent’
[10:26:14.339]   - Field: ‘expr’
[10:26:14.339]   - Field: ‘uuid’
[10:26:14.340]   - Field: ‘seed’
[10:26:14.340]   - Field: ‘version’
[10:26:14.340]   - Field: ‘result’
[10:26:14.340]   - Field: ‘asynchronous’
[10:26:14.340]   - Field: ‘calls’
[10:26:14.340]   - Field: ‘globals’
[10:26:14.340]   - Field: ‘stdout’
[10:26:14.340]   - Field: ‘earlySignal’
[10:26:14.340]   - Field: ‘lazy’
[10:26:14.341]   - Field: ‘state’
[10:26:14.341] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:14.341] - Launch lazy future ...
[10:26:14.341] Packages needed by the future expression (n = 1): ‘future’
[10:26:14.341] Packages needed by future strategies (n = 0): <none>
[10:26:14.342] {
[10:26:14.342]     {
[10:26:14.342]         {
[10:26:14.342]             ...future.startTime <- base::Sys.time()
[10:26:14.342]             {
[10:26:14.342]                 {
[10:26:14.342]                   {
[10:26:14.342]                     {
[10:26:14.342]                       {
[10:26:14.342]                         base::local({
[10:26:14.342]                           has_future <- base::requireNamespace("future", 
[10:26:14.342]                             quietly = TRUE)
[10:26:14.342]                           if (has_future) {
[10:26:14.342]                             ns <- base::getNamespace("future")
[10:26:14.342]                             version <- ns[[".package"]][["version"]]
[10:26:14.342]                             if (is.null(version)) 
[10:26:14.342]                               version <- utils::packageVersion("future")
[10:26:14.342]                           }
[10:26:14.342]                           else {
[10:26:14.342]                             version <- NULL
[10:26:14.342]                           }
[10:26:14.342]                           if (!has_future || version < "1.8.0") {
[10:26:14.342]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:14.342]                               "", base::R.version$version.string), 
[10:26:14.342]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:14.342]                                 base::R.version$platform, 8 * 
[10:26:14.342]                                   base::.Machine$sizeof.pointer), 
[10:26:14.342]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:14.342]                                 "release", "version")], collapse = " "), 
[10:26:14.342]                               hostname = base::Sys.info()[["nodename"]])
[10:26:14.342]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:14.342]                               info)
[10:26:14.342]                             info <- base::paste(info, collapse = "; ")
[10:26:14.342]                             if (!has_future) {
[10:26:14.342]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:14.342]                                 info)
[10:26:14.342]                             }
[10:26:14.342]                             else {
[10:26:14.342]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:14.342]                                 info, version)
[10:26:14.342]                             }
[10:26:14.342]                             base::stop(msg)
[10:26:14.342]                           }
[10:26:14.342]                         })
[10:26:14.342]                       }
[10:26:14.342]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:14.342]                       base::options(mc.cores = 1L)
[10:26:14.342]                     }
[10:26:14.342]                     base::local({
[10:26:14.342]                       for (pkg in "future") {
[10:26:14.342]                         base::loadNamespace(pkg)
[10:26:14.342]                         base::library(pkg, character.only = TRUE)
[10:26:14.342]                       }
[10:26:14.342]                     })
[10:26:14.342]                   }
[10:26:14.342]                   options(future.plan = NULL)
[10:26:14.342]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:14.342]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:14.342]                 }
[10:26:14.342]                 ...future.workdir <- getwd()
[10:26:14.342]             }
[10:26:14.342]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:14.342]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:14.342]         }
[10:26:14.342]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:14.342]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:14.342]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:14.342]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:14.342]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:14.342]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:14.342]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:14.342]             base::names(...future.oldOptions))
[10:26:14.342]     }
[10:26:14.342]     if (FALSE) {
[10:26:14.342]     }
[10:26:14.342]     else {
[10:26:14.342]         if (TRUE) {
[10:26:14.342]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:14.342]                 open = "w")
[10:26:14.342]         }
[10:26:14.342]         else {
[10:26:14.342]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:14.342]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:14.342]         }
[10:26:14.342]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:14.342]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:14.342]             base::sink(type = "output", split = FALSE)
[10:26:14.342]             base::close(...future.stdout)
[10:26:14.342]         }, add = TRUE)
[10:26:14.342]     }
[10:26:14.342]     ...future.frame <- base::sys.nframe()
[10:26:14.342]     ...future.conditions <- base::list()
[10:26:14.342]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:14.342]     if (FALSE) {
[10:26:14.342]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:14.342]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:14.342]     }
[10:26:14.342]     ...future.result <- base::tryCatch({
[10:26:14.342]         base::withCallingHandlers({
[10:26:14.342]             ...future.value <- base::withVisible(base::local({
[10:26:14.342]                 ...future.makeSendCondition <- base::local({
[10:26:14.342]                   sendCondition <- NULL
[10:26:14.342]                   function(frame = 1L) {
[10:26:14.342]                     if (is.function(sendCondition)) 
[10:26:14.342]                       return(sendCondition)
[10:26:14.342]                     ns <- getNamespace("parallel")
[10:26:14.342]                     if (exists("sendData", mode = "function", 
[10:26:14.342]                       envir = ns)) {
[10:26:14.342]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:14.342]                         envir = ns)
[10:26:14.342]                       envir <- sys.frame(frame)
[10:26:14.342]                       master <- NULL
[10:26:14.342]                       while (!identical(envir, .GlobalEnv) && 
[10:26:14.342]                         !identical(envir, emptyenv())) {
[10:26:14.342]                         if (exists("master", mode = "list", envir = envir, 
[10:26:14.342]                           inherits = FALSE)) {
[10:26:14.342]                           master <- get("master", mode = "list", 
[10:26:14.342]                             envir = envir, inherits = FALSE)
[10:26:14.342]                           if (inherits(master, c("SOCKnode", 
[10:26:14.342]                             "SOCK0node"))) {
[10:26:14.342]                             sendCondition <<- function(cond) {
[10:26:14.342]                               data <- list(type = "VALUE", value = cond, 
[10:26:14.342]                                 success = TRUE)
[10:26:14.342]                               parallel_sendData(master, data)
[10:26:14.342]                             }
[10:26:14.342]                             return(sendCondition)
[10:26:14.342]                           }
[10:26:14.342]                         }
[10:26:14.342]                         frame <- frame + 1L
[10:26:14.342]                         envir <- sys.frame(frame)
[10:26:14.342]                       }
[10:26:14.342]                     }
[10:26:14.342]                     sendCondition <<- function(cond) NULL
[10:26:14.342]                   }
[10:26:14.342]                 })
[10:26:14.342]                 withCallingHandlers({
[10:26:14.342]                   value(a) + 1
[10:26:14.342]                 }, immediateCondition = function(cond) {
[10:26:14.342]                   sendCondition <- ...future.makeSendCondition()
[10:26:14.342]                   sendCondition(cond)
[10:26:14.342]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.342]                   {
[10:26:14.342]                     inherits <- base::inherits
[10:26:14.342]                     invokeRestart <- base::invokeRestart
[10:26:14.342]                     is.null <- base::is.null
[10:26:14.342]                     muffled <- FALSE
[10:26:14.342]                     if (inherits(cond, "message")) {
[10:26:14.342]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:14.342]                       if (muffled) 
[10:26:14.342]                         invokeRestart("muffleMessage")
[10:26:14.342]                     }
[10:26:14.342]                     else if (inherits(cond, "warning")) {
[10:26:14.342]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:14.342]                       if (muffled) 
[10:26:14.342]                         invokeRestart("muffleWarning")
[10:26:14.342]                     }
[10:26:14.342]                     else if (inherits(cond, "condition")) {
[10:26:14.342]                       if (!is.null(pattern)) {
[10:26:14.342]                         computeRestarts <- base::computeRestarts
[10:26:14.342]                         grepl <- base::grepl
[10:26:14.342]                         restarts <- computeRestarts(cond)
[10:26:14.342]                         for (restart in restarts) {
[10:26:14.342]                           name <- restart$name
[10:26:14.342]                           if (is.null(name)) 
[10:26:14.342]                             next
[10:26:14.342]                           if (!grepl(pattern, name)) 
[10:26:14.342]                             next
[10:26:14.342]                           invokeRestart(restart)
[10:26:14.342]                           muffled <- TRUE
[10:26:14.342]                           break
[10:26:14.342]                         }
[10:26:14.342]                       }
[10:26:14.342]                     }
[10:26:14.342]                     invisible(muffled)
[10:26:14.342]                   }
[10:26:14.342]                   muffleCondition(cond)
[10:26:14.342]                 })
[10:26:14.342]             }))
[10:26:14.342]             future::FutureResult(value = ...future.value$value, 
[10:26:14.342]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:14.342]                   ...future.rng), globalenv = if (FALSE) 
[10:26:14.342]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:14.342]                     ...future.globalenv.names))
[10:26:14.342]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:14.342]         }, condition = base::local({
[10:26:14.342]             c <- base::c
[10:26:14.342]             inherits <- base::inherits
[10:26:14.342]             invokeRestart <- base::invokeRestart
[10:26:14.342]             length <- base::length
[10:26:14.342]             list <- base::list
[10:26:14.342]             seq.int <- base::seq.int
[10:26:14.342]             signalCondition <- base::signalCondition
[10:26:14.342]             sys.calls <- base::sys.calls
[10:26:14.342]             `[[` <- base::`[[`
[10:26:14.342]             `+` <- base::`+`
[10:26:14.342]             `<<-` <- base::`<<-`
[10:26:14.342]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:14.342]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:14.342]                   3L)]
[10:26:14.342]             }
[10:26:14.342]             function(cond) {
[10:26:14.342]                 is_error <- inherits(cond, "error")
[10:26:14.342]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:14.342]                   NULL)
[10:26:14.342]                 if (is_error) {
[10:26:14.342]                   sessionInformation <- function() {
[10:26:14.342]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:14.342]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:14.342]                       search = base::search(), system = base::Sys.info())
[10:26:14.342]                   }
[10:26:14.342]                   ...future.conditions[[length(...future.conditions) + 
[10:26:14.342]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:14.342]                     cond$call), session = sessionInformation(), 
[10:26:14.342]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:14.342]                   signalCondition(cond)
[10:26:14.342]                 }
[10:26:14.342]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:14.342]                 "immediateCondition"))) {
[10:26:14.342]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:14.342]                   ...future.conditions[[length(...future.conditions) + 
[10:26:14.342]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:14.342]                   if (TRUE && !signal) {
[10:26:14.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.342]                     {
[10:26:14.342]                       inherits <- base::inherits
[10:26:14.342]                       invokeRestart <- base::invokeRestart
[10:26:14.342]                       is.null <- base::is.null
[10:26:14.342]                       muffled <- FALSE
[10:26:14.342]                       if (inherits(cond, "message")) {
[10:26:14.342]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:14.342]                         if (muffled) 
[10:26:14.342]                           invokeRestart("muffleMessage")
[10:26:14.342]                       }
[10:26:14.342]                       else if (inherits(cond, "warning")) {
[10:26:14.342]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:14.342]                         if (muffled) 
[10:26:14.342]                           invokeRestart("muffleWarning")
[10:26:14.342]                       }
[10:26:14.342]                       else if (inherits(cond, "condition")) {
[10:26:14.342]                         if (!is.null(pattern)) {
[10:26:14.342]                           computeRestarts <- base::computeRestarts
[10:26:14.342]                           grepl <- base::grepl
[10:26:14.342]                           restarts <- computeRestarts(cond)
[10:26:14.342]                           for (restart in restarts) {
[10:26:14.342]                             name <- restart$name
[10:26:14.342]                             if (is.null(name)) 
[10:26:14.342]                               next
[10:26:14.342]                             if (!grepl(pattern, name)) 
[10:26:14.342]                               next
[10:26:14.342]                             invokeRestart(restart)
[10:26:14.342]                             muffled <- TRUE
[10:26:14.342]                             break
[10:26:14.342]                           }
[10:26:14.342]                         }
[10:26:14.342]                       }
[10:26:14.342]                       invisible(muffled)
[10:26:14.342]                     }
[10:26:14.342]                     muffleCondition(cond, pattern = "^muffle")
[10:26:14.342]                   }
[10:26:14.342]                 }
[10:26:14.342]                 else {
[10:26:14.342]                   if (TRUE) {
[10:26:14.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.342]                     {
[10:26:14.342]                       inherits <- base::inherits
[10:26:14.342]                       invokeRestart <- base::invokeRestart
[10:26:14.342]                       is.null <- base::is.null
[10:26:14.342]                       muffled <- FALSE
[10:26:14.342]                       if (inherits(cond, "message")) {
[10:26:14.342]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:14.342]                         if (muffled) 
[10:26:14.342]                           invokeRestart("muffleMessage")
[10:26:14.342]                       }
[10:26:14.342]                       else if (inherits(cond, "warning")) {
[10:26:14.342]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:14.342]                         if (muffled) 
[10:26:14.342]                           invokeRestart("muffleWarning")
[10:26:14.342]                       }
[10:26:14.342]                       else if (inherits(cond, "condition")) {
[10:26:14.342]                         if (!is.null(pattern)) {
[10:26:14.342]                           computeRestarts <- base::computeRestarts
[10:26:14.342]                           grepl <- base::grepl
[10:26:14.342]                           restarts <- computeRestarts(cond)
[10:26:14.342]                           for (restart in restarts) {
[10:26:14.342]                             name <- restart$name
[10:26:14.342]                             if (is.null(name)) 
[10:26:14.342]                               next
[10:26:14.342]                             if (!grepl(pattern, name)) 
[10:26:14.342]                               next
[10:26:14.342]                             invokeRestart(restart)
[10:26:14.342]                             muffled <- TRUE
[10:26:14.342]                             break
[10:26:14.342]                           }
[10:26:14.342]                         }
[10:26:14.342]                       }
[10:26:14.342]                       invisible(muffled)
[10:26:14.342]                     }
[10:26:14.342]                     muffleCondition(cond, pattern = "^muffle")
[10:26:14.342]                   }
[10:26:14.342]                 }
[10:26:14.342]             }
[10:26:14.342]         }))
[10:26:14.342]     }, error = function(ex) {
[10:26:14.342]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:14.342]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:14.342]                 ...future.rng), started = ...future.startTime, 
[10:26:14.342]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:14.342]             version = "1.8"), class = "FutureResult")
[10:26:14.342]     }, finally = {
[10:26:14.342]         if (!identical(...future.workdir, getwd())) 
[10:26:14.342]             setwd(...future.workdir)
[10:26:14.342]         {
[10:26:14.342]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:14.342]                 ...future.oldOptions$nwarnings <- NULL
[10:26:14.342]             }
[10:26:14.342]             base::options(...future.oldOptions)
[10:26:14.342]             if (.Platform$OS.type == "windows") {
[10:26:14.342]                 old_names <- names(...future.oldEnvVars)
[10:26:14.342]                 envs <- base::Sys.getenv()
[10:26:14.342]                 names <- names(envs)
[10:26:14.342]                 common <- intersect(names, old_names)
[10:26:14.342]                 added <- setdiff(names, old_names)
[10:26:14.342]                 removed <- setdiff(old_names, names)
[10:26:14.342]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:14.342]                   envs[common]]
[10:26:14.342]                 NAMES <- toupper(changed)
[10:26:14.342]                 args <- list()
[10:26:14.342]                 for (kk in seq_along(NAMES)) {
[10:26:14.342]                   name <- changed[[kk]]
[10:26:14.342]                   NAME <- NAMES[[kk]]
[10:26:14.342]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.342]                     next
[10:26:14.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:14.342]                 }
[10:26:14.342]                 NAMES <- toupper(added)
[10:26:14.342]                 for (kk in seq_along(NAMES)) {
[10:26:14.342]                   name <- added[[kk]]
[10:26:14.342]                   NAME <- NAMES[[kk]]
[10:26:14.342]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.342]                     next
[10:26:14.342]                   args[[name]] <- ""
[10:26:14.342]                 }
[10:26:14.342]                 NAMES <- toupper(removed)
[10:26:14.342]                 for (kk in seq_along(NAMES)) {
[10:26:14.342]                   name <- removed[[kk]]
[10:26:14.342]                   NAME <- NAMES[[kk]]
[10:26:14.342]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.342]                     next
[10:26:14.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:14.342]                 }
[10:26:14.342]                 if (length(args) > 0) 
[10:26:14.342]                   base::do.call(base::Sys.setenv, args = args)
[10:26:14.342]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:14.342]             }
[10:26:14.342]             else {
[10:26:14.342]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:14.342]             }
[10:26:14.342]             {
[10:26:14.342]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:14.342]                   0L) {
[10:26:14.342]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:14.342]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:14.342]                   base::options(opts)
[10:26:14.342]                 }
[10:26:14.342]                 {
[10:26:14.342]                   {
[10:26:14.342]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:14.342]                     NULL
[10:26:14.342]                   }
[10:26:14.342]                   options(future.plan = NULL)
[10:26:14.342]                   if (is.na(NA_character_)) 
[10:26:14.342]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:14.342]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:14.342]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:14.342]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:14.342]                     envir = parent.frame()) 
[10:26:14.342]                   {
[10:26:14.342]                     if (is.function(workers)) 
[10:26:14.342]                       workers <- workers()
[10:26:14.342]                     workers <- structure(as.integer(workers), 
[10:26:14.342]                       class = class(workers))
[10:26:14.342]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:14.342]                       workers >= 1)
[10:26:14.342]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:14.342]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:14.342]                     }
[10:26:14.342]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:14.342]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:14.342]                       envir = envir)
[10:26:14.342]                     if (!future$lazy) 
[10:26:14.342]                       future <- run(future)
[10:26:14.342]                     invisible(future)
[10:26:14.342]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:14.342]                 }
[10:26:14.342]             }
[10:26:14.342]         }
[10:26:14.342]     })
[10:26:14.342]     if (TRUE) {
[10:26:14.342]         base::sink(type = "output", split = FALSE)
[10:26:14.342]         if (TRUE) {
[10:26:14.342]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:14.342]         }
[10:26:14.342]         else {
[10:26:14.342]             ...future.result["stdout"] <- base::list(NULL)
[10:26:14.342]         }
[10:26:14.342]         base::close(...future.stdout)
[10:26:14.342]         ...future.stdout <- NULL
[10:26:14.342]     }
[10:26:14.342]     ...future.result$conditions <- ...future.conditions
[10:26:14.342]     ...future.result$finished <- base::Sys.time()
[10:26:14.342]     ...future.result
[10:26:14.342] }
[10:26:14.344] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[10:26:14.345] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[10:26:14.398] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[10:26:14.398] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[10:26:14.399] MultisessionFuture started
[10:26:14.399] - Launch lazy future ... done
[10:26:14.399] run() for ‘MultisessionFuture’ ... done
[10:26:14.399] result() for ClusterFuture ...
[10:26:14.399] receiveMessageFromWorker() for ClusterFuture ...
[10:26:14.399] - Validating connection of MultisessionFuture
[10:26:14.450] - received message: FutureResult
[10:26:14.450] - Received FutureResult
[10:26:14.450] - Erased future from FutureRegistry
[10:26:14.450] result() for ClusterFuture ...
[10:26:14.450] - result already collected: FutureResult
[10:26:14.451] result() for ClusterFuture ... done
[10:26:14.451] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:14.451] result() for ClusterFuture ... done
[10:26:14.451] result() for ClusterFuture ...
[10:26:14.451] - result already collected: FutureResult
[10:26:14.451] result() for ClusterFuture ... done
value(b) = 2
[10:26:14.451] result() for ClusterFuture ...
[10:26:14.451] - result already collected: FutureResult
[10:26:14.451] result() for ClusterFuture ... done
[10:26:14.451] result() for ClusterFuture ...
[10:26:14.452] - result already collected: FutureResult
[10:26:14.452] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:14.452] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:14.452] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:14.453] 
[10:26:14.453] Searching for globals ... DONE
[10:26:14.453] - globals: [0] <none>
[10:26:14.453] getGlobalsAndPackages() ... DONE
[10:26:14.453] run() for ‘Future’ ...
[10:26:14.453] - state: ‘created’
[10:26:14.453] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:14.467] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:14.468] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:14.468]   - Field: ‘node’
[10:26:14.468]   - Field: ‘label’
[10:26:14.468]   - Field: ‘local’
[10:26:14.468]   - Field: ‘owner’
[10:26:14.468]   - Field: ‘envir’
[10:26:14.468]   - Field: ‘workers’
[10:26:14.468]   - Field: ‘packages’
[10:26:14.468]   - Field: ‘gc’
[10:26:14.468]   - Field: ‘conditions’
[10:26:14.469]   - Field: ‘persistent’
[10:26:14.469]   - Field: ‘expr’
[10:26:14.469]   - Field: ‘uuid’
[10:26:14.469]   - Field: ‘seed’
[10:26:14.469]   - Field: ‘version’
[10:26:14.469]   - Field: ‘result’
[10:26:14.469]   - Field: ‘asynchronous’
[10:26:14.469]   - Field: ‘calls’
[10:26:14.469]   - Field: ‘globals’
[10:26:14.469]   - Field: ‘stdout’
[10:26:14.469]   - Field: ‘earlySignal’
[10:26:14.470]   - Field: ‘lazy’
[10:26:14.470]   - Field: ‘state’
[10:26:14.470] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:14.470] - Launch lazy future ...
[10:26:14.470] Packages needed by the future expression (n = 0): <none>
[10:26:14.470] Packages needed by future strategies (n = 0): <none>
[10:26:14.471] {
[10:26:14.471]     {
[10:26:14.471]         {
[10:26:14.471]             ...future.startTime <- base::Sys.time()
[10:26:14.471]             {
[10:26:14.471]                 {
[10:26:14.471]                   {
[10:26:14.471]                     {
[10:26:14.471]                       base::local({
[10:26:14.471]                         has_future <- base::requireNamespace("future", 
[10:26:14.471]                           quietly = TRUE)
[10:26:14.471]                         if (has_future) {
[10:26:14.471]                           ns <- base::getNamespace("future")
[10:26:14.471]                           version <- ns[[".package"]][["version"]]
[10:26:14.471]                           if (is.null(version)) 
[10:26:14.471]                             version <- utils::packageVersion("future")
[10:26:14.471]                         }
[10:26:14.471]                         else {
[10:26:14.471]                           version <- NULL
[10:26:14.471]                         }
[10:26:14.471]                         if (!has_future || version < "1.8.0") {
[10:26:14.471]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:14.471]                             "", base::R.version$version.string), 
[10:26:14.471]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:14.471]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:14.471]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:14.471]                               "release", "version")], collapse = " "), 
[10:26:14.471]                             hostname = base::Sys.info()[["nodename"]])
[10:26:14.471]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:14.471]                             info)
[10:26:14.471]                           info <- base::paste(info, collapse = "; ")
[10:26:14.471]                           if (!has_future) {
[10:26:14.471]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:14.471]                               info)
[10:26:14.471]                           }
[10:26:14.471]                           else {
[10:26:14.471]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:14.471]                               info, version)
[10:26:14.471]                           }
[10:26:14.471]                           base::stop(msg)
[10:26:14.471]                         }
[10:26:14.471]                       })
[10:26:14.471]                     }
[10:26:14.471]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:14.471]                     base::options(mc.cores = 1L)
[10:26:14.471]                   }
[10:26:14.471]                   options(future.plan = NULL)
[10:26:14.471]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:14.471]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:14.471]                 }
[10:26:14.471]                 ...future.workdir <- getwd()
[10:26:14.471]             }
[10:26:14.471]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:14.471]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:14.471]         }
[10:26:14.471]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:14.471]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:14.471]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:14.471]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:14.471]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:14.471]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:14.471]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:14.471]             base::names(...future.oldOptions))
[10:26:14.471]     }
[10:26:14.471]     if (FALSE) {
[10:26:14.471]     }
[10:26:14.471]     else {
[10:26:14.471]         if (TRUE) {
[10:26:14.471]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:14.471]                 open = "w")
[10:26:14.471]         }
[10:26:14.471]         else {
[10:26:14.471]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:14.471]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:14.471]         }
[10:26:14.471]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:14.471]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:14.471]             base::sink(type = "output", split = FALSE)
[10:26:14.471]             base::close(...future.stdout)
[10:26:14.471]         }, add = TRUE)
[10:26:14.471]     }
[10:26:14.471]     ...future.frame <- base::sys.nframe()
[10:26:14.471]     ...future.conditions <- base::list()
[10:26:14.471]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:14.471]     if (FALSE) {
[10:26:14.471]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:14.471]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:14.471]     }
[10:26:14.471]     ...future.result <- base::tryCatch({
[10:26:14.471]         base::withCallingHandlers({
[10:26:14.471]             ...future.value <- base::withVisible(base::local({
[10:26:14.471]                 ...future.makeSendCondition <- base::local({
[10:26:14.471]                   sendCondition <- NULL
[10:26:14.471]                   function(frame = 1L) {
[10:26:14.471]                     if (is.function(sendCondition)) 
[10:26:14.471]                       return(sendCondition)
[10:26:14.471]                     ns <- getNamespace("parallel")
[10:26:14.471]                     if (exists("sendData", mode = "function", 
[10:26:14.471]                       envir = ns)) {
[10:26:14.471]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:14.471]                         envir = ns)
[10:26:14.471]                       envir <- sys.frame(frame)
[10:26:14.471]                       master <- NULL
[10:26:14.471]                       while (!identical(envir, .GlobalEnv) && 
[10:26:14.471]                         !identical(envir, emptyenv())) {
[10:26:14.471]                         if (exists("master", mode = "list", envir = envir, 
[10:26:14.471]                           inherits = FALSE)) {
[10:26:14.471]                           master <- get("master", mode = "list", 
[10:26:14.471]                             envir = envir, inherits = FALSE)
[10:26:14.471]                           if (inherits(master, c("SOCKnode", 
[10:26:14.471]                             "SOCK0node"))) {
[10:26:14.471]                             sendCondition <<- function(cond) {
[10:26:14.471]                               data <- list(type = "VALUE", value = cond, 
[10:26:14.471]                                 success = TRUE)
[10:26:14.471]                               parallel_sendData(master, data)
[10:26:14.471]                             }
[10:26:14.471]                             return(sendCondition)
[10:26:14.471]                           }
[10:26:14.471]                         }
[10:26:14.471]                         frame <- frame + 1L
[10:26:14.471]                         envir <- sys.frame(frame)
[10:26:14.471]                       }
[10:26:14.471]                     }
[10:26:14.471]                     sendCondition <<- function(cond) NULL
[10:26:14.471]                   }
[10:26:14.471]                 })
[10:26:14.471]                 withCallingHandlers({
[10:26:14.471]                   1
[10:26:14.471]                 }, immediateCondition = function(cond) {
[10:26:14.471]                   sendCondition <- ...future.makeSendCondition()
[10:26:14.471]                   sendCondition(cond)
[10:26:14.471]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.471]                   {
[10:26:14.471]                     inherits <- base::inherits
[10:26:14.471]                     invokeRestart <- base::invokeRestart
[10:26:14.471]                     is.null <- base::is.null
[10:26:14.471]                     muffled <- FALSE
[10:26:14.471]                     if (inherits(cond, "message")) {
[10:26:14.471]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:14.471]                       if (muffled) 
[10:26:14.471]                         invokeRestart("muffleMessage")
[10:26:14.471]                     }
[10:26:14.471]                     else if (inherits(cond, "warning")) {
[10:26:14.471]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:14.471]                       if (muffled) 
[10:26:14.471]                         invokeRestart("muffleWarning")
[10:26:14.471]                     }
[10:26:14.471]                     else if (inherits(cond, "condition")) {
[10:26:14.471]                       if (!is.null(pattern)) {
[10:26:14.471]                         computeRestarts <- base::computeRestarts
[10:26:14.471]                         grepl <- base::grepl
[10:26:14.471]                         restarts <- computeRestarts(cond)
[10:26:14.471]                         for (restart in restarts) {
[10:26:14.471]                           name <- restart$name
[10:26:14.471]                           if (is.null(name)) 
[10:26:14.471]                             next
[10:26:14.471]                           if (!grepl(pattern, name)) 
[10:26:14.471]                             next
[10:26:14.471]                           invokeRestart(restart)
[10:26:14.471]                           muffled <- TRUE
[10:26:14.471]                           break
[10:26:14.471]                         }
[10:26:14.471]                       }
[10:26:14.471]                     }
[10:26:14.471]                     invisible(muffled)
[10:26:14.471]                   }
[10:26:14.471]                   muffleCondition(cond)
[10:26:14.471]                 })
[10:26:14.471]             }))
[10:26:14.471]             future::FutureResult(value = ...future.value$value, 
[10:26:14.471]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:14.471]                   ...future.rng), globalenv = if (FALSE) 
[10:26:14.471]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:14.471]                     ...future.globalenv.names))
[10:26:14.471]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:14.471]         }, condition = base::local({
[10:26:14.471]             c <- base::c
[10:26:14.471]             inherits <- base::inherits
[10:26:14.471]             invokeRestart <- base::invokeRestart
[10:26:14.471]             length <- base::length
[10:26:14.471]             list <- base::list
[10:26:14.471]             seq.int <- base::seq.int
[10:26:14.471]             signalCondition <- base::signalCondition
[10:26:14.471]             sys.calls <- base::sys.calls
[10:26:14.471]             `[[` <- base::`[[`
[10:26:14.471]             `+` <- base::`+`
[10:26:14.471]             `<<-` <- base::`<<-`
[10:26:14.471]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:14.471]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:14.471]                   3L)]
[10:26:14.471]             }
[10:26:14.471]             function(cond) {
[10:26:14.471]                 is_error <- inherits(cond, "error")
[10:26:14.471]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:14.471]                   NULL)
[10:26:14.471]                 if (is_error) {
[10:26:14.471]                   sessionInformation <- function() {
[10:26:14.471]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:14.471]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:14.471]                       search = base::search(), system = base::Sys.info())
[10:26:14.471]                   }
[10:26:14.471]                   ...future.conditions[[length(...future.conditions) + 
[10:26:14.471]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:14.471]                     cond$call), session = sessionInformation(), 
[10:26:14.471]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:14.471]                   signalCondition(cond)
[10:26:14.471]                 }
[10:26:14.471]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:14.471]                 "immediateCondition"))) {
[10:26:14.471]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:14.471]                   ...future.conditions[[length(...future.conditions) + 
[10:26:14.471]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:14.471]                   if (TRUE && !signal) {
[10:26:14.471]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.471]                     {
[10:26:14.471]                       inherits <- base::inherits
[10:26:14.471]                       invokeRestart <- base::invokeRestart
[10:26:14.471]                       is.null <- base::is.null
[10:26:14.471]                       muffled <- FALSE
[10:26:14.471]                       if (inherits(cond, "message")) {
[10:26:14.471]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:14.471]                         if (muffled) 
[10:26:14.471]                           invokeRestart("muffleMessage")
[10:26:14.471]                       }
[10:26:14.471]                       else if (inherits(cond, "warning")) {
[10:26:14.471]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:14.471]                         if (muffled) 
[10:26:14.471]                           invokeRestart("muffleWarning")
[10:26:14.471]                       }
[10:26:14.471]                       else if (inherits(cond, "condition")) {
[10:26:14.471]                         if (!is.null(pattern)) {
[10:26:14.471]                           computeRestarts <- base::computeRestarts
[10:26:14.471]                           grepl <- base::grepl
[10:26:14.471]                           restarts <- computeRestarts(cond)
[10:26:14.471]                           for (restart in restarts) {
[10:26:14.471]                             name <- restart$name
[10:26:14.471]                             if (is.null(name)) 
[10:26:14.471]                               next
[10:26:14.471]                             if (!grepl(pattern, name)) 
[10:26:14.471]                               next
[10:26:14.471]                             invokeRestart(restart)
[10:26:14.471]                             muffled <- TRUE
[10:26:14.471]                             break
[10:26:14.471]                           }
[10:26:14.471]                         }
[10:26:14.471]                       }
[10:26:14.471]                       invisible(muffled)
[10:26:14.471]                     }
[10:26:14.471]                     muffleCondition(cond, pattern = "^muffle")
[10:26:14.471]                   }
[10:26:14.471]                 }
[10:26:14.471]                 else {
[10:26:14.471]                   if (TRUE) {
[10:26:14.471]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.471]                     {
[10:26:14.471]                       inherits <- base::inherits
[10:26:14.471]                       invokeRestart <- base::invokeRestart
[10:26:14.471]                       is.null <- base::is.null
[10:26:14.471]                       muffled <- FALSE
[10:26:14.471]                       if (inherits(cond, "message")) {
[10:26:14.471]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:14.471]                         if (muffled) 
[10:26:14.471]                           invokeRestart("muffleMessage")
[10:26:14.471]                       }
[10:26:14.471]                       else if (inherits(cond, "warning")) {
[10:26:14.471]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:14.471]                         if (muffled) 
[10:26:14.471]                           invokeRestart("muffleWarning")
[10:26:14.471]                       }
[10:26:14.471]                       else if (inherits(cond, "condition")) {
[10:26:14.471]                         if (!is.null(pattern)) {
[10:26:14.471]                           computeRestarts <- base::computeRestarts
[10:26:14.471]                           grepl <- base::grepl
[10:26:14.471]                           restarts <- computeRestarts(cond)
[10:26:14.471]                           for (restart in restarts) {
[10:26:14.471]                             name <- restart$name
[10:26:14.471]                             if (is.null(name)) 
[10:26:14.471]                               next
[10:26:14.471]                             if (!grepl(pattern, name)) 
[10:26:14.471]                               next
[10:26:14.471]                             invokeRestart(restart)
[10:26:14.471]                             muffled <- TRUE
[10:26:14.471]                             break
[10:26:14.471]                           }
[10:26:14.471]                         }
[10:26:14.471]                       }
[10:26:14.471]                       invisible(muffled)
[10:26:14.471]                     }
[10:26:14.471]                     muffleCondition(cond, pattern = "^muffle")
[10:26:14.471]                   }
[10:26:14.471]                 }
[10:26:14.471]             }
[10:26:14.471]         }))
[10:26:14.471]     }, error = function(ex) {
[10:26:14.471]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:14.471]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:14.471]                 ...future.rng), started = ...future.startTime, 
[10:26:14.471]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:14.471]             version = "1.8"), class = "FutureResult")
[10:26:14.471]     }, finally = {
[10:26:14.471]         if (!identical(...future.workdir, getwd())) 
[10:26:14.471]             setwd(...future.workdir)
[10:26:14.471]         {
[10:26:14.471]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:14.471]                 ...future.oldOptions$nwarnings <- NULL
[10:26:14.471]             }
[10:26:14.471]             base::options(...future.oldOptions)
[10:26:14.471]             if (.Platform$OS.type == "windows") {
[10:26:14.471]                 old_names <- names(...future.oldEnvVars)
[10:26:14.471]                 envs <- base::Sys.getenv()
[10:26:14.471]                 names <- names(envs)
[10:26:14.471]                 common <- intersect(names, old_names)
[10:26:14.471]                 added <- setdiff(names, old_names)
[10:26:14.471]                 removed <- setdiff(old_names, names)
[10:26:14.471]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:14.471]                   envs[common]]
[10:26:14.471]                 NAMES <- toupper(changed)
[10:26:14.471]                 args <- list()
[10:26:14.471]                 for (kk in seq_along(NAMES)) {
[10:26:14.471]                   name <- changed[[kk]]
[10:26:14.471]                   NAME <- NAMES[[kk]]
[10:26:14.471]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.471]                     next
[10:26:14.471]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:14.471]                 }
[10:26:14.471]                 NAMES <- toupper(added)
[10:26:14.471]                 for (kk in seq_along(NAMES)) {
[10:26:14.471]                   name <- added[[kk]]
[10:26:14.471]                   NAME <- NAMES[[kk]]
[10:26:14.471]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.471]                     next
[10:26:14.471]                   args[[name]] <- ""
[10:26:14.471]                 }
[10:26:14.471]                 NAMES <- toupper(removed)
[10:26:14.471]                 for (kk in seq_along(NAMES)) {
[10:26:14.471]                   name <- removed[[kk]]
[10:26:14.471]                   NAME <- NAMES[[kk]]
[10:26:14.471]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.471]                     next
[10:26:14.471]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:14.471]                 }
[10:26:14.471]                 if (length(args) > 0) 
[10:26:14.471]                   base::do.call(base::Sys.setenv, args = args)
[10:26:14.471]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:14.471]             }
[10:26:14.471]             else {
[10:26:14.471]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:14.471]             }
[10:26:14.471]             {
[10:26:14.471]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:14.471]                   0L) {
[10:26:14.471]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:14.471]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:14.471]                   base::options(opts)
[10:26:14.471]                 }
[10:26:14.471]                 {
[10:26:14.471]                   {
[10:26:14.471]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:14.471]                     NULL
[10:26:14.471]                   }
[10:26:14.471]                   options(future.plan = NULL)
[10:26:14.471]                   if (is.na(NA_character_)) 
[10:26:14.471]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:14.471]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:14.471]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:14.471]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:14.471]                     envir = parent.frame()) 
[10:26:14.471]                   {
[10:26:14.471]                     if (is.function(workers)) 
[10:26:14.471]                       workers <- workers()
[10:26:14.471]                     workers <- structure(as.integer(workers), 
[10:26:14.471]                       class = class(workers))
[10:26:14.471]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:14.471]                       workers >= 1)
[10:26:14.471]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:14.471]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:14.471]                     }
[10:26:14.471]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:14.471]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:14.471]                       envir = envir)
[10:26:14.471]                     if (!future$lazy) 
[10:26:14.471]                       future <- run(future)
[10:26:14.471]                     invisible(future)
[10:26:14.471]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:14.471]                 }
[10:26:14.471]             }
[10:26:14.471]         }
[10:26:14.471]     })
[10:26:14.471]     if (TRUE) {
[10:26:14.471]         base::sink(type = "output", split = FALSE)
[10:26:14.471]         if (TRUE) {
[10:26:14.471]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:14.471]         }
[10:26:14.471]         else {
[10:26:14.471]             ...future.result["stdout"] <- base::list(NULL)
[10:26:14.471]         }
[10:26:14.471]         base::close(...future.stdout)
[10:26:14.471]         ...future.stdout <- NULL
[10:26:14.471]     }
[10:26:14.471]     ...future.result$conditions <- ...future.conditions
[10:26:14.471]     ...future.result$finished <- base::Sys.time()
[10:26:14.471]     ...future.result
[10:26:14.471] }
[10:26:14.473] MultisessionFuture started
[10:26:14.474] - Launch lazy future ... done
[10:26:14.474] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:14.474] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:14.474] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:14.475] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:14.475] Searching for globals ... DONE
[10:26:14.475] Resolving globals: TRUE
[10:26:14.475] Resolving any globals that are futures ...
[10:26:14.475] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:14.475] Resolving any globals that are futures ... DONE
[10:26:14.476] Resolving futures part of globals (recursively) ...
[10:26:14.476] resolve() on list ...
[10:26:14.476]  recursive: 99
[10:26:14.476]  length: 1
[10:26:14.476]  elements: ‘a’
[10:26:14.518] receiveMessageFromWorker() for ClusterFuture ...
[10:26:14.518] - Validating connection of MultisessionFuture
[10:26:14.518] - received message: FutureResult
[10:26:14.518] - Received FutureResult
[10:26:14.518] - Erased future from FutureRegistry
[10:26:14.519] result() for ClusterFuture ...
[10:26:14.519] - result already collected: FutureResult
[10:26:14.519] result() for ClusterFuture ... done
[10:26:14.519] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:14.519] Future #1
[10:26:14.519] result() for ClusterFuture ...
[10:26:14.519] - result already collected: FutureResult
[10:26:14.519] result() for ClusterFuture ... done
[10:26:14.519] result() for ClusterFuture ...
[10:26:14.519] - result already collected: FutureResult
[10:26:14.520] result() for ClusterFuture ... done
[10:26:14.520] A MultisessionFuture was resolved
[10:26:14.520]  length: 0 (resolved future 1)
[10:26:14.520] resolve() on list ... DONE
[10:26:14.520] - globals: [1] ‘a’
[10:26:14.520] Resolving futures part of globals (recursively) ... DONE
[10:26:14.521] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[10:26:14.521] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[10:26:14.521] - globals: [1] ‘a’
[10:26:14.522] - packages: [1] ‘future’
[10:26:14.522] getGlobalsAndPackages() ... DONE
[10:26:14.522] run() for ‘Future’ ...
[10:26:14.522] - state: ‘created’
[10:26:14.522] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:14.536] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:14.536] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:14.536]   - Field: ‘node’
[10:26:14.536]   - Field: ‘label’
[10:26:14.536]   - Field: ‘local’
[10:26:14.536]   - Field: ‘owner’
[10:26:14.536]   - Field: ‘envir’
[10:26:14.537]   - Field: ‘workers’
[10:26:14.537]   - Field: ‘packages’
[10:26:14.537]   - Field: ‘gc’
[10:26:14.537]   - Field: ‘conditions’
[10:26:14.537]   - Field: ‘persistent’
[10:26:14.537]   - Field: ‘expr’
[10:26:14.537]   - Field: ‘uuid’
[10:26:14.537]   - Field: ‘seed’
[10:26:14.537]   - Field: ‘version’
[10:26:14.537]   - Field: ‘result’
[10:26:14.537]   - Field: ‘asynchronous’
[10:26:14.538]   - Field: ‘calls’
[10:26:14.538]   - Field: ‘globals’
[10:26:14.538]   - Field: ‘stdout’
[10:26:14.538]   - Field: ‘earlySignal’
[10:26:14.538]   - Field: ‘lazy’
[10:26:14.538]   - Field: ‘state’
[10:26:14.538] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:14.538] - Launch lazy future ...
[10:26:14.538] Packages needed by the future expression (n = 1): ‘future’
[10:26:14.539] Packages needed by future strategies (n = 0): <none>
[10:26:14.539] {
[10:26:14.539]     {
[10:26:14.539]         {
[10:26:14.539]             ...future.startTime <- base::Sys.time()
[10:26:14.539]             {
[10:26:14.539]                 {
[10:26:14.539]                   {
[10:26:14.539]                     {
[10:26:14.539]                       {
[10:26:14.539]                         base::local({
[10:26:14.539]                           has_future <- base::requireNamespace("future", 
[10:26:14.539]                             quietly = TRUE)
[10:26:14.539]                           if (has_future) {
[10:26:14.539]                             ns <- base::getNamespace("future")
[10:26:14.539]                             version <- ns[[".package"]][["version"]]
[10:26:14.539]                             if (is.null(version)) 
[10:26:14.539]                               version <- utils::packageVersion("future")
[10:26:14.539]                           }
[10:26:14.539]                           else {
[10:26:14.539]                             version <- NULL
[10:26:14.539]                           }
[10:26:14.539]                           if (!has_future || version < "1.8.0") {
[10:26:14.539]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:14.539]                               "", base::R.version$version.string), 
[10:26:14.539]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:14.539]                                 base::R.version$platform, 8 * 
[10:26:14.539]                                   base::.Machine$sizeof.pointer), 
[10:26:14.539]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:14.539]                                 "release", "version")], collapse = " "), 
[10:26:14.539]                               hostname = base::Sys.info()[["nodename"]])
[10:26:14.539]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:14.539]                               info)
[10:26:14.539]                             info <- base::paste(info, collapse = "; ")
[10:26:14.539]                             if (!has_future) {
[10:26:14.539]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:14.539]                                 info)
[10:26:14.539]                             }
[10:26:14.539]                             else {
[10:26:14.539]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:14.539]                                 info, version)
[10:26:14.539]                             }
[10:26:14.539]                             base::stop(msg)
[10:26:14.539]                           }
[10:26:14.539]                         })
[10:26:14.539]                       }
[10:26:14.539]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:14.539]                       base::options(mc.cores = 1L)
[10:26:14.539]                     }
[10:26:14.539]                     base::local({
[10:26:14.539]                       for (pkg in "future") {
[10:26:14.539]                         base::loadNamespace(pkg)
[10:26:14.539]                         base::library(pkg, character.only = TRUE)
[10:26:14.539]                       }
[10:26:14.539]                     })
[10:26:14.539]                   }
[10:26:14.539]                   options(future.plan = NULL)
[10:26:14.539]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:14.539]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:14.539]                 }
[10:26:14.539]                 ...future.workdir <- getwd()
[10:26:14.539]             }
[10:26:14.539]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:14.539]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:14.539]         }
[10:26:14.539]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:14.539]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:14.539]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:14.539]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:14.539]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:14.539]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:14.539]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:14.539]             base::names(...future.oldOptions))
[10:26:14.539]     }
[10:26:14.539]     if (FALSE) {
[10:26:14.539]     }
[10:26:14.539]     else {
[10:26:14.539]         if (TRUE) {
[10:26:14.539]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:14.539]                 open = "w")
[10:26:14.539]         }
[10:26:14.539]         else {
[10:26:14.539]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:14.539]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:14.539]         }
[10:26:14.539]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:14.539]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:14.539]             base::sink(type = "output", split = FALSE)
[10:26:14.539]             base::close(...future.stdout)
[10:26:14.539]         }, add = TRUE)
[10:26:14.539]     }
[10:26:14.539]     ...future.frame <- base::sys.nframe()
[10:26:14.539]     ...future.conditions <- base::list()
[10:26:14.539]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:14.539]     if (FALSE) {
[10:26:14.539]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:14.539]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:14.539]     }
[10:26:14.539]     ...future.result <- base::tryCatch({
[10:26:14.539]         base::withCallingHandlers({
[10:26:14.539]             ...future.value <- base::withVisible(base::local({
[10:26:14.539]                 ...future.makeSendCondition <- base::local({
[10:26:14.539]                   sendCondition <- NULL
[10:26:14.539]                   function(frame = 1L) {
[10:26:14.539]                     if (is.function(sendCondition)) 
[10:26:14.539]                       return(sendCondition)
[10:26:14.539]                     ns <- getNamespace("parallel")
[10:26:14.539]                     if (exists("sendData", mode = "function", 
[10:26:14.539]                       envir = ns)) {
[10:26:14.539]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:14.539]                         envir = ns)
[10:26:14.539]                       envir <- sys.frame(frame)
[10:26:14.539]                       master <- NULL
[10:26:14.539]                       while (!identical(envir, .GlobalEnv) && 
[10:26:14.539]                         !identical(envir, emptyenv())) {
[10:26:14.539]                         if (exists("master", mode = "list", envir = envir, 
[10:26:14.539]                           inherits = FALSE)) {
[10:26:14.539]                           master <- get("master", mode = "list", 
[10:26:14.539]                             envir = envir, inherits = FALSE)
[10:26:14.539]                           if (inherits(master, c("SOCKnode", 
[10:26:14.539]                             "SOCK0node"))) {
[10:26:14.539]                             sendCondition <<- function(cond) {
[10:26:14.539]                               data <- list(type = "VALUE", value = cond, 
[10:26:14.539]                                 success = TRUE)
[10:26:14.539]                               parallel_sendData(master, data)
[10:26:14.539]                             }
[10:26:14.539]                             return(sendCondition)
[10:26:14.539]                           }
[10:26:14.539]                         }
[10:26:14.539]                         frame <- frame + 1L
[10:26:14.539]                         envir <- sys.frame(frame)
[10:26:14.539]                       }
[10:26:14.539]                     }
[10:26:14.539]                     sendCondition <<- function(cond) NULL
[10:26:14.539]                   }
[10:26:14.539]                 })
[10:26:14.539]                 withCallingHandlers({
[10:26:14.539]                   value(a) + 1
[10:26:14.539]                 }, immediateCondition = function(cond) {
[10:26:14.539]                   sendCondition <- ...future.makeSendCondition()
[10:26:14.539]                   sendCondition(cond)
[10:26:14.539]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.539]                   {
[10:26:14.539]                     inherits <- base::inherits
[10:26:14.539]                     invokeRestart <- base::invokeRestart
[10:26:14.539]                     is.null <- base::is.null
[10:26:14.539]                     muffled <- FALSE
[10:26:14.539]                     if (inherits(cond, "message")) {
[10:26:14.539]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:14.539]                       if (muffled) 
[10:26:14.539]                         invokeRestart("muffleMessage")
[10:26:14.539]                     }
[10:26:14.539]                     else if (inherits(cond, "warning")) {
[10:26:14.539]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:14.539]                       if (muffled) 
[10:26:14.539]                         invokeRestart("muffleWarning")
[10:26:14.539]                     }
[10:26:14.539]                     else if (inherits(cond, "condition")) {
[10:26:14.539]                       if (!is.null(pattern)) {
[10:26:14.539]                         computeRestarts <- base::computeRestarts
[10:26:14.539]                         grepl <- base::grepl
[10:26:14.539]                         restarts <- computeRestarts(cond)
[10:26:14.539]                         for (restart in restarts) {
[10:26:14.539]                           name <- restart$name
[10:26:14.539]                           if (is.null(name)) 
[10:26:14.539]                             next
[10:26:14.539]                           if (!grepl(pattern, name)) 
[10:26:14.539]                             next
[10:26:14.539]                           invokeRestart(restart)
[10:26:14.539]                           muffled <- TRUE
[10:26:14.539]                           break
[10:26:14.539]                         }
[10:26:14.539]                       }
[10:26:14.539]                     }
[10:26:14.539]                     invisible(muffled)
[10:26:14.539]                   }
[10:26:14.539]                   muffleCondition(cond)
[10:26:14.539]                 })
[10:26:14.539]             }))
[10:26:14.539]             future::FutureResult(value = ...future.value$value, 
[10:26:14.539]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:14.539]                   ...future.rng), globalenv = if (FALSE) 
[10:26:14.539]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:14.539]                     ...future.globalenv.names))
[10:26:14.539]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:14.539]         }, condition = base::local({
[10:26:14.539]             c <- base::c
[10:26:14.539]             inherits <- base::inherits
[10:26:14.539]             invokeRestart <- base::invokeRestart
[10:26:14.539]             length <- base::length
[10:26:14.539]             list <- base::list
[10:26:14.539]             seq.int <- base::seq.int
[10:26:14.539]             signalCondition <- base::signalCondition
[10:26:14.539]             sys.calls <- base::sys.calls
[10:26:14.539]             `[[` <- base::`[[`
[10:26:14.539]             `+` <- base::`+`
[10:26:14.539]             `<<-` <- base::`<<-`
[10:26:14.539]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:14.539]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:14.539]                   3L)]
[10:26:14.539]             }
[10:26:14.539]             function(cond) {
[10:26:14.539]                 is_error <- inherits(cond, "error")
[10:26:14.539]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:14.539]                   NULL)
[10:26:14.539]                 if (is_error) {
[10:26:14.539]                   sessionInformation <- function() {
[10:26:14.539]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:14.539]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:14.539]                       search = base::search(), system = base::Sys.info())
[10:26:14.539]                   }
[10:26:14.539]                   ...future.conditions[[length(...future.conditions) + 
[10:26:14.539]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:14.539]                     cond$call), session = sessionInformation(), 
[10:26:14.539]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:14.539]                   signalCondition(cond)
[10:26:14.539]                 }
[10:26:14.539]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:14.539]                 "immediateCondition"))) {
[10:26:14.539]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:14.539]                   ...future.conditions[[length(...future.conditions) + 
[10:26:14.539]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:14.539]                   if (TRUE && !signal) {
[10:26:14.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.539]                     {
[10:26:14.539]                       inherits <- base::inherits
[10:26:14.539]                       invokeRestart <- base::invokeRestart
[10:26:14.539]                       is.null <- base::is.null
[10:26:14.539]                       muffled <- FALSE
[10:26:14.539]                       if (inherits(cond, "message")) {
[10:26:14.539]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:14.539]                         if (muffled) 
[10:26:14.539]                           invokeRestart("muffleMessage")
[10:26:14.539]                       }
[10:26:14.539]                       else if (inherits(cond, "warning")) {
[10:26:14.539]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:14.539]                         if (muffled) 
[10:26:14.539]                           invokeRestart("muffleWarning")
[10:26:14.539]                       }
[10:26:14.539]                       else if (inherits(cond, "condition")) {
[10:26:14.539]                         if (!is.null(pattern)) {
[10:26:14.539]                           computeRestarts <- base::computeRestarts
[10:26:14.539]                           grepl <- base::grepl
[10:26:14.539]                           restarts <- computeRestarts(cond)
[10:26:14.539]                           for (restart in restarts) {
[10:26:14.539]                             name <- restart$name
[10:26:14.539]                             if (is.null(name)) 
[10:26:14.539]                               next
[10:26:14.539]                             if (!grepl(pattern, name)) 
[10:26:14.539]                               next
[10:26:14.539]                             invokeRestart(restart)
[10:26:14.539]                             muffled <- TRUE
[10:26:14.539]                             break
[10:26:14.539]                           }
[10:26:14.539]                         }
[10:26:14.539]                       }
[10:26:14.539]                       invisible(muffled)
[10:26:14.539]                     }
[10:26:14.539]                     muffleCondition(cond, pattern = "^muffle")
[10:26:14.539]                   }
[10:26:14.539]                 }
[10:26:14.539]                 else {
[10:26:14.539]                   if (TRUE) {
[10:26:14.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.539]                     {
[10:26:14.539]                       inherits <- base::inherits
[10:26:14.539]                       invokeRestart <- base::invokeRestart
[10:26:14.539]                       is.null <- base::is.null
[10:26:14.539]                       muffled <- FALSE
[10:26:14.539]                       if (inherits(cond, "message")) {
[10:26:14.539]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:14.539]                         if (muffled) 
[10:26:14.539]                           invokeRestart("muffleMessage")
[10:26:14.539]                       }
[10:26:14.539]                       else if (inherits(cond, "warning")) {
[10:26:14.539]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:14.539]                         if (muffled) 
[10:26:14.539]                           invokeRestart("muffleWarning")
[10:26:14.539]                       }
[10:26:14.539]                       else if (inherits(cond, "condition")) {
[10:26:14.539]                         if (!is.null(pattern)) {
[10:26:14.539]                           computeRestarts <- base::computeRestarts
[10:26:14.539]                           grepl <- base::grepl
[10:26:14.539]                           restarts <- computeRestarts(cond)
[10:26:14.539]                           for (restart in restarts) {
[10:26:14.539]                             name <- restart$name
[10:26:14.539]                             if (is.null(name)) 
[10:26:14.539]                               next
[10:26:14.539]                             if (!grepl(pattern, name)) 
[10:26:14.539]                               next
[10:26:14.539]                             invokeRestart(restart)
[10:26:14.539]                             muffled <- TRUE
[10:26:14.539]                             break
[10:26:14.539]                           }
[10:26:14.539]                         }
[10:26:14.539]                       }
[10:26:14.539]                       invisible(muffled)
[10:26:14.539]                     }
[10:26:14.539]                     muffleCondition(cond, pattern = "^muffle")
[10:26:14.539]                   }
[10:26:14.539]                 }
[10:26:14.539]             }
[10:26:14.539]         }))
[10:26:14.539]     }, error = function(ex) {
[10:26:14.539]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:14.539]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:14.539]                 ...future.rng), started = ...future.startTime, 
[10:26:14.539]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:14.539]             version = "1.8"), class = "FutureResult")
[10:26:14.539]     }, finally = {
[10:26:14.539]         if (!identical(...future.workdir, getwd())) 
[10:26:14.539]             setwd(...future.workdir)
[10:26:14.539]         {
[10:26:14.539]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:14.539]                 ...future.oldOptions$nwarnings <- NULL
[10:26:14.539]             }
[10:26:14.539]             base::options(...future.oldOptions)
[10:26:14.539]             if (.Platform$OS.type == "windows") {
[10:26:14.539]                 old_names <- names(...future.oldEnvVars)
[10:26:14.539]                 envs <- base::Sys.getenv()
[10:26:14.539]                 names <- names(envs)
[10:26:14.539]                 common <- intersect(names, old_names)
[10:26:14.539]                 added <- setdiff(names, old_names)
[10:26:14.539]                 removed <- setdiff(old_names, names)
[10:26:14.539]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:14.539]                   envs[common]]
[10:26:14.539]                 NAMES <- toupper(changed)
[10:26:14.539]                 args <- list()
[10:26:14.539]                 for (kk in seq_along(NAMES)) {
[10:26:14.539]                   name <- changed[[kk]]
[10:26:14.539]                   NAME <- NAMES[[kk]]
[10:26:14.539]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.539]                     next
[10:26:14.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:14.539]                 }
[10:26:14.539]                 NAMES <- toupper(added)
[10:26:14.539]                 for (kk in seq_along(NAMES)) {
[10:26:14.539]                   name <- added[[kk]]
[10:26:14.539]                   NAME <- NAMES[[kk]]
[10:26:14.539]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.539]                     next
[10:26:14.539]                   args[[name]] <- ""
[10:26:14.539]                 }
[10:26:14.539]                 NAMES <- toupper(removed)
[10:26:14.539]                 for (kk in seq_along(NAMES)) {
[10:26:14.539]                   name <- removed[[kk]]
[10:26:14.539]                   NAME <- NAMES[[kk]]
[10:26:14.539]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.539]                     next
[10:26:14.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:14.539]                 }
[10:26:14.539]                 if (length(args) > 0) 
[10:26:14.539]                   base::do.call(base::Sys.setenv, args = args)
[10:26:14.539]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:14.539]             }
[10:26:14.539]             else {
[10:26:14.539]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:14.539]             }
[10:26:14.539]             {
[10:26:14.539]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:14.539]                   0L) {
[10:26:14.539]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:14.539]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:14.539]                   base::options(opts)
[10:26:14.539]                 }
[10:26:14.539]                 {
[10:26:14.539]                   {
[10:26:14.539]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:14.539]                     NULL
[10:26:14.539]                   }
[10:26:14.539]                   options(future.plan = NULL)
[10:26:14.539]                   if (is.na(NA_character_)) 
[10:26:14.539]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:14.539]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:14.539]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:14.539]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:14.539]                     envir = parent.frame()) 
[10:26:14.539]                   {
[10:26:14.539]                     if (is.function(workers)) 
[10:26:14.539]                       workers <- workers()
[10:26:14.539]                     workers <- structure(as.integer(workers), 
[10:26:14.539]                       class = class(workers))
[10:26:14.539]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:14.539]                       workers >= 1)
[10:26:14.539]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:14.539]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:14.539]                     }
[10:26:14.539]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:14.539]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:14.539]                       envir = envir)
[10:26:14.539]                     if (!future$lazy) 
[10:26:14.539]                       future <- run(future)
[10:26:14.539]                     invisible(future)
[10:26:14.539]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:14.539]                 }
[10:26:14.539]             }
[10:26:14.539]         }
[10:26:14.539]     })
[10:26:14.539]     if (TRUE) {
[10:26:14.539]         base::sink(type = "output", split = FALSE)
[10:26:14.539]         if (TRUE) {
[10:26:14.539]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:14.539]         }
[10:26:14.539]         else {
[10:26:14.539]             ...future.result["stdout"] <- base::list(NULL)
[10:26:14.539]         }
[10:26:14.539]         base::close(...future.stdout)
[10:26:14.539]         ...future.stdout <- NULL
[10:26:14.539]     }
[10:26:14.539]     ...future.result$conditions <- ...future.conditions
[10:26:14.539]     ...future.result$finished <- base::Sys.time()
[10:26:14.539]     ...future.result
[10:26:14.539] }
[10:26:14.542] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[10:26:14.543] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[10:26:14.594] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[10:26:14.594] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[10:26:14.595] MultisessionFuture started
[10:26:14.595] - Launch lazy future ... done
[10:26:14.595] run() for ‘MultisessionFuture’ ... done
[10:26:14.595] result() for ClusterFuture ...
[10:26:14.595] receiveMessageFromWorker() for ClusterFuture ...
[10:26:14.595] - Validating connection of MultisessionFuture
[10:26:14.643] - received message: FutureResult
[10:26:14.643] - Received FutureResult
[10:26:14.643] - Erased future from FutureRegistry
[10:26:14.643] result() for ClusterFuture ...
[10:26:14.643] - result already collected: FutureResult
[10:26:14.643] result() for ClusterFuture ... done
[10:26:14.643] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:14.644] result() for ClusterFuture ... done
[10:26:14.644] result() for ClusterFuture ...
[10:26:14.644] - result already collected: FutureResult
[10:26:14.644] result() for ClusterFuture ... done
value(b) = 2
[10:26:14.644] result() for ClusterFuture ...
[10:26:14.644] - result already collected: FutureResult
[10:26:14.644] result() for ClusterFuture ... done
[10:26:14.644] result() for ClusterFuture ...
[10:26:14.644] - result already collected: FutureResult
[10:26:14.644] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:14.645] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:14.645] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:14.645] 
[10:26:14.646] Searching for globals ... DONE
[10:26:14.646] - globals: [0] <none>
[10:26:14.646] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:14.646] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:14.646] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:14.647] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:14.647] Searching for globals ... DONE
[10:26:14.647] Resolving globals: TRUE
[10:26:14.647] Resolving any globals that are futures ...
[10:26:14.648] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:14.648] Resolving any globals that are futures ... DONE
[10:26:14.648] Resolving futures part of globals (recursively) ...
[10:26:14.648] resolve() on list ...
[10:26:14.648]  recursive: 99
[10:26:14.648]  length: 1
[10:26:14.648]  elements: ‘a’
[10:26:14.649] run() for ‘Future’ ...
[10:26:14.649] - state: ‘created’
[10:26:14.649] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:14.663] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:14.663] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:14.663]   - Field: ‘node’
[10:26:14.663]   - Field: ‘label’
[10:26:14.663]   - Field: ‘local’
[10:26:14.663]   - Field: ‘owner’
[10:26:14.664]   - Field: ‘envir’
[10:26:14.664]   - Field: ‘workers’
[10:26:14.664]   - Field: ‘packages’
[10:26:14.664]   - Field: ‘gc’
[10:26:14.664]   - Field: ‘conditions’
[10:26:14.664]   - Field: ‘persistent’
[10:26:14.664]   - Field: ‘expr’
[10:26:14.664]   - Field: ‘uuid’
[10:26:14.664]   - Field: ‘seed’
[10:26:14.664]   - Field: ‘version’
[10:26:14.664]   - Field: ‘result’
[10:26:14.665]   - Field: ‘asynchronous’
[10:26:14.665]   - Field: ‘calls’
[10:26:14.665]   - Field: ‘globals’
[10:26:14.665]   - Field: ‘stdout’
[10:26:14.665]   - Field: ‘earlySignal’
[10:26:14.665]   - Field: ‘lazy’
[10:26:14.665]   - Field: ‘state’
[10:26:14.665] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:14.665] - Launch lazy future ...
[10:26:14.666] Packages needed by the future expression (n = 0): <none>
[10:26:14.666] Packages needed by future strategies (n = 0): <none>
[10:26:14.666] {
[10:26:14.666]     {
[10:26:14.666]         {
[10:26:14.666]             ...future.startTime <- base::Sys.time()
[10:26:14.666]             {
[10:26:14.666]                 {
[10:26:14.666]                   {
[10:26:14.666]                     {
[10:26:14.666]                       base::local({
[10:26:14.666]                         has_future <- base::requireNamespace("future", 
[10:26:14.666]                           quietly = TRUE)
[10:26:14.666]                         if (has_future) {
[10:26:14.666]                           ns <- base::getNamespace("future")
[10:26:14.666]                           version <- ns[[".package"]][["version"]]
[10:26:14.666]                           if (is.null(version)) 
[10:26:14.666]                             version <- utils::packageVersion("future")
[10:26:14.666]                         }
[10:26:14.666]                         else {
[10:26:14.666]                           version <- NULL
[10:26:14.666]                         }
[10:26:14.666]                         if (!has_future || version < "1.8.0") {
[10:26:14.666]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:14.666]                             "", base::R.version$version.string), 
[10:26:14.666]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:14.666]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:14.666]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:14.666]                               "release", "version")], collapse = " "), 
[10:26:14.666]                             hostname = base::Sys.info()[["nodename"]])
[10:26:14.666]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:14.666]                             info)
[10:26:14.666]                           info <- base::paste(info, collapse = "; ")
[10:26:14.666]                           if (!has_future) {
[10:26:14.666]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:14.666]                               info)
[10:26:14.666]                           }
[10:26:14.666]                           else {
[10:26:14.666]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:14.666]                               info, version)
[10:26:14.666]                           }
[10:26:14.666]                           base::stop(msg)
[10:26:14.666]                         }
[10:26:14.666]                       })
[10:26:14.666]                     }
[10:26:14.666]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:14.666]                     base::options(mc.cores = 1L)
[10:26:14.666]                   }
[10:26:14.666]                   options(future.plan = NULL)
[10:26:14.666]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:14.666]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:14.666]                 }
[10:26:14.666]                 ...future.workdir <- getwd()
[10:26:14.666]             }
[10:26:14.666]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:14.666]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:14.666]         }
[10:26:14.666]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:14.666]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:14.666]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:14.666]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:14.666]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:14.666]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:14.666]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:14.666]             base::names(...future.oldOptions))
[10:26:14.666]     }
[10:26:14.666]     if (FALSE) {
[10:26:14.666]     }
[10:26:14.666]     else {
[10:26:14.666]         if (TRUE) {
[10:26:14.666]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:14.666]                 open = "w")
[10:26:14.666]         }
[10:26:14.666]         else {
[10:26:14.666]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:14.666]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:14.666]         }
[10:26:14.666]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:14.666]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:14.666]             base::sink(type = "output", split = FALSE)
[10:26:14.666]             base::close(...future.stdout)
[10:26:14.666]         }, add = TRUE)
[10:26:14.666]     }
[10:26:14.666]     ...future.frame <- base::sys.nframe()
[10:26:14.666]     ...future.conditions <- base::list()
[10:26:14.666]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:14.666]     if (FALSE) {
[10:26:14.666]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:14.666]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:14.666]     }
[10:26:14.666]     ...future.result <- base::tryCatch({
[10:26:14.666]         base::withCallingHandlers({
[10:26:14.666]             ...future.value <- base::withVisible(base::local({
[10:26:14.666]                 ...future.makeSendCondition <- base::local({
[10:26:14.666]                   sendCondition <- NULL
[10:26:14.666]                   function(frame = 1L) {
[10:26:14.666]                     if (is.function(sendCondition)) 
[10:26:14.666]                       return(sendCondition)
[10:26:14.666]                     ns <- getNamespace("parallel")
[10:26:14.666]                     if (exists("sendData", mode = "function", 
[10:26:14.666]                       envir = ns)) {
[10:26:14.666]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:14.666]                         envir = ns)
[10:26:14.666]                       envir <- sys.frame(frame)
[10:26:14.666]                       master <- NULL
[10:26:14.666]                       while (!identical(envir, .GlobalEnv) && 
[10:26:14.666]                         !identical(envir, emptyenv())) {
[10:26:14.666]                         if (exists("master", mode = "list", envir = envir, 
[10:26:14.666]                           inherits = FALSE)) {
[10:26:14.666]                           master <- get("master", mode = "list", 
[10:26:14.666]                             envir = envir, inherits = FALSE)
[10:26:14.666]                           if (inherits(master, c("SOCKnode", 
[10:26:14.666]                             "SOCK0node"))) {
[10:26:14.666]                             sendCondition <<- function(cond) {
[10:26:14.666]                               data <- list(type = "VALUE", value = cond, 
[10:26:14.666]                                 success = TRUE)
[10:26:14.666]                               parallel_sendData(master, data)
[10:26:14.666]                             }
[10:26:14.666]                             return(sendCondition)
[10:26:14.666]                           }
[10:26:14.666]                         }
[10:26:14.666]                         frame <- frame + 1L
[10:26:14.666]                         envir <- sys.frame(frame)
[10:26:14.666]                       }
[10:26:14.666]                     }
[10:26:14.666]                     sendCondition <<- function(cond) NULL
[10:26:14.666]                   }
[10:26:14.666]                 })
[10:26:14.666]                 withCallingHandlers({
[10:26:14.666]                   1
[10:26:14.666]                 }, immediateCondition = function(cond) {
[10:26:14.666]                   sendCondition <- ...future.makeSendCondition()
[10:26:14.666]                   sendCondition(cond)
[10:26:14.666]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.666]                   {
[10:26:14.666]                     inherits <- base::inherits
[10:26:14.666]                     invokeRestart <- base::invokeRestart
[10:26:14.666]                     is.null <- base::is.null
[10:26:14.666]                     muffled <- FALSE
[10:26:14.666]                     if (inherits(cond, "message")) {
[10:26:14.666]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:14.666]                       if (muffled) 
[10:26:14.666]                         invokeRestart("muffleMessage")
[10:26:14.666]                     }
[10:26:14.666]                     else if (inherits(cond, "warning")) {
[10:26:14.666]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:14.666]                       if (muffled) 
[10:26:14.666]                         invokeRestart("muffleWarning")
[10:26:14.666]                     }
[10:26:14.666]                     else if (inherits(cond, "condition")) {
[10:26:14.666]                       if (!is.null(pattern)) {
[10:26:14.666]                         computeRestarts <- base::computeRestarts
[10:26:14.666]                         grepl <- base::grepl
[10:26:14.666]                         restarts <- computeRestarts(cond)
[10:26:14.666]                         for (restart in restarts) {
[10:26:14.666]                           name <- restart$name
[10:26:14.666]                           if (is.null(name)) 
[10:26:14.666]                             next
[10:26:14.666]                           if (!grepl(pattern, name)) 
[10:26:14.666]                             next
[10:26:14.666]                           invokeRestart(restart)
[10:26:14.666]                           muffled <- TRUE
[10:26:14.666]                           break
[10:26:14.666]                         }
[10:26:14.666]                       }
[10:26:14.666]                     }
[10:26:14.666]                     invisible(muffled)
[10:26:14.666]                   }
[10:26:14.666]                   muffleCondition(cond)
[10:26:14.666]                 })
[10:26:14.666]             }))
[10:26:14.666]             future::FutureResult(value = ...future.value$value, 
[10:26:14.666]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:14.666]                   ...future.rng), globalenv = if (FALSE) 
[10:26:14.666]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:14.666]                     ...future.globalenv.names))
[10:26:14.666]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:14.666]         }, condition = base::local({
[10:26:14.666]             c <- base::c
[10:26:14.666]             inherits <- base::inherits
[10:26:14.666]             invokeRestart <- base::invokeRestart
[10:26:14.666]             length <- base::length
[10:26:14.666]             list <- base::list
[10:26:14.666]             seq.int <- base::seq.int
[10:26:14.666]             signalCondition <- base::signalCondition
[10:26:14.666]             sys.calls <- base::sys.calls
[10:26:14.666]             `[[` <- base::`[[`
[10:26:14.666]             `+` <- base::`+`
[10:26:14.666]             `<<-` <- base::`<<-`
[10:26:14.666]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:14.666]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:14.666]                   3L)]
[10:26:14.666]             }
[10:26:14.666]             function(cond) {
[10:26:14.666]                 is_error <- inherits(cond, "error")
[10:26:14.666]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:14.666]                   NULL)
[10:26:14.666]                 if (is_error) {
[10:26:14.666]                   sessionInformation <- function() {
[10:26:14.666]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:14.666]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:14.666]                       search = base::search(), system = base::Sys.info())
[10:26:14.666]                   }
[10:26:14.666]                   ...future.conditions[[length(...future.conditions) + 
[10:26:14.666]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:14.666]                     cond$call), session = sessionInformation(), 
[10:26:14.666]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:14.666]                   signalCondition(cond)
[10:26:14.666]                 }
[10:26:14.666]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:14.666]                 "immediateCondition"))) {
[10:26:14.666]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:14.666]                   ...future.conditions[[length(...future.conditions) + 
[10:26:14.666]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:14.666]                   if (TRUE && !signal) {
[10:26:14.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.666]                     {
[10:26:14.666]                       inherits <- base::inherits
[10:26:14.666]                       invokeRestart <- base::invokeRestart
[10:26:14.666]                       is.null <- base::is.null
[10:26:14.666]                       muffled <- FALSE
[10:26:14.666]                       if (inherits(cond, "message")) {
[10:26:14.666]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:14.666]                         if (muffled) 
[10:26:14.666]                           invokeRestart("muffleMessage")
[10:26:14.666]                       }
[10:26:14.666]                       else if (inherits(cond, "warning")) {
[10:26:14.666]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:14.666]                         if (muffled) 
[10:26:14.666]                           invokeRestart("muffleWarning")
[10:26:14.666]                       }
[10:26:14.666]                       else if (inherits(cond, "condition")) {
[10:26:14.666]                         if (!is.null(pattern)) {
[10:26:14.666]                           computeRestarts <- base::computeRestarts
[10:26:14.666]                           grepl <- base::grepl
[10:26:14.666]                           restarts <- computeRestarts(cond)
[10:26:14.666]                           for (restart in restarts) {
[10:26:14.666]                             name <- restart$name
[10:26:14.666]                             if (is.null(name)) 
[10:26:14.666]                               next
[10:26:14.666]                             if (!grepl(pattern, name)) 
[10:26:14.666]                               next
[10:26:14.666]                             invokeRestart(restart)
[10:26:14.666]                             muffled <- TRUE
[10:26:14.666]                             break
[10:26:14.666]                           }
[10:26:14.666]                         }
[10:26:14.666]                       }
[10:26:14.666]                       invisible(muffled)
[10:26:14.666]                     }
[10:26:14.666]                     muffleCondition(cond, pattern = "^muffle")
[10:26:14.666]                   }
[10:26:14.666]                 }
[10:26:14.666]                 else {
[10:26:14.666]                   if (TRUE) {
[10:26:14.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.666]                     {
[10:26:14.666]                       inherits <- base::inherits
[10:26:14.666]                       invokeRestart <- base::invokeRestart
[10:26:14.666]                       is.null <- base::is.null
[10:26:14.666]                       muffled <- FALSE
[10:26:14.666]                       if (inherits(cond, "message")) {
[10:26:14.666]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:14.666]                         if (muffled) 
[10:26:14.666]                           invokeRestart("muffleMessage")
[10:26:14.666]                       }
[10:26:14.666]                       else if (inherits(cond, "warning")) {
[10:26:14.666]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:14.666]                         if (muffled) 
[10:26:14.666]                           invokeRestart("muffleWarning")
[10:26:14.666]                       }
[10:26:14.666]                       else if (inherits(cond, "condition")) {
[10:26:14.666]                         if (!is.null(pattern)) {
[10:26:14.666]                           computeRestarts <- base::computeRestarts
[10:26:14.666]                           grepl <- base::grepl
[10:26:14.666]                           restarts <- computeRestarts(cond)
[10:26:14.666]                           for (restart in restarts) {
[10:26:14.666]                             name <- restart$name
[10:26:14.666]                             if (is.null(name)) 
[10:26:14.666]                               next
[10:26:14.666]                             if (!grepl(pattern, name)) 
[10:26:14.666]                               next
[10:26:14.666]                             invokeRestart(restart)
[10:26:14.666]                             muffled <- TRUE
[10:26:14.666]                             break
[10:26:14.666]                           }
[10:26:14.666]                         }
[10:26:14.666]                       }
[10:26:14.666]                       invisible(muffled)
[10:26:14.666]                     }
[10:26:14.666]                     muffleCondition(cond, pattern = "^muffle")
[10:26:14.666]                   }
[10:26:14.666]                 }
[10:26:14.666]             }
[10:26:14.666]         }))
[10:26:14.666]     }, error = function(ex) {
[10:26:14.666]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:14.666]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:14.666]                 ...future.rng), started = ...future.startTime, 
[10:26:14.666]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:14.666]             version = "1.8"), class = "FutureResult")
[10:26:14.666]     }, finally = {
[10:26:14.666]         if (!identical(...future.workdir, getwd())) 
[10:26:14.666]             setwd(...future.workdir)
[10:26:14.666]         {
[10:26:14.666]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:14.666]                 ...future.oldOptions$nwarnings <- NULL
[10:26:14.666]             }
[10:26:14.666]             base::options(...future.oldOptions)
[10:26:14.666]             if (.Platform$OS.type == "windows") {
[10:26:14.666]                 old_names <- names(...future.oldEnvVars)
[10:26:14.666]                 envs <- base::Sys.getenv()
[10:26:14.666]                 names <- names(envs)
[10:26:14.666]                 common <- intersect(names, old_names)
[10:26:14.666]                 added <- setdiff(names, old_names)
[10:26:14.666]                 removed <- setdiff(old_names, names)
[10:26:14.666]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:14.666]                   envs[common]]
[10:26:14.666]                 NAMES <- toupper(changed)
[10:26:14.666]                 args <- list()
[10:26:14.666]                 for (kk in seq_along(NAMES)) {
[10:26:14.666]                   name <- changed[[kk]]
[10:26:14.666]                   NAME <- NAMES[[kk]]
[10:26:14.666]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.666]                     next
[10:26:14.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:14.666]                 }
[10:26:14.666]                 NAMES <- toupper(added)
[10:26:14.666]                 for (kk in seq_along(NAMES)) {
[10:26:14.666]                   name <- added[[kk]]
[10:26:14.666]                   NAME <- NAMES[[kk]]
[10:26:14.666]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.666]                     next
[10:26:14.666]                   args[[name]] <- ""
[10:26:14.666]                 }
[10:26:14.666]                 NAMES <- toupper(removed)
[10:26:14.666]                 for (kk in seq_along(NAMES)) {
[10:26:14.666]                   name <- removed[[kk]]
[10:26:14.666]                   NAME <- NAMES[[kk]]
[10:26:14.666]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.666]                     next
[10:26:14.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:14.666]                 }
[10:26:14.666]                 if (length(args) > 0) 
[10:26:14.666]                   base::do.call(base::Sys.setenv, args = args)
[10:26:14.666]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:14.666]             }
[10:26:14.666]             else {
[10:26:14.666]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:14.666]             }
[10:26:14.666]             {
[10:26:14.666]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:14.666]                   0L) {
[10:26:14.666]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:14.666]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:14.666]                   base::options(opts)
[10:26:14.666]                 }
[10:26:14.666]                 {
[10:26:14.666]                   {
[10:26:14.666]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:14.666]                     NULL
[10:26:14.666]                   }
[10:26:14.666]                   options(future.plan = NULL)
[10:26:14.666]                   if (is.na(NA_character_)) 
[10:26:14.666]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:14.666]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:14.666]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:14.666]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:14.666]                     envir = parent.frame()) 
[10:26:14.666]                   {
[10:26:14.666]                     if (is.function(workers)) 
[10:26:14.666]                       workers <- workers()
[10:26:14.666]                     workers <- structure(as.integer(workers), 
[10:26:14.666]                       class = class(workers))
[10:26:14.666]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:14.666]                       workers >= 1)
[10:26:14.666]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:14.666]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:14.666]                     }
[10:26:14.666]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:14.666]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:14.666]                       envir = envir)
[10:26:14.666]                     if (!future$lazy) 
[10:26:14.666]                       future <- run(future)
[10:26:14.666]                     invisible(future)
[10:26:14.666]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:14.666]                 }
[10:26:14.666]             }
[10:26:14.666]         }
[10:26:14.666]     })
[10:26:14.666]     if (TRUE) {
[10:26:14.666]         base::sink(type = "output", split = FALSE)
[10:26:14.666]         if (TRUE) {
[10:26:14.666]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:14.666]         }
[10:26:14.666]         else {
[10:26:14.666]             ...future.result["stdout"] <- base::list(NULL)
[10:26:14.666]         }
[10:26:14.666]         base::close(...future.stdout)
[10:26:14.666]         ...future.stdout <- NULL
[10:26:14.666]     }
[10:26:14.666]     ...future.result$conditions <- ...future.conditions
[10:26:14.666]     ...future.result$finished <- base::Sys.time()
[10:26:14.666]     ...future.result
[10:26:14.666] }
[10:26:14.669] MultisessionFuture started
[10:26:14.670] - Launch lazy future ... done
[10:26:14.670] run() for ‘MultisessionFuture’ ... done
[10:26:14.715] receiveMessageFromWorker() for ClusterFuture ...
[10:26:14.715] - Validating connection of MultisessionFuture
[10:26:14.715] - received message: FutureResult
[10:26:14.715] - Received FutureResult
[10:26:14.715] - Erased future from FutureRegistry
[10:26:14.715] result() for ClusterFuture ...
[10:26:14.715] - result already collected: FutureResult
[10:26:14.716] result() for ClusterFuture ... done
[10:26:14.716] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:14.716] Future #1
[10:26:14.716] result() for ClusterFuture ...
[10:26:14.716] - result already collected: FutureResult
[10:26:14.716] result() for ClusterFuture ... done
[10:26:14.716] result() for ClusterFuture ...
[10:26:14.716] - result already collected: FutureResult
[10:26:14.716] result() for ClusterFuture ... done
[10:26:14.716] A MultisessionFuture was resolved
[10:26:14.717]  length: 0 (resolved future 1)
[10:26:14.717] resolve() on list ... DONE
[10:26:14.717] - globals: [1] ‘a’
[10:26:14.717] Resolving futures part of globals (recursively) ... DONE
[10:26:14.718] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[10:26:14.718] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[10:26:14.718] - globals: [1] ‘a’
[10:26:14.718] - packages: [1] ‘future’
[10:26:14.719] getGlobalsAndPackages() ... DONE
[10:26:14.719] run() for ‘Future’ ...
[10:26:14.719] - state: ‘created’
[10:26:14.719] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:14.733] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:14.733] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:14.733]   - Field: ‘node’
[10:26:14.733]   - Field: ‘label’
[10:26:14.733]   - Field: ‘local’
[10:26:14.733]   - Field: ‘owner’
[10:26:14.734]   - Field: ‘envir’
[10:26:14.734]   - Field: ‘workers’
[10:26:14.734]   - Field: ‘packages’
[10:26:14.734]   - Field: ‘gc’
[10:26:14.734]   - Field: ‘conditions’
[10:26:14.734]   - Field: ‘persistent’
[10:26:14.734]   - Field: ‘expr’
[10:26:14.734]   - Field: ‘uuid’
[10:26:14.734]   - Field: ‘seed’
[10:26:14.734]   - Field: ‘version’
[10:26:14.735]   - Field: ‘result’
[10:26:14.735]   - Field: ‘asynchronous’
[10:26:14.735]   - Field: ‘calls’
[10:26:14.735]   - Field: ‘globals’
[10:26:14.735]   - Field: ‘stdout’
[10:26:14.735]   - Field: ‘earlySignal’
[10:26:14.735]   - Field: ‘lazy’
[10:26:14.735]   - Field: ‘state’
[10:26:14.735] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:14.735] - Launch lazy future ...
[10:26:14.736] Packages needed by the future expression (n = 1): ‘future’
[10:26:14.736] Packages needed by future strategies (n = 0): <none>
[10:26:14.736] {
[10:26:14.736]     {
[10:26:14.736]         {
[10:26:14.736]             ...future.startTime <- base::Sys.time()
[10:26:14.736]             {
[10:26:14.736]                 {
[10:26:14.736]                   {
[10:26:14.736]                     {
[10:26:14.736]                       {
[10:26:14.736]                         base::local({
[10:26:14.736]                           has_future <- base::requireNamespace("future", 
[10:26:14.736]                             quietly = TRUE)
[10:26:14.736]                           if (has_future) {
[10:26:14.736]                             ns <- base::getNamespace("future")
[10:26:14.736]                             version <- ns[[".package"]][["version"]]
[10:26:14.736]                             if (is.null(version)) 
[10:26:14.736]                               version <- utils::packageVersion("future")
[10:26:14.736]                           }
[10:26:14.736]                           else {
[10:26:14.736]                             version <- NULL
[10:26:14.736]                           }
[10:26:14.736]                           if (!has_future || version < "1.8.0") {
[10:26:14.736]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:14.736]                               "", base::R.version$version.string), 
[10:26:14.736]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:14.736]                                 base::R.version$platform, 8 * 
[10:26:14.736]                                   base::.Machine$sizeof.pointer), 
[10:26:14.736]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:14.736]                                 "release", "version")], collapse = " "), 
[10:26:14.736]                               hostname = base::Sys.info()[["nodename"]])
[10:26:14.736]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:14.736]                               info)
[10:26:14.736]                             info <- base::paste(info, collapse = "; ")
[10:26:14.736]                             if (!has_future) {
[10:26:14.736]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:14.736]                                 info)
[10:26:14.736]                             }
[10:26:14.736]                             else {
[10:26:14.736]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:14.736]                                 info, version)
[10:26:14.736]                             }
[10:26:14.736]                             base::stop(msg)
[10:26:14.736]                           }
[10:26:14.736]                         })
[10:26:14.736]                       }
[10:26:14.736]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:14.736]                       base::options(mc.cores = 1L)
[10:26:14.736]                     }
[10:26:14.736]                     base::local({
[10:26:14.736]                       for (pkg in "future") {
[10:26:14.736]                         base::loadNamespace(pkg)
[10:26:14.736]                         base::library(pkg, character.only = TRUE)
[10:26:14.736]                       }
[10:26:14.736]                     })
[10:26:14.736]                   }
[10:26:14.736]                   options(future.plan = NULL)
[10:26:14.736]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:14.736]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:14.736]                 }
[10:26:14.736]                 ...future.workdir <- getwd()
[10:26:14.736]             }
[10:26:14.736]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:14.736]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:14.736]         }
[10:26:14.736]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:14.736]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:14.736]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:14.736]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:14.736]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:14.736]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:14.736]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:14.736]             base::names(...future.oldOptions))
[10:26:14.736]     }
[10:26:14.736]     if (FALSE) {
[10:26:14.736]     }
[10:26:14.736]     else {
[10:26:14.736]         if (TRUE) {
[10:26:14.736]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:14.736]                 open = "w")
[10:26:14.736]         }
[10:26:14.736]         else {
[10:26:14.736]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:14.736]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:14.736]         }
[10:26:14.736]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:14.736]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:14.736]             base::sink(type = "output", split = FALSE)
[10:26:14.736]             base::close(...future.stdout)
[10:26:14.736]         }, add = TRUE)
[10:26:14.736]     }
[10:26:14.736]     ...future.frame <- base::sys.nframe()
[10:26:14.736]     ...future.conditions <- base::list()
[10:26:14.736]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:14.736]     if (FALSE) {
[10:26:14.736]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:14.736]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:14.736]     }
[10:26:14.736]     ...future.result <- base::tryCatch({
[10:26:14.736]         base::withCallingHandlers({
[10:26:14.736]             ...future.value <- base::withVisible(base::local({
[10:26:14.736]                 ...future.makeSendCondition <- base::local({
[10:26:14.736]                   sendCondition <- NULL
[10:26:14.736]                   function(frame = 1L) {
[10:26:14.736]                     if (is.function(sendCondition)) 
[10:26:14.736]                       return(sendCondition)
[10:26:14.736]                     ns <- getNamespace("parallel")
[10:26:14.736]                     if (exists("sendData", mode = "function", 
[10:26:14.736]                       envir = ns)) {
[10:26:14.736]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:14.736]                         envir = ns)
[10:26:14.736]                       envir <- sys.frame(frame)
[10:26:14.736]                       master <- NULL
[10:26:14.736]                       while (!identical(envir, .GlobalEnv) && 
[10:26:14.736]                         !identical(envir, emptyenv())) {
[10:26:14.736]                         if (exists("master", mode = "list", envir = envir, 
[10:26:14.736]                           inherits = FALSE)) {
[10:26:14.736]                           master <- get("master", mode = "list", 
[10:26:14.736]                             envir = envir, inherits = FALSE)
[10:26:14.736]                           if (inherits(master, c("SOCKnode", 
[10:26:14.736]                             "SOCK0node"))) {
[10:26:14.736]                             sendCondition <<- function(cond) {
[10:26:14.736]                               data <- list(type = "VALUE", value = cond, 
[10:26:14.736]                                 success = TRUE)
[10:26:14.736]                               parallel_sendData(master, data)
[10:26:14.736]                             }
[10:26:14.736]                             return(sendCondition)
[10:26:14.736]                           }
[10:26:14.736]                         }
[10:26:14.736]                         frame <- frame + 1L
[10:26:14.736]                         envir <- sys.frame(frame)
[10:26:14.736]                       }
[10:26:14.736]                     }
[10:26:14.736]                     sendCondition <<- function(cond) NULL
[10:26:14.736]                   }
[10:26:14.736]                 })
[10:26:14.736]                 withCallingHandlers({
[10:26:14.736]                   value(a) + 1
[10:26:14.736]                 }, immediateCondition = function(cond) {
[10:26:14.736]                   sendCondition <- ...future.makeSendCondition()
[10:26:14.736]                   sendCondition(cond)
[10:26:14.736]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.736]                   {
[10:26:14.736]                     inherits <- base::inherits
[10:26:14.736]                     invokeRestart <- base::invokeRestart
[10:26:14.736]                     is.null <- base::is.null
[10:26:14.736]                     muffled <- FALSE
[10:26:14.736]                     if (inherits(cond, "message")) {
[10:26:14.736]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:14.736]                       if (muffled) 
[10:26:14.736]                         invokeRestart("muffleMessage")
[10:26:14.736]                     }
[10:26:14.736]                     else if (inherits(cond, "warning")) {
[10:26:14.736]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:14.736]                       if (muffled) 
[10:26:14.736]                         invokeRestart("muffleWarning")
[10:26:14.736]                     }
[10:26:14.736]                     else if (inherits(cond, "condition")) {
[10:26:14.736]                       if (!is.null(pattern)) {
[10:26:14.736]                         computeRestarts <- base::computeRestarts
[10:26:14.736]                         grepl <- base::grepl
[10:26:14.736]                         restarts <- computeRestarts(cond)
[10:26:14.736]                         for (restart in restarts) {
[10:26:14.736]                           name <- restart$name
[10:26:14.736]                           if (is.null(name)) 
[10:26:14.736]                             next
[10:26:14.736]                           if (!grepl(pattern, name)) 
[10:26:14.736]                             next
[10:26:14.736]                           invokeRestart(restart)
[10:26:14.736]                           muffled <- TRUE
[10:26:14.736]                           break
[10:26:14.736]                         }
[10:26:14.736]                       }
[10:26:14.736]                     }
[10:26:14.736]                     invisible(muffled)
[10:26:14.736]                   }
[10:26:14.736]                   muffleCondition(cond)
[10:26:14.736]                 })
[10:26:14.736]             }))
[10:26:14.736]             future::FutureResult(value = ...future.value$value, 
[10:26:14.736]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:14.736]                   ...future.rng), globalenv = if (FALSE) 
[10:26:14.736]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:14.736]                     ...future.globalenv.names))
[10:26:14.736]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:14.736]         }, condition = base::local({
[10:26:14.736]             c <- base::c
[10:26:14.736]             inherits <- base::inherits
[10:26:14.736]             invokeRestart <- base::invokeRestart
[10:26:14.736]             length <- base::length
[10:26:14.736]             list <- base::list
[10:26:14.736]             seq.int <- base::seq.int
[10:26:14.736]             signalCondition <- base::signalCondition
[10:26:14.736]             sys.calls <- base::sys.calls
[10:26:14.736]             `[[` <- base::`[[`
[10:26:14.736]             `+` <- base::`+`
[10:26:14.736]             `<<-` <- base::`<<-`
[10:26:14.736]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:14.736]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:14.736]                   3L)]
[10:26:14.736]             }
[10:26:14.736]             function(cond) {
[10:26:14.736]                 is_error <- inherits(cond, "error")
[10:26:14.736]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:14.736]                   NULL)
[10:26:14.736]                 if (is_error) {
[10:26:14.736]                   sessionInformation <- function() {
[10:26:14.736]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:14.736]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:14.736]                       search = base::search(), system = base::Sys.info())
[10:26:14.736]                   }
[10:26:14.736]                   ...future.conditions[[length(...future.conditions) + 
[10:26:14.736]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:14.736]                     cond$call), session = sessionInformation(), 
[10:26:14.736]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:14.736]                   signalCondition(cond)
[10:26:14.736]                 }
[10:26:14.736]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:14.736]                 "immediateCondition"))) {
[10:26:14.736]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:14.736]                   ...future.conditions[[length(...future.conditions) + 
[10:26:14.736]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:14.736]                   if (TRUE && !signal) {
[10:26:14.736]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.736]                     {
[10:26:14.736]                       inherits <- base::inherits
[10:26:14.736]                       invokeRestart <- base::invokeRestart
[10:26:14.736]                       is.null <- base::is.null
[10:26:14.736]                       muffled <- FALSE
[10:26:14.736]                       if (inherits(cond, "message")) {
[10:26:14.736]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:14.736]                         if (muffled) 
[10:26:14.736]                           invokeRestart("muffleMessage")
[10:26:14.736]                       }
[10:26:14.736]                       else if (inherits(cond, "warning")) {
[10:26:14.736]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:14.736]                         if (muffled) 
[10:26:14.736]                           invokeRestart("muffleWarning")
[10:26:14.736]                       }
[10:26:14.736]                       else if (inherits(cond, "condition")) {
[10:26:14.736]                         if (!is.null(pattern)) {
[10:26:14.736]                           computeRestarts <- base::computeRestarts
[10:26:14.736]                           grepl <- base::grepl
[10:26:14.736]                           restarts <- computeRestarts(cond)
[10:26:14.736]                           for (restart in restarts) {
[10:26:14.736]                             name <- restart$name
[10:26:14.736]                             if (is.null(name)) 
[10:26:14.736]                               next
[10:26:14.736]                             if (!grepl(pattern, name)) 
[10:26:14.736]                               next
[10:26:14.736]                             invokeRestart(restart)
[10:26:14.736]                             muffled <- TRUE
[10:26:14.736]                             break
[10:26:14.736]                           }
[10:26:14.736]                         }
[10:26:14.736]                       }
[10:26:14.736]                       invisible(muffled)
[10:26:14.736]                     }
[10:26:14.736]                     muffleCondition(cond, pattern = "^muffle")
[10:26:14.736]                   }
[10:26:14.736]                 }
[10:26:14.736]                 else {
[10:26:14.736]                   if (TRUE) {
[10:26:14.736]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.736]                     {
[10:26:14.736]                       inherits <- base::inherits
[10:26:14.736]                       invokeRestart <- base::invokeRestart
[10:26:14.736]                       is.null <- base::is.null
[10:26:14.736]                       muffled <- FALSE
[10:26:14.736]                       if (inherits(cond, "message")) {
[10:26:14.736]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:14.736]                         if (muffled) 
[10:26:14.736]                           invokeRestart("muffleMessage")
[10:26:14.736]                       }
[10:26:14.736]                       else if (inherits(cond, "warning")) {
[10:26:14.736]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:14.736]                         if (muffled) 
[10:26:14.736]                           invokeRestart("muffleWarning")
[10:26:14.736]                       }
[10:26:14.736]                       else if (inherits(cond, "condition")) {
[10:26:14.736]                         if (!is.null(pattern)) {
[10:26:14.736]                           computeRestarts <- base::computeRestarts
[10:26:14.736]                           grepl <- base::grepl
[10:26:14.736]                           restarts <- computeRestarts(cond)
[10:26:14.736]                           for (restart in restarts) {
[10:26:14.736]                             name <- restart$name
[10:26:14.736]                             if (is.null(name)) 
[10:26:14.736]                               next
[10:26:14.736]                             if (!grepl(pattern, name)) 
[10:26:14.736]                               next
[10:26:14.736]                             invokeRestart(restart)
[10:26:14.736]                             muffled <- TRUE
[10:26:14.736]                             break
[10:26:14.736]                           }
[10:26:14.736]                         }
[10:26:14.736]                       }
[10:26:14.736]                       invisible(muffled)
[10:26:14.736]                     }
[10:26:14.736]                     muffleCondition(cond, pattern = "^muffle")
[10:26:14.736]                   }
[10:26:14.736]                 }
[10:26:14.736]             }
[10:26:14.736]         }))
[10:26:14.736]     }, error = function(ex) {
[10:26:14.736]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:14.736]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:14.736]                 ...future.rng), started = ...future.startTime, 
[10:26:14.736]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:14.736]             version = "1.8"), class = "FutureResult")
[10:26:14.736]     }, finally = {
[10:26:14.736]         if (!identical(...future.workdir, getwd())) 
[10:26:14.736]             setwd(...future.workdir)
[10:26:14.736]         {
[10:26:14.736]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:14.736]                 ...future.oldOptions$nwarnings <- NULL
[10:26:14.736]             }
[10:26:14.736]             base::options(...future.oldOptions)
[10:26:14.736]             if (.Platform$OS.type == "windows") {
[10:26:14.736]                 old_names <- names(...future.oldEnvVars)
[10:26:14.736]                 envs <- base::Sys.getenv()
[10:26:14.736]                 names <- names(envs)
[10:26:14.736]                 common <- intersect(names, old_names)
[10:26:14.736]                 added <- setdiff(names, old_names)
[10:26:14.736]                 removed <- setdiff(old_names, names)
[10:26:14.736]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:14.736]                   envs[common]]
[10:26:14.736]                 NAMES <- toupper(changed)
[10:26:14.736]                 args <- list()
[10:26:14.736]                 for (kk in seq_along(NAMES)) {
[10:26:14.736]                   name <- changed[[kk]]
[10:26:14.736]                   NAME <- NAMES[[kk]]
[10:26:14.736]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.736]                     next
[10:26:14.736]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:14.736]                 }
[10:26:14.736]                 NAMES <- toupper(added)
[10:26:14.736]                 for (kk in seq_along(NAMES)) {
[10:26:14.736]                   name <- added[[kk]]
[10:26:14.736]                   NAME <- NAMES[[kk]]
[10:26:14.736]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.736]                     next
[10:26:14.736]                   args[[name]] <- ""
[10:26:14.736]                 }
[10:26:14.736]                 NAMES <- toupper(removed)
[10:26:14.736]                 for (kk in seq_along(NAMES)) {
[10:26:14.736]                   name <- removed[[kk]]
[10:26:14.736]                   NAME <- NAMES[[kk]]
[10:26:14.736]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.736]                     next
[10:26:14.736]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:14.736]                 }
[10:26:14.736]                 if (length(args) > 0) 
[10:26:14.736]                   base::do.call(base::Sys.setenv, args = args)
[10:26:14.736]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:14.736]             }
[10:26:14.736]             else {
[10:26:14.736]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:14.736]             }
[10:26:14.736]             {
[10:26:14.736]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:14.736]                   0L) {
[10:26:14.736]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:14.736]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:14.736]                   base::options(opts)
[10:26:14.736]                 }
[10:26:14.736]                 {
[10:26:14.736]                   {
[10:26:14.736]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:14.736]                     NULL
[10:26:14.736]                   }
[10:26:14.736]                   options(future.plan = NULL)
[10:26:14.736]                   if (is.na(NA_character_)) 
[10:26:14.736]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:14.736]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:14.736]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:14.736]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:14.736]                     envir = parent.frame()) 
[10:26:14.736]                   {
[10:26:14.736]                     if (is.function(workers)) 
[10:26:14.736]                       workers <- workers()
[10:26:14.736]                     workers <- structure(as.integer(workers), 
[10:26:14.736]                       class = class(workers))
[10:26:14.736]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:14.736]                       workers >= 1)
[10:26:14.736]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:14.736]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:14.736]                     }
[10:26:14.736]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:14.736]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:14.736]                       envir = envir)
[10:26:14.736]                     if (!future$lazy) 
[10:26:14.736]                       future <- run(future)
[10:26:14.736]                     invisible(future)
[10:26:14.736]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:14.736]                 }
[10:26:14.736]             }
[10:26:14.736]         }
[10:26:14.736]     })
[10:26:14.736]     if (TRUE) {
[10:26:14.736]         base::sink(type = "output", split = FALSE)
[10:26:14.736]         if (TRUE) {
[10:26:14.736]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:14.736]         }
[10:26:14.736]         else {
[10:26:14.736]             ...future.result["stdout"] <- base::list(NULL)
[10:26:14.736]         }
[10:26:14.736]         base::close(...future.stdout)
[10:26:14.736]         ...future.stdout <- NULL
[10:26:14.736]     }
[10:26:14.736]     ...future.result$conditions <- ...future.conditions
[10:26:14.736]     ...future.result$finished <- base::Sys.time()
[10:26:14.736]     ...future.result
[10:26:14.736] }
[10:26:14.739] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[10:26:14.740] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[10:26:14.794] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[10:26:14.794] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[10:26:14.795] MultisessionFuture started
[10:26:14.795] - Launch lazy future ... done
[10:26:14.795] run() for ‘MultisessionFuture’ ... done
[10:26:14.795] result() for ClusterFuture ...
[10:26:14.795] receiveMessageFromWorker() for ClusterFuture ...
[10:26:14.795] - Validating connection of MultisessionFuture
[10:26:14.843] - received message: FutureResult
[10:26:14.843] - Received FutureResult
[10:26:14.843] - Erased future from FutureRegistry
[10:26:14.843] result() for ClusterFuture ...
[10:26:14.843] - result already collected: FutureResult
[10:26:14.843] result() for ClusterFuture ... done
[10:26:14.843] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:14.843] result() for ClusterFuture ... done
[10:26:14.844] result() for ClusterFuture ...
[10:26:14.844] - result already collected: FutureResult
[10:26:14.844] result() for ClusterFuture ... done
value(b) = 2
[10:26:14.844] result() for ClusterFuture ...
[10:26:14.844] - result already collected: FutureResult
[10:26:14.844] result() for ClusterFuture ... done
[10:26:14.844] result() for ClusterFuture ...
[10:26:14.844] - result already collected: FutureResult
[10:26:14.844] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:14.845] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:14.845] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:14.845] 
[10:26:14.846] Searching for globals ... DONE
[10:26:14.846] - globals: [0] <none>
[10:26:14.846] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:14.846] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:14.846] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:14.847] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:14.847] Searching for globals ... DONE
[10:26:14.847] Resolving globals: TRUE
[10:26:14.848] Resolving any globals that are futures ...
[10:26:14.848] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:14.848] Resolving any globals that are futures ... DONE
[10:26:14.848] Resolving futures part of globals (recursively) ...
[10:26:14.848] resolve() on list ...
[10:26:14.848]  recursive: 99
[10:26:14.848]  length: 1
[10:26:14.849]  elements: ‘a’
[10:26:14.849] run() for ‘Future’ ...
[10:26:14.849] - state: ‘created’
[10:26:14.851] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:14.865] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:14.865] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:14.865]   - Field: ‘node’
[10:26:14.866]   - Field: ‘label’
[10:26:14.866]   - Field: ‘local’
[10:26:14.866]   - Field: ‘owner’
[10:26:14.866]   - Field: ‘envir’
[10:26:14.866]   - Field: ‘workers’
[10:26:14.866]   - Field: ‘packages’
[10:26:14.866]   - Field: ‘gc’
[10:26:14.866]   - Field: ‘conditions’
[10:26:14.866]   - Field: ‘persistent’
[10:26:14.866]   - Field: ‘expr’
[10:26:14.866]   - Field: ‘uuid’
[10:26:14.867]   - Field: ‘seed’
[10:26:14.867]   - Field: ‘version’
[10:26:14.867]   - Field: ‘result’
[10:26:14.867]   - Field: ‘asynchronous’
[10:26:14.867]   - Field: ‘calls’
[10:26:14.867]   - Field: ‘globals’
[10:26:14.867]   - Field: ‘stdout’
[10:26:14.867]   - Field: ‘earlySignal’
[10:26:14.867]   - Field: ‘lazy’
[10:26:14.867]   - Field: ‘state’
[10:26:14.867] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:14.867] - Launch lazy future ...
[10:26:14.868] Packages needed by the future expression (n = 0): <none>
[10:26:14.868] Packages needed by future strategies (n = 0): <none>
[10:26:14.868] {
[10:26:14.868]     {
[10:26:14.868]         {
[10:26:14.868]             ...future.startTime <- base::Sys.time()
[10:26:14.868]             {
[10:26:14.868]                 {
[10:26:14.868]                   {
[10:26:14.868]                     {
[10:26:14.868]                       base::local({
[10:26:14.868]                         has_future <- base::requireNamespace("future", 
[10:26:14.868]                           quietly = TRUE)
[10:26:14.868]                         if (has_future) {
[10:26:14.868]                           ns <- base::getNamespace("future")
[10:26:14.868]                           version <- ns[[".package"]][["version"]]
[10:26:14.868]                           if (is.null(version)) 
[10:26:14.868]                             version <- utils::packageVersion("future")
[10:26:14.868]                         }
[10:26:14.868]                         else {
[10:26:14.868]                           version <- NULL
[10:26:14.868]                         }
[10:26:14.868]                         if (!has_future || version < "1.8.0") {
[10:26:14.868]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:14.868]                             "", base::R.version$version.string), 
[10:26:14.868]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:14.868]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:14.868]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:14.868]                               "release", "version")], collapse = " "), 
[10:26:14.868]                             hostname = base::Sys.info()[["nodename"]])
[10:26:14.868]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:14.868]                             info)
[10:26:14.868]                           info <- base::paste(info, collapse = "; ")
[10:26:14.868]                           if (!has_future) {
[10:26:14.868]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:14.868]                               info)
[10:26:14.868]                           }
[10:26:14.868]                           else {
[10:26:14.868]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:14.868]                               info, version)
[10:26:14.868]                           }
[10:26:14.868]                           base::stop(msg)
[10:26:14.868]                         }
[10:26:14.868]                       })
[10:26:14.868]                     }
[10:26:14.868]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:14.868]                     base::options(mc.cores = 1L)
[10:26:14.868]                   }
[10:26:14.868]                   options(future.plan = NULL)
[10:26:14.868]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:14.868]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:14.868]                 }
[10:26:14.868]                 ...future.workdir <- getwd()
[10:26:14.868]             }
[10:26:14.868]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:14.868]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:14.868]         }
[10:26:14.868]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:14.868]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:14.868]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:14.868]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:14.868]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:14.868]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:14.868]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:14.868]             base::names(...future.oldOptions))
[10:26:14.868]     }
[10:26:14.868]     if (FALSE) {
[10:26:14.868]     }
[10:26:14.868]     else {
[10:26:14.868]         if (TRUE) {
[10:26:14.868]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:14.868]                 open = "w")
[10:26:14.868]         }
[10:26:14.868]         else {
[10:26:14.868]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:14.868]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:14.868]         }
[10:26:14.868]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:14.868]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:14.868]             base::sink(type = "output", split = FALSE)
[10:26:14.868]             base::close(...future.stdout)
[10:26:14.868]         }, add = TRUE)
[10:26:14.868]     }
[10:26:14.868]     ...future.frame <- base::sys.nframe()
[10:26:14.868]     ...future.conditions <- base::list()
[10:26:14.868]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:14.868]     if (FALSE) {
[10:26:14.868]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:14.868]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:14.868]     }
[10:26:14.868]     ...future.result <- base::tryCatch({
[10:26:14.868]         base::withCallingHandlers({
[10:26:14.868]             ...future.value <- base::withVisible(base::local({
[10:26:14.868]                 ...future.makeSendCondition <- base::local({
[10:26:14.868]                   sendCondition <- NULL
[10:26:14.868]                   function(frame = 1L) {
[10:26:14.868]                     if (is.function(sendCondition)) 
[10:26:14.868]                       return(sendCondition)
[10:26:14.868]                     ns <- getNamespace("parallel")
[10:26:14.868]                     if (exists("sendData", mode = "function", 
[10:26:14.868]                       envir = ns)) {
[10:26:14.868]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:14.868]                         envir = ns)
[10:26:14.868]                       envir <- sys.frame(frame)
[10:26:14.868]                       master <- NULL
[10:26:14.868]                       while (!identical(envir, .GlobalEnv) && 
[10:26:14.868]                         !identical(envir, emptyenv())) {
[10:26:14.868]                         if (exists("master", mode = "list", envir = envir, 
[10:26:14.868]                           inherits = FALSE)) {
[10:26:14.868]                           master <- get("master", mode = "list", 
[10:26:14.868]                             envir = envir, inherits = FALSE)
[10:26:14.868]                           if (inherits(master, c("SOCKnode", 
[10:26:14.868]                             "SOCK0node"))) {
[10:26:14.868]                             sendCondition <<- function(cond) {
[10:26:14.868]                               data <- list(type = "VALUE", value = cond, 
[10:26:14.868]                                 success = TRUE)
[10:26:14.868]                               parallel_sendData(master, data)
[10:26:14.868]                             }
[10:26:14.868]                             return(sendCondition)
[10:26:14.868]                           }
[10:26:14.868]                         }
[10:26:14.868]                         frame <- frame + 1L
[10:26:14.868]                         envir <- sys.frame(frame)
[10:26:14.868]                       }
[10:26:14.868]                     }
[10:26:14.868]                     sendCondition <<- function(cond) NULL
[10:26:14.868]                   }
[10:26:14.868]                 })
[10:26:14.868]                 withCallingHandlers({
[10:26:14.868]                   1
[10:26:14.868]                 }, immediateCondition = function(cond) {
[10:26:14.868]                   sendCondition <- ...future.makeSendCondition()
[10:26:14.868]                   sendCondition(cond)
[10:26:14.868]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.868]                   {
[10:26:14.868]                     inherits <- base::inherits
[10:26:14.868]                     invokeRestart <- base::invokeRestart
[10:26:14.868]                     is.null <- base::is.null
[10:26:14.868]                     muffled <- FALSE
[10:26:14.868]                     if (inherits(cond, "message")) {
[10:26:14.868]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:14.868]                       if (muffled) 
[10:26:14.868]                         invokeRestart("muffleMessage")
[10:26:14.868]                     }
[10:26:14.868]                     else if (inherits(cond, "warning")) {
[10:26:14.868]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:14.868]                       if (muffled) 
[10:26:14.868]                         invokeRestart("muffleWarning")
[10:26:14.868]                     }
[10:26:14.868]                     else if (inherits(cond, "condition")) {
[10:26:14.868]                       if (!is.null(pattern)) {
[10:26:14.868]                         computeRestarts <- base::computeRestarts
[10:26:14.868]                         grepl <- base::grepl
[10:26:14.868]                         restarts <- computeRestarts(cond)
[10:26:14.868]                         for (restart in restarts) {
[10:26:14.868]                           name <- restart$name
[10:26:14.868]                           if (is.null(name)) 
[10:26:14.868]                             next
[10:26:14.868]                           if (!grepl(pattern, name)) 
[10:26:14.868]                             next
[10:26:14.868]                           invokeRestart(restart)
[10:26:14.868]                           muffled <- TRUE
[10:26:14.868]                           break
[10:26:14.868]                         }
[10:26:14.868]                       }
[10:26:14.868]                     }
[10:26:14.868]                     invisible(muffled)
[10:26:14.868]                   }
[10:26:14.868]                   muffleCondition(cond)
[10:26:14.868]                 })
[10:26:14.868]             }))
[10:26:14.868]             future::FutureResult(value = ...future.value$value, 
[10:26:14.868]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:14.868]                   ...future.rng), globalenv = if (FALSE) 
[10:26:14.868]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:14.868]                     ...future.globalenv.names))
[10:26:14.868]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:14.868]         }, condition = base::local({
[10:26:14.868]             c <- base::c
[10:26:14.868]             inherits <- base::inherits
[10:26:14.868]             invokeRestart <- base::invokeRestart
[10:26:14.868]             length <- base::length
[10:26:14.868]             list <- base::list
[10:26:14.868]             seq.int <- base::seq.int
[10:26:14.868]             signalCondition <- base::signalCondition
[10:26:14.868]             sys.calls <- base::sys.calls
[10:26:14.868]             `[[` <- base::`[[`
[10:26:14.868]             `+` <- base::`+`
[10:26:14.868]             `<<-` <- base::`<<-`
[10:26:14.868]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:14.868]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:14.868]                   3L)]
[10:26:14.868]             }
[10:26:14.868]             function(cond) {
[10:26:14.868]                 is_error <- inherits(cond, "error")
[10:26:14.868]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:14.868]                   NULL)
[10:26:14.868]                 if (is_error) {
[10:26:14.868]                   sessionInformation <- function() {
[10:26:14.868]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:14.868]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:14.868]                       search = base::search(), system = base::Sys.info())
[10:26:14.868]                   }
[10:26:14.868]                   ...future.conditions[[length(...future.conditions) + 
[10:26:14.868]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:14.868]                     cond$call), session = sessionInformation(), 
[10:26:14.868]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:14.868]                   signalCondition(cond)
[10:26:14.868]                 }
[10:26:14.868]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:14.868]                 "immediateCondition"))) {
[10:26:14.868]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:14.868]                   ...future.conditions[[length(...future.conditions) + 
[10:26:14.868]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:14.868]                   if (TRUE && !signal) {
[10:26:14.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.868]                     {
[10:26:14.868]                       inherits <- base::inherits
[10:26:14.868]                       invokeRestart <- base::invokeRestart
[10:26:14.868]                       is.null <- base::is.null
[10:26:14.868]                       muffled <- FALSE
[10:26:14.868]                       if (inherits(cond, "message")) {
[10:26:14.868]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:14.868]                         if (muffled) 
[10:26:14.868]                           invokeRestart("muffleMessage")
[10:26:14.868]                       }
[10:26:14.868]                       else if (inherits(cond, "warning")) {
[10:26:14.868]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:14.868]                         if (muffled) 
[10:26:14.868]                           invokeRestart("muffleWarning")
[10:26:14.868]                       }
[10:26:14.868]                       else if (inherits(cond, "condition")) {
[10:26:14.868]                         if (!is.null(pattern)) {
[10:26:14.868]                           computeRestarts <- base::computeRestarts
[10:26:14.868]                           grepl <- base::grepl
[10:26:14.868]                           restarts <- computeRestarts(cond)
[10:26:14.868]                           for (restart in restarts) {
[10:26:14.868]                             name <- restart$name
[10:26:14.868]                             if (is.null(name)) 
[10:26:14.868]                               next
[10:26:14.868]                             if (!grepl(pattern, name)) 
[10:26:14.868]                               next
[10:26:14.868]                             invokeRestart(restart)
[10:26:14.868]                             muffled <- TRUE
[10:26:14.868]                             break
[10:26:14.868]                           }
[10:26:14.868]                         }
[10:26:14.868]                       }
[10:26:14.868]                       invisible(muffled)
[10:26:14.868]                     }
[10:26:14.868]                     muffleCondition(cond, pattern = "^muffle")
[10:26:14.868]                   }
[10:26:14.868]                 }
[10:26:14.868]                 else {
[10:26:14.868]                   if (TRUE) {
[10:26:14.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.868]                     {
[10:26:14.868]                       inherits <- base::inherits
[10:26:14.868]                       invokeRestart <- base::invokeRestart
[10:26:14.868]                       is.null <- base::is.null
[10:26:14.868]                       muffled <- FALSE
[10:26:14.868]                       if (inherits(cond, "message")) {
[10:26:14.868]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:14.868]                         if (muffled) 
[10:26:14.868]                           invokeRestart("muffleMessage")
[10:26:14.868]                       }
[10:26:14.868]                       else if (inherits(cond, "warning")) {
[10:26:14.868]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:14.868]                         if (muffled) 
[10:26:14.868]                           invokeRestart("muffleWarning")
[10:26:14.868]                       }
[10:26:14.868]                       else if (inherits(cond, "condition")) {
[10:26:14.868]                         if (!is.null(pattern)) {
[10:26:14.868]                           computeRestarts <- base::computeRestarts
[10:26:14.868]                           grepl <- base::grepl
[10:26:14.868]                           restarts <- computeRestarts(cond)
[10:26:14.868]                           for (restart in restarts) {
[10:26:14.868]                             name <- restart$name
[10:26:14.868]                             if (is.null(name)) 
[10:26:14.868]                               next
[10:26:14.868]                             if (!grepl(pattern, name)) 
[10:26:14.868]                               next
[10:26:14.868]                             invokeRestart(restart)
[10:26:14.868]                             muffled <- TRUE
[10:26:14.868]                             break
[10:26:14.868]                           }
[10:26:14.868]                         }
[10:26:14.868]                       }
[10:26:14.868]                       invisible(muffled)
[10:26:14.868]                     }
[10:26:14.868]                     muffleCondition(cond, pattern = "^muffle")
[10:26:14.868]                   }
[10:26:14.868]                 }
[10:26:14.868]             }
[10:26:14.868]         }))
[10:26:14.868]     }, error = function(ex) {
[10:26:14.868]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:14.868]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:14.868]                 ...future.rng), started = ...future.startTime, 
[10:26:14.868]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:14.868]             version = "1.8"), class = "FutureResult")
[10:26:14.868]     }, finally = {
[10:26:14.868]         if (!identical(...future.workdir, getwd())) 
[10:26:14.868]             setwd(...future.workdir)
[10:26:14.868]         {
[10:26:14.868]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:14.868]                 ...future.oldOptions$nwarnings <- NULL
[10:26:14.868]             }
[10:26:14.868]             base::options(...future.oldOptions)
[10:26:14.868]             if (.Platform$OS.type == "windows") {
[10:26:14.868]                 old_names <- names(...future.oldEnvVars)
[10:26:14.868]                 envs <- base::Sys.getenv()
[10:26:14.868]                 names <- names(envs)
[10:26:14.868]                 common <- intersect(names, old_names)
[10:26:14.868]                 added <- setdiff(names, old_names)
[10:26:14.868]                 removed <- setdiff(old_names, names)
[10:26:14.868]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:14.868]                   envs[common]]
[10:26:14.868]                 NAMES <- toupper(changed)
[10:26:14.868]                 args <- list()
[10:26:14.868]                 for (kk in seq_along(NAMES)) {
[10:26:14.868]                   name <- changed[[kk]]
[10:26:14.868]                   NAME <- NAMES[[kk]]
[10:26:14.868]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.868]                     next
[10:26:14.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:14.868]                 }
[10:26:14.868]                 NAMES <- toupper(added)
[10:26:14.868]                 for (kk in seq_along(NAMES)) {
[10:26:14.868]                   name <- added[[kk]]
[10:26:14.868]                   NAME <- NAMES[[kk]]
[10:26:14.868]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.868]                     next
[10:26:14.868]                   args[[name]] <- ""
[10:26:14.868]                 }
[10:26:14.868]                 NAMES <- toupper(removed)
[10:26:14.868]                 for (kk in seq_along(NAMES)) {
[10:26:14.868]                   name <- removed[[kk]]
[10:26:14.868]                   NAME <- NAMES[[kk]]
[10:26:14.868]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.868]                     next
[10:26:14.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:14.868]                 }
[10:26:14.868]                 if (length(args) > 0) 
[10:26:14.868]                   base::do.call(base::Sys.setenv, args = args)
[10:26:14.868]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:14.868]             }
[10:26:14.868]             else {
[10:26:14.868]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:14.868]             }
[10:26:14.868]             {
[10:26:14.868]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:14.868]                   0L) {
[10:26:14.868]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:14.868]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:14.868]                   base::options(opts)
[10:26:14.868]                 }
[10:26:14.868]                 {
[10:26:14.868]                   {
[10:26:14.868]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:14.868]                     NULL
[10:26:14.868]                   }
[10:26:14.868]                   options(future.plan = NULL)
[10:26:14.868]                   if (is.na(NA_character_)) 
[10:26:14.868]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:14.868]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:14.868]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:14.868]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:14.868]                     envir = parent.frame()) 
[10:26:14.868]                   {
[10:26:14.868]                     if (is.function(workers)) 
[10:26:14.868]                       workers <- workers()
[10:26:14.868]                     workers <- structure(as.integer(workers), 
[10:26:14.868]                       class = class(workers))
[10:26:14.868]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:14.868]                       workers >= 1)
[10:26:14.868]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:14.868]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:14.868]                     }
[10:26:14.868]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:14.868]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:14.868]                       envir = envir)
[10:26:14.868]                     if (!future$lazy) 
[10:26:14.868]                       future <- run(future)
[10:26:14.868]                     invisible(future)
[10:26:14.868]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:14.868]                 }
[10:26:14.868]             }
[10:26:14.868]         }
[10:26:14.868]     })
[10:26:14.868]     if (TRUE) {
[10:26:14.868]         base::sink(type = "output", split = FALSE)
[10:26:14.868]         if (TRUE) {
[10:26:14.868]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:14.868]         }
[10:26:14.868]         else {
[10:26:14.868]             ...future.result["stdout"] <- base::list(NULL)
[10:26:14.868]         }
[10:26:14.868]         base::close(...future.stdout)
[10:26:14.868]         ...future.stdout <- NULL
[10:26:14.868]     }
[10:26:14.868]     ...future.result$conditions <- ...future.conditions
[10:26:14.868]     ...future.result$finished <- base::Sys.time()
[10:26:14.868]     ...future.result
[10:26:14.868] }
[10:26:14.871] MultisessionFuture started
[10:26:14.871] - Launch lazy future ... done
[10:26:14.872] run() for ‘MultisessionFuture’ ... done
[10:26:14.918] receiveMessageFromWorker() for ClusterFuture ...
[10:26:14.918] - Validating connection of MultisessionFuture
[10:26:14.919] - received message: FutureResult
[10:26:14.919] - Received FutureResult
[10:26:14.919] - Erased future from FutureRegistry
[10:26:14.919] result() for ClusterFuture ...
[10:26:14.919] - result already collected: FutureResult
[10:26:14.919] result() for ClusterFuture ... done
[10:26:14.919] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:14.919] Future #1
[10:26:14.919] result() for ClusterFuture ...
[10:26:14.920] - result already collected: FutureResult
[10:26:14.920] result() for ClusterFuture ... done
[10:26:14.920] result() for ClusterFuture ...
[10:26:14.920] - result already collected: FutureResult
[10:26:14.920] result() for ClusterFuture ... done
[10:26:14.920] A MultisessionFuture was resolved
[10:26:14.920]  length: 0 (resolved future 1)
[10:26:14.920] resolve() on list ... DONE
[10:26:14.920] - globals: [1] ‘a’
[10:26:14.920] Resolving futures part of globals (recursively) ... DONE
[10:26:14.921] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[10:26:14.922] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[10:26:14.922] - globals: [1] ‘a’
[10:26:14.922] - packages: [1] ‘future’
[10:26:14.922] getGlobalsAndPackages() ... DONE
[10:26:14.922] run() for ‘Future’ ...
[10:26:14.922] - state: ‘created’
[10:26:14.923] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:14.936] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:14.936] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:14.936]   - Field: ‘node’
[10:26:14.936]   - Field: ‘label’
[10:26:14.936]   - Field: ‘local’
[10:26:14.937]   - Field: ‘owner’
[10:26:14.937]   - Field: ‘envir’
[10:26:14.937]   - Field: ‘workers’
[10:26:14.937]   - Field: ‘packages’
[10:26:14.937]   - Field: ‘gc’
[10:26:14.937]   - Field: ‘conditions’
[10:26:14.937]   - Field: ‘persistent’
[10:26:14.937]   - Field: ‘expr’
[10:26:14.937]   - Field: ‘uuid’
[10:26:14.937]   - Field: ‘seed’
[10:26:14.938]   - Field: ‘version’
[10:26:14.938]   - Field: ‘result’
[10:26:14.938]   - Field: ‘asynchronous’
[10:26:14.938]   - Field: ‘calls’
[10:26:14.938]   - Field: ‘globals’
[10:26:14.938]   - Field: ‘stdout’
[10:26:14.938]   - Field: ‘earlySignal’
[10:26:14.938]   - Field: ‘lazy’
[10:26:14.938]   - Field: ‘state’
[10:26:14.938] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:14.938] - Launch lazy future ...
[10:26:14.939] Packages needed by the future expression (n = 1): ‘future’
[10:26:14.939] Packages needed by future strategies (n = 0): <none>
[10:26:14.939] {
[10:26:14.939]     {
[10:26:14.939]         {
[10:26:14.939]             ...future.startTime <- base::Sys.time()
[10:26:14.939]             {
[10:26:14.939]                 {
[10:26:14.939]                   {
[10:26:14.939]                     {
[10:26:14.939]                       {
[10:26:14.939]                         base::local({
[10:26:14.939]                           has_future <- base::requireNamespace("future", 
[10:26:14.939]                             quietly = TRUE)
[10:26:14.939]                           if (has_future) {
[10:26:14.939]                             ns <- base::getNamespace("future")
[10:26:14.939]                             version <- ns[[".package"]][["version"]]
[10:26:14.939]                             if (is.null(version)) 
[10:26:14.939]                               version <- utils::packageVersion("future")
[10:26:14.939]                           }
[10:26:14.939]                           else {
[10:26:14.939]                             version <- NULL
[10:26:14.939]                           }
[10:26:14.939]                           if (!has_future || version < "1.8.0") {
[10:26:14.939]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:14.939]                               "", base::R.version$version.string), 
[10:26:14.939]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:14.939]                                 base::R.version$platform, 8 * 
[10:26:14.939]                                   base::.Machine$sizeof.pointer), 
[10:26:14.939]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:14.939]                                 "release", "version")], collapse = " "), 
[10:26:14.939]                               hostname = base::Sys.info()[["nodename"]])
[10:26:14.939]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:14.939]                               info)
[10:26:14.939]                             info <- base::paste(info, collapse = "; ")
[10:26:14.939]                             if (!has_future) {
[10:26:14.939]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:14.939]                                 info)
[10:26:14.939]                             }
[10:26:14.939]                             else {
[10:26:14.939]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:14.939]                                 info, version)
[10:26:14.939]                             }
[10:26:14.939]                             base::stop(msg)
[10:26:14.939]                           }
[10:26:14.939]                         })
[10:26:14.939]                       }
[10:26:14.939]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:14.939]                       base::options(mc.cores = 1L)
[10:26:14.939]                     }
[10:26:14.939]                     base::local({
[10:26:14.939]                       for (pkg in "future") {
[10:26:14.939]                         base::loadNamespace(pkg)
[10:26:14.939]                         base::library(pkg, character.only = TRUE)
[10:26:14.939]                       }
[10:26:14.939]                     })
[10:26:14.939]                   }
[10:26:14.939]                   options(future.plan = NULL)
[10:26:14.939]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:14.939]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:14.939]                 }
[10:26:14.939]                 ...future.workdir <- getwd()
[10:26:14.939]             }
[10:26:14.939]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:14.939]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:14.939]         }
[10:26:14.939]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:14.939]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:14.939]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:14.939]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:14.939]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:14.939]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:14.939]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:14.939]             base::names(...future.oldOptions))
[10:26:14.939]     }
[10:26:14.939]     if (FALSE) {
[10:26:14.939]     }
[10:26:14.939]     else {
[10:26:14.939]         if (TRUE) {
[10:26:14.939]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:14.939]                 open = "w")
[10:26:14.939]         }
[10:26:14.939]         else {
[10:26:14.939]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:14.939]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:14.939]         }
[10:26:14.939]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:14.939]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:14.939]             base::sink(type = "output", split = FALSE)
[10:26:14.939]             base::close(...future.stdout)
[10:26:14.939]         }, add = TRUE)
[10:26:14.939]     }
[10:26:14.939]     ...future.frame <- base::sys.nframe()
[10:26:14.939]     ...future.conditions <- base::list()
[10:26:14.939]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:14.939]     if (FALSE) {
[10:26:14.939]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:14.939]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:14.939]     }
[10:26:14.939]     ...future.result <- base::tryCatch({
[10:26:14.939]         base::withCallingHandlers({
[10:26:14.939]             ...future.value <- base::withVisible(base::local({
[10:26:14.939]                 ...future.makeSendCondition <- base::local({
[10:26:14.939]                   sendCondition <- NULL
[10:26:14.939]                   function(frame = 1L) {
[10:26:14.939]                     if (is.function(sendCondition)) 
[10:26:14.939]                       return(sendCondition)
[10:26:14.939]                     ns <- getNamespace("parallel")
[10:26:14.939]                     if (exists("sendData", mode = "function", 
[10:26:14.939]                       envir = ns)) {
[10:26:14.939]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:14.939]                         envir = ns)
[10:26:14.939]                       envir <- sys.frame(frame)
[10:26:14.939]                       master <- NULL
[10:26:14.939]                       while (!identical(envir, .GlobalEnv) && 
[10:26:14.939]                         !identical(envir, emptyenv())) {
[10:26:14.939]                         if (exists("master", mode = "list", envir = envir, 
[10:26:14.939]                           inherits = FALSE)) {
[10:26:14.939]                           master <- get("master", mode = "list", 
[10:26:14.939]                             envir = envir, inherits = FALSE)
[10:26:14.939]                           if (inherits(master, c("SOCKnode", 
[10:26:14.939]                             "SOCK0node"))) {
[10:26:14.939]                             sendCondition <<- function(cond) {
[10:26:14.939]                               data <- list(type = "VALUE", value = cond, 
[10:26:14.939]                                 success = TRUE)
[10:26:14.939]                               parallel_sendData(master, data)
[10:26:14.939]                             }
[10:26:14.939]                             return(sendCondition)
[10:26:14.939]                           }
[10:26:14.939]                         }
[10:26:14.939]                         frame <- frame + 1L
[10:26:14.939]                         envir <- sys.frame(frame)
[10:26:14.939]                       }
[10:26:14.939]                     }
[10:26:14.939]                     sendCondition <<- function(cond) NULL
[10:26:14.939]                   }
[10:26:14.939]                 })
[10:26:14.939]                 withCallingHandlers({
[10:26:14.939]                   value(a) + 1
[10:26:14.939]                 }, immediateCondition = function(cond) {
[10:26:14.939]                   sendCondition <- ...future.makeSendCondition()
[10:26:14.939]                   sendCondition(cond)
[10:26:14.939]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.939]                   {
[10:26:14.939]                     inherits <- base::inherits
[10:26:14.939]                     invokeRestart <- base::invokeRestart
[10:26:14.939]                     is.null <- base::is.null
[10:26:14.939]                     muffled <- FALSE
[10:26:14.939]                     if (inherits(cond, "message")) {
[10:26:14.939]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:14.939]                       if (muffled) 
[10:26:14.939]                         invokeRestart("muffleMessage")
[10:26:14.939]                     }
[10:26:14.939]                     else if (inherits(cond, "warning")) {
[10:26:14.939]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:14.939]                       if (muffled) 
[10:26:14.939]                         invokeRestart("muffleWarning")
[10:26:14.939]                     }
[10:26:14.939]                     else if (inherits(cond, "condition")) {
[10:26:14.939]                       if (!is.null(pattern)) {
[10:26:14.939]                         computeRestarts <- base::computeRestarts
[10:26:14.939]                         grepl <- base::grepl
[10:26:14.939]                         restarts <- computeRestarts(cond)
[10:26:14.939]                         for (restart in restarts) {
[10:26:14.939]                           name <- restart$name
[10:26:14.939]                           if (is.null(name)) 
[10:26:14.939]                             next
[10:26:14.939]                           if (!grepl(pattern, name)) 
[10:26:14.939]                             next
[10:26:14.939]                           invokeRestart(restart)
[10:26:14.939]                           muffled <- TRUE
[10:26:14.939]                           break
[10:26:14.939]                         }
[10:26:14.939]                       }
[10:26:14.939]                     }
[10:26:14.939]                     invisible(muffled)
[10:26:14.939]                   }
[10:26:14.939]                   muffleCondition(cond)
[10:26:14.939]                 })
[10:26:14.939]             }))
[10:26:14.939]             future::FutureResult(value = ...future.value$value, 
[10:26:14.939]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:14.939]                   ...future.rng), globalenv = if (FALSE) 
[10:26:14.939]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:14.939]                     ...future.globalenv.names))
[10:26:14.939]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:14.939]         }, condition = base::local({
[10:26:14.939]             c <- base::c
[10:26:14.939]             inherits <- base::inherits
[10:26:14.939]             invokeRestart <- base::invokeRestart
[10:26:14.939]             length <- base::length
[10:26:14.939]             list <- base::list
[10:26:14.939]             seq.int <- base::seq.int
[10:26:14.939]             signalCondition <- base::signalCondition
[10:26:14.939]             sys.calls <- base::sys.calls
[10:26:14.939]             `[[` <- base::`[[`
[10:26:14.939]             `+` <- base::`+`
[10:26:14.939]             `<<-` <- base::`<<-`
[10:26:14.939]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:14.939]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:14.939]                   3L)]
[10:26:14.939]             }
[10:26:14.939]             function(cond) {
[10:26:14.939]                 is_error <- inherits(cond, "error")
[10:26:14.939]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:14.939]                   NULL)
[10:26:14.939]                 if (is_error) {
[10:26:14.939]                   sessionInformation <- function() {
[10:26:14.939]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:14.939]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:14.939]                       search = base::search(), system = base::Sys.info())
[10:26:14.939]                   }
[10:26:14.939]                   ...future.conditions[[length(...future.conditions) + 
[10:26:14.939]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:14.939]                     cond$call), session = sessionInformation(), 
[10:26:14.939]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:14.939]                   signalCondition(cond)
[10:26:14.939]                 }
[10:26:14.939]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:14.939]                 "immediateCondition"))) {
[10:26:14.939]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:14.939]                   ...future.conditions[[length(...future.conditions) + 
[10:26:14.939]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:14.939]                   if (TRUE && !signal) {
[10:26:14.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.939]                     {
[10:26:14.939]                       inherits <- base::inherits
[10:26:14.939]                       invokeRestart <- base::invokeRestart
[10:26:14.939]                       is.null <- base::is.null
[10:26:14.939]                       muffled <- FALSE
[10:26:14.939]                       if (inherits(cond, "message")) {
[10:26:14.939]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:14.939]                         if (muffled) 
[10:26:14.939]                           invokeRestart("muffleMessage")
[10:26:14.939]                       }
[10:26:14.939]                       else if (inherits(cond, "warning")) {
[10:26:14.939]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:14.939]                         if (muffled) 
[10:26:14.939]                           invokeRestart("muffleWarning")
[10:26:14.939]                       }
[10:26:14.939]                       else if (inherits(cond, "condition")) {
[10:26:14.939]                         if (!is.null(pattern)) {
[10:26:14.939]                           computeRestarts <- base::computeRestarts
[10:26:14.939]                           grepl <- base::grepl
[10:26:14.939]                           restarts <- computeRestarts(cond)
[10:26:14.939]                           for (restart in restarts) {
[10:26:14.939]                             name <- restart$name
[10:26:14.939]                             if (is.null(name)) 
[10:26:14.939]                               next
[10:26:14.939]                             if (!grepl(pattern, name)) 
[10:26:14.939]                               next
[10:26:14.939]                             invokeRestart(restart)
[10:26:14.939]                             muffled <- TRUE
[10:26:14.939]                             break
[10:26:14.939]                           }
[10:26:14.939]                         }
[10:26:14.939]                       }
[10:26:14.939]                       invisible(muffled)
[10:26:14.939]                     }
[10:26:14.939]                     muffleCondition(cond, pattern = "^muffle")
[10:26:14.939]                   }
[10:26:14.939]                 }
[10:26:14.939]                 else {
[10:26:14.939]                   if (TRUE) {
[10:26:14.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:14.939]                     {
[10:26:14.939]                       inherits <- base::inherits
[10:26:14.939]                       invokeRestart <- base::invokeRestart
[10:26:14.939]                       is.null <- base::is.null
[10:26:14.939]                       muffled <- FALSE
[10:26:14.939]                       if (inherits(cond, "message")) {
[10:26:14.939]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:14.939]                         if (muffled) 
[10:26:14.939]                           invokeRestart("muffleMessage")
[10:26:14.939]                       }
[10:26:14.939]                       else if (inherits(cond, "warning")) {
[10:26:14.939]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:14.939]                         if (muffled) 
[10:26:14.939]                           invokeRestart("muffleWarning")
[10:26:14.939]                       }
[10:26:14.939]                       else if (inherits(cond, "condition")) {
[10:26:14.939]                         if (!is.null(pattern)) {
[10:26:14.939]                           computeRestarts <- base::computeRestarts
[10:26:14.939]                           grepl <- base::grepl
[10:26:14.939]                           restarts <- computeRestarts(cond)
[10:26:14.939]                           for (restart in restarts) {
[10:26:14.939]                             name <- restart$name
[10:26:14.939]                             if (is.null(name)) 
[10:26:14.939]                               next
[10:26:14.939]                             if (!grepl(pattern, name)) 
[10:26:14.939]                               next
[10:26:14.939]                             invokeRestart(restart)
[10:26:14.939]                             muffled <- TRUE
[10:26:14.939]                             break
[10:26:14.939]                           }
[10:26:14.939]                         }
[10:26:14.939]                       }
[10:26:14.939]                       invisible(muffled)
[10:26:14.939]                     }
[10:26:14.939]                     muffleCondition(cond, pattern = "^muffle")
[10:26:14.939]                   }
[10:26:14.939]                 }
[10:26:14.939]             }
[10:26:14.939]         }))
[10:26:14.939]     }, error = function(ex) {
[10:26:14.939]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:14.939]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:14.939]                 ...future.rng), started = ...future.startTime, 
[10:26:14.939]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:14.939]             version = "1.8"), class = "FutureResult")
[10:26:14.939]     }, finally = {
[10:26:14.939]         if (!identical(...future.workdir, getwd())) 
[10:26:14.939]             setwd(...future.workdir)
[10:26:14.939]         {
[10:26:14.939]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:14.939]                 ...future.oldOptions$nwarnings <- NULL
[10:26:14.939]             }
[10:26:14.939]             base::options(...future.oldOptions)
[10:26:14.939]             if (.Platform$OS.type == "windows") {
[10:26:14.939]                 old_names <- names(...future.oldEnvVars)
[10:26:14.939]                 envs <- base::Sys.getenv()
[10:26:14.939]                 names <- names(envs)
[10:26:14.939]                 common <- intersect(names, old_names)
[10:26:14.939]                 added <- setdiff(names, old_names)
[10:26:14.939]                 removed <- setdiff(old_names, names)
[10:26:14.939]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:14.939]                   envs[common]]
[10:26:14.939]                 NAMES <- toupper(changed)
[10:26:14.939]                 args <- list()
[10:26:14.939]                 for (kk in seq_along(NAMES)) {
[10:26:14.939]                   name <- changed[[kk]]
[10:26:14.939]                   NAME <- NAMES[[kk]]
[10:26:14.939]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.939]                     next
[10:26:14.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:14.939]                 }
[10:26:14.939]                 NAMES <- toupper(added)
[10:26:14.939]                 for (kk in seq_along(NAMES)) {
[10:26:14.939]                   name <- added[[kk]]
[10:26:14.939]                   NAME <- NAMES[[kk]]
[10:26:14.939]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.939]                     next
[10:26:14.939]                   args[[name]] <- ""
[10:26:14.939]                 }
[10:26:14.939]                 NAMES <- toupper(removed)
[10:26:14.939]                 for (kk in seq_along(NAMES)) {
[10:26:14.939]                   name <- removed[[kk]]
[10:26:14.939]                   NAME <- NAMES[[kk]]
[10:26:14.939]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:14.939]                     next
[10:26:14.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:14.939]                 }
[10:26:14.939]                 if (length(args) > 0) 
[10:26:14.939]                   base::do.call(base::Sys.setenv, args = args)
[10:26:14.939]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:14.939]             }
[10:26:14.939]             else {
[10:26:14.939]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:14.939]             }
[10:26:14.939]             {
[10:26:14.939]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:14.939]                   0L) {
[10:26:14.939]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:14.939]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:14.939]                   base::options(opts)
[10:26:14.939]                 }
[10:26:14.939]                 {
[10:26:14.939]                   {
[10:26:14.939]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:14.939]                     NULL
[10:26:14.939]                   }
[10:26:14.939]                   options(future.plan = NULL)
[10:26:14.939]                   if (is.na(NA_character_)) 
[10:26:14.939]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:14.939]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:14.939]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:14.939]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:14.939]                     envir = parent.frame()) 
[10:26:14.939]                   {
[10:26:14.939]                     if (is.function(workers)) 
[10:26:14.939]                       workers <- workers()
[10:26:14.939]                     workers <- structure(as.integer(workers), 
[10:26:14.939]                       class = class(workers))
[10:26:14.939]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:14.939]                       workers >= 1)
[10:26:14.939]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:14.939]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:14.939]                     }
[10:26:14.939]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:14.939]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:14.939]                       envir = envir)
[10:26:14.939]                     if (!future$lazy) 
[10:26:14.939]                       future <- run(future)
[10:26:14.939]                     invisible(future)
[10:26:14.939]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:14.939]                 }
[10:26:14.939]             }
[10:26:14.939]         }
[10:26:14.939]     })
[10:26:14.939]     if (TRUE) {
[10:26:14.939]         base::sink(type = "output", split = FALSE)
[10:26:14.939]         if (TRUE) {
[10:26:14.939]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:14.939]         }
[10:26:14.939]         else {
[10:26:14.939]             ...future.result["stdout"] <- base::list(NULL)
[10:26:14.939]         }
[10:26:14.939]         base::close(...future.stdout)
[10:26:14.939]         ...future.stdout <- NULL
[10:26:14.939]     }
[10:26:14.939]     ...future.result$conditions <- ...future.conditions
[10:26:14.939]     ...future.result$finished <- base::Sys.time()
[10:26:14.939]     ...future.result
[10:26:14.939] }
[10:26:14.942] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[10:26:14.943] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[10:26:14.994] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[10:26:14.994] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[10:26:14.994] MultisessionFuture started
[10:26:14.995] - Launch lazy future ... done
[10:26:14.995] run() for ‘MultisessionFuture’ ... done
[10:26:14.995] result() for ClusterFuture ...
[10:26:14.995] receiveMessageFromWorker() for ClusterFuture ...
[10:26:14.995] - Validating connection of MultisessionFuture
[10:26:15.043] - received message: FutureResult
[10:26:15.043] - Received FutureResult
[10:26:15.043] - Erased future from FutureRegistry
[10:26:15.043] result() for ClusterFuture ...
[10:26:15.043] - result already collected: FutureResult
[10:26:15.044] result() for ClusterFuture ... done
[10:26:15.044] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:15.044] result() for ClusterFuture ... done
[10:26:15.044] result() for ClusterFuture ...
[10:26:15.044] - result already collected: FutureResult
[10:26:15.044] result() for ClusterFuture ... done
value(b) = 2
[10:26:15.044] result() for ClusterFuture ...
[10:26:15.044] - result already collected: FutureResult
[10:26:15.044] result() for ClusterFuture ... done
[10:26:15.045] result() for ClusterFuture ...
[10:26:15.045] - result already collected: FutureResult
[10:26:15.045] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:15.045] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:15.045] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:26:15.046] - globals found: [2] ‘{’, ‘pkg’
[10:26:15.046] Searching for globals ... DONE
[10:26:15.046] Resolving globals: TRUE
[10:26:15.046] Resolving any globals that are futures ...
[10:26:15.046] - globals: [2] ‘{’, ‘pkg’
[10:26:15.047] Resolving any globals that are futures ... DONE
[10:26:15.047] Resolving futures part of globals (recursively) ...
[10:26:15.047] resolve() on list ...
[10:26:15.047]  recursive: 99
[10:26:15.047]  length: 1
[10:26:15.047]  elements: ‘pkg’
[10:26:15.048]  length: 0 (resolved future 1)
[10:26:15.048] resolve() on list ... DONE
[10:26:15.048] - globals: [1] ‘pkg’
[10:26:15.048] Resolving futures part of globals (recursively) ... DONE
[10:26:15.048] The total size of the 1 globals is 112 bytes (112 bytes)
[10:26:15.048] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[10:26:15.048] - globals: [1] ‘pkg’
[10:26:15.049] 
[10:26:15.049] getGlobalsAndPackages() ... DONE
[10:26:15.049] Packages needed by the future expression (n = 0): <none>
[10:26:15.049] Packages needed by future strategies (n = 0): <none>
[10:26:15.050] {
[10:26:15.050]     {
[10:26:15.050]         {
[10:26:15.050]             ...future.startTime <- base::Sys.time()
[10:26:15.050]             {
[10:26:15.050]                 {
[10:26:15.050]                   {
[10:26:15.050]                     base::local({
[10:26:15.050]                       has_future <- base::requireNamespace("future", 
[10:26:15.050]                         quietly = TRUE)
[10:26:15.050]                       if (has_future) {
[10:26:15.050]                         ns <- base::getNamespace("future")
[10:26:15.050]                         version <- ns[[".package"]][["version"]]
[10:26:15.050]                         if (is.null(version)) 
[10:26:15.050]                           version <- utils::packageVersion("future")
[10:26:15.050]                       }
[10:26:15.050]                       else {
[10:26:15.050]                         version <- NULL
[10:26:15.050]                       }
[10:26:15.050]                       if (!has_future || version < "1.8.0") {
[10:26:15.050]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:15.050]                           "", base::R.version$version.string), 
[10:26:15.050]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:15.050]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:15.050]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:15.050]                             "release", "version")], collapse = " "), 
[10:26:15.050]                           hostname = base::Sys.info()[["nodename"]])
[10:26:15.050]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:15.050]                           info)
[10:26:15.050]                         info <- base::paste(info, collapse = "; ")
[10:26:15.050]                         if (!has_future) {
[10:26:15.050]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:15.050]                             info)
[10:26:15.050]                         }
[10:26:15.050]                         else {
[10:26:15.050]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:15.050]                             info, version)
[10:26:15.050]                         }
[10:26:15.050]                         base::stop(msg)
[10:26:15.050]                       }
[10:26:15.050]                     })
[10:26:15.050]                   }
[10:26:15.050]                   options(future.plan = NULL)
[10:26:15.050]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.050]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:15.050]                 }
[10:26:15.050]                 ...future.workdir <- getwd()
[10:26:15.050]             }
[10:26:15.050]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:15.050]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:15.050]         }
[10:26:15.050]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:15.050]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:26:15.050]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:15.050]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:15.050]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:15.050]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:15.050]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:15.050]             base::names(...future.oldOptions))
[10:26:15.050]     }
[10:26:15.050]     if (FALSE) {
[10:26:15.050]     }
[10:26:15.050]     else {
[10:26:15.050]         if (TRUE) {
[10:26:15.050]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:15.050]                 open = "w")
[10:26:15.050]         }
[10:26:15.050]         else {
[10:26:15.050]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:15.050]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:15.050]         }
[10:26:15.050]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:15.050]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:15.050]             base::sink(type = "output", split = FALSE)
[10:26:15.050]             base::close(...future.stdout)
[10:26:15.050]         }, add = TRUE)
[10:26:15.050]     }
[10:26:15.050]     ...future.frame <- base::sys.nframe()
[10:26:15.050]     ...future.conditions <- base::list()
[10:26:15.050]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:15.050]     if (FALSE) {
[10:26:15.050]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:15.050]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:15.050]     }
[10:26:15.050]     ...future.result <- base::tryCatch({
[10:26:15.050]         base::withCallingHandlers({
[10:26:15.050]             ...future.value <- base::withVisible(base::local({
[10:26:15.050]                 pkg
[10:26:15.050]             }))
[10:26:15.050]             future::FutureResult(value = ...future.value$value, 
[10:26:15.050]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.050]                   ...future.rng), globalenv = if (FALSE) 
[10:26:15.050]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:15.050]                     ...future.globalenv.names))
[10:26:15.050]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:15.050]         }, condition = base::local({
[10:26:15.050]             c <- base::c
[10:26:15.050]             inherits <- base::inherits
[10:26:15.050]             invokeRestart <- base::invokeRestart
[10:26:15.050]             length <- base::length
[10:26:15.050]             list <- base::list
[10:26:15.050]             seq.int <- base::seq.int
[10:26:15.050]             signalCondition <- base::signalCondition
[10:26:15.050]             sys.calls <- base::sys.calls
[10:26:15.050]             `[[` <- base::`[[`
[10:26:15.050]             `+` <- base::`+`
[10:26:15.050]             `<<-` <- base::`<<-`
[10:26:15.050]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:15.050]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:15.050]                   3L)]
[10:26:15.050]             }
[10:26:15.050]             function(cond) {
[10:26:15.050]                 is_error <- inherits(cond, "error")
[10:26:15.050]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:15.050]                   NULL)
[10:26:15.050]                 if (is_error) {
[10:26:15.050]                   sessionInformation <- function() {
[10:26:15.050]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:15.050]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:15.050]                       search = base::search(), system = base::Sys.info())
[10:26:15.050]                   }
[10:26:15.050]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.050]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:15.050]                     cond$call), session = sessionInformation(), 
[10:26:15.050]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:15.050]                   signalCondition(cond)
[10:26:15.050]                 }
[10:26:15.050]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:15.050]                 "immediateCondition"))) {
[10:26:15.050]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:15.050]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.050]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:15.050]                   if (TRUE && !signal) {
[10:26:15.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.050]                     {
[10:26:15.050]                       inherits <- base::inherits
[10:26:15.050]                       invokeRestart <- base::invokeRestart
[10:26:15.050]                       is.null <- base::is.null
[10:26:15.050]                       muffled <- FALSE
[10:26:15.050]                       if (inherits(cond, "message")) {
[10:26:15.050]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.050]                         if (muffled) 
[10:26:15.050]                           invokeRestart("muffleMessage")
[10:26:15.050]                       }
[10:26:15.050]                       else if (inherits(cond, "warning")) {
[10:26:15.050]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.050]                         if (muffled) 
[10:26:15.050]                           invokeRestart("muffleWarning")
[10:26:15.050]                       }
[10:26:15.050]                       else if (inherits(cond, "condition")) {
[10:26:15.050]                         if (!is.null(pattern)) {
[10:26:15.050]                           computeRestarts <- base::computeRestarts
[10:26:15.050]                           grepl <- base::grepl
[10:26:15.050]                           restarts <- computeRestarts(cond)
[10:26:15.050]                           for (restart in restarts) {
[10:26:15.050]                             name <- restart$name
[10:26:15.050]                             if (is.null(name)) 
[10:26:15.050]                               next
[10:26:15.050]                             if (!grepl(pattern, name)) 
[10:26:15.050]                               next
[10:26:15.050]                             invokeRestart(restart)
[10:26:15.050]                             muffled <- TRUE
[10:26:15.050]                             break
[10:26:15.050]                           }
[10:26:15.050]                         }
[10:26:15.050]                       }
[10:26:15.050]                       invisible(muffled)
[10:26:15.050]                     }
[10:26:15.050]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.050]                   }
[10:26:15.050]                 }
[10:26:15.050]                 else {
[10:26:15.050]                   if (TRUE) {
[10:26:15.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.050]                     {
[10:26:15.050]                       inherits <- base::inherits
[10:26:15.050]                       invokeRestart <- base::invokeRestart
[10:26:15.050]                       is.null <- base::is.null
[10:26:15.050]                       muffled <- FALSE
[10:26:15.050]                       if (inherits(cond, "message")) {
[10:26:15.050]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.050]                         if (muffled) 
[10:26:15.050]                           invokeRestart("muffleMessage")
[10:26:15.050]                       }
[10:26:15.050]                       else if (inherits(cond, "warning")) {
[10:26:15.050]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.050]                         if (muffled) 
[10:26:15.050]                           invokeRestart("muffleWarning")
[10:26:15.050]                       }
[10:26:15.050]                       else if (inherits(cond, "condition")) {
[10:26:15.050]                         if (!is.null(pattern)) {
[10:26:15.050]                           computeRestarts <- base::computeRestarts
[10:26:15.050]                           grepl <- base::grepl
[10:26:15.050]                           restarts <- computeRestarts(cond)
[10:26:15.050]                           for (restart in restarts) {
[10:26:15.050]                             name <- restart$name
[10:26:15.050]                             if (is.null(name)) 
[10:26:15.050]                               next
[10:26:15.050]                             if (!grepl(pattern, name)) 
[10:26:15.050]                               next
[10:26:15.050]                             invokeRestart(restart)
[10:26:15.050]                             muffled <- TRUE
[10:26:15.050]                             break
[10:26:15.050]                           }
[10:26:15.050]                         }
[10:26:15.050]                       }
[10:26:15.050]                       invisible(muffled)
[10:26:15.050]                     }
[10:26:15.050]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.050]                   }
[10:26:15.050]                 }
[10:26:15.050]             }
[10:26:15.050]         }))
[10:26:15.050]     }, error = function(ex) {
[10:26:15.050]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:15.050]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.050]                 ...future.rng), started = ...future.startTime, 
[10:26:15.050]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:15.050]             version = "1.8"), class = "FutureResult")
[10:26:15.050]     }, finally = {
[10:26:15.050]         if (!identical(...future.workdir, getwd())) 
[10:26:15.050]             setwd(...future.workdir)
[10:26:15.050]         {
[10:26:15.050]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:15.050]                 ...future.oldOptions$nwarnings <- NULL
[10:26:15.050]             }
[10:26:15.050]             base::options(...future.oldOptions)
[10:26:15.050]             if (.Platform$OS.type == "windows") {
[10:26:15.050]                 old_names <- names(...future.oldEnvVars)
[10:26:15.050]                 envs <- base::Sys.getenv()
[10:26:15.050]                 names <- names(envs)
[10:26:15.050]                 common <- intersect(names, old_names)
[10:26:15.050]                 added <- setdiff(names, old_names)
[10:26:15.050]                 removed <- setdiff(old_names, names)
[10:26:15.050]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:15.050]                   envs[common]]
[10:26:15.050]                 NAMES <- toupper(changed)
[10:26:15.050]                 args <- list()
[10:26:15.050]                 for (kk in seq_along(NAMES)) {
[10:26:15.050]                   name <- changed[[kk]]
[10:26:15.050]                   NAME <- NAMES[[kk]]
[10:26:15.050]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.050]                     next
[10:26:15.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.050]                 }
[10:26:15.050]                 NAMES <- toupper(added)
[10:26:15.050]                 for (kk in seq_along(NAMES)) {
[10:26:15.050]                   name <- added[[kk]]
[10:26:15.050]                   NAME <- NAMES[[kk]]
[10:26:15.050]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.050]                     next
[10:26:15.050]                   args[[name]] <- ""
[10:26:15.050]                 }
[10:26:15.050]                 NAMES <- toupper(removed)
[10:26:15.050]                 for (kk in seq_along(NAMES)) {
[10:26:15.050]                   name <- removed[[kk]]
[10:26:15.050]                   NAME <- NAMES[[kk]]
[10:26:15.050]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.050]                     next
[10:26:15.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.050]                 }
[10:26:15.050]                 if (length(args) > 0) 
[10:26:15.050]                   base::do.call(base::Sys.setenv, args = args)
[10:26:15.050]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:15.050]             }
[10:26:15.050]             else {
[10:26:15.050]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:15.050]             }
[10:26:15.050]             {
[10:26:15.050]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:15.050]                   0L) {
[10:26:15.050]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:15.050]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:15.050]                   base::options(opts)
[10:26:15.050]                 }
[10:26:15.050]                 {
[10:26:15.050]                   {
[10:26:15.050]                     NULL
[10:26:15.050]                     RNGkind("Mersenne-Twister")
[10:26:15.050]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:15.050]                       inherits = FALSE)
[10:26:15.050]                   }
[10:26:15.050]                   options(future.plan = NULL)
[10:26:15.050]                   if (is.na(NA_character_)) 
[10:26:15.050]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.050]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:15.050]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:15.050]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:15.050]                     envir = parent.frame()) 
[10:26:15.050]                   {
[10:26:15.050]                     if (is.function(workers)) 
[10:26:15.050]                       workers <- workers()
[10:26:15.050]                     workers <- structure(as.integer(workers), 
[10:26:15.050]                       class = class(workers))
[10:26:15.050]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:15.050]                       workers >= 1)
[10:26:15.050]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:15.050]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:15.050]                     }
[10:26:15.050]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:15.050]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:15.050]                       envir = envir)
[10:26:15.050]                     if (!future$lazy) 
[10:26:15.050]                       future <- run(future)
[10:26:15.050]                     invisible(future)
[10:26:15.050]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:15.050]                 }
[10:26:15.050]             }
[10:26:15.050]         }
[10:26:15.050]     })
[10:26:15.050]     if (TRUE) {
[10:26:15.050]         base::sink(type = "output", split = FALSE)
[10:26:15.050]         if (TRUE) {
[10:26:15.050]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:15.050]         }
[10:26:15.050]         else {
[10:26:15.050]             ...future.result["stdout"] <- base::list(NULL)
[10:26:15.050]         }
[10:26:15.050]         base::close(...future.stdout)
[10:26:15.050]         ...future.stdout <- NULL
[10:26:15.050]     }
[10:26:15.050]     ...future.result$conditions <- ...future.conditions
[10:26:15.050]     ...future.result$finished <- base::Sys.time()
[10:26:15.050]     ...future.result
[10:26:15.050] }
[10:26:15.051] assign_globals() ...
[10:26:15.051] List of 1
[10:26:15.051]  $ pkg: chr "foo"
[10:26:15.051]  - attr(*, "where")=List of 1
[10:26:15.051]   ..$ pkg:<environment: R_EmptyEnv> 
[10:26:15.051]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:15.051]  - attr(*, "resolved")= logi TRUE
[10:26:15.051]  - attr(*, "total_size")= num 112
[10:26:15.054] - copied ‘pkg’ to environment
[10:26:15.054] assign_globals() ... done
[10:26:15.054] plan(): Setting new future strategy stack:
[10:26:15.054] List of future strategies:
[10:26:15.054] 1. sequential:
[10:26:15.054]    - args: function (..., envir = parent.frame())
[10:26:15.054]    - tweaked: FALSE
[10:26:15.054]    - call: NULL
[10:26:15.054] plan(): nbrOfWorkers() = 1
[10:26:15.055] plan(): Setting new future strategy stack:
[10:26:15.055] List of future strategies:
[10:26:15.055] 1. multisession:
[10:26:15.055]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:15.055]    - tweaked: FALSE
[10:26:15.055]    - call: plan(strategy)
[10:26:15.059] plan(): nbrOfWorkers() = 2
[10:26:15.059] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:15.060] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:15.060] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:15.062] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:26:15.062] Searching for globals ... DONE
[10:26:15.062] Resolving globals: TRUE
[10:26:15.062] Resolving any globals that are futures ...
[10:26:15.062] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:26:15.062] Resolving any globals that are futures ... DONE
[10:26:15.062] Resolving futures part of globals (recursively) ...
[10:26:15.063] resolve() on list ...
[10:26:15.063]  recursive: 99
[10:26:15.063]  length: 1
[10:26:15.063]  elements: ‘a’
[10:26:15.063]  length: 0 (resolved future 1)
[10:26:15.063] resolve() on list ... DONE
[10:26:15.063] - globals: [1] ‘a’
[10:26:15.063] Resolving futures part of globals (recursively) ... DONE
[10:26:15.063] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:15.064] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:26:15.064] - globals: [1] ‘a’
[10:26:15.064] 
[10:26:15.064] getGlobalsAndPackages() ... DONE
[10:26:15.064] run() for ‘Future’ ...
[10:26:15.064] - state: ‘created’
[10:26:15.065] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:15.078] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:15.078] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:15.078]   - Field: ‘node’
[10:26:15.078]   - Field: ‘label’
[10:26:15.079]   - Field: ‘local’
[10:26:15.079]   - Field: ‘owner’
[10:26:15.079]   - Field: ‘envir’
[10:26:15.079]   - Field: ‘workers’
[10:26:15.079]   - Field: ‘packages’
[10:26:15.079]   - Field: ‘gc’
[10:26:15.079]   - Field: ‘conditions’
[10:26:15.079]   - Field: ‘persistent’
[10:26:15.079]   - Field: ‘expr’
[10:26:15.079]   - Field: ‘uuid’
[10:26:15.079]   - Field: ‘seed’
[10:26:15.080]   - Field: ‘version’
[10:26:15.080]   - Field: ‘result’
[10:26:15.080]   - Field: ‘asynchronous’
[10:26:15.080]   - Field: ‘calls’
[10:26:15.080]   - Field: ‘globals’
[10:26:15.080]   - Field: ‘stdout’
[10:26:15.080]   - Field: ‘earlySignal’
[10:26:15.080]   - Field: ‘lazy’
[10:26:15.080]   - Field: ‘state’
[10:26:15.080] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:15.080] - Launch lazy future ...
[10:26:15.081] Packages needed by the future expression (n = 0): <none>
[10:26:15.081] Packages needed by future strategies (n = 0): <none>
[10:26:15.081] {
[10:26:15.081]     {
[10:26:15.081]         {
[10:26:15.081]             ...future.startTime <- base::Sys.time()
[10:26:15.081]             {
[10:26:15.081]                 {
[10:26:15.081]                   {
[10:26:15.081]                     {
[10:26:15.081]                       base::local({
[10:26:15.081]                         has_future <- base::requireNamespace("future", 
[10:26:15.081]                           quietly = TRUE)
[10:26:15.081]                         if (has_future) {
[10:26:15.081]                           ns <- base::getNamespace("future")
[10:26:15.081]                           version <- ns[[".package"]][["version"]]
[10:26:15.081]                           if (is.null(version)) 
[10:26:15.081]                             version <- utils::packageVersion("future")
[10:26:15.081]                         }
[10:26:15.081]                         else {
[10:26:15.081]                           version <- NULL
[10:26:15.081]                         }
[10:26:15.081]                         if (!has_future || version < "1.8.0") {
[10:26:15.081]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:15.081]                             "", base::R.version$version.string), 
[10:26:15.081]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:15.081]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:15.081]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:15.081]                               "release", "version")], collapse = " "), 
[10:26:15.081]                             hostname = base::Sys.info()[["nodename"]])
[10:26:15.081]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:15.081]                             info)
[10:26:15.081]                           info <- base::paste(info, collapse = "; ")
[10:26:15.081]                           if (!has_future) {
[10:26:15.081]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:15.081]                               info)
[10:26:15.081]                           }
[10:26:15.081]                           else {
[10:26:15.081]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:15.081]                               info, version)
[10:26:15.081]                           }
[10:26:15.081]                           base::stop(msg)
[10:26:15.081]                         }
[10:26:15.081]                       })
[10:26:15.081]                     }
[10:26:15.081]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:15.081]                     base::options(mc.cores = 1L)
[10:26:15.081]                   }
[10:26:15.081]                   options(future.plan = NULL)
[10:26:15.081]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.081]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:15.081]                 }
[10:26:15.081]                 ...future.workdir <- getwd()
[10:26:15.081]             }
[10:26:15.081]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:15.081]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:15.081]         }
[10:26:15.081]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:15.081]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:15.081]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:15.081]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:15.081]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:15.081]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:15.081]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:15.081]             base::names(...future.oldOptions))
[10:26:15.081]     }
[10:26:15.081]     if (FALSE) {
[10:26:15.081]     }
[10:26:15.081]     else {
[10:26:15.081]         if (TRUE) {
[10:26:15.081]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:15.081]                 open = "w")
[10:26:15.081]         }
[10:26:15.081]         else {
[10:26:15.081]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:15.081]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:15.081]         }
[10:26:15.081]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:15.081]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:15.081]             base::sink(type = "output", split = FALSE)
[10:26:15.081]             base::close(...future.stdout)
[10:26:15.081]         }, add = TRUE)
[10:26:15.081]     }
[10:26:15.081]     ...future.frame <- base::sys.nframe()
[10:26:15.081]     ...future.conditions <- base::list()
[10:26:15.081]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:15.081]     if (FALSE) {
[10:26:15.081]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:15.081]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:15.081]     }
[10:26:15.081]     ...future.result <- base::tryCatch({
[10:26:15.081]         base::withCallingHandlers({
[10:26:15.081]             ...future.value <- base::withVisible(base::local({
[10:26:15.081]                 ...future.makeSendCondition <- base::local({
[10:26:15.081]                   sendCondition <- NULL
[10:26:15.081]                   function(frame = 1L) {
[10:26:15.081]                     if (is.function(sendCondition)) 
[10:26:15.081]                       return(sendCondition)
[10:26:15.081]                     ns <- getNamespace("parallel")
[10:26:15.081]                     if (exists("sendData", mode = "function", 
[10:26:15.081]                       envir = ns)) {
[10:26:15.081]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:15.081]                         envir = ns)
[10:26:15.081]                       envir <- sys.frame(frame)
[10:26:15.081]                       master <- NULL
[10:26:15.081]                       while (!identical(envir, .GlobalEnv) && 
[10:26:15.081]                         !identical(envir, emptyenv())) {
[10:26:15.081]                         if (exists("master", mode = "list", envir = envir, 
[10:26:15.081]                           inherits = FALSE)) {
[10:26:15.081]                           master <- get("master", mode = "list", 
[10:26:15.081]                             envir = envir, inherits = FALSE)
[10:26:15.081]                           if (inherits(master, c("SOCKnode", 
[10:26:15.081]                             "SOCK0node"))) {
[10:26:15.081]                             sendCondition <<- function(cond) {
[10:26:15.081]                               data <- list(type = "VALUE", value = cond, 
[10:26:15.081]                                 success = TRUE)
[10:26:15.081]                               parallel_sendData(master, data)
[10:26:15.081]                             }
[10:26:15.081]                             return(sendCondition)
[10:26:15.081]                           }
[10:26:15.081]                         }
[10:26:15.081]                         frame <- frame + 1L
[10:26:15.081]                         envir <- sys.frame(frame)
[10:26:15.081]                       }
[10:26:15.081]                     }
[10:26:15.081]                     sendCondition <<- function(cond) NULL
[10:26:15.081]                   }
[10:26:15.081]                 })
[10:26:15.081]                 withCallingHandlers({
[10:26:15.081]                   {
[10:26:15.081]                     b <- a
[10:26:15.081]                     a <- 2
[10:26:15.081]                     a * b
[10:26:15.081]                   }
[10:26:15.081]                 }, immediateCondition = function(cond) {
[10:26:15.081]                   sendCondition <- ...future.makeSendCondition()
[10:26:15.081]                   sendCondition(cond)
[10:26:15.081]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.081]                   {
[10:26:15.081]                     inherits <- base::inherits
[10:26:15.081]                     invokeRestart <- base::invokeRestart
[10:26:15.081]                     is.null <- base::is.null
[10:26:15.081]                     muffled <- FALSE
[10:26:15.081]                     if (inherits(cond, "message")) {
[10:26:15.081]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:15.081]                       if (muffled) 
[10:26:15.081]                         invokeRestart("muffleMessage")
[10:26:15.081]                     }
[10:26:15.081]                     else if (inherits(cond, "warning")) {
[10:26:15.081]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:15.081]                       if (muffled) 
[10:26:15.081]                         invokeRestart("muffleWarning")
[10:26:15.081]                     }
[10:26:15.081]                     else if (inherits(cond, "condition")) {
[10:26:15.081]                       if (!is.null(pattern)) {
[10:26:15.081]                         computeRestarts <- base::computeRestarts
[10:26:15.081]                         grepl <- base::grepl
[10:26:15.081]                         restarts <- computeRestarts(cond)
[10:26:15.081]                         for (restart in restarts) {
[10:26:15.081]                           name <- restart$name
[10:26:15.081]                           if (is.null(name)) 
[10:26:15.081]                             next
[10:26:15.081]                           if (!grepl(pattern, name)) 
[10:26:15.081]                             next
[10:26:15.081]                           invokeRestart(restart)
[10:26:15.081]                           muffled <- TRUE
[10:26:15.081]                           break
[10:26:15.081]                         }
[10:26:15.081]                       }
[10:26:15.081]                     }
[10:26:15.081]                     invisible(muffled)
[10:26:15.081]                   }
[10:26:15.081]                   muffleCondition(cond)
[10:26:15.081]                 })
[10:26:15.081]             }))
[10:26:15.081]             future::FutureResult(value = ...future.value$value, 
[10:26:15.081]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.081]                   ...future.rng), globalenv = if (FALSE) 
[10:26:15.081]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:15.081]                     ...future.globalenv.names))
[10:26:15.081]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:15.081]         }, condition = base::local({
[10:26:15.081]             c <- base::c
[10:26:15.081]             inherits <- base::inherits
[10:26:15.081]             invokeRestart <- base::invokeRestart
[10:26:15.081]             length <- base::length
[10:26:15.081]             list <- base::list
[10:26:15.081]             seq.int <- base::seq.int
[10:26:15.081]             signalCondition <- base::signalCondition
[10:26:15.081]             sys.calls <- base::sys.calls
[10:26:15.081]             `[[` <- base::`[[`
[10:26:15.081]             `+` <- base::`+`
[10:26:15.081]             `<<-` <- base::`<<-`
[10:26:15.081]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:15.081]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:15.081]                   3L)]
[10:26:15.081]             }
[10:26:15.081]             function(cond) {
[10:26:15.081]                 is_error <- inherits(cond, "error")
[10:26:15.081]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:15.081]                   NULL)
[10:26:15.081]                 if (is_error) {
[10:26:15.081]                   sessionInformation <- function() {
[10:26:15.081]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:15.081]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:15.081]                       search = base::search(), system = base::Sys.info())
[10:26:15.081]                   }
[10:26:15.081]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.081]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:15.081]                     cond$call), session = sessionInformation(), 
[10:26:15.081]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:15.081]                   signalCondition(cond)
[10:26:15.081]                 }
[10:26:15.081]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:15.081]                 "immediateCondition"))) {
[10:26:15.081]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:15.081]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.081]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:15.081]                   if (TRUE && !signal) {
[10:26:15.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.081]                     {
[10:26:15.081]                       inherits <- base::inherits
[10:26:15.081]                       invokeRestart <- base::invokeRestart
[10:26:15.081]                       is.null <- base::is.null
[10:26:15.081]                       muffled <- FALSE
[10:26:15.081]                       if (inherits(cond, "message")) {
[10:26:15.081]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.081]                         if (muffled) 
[10:26:15.081]                           invokeRestart("muffleMessage")
[10:26:15.081]                       }
[10:26:15.081]                       else if (inherits(cond, "warning")) {
[10:26:15.081]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.081]                         if (muffled) 
[10:26:15.081]                           invokeRestart("muffleWarning")
[10:26:15.081]                       }
[10:26:15.081]                       else if (inherits(cond, "condition")) {
[10:26:15.081]                         if (!is.null(pattern)) {
[10:26:15.081]                           computeRestarts <- base::computeRestarts
[10:26:15.081]                           grepl <- base::grepl
[10:26:15.081]                           restarts <- computeRestarts(cond)
[10:26:15.081]                           for (restart in restarts) {
[10:26:15.081]                             name <- restart$name
[10:26:15.081]                             if (is.null(name)) 
[10:26:15.081]                               next
[10:26:15.081]                             if (!grepl(pattern, name)) 
[10:26:15.081]                               next
[10:26:15.081]                             invokeRestart(restart)
[10:26:15.081]                             muffled <- TRUE
[10:26:15.081]                             break
[10:26:15.081]                           }
[10:26:15.081]                         }
[10:26:15.081]                       }
[10:26:15.081]                       invisible(muffled)
[10:26:15.081]                     }
[10:26:15.081]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.081]                   }
[10:26:15.081]                 }
[10:26:15.081]                 else {
[10:26:15.081]                   if (TRUE) {
[10:26:15.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.081]                     {
[10:26:15.081]                       inherits <- base::inherits
[10:26:15.081]                       invokeRestart <- base::invokeRestart
[10:26:15.081]                       is.null <- base::is.null
[10:26:15.081]                       muffled <- FALSE
[10:26:15.081]                       if (inherits(cond, "message")) {
[10:26:15.081]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.081]                         if (muffled) 
[10:26:15.081]                           invokeRestart("muffleMessage")
[10:26:15.081]                       }
[10:26:15.081]                       else if (inherits(cond, "warning")) {
[10:26:15.081]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.081]                         if (muffled) 
[10:26:15.081]                           invokeRestart("muffleWarning")
[10:26:15.081]                       }
[10:26:15.081]                       else if (inherits(cond, "condition")) {
[10:26:15.081]                         if (!is.null(pattern)) {
[10:26:15.081]                           computeRestarts <- base::computeRestarts
[10:26:15.081]                           grepl <- base::grepl
[10:26:15.081]                           restarts <- computeRestarts(cond)
[10:26:15.081]                           for (restart in restarts) {
[10:26:15.081]                             name <- restart$name
[10:26:15.081]                             if (is.null(name)) 
[10:26:15.081]                               next
[10:26:15.081]                             if (!grepl(pattern, name)) 
[10:26:15.081]                               next
[10:26:15.081]                             invokeRestart(restart)
[10:26:15.081]                             muffled <- TRUE
[10:26:15.081]                             break
[10:26:15.081]                           }
[10:26:15.081]                         }
[10:26:15.081]                       }
[10:26:15.081]                       invisible(muffled)
[10:26:15.081]                     }
[10:26:15.081]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.081]                   }
[10:26:15.081]                 }
[10:26:15.081]             }
[10:26:15.081]         }))
[10:26:15.081]     }, error = function(ex) {
[10:26:15.081]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:15.081]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.081]                 ...future.rng), started = ...future.startTime, 
[10:26:15.081]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:15.081]             version = "1.8"), class = "FutureResult")
[10:26:15.081]     }, finally = {
[10:26:15.081]         if (!identical(...future.workdir, getwd())) 
[10:26:15.081]             setwd(...future.workdir)
[10:26:15.081]         {
[10:26:15.081]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:15.081]                 ...future.oldOptions$nwarnings <- NULL
[10:26:15.081]             }
[10:26:15.081]             base::options(...future.oldOptions)
[10:26:15.081]             if (.Platform$OS.type == "windows") {
[10:26:15.081]                 old_names <- names(...future.oldEnvVars)
[10:26:15.081]                 envs <- base::Sys.getenv()
[10:26:15.081]                 names <- names(envs)
[10:26:15.081]                 common <- intersect(names, old_names)
[10:26:15.081]                 added <- setdiff(names, old_names)
[10:26:15.081]                 removed <- setdiff(old_names, names)
[10:26:15.081]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:15.081]                   envs[common]]
[10:26:15.081]                 NAMES <- toupper(changed)
[10:26:15.081]                 args <- list()
[10:26:15.081]                 for (kk in seq_along(NAMES)) {
[10:26:15.081]                   name <- changed[[kk]]
[10:26:15.081]                   NAME <- NAMES[[kk]]
[10:26:15.081]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.081]                     next
[10:26:15.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.081]                 }
[10:26:15.081]                 NAMES <- toupper(added)
[10:26:15.081]                 for (kk in seq_along(NAMES)) {
[10:26:15.081]                   name <- added[[kk]]
[10:26:15.081]                   NAME <- NAMES[[kk]]
[10:26:15.081]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.081]                     next
[10:26:15.081]                   args[[name]] <- ""
[10:26:15.081]                 }
[10:26:15.081]                 NAMES <- toupper(removed)
[10:26:15.081]                 for (kk in seq_along(NAMES)) {
[10:26:15.081]                   name <- removed[[kk]]
[10:26:15.081]                   NAME <- NAMES[[kk]]
[10:26:15.081]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.081]                     next
[10:26:15.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.081]                 }
[10:26:15.081]                 if (length(args) > 0) 
[10:26:15.081]                   base::do.call(base::Sys.setenv, args = args)
[10:26:15.081]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:15.081]             }
[10:26:15.081]             else {
[10:26:15.081]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:15.081]             }
[10:26:15.081]             {
[10:26:15.081]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:15.081]                   0L) {
[10:26:15.081]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:15.081]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:15.081]                   base::options(opts)
[10:26:15.081]                 }
[10:26:15.081]                 {
[10:26:15.081]                   {
[10:26:15.081]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:15.081]                     NULL
[10:26:15.081]                   }
[10:26:15.081]                   options(future.plan = NULL)
[10:26:15.081]                   if (is.na(NA_character_)) 
[10:26:15.081]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.081]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:15.081]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:15.081]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:15.081]                     envir = parent.frame()) 
[10:26:15.081]                   {
[10:26:15.081]                     if (is.function(workers)) 
[10:26:15.081]                       workers <- workers()
[10:26:15.081]                     workers <- structure(as.integer(workers), 
[10:26:15.081]                       class = class(workers))
[10:26:15.081]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:15.081]                       workers >= 1)
[10:26:15.081]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:15.081]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:15.081]                     }
[10:26:15.081]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:15.081]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:15.081]                       envir = envir)
[10:26:15.081]                     if (!future$lazy) 
[10:26:15.081]                       future <- run(future)
[10:26:15.081]                     invisible(future)
[10:26:15.081]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:15.081]                 }
[10:26:15.081]             }
[10:26:15.081]         }
[10:26:15.081]     })
[10:26:15.081]     if (TRUE) {
[10:26:15.081]         base::sink(type = "output", split = FALSE)
[10:26:15.081]         if (TRUE) {
[10:26:15.081]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:15.081]         }
[10:26:15.081]         else {
[10:26:15.081]             ...future.result["stdout"] <- base::list(NULL)
[10:26:15.081]         }
[10:26:15.081]         base::close(...future.stdout)
[10:26:15.081]         ...future.stdout <- NULL
[10:26:15.081]     }
[10:26:15.081]     ...future.result$conditions <- ...future.conditions
[10:26:15.081]     ...future.result$finished <- base::Sys.time()
[10:26:15.081]     ...future.result
[10:26:15.081] }
[10:26:15.084] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[10:26:15.084] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[10:26:15.084] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[10:26:15.084] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[10:26:15.085] MultisessionFuture started
[10:26:15.085] - Launch lazy future ... done
[10:26:15.085] run() for ‘MultisessionFuture’ ... done
[10:26:15.085] result() for ClusterFuture ...
[10:26:15.085] receiveMessageFromWorker() for ClusterFuture ...
[10:26:15.086] - Validating connection of MultisessionFuture
[10:26:15.130] - received message: FutureResult
[10:26:15.131] - Received FutureResult
[10:26:15.131] - Erased future from FutureRegistry
[10:26:15.131] result() for ClusterFuture ...
[10:26:15.131] - result already collected: FutureResult
[10:26:15.131] result() for ClusterFuture ... done
[10:26:15.131] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:15.131] result() for ClusterFuture ... done
[10:26:15.131] result() for ClusterFuture ...
[10:26:15.131] - result already collected: FutureResult
[10:26:15.131] result() for ClusterFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:15.132] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:15.132] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:15.134] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:26:15.134] Searching for globals ... DONE
[10:26:15.134] Resolving globals: TRUE
[10:26:15.134] Resolving any globals that are futures ...
[10:26:15.134] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:26:15.134] Resolving any globals that are futures ... DONE
[10:26:15.135] Resolving futures part of globals (recursively) ...
[10:26:15.135] resolve() on list ...
[10:26:15.135]  recursive: 99
[10:26:15.135]  length: 1
[10:26:15.135]  elements: ‘a’
[10:26:15.135]  length: 0 (resolved future 1)
[10:26:15.135] resolve() on list ... DONE
[10:26:15.136] - globals: [1] ‘a’
[10:26:15.136] Resolving futures part of globals (recursively) ... DONE
[10:26:15.136] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:15.136] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:26:15.136] - globals: [1] ‘a’
[10:26:15.136] 
[10:26:15.136] getGlobalsAndPackages() ... DONE
[10:26:15.137] run() for ‘Future’ ...
[10:26:15.137] - state: ‘created’
[10:26:15.137] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:15.150] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:15.151] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:15.151]   - Field: ‘node’
[10:26:15.151]   - Field: ‘label’
[10:26:15.151]   - Field: ‘local’
[10:26:15.151]   - Field: ‘owner’
[10:26:15.151]   - Field: ‘envir’
[10:26:15.151]   - Field: ‘workers’
[10:26:15.151]   - Field: ‘packages’
[10:26:15.151]   - Field: ‘gc’
[10:26:15.151]   - Field: ‘conditions’
[10:26:15.152]   - Field: ‘persistent’
[10:26:15.152]   - Field: ‘expr’
[10:26:15.152]   - Field: ‘uuid’
[10:26:15.152]   - Field: ‘seed’
[10:26:15.152]   - Field: ‘version’
[10:26:15.152]   - Field: ‘result’
[10:26:15.152]   - Field: ‘asynchronous’
[10:26:15.152]   - Field: ‘calls’
[10:26:15.152]   - Field: ‘globals’
[10:26:15.152]   - Field: ‘stdout’
[10:26:15.152]   - Field: ‘earlySignal’
[10:26:15.153]   - Field: ‘lazy’
[10:26:15.153]   - Field: ‘state’
[10:26:15.153] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:15.153] - Launch lazy future ...
[10:26:15.153] Packages needed by the future expression (n = 0): <none>
[10:26:15.153] Packages needed by future strategies (n = 0): <none>
[10:26:15.154] {
[10:26:15.154]     {
[10:26:15.154]         {
[10:26:15.154]             ...future.startTime <- base::Sys.time()
[10:26:15.154]             {
[10:26:15.154]                 {
[10:26:15.154]                   {
[10:26:15.154]                     {
[10:26:15.154]                       base::local({
[10:26:15.154]                         has_future <- base::requireNamespace("future", 
[10:26:15.154]                           quietly = TRUE)
[10:26:15.154]                         if (has_future) {
[10:26:15.154]                           ns <- base::getNamespace("future")
[10:26:15.154]                           version <- ns[[".package"]][["version"]]
[10:26:15.154]                           if (is.null(version)) 
[10:26:15.154]                             version <- utils::packageVersion("future")
[10:26:15.154]                         }
[10:26:15.154]                         else {
[10:26:15.154]                           version <- NULL
[10:26:15.154]                         }
[10:26:15.154]                         if (!has_future || version < "1.8.0") {
[10:26:15.154]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:15.154]                             "", base::R.version$version.string), 
[10:26:15.154]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:15.154]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:15.154]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:15.154]                               "release", "version")], collapse = " "), 
[10:26:15.154]                             hostname = base::Sys.info()[["nodename"]])
[10:26:15.154]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:15.154]                             info)
[10:26:15.154]                           info <- base::paste(info, collapse = "; ")
[10:26:15.154]                           if (!has_future) {
[10:26:15.154]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:15.154]                               info)
[10:26:15.154]                           }
[10:26:15.154]                           else {
[10:26:15.154]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:15.154]                               info, version)
[10:26:15.154]                           }
[10:26:15.154]                           base::stop(msg)
[10:26:15.154]                         }
[10:26:15.154]                       })
[10:26:15.154]                     }
[10:26:15.154]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:15.154]                     base::options(mc.cores = 1L)
[10:26:15.154]                   }
[10:26:15.154]                   options(future.plan = NULL)
[10:26:15.154]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.154]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:15.154]                 }
[10:26:15.154]                 ...future.workdir <- getwd()
[10:26:15.154]             }
[10:26:15.154]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:15.154]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:15.154]         }
[10:26:15.154]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:15.154]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:15.154]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:15.154]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:15.154]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:15.154]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:15.154]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:15.154]             base::names(...future.oldOptions))
[10:26:15.154]     }
[10:26:15.154]     if (FALSE) {
[10:26:15.154]     }
[10:26:15.154]     else {
[10:26:15.154]         if (TRUE) {
[10:26:15.154]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:15.154]                 open = "w")
[10:26:15.154]         }
[10:26:15.154]         else {
[10:26:15.154]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:15.154]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:15.154]         }
[10:26:15.154]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:15.154]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:15.154]             base::sink(type = "output", split = FALSE)
[10:26:15.154]             base::close(...future.stdout)
[10:26:15.154]         }, add = TRUE)
[10:26:15.154]     }
[10:26:15.154]     ...future.frame <- base::sys.nframe()
[10:26:15.154]     ...future.conditions <- base::list()
[10:26:15.154]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:15.154]     if (FALSE) {
[10:26:15.154]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:15.154]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:15.154]     }
[10:26:15.154]     ...future.result <- base::tryCatch({
[10:26:15.154]         base::withCallingHandlers({
[10:26:15.154]             ...future.value <- base::withVisible(base::local({
[10:26:15.154]                 ...future.makeSendCondition <- base::local({
[10:26:15.154]                   sendCondition <- NULL
[10:26:15.154]                   function(frame = 1L) {
[10:26:15.154]                     if (is.function(sendCondition)) 
[10:26:15.154]                       return(sendCondition)
[10:26:15.154]                     ns <- getNamespace("parallel")
[10:26:15.154]                     if (exists("sendData", mode = "function", 
[10:26:15.154]                       envir = ns)) {
[10:26:15.154]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:15.154]                         envir = ns)
[10:26:15.154]                       envir <- sys.frame(frame)
[10:26:15.154]                       master <- NULL
[10:26:15.154]                       while (!identical(envir, .GlobalEnv) && 
[10:26:15.154]                         !identical(envir, emptyenv())) {
[10:26:15.154]                         if (exists("master", mode = "list", envir = envir, 
[10:26:15.154]                           inherits = FALSE)) {
[10:26:15.154]                           master <- get("master", mode = "list", 
[10:26:15.154]                             envir = envir, inherits = FALSE)
[10:26:15.154]                           if (inherits(master, c("SOCKnode", 
[10:26:15.154]                             "SOCK0node"))) {
[10:26:15.154]                             sendCondition <<- function(cond) {
[10:26:15.154]                               data <- list(type = "VALUE", value = cond, 
[10:26:15.154]                                 success = TRUE)
[10:26:15.154]                               parallel_sendData(master, data)
[10:26:15.154]                             }
[10:26:15.154]                             return(sendCondition)
[10:26:15.154]                           }
[10:26:15.154]                         }
[10:26:15.154]                         frame <- frame + 1L
[10:26:15.154]                         envir <- sys.frame(frame)
[10:26:15.154]                       }
[10:26:15.154]                     }
[10:26:15.154]                     sendCondition <<- function(cond) NULL
[10:26:15.154]                   }
[10:26:15.154]                 })
[10:26:15.154]                 withCallingHandlers({
[10:26:15.154]                   {
[10:26:15.154]                     b <- a
[10:26:15.154]                     a <- 2
[10:26:15.154]                     a * b
[10:26:15.154]                   }
[10:26:15.154]                 }, immediateCondition = function(cond) {
[10:26:15.154]                   sendCondition <- ...future.makeSendCondition()
[10:26:15.154]                   sendCondition(cond)
[10:26:15.154]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.154]                   {
[10:26:15.154]                     inherits <- base::inherits
[10:26:15.154]                     invokeRestart <- base::invokeRestart
[10:26:15.154]                     is.null <- base::is.null
[10:26:15.154]                     muffled <- FALSE
[10:26:15.154]                     if (inherits(cond, "message")) {
[10:26:15.154]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:15.154]                       if (muffled) 
[10:26:15.154]                         invokeRestart("muffleMessage")
[10:26:15.154]                     }
[10:26:15.154]                     else if (inherits(cond, "warning")) {
[10:26:15.154]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:15.154]                       if (muffled) 
[10:26:15.154]                         invokeRestart("muffleWarning")
[10:26:15.154]                     }
[10:26:15.154]                     else if (inherits(cond, "condition")) {
[10:26:15.154]                       if (!is.null(pattern)) {
[10:26:15.154]                         computeRestarts <- base::computeRestarts
[10:26:15.154]                         grepl <- base::grepl
[10:26:15.154]                         restarts <- computeRestarts(cond)
[10:26:15.154]                         for (restart in restarts) {
[10:26:15.154]                           name <- restart$name
[10:26:15.154]                           if (is.null(name)) 
[10:26:15.154]                             next
[10:26:15.154]                           if (!grepl(pattern, name)) 
[10:26:15.154]                             next
[10:26:15.154]                           invokeRestart(restart)
[10:26:15.154]                           muffled <- TRUE
[10:26:15.154]                           break
[10:26:15.154]                         }
[10:26:15.154]                       }
[10:26:15.154]                     }
[10:26:15.154]                     invisible(muffled)
[10:26:15.154]                   }
[10:26:15.154]                   muffleCondition(cond)
[10:26:15.154]                 })
[10:26:15.154]             }))
[10:26:15.154]             future::FutureResult(value = ...future.value$value, 
[10:26:15.154]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.154]                   ...future.rng), globalenv = if (FALSE) 
[10:26:15.154]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:15.154]                     ...future.globalenv.names))
[10:26:15.154]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:15.154]         }, condition = base::local({
[10:26:15.154]             c <- base::c
[10:26:15.154]             inherits <- base::inherits
[10:26:15.154]             invokeRestart <- base::invokeRestart
[10:26:15.154]             length <- base::length
[10:26:15.154]             list <- base::list
[10:26:15.154]             seq.int <- base::seq.int
[10:26:15.154]             signalCondition <- base::signalCondition
[10:26:15.154]             sys.calls <- base::sys.calls
[10:26:15.154]             `[[` <- base::`[[`
[10:26:15.154]             `+` <- base::`+`
[10:26:15.154]             `<<-` <- base::`<<-`
[10:26:15.154]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:15.154]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:15.154]                   3L)]
[10:26:15.154]             }
[10:26:15.154]             function(cond) {
[10:26:15.154]                 is_error <- inherits(cond, "error")
[10:26:15.154]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:15.154]                   NULL)
[10:26:15.154]                 if (is_error) {
[10:26:15.154]                   sessionInformation <- function() {
[10:26:15.154]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:15.154]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:15.154]                       search = base::search(), system = base::Sys.info())
[10:26:15.154]                   }
[10:26:15.154]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.154]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:15.154]                     cond$call), session = sessionInformation(), 
[10:26:15.154]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:15.154]                   signalCondition(cond)
[10:26:15.154]                 }
[10:26:15.154]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:15.154]                 "immediateCondition"))) {
[10:26:15.154]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:15.154]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.154]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:15.154]                   if (TRUE && !signal) {
[10:26:15.154]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.154]                     {
[10:26:15.154]                       inherits <- base::inherits
[10:26:15.154]                       invokeRestart <- base::invokeRestart
[10:26:15.154]                       is.null <- base::is.null
[10:26:15.154]                       muffled <- FALSE
[10:26:15.154]                       if (inherits(cond, "message")) {
[10:26:15.154]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.154]                         if (muffled) 
[10:26:15.154]                           invokeRestart("muffleMessage")
[10:26:15.154]                       }
[10:26:15.154]                       else if (inherits(cond, "warning")) {
[10:26:15.154]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.154]                         if (muffled) 
[10:26:15.154]                           invokeRestart("muffleWarning")
[10:26:15.154]                       }
[10:26:15.154]                       else if (inherits(cond, "condition")) {
[10:26:15.154]                         if (!is.null(pattern)) {
[10:26:15.154]                           computeRestarts <- base::computeRestarts
[10:26:15.154]                           grepl <- base::grepl
[10:26:15.154]                           restarts <- computeRestarts(cond)
[10:26:15.154]                           for (restart in restarts) {
[10:26:15.154]                             name <- restart$name
[10:26:15.154]                             if (is.null(name)) 
[10:26:15.154]                               next
[10:26:15.154]                             if (!grepl(pattern, name)) 
[10:26:15.154]                               next
[10:26:15.154]                             invokeRestart(restart)
[10:26:15.154]                             muffled <- TRUE
[10:26:15.154]                             break
[10:26:15.154]                           }
[10:26:15.154]                         }
[10:26:15.154]                       }
[10:26:15.154]                       invisible(muffled)
[10:26:15.154]                     }
[10:26:15.154]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.154]                   }
[10:26:15.154]                 }
[10:26:15.154]                 else {
[10:26:15.154]                   if (TRUE) {
[10:26:15.154]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.154]                     {
[10:26:15.154]                       inherits <- base::inherits
[10:26:15.154]                       invokeRestart <- base::invokeRestart
[10:26:15.154]                       is.null <- base::is.null
[10:26:15.154]                       muffled <- FALSE
[10:26:15.154]                       if (inherits(cond, "message")) {
[10:26:15.154]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.154]                         if (muffled) 
[10:26:15.154]                           invokeRestart("muffleMessage")
[10:26:15.154]                       }
[10:26:15.154]                       else if (inherits(cond, "warning")) {
[10:26:15.154]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.154]                         if (muffled) 
[10:26:15.154]                           invokeRestart("muffleWarning")
[10:26:15.154]                       }
[10:26:15.154]                       else if (inherits(cond, "condition")) {
[10:26:15.154]                         if (!is.null(pattern)) {
[10:26:15.154]                           computeRestarts <- base::computeRestarts
[10:26:15.154]                           grepl <- base::grepl
[10:26:15.154]                           restarts <- computeRestarts(cond)
[10:26:15.154]                           for (restart in restarts) {
[10:26:15.154]                             name <- restart$name
[10:26:15.154]                             if (is.null(name)) 
[10:26:15.154]                               next
[10:26:15.154]                             if (!grepl(pattern, name)) 
[10:26:15.154]                               next
[10:26:15.154]                             invokeRestart(restart)
[10:26:15.154]                             muffled <- TRUE
[10:26:15.154]                             break
[10:26:15.154]                           }
[10:26:15.154]                         }
[10:26:15.154]                       }
[10:26:15.154]                       invisible(muffled)
[10:26:15.154]                     }
[10:26:15.154]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.154]                   }
[10:26:15.154]                 }
[10:26:15.154]             }
[10:26:15.154]         }))
[10:26:15.154]     }, error = function(ex) {
[10:26:15.154]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:15.154]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.154]                 ...future.rng), started = ...future.startTime, 
[10:26:15.154]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:15.154]             version = "1.8"), class = "FutureResult")
[10:26:15.154]     }, finally = {
[10:26:15.154]         if (!identical(...future.workdir, getwd())) 
[10:26:15.154]             setwd(...future.workdir)
[10:26:15.154]         {
[10:26:15.154]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:15.154]                 ...future.oldOptions$nwarnings <- NULL
[10:26:15.154]             }
[10:26:15.154]             base::options(...future.oldOptions)
[10:26:15.154]             if (.Platform$OS.type == "windows") {
[10:26:15.154]                 old_names <- names(...future.oldEnvVars)
[10:26:15.154]                 envs <- base::Sys.getenv()
[10:26:15.154]                 names <- names(envs)
[10:26:15.154]                 common <- intersect(names, old_names)
[10:26:15.154]                 added <- setdiff(names, old_names)
[10:26:15.154]                 removed <- setdiff(old_names, names)
[10:26:15.154]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:15.154]                   envs[common]]
[10:26:15.154]                 NAMES <- toupper(changed)
[10:26:15.154]                 args <- list()
[10:26:15.154]                 for (kk in seq_along(NAMES)) {
[10:26:15.154]                   name <- changed[[kk]]
[10:26:15.154]                   NAME <- NAMES[[kk]]
[10:26:15.154]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.154]                     next
[10:26:15.154]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.154]                 }
[10:26:15.154]                 NAMES <- toupper(added)
[10:26:15.154]                 for (kk in seq_along(NAMES)) {
[10:26:15.154]                   name <- added[[kk]]
[10:26:15.154]                   NAME <- NAMES[[kk]]
[10:26:15.154]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.154]                     next
[10:26:15.154]                   args[[name]] <- ""
[10:26:15.154]                 }
[10:26:15.154]                 NAMES <- toupper(removed)
[10:26:15.154]                 for (kk in seq_along(NAMES)) {
[10:26:15.154]                   name <- removed[[kk]]
[10:26:15.154]                   NAME <- NAMES[[kk]]
[10:26:15.154]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.154]                     next
[10:26:15.154]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.154]                 }
[10:26:15.154]                 if (length(args) > 0) 
[10:26:15.154]                   base::do.call(base::Sys.setenv, args = args)
[10:26:15.154]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:15.154]             }
[10:26:15.154]             else {
[10:26:15.154]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:15.154]             }
[10:26:15.154]             {
[10:26:15.154]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:15.154]                   0L) {
[10:26:15.154]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:15.154]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:15.154]                   base::options(opts)
[10:26:15.154]                 }
[10:26:15.154]                 {
[10:26:15.154]                   {
[10:26:15.154]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:15.154]                     NULL
[10:26:15.154]                   }
[10:26:15.154]                   options(future.plan = NULL)
[10:26:15.154]                   if (is.na(NA_character_)) 
[10:26:15.154]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.154]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:15.154]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:15.154]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:15.154]                     envir = parent.frame()) 
[10:26:15.154]                   {
[10:26:15.154]                     if (is.function(workers)) 
[10:26:15.154]                       workers <- workers()
[10:26:15.154]                     workers <- structure(as.integer(workers), 
[10:26:15.154]                       class = class(workers))
[10:26:15.154]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:15.154]                       workers >= 1)
[10:26:15.154]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:15.154]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:15.154]                     }
[10:26:15.154]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:15.154]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:15.154]                       envir = envir)
[10:26:15.154]                     if (!future$lazy) 
[10:26:15.154]                       future <- run(future)
[10:26:15.154]                     invisible(future)
[10:26:15.154]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:15.154]                 }
[10:26:15.154]             }
[10:26:15.154]         }
[10:26:15.154]     })
[10:26:15.154]     if (TRUE) {
[10:26:15.154]         base::sink(type = "output", split = FALSE)
[10:26:15.154]         if (TRUE) {
[10:26:15.154]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:15.154]         }
[10:26:15.154]         else {
[10:26:15.154]             ...future.result["stdout"] <- base::list(NULL)
[10:26:15.154]         }
[10:26:15.154]         base::close(...future.stdout)
[10:26:15.154]         ...future.stdout <- NULL
[10:26:15.154]     }
[10:26:15.154]     ...future.result$conditions <- ...future.conditions
[10:26:15.154]     ...future.result$finished <- base::Sys.time()
[10:26:15.154]     ...future.result
[10:26:15.154] }
[10:26:15.156] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[10:26:15.156] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[10:26:15.157] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[10:26:15.157] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[10:26:15.157] MultisessionFuture started
[10:26:15.158] - Launch lazy future ... done
[10:26:15.158] run() for ‘MultisessionFuture’ ... done
[10:26:15.158] result() for ClusterFuture ...
[10:26:15.158] receiveMessageFromWorker() for ClusterFuture ...
[10:26:15.158] - Validating connection of MultisessionFuture
[10:26:15.202] - received message: FutureResult
[10:26:15.202] - Received FutureResult
[10:26:15.203] - Erased future from FutureRegistry
[10:26:15.203] result() for ClusterFuture ...
[10:26:15.203] - result already collected: FutureResult
[10:26:15.203] result() for ClusterFuture ... done
[10:26:15.203] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:15.203] result() for ClusterFuture ... done
[10:26:15.203] result() for ClusterFuture ...
[10:26:15.203] - result already collected: FutureResult
[10:26:15.203] result() for ClusterFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:15.204] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:15.204] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:15.206] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:15.206] Searching for globals ... DONE
[10:26:15.206] Resolving globals: TRUE
[10:26:15.206] Resolving any globals that are futures ...
[10:26:15.206] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:15.206] Resolving any globals that are futures ... DONE
[10:26:15.207] Resolving futures part of globals (recursively) ...
[10:26:15.207] resolve() on list ...
[10:26:15.207]  recursive: 99
[10:26:15.207]  length: 2
[10:26:15.207]  elements: ‘a’, ‘ii’
[10:26:15.207]  length: 1 (resolved future 1)
[10:26:15.207]  length: 0 (resolved future 2)
[10:26:15.208] resolve() on list ... DONE
[10:26:15.208] - globals: [2] ‘a’, ‘ii’
[10:26:15.208] Resolving futures part of globals (recursively) ... DONE
[10:26:15.208] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:15.210] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:26:15.210] - globals: [2] ‘a’, ‘ii’
[10:26:15.211] 
[10:26:15.211] getGlobalsAndPackages() ... DONE
[10:26:15.211] run() for ‘Future’ ...
[10:26:15.211] - state: ‘created’
[10:26:15.211] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:15.225] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:15.225] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:15.225]   - Field: ‘node’
[10:26:15.225]   - Field: ‘label’
[10:26:15.225]   - Field: ‘local’
[10:26:15.226]   - Field: ‘owner’
[10:26:15.226]   - Field: ‘envir’
[10:26:15.226]   - Field: ‘workers’
[10:26:15.226]   - Field: ‘packages’
[10:26:15.226]   - Field: ‘gc’
[10:26:15.226]   - Field: ‘conditions’
[10:26:15.226]   - Field: ‘persistent’
[10:26:15.226]   - Field: ‘expr’
[10:26:15.226]   - Field: ‘uuid’
[10:26:15.226]   - Field: ‘seed’
[10:26:15.226]   - Field: ‘version’
[10:26:15.227]   - Field: ‘result’
[10:26:15.227]   - Field: ‘asynchronous’
[10:26:15.227]   - Field: ‘calls’
[10:26:15.227]   - Field: ‘globals’
[10:26:15.227]   - Field: ‘stdout’
[10:26:15.227]   - Field: ‘earlySignal’
[10:26:15.227]   - Field: ‘lazy’
[10:26:15.227]   - Field: ‘state’
[10:26:15.227] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:15.227] - Launch lazy future ...
[10:26:15.228] Packages needed by the future expression (n = 0): <none>
[10:26:15.228] Packages needed by future strategies (n = 0): <none>
[10:26:15.228] {
[10:26:15.228]     {
[10:26:15.228]         {
[10:26:15.228]             ...future.startTime <- base::Sys.time()
[10:26:15.228]             {
[10:26:15.228]                 {
[10:26:15.228]                   {
[10:26:15.228]                     {
[10:26:15.228]                       base::local({
[10:26:15.228]                         has_future <- base::requireNamespace("future", 
[10:26:15.228]                           quietly = TRUE)
[10:26:15.228]                         if (has_future) {
[10:26:15.228]                           ns <- base::getNamespace("future")
[10:26:15.228]                           version <- ns[[".package"]][["version"]]
[10:26:15.228]                           if (is.null(version)) 
[10:26:15.228]                             version <- utils::packageVersion("future")
[10:26:15.228]                         }
[10:26:15.228]                         else {
[10:26:15.228]                           version <- NULL
[10:26:15.228]                         }
[10:26:15.228]                         if (!has_future || version < "1.8.0") {
[10:26:15.228]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:15.228]                             "", base::R.version$version.string), 
[10:26:15.228]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:15.228]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:15.228]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:15.228]                               "release", "version")], collapse = " "), 
[10:26:15.228]                             hostname = base::Sys.info()[["nodename"]])
[10:26:15.228]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:15.228]                             info)
[10:26:15.228]                           info <- base::paste(info, collapse = "; ")
[10:26:15.228]                           if (!has_future) {
[10:26:15.228]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:15.228]                               info)
[10:26:15.228]                           }
[10:26:15.228]                           else {
[10:26:15.228]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:15.228]                               info, version)
[10:26:15.228]                           }
[10:26:15.228]                           base::stop(msg)
[10:26:15.228]                         }
[10:26:15.228]                       })
[10:26:15.228]                     }
[10:26:15.228]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:15.228]                     base::options(mc.cores = 1L)
[10:26:15.228]                   }
[10:26:15.228]                   options(future.plan = NULL)
[10:26:15.228]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.228]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:15.228]                 }
[10:26:15.228]                 ...future.workdir <- getwd()
[10:26:15.228]             }
[10:26:15.228]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:15.228]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:15.228]         }
[10:26:15.228]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:15.228]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:15.228]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:15.228]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:15.228]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:15.228]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:15.228]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:15.228]             base::names(...future.oldOptions))
[10:26:15.228]     }
[10:26:15.228]     if (FALSE) {
[10:26:15.228]     }
[10:26:15.228]     else {
[10:26:15.228]         if (TRUE) {
[10:26:15.228]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:15.228]                 open = "w")
[10:26:15.228]         }
[10:26:15.228]         else {
[10:26:15.228]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:15.228]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:15.228]         }
[10:26:15.228]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:15.228]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:15.228]             base::sink(type = "output", split = FALSE)
[10:26:15.228]             base::close(...future.stdout)
[10:26:15.228]         }, add = TRUE)
[10:26:15.228]     }
[10:26:15.228]     ...future.frame <- base::sys.nframe()
[10:26:15.228]     ...future.conditions <- base::list()
[10:26:15.228]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:15.228]     if (FALSE) {
[10:26:15.228]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:15.228]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:15.228]     }
[10:26:15.228]     ...future.result <- base::tryCatch({
[10:26:15.228]         base::withCallingHandlers({
[10:26:15.228]             ...future.value <- base::withVisible(base::local({
[10:26:15.228]                 ...future.makeSendCondition <- base::local({
[10:26:15.228]                   sendCondition <- NULL
[10:26:15.228]                   function(frame = 1L) {
[10:26:15.228]                     if (is.function(sendCondition)) 
[10:26:15.228]                       return(sendCondition)
[10:26:15.228]                     ns <- getNamespace("parallel")
[10:26:15.228]                     if (exists("sendData", mode = "function", 
[10:26:15.228]                       envir = ns)) {
[10:26:15.228]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:15.228]                         envir = ns)
[10:26:15.228]                       envir <- sys.frame(frame)
[10:26:15.228]                       master <- NULL
[10:26:15.228]                       while (!identical(envir, .GlobalEnv) && 
[10:26:15.228]                         !identical(envir, emptyenv())) {
[10:26:15.228]                         if (exists("master", mode = "list", envir = envir, 
[10:26:15.228]                           inherits = FALSE)) {
[10:26:15.228]                           master <- get("master", mode = "list", 
[10:26:15.228]                             envir = envir, inherits = FALSE)
[10:26:15.228]                           if (inherits(master, c("SOCKnode", 
[10:26:15.228]                             "SOCK0node"))) {
[10:26:15.228]                             sendCondition <<- function(cond) {
[10:26:15.228]                               data <- list(type = "VALUE", value = cond, 
[10:26:15.228]                                 success = TRUE)
[10:26:15.228]                               parallel_sendData(master, data)
[10:26:15.228]                             }
[10:26:15.228]                             return(sendCondition)
[10:26:15.228]                           }
[10:26:15.228]                         }
[10:26:15.228]                         frame <- frame + 1L
[10:26:15.228]                         envir <- sys.frame(frame)
[10:26:15.228]                       }
[10:26:15.228]                     }
[10:26:15.228]                     sendCondition <<- function(cond) NULL
[10:26:15.228]                   }
[10:26:15.228]                 })
[10:26:15.228]                 withCallingHandlers({
[10:26:15.228]                   {
[10:26:15.228]                     b <- a * ii
[10:26:15.228]                     a <- 0
[10:26:15.228]                     b
[10:26:15.228]                   }
[10:26:15.228]                 }, immediateCondition = function(cond) {
[10:26:15.228]                   sendCondition <- ...future.makeSendCondition()
[10:26:15.228]                   sendCondition(cond)
[10:26:15.228]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.228]                   {
[10:26:15.228]                     inherits <- base::inherits
[10:26:15.228]                     invokeRestart <- base::invokeRestart
[10:26:15.228]                     is.null <- base::is.null
[10:26:15.228]                     muffled <- FALSE
[10:26:15.228]                     if (inherits(cond, "message")) {
[10:26:15.228]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:15.228]                       if (muffled) 
[10:26:15.228]                         invokeRestart("muffleMessage")
[10:26:15.228]                     }
[10:26:15.228]                     else if (inherits(cond, "warning")) {
[10:26:15.228]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:15.228]                       if (muffled) 
[10:26:15.228]                         invokeRestart("muffleWarning")
[10:26:15.228]                     }
[10:26:15.228]                     else if (inherits(cond, "condition")) {
[10:26:15.228]                       if (!is.null(pattern)) {
[10:26:15.228]                         computeRestarts <- base::computeRestarts
[10:26:15.228]                         grepl <- base::grepl
[10:26:15.228]                         restarts <- computeRestarts(cond)
[10:26:15.228]                         for (restart in restarts) {
[10:26:15.228]                           name <- restart$name
[10:26:15.228]                           if (is.null(name)) 
[10:26:15.228]                             next
[10:26:15.228]                           if (!grepl(pattern, name)) 
[10:26:15.228]                             next
[10:26:15.228]                           invokeRestart(restart)
[10:26:15.228]                           muffled <- TRUE
[10:26:15.228]                           break
[10:26:15.228]                         }
[10:26:15.228]                       }
[10:26:15.228]                     }
[10:26:15.228]                     invisible(muffled)
[10:26:15.228]                   }
[10:26:15.228]                   muffleCondition(cond)
[10:26:15.228]                 })
[10:26:15.228]             }))
[10:26:15.228]             future::FutureResult(value = ...future.value$value, 
[10:26:15.228]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.228]                   ...future.rng), globalenv = if (FALSE) 
[10:26:15.228]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:15.228]                     ...future.globalenv.names))
[10:26:15.228]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:15.228]         }, condition = base::local({
[10:26:15.228]             c <- base::c
[10:26:15.228]             inherits <- base::inherits
[10:26:15.228]             invokeRestart <- base::invokeRestart
[10:26:15.228]             length <- base::length
[10:26:15.228]             list <- base::list
[10:26:15.228]             seq.int <- base::seq.int
[10:26:15.228]             signalCondition <- base::signalCondition
[10:26:15.228]             sys.calls <- base::sys.calls
[10:26:15.228]             `[[` <- base::`[[`
[10:26:15.228]             `+` <- base::`+`
[10:26:15.228]             `<<-` <- base::`<<-`
[10:26:15.228]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:15.228]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:15.228]                   3L)]
[10:26:15.228]             }
[10:26:15.228]             function(cond) {
[10:26:15.228]                 is_error <- inherits(cond, "error")
[10:26:15.228]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:15.228]                   NULL)
[10:26:15.228]                 if (is_error) {
[10:26:15.228]                   sessionInformation <- function() {
[10:26:15.228]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:15.228]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:15.228]                       search = base::search(), system = base::Sys.info())
[10:26:15.228]                   }
[10:26:15.228]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.228]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:15.228]                     cond$call), session = sessionInformation(), 
[10:26:15.228]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:15.228]                   signalCondition(cond)
[10:26:15.228]                 }
[10:26:15.228]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:15.228]                 "immediateCondition"))) {
[10:26:15.228]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:15.228]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.228]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:15.228]                   if (TRUE && !signal) {
[10:26:15.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.228]                     {
[10:26:15.228]                       inherits <- base::inherits
[10:26:15.228]                       invokeRestart <- base::invokeRestart
[10:26:15.228]                       is.null <- base::is.null
[10:26:15.228]                       muffled <- FALSE
[10:26:15.228]                       if (inherits(cond, "message")) {
[10:26:15.228]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.228]                         if (muffled) 
[10:26:15.228]                           invokeRestart("muffleMessage")
[10:26:15.228]                       }
[10:26:15.228]                       else if (inherits(cond, "warning")) {
[10:26:15.228]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.228]                         if (muffled) 
[10:26:15.228]                           invokeRestart("muffleWarning")
[10:26:15.228]                       }
[10:26:15.228]                       else if (inherits(cond, "condition")) {
[10:26:15.228]                         if (!is.null(pattern)) {
[10:26:15.228]                           computeRestarts <- base::computeRestarts
[10:26:15.228]                           grepl <- base::grepl
[10:26:15.228]                           restarts <- computeRestarts(cond)
[10:26:15.228]                           for (restart in restarts) {
[10:26:15.228]                             name <- restart$name
[10:26:15.228]                             if (is.null(name)) 
[10:26:15.228]                               next
[10:26:15.228]                             if (!grepl(pattern, name)) 
[10:26:15.228]                               next
[10:26:15.228]                             invokeRestart(restart)
[10:26:15.228]                             muffled <- TRUE
[10:26:15.228]                             break
[10:26:15.228]                           }
[10:26:15.228]                         }
[10:26:15.228]                       }
[10:26:15.228]                       invisible(muffled)
[10:26:15.228]                     }
[10:26:15.228]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.228]                   }
[10:26:15.228]                 }
[10:26:15.228]                 else {
[10:26:15.228]                   if (TRUE) {
[10:26:15.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.228]                     {
[10:26:15.228]                       inherits <- base::inherits
[10:26:15.228]                       invokeRestart <- base::invokeRestart
[10:26:15.228]                       is.null <- base::is.null
[10:26:15.228]                       muffled <- FALSE
[10:26:15.228]                       if (inherits(cond, "message")) {
[10:26:15.228]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.228]                         if (muffled) 
[10:26:15.228]                           invokeRestart("muffleMessage")
[10:26:15.228]                       }
[10:26:15.228]                       else if (inherits(cond, "warning")) {
[10:26:15.228]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.228]                         if (muffled) 
[10:26:15.228]                           invokeRestart("muffleWarning")
[10:26:15.228]                       }
[10:26:15.228]                       else if (inherits(cond, "condition")) {
[10:26:15.228]                         if (!is.null(pattern)) {
[10:26:15.228]                           computeRestarts <- base::computeRestarts
[10:26:15.228]                           grepl <- base::grepl
[10:26:15.228]                           restarts <- computeRestarts(cond)
[10:26:15.228]                           for (restart in restarts) {
[10:26:15.228]                             name <- restart$name
[10:26:15.228]                             if (is.null(name)) 
[10:26:15.228]                               next
[10:26:15.228]                             if (!grepl(pattern, name)) 
[10:26:15.228]                               next
[10:26:15.228]                             invokeRestart(restart)
[10:26:15.228]                             muffled <- TRUE
[10:26:15.228]                             break
[10:26:15.228]                           }
[10:26:15.228]                         }
[10:26:15.228]                       }
[10:26:15.228]                       invisible(muffled)
[10:26:15.228]                     }
[10:26:15.228]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.228]                   }
[10:26:15.228]                 }
[10:26:15.228]             }
[10:26:15.228]         }))
[10:26:15.228]     }, error = function(ex) {
[10:26:15.228]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:15.228]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.228]                 ...future.rng), started = ...future.startTime, 
[10:26:15.228]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:15.228]             version = "1.8"), class = "FutureResult")
[10:26:15.228]     }, finally = {
[10:26:15.228]         if (!identical(...future.workdir, getwd())) 
[10:26:15.228]             setwd(...future.workdir)
[10:26:15.228]         {
[10:26:15.228]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:15.228]                 ...future.oldOptions$nwarnings <- NULL
[10:26:15.228]             }
[10:26:15.228]             base::options(...future.oldOptions)
[10:26:15.228]             if (.Platform$OS.type == "windows") {
[10:26:15.228]                 old_names <- names(...future.oldEnvVars)
[10:26:15.228]                 envs <- base::Sys.getenv()
[10:26:15.228]                 names <- names(envs)
[10:26:15.228]                 common <- intersect(names, old_names)
[10:26:15.228]                 added <- setdiff(names, old_names)
[10:26:15.228]                 removed <- setdiff(old_names, names)
[10:26:15.228]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:15.228]                   envs[common]]
[10:26:15.228]                 NAMES <- toupper(changed)
[10:26:15.228]                 args <- list()
[10:26:15.228]                 for (kk in seq_along(NAMES)) {
[10:26:15.228]                   name <- changed[[kk]]
[10:26:15.228]                   NAME <- NAMES[[kk]]
[10:26:15.228]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.228]                     next
[10:26:15.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.228]                 }
[10:26:15.228]                 NAMES <- toupper(added)
[10:26:15.228]                 for (kk in seq_along(NAMES)) {
[10:26:15.228]                   name <- added[[kk]]
[10:26:15.228]                   NAME <- NAMES[[kk]]
[10:26:15.228]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.228]                     next
[10:26:15.228]                   args[[name]] <- ""
[10:26:15.228]                 }
[10:26:15.228]                 NAMES <- toupper(removed)
[10:26:15.228]                 for (kk in seq_along(NAMES)) {
[10:26:15.228]                   name <- removed[[kk]]
[10:26:15.228]                   NAME <- NAMES[[kk]]
[10:26:15.228]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.228]                     next
[10:26:15.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.228]                 }
[10:26:15.228]                 if (length(args) > 0) 
[10:26:15.228]                   base::do.call(base::Sys.setenv, args = args)
[10:26:15.228]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:15.228]             }
[10:26:15.228]             else {
[10:26:15.228]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:15.228]             }
[10:26:15.228]             {
[10:26:15.228]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:15.228]                   0L) {
[10:26:15.228]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:15.228]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:15.228]                   base::options(opts)
[10:26:15.228]                 }
[10:26:15.228]                 {
[10:26:15.228]                   {
[10:26:15.228]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:15.228]                     NULL
[10:26:15.228]                   }
[10:26:15.228]                   options(future.plan = NULL)
[10:26:15.228]                   if (is.na(NA_character_)) 
[10:26:15.228]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.228]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:15.228]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:15.228]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:15.228]                     envir = parent.frame()) 
[10:26:15.228]                   {
[10:26:15.228]                     if (is.function(workers)) 
[10:26:15.228]                       workers <- workers()
[10:26:15.228]                     workers <- structure(as.integer(workers), 
[10:26:15.228]                       class = class(workers))
[10:26:15.228]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:15.228]                       workers >= 1)
[10:26:15.228]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:15.228]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:15.228]                     }
[10:26:15.228]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:15.228]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:15.228]                       envir = envir)
[10:26:15.228]                     if (!future$lazy) 
[10:26:15.228]                       future <- run(future)
[10:26:15.228]                     invisible(future)
[10:26:15.228]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:15.228]                 }
[10:26:15.228]             }
[10:26:15.228]         }
[10:26:15.228]     })
[10:26:15.228]     if (TRUE) {
[10:26:15.228]         base::sink(type = "output", split = FALSE)
[10:26:15.228]         if (TRUE) {
[10:26:15.228]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:15.228]         }
[10:26:15.228]         else {
[10:26:15.228]             ...future.result["stdout"] <- base::list(NULL)
[10:26:15.228]         }
[10:26:15.228]         base::close(...future.stdout)
[10:26:15.228]         ...future.stdout <- NULL
[10:26:15.228]     }
[10:26:15.228]     ...future.result$conditions <- ...future.conditions
[10:26:15.228]     ...future.result$finished <- base::Sys.time()
[10:26:15.228]     ...future.result
[10:26:15.228] }
[10:26:15.231] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[10:26:15.231] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[10:26:15.231] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[10:26:15.231] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[10:26:15.231] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[10:26:15.232] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[10:26:15.232] MultisessionFuture started
[10:26:15.232] - Launch lazy future ... done
[10:26:15.232] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:15.233] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:15.233] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:15.235] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:15.235] Searching for globals ... DONE
[10:26:15.235] Resolving globals: TRUE
[10:26:15.235] Resolving any globals that are futures ...
[10:26:15.235] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:15.235] Resolving any globals that are futures ... DONE
[10:26:15.236] Resolving futures part of globals (recursively) ...
[10:26:15.236] resolve() on list ...
[10:26:15.236]  recursive: 99
[10:26:15.236]  length: 2
[10:26:15.236]  elements: ‘a’, ‘ii’
[10:26:15.236]  length: 1 (resolved future 1)
[10:26:15.236]  length: 0 (resolved future 2)
[10:26:15.236] resolve() on list ... DONE
[10:26:15.236] - globals: [2] ‘a’, ‘ii’
[10:26:15.236] Resolving futures part of globals (recursively) ... DONE
[10:26:15.237] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:15.237] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:26:15.237] - globals: [2] ‘a’, ‘ii’
[10:26:15.237] 
[10:26:15.237] getGlobalsAndPackages() ... DONE
[10:26:15.238] run() for ‘Future’ ...
[10:26:15.238] - state: ‘created’
[10:26:15.238] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:15.251] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:15.251] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:15.251]   - Field: ‘node’
[10:26:15.251]   - Field: ‘label’
[10:26:15.251]   - Field: ‘local’
[10:26:15.251]   - Field: ‘owner’
[10:26:15.252]   - Field: ‘envir’
[10:26:15.252]   - Field: ‘workers’
[10:26:15.252]   - Field: ‘packages’
[10:26:15.252]   - Field: ‘gc’
[10:26:15.252]   - Field: ‘conditions’
[10:26:15.252]   - Field: ‘persistent’
[10:26:15.252]   - Field: ‘expr’
[10:26:15.252]   - Field: ‘uuid’
[10:26:15.252]   - Field: ‘seed’
[10:26:15.252]   - Field: ‘version’
[10:26:15.252]   - Field: ‘result’
[10:26:15.253]   - Field: ‘asynchronous’
[10:26:15.253]   - Field: ‘calls’
[10:26:15.253]   - Field: ‘globals’
[10:26:15.253]   - Field: ‘stdout’
[10:26:15.253]   - Field: ‘earlySignal’
[10:26:15.253]   - Field: ‘lazy’
[10:26:15.253]   - Field: ‘state’
[10:26:15.253] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:15.253] - Launch lazy future ...
[10:26:15.254] Packages needed by the future expression (n = 0): <none>
[10:26:15.254] Packages needed by future strategies (n = 0): <none>
[10:26:15.254] {
[10:26:15.254]     {
[10:26:15.254]         {
[10:26:15.254]             ...future.startTime <- base::Sys.time()
[10:26:15.254]             {
[10:26:15.254]                 {
[10:26:15.254]                   {
[10:26:15.254]                     {
[10:26:15.254]                       base::local({
[10:26:15.254]                         has_future <- base::requireNamespace("future", 
[10:26:15.254]                           quietly = TRUE)
[10:26:15.254]                         if (has_future) {
[10:26:15.254]                           ns <- base::getNamespace("future")
[10:26:15.254]                           version <- ns[[".package"]][["version"]]
[10:26:15.254]                           if (is.null(version)) 
[10:26:15.254]                             version <- utils::packageVersion("future")
[10:26:15.254]                         }
[10:26:15.254]                         else {
[10:26:15.254]                           version <- NULL
[10:26:15.254]                         }
[10:26:15.254]                         if (!has_future || version < "1.8.0") {
[10:26:15.254]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:15.254]                             "", base::R.version$version.string), 
[10:26:15.254]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:15.254]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:15.254]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:15.254]                               "release", "version")], collapse = " "), 
[10:26:15.254]                             hostname = base::Sys.info()[["nodename"]])
[10:26:15.254]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:15.254]                             info)
[10:26:15.254]                           info <- base::paste(info, collapse = "; ")
[10:26:15.254]                           if (!has_future) {
[10:26:15.254]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:15.254]                               info)
[10:26:15.254]                           }
[10:26:15.254]                           else {
[10:26:15.254]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:15.254]                               info, version)
[10:26:15.254]                           }
[10:26:15.254]                           base::stop(msg)
[10:26:15.254]                         }
[10:26:15.254]                       })
[10:26:15.254]                     }
[10:26:15.254]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:15.254]                     base::options(mc.cores = 1L)
[10:26:15.254]                   }
[10:26:15.254]                   options(future.plan = NULL)
[10:26:15.254]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.254]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:15.254]                 }
[10:26:15.254]                 ...future.workdir <- getwd()
[10:26:15.254]             }
[10:26:15.254]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:15.254]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:15.254]         }
[10:26:15.254]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:15.254]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:15.254]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:15.254]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:15.254]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:15.254]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:15.254]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:15.254]             base::names(...future.oldOptions))
[10:26:15.254]     }
[10:26:15.254]     if (FALSE) {
[10:26:15.254]     }
[10:26:15.254]     else {
[10:26:15.254]         if (TRUE) {
[10:26:15.254]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:15.254]                 open = "w")
[10:26:15.254]         }
[10:26:15.254]         else {
[10:26:15.254]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:15.254]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:15.254]         }
[10:26:15.254]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:15.254]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:15.254]             base::sink(type = "output", split = FALSE)
[10:26:15.254]             base::close(...future.stdout)
[10:26:15.254]         }, add = TRUE)
[10:26:15.254]     }
[10:26:15.254]     ...future.frame <- base::sys.nframe()
[10:26:15.254]     ...future.conditions <- base::list()
[10:26:15.254]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:15.254]     if (FALSE) {
[10:26:15.254]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:15.254]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:15.254]     }
[10:26:15.254]     ...future.result <- base::tryCatch({
[10:26:15.254]         base::withCallingHandlers({
[10:26:15.254]             ...future.value <- base::withVisible(base::local({
[10:26:15.254]                 ...future.makeSendCondition <- base::local({
[10:26:15.254]                   sendCondition <- NULL
[10:26:15.254]                   function(frame = 1L) {
[10:26:15.254]                     if (is.function(sendCondition)) 
[10:26:15.254]                       return(sendCondition)
[10:26:15.254]                     ns <- getNamespace("parallel")
[10:26:15.254]                     if (exists("sendData", mode = "function", 
[10:26:15.254]                       envir = ns)) {
[10:26:15.254]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:15.254]                         envir = ns)
[10:26:15.254]                       envir <- sys.frame(frame)
[10:26:15.254]                       master <- NULL
[10:26:15.254]                       while (!identical(envir, .GlobalEnv) && 
[10:26:15.254]                         !identical(envir, emptyenv())) {
[10:26:15.254]                         if (exists("master", mode = "list", envir = envir, 
[10:26:15.254]                           inherits = FALSE)) {
[10:26:15.254]                           master <- get("master", mode = "list", 
[10:26:15.254]                             envir = envir, inherits = FALSE)
[10:26:15.254]                           if (inherits(master, c("SOCKnode", 
[10:26:15.254]                             "SOCK0node"))) {
[10:26:15.254]                             sendCondition <<- function(cond) {
[10:26:15.254]                               data <- list(type = "VALUE", value = cond, 
[10:26:15.254]                                 success = TRUE)
[10:26:15.254]                               parallel_sendData(master, data)
[10:26:15.254]                             }
[10:26:15.254]                             return(sendCondition)
[10:26:15.254]                           }
[10:26:15.254]                         }
[10:26:15.254]                         frame <- frame + 1L
[10:26:15.254]                         envir <- sys.frame(frame)
[10:26:15.254]                       }
[10:26:15.254]                     }
[10:26:15.254]                     sendCondition <<- function(cond) NULL
[10:26:15.254]                   }
[10:26:15.254]                 })
[10:26:15.254]                 withCallingHandlers({
[10:26:15.254]                   {
[10:26:15.254]                     b <- a * ii
[10:26:15.254]                     a <- 0
[10:26:15.254]                     b
[10:26:15.254]                   }
[10:26:15.254]                 }, immediateCondition = function(cond) {
[10:26:15.254]                   sendCondition <- ...future.makeSendCondition()
[10:26:15.254]                   sendCondition(cond)
[10:26:15.254]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.254]                   {
[10:26:15.254]                     inherits <- base::inherits
[10:26:15.254]                     invokeRestart <- base::invokeRestart
[10:26:15.254]                     is.null <- base::is.null
[10:26:15.254]                     muffled <- FALSE
[10:26:15.254]                     if (inherits(cond, "message")) {
[10:26:15.254]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:15.254]                       if (muffled) 
[10:26:15.254]                         invokeRestart("muffleMessage")
[10:26:15.254]                     }
[10:26:15.254]                     else if (inherits(cond, "warning")) {
[10:26:15.254]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:15.254]                       if (muffled) 
[10:26:15.254]                         invokeRestart("muffleWarning")
[10:26:15.254]                     }
[10:26:15.254]                     else if (inherits(cond, "condition")) {
[10:26:15.254]                       if (!is.null(pattern)) {
[10:26:15.254]                         computeRestarts <- base::computeRestarts
[10:26:15.254]                         grepl <- base::grepl
[10:26:15.254]                         restarts <- computeRestarts(cond)
[10:26:15.254]                         for (restart in restarts) {
[10:26:15.254]                           name <- restart$name
[10:26:15.254]                           if (is.null(name)) 
[10:26:15.254]                             next
[10:26:15.254]                           if (!grepl(pattern, name)) 
[10:26:15.254]                             next
[10:26:15.254]                           invokeRestart(restart)
[10:26:15.254]                           muffled <- TRUE
[10:26:15.254]                           break
[10:26:15.254]                         }
[10:26:15.254]                       }
[10:26:15.254]                     }
[10:26:15.254]                     invisible(muffled)
[10:26:15.254]                   }
[10:26:15.254]                   muffleCondition(cond)
[10:26:15.254]                 })
[10:26:15.254]             }))
[10:26:15.254]             future::FutureResult(value = ...future.value$value, 
[10:26:15.254]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.254]                   ...future.rng), globalenv = if (FALSE) 
[10:26:15.254]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:15.254]                     ...future.globalenv.names))
[10:26:15.254]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:15.254]         }, condition = base::local({
[10:26:15.254]             c <- base::c
[10:26:15.254]             inherits <- base::inherits
[10:26:15.254]             invokeRestart <- base::invokeRestart
[10:26:15.254]             length <- base::length
[10:26:15.254]             list <- base::list
[10:26:15.254]             seq.int <- base::seq.int
[10:26:15.254]             signalCondition <- base::signalCondition
[10:26:15.254]             sys.calls <- base::sys.calls
[10:26:15.254]             `[[` <- base::`[[`
[10:26:15.254]             `+` <- base::`+`
[10:26:15.254]             `<<-` <- base::`<<-`
[10:26:15.254]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:15.254]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:15.254]                   3L)]
[10:26:15.254]             }
[10:26:15.254]             function(cond) {
[10:26:15.254]                 is_error <- inherits(cond, "error")
[10:26:15.254]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:15.254]                   NULL)
[10:26:15.254]                 if (is_error) {
[10:26:15.254]                   sessionInformation <- function() {
[10:26:15.254]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:15.254]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:15.254]                       search = base::search(), system = base::Sys.info())
[10:26:15.254]                   }
[10:26:15.254]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.254]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:15.254]                     cond$call), session = sessionInformation(), 
[10:26:15.254]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:15.254]                   signalCondition(cond)
[10:26:15.254]                 }
[10:26:15.254]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:15.254]                 "immediateCondition"))) {
[10:26:15.254]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:15.254]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.254]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:15.254]                   if (TRUE && !signal) {
[10:26:15.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.254]                     {
[10:26:15.254]                       inherits <- base::inherits
[10:26:15.254]                       invokeRestart <- base::invokeRestart
[10:26:15.254]                       is.null <- base::is.null
[10:26:15.254]                       muffled <- FALSE
[10:26:15.254]                       if (inherits(cond, "message")) {
[10:26:15.254]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.254]                         if (muffled) 
[10:26:15.254]                           invokeRestart("muffleMessage")
[10:26:15.254]                       }
[10:26:15.254]                       else if (inherits(cond, "warning")) {
[10:26:15.254]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.254]                         if (muffled) 
[10:26:15.254]                           invokeRestart("muffleWarning")
[10:26:15.254]                       }
[10:26:15.254]                       else if (inherits(cond, "condition")) {
[10:26:15.254]                         if (!is.null(pattern)) {
[10:26:15.254]                           computeRestarts <- base::computeRestarts
[10:26:15.254]                           grepl <- base::grepl
[10:26:15.254]                           restarts <- computeRestarts(cond)
[10:26:15.254]                           for (restart in restarts) {
[10:26:15.254]                             name <- restart$name
[10:26:15.254]                             if (is.null(name)) 
[10:26:15.254]                               next
[10:26:15.254]                             if (!grepl(pattern, name)) 
[10:26:15.254]                               next
[10:26:15.254]                             invokeRestart(restart)
[10:26:15.254]                             muffled <- TRUE
[10:26:15.254]                             break
[10:26:15.254]                           }
[10:26:15.254]                         }
[10:26:15.254]                       }
[10:26:15.254]                       invisible(muffled)
[10:26:15.254]                     }
[10:26:15.254]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.254]                   }
[10:26:15.254]                 }
[10:26:15.254]                 else {
[10:26:15.254]                   if (TRUE) {
[10:26:15.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.254]                     {
[10:26:15.254]                       inherits <- base::inherits
[10:26:15.254]                       invokeRestart <- base::invokeRestart
[10:26:15.254]                       is.null <- base::is.null
[10:26:15.254]                       muffled <- FALSE
[10:26:15.254]                       if (inherits(cond, "message")) {
[10:26:15.254]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.254]                         if (muffled) 
[10:26:15.254]                           invokeRestart("muffleMessage")
[10:26:15.254]                       }
[10:26:15.254]                       else if (inherits(cond, "warning")) {
[10:26:15.254]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.254]                         if (muffled) 
[10:26:15.254]                           invokeRestart("muffleWarning")
[10:26:15.254]                       }
[10:26:15.254]                       else if (inherits(cond, "condition")) {
[10:26:15.254]                         if (!is.null(pattern)) {
[10:26:15.254]                           computeRestarts <- base::computeRestarts
[10:26:15.254]                           grepl <- base::grepl
[10:26:15.254]                           restarts <- computeRestarts(cond)
[10:26:15.254]                           for (restart in restarts) {
[10:26:15.254]                             name <- restart$name
[10:26:15.254]                             if (is.null(name)) 
[10:26:15.254]                               next
[10:26:15.254]                             if (!grepl(pattern, name)) 
[10:26:15.254]                               next
[10:26:15.254]                             invokeRestart(restart)
[10:26:15.254]                             muffled <- TRUE
[10:26:15.254]                             break
[10:26:15.254]                           }
[10:26:15.254]                         }
[10:26:15.254]                       }
[10:26:15.254]                       invisible(muffled)
[10:26:15.254]                     }
[10:26:15.254]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.254]                   }
[10:26:15.254]                 }
[10:26:15.254]             }
[10:26:15.254]         }))
[10:26:15.254]     }, error = function(ex) {
[10:26:15.254]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:15.254]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.254]                 ...future.rng), started = ...future.startTime, 
[10:26:15.254]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:15.254]             version = "1.8"), class = "FutureResult")
[10:26:15.254]     }, finally = {
[10:26:15.254]         if (!identical(...future.workdir, getwd())) 
[10:26:15.254]             setwd(...future.workdir)
[10:26:15.254]         {
[10:26:15.254]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:15.254]                 ...future.oldOptions$nwarnings <- NULL
[10:26:15.254]             }
[10:26:15.254]             base::options(...future.oldOptions)
[10:26:15.254]             if (.Platform$OS.type == "windows") {
[10:26:15.254]                 old_names <- names(...future.oldEnvVars)
[10:26:15.254]                 envs <- base::Sys.getenv()
[10:26:15.254]                 names <- names(envs)
[10:26:15.254]                 common <- intersect(names, old_names)
[10:26:15.254]                 added <- setdiff(names, old_names)
[10:26:15.254]                 removed <- setdiff(old_names, names)
[10:26:15.254]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:15.254]                   envs[common]]
[10:26:15.254]                 NAMES <- toupper(changed)
[10:26:15.254]                 args <- list()
[10:26:15.254]                 for (kk in seq_along(NAMES)) {
[10:26:15.254]                   name <- changed[[kk]]
[10:26:15.254]                   NAME <- NAMES[[kk]]
[10:26:15.254]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.254]                     next
[10:26:15.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.254]                 }
[10:26:15.254]                 NAMES <- toupper(added)
[10:26:15.254]                 for (kk in seq_along(NAMES)) {
[10:26:15.254]                   name <- added[[kk]]
[10:26:15.254]                   NAME <- NAMES[[kk]]
[10:26:15.254]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.254]                     next
[10:26:15.254]                   args[[name]] <- ""
[10:26:15.254]                 }
[10:26:15.254]                 NAMES <- toupper(removed)
[10:26:15.254]                 for (kk in seq_along(NAMES)) {
[10:26:15.254]                   name <- removed[[kk]]
[10:26:15.254]                   NAME <- NAMES[[kk]]
[10:26:15.254]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.254]                     next
[10:26:15.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.254]                 }
[10:26:15.254]                 if (length(args) > 0) 
[10:26:15.254]                   base::do.call(base::Sys.setenv, args = args)
[10:26:15.254]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:15.254]             }
[10:26:15.254]             else {
[10:26:15.254]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:15.254]             }
[10:26:15.254]             {
[10:26:15.254]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:15.254]                   0L) {
[10:26:15.254]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:15.254]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:15.254]                   base::options(opts)
[10:26:15.254]                 }
[10:26:15.254]                 {
[10:26:15.254]                   {
[10:26:15.254]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:15.254]                     NULL
[10:26:15.254]                   }
[10:26:15.254]                   options(future.plan = NULL)
[10:26:15.254]                   if (is.na(NA_character_)) 
[10:26:15.254]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.254]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:15.254]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:15.254]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:15.254]                     envir = parent.frame()) 
[10:26:15.254]                   {
[10:26:15.254]                     if (is.function(workers)) 
[10:26:15.254]                       workers <- workers()
[10:26:15.254]                     workers <- structure(as.integer(workers), 
[10:26:15.254]                       class = class(workers))
[10:26:15.254]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:15.254]                       workers >= 1)
[10:26:15.254]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:15.254]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:15.254]                     }
[10:26:15.254]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:15.254]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:15.254]                       envir = envir)
[10:26:15.254]                     if (!future$lazy) 
[10:26:15.254]                       future <- run(future)
[10:26:15.254]                     invisible(future)
[10:26:15.254]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:15.254]                 }
[10:26:15.254]             }
[10:26:15.254]         }
[10:26:15.254]     })
[10:26:15.254]     if (TRUE) {
[10:26:15.254]         base::sink(type = "output", split = FALSE)
[10:26:15.254]         if (TRUE) {
[10:26:15.254]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:15.254]         }
[10:26:15.254]         else {
[10:26:15.254]             ...future.result["stdout"] <- base::list(NULL)
[10:26:15.254]         }
[10:26:15.254]         base::close(...future.stdout)
[10:26:15.254]         ...future.stdout <- NULL
[10:26:15.254]     }
[10:26:15.254]     ...future.result$conditions <- ...future.conditions
[10:26:15.254]     ...future.result$finished <- base::Sys.time()
[10:26:15.254]     ...future.result
[10:26:15.254] }
[10:26:15.256] Poll #1 (0): usedNodes() = 2, workers = 2
[10:26:15.267] receiveMessageFromWorker() for ClusterFuture ...
[10:26:15.267] - Validating connection of MultisessionFuture
[10:26:15.267] - received message: FutureResult
[10:26:15.267] - Received FutureResult
[10:26:15.268] - Erased future from FutureRegistry
[10:26:15.268] result() for ClusterFuture ...
[10:26:15.268] - result already collected: FutureResult
[10:26:15.268] result() for ClusterFuture ... done
[10:26:15.268] signalConditions() ...
[10:26:15.268]  - include = ‘immediateCondition’
[10:26:15.268]  - exclude = 
[10:26:15.268]  - resignal = FALSE
[10:26:15.268]  - Number of conditions: 1
[10:26:15.268] signalConditions() ... done
[10:26:15.268] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:15.269] result() for ClusterFuture ...
[10:26:15.269] - result already collected: FutureResult
[10:26:15.269] result() for ClusterFuture ... done
[10:26:15.269] result() for ClusterFuture ...
[10:26:15.269] - result already collected: FutureResult
[10:26:15.269] result() for ClusterFuture ... done
[10:26:15.269] signalConditions() ...
[10:26:15.269]  - include = ‘immediateCondition’
[10:26:15.269]  - exclude = 
[10:26:15.269]  - resignal = FALSE
[10:26:15.269]  - Number of conditions: 1
[10:26:15.270] signalConditions() ... done
[10:26:15.270] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[10:26:15.270] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[10:26:15.271] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[10:26:15.271] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[10:26:15.271] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[10:26:15.271] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[10:26:15.272] MultisessionFuture started
[10:26:15.272] - Launch lazy future ... done
[10:26:15.272] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:15.272] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:15.273] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:15.274] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:15.274] Searching for globals ... DONE
[10:26:15.275] Resolving globals: TRUE
[10:26:15.275] Resolving any globals that are futures ...
[10:26:15.275] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:15.275] Resolving any globals that are futures ... DONE
[10:26:15.275] Resolving futures part of globals (recursively) ...
[10:26:15.275] resolve() on list ...
[10:26:15.276]  recursive: 99
[10:26:15.276]  length: 2
[10:26:15.276]  elements: ‘a’, ‘ii’
[10:26:15.276]  length: 1 (resolved future 1)
[10:26:15.276]  length: 0 (resolved future 2)
[10:26:15.276] resolve() on list ... DONE
[10:26:15.276] - globals: [2] ‘a’, ‘ii’
[10:26:15.276] Resolving futures part of globals (recursively) ... DONE
[10:26:15.276] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:15.277] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:26:15.277] - globals: [2] ‘a’, ‘ii’
[10:26:15.277] 
[10:26:15.277] getGlobalsAndPackages() ... DONE
[10:26:15.277] run() for ‘Future’ ...
[10:26:15.277] - state: ‘created’
[10:26:15.278] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:15.291] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:15.291] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:15.291]   - Field: ‘node’
[10:26:15.291]   - Field: ‘label’
[10:26:15.291]   - Field: ‘local’
[10:26:15.291]   - Field: ‘owner’
[10:26:15.291]   - Field: ‘envir’
[10:26:15.291]   - Field: ‘workers’
[10:26:15.291]   - Field: ‘packages’
[10:26:15.292]   - Field: ‘gc’
[10:26:15.292]   - Field: ‘conditions’
[10:26:15.292]   - Field: ‘persistent’
[10:26:15.292]   - Field: ‘expr’
[10:26:15.292]   - Field: ‘uuid’
[10:26:15.292]   - Field: ‘seed’
[10:26:15.292]   - Field: ‘version’
[10:26:15.292]   - Field: ‘result’
[10:26:15.292]   - Field: ‘asynchronous’
[10:26:15.292]   - Field: ‘calls’
[10:26:15.292]   - Field: ‘globals’
[10:26:15.293]   - Field: ‘stdout’
[10:26:15.293]   - Field: ‘earlySignal’
[10:26:15.293]   - Field: ‘lazy’
[10:26:15.293]   - Field: ‘state’
[10:26:15.293] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:15.293] - Launch lazy future ...
[10:26:15.293] Packages needed by the future expression (n = 0): <none>
[10:26:15.293] Packages needed by future strategies (n = 0): <none>
[10:26:15.294] {
[10:26:15.294]     {
[10:26:15.294]         {
[10:26:15.294]             ...future.startTime <- base::Sys.time()
[10:26:15.294]             {
[10:26:15.294]                 {
[10:26:15.294]                   {
[10:26:15.294]                     {
[10:26:15.294]                       base::local({
[10:26:15.294]                         has_future <- base::requireNamespace("future", 
[10:26:15.294]                           quietly = TRUE)
[10:26:15.294]                         if (has_future) {
[10:26:15.294]                           ns <- base::getNamespace("future")
[10:26:15.294]                           version <- ns[[".package"]][["version"]]
[10:26:15.294]                           if (is.null(version)) 
[10:26:15.294]                             version <- utils::packageVersion("future")
[10:26:15.294]                         }
[10:26:15.294]                         else {
[10:26:15.294]                           version <- NULL
[10:26:15.294]                         }
[10:26:15.294]                         if (!has_future || version < "1.8.0") {
[10:26:15.294]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:15.294]                             "", base::R.version$version.string), 
[10:26:15.294]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:15.294]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:15.294]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:15.294]                               "release", "version")], collapse = " "), 
[10:26:15.294]                             hostname = base::Sys.info()[["nodename"]])
[10:26:15.294]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:15.294]                             info)
[10:26:15.294]                           info <- base::paste(info, collapse = "; ")
[10:26:15.294]                           if (!has_future) {
[10:26:15.294]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:15.294]                               info)
[10:26:15.294]                           }
[10:26:15.294]                           else {
[10:26:15.294]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:15.294]                               info, version)
[10:26:15.294]                           }
[10:26:15.294]                           base::stop(msg)
[10:26:15.294]                         }
[10:26:15.294]                       })
[10:26:15.294]                     }
[10:26:15.294]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:15.294]                     base::options(mc.cores = 1L)
[10:26:15.294]                   }
[10:26:15.294]                   options(future.plan = NULL)
[10:26:15.294]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.294]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:15.294]                 }
[10:26:15.294]                 ...future.workdir <- getwd()
[10:26:15.294]             }
[10:26:15.294]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:15.294]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:15.294]         }
[10:26:15.294]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:15.294]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:15.294]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:15.294]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:15.294]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:15.294]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:15.294]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:15.294]             base::names(...future.oldOptions))
[10:26:15.294]     }
[10:26:15.294]     if (FALSE) {
[10:26:15.294]     }
[10:26:15.294]     else {
[10:26:15.294]         if (TRUE) {
[10:26:15.294]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:15.294]                 open = "w")
[10:26:15.294]         }
[10:26:15.294]         else {
[10:26:15.294]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:15.294]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:15.294]         }
[10:26:15.294]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:15.294]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:15.294]             base::sink(type = "output", split = FALSE)
[10:26:15.294]             base::close(...future.stdout)
[10:26:15.294]         }, add = TRUE)
[10:26:15.294]     }
[10:26:15.294]     ...future.frame <- base::sys.nframe()
[10:26:15.294]     ...future.conditions <- base::list()
[10:26:15.294]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:15.294]     if (FALSE) {
[10:26:15.294]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:15.294]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:15.294]     }
[10:26:15.294]     ...future.result <- base::tryCatch({
[10:26:15.294]         base::withCallingHandlers({
[10:26:15.294]             ...future.value <- base::withVisible(base::local({
[10:26:15.294]                 ...future.makeSendCondition <- base::local({
[10:26:15.294]                   sendCondition <- NULL
[10:26:15.294]                   function(frame = 1L) {
[10:26:15.294]                     if (is.function(sendCondition)) 
[10:26:15.294]                       return(sendCondition)
[10:26:15.294]                     ns <- getNamespace("parallel")
[10:26:15.294]                     if (exists("sendData", mode = "function", 
[10:26:15.294]                       envir = ns)) {
[10:26:15.294]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:15.294]                         envir = ns)
[10:26:15.294]                       envir <- sys.frame(frame)
[10:26:15.294]                       master <- NULL
[10:26:15.294]                       while (!identical(envir, .GlobalEnv) && 
[10:26:15.294]                         !identical(envir, emptyenv())) {
[10:26:15.294]                         if (exists("master", mode = "list", envir = envir, 
[10:26:15.294]                           inherits = FALSE)) {
[10:26:15.294]                           master <- get("master", mode = "list", 
[10:26:15.294]                             envir = envir, inherits = FALSE)
[10:26:15.294]                           if (inherits(master, c("SOCKnode", 
[10:26:15.294]                             "SOCK0node"))) {
[10:26:15.294]                             sendCondition <<- function(cond) {
[10:26:15.294]                               data <- list(type = "VALUE", value = cond, 
[10:26:15.294]                                 success = TRUE)
[10:26:15.294]                               parallel_sendData(master, data)
[10:26:15.294]                             }
[10:26:15.294]                             return(sendCondition)
[10:26:15.294]                           }
[10:26:15.294]                         }
[10:26:15.294]                         frame <- frame + 1L
[10:26:15.294]                         envir <- sys.frame(frame)
[10:26:15.294]                       }
[10:26:15.294]                     }
[10:26:15.294]                     sendCondition <<- function(cond) NULL
[10:26:15.294]                   }
[10:26:15.294]                 })
[10:26:15.294]                 withCallingHandlers({
[10:26:15.294]                   {
[10:26:15.294]                     b <- a * ii
[10:26:15.294]                     a <- 0
[10:26:15.294]                     b
[10:26:15.294]                   }
[10:26:15.294]                 }, immediateCondition = function(cond) {
[10:26:15.294]                   sendCondition <- ...future.makeSendCondition()
[10:26:15.294]                   sendCondition(cond)
[10:26:15.294]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.294]                   {
[10:26:15.294]                     inherits <- base::inherits
[10:26:15.294]                     invokeRestart <- base::invokeRestart
[10:26:15.294]                     is.null <- base::is.null
[10:26:15.294]                     muffled <- FALSE
[10:26:15.294]                     if (inherits(cond, "message")) {
[10:26:15.294]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:15.294]                       if (muffled) 
[10:26:15.294]                         invokeRestart("muffleMessage")
[10:26:15.294]                     }
[10:26:15.294]                     else if (inherits(cond, "warning")) {
[10:26:15.294]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:15.294]                       if (muffled) 
[10:26:15.294]                         invokeRestart("muffleWarning")
[10:26:15.294]                     }
[10:26:15.294]                     else if (inherits(cond, "condition")) {
[10:26:15.294]                       if (!is.null(pattern)) {
[10:26:15.294]                         computeRestarts <- base::computeRestarts
[10:26:15.294]                         grepl <- base::grepl
[10:26:15.294]                         restarts <- computeRestarts(cond)
[10:26:15.294]                         for (restart in restarts) {
[10:26:15.294]                           name <- restart$name
[10:26:15.294]                           if (is.null(name)) 
[10:26:15.294]                             next
[10:26:15.294]                           if (!grepl(pattern, name)) 
[10:26:15.294]                             next
[10:26:15.294]                           invokeRestart(restart)
[10:26:15.294]                           muffled <- TRUE
[10:26:15.294]                           break
[10:26:15.294]                         }
[10:26:15.294]                       }
[10:26:15.294]                     }
[10:26:15.294]                     invisible(muffled)
[10:26:15.294]                   }
[10:26:15.294]                   muffleCondition(cond)
[10:26:15.294]                 })
[10:26:15.294]             }))
[10:26:15.294]             future::FutureResult(value = ...future.value$value, 
[10:26:15.294]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.294]                   ...future.rng), globalenv = if (FALSE) 
[10:26:15.294]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:15.294]                     ...future.globalenv.names))
[10:26:15.294]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:15.294]         }, condition = base::local({
[10:26:15.294]             c <- base::c
[10:26:15.294]             inherits <- base::inherits
[10:26:15.294]             invokeRestart <- base::invokeRestart
[10:26:15.294]             length <- base::length
[10:26:15.294]             list <- base::list
[10:26:15.294]             seq.int <- base::seq.int
[10:26:15.294]             signalCondition <- base::signalCondition
[10:26:15.294]             sys.calls <- base::sys.calls
[10:26:15.294]             `[[` <- base::`[[`
[10:26:15.294]             `+` <- base::`+`
[10:26:15.294]             `<<-` <- base::`<<-`
[10:26:15.294]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:15.294]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:15.294]                   3L)]
[10:26:15.294]             }
[10:26:15.294]             function(cond) {
[10:26:15.294]                 is_error <- inherits(cond, "error")
[10:26:15.294]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:15.294]                   NULL)
[10:26:15.294]                 if (is_error) {
[10:26:15.294]                   sessionInformation <- function() {
[10:26:15.294]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:15.294]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:15.294]                       search = base::search(), system = base::Sys.info())
[10:26:15.294]                   }
[10:26:15.294]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.294]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:15.294]                     cond$call), session = sessionInformation(), 
[10:26:15.294]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:15.294]                   signalCondition(cond)
[10:26:15.294]                 }
[10:26:15.294]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:15.294]                 "immediateCondition"))) {
[10:26:15.294]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:15.294]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.294]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:15.294]                   if (TRUE && !signal) {
[10:26:15.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.294]                     {
[10:26:15.294]                       inherits <- base::inherits
[10:26:15.294]                       invokeRestart <- base::invokeRestart
[10:26:15.294]                       is.null <- base::is.null
[10:26:15.294]                       muffled <- FALSE
[10:26:15.294]                       if (inherits(cond, "message")) {
[10:26:15.294]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.294]                         if (muffled) 
[10:26:15.294]                           invokeRestart("muffleMessage")
[10:26:15.294]                       }
[10:26:15.294]                       else if (inherits(cond, "warning")) {
[10:26:15.294]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.294]                         if (muffled) 
[10:26:15.294]                           invokeRestart("muffleWarning")
[10:26:15.294]                       }
[10:26:15.294]                       else if (inherits(cond, "condition")) {
[10:26:15.294]                         if (!is.null(pattern)) {
[10:26:15.294]                           computeRestarts <- base::computeRestarts
[10:26:15.294]                           grepl <- base::grepl
[10:26:15.294]                           restarts <- computeRestarts(cond)
[10:26:15.294]                           for (restart in restarts) {
[10:26:15.294]                             name <- restart$name
[10:26:15.294]                             if (is.null(name)) 
[10:26:15.294]                               next
[10:26:15.294]                             if (!grepl(pattern, name)) 
[10:26:15.294]                               next
[10:26:15.294]                             invokeRestart(restart)
[10:26:15.294]                             muffled <- TRUE
[10:26:15.294]                             break
[10:26:15.294]                           }
[10:26:15.294]                         }
[10:26:15.294]                       }
[10:26:15.294]                       invisible(muffled)
[10:26:15.294]                     }
[10:26:15.294]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.294]                   }
[10:26:15.294]                 }
[10:26:15.294]                 else {
[10:26:15.294]                   if (TRUE) {
[10:26:15.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.294]                     {
[10:26:15.294]                       inherits <- base::inherits
[10:26:15.294]                       invokeRestart <- base::invokeRestart
[10:26:15.294]                       is.null <- base::is.null
[10:26:15.294]                       muffled <- FALSE
[10:26:15.294]                       if (inherits(cond, "message")) {
[10:26:15.294]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.294]                         if (muffled) 
[10:26:15.294]                           invokeRestart("muffleMessage")
[10:26:15.294]                       }
[10:26:15.294]                       else if (inherits(cond, "warning")) {
[10:26:15.294]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.294]                         if (muffled) 
[10:26:15.294]                           invokeRestart("muffleWarning")
[10:26:15.294]                       }
[10:26:15.294]                       else if (inherits(cond, "condition")) {
[10:26:15.294]                         if (!is.null(pattern)) {
[10:26:15.294]                           computeRestarts <- base::computeRestarts
[10:26:15.294]                           grepl <- base::grepl
[10:26:15.294]                           restarts <- computeRestarts(cond)
[10:26:15.294]                           for (restart in restarts) {
[10:26:15.294]                             name <- restart$name
[10:26:15.294]                             if (is.null(name)) 
[10:26:15.294]                               next
[10:26:15.294]                             if (!grepl(pattern, name)) 
[10:26:15.294]                               next
[10:26:15.294]                             invokeRestart(restart)
[10:26:15.294]                             muffled <- TRUE
[10:26:15.294]                             break
[10:26:15.294]                           }
[10:26:15.294]                         }
[10:26:15.294]                       }
[10:26:15.294]                       invisible(muffled)
[10:26:15.294]                     }
[10:26:15.294]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.294]                   }
[10:26:15.294]                 }
[10:26:15.294]             }
[10:26:15.294]         }))
[10:26:15.294]     }, error = function(ex) {
[10:26:15.294]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:15.294]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.294]                 ...future.rng), started = ...future.startTime, 
[10:26:15.294]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:15.294]             version = "1.8"), class = "FutureResult")
[10:26:15.294]     }, finally = {
[10:26:15.294]         if (!identical(...future.workdir, getwd())) 
[10:26:15.294]             setwd(...future.workdir)
[10:26:15.294]         {
[10:26:15.294]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:15.294]                 ...future.oldOptions$nwarnings <- NULL
[10:26:15.294]             }
[10:26:15.294]             base::options(...future.oldOptions)
[10:26:15.294]             if (.Platform$OS.type == "windows") {
[10:26:15.294]                 old_names <- names(...future.oldEnvVars)
[10:26:15.294]                 envs <- base::Sys.getenv()
[10:26:15.294]                 names <- names(envs)
[10:26:15.294]                 common <- intersect(names, old_names)
[10:26:15.294]                 added <- setdiff(names, old_names)
[10:26:15.294]                 removed <- setdiff(old_names, names)
[10:26:15.294]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:15.294]                   envs[common]]
[10:26:15.294]                 NAMES <- toupper(changed)
[10:26:15.294]                 args <- list()
[10:26:15.294]                 for (kk in seq_along(NAMES)) {
[10:26:15.294]                   name <- changed[[kk]]
[10:26:15.294]                   NAME <- NAMES[[kk]]
[10:26:15.294]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.294]                     next
[10:26:15.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.294]                 }
[10:26:15.294]                 NAMES <- toupper(added)
[10:26:15.294]                 for (kk in seq_along(NAMES)) {
[10:26:15.294]                   name <- added[[kk]]
[10:26:15.294]                   NAME <- NAMES[[kk]]
[10:26:15.294]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.294]                     next
[10:26:15.294]                   args[[name]] <- ""
[10:26:15.294]                 }
[10:26:15.294]                 NAMES <- toupper(removed)
[10:26:15.294]                 for (kk in seq_along(NAMES)) {
[10:26:15.294]                   name <- removed[[kk]]
[10:26:15.294]                   NAME <- NAMES[[kk]]
[10:26:15.294]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.294]                     next
[10:26:15.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.294]                 }
[10:26:15.294]                 if (length(args) > 0) 
[10:26:15.294]                   base::do.call(base::Sys.setenv, args = args)
[10:26:15.294]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:15.294]             }
[10:26:15.294]             else {
[10:26:15.294]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:15.294]             }
[10:26:15.294]             {
[10:26:15.294]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:15.294]                   0L) {
[10:26:15.294]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:15.294]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:15.294]                   base::options(opts)
[10:26:15.294]                 }
[10:26:15.294]                 {
[10:26:15.294]                   {
[10:26:15.294]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:15.294]                     NULL
[10:26:15.294]                   }
[10:26:15.294]                   options(future.plan = NULL)
[10:26:15.294]                   if (is.na(NA_character_)) 
[10:26:15.294]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.294]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:15.294]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:15.294]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:15.294]                     envir = parent.frame()) 
[10:26:15.294]                   {
[10:26:15.294]                     if (is.function(workers)) 
[10:26:15.294]                       workers <- workers()
[10:26:15.294]                     workers <- structure(as.integer(workers), 
[10:26:15.294]                       class = class(workers))
[10:26:15.294]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:15.294]                       workers >= 1)
[10:26:15.294]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:15.294]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:15.294]                     }
[10:26:15.294]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:15.294]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:15.294]                       envir = envir)
[10:26:15.294]                     if (!future$lazy) 
[10:26:15.294]                       future <- run(future)
[10:26:15.294]                     invisible(future)
[10:26:15.294]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:15.294]                 }
[10:26:15.294]             }
[10:26:15.294]         }
[10:26:15.294]     })
[10:26:15.294]     if (TRUE) {
[10:26:15.294]         base::sink(type = "output", split = FALSE)
[10:26:15.294]         if (TRUE) {
[10:26:15.294]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:15.294]         }
[10:26:15.294]         else {
[10:26:15.294]             ...future.result["stdout"] <- base::list(NULL)
[10:26:15.294]         }
[10:26:15.294]         base::close(...future.stdout)
[10:26:15.294]         ...future.stdout <- NULL
[10:26:15.294]     }
[10:26:15.294]     ...future.result$conditions <- ...future.conditions
[10:26:15.294]     ...future.result$finished <- base::Sys.time()
[10:26:15.294]     ...future.result
[10:26:15.294] }
[10:26:15.296] Poll #1 (0): usedNodes() = 2, workers = 2
[10:26:15.307] receiveMessageFromWorker() for ClusterFuture ...
[10:26:15.307] - Validating connection of MultisessionFuture
[10:26:15.307] - received message: FutureResult
[10:26:15.307] - Received FutureResult
[10:26:15.307] - Erased future from FutureRegistry
[10:26:15.307] result() for ClusterFuture ...
[10:26:15.307] - result already collected: FutureResult
[10:26:15.307] result() for ClusterFuture ... done
[10:26:15.308] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:15.308] result() for ClusterFuture ...
[10:26:15.308] - result already collected: FutureResult
[10:26:15.308] result() for ClusterFuture ... done
[10:26:15.308] result() for ClusterFuture ...
[10:26:15.308] - result already collected: FutureResult
[10:26:15.308] result() for ClusterFuture ... done
[10:26:15.309] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[10:26:15.309] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[10:26:15.309] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[10:26:15.309] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[10:26:15.310] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[10:26:15.310] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[10:26:15.310] MultisessionFuture started
[10:26:15.310] - Launch lazy future ... done
[10:26:15.310] run() for ‘MultisessionFuture’ ... done
[10:26:15.311] result() for ClusterFuture ...
[10:26:15.311] - result already collected: FutureResult
[10:26:15.311] result() for ClusterFuture ... done
[10:26:15.311] result() for ClusterFuture ...
[10:26:15.311] - result already collected: FutureResult
[10:26:15.311] result() for ClusterFuture ... done
[10:26:15.311] result() for ClusterFuture ...
[10:26:15.311] receiveMessageFromWorker() for ClusterFuture ...
[10:26:15.311] - Validating connection of MultisessionFuture
[10:26:15.318] - received message: FutureResult
[10:26:15.318] - Received FutureResult
[10:26:15.319] - Erased future from FutureRegistry
[10:26:15.319] result() for ClusterFuture ...
[10:26:15.319] - result already collected: FutureResult
[10:26:15.319] result() for ClusterFuture ... done
[10:26:15.319] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:15.319] result() for ClusterFuture ... done
[10:26:15.319] result() for ClusterFuture ...
[10:26:15.319] - result already collected: FutureResult
[10:26:15.319] result() for ClusterFuture ... done
[10:26:15.319] result() for ClusterFuture ...
[10:26:15.319] receiveMessageFromWorker() for ClusterFuture ...
[10:26:15.320] - Validating connection of MultisessionFuture
[10:26:15.358] - received message: FutureResult
[10:26:15.359] - Received FutureResult
[10:26:15.359] - Erased future from FutureRegistry
[10:26:15.359] result() for ClusterFuture ...
[10:26:15.359] - result already collected: FutureResult
[10:26:15.359] result() for ClusterFuture ... done
[10:26:15.359] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:15.359] result() for ClusterFuture ... done
[10:26:15.359] result() for ClusterFuture ...
[10:26:15.359] - result already collected: FutureResult
[10:26:15.359] result() for ClusterFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:15.360] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:15.360] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:15.362] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:15.362] Searching for globals ... DONE
[10:26:15.362] Resolving globals: TRUE
[10:26:15.363] Resolving any globals that are futures ...
[10:26:15.363] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:15.363] Resolving any globals that are futures ... DONE
[10:26:15.363] Resolving futures part of globals (recursively) ...
[10:26:15.363] resolve() on list ...
[10:26:15.363]  recursive: 99
[10:26:15.364]  length: 2
[10:26:15.364]  elements: ‘a’, ‘ii’
[10:26:15.364]  length: 1 (resolved future 1)
[10:26:15.364]  length: 0 (resolved future 2)
[10:26:15.364] resolve() on list ... DONE
[10:26:15.364] - globals: [2] ‘a’, ‘ii’
[10:26:15.364] Resolving futures part of globals (recursively) ... DONE
[10:26:15.364] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:15.365] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:26:15.365] - globals: [2] ‘a’, ‘ii’
[10:26:15.365] 
[10:26:15.365] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:15.366] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:15.366] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:15.368] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:15.368] Searching for globals ... DONE
[10:26:15.368] Resolving globals: TRUE
[10:26:15.368] Resolving any globals that are futures ...
[10:26:15.368] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:15.368] Resolving any globals that are futures ... DONE
[10:26:15.368] Resolving futures part of globals (recursively) ...
[10:26:15.369] resolve() on list ...
[10:26:15.369]  recursive: 99
[10:26:15.369]  length: 2
[10:26:15.369]  elements: ‘a’, ‘ii’
[10:26:15.369]  length: 1 (resolved future 1)
[10:26:15.369]  length: 0 (resolved future 2)
[10:26:15.369] resolve() on list ... DONE
[10:26:15.369] - globals: [2] ‘a’, ‘ii’
[10:26:15.369] Resolving futures part of globals (recursively) ... DONE
[10:26:15.370] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:15.370] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:26:15.370] - globals: [2] ‘a’, ‘ii’
[10:26:15.370] 
[10:26:15.370] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:15.371] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:15.371] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:15.373] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:15.373] Searching for globals ... DONE
[10:26:15.373] Resolving globals: TRUE
[10:26:15.373] Resolving any globals that are futures ...
[10:26:15.373] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:26:15.373] Resolving any globals that are futures ... DONE
[10:26:15.374] Resolving futures part of globals (recursively) ...
[10:26:15.374] resolve() on list ...
[10:26:15.374]  recursive: 99
[10:26:15.374]  length: 2
[10:26:15.374]  elements: ‘a’, ‘ii’
[10:26:15.374]  length: 1 (resolved future 1)
[10:26:15.374]  length: 0 (resolved future 2)
[10:26:15.374] resolve() on list ... DONE
[10:26:15.374] - globals: [2] ‘a’, ‘ii’
[10:26:15.375] Resolving futures part of globals (recursively) ... DONE
[10:26:15.375] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:15.375] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:26:15.375] - globals: [2] ‘a’, ‘ii’
[10:26:15.375] 
[10:26:15.375] getGlobalsAndPackages() ... DONE
[10:26:15.376] run() for ‘Future’ ...
[10:26:15.376] - state: ‘created’
[10:26:15.376] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:15.389] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:15.390] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:15.390]   - Field: ‘node’
[10:26:15.390]   - Field: ‘label’
[10:26:15.390]   - Field: ‘local’
[10:26:15.390]   - Field: ‘owner’
[10:26:15.390]   - Field: ‘envir’
[10:26:15.390]   - Field: ‘workers’
[10:26:15.390]   - Field: ‘packages’
[10:26:15.390]   - Field: ‘gc’
[10:26:15.390]   - Field: ‘conditions’
[10:26:15.391]   - Field: ‘persistent’
[10:26:15.391]   - Field: ‘expr’
[10:26:15.391]   - Field: ‘uuid’
[10:26:15.391]   - Field: ‘seed’
[10:26:15.391]   - Field: ‘version’
[10:26:15.391]   - Field: ‘result’
[10:26:15.391]   - Field: ‘asynchronous’
[10:26:15.391]   - Field: ‘calls’
[10:26:15.391]   - Field: ‘globals’
[10:26:15.391]   - Field: ‘stdout’
[10:26:15.391]   - Field: ‘earlySignal’
[10:26:15.392]   - Field: ‘lazy’
[10:26:15.392]   - Field: ‘state’
[10:26:15.394] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:15.394] - Launch lazy future ...
[10:26:15.394] Packages needed by the future expression (n = 0): <none>
[10:26:15.394] Packages needed by future strategies (n = 0): <none>
[10:26:15.395] {
[10:26:15.395]     {
[10:26:15.395]         {
[10:26:15.395]             ...future.startTime <- base::Sys.time()
[10:26:15.395]             {
[10:26:15.395]                 {
[10:26:15.395]                   {
[10:26:15.395]                     {
[10:26:15.395]                       base::local({
[10:26:15.395]                         has_future <- base::requireNamespace("future", 
[10:26:15.395]                           quietly = TRUE)
[10:26:15.395]                         if (has_future) {
[10:26:15.395]                           ns <- base::getNamespace("future")
[10:26:15.395]                           version <- ns[[".package"]][["version"]]
[10:26:15.395]                           if (is.null(version)) 
[10:26:15.395]                             version <- utils::packageVersion("future")
[10:26:15.395]                         }
[10:26:15.395]                         else {
[10:26:15.395]                           version <- NULL
[10:26:15.395]                         }
[10:26:15.395]                         if (!has_future || version < "1.8.0") {
[10:26:15.395]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:15.395]                             "", base::R.version$version.string), 
[10:26:15.395]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:15.395]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:15.395]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:15.395]                               "release", "version")], collapse = " "), 
[10:26:15.395]                             hostname = base::Sys.info()[["nodename"]])
[10:26:15.395]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:15.395]                             info)
[10:26:15.395]                           info <- base::paste(info, collapse = "; ")
[10:26:15.395]                           if (!has_future) {
[10:26:15.395]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:15.395]                               info)
[10:26:15.395]                           }
[10:26:15.395]                           else {
[10:26:15.395]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:15.395]                               info, version)
[10:26:15.395]                           }
[10:26:15.395]                           base::stop(msg)
[10:26:15.395]                         }
[10:26:15.395]                       })
[10:26:15.395]                     }
[10:26:15.395]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:15.395]                     base::options(mc.cores = 1L)
[10:26:15.395]                   }
[10:26:15.395]                   options(future.plan = NULL)
[10:26:15.395]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.395]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:15.395]                 }
[10:26:15.395]                 ...future.workdir <- getwd()
[10:26:15.395]             }
[10:26:15.395]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:15.395]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:15.395]         }
[10:26:15.395]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:15.395]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:15.395]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:15.395]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:15.395]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:15.395]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:15.395]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:15.395]             base::names(...future.oldOptions))
[10:26:15.395]     }
[10:26:15.395]     if (FALSE) {
[10:26:15.395]     }
[10:26:15.395]     else {
[10:26:15.395]         if (TRUE) {
[10:26:15.395]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:15.395]                 open = "w")
[10:26:15.395]         }
[10:26:15.395]         else {
[10:26:15.395]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:15.395]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:15.395]         }
[10:26:15.395]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:15.395]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:15.395]             base::sink(type = "output", split = FALSE)
[10:26:15.395]             base::close(...future.stdout)
[10:26:15.395]         }, add = TRUE)
[10:26:15.395]     }
[10:26:15.395]     ...future.frame <- base::sys.nframe()
[10:26:15.395]     ...future.conditions <- base::list()
[10:26:15.395]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:15.395]     if (FALSE) {
[10:26:15.395]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:15.395]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:15.395]     }
[10:26:15.395]     ...future.result <- base::tryCatch({
[10:26:15.395]         base::withCallingHandlers({
[10:26:15.395]             ...future.value <- base::withVisible(base::local({
[10:26:15.395]                 ...future.makeSendCondition <- base::local({
[10:26:15.395]                   sendCondition <- NULL
[10:26:15.395]                   function(frame = 1L) {
[10:26:15.395]                     if (is.function(sendCondition)) 
[10:26:15.395]                       return(sendCondition)
[10:26:15.395]                     ns <- getNamespace("parallel")
[10:26:15.395]                     if (exists("sendData", mode = "function", 
[10:26:15.395]                       envir = ns)) {
[10:26:15.395]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:15.395]                         envir = ns)
[10:26:15.395]                       envir <- sys.frame(frame)
[10:26:15.395]                       master <- NULL
[10:26:15.395]                       while (!identical(envir, .GlobalEnv) && 
[10:26:15.395]                         !identical(envir, emptyenv())) {
[10:26:15.395]                         if (exists("master", mode = "list", envir = envir, 
[10:26:15.395]                           inherits = FALSE)) {
[10:26:15.395]                           master <- get("master", mode = "list", 
[10:26:15.395]                             envir = envir, inherits = FALSE)
[10:26:15.395]                           if (inherits(master, c("SOCKnode", 
[10:26:15.395]                             "SOCK0node"))) {
[10:26:15.395]                             sendCondition <<- function(cond) {
[10:26:15.395]                               data <- list(type = "VALUE", value = cond, 
[10:26:15.395]                                 success = TRUE)
[10:26:15.395]                               parallel_sendData(master, data)
[10:26:15.395]                             }
[10:26:15.395]                             return(sendCondition)
[10:26:15.395]                           }
[10:26:15.395]                         }
[10:26:15.395]                         frame <- frame + 1L
[10:26:15.395]                         envir <- sys.frame(frame)
[10:26:15.395]                       }
[10:26:15.395]                     }
[10:26:15.395]                     sendCondition <<- function(cond) NULL
[10:26:15.395]                   }
[10:26:15.395]                 })
[10:26:15.395]                 withCallingHandlers({
[10:26:15.395]                   {
[10:26:15.395]                     b <- a * ii
[10:26:15.395]                     a <- 0
[10:26:15.395]                     b
[10:26:15.395]                   }
[10:26:15.395]                 }, immediateCondition = function(cond) {
[10:26:15.395]                   sendCondition <- ...future.makeSendCondition()
[10:26:15.395]                   sendCondition(cond)
[10:26:15.395]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.395]                   {
[10:26:15.395]                     inherits <- base::inherits
[10:26:15.395]                     invokeRestart <- base::invokeRestart
[10:26:15.395]                     is.null <- base::is.null
[10:26:15.395]                     muffled <- FALSE
[10:26:15.395]                     if (inherits(cond, "message")) {
[10:26:15.395]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:15.395]                       if (muffled) 
[10:26:15.395]                         invokeRestart("muffleMessage")
[10:26:15.395]                     }
[10:26:15.395]                     else if (inherits(cond, "warning")) {
[10:26:15.395]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:15.395]                       if (muffled) 
[10:26:15.395]                         invokeRestart("muffleWarning")
[10:26:15.395]                     }
[10:26:15.395]                     else if (inherits(cond, "condition")) {
[10:26:15.395]                       if (!is.null(pattern)) {
[10:26:15.395]                         computeRestarts <- base::computeRestarts
[10:26:15.395]                         grepl <- base::grepl
[10:26:15.395]                         restarts <- computeRestarts(cond)
[10:26:15.395]                         for (restart in restarts) {
[10:26:15.395]                           name <- restart$name
[10:26:15.395]                           if (is.null(name)) 
[10:26:15.395]                             next
[10:26:15.395]                           if (!grepl(pattern, name)) 
[10:26:15.395]                             next
[10:26:15.395]                           invokeRestart(restart)
[10:26:15.395]                           muffled <- TRUE
[10:26:15.395]                           break
[10:26:15.395]                         }
[10:26:15.395]                       }
[10:26:15.395]                     }
[10:26:15.395]                     invisible(muffled)
[10:26:15.395]                   }
[10:26:15.395]                   muffleCondition(cond)
[10:26:15.395]                 })
[10:26:15.395]             }))
[10:26:15.395]             future::FutureResult(value = ...future.value$value, 
[10:26:15.395]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.395]                   ...future.rng), globalenv = if (FALSE) 
[10:26:15.395]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:15.395]                     ...future.globalenv.names))
[10:26:15.395]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:15.395]         }, condition = base::local({
[10:26:15.395]             c <- base::c
[10:26:15.395]             inherits <- base::inherits
[10:26:15.395]             invokeRestart <- base::invokeRestart
[10:26:15.395]             length <- base::length
[10:26:15.395]             list <- base::list
[10:26:15.395]             seq.int <- base::seq.int
[10:26:15.395]             signalCondition <- base::signalCondition
[10:26:15.395]             sys.calls <- base::sys.calls
[10:26:15.395]             `[[` <- base::`[[`
[10:26:15.395]             `+` <- base::`+`
[10:26:15.395]             `<<-` <- base::`<<-`
[10:26:15.395]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:15.395]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:15.395]                   3L)]
[10:26:15.395]             }
[10:26:15.395]             function(cond) {
[10:26:15.395]                 is_error <- inherits(cond, "error")
[10:26:15.395]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:15.395]                   NULL)
[10:26:15.395]                 if (is_error) {
[10:26:15.395]                   sessionInformation <- function() {
[10:26:15.395]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:15.395]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:15.395]                       search = base::search(), system = base::Sys.info())
[10:26:15.395]                   }
[10:26:15.395]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.395]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:15.395]                     cond$call), session = sessionInformation(), 
[10:26:15.395]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:15.395]                   signalCondition(cond)
[10:26:15.395]                 }
[10:26:15.395]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:15.395]                 "immediateCondition"))) {
[10:26:15.395]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:15.395]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.395]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:15.395]                   if (TRUE && !signal) {
[10:26:15.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.395]                     {
[10:26:15.395]                       inherits <- base::inherits
[10:26:15.395]                       invokeRestart <- base::invokeRestart
[10:26:15.395]                       is.null <- base::is.null
[10:26:15.395]                       muffled <- FALSE
[10:26:15.395]                       if (inherits(cond, "message")) {
[10:26:15.395]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.395]                         if (muffled) 
[10:26:15.395]                           invokeRestart("muffleMessage")
[10:26:15.395]                       }
[10:26:15.395]                       else if (inherits(cond, "warning")) {
[10:26:15.395]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.395]                         if (muffled) 
[10:26:15.395]                           invokeRestart("muffleWarning")
[10:26:15.395]                       }
[10:26:15.395]                       else if (inherits(cond, "condition")) {
[10:26:15.395]                         if (!is.null(pattern)) {
[10:26:15.395]                           computeRestarts <- base::computeRestarts
[10:26:15.395]                           grepl <- base::grepl
[10:26:15.395]                           restarts <- computeRestarts(cond)
[10:26:15.395]                           for (restart in restarts) {
[10:26:15.395]                             name <- restart$name
[10:26:15.395]                             if (is.null(name)) 
[10:26:15.395]                               next
[10:26:15.395]                             if (!grepl(pattern, name)) 
[10:26:15.395]                               next
[10:26:15.395]                             invokeRestart(restart)
[10:26:15.395]                             muffled <- TRUE
[10:26:15.395]                             break
[10:26:15.395]                           }
[10:26:15.395]                         }
[10:26:15.395]                       }
[10:26:15.395]                       invisible(muffled)
[10:26:15.395]                     }
[10:26:15.395]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.395]                   }
[10:26:15.395]                 }
[10:26:15.395]                 else {
[10:26:15.395]                   if (TRUE) {
[10:26:15.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.395]                     {
[10:26:15.395]                       inherits <- base::inherits
[10:26:15.395]                       invokeRestart <- base::invokeRestart
[10:26:15.395]                       is.null <- base::is.null
[10:26:15.395]                       muffled <- FALSE
[10:26:15.395]                       if (inherits(cond, "message")) {
[10:26:15.395]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.395]                         if (muffled) 
[10:26:15.395]                           invokeRestart("muffleMessage")
[10:26:15.395]                       }
[10:26:15.395]                       else if (inherits(cond, "warning")) {
[10:26:15.395]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.395]                         if (muffled) 
[10:26:15.395]                           invokeRestart("muffleWarning")
[10:26:15.395]                       }
[10:26:15.395]                       else if (inherits(cond, "condition")) {
[10:26:15.395]                         if (!is.null(pattern)) {
[10:26:15.395]                           computeRestarts <- base::computeRestarts
[10:26:15.395]                           grepl <- base::grepl
[10:26:15.395]                           restarts <- computeRestarts(cond)
[10:26:15.395]                           for (restart in restarts) {
[10:26:15.395]                             name <- restart$name
[10:26:15.395]                             if (is.null(name)) 
[10:26:15.395]                               next
[10:26:15.395]                             if (!grepl(pattern, name)) 
[10:26:15.395]                               next
[10:26:15.395]                             invokeRestart(restart)
[10:26:15.395]                             muffled <- TRUE
[10:26:15.395]                             break
[10:26:15.395]                           }
[10:26:15.395]                         }
[10:26:15.395]                       }
[10:26:15.395]                       invisible(muffled)
[10:26:15.395]                     }
[10:26:15.395]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.395]                   }
[10:26:15.395]                 }
[10:26:15.395]             }
[10:26:15.395]         }))
[10:26:15.395]     }, error = function(ex) {
[10:26:15.395]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:15.395]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.395]                 ...future.rng), started = ...future.startTime, 
[10:26:15.395]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:15.395]             version = "1.8"), class = "FutureResult")
[10:26:15.395]     }, finally = {
[10:26:15.395]         if (!identical(...future.workdir, getwd())) 
[10:26:15.395]             setwd(...future.workdir)
[10:26:15.395]         {
[10:26:15.395]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:15.395]                 ...future.oldOptions$nwarnings <- NULL
[10:26:15.395]             }
[10:26:15.395]             base::options(...future.oldOptions)
[10:26:15.395]             if (.Platform$OS.type == "windows") {
[10:26:15.395]                 old_names <- names(...future.oldEnvVars)
[10:26:15.395]                 envs <- base::Sys.getenv()
[10:26:15.395]                 names <- names(envs)
[10:26:15.395]                 common <- intersect(names, old_names)
[10:26:15.395]                 added <- setdiff(names, old_names)
[10:26:15.395]                 removed <- setdiff(old_names, names)
[10:26:15.395]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:15.395]                   envs[common]]
[10:26:15.395]                 NAMES <- toupper(changed)
[10:26:15.395]                 args <- list()
[10:26:15.395]                 for (kk in seq_along(NAMES)) {
[10:26:15.395]                   name <- changed[[kk]]
[10:26:15.395]                   NAME <- NAMES[[kk]]
[10:26:15.395]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.395]                     next
[10:26:15.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.395]                 }
[10:26:15.395]                 NAMES <- toupper(added)
[10:26:15.395]                 for (kk in seq_along(NAMES)) {
[10:26:15.395]                   name <- added[[kk]]
[10:26:15.395]                   NAME <- NAMES[[kk]]
[10:26:15.395]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.395]                     next
[10:26:15.395]                   args[[name]] <- ""
[10:26:15.395]                 }
[10:26:15.395]                 NAMES <- toupper(removed)
[10:26:15.395]                 for (kk in seq_along(NAMES)) {
[10:26:15.395]                   name <- removed[[kk]]
[10:26:15.395]                   NAME <- NAMES[[kk]]
[10:26:15.395]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.395]                     next
[10:26:15.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.395]                 }
[10:26:15.395]                 if (length(args) > 0) 
[10:26:15.395]                   base::do.call(base::Sys.setenv, args = args)
[10:26:15.395]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:15.395]             }
[10:26:15.395]             else {
[10:26:15.395]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:15.395]             }
[10:26:15.395]             {
[10:26:15.395]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:15.395]                   0L) {
[10:26:15.395]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:15.395]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:15.395]                   base::options(opts)
[10:26:15.395]                 }
[10:26:15.395]                 {
[10:26:15.395]                   {
[10:26:15.395]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:15.395]                     NULL
[10:26:15.395]                   }
[10:26:15.395]                   options(future.plan = NULL)
[10:26:15.395]                   if (is.na(NA_character_)) 
[10:26:15.395]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.395]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:15.395]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:15.395]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:15.395]                     envir = parent.frame()) 
[10:26:15.395]                   {
[10:26:15.395]                     if (is.function(workers)) 
[10:26:15.395]                       workers <- workers()
[10:26:15.395]                     workers <- structure(as.integer(workers), 
[10:26:15.395]                       class = class(workers))
[10:26:15.395]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:15.395]                       workers >= 1)
[10:26:15.395]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:15.395]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:15.395]                     }
[10:26:15.395]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:15.395]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:15.395]                       envir = envir)
[10:26:15.395]                     if (!future$lazy) 
[10:26:15.395]                       future <- run(future)
[10:26:15.395]                     invisible(future)
[10:26:15.395]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:15.395]                 }
[10:26:15.395]             }
[10:26:15.395]         }
[10:26:15.395]     })
[10:26:15.395]     if (TRUE) {
[10:26:15.395]         base::sink(type = "output", split = FALSE)
[10:26:15.395]         if (TRUE) {
[10:26:15.395]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:15.395]         }
[10:26:15.395]         else {
[10:26:15.395]             ...future.result["stdout"] <- base::list(NULL)
[10:26:15.395]         }
[10:26:15.395]         base::close(...future.stdout)
[10:26:15.395]         ...future.stdout <- NULL
[10:26:15.395]     }
[10:26:15.395]     ...future.result$conditions <- ...future.conditions
[10:26:15.395]     ...future.result$finished <- base::Sys.time()
[10:26:15.395]     ...future.result
[10:26:15.395] }
[10:26:15.397] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[10:26:15.397] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[10:26:15.398] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[10:26:15.398] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[10:26:15.398] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[10:26:15.398] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[10:26:15.399] MultisessionFuture started
[10:26:15.399] - Launch lazy future ... done
[10:26:15.399] run() for ‘MultisessionFuture’ ... done
[10:26:15.399] result() for ClusterFuture ...
[10:26:15.399] receiveMessageFromWorker() for ClusterFuture ...
[10:26:15.399] - Validating connection of MultisessionFuture
[10:26:15.446] - received message: FutureResult
[10:26:15.446] - Received FutureResult
[10:26:15.446] - Erased future from FutureRegistry
[10:26:15.447] result() for ClusterFuture ...
[10:26:15.447] - result already collected: FutureResult
[10:26:15.447] result() for ClusterFuture ... done
[10:26:15.447] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:15.447] result() for ClusterFuture ... done
[10:26:15.447] result() for ClusterFuture ...
[10:26:15.447] - result already collected: FutureResult
[10:26:15.447] result() for ClusterFuture ... done
[10:26:15.447] run() for ‘Future’ ...
[10:26:15.447] - state: ‘created’
[10:26:15.448] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:15.462] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:15.462] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:15.462]   - Field: ‘node’
[10:26:15.462]   - Field: ‘label’
[10:26:15.462]   - Field: ‘local’
[10:26:15.462]   - Field: ‘owner’
[10:26:15.462]   - Field: ‘envir’
[10:26:15.462]   - Field: ‘workers’
[10:26:15.462]   - Field: ‘packages’
[10:26:15.463]   - Field: ‘gc’
[10:26:15.463]   - Field: ‘conditions’
[10:26:15.463]   - Field: ‘persistent’
[10:26:15.463]   - Field: ‘expr’
[10:26:15.463]   - Field: ‘uuid’
[10:26:15.463]   - Field: ‘seed’
[10:26:15.463]   - Field: ‘version’
[10:26:15.463]   - Field: ‘result’
[10:26:15.463]   - Field: ‘asynchronous’
[10:26:15.463]   - Field: ‘calls’
[10:26:15.463]   - Field: ‘globals’
[10:26:15.464]   - Field: ‘stdout’
[10:26:15.464]   - Field: ‘earlySignal’
[10:26:15.464]   - Field: ‘lazy’
[10:26:15.464]   - Field: ‘state’
[10:26:15.464] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:15.464] - Launch lazy future ...
[10:26:15.464] Packages needed by the future expression (n = 0): <none>
[10:26:15.464] Packages needed by future strategies (n = 0): <none>
[10:26:15.465] {
[10:26:15.465]     {
[10:26:15.465]         {
[10:26:15.465]             ...future.startTime <- base::Sys.time()
[10:26:15.465]             {
[10:26:15.465]                 {
[10:26:15.465]                   {
[10:26:15.465]                     {
[10:26:15.465]                       base::local({
[10:26:15.465]                         has_future <- base::requireNamespace("future", 
[10:26:15.465]                           quietly = TRUE)
[10:26:15.465]                         if (has_future) {
[10:26:15.465]                           ns <- base::getNamespace("future")
[10:26:15.465]                           version <- ns[[".package"]][["version"]]
[10:26:15.465]                           if (is.null(version)) 
[10:26:15.465]                             version <- utils::packageVersion("future")
[10:26:15.465]                         }
[10:26:15.465]                         else {
[10:26:15.465]                           version <- NULL
[10:26:15.465]                         }
[10:26:15.465]                         if (!has_future || version < "1.8.0") {
[10:26:15.465]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:15.465]                             "", base::R.version$version.string), 
[10:26:15.465]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:15.465]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:15.465]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:15.465]                               "release", "version")], collapse = " "), 
[10:26:15.465]                             hostname = base::Sys.info()[["nodename"]])
[10:26:15.465]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:15.465]                             info)
[10:26:15.465]                           info <- base::paste(info, collapse = "; ")
[10:26:15.465]                           if (!has_future) {
[10:26:15.465]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:15.465]                               info)
[10:26:15.465]                           }
[10:26:15.465]                           else {
[10:26:15.465]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:15.465]                               info, version)
[10:26:15.465]                           }
[10:26:15.465]                           base::stop(msg)
[10:26:15.465]                         }
[10:26:15.465]                       })
[10:26:15.465]                     }
[10:26:15.465]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:15.465]                     base::options(mc.cores = 1L)
[10:26:15.465]                   }
[10:26:15.465]                   options(future.plan = NULL)
[10:26:15.465]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.465]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:15.465]                 }
[10:26:15.465]                 ...future.workdir <- getwd()
[10:26:15.465]             }
[10:26:15.465]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:15.465]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:15.465]         }
[10:26:15.465]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:15.465]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:15.465]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:15.465]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:15.465]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:15.465]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:15.465]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:15.465]             base::names(...future.oldOptions))
[10:26:15.465]     }
[10:26:15.465]     if (FALSE) {
[10:26:15.465]     }
[10:26:15.465]     else {
[10:26:15.465]         if (TRUE) {
[10:26:15.465]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:15.465]                 open = "w")
[10:26:15.465]         }
[10:26:15.465]         else {
[10:26:15.465]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:15.465]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:15.465]         }
[10:26:15.465]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:15.465]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:15.465]             base::sink(type = "output", split = FALSE)
[10:26:15.465]             base::close(...future.stdout)
[10:26:15.465]         }, add = TRUE)
[10:26:15.465]     }
[10:26:15.465]     ...future.frame <- base::sys.nframe()
[10:26:15.465]     ...future.conditions <- base::list()
[10:26:15.465]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:15.465]     if (FALSE) {
[10:26:15.465]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:15.465]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:15.465]     }
[10:26:15.465]     ...future.result <- base::tryCatch({
[10:26:15.465]         base::withCallingHandlers({
[10:26:15.465]             ...future.value <- base::withVisible(base::local({
[10:26:15.465]                 ...future.makeSendCondition <- base::local({
[10:26:15.465]                   sendCondition <- NULL
[10:26:15.465]                   function(frame = 1L) {
[10:26:15.465]                     if (is.function(sendCondition)) 
[10:26:15.465]                       return(sendCondition)
[10:26:15.465]                     ns <- getNamespace("parallel")
[10:26:15.465]                     if (exists("sendData", mode = "function", 
[10:26:15.465]                       envir = ns)) {
[10:26:15.465]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:15.465]                         envir = ns)
[10:26:15.465]                       envir <- sys.frame(frame)
[10:26:15.465]                       master <- NULL
[10:26:15.465]                       while (!identical(envir, .GlobalEnv) && 
[10:26:15.465]                         !identical(envir, emptyenv())) {
[10:26:15.465]                         if (exists("master", mode = "list", envir = envir, 
[10:26:15.465]                           inherits = FALSE)) {
[10:26:15.465]                           master <- get("master", mode = "list", 
[10:26:15.465]                             envir = envir, inherits = FALSE)
[10:26:15.465]                           if (inherits(master, c("SOCKnode", 
[10:26:15.465]                             "SOCK0node"))) {
[10:26:15.465]                             sendCondition <<- function(cond) {
[10:26:15.465]                               data <- list(type = "VALUE", value = cond, 
[10:26:15.465]                                 success = TRUE)
[10:26:15.465]                               parallel_sendData(master, data)
[10:26:15.465]                             }
[10:26:15.465]                             return(sendCondition)
[10:26:15.465]                           }
[10:26:15.465]                         }
[10:26:15.465]                         frame <- frame + 1L
[10:26:15.465]                         envir <- sys.frame(frame)
[10:26:15.465]                       }
[10:26:15.465]                     }
[10:26:15.465]                     sendCondition <<- function(cond) NULL
[10:26:15.465]                   }
[10:26:15.465]                 })
[10:26:15.465]                 withCallingHandlers({
[10:26:15.465]                   {
[10:26:15.465]                     b <- a * ii
[10:26:15.465]                     a <- 0
[10:26:15.465]                     b
[10:26:15.465]                   }
[10:26:15.465]                 }, immediateCondition = function(cond) {
[10:26:15.465]                   sendCondition <- ...future.makeSendCondition()
[10:26:15.465]                   sendCondition(cond)
[10:26:15.465]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.465]                   {
[10:26:15.465]                     inherits <- base::inherits
[10:26:15.465]                     invokeRestart <- base::invokeRestart
[10:26:15.465]                     is.null <- base::is.null
[10:26:15.465]                     muffled <- FALSE
[10:26:15.465]                     if (inherits(cond, "message")) {
[10:26:15.465]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:15.465]                       if (muffled) 
[10:26:15.465]                         invokeRestart("muffleMessage")
[10:26:15.465]                     }
[10:26:15.465]                     else if (inherits(cond, "warning")) {
[10:26:15.465]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:15.465]                       if (muffled) 
[10:26:15.465]                         invokeRestart("muffleWarning")
[10:26:15.465]                     }
[10:26:15.465]                     else if (inherits(cond, "condition")) {
[10:26:15.465]                       if (!is.null(pattern)) {
[10:26:15.465]                         computeRestarts <- base::computeRestarts
[10:26:15.465]                         grepl <- base::grepl
[10:26:15.465]                         restarts <- computeRestarts(cond)
[10:26:15.465]                         for (restart in restarts) {
[10:26:15.465]                           name <- restart$name
[10:26:15.465]                           if (is.null(name)) 
[10:26:15.465]                             next
[10:26:15.465]                           if (!grepl(pattern, name)) 
[10:26:15.465]                             next
[10:26:15.465]                           invokeRestart(restart)
[10:26:15.465]                           muffled <- TRUE
[10:26:15.465]                           break
[10:26:15.465]                         }
[10:26:15.465]                       }
[10:26:15.465]                     }
[10:26:15.465]                     invisible(muffled)
[10:26:15.465]                   }
[10:26:15.465]                   muffleCondition(cond)
[10:26:15.465]                 })
[10:26:15.465]             }))
[10:26:15.465]             future::FutureResult(value = ...future.value$value, 
[10:26:15.465]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.465]                   ...future.rng), globalenv = if (FALSE) 
[10:26:15.465]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:15.465]                     ...future.globalenv.names))
[10:26:15.465]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:15.465]         }, condition = base::local({
[10:26:15.465]             c <- base::c
[10:26:15.465]             inherits <- base::inherits
[10:26:15.465]             invokeRestart <- base::invokeRestart
[10:26:15.465]             length <- base::length
[10:26:15.465]             list <- base::list
[10:26:15.465]             seq.int <- base::seq.int
[10:26:15.465]             signalCondition <- base::signalCondition
[10:26:15.465]             sys.calls <- base::sys.calls
[10:26:15.465]             `[[` <- base::`[[`
[10:26:15.465]             `+` <- base::`+`
[10:26:15.465]             `<<-` <- base::`<<-`
[10:26:15.465]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:15.465]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:15.465]                   3L)]
[10:26:15.465]             }
[10:26:15.465]             function(cond) {
[10:26:15.465]                 is_error <- inherits(cond, "error")
[10:26:15.465]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:15.465]                   NULL)
[10:26:15.465]                 if (is_error) {
[10:26:15.465]                   sessionInformation <- function() {
[10:26:15.465]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:15.465]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:15.465]                       search = base::search(), system = base::Sys.info())
[10:26:15.465]                   }
[10:26:15.465]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.465]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:15.465]                     cond$call), session = sessionInformation(), 
[10:26:15.465]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:15.465]                   signalCondition(cond)
[10:26:15.465]                 }
[10:26:15.465]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:15.465]                 "immediateCondition"))) {
[10:26:15.465]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:15.465]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.465]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:15.465]                   if (TRUE && !signal) {
[10:26:15.465]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.465]                     {
[10:26:15.465]                       inherits <- base::inherits
[10:26:15.465]                       invokeRestart <- base::invokeRestart
[10:26:15.465]                       is.null <- base::is.null
[10:26:15.465]                       muffled <- FALSE
[10:26:15.465]                       if (inherits(cond, "message")) {
[10:26:15.465]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.465]                         if (muffled) 
[10:26:15.465]                           invokeRestart("muffleMessage")
[10:26:15.465]                       }
[10:26:15.465]                       else if (inherits(cond, "warning")) {
[10:26:15.465]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.465]                         if (muffled) 
[10:26:15.465]                           invokeRestart("muffleWarning")
[10:26:15.465]                       }
[10:26:15.465]                       else if (inherits(cond, "condition")) {
[10:26:15.465]                         if (!is.null(pattern)) {
[10:26:15.465]                           computeRestarts <- base::computeRestarts
[10:26:15.465]                           grepl <- base::grepl
[10:26:15.465]                           restarts <- computeRestarts(cond)
[10:26:15.465]                           for (restart in restarts) {
[10:26:15.465]                             name <- restart$name
[10:26:15.465]                             if (is.null(name)) 
[10:26:15.465]                               next
[10:26:15.465]                             if (!grepl(pattern, name)) 
[10:26:15.465]                               next
[10:26:15.465]                             invokeRestart(restart)
[10:26:15.465]                             muffled <- TRUE
[10:26:15.465]                             break
[10:26:15.465]                           }
[10:26:15.465]                         }
[10:26:15.465]                       }
[10:26:15.465]                       invisible(muffled)
[10:26:15.465]                     }
[10:26:15.465]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.465]                   }
[10:26:15.465]                 }
[10:26:15.465]                 else {
[10:26:15.465]                   if (TRUE) {
[10:26:15.465]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.465]                     {
[10:26:15.465]                       inherits <- base::inherits
[10:26:15.465]                       invokeRestart <- base::invokeRestart
[10:26:15.465]                       is.null <- base::is.null
[10:26:15.465]                       muffled <- FALSE
[10:26:15.465]                       if (inherits(cond, "message")) {
[10:26:15.465]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.465]                         if (muffled) 
[10:26:15.465]                           invokeRestart("muffleMessage")
[10:26:15.465]                       }
[10:26:15.465]                       else if (inherits(cond, "warning")) {
[10:26:15.465]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.465]                         if (muffled) 
[10:26:15.465]                           invokeRestart("muffleWarning")
[10:26:15.465]                       }
[10:26:15.465]                       else if (inherits(cond, "condition")) {
[10:26:15.465]                         if (!is.null(pattern)) {
[10:26:15.465]                           computeRestarts <- base::computeRestarts
[10:26:15.465]                           grepl <- base::grepl
[10:26:15.465]                           restarts <- computeRestarts(cond)
[10:26:15.465]                           for (restart in restarts) {
[10:26:15.465]                             name <- restart$name
[10:26:15.465]                             if (is.null(name)) 
[10:26:15.465]                               next
[10:26:15.465]                             if (!grepl(pattern, name)) 
[10:26:15.465]                               next
[10:26:15.465]                             invokeRestart(restart)
[10:26:15.465]                             muffled <- TRUE
[10:26:15.465]                             break
[10:26:15.465]                           }
[10:26:15.465]                         }
[10:26:15.465]                       }
[10:26:15.465]                       invisible(muffled)
[10:26:15.465]                     }
[10:26:15.465]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.465]                   }
[10:26:15.465]                 }
[10:26:15.465]             }
[10:26:15.465]         }))
[10:26:15.465]     }, error = function(ex) {
[10:26:15.465]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:15.465]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.465]                 ...future.rng), started = ...future.startTime, 
[10:26:15.465]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:15.465]             version = "1.8"), class = "FutureResult")
[10:26:15.465]     }, finally = {
[10:26:15.465]         if (!identical(...future.workdir, getwd())) 
[10:26:15.465]             setwd(...future.workdir)
[10:26:15.465]         {
[10:26:15.465]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:15.465]                 ...future.oldOptions$nwarnings <- NULL
[10:26:15.465]             }
[10:26:15.465]             base::options(...future.oldOptions)
[10:26:15.465]             if (.Platform$OS.type == "windows") {
[10:26:15.465]                 old_names <- names(...future.oldEnvVars)
[10:26:15.465]                 envs <- base::Sys.getenv()
[10:26:15.465]                 names <- names(envs)
[10:26:15.465]                 common <- intersect(names, old_names)
[10:26:15.465]                 added <- setdiff(names, old_names)
[10:26:15.465]                 removed <- setdiff(old_names, names)
[10:26:15.465]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:15.465]                   envs[common]]
[10:26:15.465]                 NAMES <- toupper(changed)
[10:26:15.465]                 args <- list()
[10:26:15.465]                 for (kk in seq_along(NAMES)) {
[10:26:15.465]                   name <- changed[[kk]]
[10:26:15.465]                   NAME <- NAMES[[kk]]
[10:26:15.465]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.465]                     next
[10:26:15.465]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.465]                 }
[10:26:15.465]                 NAMES <- toupper(added)
[10:26:15.465]                 for (kk in seq_along(NAMES)) {
[10:26:15.465]                   name <- added[[kk]]
[10:26:15.465]                   NAME <- NAMES[[kk]]
[10:26:15.465]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.465]                     next
[10:26:15.465]                   args[[name]] <- ""
[10:26:15.465]                 }
[10:26:15.465]                 NAMES <- toupper(removed)
[10:26:15.465]                 for (kk in seq_along(NAMES)) {
[10:26:15.465]                   name <- removed[[kk]]
[10:26:15.465]                   NAME <- NAMES[[kk]]
[10:26:15.465]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.465]                     next
[10:26:15.465]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.465]                 }
[10:26:15.465]                 if (length(args) > 0) 
[10:26:15.465]                   base::do.call(base::Sys.setenv, args = args)
[10:26:15.465]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:15.465]             }
[10:26:15.465]             else {
[10:26:15.465]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:15.465]             }
[10:26:15.465]             {
[10:26:15.465]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:15.465]                   0L) {
[10:26:15.465]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:15.465]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:15.465]                   base::options(opts)
[10:26:15.465]                 }
[10:26:15.465]                 {
[10:26:15.465]                   {
[10:26:15.465]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:15.465]                     NULL
[10:26:15.465]                   }
[10:26:15.465]                   options(future.plan = NULL)
[10:26:15.465]                   if (is.na(NA_character_)) 
[10:26:15.465]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.465]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:15.465]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:15.465]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:15.465]                     envir = parent.frame()) 
[10:26:15.465]                   {
[10:26:15.465]                     if (is.function(workers)) 
[10:26:15.465]                       workers <- workers()
[10:26:15.465]                     workers <- structure(as.integer(workers), 
[10:26:15.465]                       class = class(workers))
[10:26:15.465]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:15.465]                       workers >= 1)
[10:26:15.465]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:15.465]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:15.465]                     }
[10:26:15.465]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:15.465]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:15.465]                       envir = envir)
[10:26:15.465]                     if (!future$lazy) 
[10:26:15.465]                       future <- run(future)
[10:26:15.465]                     invisible(future)
[10:26:15.465]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:15.465]                 }
[10:26:15.465]             }
[10:26:15.465]         }
[10:26:15.465]     })
[10:26:15.465]     if (TRUE) {
[10:26:15.465]         base::sink(type = "output", split = FALSE)
[10:26:15.465]         if (TRUE) {
[10:26:15.465]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:15.465]         }
[10:26:15.465]         else {
[10:26:15.465]             ...future.result["stdout"] <- base::list(NULL)
[10:26:15.465]         }
[10:26:15.465]         base::close(...future.stdout)
[10:26:15.465]         ...future.stdout <- NULL
[10:26:15.465]     }
[10:26:15.465]     ...future.result$conditions <- ...future.conditions
[10:26:15.465]     ...future.result$finished <- base::Sys.time()
[10:26:15.465]     ...future.result
[10:26:15.465] }
[10:26:15.467] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[10:26:15.468] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[10:26:15.468] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[10:26:15.468] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[10:26:15.468] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[10:26:15.468] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[10:26:15.469] MultisessionFuture started
[10:26:15.469] - Launch lazy future ... done
[10:26:15.469] run() for ‘MultisessionFuture’ ... done
[10:26:15.469] result() for ClusterFuture ...
[10:26:15.469] receiveMessageFromWorker() for ClusterFuture ...
[10:26:15.469] - Validating connection of MultisessionFuture
[10:26:15.514] - received message: FutureResult
[10:26:15.514] - Received FutureResult
[10:26:15.514] - Erased future from FutureRegistry
[10:26:15.514] result() for ClusterFuture ...
[10:26:15.514] - result already collected: FutureResult
[10:26:15.514] result() for ClusterFuture ... done
[10:26:15.514] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:15.515] result() for ClusterFuture ... done
[10:26:15.515] result() for ClusterFuture ...
[10:26:15.515] - result already collected: FutureResult
[10:26:15.515] result() for ClusterFuture ... done
[10:26:15.515] run() for ‘Future’ ...
[10:26:15.515] - state: ‘created’
[10:26:15.515] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:15.529] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:15.529] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:15.529]   - Field: ‘node’
[10:26:15.529]   - Field: ‘label’
[10:26:15.529]   - Field: ‘local’
[10:26:15.530]   - Field: ‘owner’
[10:26:15.530]   - Field: ‘envir’
[10:26:15.530]   - Field: ‘workers’
[10:26:15.530]   - Field: ‘packages’
[10:26:15.530]   - Field: ‘gc’
[10:26:15.530]   - Field: ‘conditions’
[10:26:15.530]   - Field: ‘persistent’
[10:26:15.530]   - Field: ‘expr’
[10:26:15.530]   - Field: ‘uuid’
[10:26:15.530]   - Field: ‘seed’
[10:26:15.530]   - Field: ‘version’
[10:26:15.531]   - Field: ‘result’
[10:26:15.531]   - Field: ‘asynchronous’
[10:26:15.531]   - Field: ‘calls’
[10:26:15.531]   - Field: ‘globals’
[10:26:15.531]   - Field: ‘stdout’
[10:26:15.531]   - Field: ‘earlySignal’
[10:26:15.531]   - Field: ‘lazy’
[10:26:15.531]   - Field: ‘state’
[10:26:15.531] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:15.531] - Launch lazy future ...
[10:26:15.532] Packages needed by the future expression (n = 0): <none>
[10:26:15.532] Packages needed by future strategies (n = 0): <none>
[10:26:15.532] {
[10:26:15.532]     {
[10:26:15.532]         {
[10:26:15.532]             ...future.startTime <- base::Sys.time()
[10:26:15.532]             {
[10:26:15.532]                 {
[10:26:15.532]                   {
[10:26:15.532]                     {
[10:26:15.532]                       base::local({
[10:26:15.532]                         has_future <- base::requireNamespace("future", 
[10:26:15.532]                           quietly = TRUE)
[10:26:15.532]                         if (has_future) {
[10:26:15.532]                           ns <- base::getNamespace("future")
[10:26:15.532]                           version <- ns[[".package"]][["version"]]
[10:26:15.532]                           if (is.null(version)) 
[10:26:15.532]                             version <- utils::packageVersion("future")
[10:26:15.532]                         }
[10:26:15.532]                         else {
[10:26:15.532]                           version <- NULL
[10:26:15.532]                         }
[10:26:15.532]                         if (!has_future || version < "1.8.0") {
[10:26:15.532]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:15.532]                             "", base::R.version$version.string), 
[10:26:15.532]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:15.532]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:15.532]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:15.532]                               "release", "version")], collapse = " "), 
[10:26:15.532]                             hostname = base::Sys.info()[["nodename"]])
[10:26:15.532]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:15.532]                             info)
[10:26:15.532]                           info <- base::paste(info, collapse = "; ")
[10:26:15.532]                           if (!has_future) {
[10:26:15.532]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:15.532]                               info)
[10:26:15.532]                           }
[10:26:15.532]                           else {
[10:26:15.532]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:15.532]                               info, version)
[10:26:15.532]                           }
[10:26:15.532]                           base::stop(msg)
[10:26:15.532]                         }
[10:26:15.532]                       })
[10:26:15.532]                     }
[10:26:15.532]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:15.532]                     base::options(mc.cores = 1L)
[10:26:15.532]                   }
[10:26:15.532]                   options(future.plan = NULL)
[10:26:15.532]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.532]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:15.532]                 }
[10:26:15.532]                 ...future.workdir <- getwd()
[10:26:15.532]             }
[10:26:15.532]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:15.532]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:15.532]         }
[10:26:15.532]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:15.532]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:15.532]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:15.532]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:15.532]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:15.532]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:15.532]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:15.532]             base::names(...future.oldOptions))
[10:26:15.532]     }
[10:26:15.532]     if (FALSE) {
[10:26:15.532]     }
[10:26:15.532]     else {
[10:26:15.532]         if (TRUE) {
[10:26:15.532]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:15.532]                 open = "w")
[10:26:15.532]         }
[10:26:15.532]         else {
[10:26:15.532]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:15.532]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:15.532]         }
[10:26:15.532]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:15.532]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:15.532]             base::sink(type = "output", split = FALSE)
[10:26:15.532]             base::close(...future.stdout)
[10:26:15.532]         }, add = TRUE)
[10:26:15.532]     }
[10:26:15.532]     ...future.frame <- base::sys.nframe()
[10:26:15.532]     ...future.conditions <- base::list()
[10:26:15.532]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:15.532]     if (FALSE) {
[10:26:15.532]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:15.532]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:15.532]     }
[10:26:15.532]     ...future.result <- base::tryCatch({
[10:26:15.532]         base::withCallingHandlers({
[10:26:15.532]             ...future.value <- base::withVisible(base::local({
[10:26:15.532]                 ...future.makeSendCondition <- base::local({
[10:26:15.532]                   sendCondition <- NULL
[10:26:15.532]                   function(frame = 1L) {
[10:26:15.532]                     if (is.function(sendCondition)) 
[10:26:15.532]                       return(sendCondition)
[10:26:15.532]                     ns <- getNamespace("parallel")
[10:26:15.532]                     if (exists("sendData", mode = "function", 
[10:26:15.532]                       envir = ns)) {
[10:26:15.532]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:15.532]                         envir = ns)
[10:26:15.532]                       envir <- sys.frame(frame)
[10:26:15.532]                       master <- NULL
[10:26:15.532]                       while (!identical(envir, .GlobalEnv) && 
[10:26:15.532]                         !identical(envir, emptyenv())) {
[10:26:15.532]                         if (exists("master", mode = "list", envir = envir, 
[10:26:15.532]                           inherits = FALSE)) {
[10:26:15.532]                           master <- get("master", mode = "list", 
[10:26:15.532]                             envir = envir, inherits = FALSE)
[10:26:15.532]                           if (inherits(master, c("SOCKnode", 
[10:26:15.532]                             "SOCK0node"))) {
[10:26:15.532]                             sendCondition <<- function(cond) {
[10:26:15.532]                               data <- list(type = "VALUE", value = cond, 
[10:26:15.532]                                 success = TRUE)
[10:26:15.532]                               parallel_sendData(master, data)
[10:26:15.532]                             }
[10:26:15.532]                             return(sendCondition)
[10:26:15.532]                           }
[10:26:15.532]                         }
[10:26:15.532]                         frame <- frame + 1L
[10:26:15.532]                         envir <- sys.frame(frame)
[10:26:15.532]                       }
[10:26:15.532]                     }
[10:26:15.532]                     sendCondition <<- function(cond) NULL
[10:26:15.532]                   }
[10:26:15.532]                 })
[10:26:15.532]                 withCallingHandlers({
[10:26:15.532]                   {
[10:26:15.532]                     b <- a * ii
[10:26:15.532]                     a <- 0
[10:26:15.532]                     b
[10:26:15.532]                   }
[10:26:15.532]                 }, immediateCondition = function(cond) {
[10:26:15.532]                   sendCondition <- ...future.makeSendCondition()
[10:26:15.532]                   sendCondition(cond)
[10:26:15.532]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.532]                   {
[10:26:15.532]                     inherits <- base::inherits
[10:26:15.532]                     invokeRestart <- base::invokeRestart
[10:26:15.532]                     is.null <- base::is.null
[10:26:15.532]                     muffled <- FALSE
[10:26:15.532]                     if (inherits(cond, "message")) {
[10:26:15.532]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:15.532]                       if (muffled) 
[10:26:15.532]                         invokeRestart("muffleMessage")
[10:26:15.532]                     }
[10:26:15.532]                     else if (inherits(cond, "warning")) {
[10:26:15.532]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:15.532]                       if (muffled) 
[10:26:15.532]                         invokeRestart("muffleWarning")
[10:26:15.532]                     }
[10:26:15.532]                     else if (inherits(cond, "condition")) {
[10:26:15.532]                       if (!is.null(pattern)) {
[10:26:15.532]                         computeRestarts <- base::computeRestarts
[10:26:15.532]                         grepl <- base::grepl
[10:26:15.532]                         restarts <- computeRestarts(cond)
[10:26:15.532]                         for (restart in restarts) {
[10:26:15.532]                           name <- restart$name
[10:26:15.532]                           if (is.null(name)) 
[10:26:15.532]                             next
[10:26:15.532]                           if (!grepl(pattern, name)) 
[10:26:15.532]                             next
[10:26:15.532]                           invokeRestart(restart)
[10:26:15.532]                           muffled <- TRUE
[10:26:15.532]                           break
[10:26:15.532]                         }
[10:26:15.532]                       }
[10:26:15.532]                     }
[10:26:15.532]                     invisible(muffled)
[10:26:15.532]                   }
[10:26:15.532]                   muffleCondition(cond)
[10:26:15.532]                 })
[10:26:15.532]             }))
[10:26:15.532]             future::FutureResult(value = ...future.value$value, 
[10:26:15.532]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.532]                   ...future.rng), globalenv = if (FALSE) 
[10:26:15.532]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:15.532]                     ...future.globalenv.names))
[10:26:15.532]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:15.532]         }, condition = base::local({
[10:26:15.532]             c <- base::c
[10:26:15.532]             inherits <- base::inherits
[10:26:15.532]             invokeRestart <- base::invokeRestart
[10:26:15.532]             length <- base::length
[10:26:15.532]             list <- base::list
[10:26:15.532]             seq.int <- base::seq.int
[10:26:15.532]             signalCondition <- base::signalCondition
[10:26:15.532]             sys.calls <- base::sys.calls
[10:26:15.532]             `[[` <- base::`[[`
[10:26:15.532]             `+` <- base::`+`
[10:26:15.532]             `<<-` <- base::`<<-`
[10:26:15.532]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:15.532]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:15.532]                   3L)]
[10:26:15.532]             }
[10:26:15.532]             function(cond) {
[10:26:15.532]                 is_error <- inherits(cond, "error")
[10:26:15.532]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:15.532]                   NULL)
[10:26:15.532]                 if (is_error) {
[10:26:15.532]                   sessionInformation <- function() {
[10:26:15.532]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:15.532]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:15.532]                       search = base::search(), system = base::Sys.info())
[10:26:15.532]                   }
[10:26:15.532]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.532]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:15.532]                     cond$call), session = sessionInformation(), 
[10:26:15.532]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:15.532]                   signalCondition(cond)
[10:26:15.532]                 }
[10:26:15.532]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:15.532]                 "immediateCondition"))) {
[10:26:15.532]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:15.532]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.532]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:15.532]                   if (TRUE && !signal) {
[10:26:15.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.532]                     {
[10:26:15.532]                       inherits <- base::inherits
[10:26:15.532]                       invokeRestart <- base::invokeRestart
[10:26:15.532]                       is.null <- base::is.null
[10:26:15.532]                       muffled <- FALSE
[10:26:15.532]                       if (inherits(cond, "message")) {
[10:26:15.532]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.532]                         if (muffled) 
[10:26:15.532]                           invokeRestart("muffleMessage")
[10:26:15.532]                       }
[10:26:15.532]                       else if (inherits(cond, "warning")) {
[10:26:15.532]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.532]                         if (muffled) 
[10:26:15.532]                           invokeRestart("muffleWarning")
[10:26:15.532]                       }
[10:26:15.532]                       else if (inherits(cond, "condition")) {
[10:26:15.532]                         if (!is.null(pattern)) {
[10:26:15.532]                           computeRestarts <- base::computeRestarts
[10:26:15.532]                           grepl <- base::grepl
[10:26:15.532]                           restarts <- computeRestarts(cond)
[10:26:15.532]                           for (restart in restarts) {
[10:26:15.532]                             name <- restart$name
[10:26:15.532]                             if (is.null(name)) 
[10:26:15.532]                               next
[10:26:15.532]                             if (!grepl(pattern, name)) 
[10:26:15.532]                               next
[10:26:15.532]                             invokeRestart(restart)
[10:26:15.532]                             muffled <- TRUE
[10:26:15.532]                             break
[10:26:15.532]                           }
[10:26:15.532]                         }
[10:26:15.532]                       }
[10:26:15.532]                       invisible(muffled)
[10:26:15.532]                     }
[10:26:15.532]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.532]                   }
[10:26:15.532]                 }
[10:26:15.532]                 else {
[10:26:15.532]                   if (TRUE) {
[10:26:15.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.532]                     {
[10:26:15.532]                       inherits <- base::inherits
[10:26:15.532]                       invokeRestart <- base::invokeRestart
[10:26:15.532]                       is.null <- base::is.null
[10:26:15.532]                       muffled <- FALSE
[10:26:15.532]                       if (inherits(cond, "message")) {
[10:26:15.532]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.532]                         if (muffled) 
[10:26:15.532]                           invokeRestart("muffleMessage")
[10:26:15.532]                       }
[10:26:15.532]                       else if (inherits(cond, "warning")) {
[10:26:15.532]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.532]                         if (muffled) 
[10:26:15.532]                           invokeRestart("muffleWarning")
[10:26:15.532]                       }
[10:26:15.532]                       else if (inherits(cond, "condition")) {
[10:26:15.532]                         if (!is.null(pattern)) {
[10:26:15.532]                           computeRestarts <- base::computeRestarts
[10:26:15.532]                           grepl <- base::grepl
[10:26:15.532]                           restarts <- computeRestarts(cond)
[10:26:15.532]                           for (restart in restarts) {
[10:26:15.532]                             name <- restart$name
[10:26:15.532]                             if (is.null(name)) 
[10:26:15.532]                               next
[10:26:15.532]                             if (!grepl(pattern, name)) 
[10:26:15.532]                               next
[10:26:15.532]                             invokeRestart(restart)
[10:26:15.532]                             muffled <- TRUE
[10:26:15.532]                             break
[10:26:15.532]                           }
[10:26:15.532]                         }
[10:26:15.532]                       }
[10:26:15.532]                       invisible(muffled)
[10:26:15.532]                     }
[10:26:15.532]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.532]                   }
[10:26:15.532]                 }
[10:26:15.532]             }
[10:26:15.532]         }))
[10:26:15.532]     }, error = function(ex) {
[10:26:15.532]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:15.532]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.532]                 ...future.rng), started = ...future.startTime, 
[10:26:15.532]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:15.532]             version = "1.8"), class = "FutureResult")
[10:26:15.532]     }, finally = {
[10:26:15.532]         if (!identical(...future.workdir, getwd())) 
[10:26:15.532]             setwd(...future.workdir)
[10:26:15.532]         {
[10:26:15.532]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:15.532]                 ...future.oldOptions$nwarnings <- NULL
[10:26:15.532]             }
[10:26:15.532]             base::options(...future.oldOptions)
[10:26:15.532]             if (.Platform$OS.type == "windows") {
[10:26:15.532]                 old_names <- names(...future.oldEnvVars)
[10:26:15.532]                 envs <- base::Sys.getenv()
[10:26:15.532]                 names <- names(envs)
[10:26:15.532]                 common <- intersect(names, old_names)
[10:26:15.532]                 added <- setdiff(names, old_names)
[10:26:15.532]                 removed <- setdiff(old_names, names)
[10:26:15.532]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:15.532]                   envs[common]]
[10:26:15.532]                 NAMES <- toupper(changed)
[10:26:15.532]                 args <- list()
[10:26:15.532]                 for (kk in seq_along(NAMES)) {
[10:26:15.532]                   name <- changed[[kk]]
[10:26:15.532]                   NAME <- NAMES[[kk]]
[10:26:15.532]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.532]                     next
[10:26:15.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.532]                 }
[10:26:15.532]                 NAMES <- toupper(added)
[10:26:15.532]                 for (kk in seq_along(NAMES)) {
[10:26:15.532]                   name <- added[[kk]]
[10:26:15.532]                   NAME <- NAMES[[kk]]
[10:26:15.532]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.532]                     next
[10:26:15.532]                   args[[name]] <- ""
[10:26:15.532]                 }
[10:26:15.532]                 NAMES <- toupper(removed)
[10:26:15.532]                 for (kk in seq_along(NAMES)) {
[10:26:15.532]                   name <- removed[[kk]]
[10:26:15.532]                   NAME <- NAMES[[kk]]
[10:26:15.532]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.532]                     next
[10:26:15.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.532]                 }
[10:26:15.532]                 if (length(args) > 0) 
[10:26:15.532]                   base::do.call(base::Sys.setenv, args = args)
[10:26:15.532]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:15.532]             }
[10:26:15.532]             else {
[10:26:15.532]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:15.532]             }
[10:26:15.532]             {
[10:26:15.532]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:15.532]                   0L) {
[10:26:15.532]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:15.532]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:15.532]                   base::options(opts)
[10:26:15.532]                 }
[10:26:15.532]                 {
[10:26:15.532]                   {
[10:26:15.532]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:15.532]                     NULL
[10:26:15.532]                   }
[10:26:15.532]                   options(future.plan = NULL)
[10:26:15.532]                   if (is.na(NA_character_)) 
[10:26:15.532]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.532]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:15.532]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:15.532]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:15.532]                     envir = parent.frame()) 
[10:26:15.532]                   {
[10:26:15.532]                     if (is.function(workers)) 
[10:26:15.532]                       workers <- workers()
[10:26:15.532]                     workers <- structure(as.integer(workers), 
[10:26:15.532]                       class = class(workers))
[10:26:15.532]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:15.532]                       workers >= 1)
[10:26:15.532]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:15.532]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:15.532]                     }
[10:26:15.532]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:15.532]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:15.532]                       envir = envir)
[10:26:15.532]                     if (!future$lazy) 
[10:26:15.532]                       future <- run(future)
[10:26:15.532]                     invisible(future)
[10:26:15.532]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:15.532]                 }
[10:26:15.532]             }
[10:26:15.532]         }
[10:26:15.532]     })
[10:26:15.532]     if (TRUE) {
[10:26:15.532]         base::sink(type = "output", split = FALSE)
[10:26:15.532]         if (TRUE) {
[10:26:15.532]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:15.532]         }
[10:26:15.532]         else {
[10:26:15.532]             ...future.result["stdout"] <- base::list(NULL)
[10:26:15.532]         }
[10:26:15.532]         base::close(...future.stdout)
[10:26:15.532]         ...future.stdout <- NULL
[10:26:15.532]     }
[10:26:15.532]     ...future.result$conditions <- ...future.conditions
[10:26:15.532]     ...future.result$finished <- base::Sys.time()
[10:26:15.532]     ...future.result
[10:26:15.532] }
[10:26:15.535] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[10:26:15.535] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[10:26:15.535] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[10:26:15.535] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[10:26:15.536] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[10:26:15.536] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[10:26:15.536] MultisessionFuture started
[10:26:15.536] - Launch lazy future ... done
[10:26:15.536] run() for ‘MultisessionFuture’ ... done
[10:26:15.537] result() for ClusterFuture ...
[10:26:15.537] receiveMessageFromWorker() for ClusterFuture ...
[10:26:15.537] - Validating connection of MultisessionFuture
[10:26:15.582] - received message: FutureResult
[10:26:15.582] - Received FutureResult
[10:26:15.582] - Erased future from FutureRegistry
[10:26:15.582] result() for ClusterFuture ...
[10:26:15.582] - result already collected: FutureResult
[10:26:15.582] result() for ClusterFuture ... done
[10:26:15.583] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:15.583] result() for ClusterFuture ... done
[10:26:15.583] result() for ClusterFuture ...
[10:26:15.583] - result already collected: FutureResult
[10:26:15.583] result() for ClusterFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:15.583] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:15.583] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:15.584] 
[10:26:15.584] Searching for globals ... DONE
[10:26:15.584] - globals: [0] <none>
[10:26:15.584] getGlobalsAndPackages() ... DONE
[10:26:15.584] run() for ‘Future’ ...
[10:26:15.585] - state: ‘created’
[10:26:15.585] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:15.598] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:15.598] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:15.598]   - Field: ‘node’
[10:26:15.599]   - Field: ‘label’
[10:26:15.599]   - Field: ‘local’
[10:26:15.599]   - Field: ‘owner’
[10:26:15.599]   - Field: ‘envir’
[10:26:15.599]   - Field: ‘workers’
[10:26:15.599]   - Field: ‘packages’
[10:26:15.599]   - Field: ‘gc’
[10:26:15.599]   - Field: ‘conditions’
[10:26:15.599]   - Field: ‘persistent’
[10:26:15.599]   - Field: ‘expr’
[10:26:15.599]   - Field: ‘uuid’
[10:26:15.600]   - Field: ‘seed’
[10:26:15.600]   - Field: ‘version’
[10:26:15.600]   - Field: ‘result’
[10:26:15.600]   - Field: ‘asynchronous’
[10:26:15.600]   - Field: ‘calls’
[10:26:15.600]   - Field: ‘globals’
[10:26:15.600]   - Field: ‘stdout’
[10:26:15.600]   - Field: ‘earlySignal’
[10:26:15.600]   - Field: ‘lazy’
[10:26:15.600]   - Field: ‘state’
[10:26:15.600] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:15.601] - Launch lazy future ...
[10:26:15.601] Packages needed by the future expression (n = 0): <none>
[10:26:15.601] Packages needed by future strategies (n = 0): <none>
[10:26:15.601] {
[10:26:15.601]     {
[10:26:15.601]         {
[10:26:15.601]             ...future.startTime <- base::Sys.time()
[10:26:15.601]             {
[10:26:15.601]                 {
[10:26:15.601]                   {
[10:26:15.601]                     {
[10:26:15.601]                       base::local({
[10:26:15.601]                         has_future <- base::requireNamespace("future", 
[10:26:15.601]                           quietly = TRUE)
[10:26:15.601]                         if (has_future) {
[10:26:15.601]                           ns <- base::getNamespace("future")
[10:26:15.601]                           version <- ns[[".package"]][["version"]]
[10:26:15.601]                           if (is.null(version)) 
[10:26:15.601]                             version <- utils::packageVersion("future")
[10:26:15.601]                         }
[10:26:15.601]                         else {
[10:26:15.601]                           version <- NULL
[10:26:15.601]                         }
[10:26:15.601]                         if (!has_future || version < "1.8.0") {
[10:26:15.601]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:15.601]                             "", base::R.version$version.string), 
[10:26:15.601]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:15.601]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:15.601]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:15.601]                               "release", "version")], collapse = " "), 
[10:26:15.601]                             hostname = base::Sys.info()[["nodename"]])
[10:26:15.601]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:15.601]                             info)
[10:26:15.601]                           info <- base::paste(info, collapse = "; ")
[10:26:15.601]                           if (!has_future) {
[10:26:15.601]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:15.601]                               info)
[10:26:15.601]                           }
[10:26:15.601]                           else {
[10:26:15.601]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:15.601]                               info, version)
[10:26:15.601]                           }
[10:26:15.601]                           base::stop(msg)
[10:26:15.601]                         }
[10:26:15.601]                       })
[10:26:15.601]                     }
[10:26:15.601]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:15.601]                     base::options(mc.cores = 1L)
[10:26:15.601]                   }
[10:26:15.601]                   options(future.plan = NULL)
[10:26:15.601]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.601]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:15.601]                 }
[10:26:15.601]                 ...future.workdir <- getwd()
[10:26:15.601]             }
[10:26:15.601]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:15.601]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:15.601]         }
[10:26:15.601]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:15.601]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:15.601]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:15.601]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:15.601]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:15.601]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:15.601]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:15.601]             base::names(...future.oldOptions))
[10:26:15.601]     }
[10:26:15.601]     if (FALSE) {
[10:26:15.601]     }
[10:26:15.601]     else {
[10:26:15.601]         if (TRUE) {
[10:26:15.601]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:15.601]                 open = "w")
[10:26:15.601]         }
[10:26:15.601]         else {
[10:26:15.601]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:15.601]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:15.601]         }
[10:26:15.601]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:15.601]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:15.601]             base::sink(type = "output", split = FALSE)
[10:26:15.601]             base::close(...future.stdout)
[10:26:15.601]         }, add = TRUE)
[10:26:15.601]     }
[10:26:15.601]     ...future.frame <- base::sys.nframe()
[10:26:15.601]     ...future.conditions <- base::list()
[10:26:15.601]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:15.601]     if (FALSE) {
[10:26:15.601]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:15.601]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:15.601]     }
[10:26:15.601]     ...future.result <- base::tryCatch({
[10:26:15.601]         base::withCallingHandlers({
[10:26:15.601]             ...future.value <- base::withVisible(base::local({
[10:26:15.601]                 ...future.makeSendCondition <- base::local({
[10:26:15.601]                   sendCondition <- NULL
[10:26:15.601]                   function(frame = 1L) {
[10:26:15.601]                     if (is.function(sendCondition)) 
[10:26:15.601]                       return(sendCondition)
[10:26:15.601]                     ns <- getNamespace("parallel")
[10:26:15.601]                     if (exists("sendData", mode = "function", 
[10:26:15.601]                       envir = ns)) {
[10:26:15.601]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:15.601]                         envir = ns)
[10:26:15.601]                       envir <- sys.frame(frame)
[10:26:15.601]                       master <- NULL
[10:26:15.601]                       while (!identical(envir, .GlobalEnv) && 
[10:26:15.601]                         !identical(envir, emptyenv())) {
[10:26:15.601]                         if (exists("master", mode = "list", envir = envir, 
[10:26:15.601]                           inherits = FALSE)) {
[10:26:15.601]                           master <- get("master", mode = "list", 
[10:26:15.601]                             envir = envir, inherits = FALSE)
[10:26:15.601]                           if (inherits(master, c("SOCKnode", 
[10:26:15.601]                             "SOCK0node"))) {
[10:26:15.601]                             sendCondition <<- function(cond) {
[10:26:15.601]                               data <- list(type = "VALUE", value = cond, 
[10:26:15.601]                                 success = TRUE)
[10:26:15.601]                               parallel_sendData(master, data)
[10:26:15.601]                             }
[10:26:15.601]                             return(sendCondition)
[10:26:15.601]                           }
[10:26:15.601]                         }
[10:26:15.601]                         frame <- frame + 1L
[10:26:15.601]                         envir <- sys.frame(frame)
[10:26:15.601]                       }
[10:26:15.601]                     }
[10:26:15.601]                     sendCondition <<- function(cond) NULL
[10:26:15.601]                   }
[10:26:15.601]                 })
[10:26:15.601]                 withCallingHandlers({
[10:26:15.601]                   1
[10:26:15.601]                 }, immediateCondition = function(cond) {
[10:26:15.601]                   sendCondition <- ...future.makeSendCondition()
[10:26:15.601]                   sendCondition(cond)
[10:26:15.601]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.601]                   {
[10:26:15.601]                     inherits <- base::inherits
[10:26:15.601]                     invokeRestart <- base::invokeRestart
[10:26:15.601]                     is.null <- base::is.null
[10:26:15.601]                     muffled <- FALSE
[10:26:15.601]                     if (inherits(cond, "message")) {
[10:26:15.601]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:15.601]                       if (muffled) 
[10:26:15.601]                         invokeRestart("muffleMessage")
[10:26:15.601]                     }
[10:26:15.601]                     else if (inherits(cond, "warning")) {
[10:26:15.601]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:15.601]                       if (muffled) 
[10:26:15.601]                         invokeRestart("muffleWarning")
[10:26:15.601]                     }
[10:26:15.601]                     else if (inherits(cond, "condition")) {
[10:26:15.601]                       if (!is.null(pattern)) {
[10:26:15.601]                         computeRestarts <- base::computeRestarts
[10:26:15.601]                         grepl <- base::grepl
[10:26:15.601]                         restarts <- computeRestarts(cond)
[10:26:15.601]                         for (restart in restarts) {
[10:26:15.601]                           name <- restart$name
[10:26:15.601]                           if (is.null(name)) 
[10:26:15.601]                             next
[10:26:15.601]                           if (!grepl(pattern, name)) 
[10:26:15.601]                             next
[10:26:15.601]                           invokeRestart(restart)
[10:26:15.601]                           muffled <- TRUE
[10:26:15.601]                           break
[10:26:15.601]                         }
[10:26:15.601]                       }
[10:26:15.601]                     }
[10:26:15.601]                     invisible(muffled)
[10:26:15.601]                   }
[10:26:15.601]                   muffleCondition(cond)
[10:26:15.601]                 })
[10:26:15.601]             }))
[10:26:15.601]             future::FutureResult(value = ...future.value$value, 
[10:26:15.601]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.601]                   ...future.rng), globalenv = if (FALSE) 
[10:26:15.601]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:15.601]                     ...future.globalenv.names))
[10:26:15.601]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:15.601]         }, condition = base::local({
[10:26:15.601]             c <- base::c
[10:26:15.601]             inherits <- base::inherits
[10:26:15.601]             invokeRestart <- base::invokeRestart
[10:26:15.601]             length <- base::length
[10:26:15.601]             list <- base::list
[10:26:15.601]             seq.int <- base::seq.int
[10:26:15.601]             signalCondition <- base::signalCondition
[10:26:15.601]             sys.calls <- base::sys.calls
[10:26:15.601]             `[[` <- base::`[[`
[10:26:15.601]             `+` <- base::`+`
[10:26:15.601]             `<<-` <- base::`<<-`
[10:26:15.601]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:15.601]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:15.601]                   3L)]
[10:26:15.601]             }
[10:26:15.601]             function(cond) {
[10:26:15.601]                 is_error <- inherits(cond, "error")
[10:26:15.601]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:15.601]                   NULL)
[10:26:15.601]                 if (is_error) {
[10:26:15.601]                   sessionInformation <- function() {
[10:26:15.601]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:15.601]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:15.601]                       search = base::search(), system = base::Sys.info())
[10:26:15.601]                   }
[10:26:15.601]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.601]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:15.601]                     cond$call), session = sessionInformation(), 
[10:26:15.601]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:15.601]                   signalCondition(cond)
[10:26:15.601]                 }
[10:26:15.601]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:15.601]                 "immediateCondition"))) {
[10:26:15.601]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:15.601]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.601]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:15.601]                   if (TRUE && !signal) {
[10:26:15.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.601]                     {
[10:26:15.601]                       inherits <- base::inherits
[10:26:15.601]                       invokeRestart <- base::invokeRestart
[10:26:15.601]                       is.null <- base::is.null
[10:26:15.601]                       muffled <- FALSE
[10:26:15.601]                       if (inherits(cond, "message")) {
[10:26:15.601]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.601]                         if (muffled) 
[10:26:15.601]                           invokeRestart("muffleMessage")
[10:26:15.601]                       }
[10:26:15.601]                       else if (inherits(cond, "warning")) {
[10:26:15.601]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.601]                         if (muffled) 
[10:26:15.601]                           invokeRestart("muffleWarning")
[10:26:15.601]                       }
[10:26:15.601]                       else if (inherits(cond, "condition")) {
[10:26:15.601]                         if (!is.null(pattern)) {
[10:26:15.601]                           computeRestarts <- base::computeRestarts
[10:26:15.601]                           grepl <- base::grepl
[10:26:15.601]                           restarts <- computeRestarts(cond)
[10:26:15.601]                           for (restart in restarts) {
[10:26:15.601]                             name <- restart$name
[10:26:15.601]                             if (is.null(name)) 
[10:26:15.601]                               next
[10:26:15.601]                             if (!grepl(pattern, name)) 
[10:26:15.601]                               next
[10:26:15.601]                             invokeRestart(restart)
[10:26:15.601]                             muffled <- TRUE
[10:26:15.601]                             break
[10:26:15.601]                           }
[10:26:15.601]                         }
[10:26:15.601]                       }
[10:26:15.601]                       invisible(muffled)
[10:26:15.601]                     }
[10:26:15.601]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.601]                   }
[10:26:15.601]                 }
[10:26:15.601]                 else {
[10:26:15.601]                   if (TRUE) {
[10:26:15.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.601]                     {
[10:26:15.601]                       inherits <- base::inherits
[10:26:15.601]                       invokeRestart <- base::invokeRestart
[10:26:15.601]                       is.null <- base::is.null
[10:26:15.601]                       muffled <- FALSE
[10:26:15.601]                       if (inherits(cond, "message")) {
[10:26:15.601]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.601]                         if (muffled) 
[10:26:15.601]                           invokeRestart("muffleMessage")
[10:26:15.601]                       }
[10:26:15.601]                       else if (inherits(cond, "warning")) {
[10:26:15.601]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.601]                         if (muffled) 
[10:26:15.601]                           invokeRestart("muffleWarning")
[10:26:15.601]                       }
[10:26:15.601]                       else if (inherits(cond, "condition")) {
[10:26:15.601]                         if (!is.null(pattern)) {
[10:26:15.601]                           computeRestarts <- base::computeRestarts
[10:26:15.601]                           grepl <- base::grepl
[10:26:15.601]                           restarts <- computeRestarts(cond)
[10:26:15.601]                           for (restart in restarts) {
[10:26:15.601]                             name <- restart$name
[10:26:15.601]                             if (is.null(name)) 
[10:26:15.601]                               next
[10:26:15.601]                             if (!grepl(pattern, name)) 
[10:26:15.601]                               next
[10:26:15.601]                             invokeRestart(restart)
[10:26:15.601]                             muffled <- TRUE
[10:26:15.601]                             break
[10:26:15.601]                           }
[10:26:15.601]                         }
[10:26:15.601]                       }
[10:26:15.601]                       invisible(muffled)
[10:26:15.601]                     }
[10:26:15.601]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.601]                   }
[10:26:15.601]                 }
[10:26:15.601]             }
[10:26:15.601]         }))
[10:26:15.601]     }, error = function(ex) {
[10:26:15.601]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:15.601]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.601]                 ...future.rng), started = ...future.startTime, 
[10:26:15.601]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:15.601]             version = "1.8"), class = "FutureResult")
[10:26:15.601]     }, finally = {
[10:26:15.601]         if (!identical(...future.workdir, getwd())) 
[10:26:15.601]             setwd(...future.workdir)
[10:26:15.601]         {
[10:26:15.601]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:15.601]                 ...future.oldOptions$nwarnings <- NULL
[10:26:15.601]             }
[10:26:15.601]             base::options(...future.oldOptions)
[10:26:15.601]             if (.Platform$OS.type == "windows") {
[10:26:15.601]                 old_names <- names(...future.oldEnvVars)
[10:26:15.601]                 envs <- base::Sys.getenv()
[10:26:15.601]                 names <- names(envs)
[10:26:15.601]                 common <- intersect(names, old_names)
[10:26:15.601]                 added <- setdiff(names, old_names)
[10:26:15.601]                 removed <- setdiff(old_names, names)
[10:26:15.601]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:15.601]                   envs[common]]
[10:26:15.601]                 NAMES <- toupper(changed)
[10:26:15.601]                 args <- list()
[10:26:15.601]                 for (kk in seq_along(NAMES)) {
[10:26:15.601]                   name <- changed[[kk]]
[10:26:15.601]                   NAME <- NAMES[[kk]]
[10:26:15.601]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.601]                     next
[10:26:15.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.601]                 }
[10:26:15.601]                 NAMES <- toupper(added)
[10:26:15.601]                 for (kk in seq_along(NAMES)) {
[10:26:15.601]                   name <- added[[kk]]
[10:26:15.601]                   NAME <- NAMES[[kk]]
[10:26:15.601]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.601]                     next
[10:26:15.601]                   args[[name]] <- ""
[10:26:15.601]                 }
[10:26:15.601]                 NAMES <- toupper(removed)
[10:26:15.601]                 for (kk in seq_along(NAMES)) {
[10:26:15.601]                   name <- removed[[kk]]
[10:26:15.601]                   NAME <- NAMES[[kk]]
[10:26:15.601]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.601]                     next
[10:26:15.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.601]                 }
[10:26:15.601]                 if (length(args) > 0) 
[10:26:15.601]                   base::do.call(base::Sys.setenv, args = args)
[10:26:15.601]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:15.601]             }
[10:26:15.601]             else {
[10:26:15.601]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:15.601]             }
[10:26:15.601]             {
[10:26:15.601]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:15.601]                   0L) {
[10:26:15.601]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:15.601]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:15.601]                   base::options(opts)
[10:26:15.601]                 }
[10:26:15.601]                 {
[10:26:15.601]                   {
[10:26:15.601]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:15.601]                     NULL
[10:26:15.601]                   }
[10:26:15.601]                   options(future.plan = NULL)
[10:26:15.601]                   if (is.na(NA_character_)) 
[10:26:15.601]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.601]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:15.601]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:15.601]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:15.601]                     envir = parent.frame()) 
[10:26:15.601]                   {
[10:26:15.601]                     if (is.function(workers)) 
[10:26:15.601]                       workers <- workers()
[10:26:15.601]                     workers <- structure(as.integer(workers), 
[10:26:15.601]                       class = class(workers))
[10:26:15.601]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:15.601]                       workers >= 1)
[10:26:15.601]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:15.601]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:15.601]                     }
[10:26:15.601]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:15.601]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:15.601]                       envir = envir)
[10:26:15.601]                     if (!future$lazy) 
[10:26:15.601]                       future <- run(future)
[10:26:15.601]                     invisible(future)
[10:26:15.601]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:15.601]                 }
[10:26:15.601]             }
[10:26:15.601]         }
[10:26:15.601]     })
[10:26:15.601]     if (TRUE) {
[10:26:15.601]         base::sink(type = "output", split = FALSE)
[10:26:15.601]         if (TRUE) {
[10:26:15.601]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:15.601]         }
[10:26:15.601]         else {
[10:26:15.601]             ...future.result["stdout"] <- base::list(NULL)
[10:26:15.601]         }
[10:26:15.601]         base::close(...future.stdout)
[10:26:15.601]         ...future.stdout <- NULL
[10:26:15.601]     }
[10:26:15.601]     ...future.result$conditions <- ...future.conditions
[10:26:15.601]     ...future.result$finished <- base::Sys.time()
[10:26:15.601]     ...future.result
[10:26:15.601] }
[10:26:15.604] MultisessionFuture started
[10:26:15.604] - Launch lazy future ... done
[10:26:15.604] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:15.605] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:15.605] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:15.606] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:15.606] Searching for globals ... DONE
[10:26:15.606] Resolving globals: TRUE
[10:26:15.606] Resolving any globals that are futures ...
[10:26:15.606] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:15.606] Resolving any globals that are futures ... DONE
[10:26:15.606] Resolving futures part of globals (recursively) ...
[10:26:15.607] resolve() on list ...
[10:26:15.607]  recursive: 99
[10:26:15.607]  length: 1
[10:26:15.607]  elements: ‘a’
[10:26:15.650] receiveMessageFromWorker() for ClusterFuture ...
[10:26:15.650] - Validating connection of MultisessionFuture
[10:26:15.650] - received message: FutureResult
[10:26:15.650] - Received FutureResult
[10:26:15.651] - Erased future from FutureRegistry
[10:26:15.651] result() for ClusterFuture ...
[10:26:15.651] - result already collected: FutureResult
[10:26:15.651] result() for ClusterFuture ... done
[10:26:15.651] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:15.651] Future #1
[10:26:15.651] result() for ClusterFuture ...
[10:26:15.651] - result already collected: FutureResult
[10:26:15.651] result() for ClusterFuture ... done
[10:26:15.651] result() for ClusterFuture ...
[10:26:15.651] - result already collected: FutureResult
[10:26:15.652] result() for ClusterFuture ... done
[10:26:15.652] A MultisessionFuture was resolved
[10:26:15.652]  length: 0 (resolved future 1)
[10:26:15.652] resolve() on list ... DONE
[10:26:15.652] - globals: [1] ‘a’
[10:26:15.652] Resolving futures part of globals (recursively) ... DONE
[10:26:15.654] The total size of the 1 globals is 1.56 MiB (1640840 bytes)
[10:26:15.655] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.56 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.56 MiB of class ‘environment’)
[10:26:15.655] - globals: [1] ‘a’
[10:26:15.655] - packages: [1] ‘future’
[10:26:15.655] getGlobalsAndPackages() ... DONE
[10:26:15.655] run() for ‘Future’ ...
[10:26:15.655] - state: ‘created’
[10:26:15.655] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:15.669] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:15.669] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:15.669]   - Field: ‘node’
[10:26:15.669]   - Field: ‘label’
[10:26:15.670]   - Field: ‘local’
[10:26:15.670]   - Field: ‘owner’
[10:26:15.670]   - Field: ‘envir’
[10:26:15.670]   - Field: ‘workers’
[10:26:15.670]   - Field: ‘packages’
[10:26:15.670]   - Field: ‘gc’
[10:26:15.670]   - Field: ‘conditions’
[10:26:15.670]   - Field: ‘persistent’
[10:26:15.670]   - Field: ‘expr’
[10:26:15.670]   - Field: ‘uuid’
[10:26:15.670]   - Field: ‘seed’
[10:26:15.671]   - Field: ‘version’
[10:26:15.671]   - Field: ‘result’
[10:26:15.671]   - Field: ‘asynchronous’
[10:26:15.671]   - Field: ‘calls’
[10:26:15.671]   - Field: ‘globals’
[10:26:15.671]   - Field: ‘stdout’
[10:26:15.671]   - Field: ‘earlySignal’
[10:26:15.671]   - Field: ‘lazy’
[10:26:15.671]   - Field: ‘state’
[10:26:15.671] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:15.671] - Launch lazy future ...
[10:26:15.672] Packages needed by the future expression (n = 1): ‘future’
[10:26:15.672] Packages needed by future strategies (n = 0): <none>
[10:26:15.672] {
[10:26:15.672]     {
[10:26:15.672]         {
[10:26:15.672]             ...future.startTime <- base::Sys.time()
[10:26:15.672]             {
[10:26:15.672]                 {
[10:26:15.672]                   {
[10:26:15.672]                     {
[10:26:15.672]                       {
[10:26:15.672]                         base::local({
[10:26:15.672]                           has_future <- base::requireNamespace("future", 
[10:26:15.672]                             quietly = TRUE)
[10:26:15.672]                           if (has_future) {
[10:26:15.672]                             ns <- base::getNamespace("future")
[10:26:15.672]                             version <- ns[[".package"]][["version"]]
[10:26:15.672]                             if (is.null(version)) 
[10:26:15.672]                               version <- utils::packageVersion("future")
[10:26:15.672]                           }
[10:26:15.672]                           else {
[10:26:15.672]                             version <- NULL
[10:26:15.672]                           }
[10:26:15.672]                           if (!has_future || version < "1.8.0") {
[10:26:15.672]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:15.672]                               "", base::R.version$version.string), 
[10:26:15.672]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:15.672]                                 base::R.version$platform, 8 * 
[10:26:15.672]                                   base::.Machine$sizeof.pointer), 
[10:26:15.672]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:15.672]                                 "release", "version")], collapse = " "), 
[10:26:15.672]                               hostname = base::Sys.info()[["nodename"]])
[10:26:15.672]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:15.672]                               info)
[10:26:15.672]                             info <- base::paste(info, collapse = "; ")
[10:26:15.672]                             if (!has_future) {
[10:26:15.672]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:15.672]                                 info)
[10:26:15.672]                             }
[10:26:15.672]                             else {
[10:26:15.672]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:15.672]                                 info, version)
[10:26:15.672]                             }
[10:26:15.672]                             base::stop(msg)
[10:26:15.672]                           }
[10:26:15.672]                         })
[10:26:15.672]                       }
[10:26:15.672]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:15.672]                       base::options(mc.cores = 1L)
[10:26:15.672]                     }
[10:26:15.672]                     base::local({
[10:26:15.672]                       for (pkg in "future") {
[10:26:15.672]                         base::loadNamespace(pkg)
[10:26:15.672]                         base::library(pkg, character.only = TRUE)
[10:26:15.672]                       }
[10:26:15.672]                     })
[10:26:15.672]                   }
[10:26:15.672]                   options(future.plan = NULL)
[10:26:15.672]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.672]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:15.672]                 }
[10:26:15.672]                 ...future.workdir <- getwd()
[10:26:15.672]             }
[10:26:15.672]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:15.672]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:15.672]         }
[10:26:15.672]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:15.672]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:15.672]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:15.672]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:15.672]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:15.672]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:15.672]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:15.672]             base::names(...future.oldOptions))
[10:26:15.672]     }
[10:26:15.672]     if (FALSE) {
[10:26:15.672]     }
[10:26:15.672]     else {
[10:26:15.672]         if (TRUE) {
[10:26:15.672]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:15.672]                 open = "w")
[10:26:15.672]         }
[10:26:15.672]         else {
[10:26:15.672]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:15.672]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:15.672]         }
[10:26:15.672]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:15.672]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:15.672]             base::sink(type = "output", split = FALSE)
[10:26:15.672]             base::close(...future.stdout)
[10:26:15.672]         }, add = TRUE)
[10:26:15.672]     }
[10:26:15.672]     ...future.frame <- base::sys.nframe()
[10:26:15.672]     ...future.conditions <- base::list()
[10:26:15.672]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:15.672]     if (FALSE) {
[10:26:15.672]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:15.672]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:15.672]     }
[10:26:15.672]     ...future.result <- base::tryCatch({
[10:26:15.672]         base::withCallingHandlers({
[10:26:15.672]             ...future.value <- base::withVisible(base::local({
[10:26:15.672]                 ...future.makeSendCondition <- base::local({
[10:26:15.672]                   sendCondition <- NULL
[10:26:15.672]                   function(frame = 1L) {
[10:26:15.672]                     if (is.function(sendCondition)) 
[10:26:15.672]                       return(sendCondition)
[10:26:15.672]                     ns <- getNamespace("parallel")
[10:26:15.672]                     if (exists("sendData", mode = "function", 
[10:26:15.672]                       envir = ns)) {
[10:26:15.672]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:15.672]                         envir = ns)
[10:26:15.672]                       envir <- sys.frame(frame)
[10:26:15.672]                       master <- NULL
[10:26:15.672]                       while (!identical(envir, .GlobalEnv) && 
[10:26:15.672]                         !identical(envir, emptyenv())) {
[10:26:15.672]                         if (exists("master", mode = "list", envir = envir, 
[10:26:15.672]                           inherits = FALSE)) {
[10:26:15.672]                           master <- get("master", mode = "list", 
[10:26:15.672]                             envir = envir, inherits = FALSE)
[10:26:15.672]                           if (inherits(master, c("SOCKnode", 
[10:26:15.672]                             "SOCK0node"))) {
[10:26:15.672]                             sendCondition <<- function(cond) {
[10:26:15.672]                               data <- list(type = "VALUE", value = cond, 
[10:26:15.672]                                 success = TRUE)
[10:26:15.672]                               parallel_sendData(master, data)
[10:26:15.672]                             }
[10:26:15.672]                             return(sendCondition)
[10:26:15.672]                           }
[10:26:15.672]                         }
[10:26:15.672]                         frame <- frame + 1L
[10:26:15.672]                         envir <- sys.frame(frame)
[10:26:15.672]                       }
[10:26:15.672]                     }
[10:26:15.672]                     sendCondition <<- function(cond) NULL
[10:26:15.672]                   }
[10:26:15.672]                 })
[10:26:15.672]                 withCallingHandlers({
[10:26:15.672]                   value(a) + 1
[10:26:15.672]                 }, immediateCondition = function(cond) {
[10:26:15.672]                   sendCondition <- ...future.makeSendCondition()
[10:26:15.672]                   sendCondition(cond)
[10:26:15.672]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.672]                   {
[10:26:15.672]                     inherits <- base::inherits
[10:26:15.672]                     invokeRestart <- base::invokeRestart
[10:26:15.672]                     is.null <- base::is.null
[10:26:15.672]                     muffled <- FALSE
[10:26:15.672]                     if (inherits(cond, "message")) {
[10:26:15.672]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:15.672]                       if (muffled) 
[10:26:15.672]                         invokeRestart("muffleMessage")
[10:26:15.672]                     }
[10:26:15.672]                     else if (inherits(cond, "warning")) {
[10:26:15.672]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:15.672]                       if (muffled) 
[10:26:15.672]                         invokeRestart("muffleWarning")
[10:26:15.672]                     }
[10:26:15.672]                     else if (inherits(cond, "condition")) {
[10:26:15.672]                       if (!is.null(pattern)) {
[10:26:15.672]                         computeRestarts <- base::computeRestarts
[10:26:15.672]                         grepl <- base::grepl
[10:26:15.672]                         restarts <- computeRestarts(cond)
[10:26:15.672]                         for (restart in restarts) {
[10:26:15.672]                           name <- restart$name
[10:26:15.672]                           if (is.null(name)) 
[10:26:15.672]                             next
[10:26:15.672]                           if (!grepl(pattern, name)) 
[10:26:15.672]                             next
[10:26:15.672]                           invokeRestart(restart)
[10:26:15.672]                           muffled <- TRUE
[10:26:15.672]                           break
[10:26:15.672]                         }
[10:26:15.672]                       }
[10:26:15.672]                     }
[10:26:15.672]                     invisible(muffled)
[10:26:15.672]                   }
[10:26:15.672]                   muffleCondition(cond)
[10:26:15.672]                 })
[10:26:15.672]             }))
[10:26:15.672]             future::FutureResult(value = ...future.value$value, 
[10:26:15.672]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.672]                   ...future.rng), globalenv = if (FALSE) 
[10:26:15.672]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:15.672]                     ...future.globalenv.names))
[10:26:15.672]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:15.672]         }, condition = base::local({
[10:26:15.672]             c <- base::c
[10:26:15.672]             inherits <- base::inherits
[10:26:15.672]             invokeRestart <- base::invokeRestart
[10:26:15.672]             length <- base::length
[10:26:15.672]             list <- base::list
[10:26:15.672]             seq.int <- base::seq.int
[10:26:15.672]             signalCondition <- base::signalCondition
[10:26:15.672]             sys.calls <- base::sys.calls
[10:26:15.672]             `[[` <- base::`[[`
[10:26:15.672]             `+` <- base::`+`
[10:26:15.672]             `<<-` <- base::`<<-`
[10:26:15.672]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:15.672]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:15.672]                   3L)]
[10:26:15.672]             }
[10:26:15.672]             function(cond) {
[10:26:15.672]                 is_error <- inherits(cond, "error")
[10:26:15.672]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:15.672]                   NULL)
[10:26:15.672]                 if (is_error) {
[10:26:15.672]                   sessionInformation <- function() {
[10:26:15.672]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:15.672]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:15.672]                       search = base::search(), system = base::Sys.info())
[10:26:15.672]                   }
[10:26:15.672]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.672]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:15.672]                     cond$call), session = sessionInformation(), 
[10:26:15.672]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:15.672]                   signalCondition(cond)
[10:26:15.672]                 }
[10:26:15.672]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:15.672]                 "immediateCondition"))) {
[10:26:15.672]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:15.672]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.672]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:15.672]                   if (TRUE && !signal) {
[10:26:15.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.672]                     {
[10:26:15.672]                       inherits <- base::inherits
[10:26:15.672]                       invokeRestart <- base::invokeRestart
[10:26:15.672]                       is.null <- base::is.null
[10:26:15.672]                       muffled <- FALSE
[10:26:15.672]                       if (inherits(cond, "message")) {
[10:26:15.672]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.672]                         if (muffled) 
[10:26:15.672]                           invokeRestart("muffleMessage")
[10:26:15.672]                       }
[10:26:15.672]                       else if (inherits(cond, "warning")) {
[10:26:15.672]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.672]                         if (muffled) 
[10:26:15.672]                           invokeRestart("muffleWarning")
[10:26:15.672]                       }
[10:26:15.672]                       else if (inherits(cond, "condition")) {
[10:26:15.672]                         if (!is.null(pattern)) {
[10:26:15.672]                           computeRestarts <- base::computeRestarts
[10:26:15.672]                           grepl <- base::grepl
[10:26:15.672]                           restarts <- computeRestarts(cond)
[10:26:15.672]                           for (restart in restarts) {
[10:26:15.672]                             name <- restart$name
[10:26:15.672]                             if (is.null(name)) 
[10:26:15.672]                               next
[10:26:15.672]                             if (!grepl(pattern, name)) 
[10:26:15.672]                               next
[10:26:15.672]                             invokeRestart(restart)
[10:26:15.672]                             muffled <- TRUE
[10:26:15.672]                             break
[10:26:15.672]                           }
[10:26:15.672]                         }
[10:26:15.672]                       }
[10:26:15.672]                       invisible(muffled)
[10:26:15.672]                     }
[10:26:15.672]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.672]                   }
[10:26:15.672]                 }
[10:26:15.672]                 else {
[10:26:15.672]                   if (TRUE) {
[10:26:15.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.672]                     {
[10:26:15.672]                       inherits <- base::inherits
[10:26:15.672]                       invokeRestart <- base::invokeRestart
[10:26:15.672]                       is.null <- base::is.null
[10:26:15.672]                       muffled <- FALSE
[10:26:15.672]                       if (inherits(cond, "message")) {
[10:26:15.672]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.672]                         if (muffled) 
[10:26:15.672]                           invokeRestart("muffleMessage")
[10:26:15.672]                       }
[10:26:15.672]                       else if (inherits(cond, "warning")) {
[10:26:15.672]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.672]                         if (muffled) 
[10:26:15.672]                           invokeRestart("muffleWarning")
[10:26:15.672]                       }
[10:26:15.672]                       else if (inherits(cond, "condition")) {
[10:26:15.672]                         if (!is.null(pattern)) {
[10:26:15.672]                           computeRestarts <- base::computeRestarts
[10:26:15.672]                           grepl <- base::grepl
[10:26:15.672]                           restarts <- computeRestarts(cond)
[10:26:15.672]                           for (restart in restarts) {
[10:26:15.672]                             name <- restart$name
[10:26:15.672]                             if (is.null(name)) 
[10:26:15.672]                               next
[10:26:15.672]                             if (!grepl(pattern, name)) 
[10:26:15.672]                               next
[10:26:15.672]                             invokeRestart(restart)
[10:26:15.672]                             muffled <- TRUE
[10:26:15.672]                             break
[10:26:15.672]                           }
[10:26:15.672]                         }
[10:26:15.672]                       }
[10:26:15.672]                       invisible(muffled)
[10:26:15.672]                     }
[10:26:15.672]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.672]                   }
[10:26:15.672]                 }
[10:26:15.672]             }
[10:26:15.672]         }))
[10:26:15.672]     }, error = function(ex) {
[10:26:15.672]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:15.672]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.672]                 ...future.rng), started = ...future.startTime, 
[10:26:15.672]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:15.672]             version = "1.8"), class = "FutureResult")
[10:26:15.672]     }, finally = {
[10:26:15.672]         if (!identical(...future.workdir, getwd())) 
[10:26:15.672]             setwd(...future.workdir)
[10:26:15.672]         {
[10:26:15.672]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:15.672]                 ...future.oldOptions$nwarnings <- NULL
[10:26:15.672]             }
[10:26:15.672]             base::options(...future.oldOptions)
[10:26:15.672]             if (.Platform$OS.type == "windows") {
[10:26:15.672]                 old_names <- names(...future.oldEnvVars)
[10:26:15.672]                 envs <- base::Sys.getenv()
[10:26:15.672]                 names <- names(envs)
[10:26:15.672]                 common <- intersect(names, old_names)
[10:26:15.672]                 added <- setdiff(names, old_names)
[10:26:15.672]                 removed <- setdiff(old_names, names)
[10:26:15.672]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:15.672]                   envs[common]]
[10:26:15.672]                 NAMES <- toupper(changed)
[10:26:15.672]                 args <- list()
[10:26:15.672]                 for (kk in seq_along(NAMES)) {
[10:26:15.672]                   name <- changed[[kk]]
[10:26:15.672]                   NAME <- NAMES[[kk]]
[10:26:15.672]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.672]                     next
[10:26:15.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.672]                 }
[10:26:15.672]                 NAMES <- toupper(added)
[10:26:15.672]                 for (kk in seq_along(NAMES)) {
[10:26:15.672]                   name <- added[[kk]]
[10:26:15.672]                   NAME <- NAMES[[kk]]
[10:26:15.672]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.672]                     next
[10:26:15.672]                   args[[name]] <- ""
[10:26:15.672]                 }
[10:26:15.672]                 NAMES <- toupper(removed)
[10:26:15.672]                 for (kk in seq_along(NAMES)) {
[10:26:15.672]                   name <- removed[[kk]]
[10:26:15.672]                   NAME <- NAMES[[kk]]
[10:26:15.672]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.672]                     next
[10:26:15.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.672]                 }
[10:26:15.672]                 if (length(args) > 0) 
[10:26:15.672]                   base::do.call(base::Sys.setenv, args = args)
[10:26:15.672]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:15.672]             }
[10:26:15.672]             else {
[10:26:15.672]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:15.672]             }
[10:26:15.672]             {
[10:26:15.672]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:15.672]                   0L) {
[10:26:15.672]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:15.672]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:15.672]                   base::options(opts)
[10:26:15.672]                 }
[10:26:15.672]                 {
[10:26:15.672]                   {
[10:26:15.672]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:15.672]                     NULL
[10:26:15.672]                   }
[10:26:15.672]                   options(future.plan = NULL)
[10:26:15.672]                   if (is.na(NA_character_)) 
[10:26:15.672]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.672]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:15.672]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:15.672]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:15.672]                     envir = parent.frame()) 
[10:26:15.672]                   {
[10:26:15.672]                     if (is.function(workers)) 
[10:26:15.672]                       workers <- workers()
[10:26:15.672]                     workers <- structure(as.integer(workers), 
[10:26:15.672]                       class = class(workers))
[10:26:15.672]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:15.672]                       workers >= 1)
[10:26:15.672]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:15.672]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:15.672]                     }
[10:26:15.672]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:15.672]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:15.672]                       envir = envir)
[10:26:15.672]                     if (!future$lazy) 
[10:26:15.672]                       future <- run(future)
[10:26:15.672]                     invisible(future)
[10:26:15.672]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:15.672]                 }
[10:26:15.672]             }
[10:26:15.672]         }
[10:26:15.672]     })
[10:26:15.672]     if (TRUE) {
[10:26:15.672]         base::sink(type = "output", split = FALSE)
[10:26:15.672]         if (TRUE) {
[10:26:15.672]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:15.672]         }
[10:26:15.672]         else {
[10:26:15.672]             ...future.result["stdout"] <- base::list(NULL)
[10:26:15.672]         }
[10:26:15.672]         base::close(...future.stdout)
[10:26:15.672]         ...future.stdout <- NULL
[10:26:15.672]     }
[10:26:15.672]     ...future.result$conditions <- ...future.conditions
[10:26:15.672]     ...future.result$finished <- base::Sys.time()
[10:26:15.672]     ...future.result
[10:26:15.672] }
[10:26:15.675] Exporting 1 global objects (1.56 MiB) to cluster node #1 ...
[10:26:15.677] Exporting ‘a’ (1.56 MiB) to cluster node #1 ...
[10:26:15.730] Exporting ‘a’ (1.56 MiB) to cluster node #1 ... DONE
[10:26:15.730] Exporting 1 global objects (1.56 MiB) to cluster node #1 ... DONE
[10:26:15.731] MultisessionFuture started
[10:26:15.731] - Launch lazy future ... done
[10:26:15.731] run() for ‘MultisessionFuture’ ... done
[10:26:15.731] result() for ClusterFuture ...
[10:26:15.731] receiveMessageFromWorker() for ClusterFuture ...
[10:26:15.731] - Validating connection of MultisessionFuture
[10:26:15.782] - received message: FutureResult
[10:26:15.783] - Received FutureResult
[10:26:15.783] - Erased future from FutureRegistry
[10:26:15.783] result() for ClusterFuture ...
[10:26:15.783] - result already collected: FutureResult
[10:26:15.783] result() for ClusterFuture ... done
[10:26:15.783] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:15.783] result() for ClusterFuture ... done
[10:26:15.783] result() for ClusterFuture ...
[10:26:15.784] - result already collected: FutureResult
[10:26:15.784] result() for ClusterFuture ... done
value(b) = 2
[10:26:15.784] result() for ClusterFuture ...
[10:26:15.784] - result already collected: FutureResult
[10:26:15.784] result() for ClusterFuture ... done
[10:26:15.784] result() for ClusterFuture ...
[10:26:15.784] - result already collected: FutureResult
[10:26:15.784] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:15.784] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:15.785] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:15.785] 
[10:26:15.785] Searching for globals ... DONE
[10:26:15.785] - globals: [0] <none>
[10:26:15.785] getGlobalsAndPackages() ... DONE
[10:26:15.786] run() for ‘Future’ ...
[10:26:15.786] - state: ‘created’
[10:26:15.786] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:15.800] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:15.800] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:15.800]   - Field: ‘node’
[10:26:15.800]   - Field: ‘label’
[10:26:15.800]   - Field: ‘local’
[10:26:15.800]   - Field: ‘owner’
[10:26:15.800]   - Field: ‘envir’
[10:26:15.801]   - Field: ‘workers’
[10:26:15.801]   - Field: ‘packages’
[10:26:15.801]   - Field: ‘gc’
[10:26:15.801]   - Field: ‘conditions’
[10:26:15.801]   - Field: ‘persistent’
[10:26:15.801]   - Field: ‘expr’
[10:26:15.801]   - Field: ‘uuid’
[10:26:15.801]   - Field: ‘seed’
[10:26:15.801]   - Field: ‘version’
[10:26:15.801]   - Field: ‘result’
[10:26:15.802]   - Field: ‘asynchronous’
[10:26:15.802]   - Field: ‘calls’
[10:26:15.802]   - Field: ‘globals’
[10:26:15.802]   - Field: ‘stdout’
[10:26:15.802]   - Field: ‘earlySignal’
[10:26:15.802]   - Field: ‘lazy’
[10:26:15.802]   - Field: ‘state’
[10:26:15.802] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:15.802] - Launch lazy future ...
[10:26:15.803] Packages needed by the future expression (n = 0): <none>
[10:26:15.803] Packages needed by future strategies (n = 0): <none>
[10:26:15.803] {
[10:26:15.803]     {
[10:26:15.803]         {
[10:26:15.803]             ...future.startTime <- base::Sys.time()
[10:26:15.803]             {
[10:26:15.803]                 {
[10:26:15.803]                   {
[10:26:15.803]                     {
[10:26:15.803]                       base::local({
[10:26:15.803]                         has_future <- base::requireNamespace("future", 
[10:26:15.803]                           quietly = TRUE)
[10:26:15.803]                         if (has_future) {
[10:26:15.803]                           ns <- base::getNamespace("future")
[10:26:15.803]                           version <- ns[[".package"]][["version"]]
[10:26:15.803]                           if (is.null(version)) 
[10:26:15.803]                             version <- utils::packageVersion("future")
[10:26:15.803]                         }
[10:26:15.803]                         else {
[10:26:15.803]                           version <- NULL
[10:26:15.803]                         }
[10:26:15.803]                         if (!has_future || version < "1.8.0") {
[10:26:15.803]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:15.803]                             "", base::R.version$version.string), 
[10:26:15.803]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:15.803]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:15.803]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:15.803]                               "release", "version")], collapse = " "), 
[10:26:15.803]                             hostname = base::Sys.info()[["nodename"]])
[10:26:15.803]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:15.803]                             info)
[10:26:15.803]                           info <- base::paste(info, collapse = "; ")
[10:26:15.803]                           if (!has_future) {
[10:26:15.803]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:15.803]                               info)
[10:26:15.803]                           }
[10:26:15.803]                           else {
[10:26:15.803]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:15.803]                               info, version)
[10:26:15.803]                           }
[10:26:15.803]                           base::stop(msg)
[10:26:15.803]                         }
[10:26:15.803]                       })
[10:26:15.803]                     }
[10:26:15.803]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:15.803]                     base::options(mc.cores = 1L)
[10:26:15.803]                   }
[10:26:15.803]                   options(future.plan = NULL)
[10:26:15.803]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.803]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:15.803]                 }
[10:26:15.803]                 ...future.workdir <- getwd()
[10:26:15.803]             }
[10:26:15.803]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:15.803]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:15.803]         }
[10:26:15.803]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:15.803]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:15.803]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:15.803]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:15.803]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:15.803]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:15.803]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:15.803]             base::names(...future.oldOptions))
[10:26:15.803]     }
[10:26:15.803]     if (FALSE) {
[10:26:15.803]     }
[10:26:15.803]     else {
[10:26:15.803]         if (TRUE) {
[10:26:15.803]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:15.803]                 open = "w")
[10:26:15.803]         }
[10:26:15.803]         else {
[10:26:15.803]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:15.803]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:15.803]         }
[10:26:15.803]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:15.803]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:15.803]             base::sink(type = "output", split = FALSE)
[10:26:15.803]             base::close(...future.stdout)
[10:26:15.803]         }, add = TRUE)
[10:26:15.803]     }
[10:26:15.803]     ...future.frame <- base::sys.nframe()
[10:26:15.803]     ...future.conditions <- base::list()
[10:26:15.803]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:15.803]     if (FALSE) {
[10:26:15.803]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:15.803]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:15.803]     }
[10:26:15.803]     ...future.result <- base::tryCatch({
[10:26:15.803]         base::withCallingHandlers({
[10:26:15.803]             ...future.value <- base::withVisible(base::local({
[10:26:15.803]                 ...future.makeSendCondition <- base::local({
[10:26:15.803]                   sendCondition <- NULL
[10:26:15.803]                   function(frame = 1L) {
[10:26:15.803]                     if (is.function(sendCondition)) 
[10:26:15.803]                       return(sendCondition)
[10:26:15.803]                     ns <- getNamespace("parallel")
[10:26:15.803]                     if (exists("sendData", mode = "function", 
[10:26:15.803]                       envir = ns)) {
[10:26:15.803]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:15.803]                         envir = ns)
[10:26:15.803]                       envir <- sys.frame(frame)
[10:26:15.803]                       master <- NULL
[10:26:15.803]                       while (!identical(envir, .GlobalEnv) && 
[10:26:15.803]                         !identical(envir, emptyenv())) {
[10:26:15.803]                         if (exists("master", mode = "list", envir = envir, 
[10:26:15.803]                           inherits = FALSE)) {
[10:26:15.803]                           master <- get("master", mode = "list", 
[10:26:15.803]                             envir = envir, inherits = FALSE)
[10:26:15.803]                           if (inherits(master, c("SOCKnode", 
[10:26:15.803]                             "SOCK0node"))) {
[10:26:15.803]                             sendCondition <<- function(cond) {
[10:26:15.803]                               data <- list(type = "VALUE", value = cond, 
[10:26:15.803]                                 success = TRUE)
[10:26:15.803]                               parallel_sendData(master, data)
[10:26:15.803]                             }
[10:26:15.803]                             return(sendCondition)
[10:26:15.803]                           }
[10:26:15.803]                         }
[10:26:15.803]                         frame <- frame + 1L
[10:26:15.803]                         envir <- sys.frame(frame)
[10:26:15.803]                       }
[10:26:15.803]                     }
[10:26:15.803]                     sendCondition <<- function(cond) NULL
[10:26:15.803]                   }
[10:26:15.803]                 })
[10:26:15.803]                 withCallingHandlers({
[10:26:15.803]                   1
[10:26:15.803]                 }, immediateCondition = function(cond) {
[10:26:15.803]                   sendCondition <- ...future.makeSendCondition()
[10:26:15.803]                   sendCondition(cond)
[10:26:15.803]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.803]                   {
[10:26:15.803]                     inherits <- base::inherits
[10:26:15.803]                     invokeRestart <- base::invokeRestart
[10:26:15.803]                     is.null <- base::is.null
[10:26:15.803]                     muffled <- FALSE
[10:26:15.803]                     if (inherits(cond, "message")) {
[10:26:15.803]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:15.803]                       if (muffled) 
[10:26:15.803]                         invokeRestart("muffleMessage")
[10:26:15.803]                     }
[10:26:15.803]                     else if (inherits(cond, "warning")) {
[10:26:15.803]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:15.803]                       if (muffled) 
[10:26:15.803]                         invokeRestart("muffleWarning")
[10:26:15.803]                     }
[10:26:15.803]                     else if (inherits(cond, "condition")) {
[10:26:15.803]                       if (!is.null(pattern)) {
[10:26:15.803]                         computeRestarts <- base::computeRestarts
[10:26:15.803]                         grepl <- base::grepl
[10:26:15.803]                         restarts <- computeRestarts(cond)
[10:26:15.803]                         for (restart in restarts) {
[10:26:15.803]                           name <- restart$name
[10:26:15.803]                           if (is.null(name)) 
[10:26:15.803]                             next
[10:26:15.803]                           if (!grepl(pattern, name)) 
[10:26:15.803]                             next
[10:26:15.803]                           invokeRestart(restart)
[10:26:15.803]                           muffled <- TRUE
[10:26:15.803]                           break
[10:26:15.803]                         }
[10:26:15.803]                       }
[10:26:15.803]                     }
[10:26:15.803]                     invisible(muffled)
[10:26:15.803]                   }
[10:26:15.803]                   muffleCondition(cond)
[10:26:15.803]                 })
[10:26:15.803]             }))
[10:26:15.803]             future::FutureResult(value = ...future.value$value, 
[10:26:15.803]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.803]                   ...future.rng), globalenv = if (FALSE) 
[10:26:15.803]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:15.803]                     ...future.globalenv.names))
[10:26:15.803]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:15.803]         }, condition = base::local({
[10:26:15.803]             c <- base::c
[10:26:15.803]             inherits <- base::inherits
[10:26:15.803]             invokeRestart <- base::invokeRestart
[10:26:15.803]             length <- base::length
[10:26:15.803]             list <- base::list
[10:26:15.803]             seq.int <- base::seq.int
[10:26:15.803]             signalCondition <- base::signalCondition
[10:26:15.803]             sys.calls <- base::sys.calls
[10:26:15.803]             `[[` <- base::`[[`
[10:26:15.803]             `+` <- base::`+`
[10:26:15.803]             `<<-` <- base::`<<-`
[10:26:15.803]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:15.803]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:15.803]                   3L)]
[10:26:15.803]             }
[10:26:15.803]             function(cond) {
[10:26:15.803]                 is_error <- inherits(cond, "error")
[10:26:15.803]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:15.803]                   NULL)
[10:26:15.803]                 if (is_error) {
[10:26:15.803]                   sessionInformation <- function() {
[10:26:15.803]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:15.803]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:15.803]                       search = base::search(), system = base::Sys.info())
[10:26:15.803]                   }
[10:26:15.803]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.803]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:15.803]                     cond$call), session = sessionInformation(), 
[10:26:15.803]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:15.803]                   signalCondition(cond)
[10:26:15.803]                 }
[10:26:15.803]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:15.803]                 "immediateCondition"))) {
[10:26:15.803]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:15.803]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.803]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:15.803]                   if (TRUE && !signal) {
[10:26:15.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.803]                     {
[10:26:15.803]                       inherits <- base::inherits
[10:26:15.803]                       invokeRestart <- base::invokeRestart
[10:26:15.803]                       is.null <- base::is.null
[10:26:15.803]                       muffled <- FALSE
[10:26:15.803]                       if (inherits(cond, "message")) {
[10:26:15.803]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.803]                         if (muffled) 
[10:26:15.803]                           invokeRestart("muffleMessage")
[10:26:15.803]                       }
[10:26:15.803]                       else if (inherits(cond, "warning")) {
[10:26:15.803]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.803]                         if (muffled) 
[10:26:15.803]                           invokeRestart("muffleWarning")
[10:26:15.803]                       }
[10:26:15.803]                       else if (inherits(cond, "condition")) {
[10:26:15.803]                         if (!is.null(pattern)) {
[10:26:15.803]                           computeRestarts <- base::computeRestarts
[10:26:15.803]                           grepl <- base::grepl
[10:26:15.803]                           restarts <- computeRestarts(cond)
[10:26:15.803]                           for (restart in restarts) {
[10:26:15.803]                             name <- restart$name
[10:26:15.803]                             if (is.null(name)) 
[10:26:15.803]                               next
[10:26:15.803]                             if (!grepl(pattern, name)) 
[10:26:15.803]                               next
[10:26:15.803]                             invokeRestart(restart)
[10:26:15.803]                             muffled <- TRUE
[10:26:15.803]                             break
[10:26:15.803]                           }
[10:26:15.803]                         }
[10:26:15.803]                       }
[10:26:15.803]                       invisible(muffled)
[10:26:15.803]                     }
[10:26:15.803]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.803]                   }
[10:26:15.803]                 }
[10:26:15.803]                 else {
[10:26:15.803]                   if (TRUE) {
[10:26:15.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.803]                     {
[10:26:15.803]                       inherits <- base::inherits
[10:26:15.803]                       invokeRestart <- base::invokeRestart
[10:26:15.803]                       is.null <- base::is.null
[10:26:15.803]                       muffled <- FALSE
[10:26:15.803]                       if (inherits(cond, "message")) {
[10:26:15.803]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.803]                         if (muffled) 
[10:26:15.803]                           invokeRestart("muffleMessage")
[10:26:15.803]                       }
[10:26:15.803]                       else if (inherits(cond, "warning")) {
[10:26:15.803]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.803]                         if (muffled) 
[10:26:15.803]                           invokeRestart("muffleWarning")
[10:26:15.803]                       }
[10:26:15.803]                       else if (inherits(cond, "condition")) {
[10:26:15.803]                         if (!is.null(pattern)) {
[10:26:15.803]                           computeRestarts <- base::computeRestarts
[10:26:15.803]                           grepl <- base::grepl
[10:26:15.803]                           restarts <- computeRestarts(cond)
[10:26:15.803]                           for (restart in restarts) {
[10:26:15.803]                             name <- restart$name
[10:26:15.803]                             if (is.null(name)) 
[10:26:15.803]                               next
[10:26:15.803]                             if (!grepl(pattern, name)) 
[10:26:15.803]                               next
[10:26:15.803]                             invokeRestart(restart)
[10:26:15.803]                             muffled <- TRUE
[10:26:15.803]                             break
[10:26:15.803]                           }
[10:26:15.803]                         }
[10:26:15.803]                       }
[10:26:15.803]                       invisible(muffled)
[10:26:15.803]                     }
[10:26:15.803]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.803]                   }
[10:26:15.803]                 }
[10:26:15.803]             }
[10:26:15.803]         }))
[10:26:15.803]     }, error = function(ex) {
[10:26:15.803]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:15.803]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.803]                 ...future.rng), started = ...future.startTime, 
[10:26:15.803]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:15.803]             version = "1.8"), class = "FutureResult")
[10:26:15.803]     }, finally = {
[10:26:15.803]         if (!identical(...future.workdir, getwd())) 
[10:26:15.803]             setwd(...future.workdir)
[10:26:15.803]         {
[10:26:15.803]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:15.803]                 ...future.oldOptions$nwarnings <- NULL
[10:26:15.803]             }
[10:26:15.803]             base::options(...future.oldOptions)
[10:26:15.803]             if (.Platform$OS.type == "windows") {
[10:26:15.803]                 old_names <- names(...future.oldEnvVars)
[10:26:15.803]                 envs <- base::Sys.getenv()
[10:26:15.803]                 names <- names(envs)
[10:26:15.803]                 common <- intersect(names, old_names)
[10:26:15.803]                 added <- setdiff(names, old_names)
[10:26:15.803]                 removed <- setdiff(old_names, names)
[10:26:15.803]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:15.803]                   envs[common]]
[10:26:15.803]                 NAMES <- toupper(changed)
[10:26:15.803]                 args <- list()
[10:26:15.803]                 for (kk in seq_along(NAMES)) {
[10:26:15.803]                   name <- changed[[kk]]
[10:26:15.803]                   NAME <- NAMES[[kk]]
[10:26:15.803]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.803]                     next
[10:26:15.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.803]                 }
[10:26:15.803]                 NAMES <- toupper(added)
[10:26:15.803]                 for (kk in seq_along(NAMES)) {
[10:26:15.803]                   name <- added[[kk]]
[10:26:15.803]                   NAME <- NAMES[[kk]]
[10:26:15.803]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.803]                     next
[10:26:15.803]                   args[[name]] <- ""
[10:26:15.803]                 }
[10:26:15.803]                 NAMES <- toupper(removed)
[10:26:15.803]                 for (kk in seq_along(NAMES)) {
[10:26:15.803]                   name <- removed[[kk]]
[10:26:15.803]                   NAME <- NAMES[[kk]]
[10:26:15.803]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.803]                     next
[10:26:15.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.803]                 }
[10:26:15.803]                 if (length(args) > 0) 
[10:26:15.803]                   base::do.call(base::Sys.setenv, args = args)
[10:26:15.803]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:15.803]             }
[10:26:15.803]             else {
[10:26:15.803]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:15.803]             }
[10:26:15.803]             {
[10:26:15.803]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:15.803]                   0L) {
[10:26:15.803]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:15.803]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:15.803]                   base::options(opts)
[10:26:15.803]                 }
[10:26:15.803]                 {
[10:26:15.803]                   {
[10:26:15.803]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:15.803]                     NULL
[10:26:15.803]                   }
[10:26:15.803]                   options(future.plan = NULL)
[10:26:15.803]                   if (is.na(NA_character_)) 
[10:26:15.803]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.803]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:15.803]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:15.803]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:15.803]                     envir = parent.frame()) 
[10:26:15.803]                   {
[10:26:15.803]                     if (is.function(workers)) 
[10:26:15.803]                       workers <- workers()
[10:26:15.803]                     workers <- structure(as.integer(workers), 
[10:26:15.803]                       class = class(workers))
[10:26:15.803]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:15.803]                       workers >= 1)
[10:26:15.803]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:15.803]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:15.803]                     }
[10:26:15.803]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:15.803]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:15.803]                       envir = envir)
[10:26:15.803]                     if (!future$lazy) 
[10:26:15.803]                       future <- run(future)
[10:26:15.803]                     invisible(future)
[10:26:15.803]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:15.803]                 }
[10:26:15.803]             }
[10:26:15.803]         }
[10:26:15.803]     })
[10:26:15.803]     if (TRUE) {
[10:26:15.803]         base::sink(type = "output", split = FALSE)
[10:26:15.803]         if (TRUE) {
[10:26:15.803]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:15.803]         }
[10:26:15.803]         else {
[10:26:15.803]             ...future.result["stdout"] <- base::list(NULL)
[10:26:15.803]         }
[10:26:15.803]         base::close(...future.stdout)
[10:26:15.803]         ...future.stdout <- NULL
[10:26:15.803]     }
[10:26:15.803]     ...future.result$conditions <- ...future.conditions
[10:26:15.803]     ...future.result$finished <- base::Sys.time()
[10:26:15.803]     ...future.result
[10:26:15.803] }
[10:26:15.806] MultisessionFuture started
[10:26:15.806] - Launch lazy future ... done
[10:26:15.806] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:15.807] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:15.807] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:15.808] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:15.808] Searching for globals ... DONE
[10:26:15.808] Resolving globals: TRUE
[10:26:15.808] Resolving any globals that are futures ...
[10:26:15.808] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:15.808] Resolving any globals that are futures ... DONE
[10:26:15.809] Resolving futures part of globals (recursively) ...
[10:26:15.809] resolve() on list ...
[10:26:15.809]  recursive: 99
[10:26:15.809]  length: 1
[10:26:15.809]  elements: ‘a’
[10:26:15.854] receiveMessageFromWorker() for ClusterFuture ...
[10:26:15.854] - Validating connection of MultisessionFuture
[10:26:15.855] - received message: FutureResult
[10:26:15.855] - Received FutureResult
[10:26:15.855] - Erased future from FutureRegistry
[10:26:15.855] result() for ClusterFuture ...
[10:26:15.855] - result already collected: FutureResult
[10:26:15.855] result() for ClusterFuture ... done
[10:26:15.855] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:15.855] Future #1
[10:26:15.855] result() for ClusterFuture ...
[10:26:15.855] - result already collected: FutureResult
[10:26:15.856] result() for ClusterFuture ... done
[10:26:15.856] result() for ClusterFuture ...
[10:26:15.856] - result already collected: FutureResult
[10:26:15.856] result() for ClusterFuture ... done
[10:26:15.856] A MultisessionFuture was resolved
[10:26:15.856]  length: 0 (resolved future 1)
[10:26:15.856] resolve() on list ... DONE
[10:26:15.856] - globals: [1] ‘a’
[10:26:15.856] Resolving futures part of globals (recursively) ... DONE
[10:26:15.861] The total size of the 1 globals is 1.56 MiB (1640840 bytes)
[10:26:15.861] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.56 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.56 MiB of class ‘environment’)
[10:26:15.861] - globals: [1] ‘a’
[10:26:15.861] - packages: [1] ‘future’
[10:26:15.861] getGlobalsAndPackages() ... DONE
[10:26:15.862] run() for ‘Future’ ...
[10:26:15.862] - state: ‘created’
[10:26:15.862] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:15.876] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:15.876] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:15.876]   - Field: ‘node’
[10:26:15.876]   - Field: ‘label’
[10:26:15.876]   - Field: ‘local’
[10:26:15.876]   - Field: ‘owner’
[10:26:15.876]   - Field: ‘envir’
[10:26:15.877]   - Field: ‘workers’
[10:26:15.877]   - Field: ‘packages’
[10:26:15.877]   - Field: ‘gc’
[10:26:15.877]   - Field: ‘conditions’
[10:26:15.877]   - Field: ‘persistent’
[10:26:15.877]   - Field: ‘expr’
[10:26:15.877]   - Field: ‘uuid’
[10:26:15.877]   - Field: ‘seed’
[10:26:15.877]   - Field: ‘version’
[10:26:15.877]   - Field: ‘result’
[10:26:15.877]   - Field: ‘asynchronous’
[10:26:15.878]   - Field: ‘calls’
[10:26:15.878]   - Field: ‘globals’
[10:26:15.878]   - Field: ‘stdout’
[10:26:15.878]   - Field: ‘earlySignal’
[10:26:15.878]   - Field: ‘lazy’
[10:26:15.878]   - Field: ‘state’
[10:26:15.878] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:15.878] - Launch lazy future ...
[10:26:15.878] Packages needed by the future expression (n = 1): ‘future’
[10:26:15.879] Packages needed by future strategies (n = 0): <none>
[10:26:15.879] {
[10:26:15.879]     {
[10:26:15.879]         {
[10:26:15.879]             ...future.startTime <- base::Sys.time()
[10:26:15.879]             {
[10:26:15.879]                 {
[10:26:15.879]                   {
[10:26:15.879]                     {
[10:26:15.879]                       {
[10:26:15.879]                         base::local({
[10:26:15.879]                           has_future <- base::requireNamespace("future", 
[10:26:15.879]                             quietly = TRUE)
[10:26:15.879]                           if (has_future) {
[10:26:15.879]                             ns <- base::getNamespace("future")
[10:26:15.879]                             version <- ns[[".package"]][["version"]]
[10:26:15.879]                             if (is.null(version)) 
[10:26:15.879]                               version <- utils::packageVersion("future")
[10:26:15.879]                           }
[10:26:15.879]                           else {
[10:26:15.879]                             version <- NULL
[10:26:15.879]                           }
[10:26:15.879]                           if (!has_future || version < "1.8.0") {
[10:26:15.879]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:15.879]                               "", base::R.version$version.string), 
[10:26:15.879]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:15.879]                                 base::R.version$platform, 8 * 
[10:26:15.879]                                   base::.Machine$sizeof.pointer), 
[10:26:15.879]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:15.879]                                 "release", "version")], collapse = " "), 
[10:26:15.879]                               hostname = base::Sys.info()[["nodename"]])
[10:26:15.879]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:15.879]                               info)
[10:26:15.879]                             info <- base::paste(info, collapse = "; ")
[10:26:15.879]                             if (!has_future) {
[10:26:15.879]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:15.879]                                 info)
[10:26:15.879]                             }
[10:26:15.879]                             else {
[10:26:15.879]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:15.879]                                 info, version)
[10:26:15.879]                             }
[10:26:15.879]                             base::stop(msg)
[10:26:15.879]                           }
[10:26:15.879]                         })
[10:26:15.879]                       }
[10:26:15.879]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:15.879]                       base::options(mc.cores = 1L)
[10:26:15.879]                     }
[10:26:15.879]                     base::local({
[10:26:15.879]                       for (pkg in "future") {
[10:26:15.879]                         base::loadNamespace(pkg)
[10:26:15.879]                         base::library(pkg, character.only = TRUE)
[10:26:15.879]                       }
[10:26:15.879]                     })
[10:26:15.879]                   }
[10:26:15.879]                   options(future.plan = NULL)
[10:26:15.879]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.879]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:15.879]                 }
[10:26:15.879]                 ...future.workdir <- getwd()
[10:26:15.879]             }
[10:26:15.879]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:15.879]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:15.879]         }
[10:26:15.879]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:15.879]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:15.879]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:15.879]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:15.879]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:15.879]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:15.879]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:15.879]             base::names(...future.oldOptions))
[10:26:15.879]     }
[10:26:15.879]     if (FALSE) {
[10:26:15.879]     }
[10:26:15.879]     else {
[10:26:15.879]         if (TRUE) {
[10:26:15.879]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:15.879]                 open = "w")
[10:26:15.879]         }
[10:26:15.879]         else {
[10:26:15.879]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:15.879]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:15.879]         }
[10:26:15.879]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:15.879]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:15.879]             base::sink(type = "output", split = FALSE)
[10:26:15.879]             base::close(...future.stdout)
[10:26:15.879]         }, add = TRUE)
[10:26:15.879]     }
[10:26:15.879]     ...future.frame <- base::sys.nframe()
[10:26:15.879]     ...future.conditions <- base::list()
[10:26:15.879]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:15.879]     if (FALSE) {
[10:26:15.879]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:15.879]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:15.879]     }
[10:26:15.879]     ...future.result <- base::tryCatch({
[10:26:15.879]         base::withCallingHandlers({
[10:26:15.879]             ...future.value <- base::withVisible(base::local({
[10:26:15.879]                 ...future.makeSendCondition <- base::local({
[10:26:15.879]                   sendCondition <- NULL
[10:26:15.879]                   function(frame = 1L) {
[10:26:15.879]                     if (is.function(sendCondition)) 
[10:26:15.879]                       return(sendCondition)
[10:26:15.879]                     ns <- getNamespace("parallel")
[10:26:15.879]                     if (exists("sendData", mode = "function", 
[10:26:15.879]                       envir = ns)) {
[10:26:15.879]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:15.879]                         envir = ns)
[10:26:15.879]                       envir <- sys.frame(frame)
[10:26:15.879]                       master <- NULL
[10:26:15.879]                       while (!identical(envir, .GlobalEnv) && 
[10:26:15.879]                         !identical(envir, emptyenv())) {
[10:26:15.879]                         if (exists("master", mode = "list", envir = envir, 
[10:26:15.879]                           inherits = FALSE)) {
[10:26:15.879]                           master <- get("master", mode = "list", 
[10:26:15.879]                             envir = envir, inherits = FALSE)
[10:26:15.879]                           if (inherits(master, c("SOCKnode", 
[10:26:15.879]                             "SOCK0node"))) {
[10:26:15.879]                             sendCondition <<- function(cond) {
[10:26:15.879]                               data <- list(type = "VALUE", value = cond, 
[10:26:15.879]                                 success = TRUE)
[10:26:15.879]                               parallel_sendData(master, data)
[10:26:15.879]                             }
[10:26:15.879]                             return(sendCondition)
[10:26:15.879]                           }
[10:26:15.879]                         }
[10:26:15.879]                         frame <- frame + 1L
[10:26:15.879]                         envir <- sys.frame(frame)
[10:26:15.879]                       }
[10:26:15.879]                     }
[10:26:15.879]                     sendCondition <<- function(cond) NULL
[10:26:15.879]                   }
[10:26:15.879]                 })
[10:26:15.879]                 withCallingHandlers({
[10:26:15.879]                   value(a) + 1
[10:26:15.879]                 }, immediateCondition = function(cond) {
[10:26:15.879]                   sendCondition <- ...future.makeSendCondition()
[10:26:15.879]                   sendCondition(cond)
[10:26:15.879]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.879]                   {
[10:26:15.879]                     inherits <- base::inherits
[10:26:15.879]                     invokeRestart <- base::invokeRestart
[10:26:15.879]                     is.null <- base::is.null
[10:26:15.879]                     muffled <- FALSE
[10:26:15.879]                     if (inherits(cond, "message")) {
[10:26:15.879]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:15.879]                       if (muffled) 
[10:26:15.879]                         invokeRestart("muffleMessage")
[10:26:15.879]                     }
[10:26:15.879]                     else if (inherits(cond, "warning")) {
[10:26:15.879]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:15.879]                       if (muffled) 
[10:26:15.879]                         invokeRestart("muffleWarning")
[10:26:15.879]                     }
[10:26:15.879]                     else if (inherits(cond, "condition")) {
[10:26:15.879]                       if (!is.null(pattern)) {
[10:26:15.879]                         computeRestarts <- base::computeRestarts
[10:26:15.879]                         grepl <- base::grepl
[10:26:15.879]                         restarts <- computeRestarts(cond)
[10:26:15.879]                         for (restart in restarts) {
[10:26:15.879]                           name <- restart$name
[10:26:15.879]                           if (is.null(name)) 
[10:26:15.879]                             next
[10:26:15.879]                           if (!grepl(pattern, name)) 
[10:26:15.879]                             next
[10:26:15.879]                           invokeRestart(restart)
[10:26:15.879]                           muffled <- TRUE
[10:26:15.879]                           break
[10:26:15.879]                         }
[10:26:15.879]                       }
[10:26:15.879]                     }
[10:26:15.879]                     invisible(muffled)
[10:26:15.879]                   }
[10:26:15.879]                   muffleCondition(cond)
[10:26:15.879]                 })
[10:26:15.879]             }))
[10:26:15.879]             future::FutureResult(value = ...future.value$value, 
[10:26:15.879]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.879]                   ...future.rng), globalenv = if (FALSE) 
[10:26:15.879]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:15.879]                     ...future.globalenv.names))
[10:26:15.879]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:15.879]         }, condition = base::local({
[10:26:15.879]             c <- base::c
[10:26:15.879]             inherits <- base::inherits
[10:26:15.879]             invokeRestart <- base::invokeRestart
[10:26:15.879]             length <- base::length
[10:26:15.879]             list <- base::list
[10:26:15.879]             seq.int <- base::seq.int
[10:26:15.879]             signalCondition <- base::signalCondition
[10:26:15.879]             sys.calls <- base::sys.calls
[10:26:15.879]             `[[` <- base::`[[`
[10:26:15.879]             `+` <- base::`+`
[10:26:15.879]             `<<-` <- base::`<<-`
[10:26:15.879]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:15.879]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:15.879]                   3L)]
[10:26:15.879]             }
[10:26:15.879]             function(cond) {
[10:26:15.879]                 is_error <- inherits(cond, "error")
[10:26:15.879]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:15.879]                   NULL)
[10:26:15.879]                 if (is_error) {
[10:26:15.879]                   sessionInformation <- function() {
[10:26:15.879]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:15.879]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:15.879]                       search = base::search(), system = base::Sys.info())
[10:26:15.879]                   }
[10:26:15.879]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.879]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:15.879]                     cond$call), session = sessionInformation(), 
[10:26:15.879]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:15.879]                   signalCondition(cond)
[10:26:15.879]                 }
[10:26:15.879]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:15.879]                 "immediateCondition"))) {
[10:26:15.879]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:15.879]                   ...future.conditions[[length(...future.conditions) + 
[10:26:15.879]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:15.879]                   if (TRUE && !signal) {
[10:26:15.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.879]                     {
[10:26:15.879]                       inherits <- base::inherits
[10:26:15.879]                       invokeRestart <- base::invokeRestart
[10:26:15.879]                       is.null <- base::is.null
[10:26:15.879]                       muffled <- FALSE
[10:26:15.879]                       if (inherits(cond, "message")) {
[10:26:15.879]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.879]                         if (muffled) 
[10:26:15.879]                           invokeRestart("muffleMessage")
[10:26:15.879]                       }
[10:26:15.879]                       else if (inherits(cond, "warning")) {
[10:26:15.879]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.879]                         if (muffled) 
[10:26:15.879]                           invokeRestart("muffleWarning")
[10:26:15.879]                       }
[10:26:15.879]                       else if (inherits(cond, "condition")) {
[10:26:15.879]                         if (!is.null(pattern)) {
[10:26:15.879]                           computeRestarts <- base::computeRestarts
[10:26:15.879]                           grepl <- base::grepl
[10:26:15.879]                           restarts <- computeRestarts(cond)
[10:26:15.879]                           for (restart in restarts) {
[10:26:15.879]                             name <- restart$name
[10:26:15.879]                             if (is.null(name)) 
[10:26:15.879]                               next
[10:26:15.879]                             if (!grepl(pattern, name)) 
[10:26:15.879]                               next
[10:26:15.879]                             invokeRestart(restart)
[10:26:15.879]                             muffled <- TRUE
[10:26:15.879]                             break
[10:26:15.879]                           }
[10:26:15.879]                         }
[10:26:15.879]                       }
[10:26:15.879]                       invisible(muffled)
[10:26:15.879]                     }
[10:26:15.879]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.879]                   }
[10:26:15.879]                 }
[10:26:15.879]                 else {
[10:26:15.879]                   if (TRUE) {
[10:26:15.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:15.879]                     {
[10:26:15.879]                       inherits <- base::inherits
[10:26:15.879]                       invokeRestart <- base::invokeRestart
[10:26:15.879]                       is.null <- base::is.null
[10:26:15.879]                       muffled <- FALSE
[10:26:15.879]                       if (inherits(cond, "message")) {
[10:26:15.879]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:15.879]                         if (muffled) 
[10:26:15.879]                           invokeRestart("muffleMessage")
[10:26:15.879]                       }
[10:26:15.879]                       else if (inherits(cond, "warning")) {
[10:26:15.879]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:15.879]                         if (muffled) 
[10:26:15.879]                           invokeRestart("muffleWarning")
[10:26:15.879]                       }
[10:26:15.879]                       else if (inherits(cond, "condition")) {
[10:26:15.879]                         if (!is.null(pattern)) {
[10:26:15.879]                           computeRestarts <- base::computeRestarts
[10:26:15.879]                           grepl <- base::grepl
[10:26:15.879]                           restarts <- computeRestarts(cond)
[10:26:15.879]                           for (restart in restarts) {
[10:26:15.879]                             name <- restart$name
[10:26:15.879]                             if (is.null(name)) 
[10:26:15.879]                               next
[10:26:15.879]                             if (!grepl(pattern, name)) 
[10:26:15.879]                               next
[10:26:15.879]                             invokeRestart(restart)
[10:26:15.879]                             muffled <- TRUE
[10:26:15.879]                             break
[10:26:15.879]                           }
[10:26:15.879]                         }
[10:26:15.879]                       }
[10:26:15.879]                       invisible(muffled)
[10:26:15.879]                     }
[10:26:15.879]                     muffleCondition(cond, pattern = "^muffle")
[10:26:15.879]                   }
[10:26:15.879]                 }
[10:26:15.879]             }
[10:26:15.879]         }))
[10:26:15.879]     }, error = function(ex) {
[10:26:15.879]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:15.879]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:15.879]                 ...future.rng), started = ...future.startTime, 
[10:26:15.879]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:15.879]             version = "1.8"), class = "FutureResult")
[10:26:15.879]     }, finally = {
[10:26:15.879]         if (!identical(...future.workdir, getwd())) 
[10:26:15.879]             setwd(...future.workdir)
[10:26:15.879]         {
[10:26:15.879]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:15.879]                 ...future.oldOptions$nwarnings <- NULL
[10:26:15.879]             }
[10:26:15.879]             base::options(...future.oldOptions)
[10:26:15.879]             if (.Platform$OS.type == "windows") {
[10:26:15.879]                 old_names <- names(...future.oldEnvVars)
[10:26:15.879]                 envs <- base::Sys.getenv()
[10:26:15.879]                 names <- names(envs)
[10:26:15.879]                 common <- intersect(names, old_names)
[10:26:15.879]                 added <- setdiff(names, old_names)
[10:26:15.879]                 removed <- setdiff(old_names, names)
[10:26:15.879]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:15.879]                   envs[common]]
[10:26:15.879]                 NAMES <- toupper(changed)
[10:26:15.879]                 args <- list()
[10:26:15.879]                 for (kk in seq_along(NAMES)) {
[10:26:15.879]                   name <- changed[[kk]]
[10:26:15.879]                   NAME <- NAMES[[kk]]
[10:26:15.879]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.879]                     next
[10:26:15.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.879]                 }
[10:26:15.879]                 NAMES <- toupper(added)
[10:26:15.879]                 for (kk in seq_along(NAMES)) {
[10:26:15.879]                   name <- added[[kk]]
[10:26:15.879]                   NAME <- NAMES[[kk]]
[10:26:15.879]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.879]                     next
[10:26:15.879]                   args[[name]] <- ""
[10:26:15.879]                 }
[10:26:15.879]                 NAMES <- toupper(removed)
[10:26:15.879]                 for (kk in seq_along(NAMES)) {
[10:26:15.879]                   name <- removed[[kk]]
[10:26:15.879]                   NAME <- NAMES[[kk]]
[10:26:15.879]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:15.879]                     next
[10:26:15.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:15.879]                 }
[10:26:15.879]                 if (length(args) > 0) 
[10:26:15.879]                   base::do.call(base::Sys.setenv, args = args)
[10:26:15.879]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:15.879]             }
[10:26:15.879]             else {
[10:26:15.879]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:15.879]             }
[10:26:15.879]             {
[10:26:15.879]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:15.879]                   0L) {
[10:26:15.879]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:15.879]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:15.879]                   base::options(opts)
[10:26:15.879]                 }
[10:26:15.879]                 {
[10:26:15.879]                   {
[10:26:15.879]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:15.879]                     NULL
[10:26:15.879]                   }
[10:26:15.879]                   options(future.plan = NULL)
[10:26:15.879]                   if (is.na(NA_character_)) 
[10:26:15.879]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:15.879]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:15.879]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:15.879]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:15.879]                     envir = parent.frame()) 
[10:26:15.879]                   {
[10:26:15.879]                     if (is.function(workers)) 
[10:26:15.879]                       workers <- workers()
[10:26:15.879]                     workers <- structure(as.integer(workers), 
[10:26:15.879]                       class = class(workers))
[10:26:15.879]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:15.879]                       workers >= 1)
[10:26:15.879]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:15.879]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:15.879]                     }
[10:26:15.879]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:15.879]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:15.879]                       envir = envir)
[10:26:15.879]                     if (!future$lazy) 
[10:26:15.879]                       future <- run(future)
[10:26:15.879]                     invisible(future)
[10:26:15.879]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:15.879]                 }
[10:26:15.879]             }
[10:26:15.879]         }
[10:26:15.879]     })
[10:26:15.879]     if (TRUE) {
[10:26:15.879]         base::sink(type = "output", split = FALSE)
[10:26:15.879]         if (TRUE) {
[10:26:15.879]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:15.879]         }
[10:26:15.879]         else {
[10:26:15.879]             ...future.result["stdout"] <- base::list(NULL)
[10:26:15.879]         }
[10:26:15.879]         base::close(...future.stdout)
[10:26:15.879]         ...future.stdout <- NULL
[10:26:15.879]     }
[10:26:15.879]     ...future.result$conditions <- ...future.conditions
[10:26:15.879]     ...future.result$finished <- base::Sys.time()
[10:26:15.879]     ...future.result
[10:26:15.879] }
[10:26:15.882] Exporting 1 global objects (1.56 MiB) to cluster node #1 ...
[10:26:15.883] Exporting ‘a’ (1.56 MiB) to cluster node #1 ...
[10:26:15.934] Exporting ‘a’ (1.56 MiB) to cluster node #1 ... DONE
[10:26:15.934] Exporting 1 global objects (1.56 MiB) to cluster node #1 ... DONE
[10:26:15.935] MultisessionFuture started
[10:26:15.935] - Launch lazy future ... done
[10:26:15.935] run() for ‘MultisessionFuture’ ... done
[10:26:15.935] result() for ClusterFuture ...
[10:26:15.935] receiveMessageFromWorker() for ClusterFuture ...
[10:26:15.935] - Validating connection of MultisessionFuture
[10:26:15.983] - received message: FutureResult
[10:26:15.983] - Received FutureResult
[10:26:15.983] - Erased future from FutureRegistry
[10:26:15.983] result() for ClusterFuture ...
[10:26:15.983] - result already collected: FutureResult
[10:26:15.983] result() for ClusterFuture ... done
[10:26:15.983] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:15.983] result() for ClusterFuture ... done
[10:26:15.983] result() for ClusterFuture ...
[10:26:15.984] - result already collected: FutureResult
[10:26:15.984] result() for ClusterFuture ... done
value(b) = 2
[10:26:15.984] result() for ClusterFuture ...
[10:26:15.984] - result already collected: FutureResult
[10:26:15.984] result() for ClusterFuture ... done
[10:26:15.984] result() for ClusterFuture ...
[10:26:15.984] - result already collected: FutureResult
[10:26:15.984] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:15.984] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:15.985] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:15.985] 
[10:26:15.985] Searching for globals ... DONE
[10:26:15.985] - globals: [0] <none>
[10:26:15.985] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:15.986] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:15.986] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:15.987] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:15.987] Searching for globals ... DONE
[10:26:15.987] Resolving globals: TRUE
[10:26:15.987] Resolving any globals that are futures ...
[10:26:15.987] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:15.987] Resolving any globals that are futures ... DONE
[10:26:15.987] Resolving futures part of globals (recursively) ...
[10:26:15.988] resolve() on list ...
[10:26:15.988]  recursive: 99
[10:26:15.988]  length: 1
[10:26:15.988]  elements: ‘a’
[10:26:15.988] run() for ‘Future’ ...
[10:26:15.988] - state: ‘created’
[10:26:15.988] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:16.003] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:16.003] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:16.003]   - Field: ‘node’
[10:26:16.003]   - Field: ‘label’
[10:26:16.003]   - Field: ‘local’
[10:26:16.004]   - Field: ‘owner’
[10:26:16.004]   - Field: ‘envir’
[10:26:16.004]   - Field: ‘workers’
[10:26:16.004]   - Field: ‘packages’
[10:26:16.004]   - Field: ‘gc’
[10:26:16.004]   - Field: ‘conditions’
[10:26:16.004]   - Field: ‘persistent’
[10:26:16.004]   - Field: ‘expr’
[10:26:16.004]   - Field: ‘uuid’
[10:26:16.004]   - Field: ‘seed’
[10:26:16.004]   - Field: ‘version’
[10:26:16.005]   - Field: ‘result’
[10:26:16.005]   - Field: ‘asynchronous’
[10:26:16.005]   - Field: ‘calls’
[10:26:16.005]   - Field: ‘globals’
[10:26:16.005]   - Field: ‘stdout’
[10:26:16.005]   - Field: ‘earlySignal’
[10:26:16.005]   - Field: ‘lazy’
[10:26:16.005]   - Field: ‘state’
[10:26:16.005] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:16.005] - Launch lazy future ...
[10:26:16.006] Packages needed by the future expression (n = 0): <none>
[10:26:16.006] Packages needed by future strategies (n = 0): <none>
[10:26:16.006] {
[10:26:16.006]     {
[10:26:16.006]         {
[10:26:16.006]             ...future.startTime <- base::Sys.time()
[10:26:16.006]             {
[10:26:16.006]                 {
[10:26:16.006]                   {
[10:26:16.006]                     {
[10:26:16.006]                       base::local({
[10:26:16.006]                         has_future <- base::requireNamespace("future", 
[10:26:16.006]                           quietly = TRUE)
[10:26:16.006]                         if (has_future) {
[10:26:16.006]                           ns <- base::getNamespace("future")
[10:26:16.006]                           version <- ns[[".package"]][["version"]]
[10:26:16.006]                           if (is.null(version)) 
[10:26:16.006]                             version <- utils::packageVersion("future")
[10:26:16.006]                         }
[10:26:16.006]                         else {
[10:26:16.006]                           version <- NULL
[10:26:16.006]                         }
[10:26:16.006]                         if (!has_future || version < "1.8.0") {
[10:26:16.006]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:16.006]                             "", base::R.version$version.string), 
[10:26:16.006]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:16.006]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:16.006]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:16.006]                               "release", "version")], collapse = " "), 
[10:26:16.006]                             hostname = base::Sys.info()[["nodename"]])
[10:26:16.006]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:16.006]                             info)
[10:26:16.006]                           info <- base::paste(info, collapse = "; ")
[10:26:16.006]                           if (!has_future) {
[10:26:16.006]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:16.006]                               info)
[10:26:16.006]                           }
[10:26:16.006]                           else {
[10:26:16.006]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:16.006]                               info, version)
[10:26:16.006]                           }
[10:26:16.006]                           base::stop(msg)
[10:26:16.006]                         }
[10:26:16.006]                       })
[10:26:16.006]                     }
[10:26:16.006]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:16.006]                     base::options(mc.cores = 1L)
[10:26:16.006]                   }
[10:26:16.006]                   options(future.plan = NULL)
[10:26:16.006]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:16.006]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:16.006]                 }
[10:26:16.006]                 ...future.workdir <- getwd()
[10:26:16.006]             }
[10:26:16.006]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:16.006]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:16.006]         }
[10:26:16.006]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:16.006]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:16.006]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:16.006]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:16.006]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:16.006]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:16.006]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:16.006]             base::names(...future.oldOptions))
[10:26:16.006]     }
[10:26:16.006]     if (FALSE) {
[10:26:16.006]     }
[10:26:16.006]     else {
[10:26:16.006]         if (TRUE) {
[10:26:16.006]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:16.006]                 open = "w")
[10:26:16.006]         }
[10:26:16.006]         else {
[10:26:16.006]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:16.006]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:16.006]         }
[10:26:16.006]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:16.006]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:16.006]             base::sink(type = "output", split = FALSE)
[10:26:16.006]             base::close(...future.stdout)
[10:26:16.006]         }, add = TRUE)
[10:26:16.006]     }
[10:26:16.006]     ...future.frame <- base::sys.nframe()
[10:26:16.006]     ...future.conditions <- base::list()
[10:26:16.006]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:16.006]     if (FALSE) {
[10:26:16.006]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:16.006]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:16.006]     }
[10:26:16.006]     ...future.result <- base::tryCatch({
[10:26:16.006]         base::withCallingHandlers({
[10:26:16.006]             ...future.value <- base::withVisible(base::local({
[10:26:16.006]                 ...future.makeSendCondition <- base::local({
[10:26:16.006]                   sendCondition <- NULL
[10:26:16.006]                   function(frame = 1L) {
[10:26:16.006]                     if (is.function(sendCondition)) 
[10:26:16.006]                       return(sendCondition)
[10:26:16.006]                     ns <- getNamespace("parallel")
[10:26:16.006]                     if (exists("sendData", mode = "function", 
[10:26:16.006]                       envir = ns)) {
[10:26:16.006]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:16.006]                         envir = ns)
[10:26:16.006]                       envir <- sys.frame(frame)
[10:26:16.006]                       master <- NULL
[10:26:16.006]                       while (!identical(envir, .GlobalEnv) && 
[10:26:16.006]                         !identical(envir, emptyenv())) {
[10:26:16.006]                         if (exists("master", mode = "list", envir = envir, 
[10:26:16.006]                           inherits = FALSE)) {
[10:26:16.006]                           master <- get("master", mode = "list", 
[10:26:16.006]                             envir = envir, inherits = FALSE)
[10:26:16.006]                           if (inherits(master, c("SOCKnode", 
[10:26:16.006]                             "SOCK0node"))) {
[10:26:16.006]                             sendCondition <<- function(cond) {
[10:26:16.006]                               data <- list(type = "VALUE", value = cond, 
[10:26:16.006]                                 success = TRUE)
[10:26:16.006]                               parallel_sendData(master, data)
[10:26:16.006]                             }
[10:26:16.006]                             return(sendCondition)
[10:26:16.006]                           }
[10:26:16.006]                         }
[10:26:16.006]                         frame <- frame + 1L
[10:26:16.006]                         envir <- sys.frame(frame)
[10:26:16.006]                       }
[10:26:16.006]                     }
[10:26:16.006]                     sendCondition <<- function(cond) NULL
[10:26:16.006]                   }
[10:26:16.006]                 })
[10:26:16.006]                 withCallingHandlers({
[10:26:16.006]                   1
[10:26:16.006]                 }, immediateCondition = function(cond) {
[10:26:16.006]                   sendCondition <- ...future.makeSendCondition()
[10:26:16.006]                   sendCondition(cond)
[10:26:16.006]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:16.006]                   {
[10:26:16.006]                     inherits <- base::inherits
[10:26:16.006]                     invokeRestart <- base::invokeRestart
[10:26:16.006]                     is.null <- base::is.null
[10:26:16.006]                     muffled <- FALSE
[10:26:16.006]                     if (inherits(cond, "message")) {
[10:26:16.006]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:16.006]                       if (muffled) 
[10:26:16.006]                         invokeRestart("muffleMessage")
[10:26:16.006]                     }
[10:26:16.006]                     else if (inherits(cond, "warning")) {
[10:26:16.006]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:16.006]                       if (muffled) 
[10:26:16.006]                         invokeRestart("muffleWarning")
[10:26:16.006]                     }
[10:26:16.006]                     else if (inherits(cond, "condition")) {
[10:26:16.006]                       if (!is.null(pattern)) {
[10:26:16.006]                         computeRestarts <- base::computeRestarts
[10:26:16.006]                         grepl <- base::grepl
[10:26:16.006]                         restarts <- computeRestarts(cond)
[10:26:16.006]                         for (restart in restarts) {
[10:26:16.006]                           name <- restart$name
[10:26:16.006]                           if (is.null(name)) 
[10:26:16.006]                             next
[10:26:16.006]                           if (!grepl(pattern, name)) 
[10:26:16.006]                             next
[10:26:16.006]                           invokeRestart(restart)
[10:26:16.006]                           muffled <- TRUE
[10:26:16.006]                           break
[10:26:16.006]                         }
[10:26:16.006]                       }
[10:26:16.006]                     }
[10:26:16.006]                     invisible(muffled)
[10:26:16.006]                   }
[10:26:16.006]                   muffleCondition(cond)
[10:26:16.006]                 })
[10:26:16.006]             }))
[10:26:16.006]             future::FutureResult(value = ...future.value$value, 
[10:26:16.006]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:16.006]                   ...future.rng), globalenv = if (FALSE) 
[10:26:16.006]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:16.006]                     ...future.globalenv.names))
[10:26:16.006]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:16.006]         }, condition = base::local({
[10:26:16.006]             c <- base::c
[10:26:16.006]             inherits <- base::inherits
[10:26:16.006]             invokeRestart <- base::invokeRestart
[10:26:16.006]             length <- base::length
[10:26:16.006]             list <- base::list
[10:26:16.006]             seq.int <- base::seq.int
[10:26:16.006]             signalCondition <- base::signalCondition
[10:26:16.006]             sys.calls <- base::sys.calls
[10:26:16.006]             `[[` <- base::`[[`
[10:26:16.006]             `+` <- base::`+`
[10:26:16.006]             `<<-` <- base::`<<-`
[10:26:16.006]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:16.006]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:16.006]                   3L)]
[10:26:16.006]             }
[10:26:16.006]             function(cond) {
[10:26:16.006]                 is_error <- inherits(cond, "error")
[10:26:16.006]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:16.006]                   NULL)
[10:26:16.006]                 if (is_error) {
[10:26:16.006]                   sessionInformation <- function() {
[10:26:16.006]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:16.006]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:16.006]                       search = base::search(), system = base::Sys.info())
[10:26:16.006]                   }
[10:26:16.006]                   ...future.conditions[[length(...future.conditions) + 
[10:26:16.006]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:16.006]                     cond$call), session = sessionInformation(), 
[10:26:16.006]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:16.006]                   signalCondition(cond)
[10:26:16.006]                 }
[10:26:16.006]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:16.006]                 "immediateCondition"))) {
[10:26:16.006]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:16.006]                   ...future.conditions[[length(...future.conditions) + 
[10:26:16.006]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:16.006]                   if (TRUE && !signal) {
[10:26:16.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:16.006]                     {
[10:26:16.006]                       inherits <- base::inherits
[10:26:16.006]                       invokeRestart <- base::invokeRestart
[10:26:16.006]                       is.null <- base::is.null
[10:26:16.006]                       muffled <- FALSE
[10:26:16.006]                       if (inherits(cond, "message")) {
[10:26:16.006]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:16.006]                         if (muffled) 
[10:26:16.006]                           invokeRestart("muffleMessage")
[10:26:16.006]                       }
[10:26:16.006]                       else if (inherits(cond, "warning")) {
[10:26:16.006]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:16.006]                         if (muffled) 
[10:26:16.006]                           invokeRestart("muffleWarning")
[10:26:16.006]                       }
[10:26:16.006]                       else if (inherits(cond, "condition")) {
[10:26:16.006]                         if (!is.null(pattern)) {
[10:26:16.006]                           computeRestarts <- base::computeRestarts
[10:26:16.006]                           grepl <- base::grepl
[10:26:16.006]                           restarts <- computeRestarts(cond)
[10:26:16.006]                           for (restart in restarts) {
[10:26:16.006]                             name <- restart$name
[10:26:16.006]                             if (is.null(name)) 
[10:26:16.006]                               next
[10:26:16.006]                             if (!grepl(pattern, name)) 
[10:26:16.006]                               next
[10:26:16.006]                             invokeRestart(restart)
[10:26:16.006]                             muffled <- TRUE
[10:26:16.006]                             break
[10:26:16.006]                           }
[10:26:16.006]                         }
[10:26:16.006]                       }
[10:26:16.006]                       invisible(muffled)
[10:26:16.006]                     }
[10:26:16.006]                     muffleCondition(cond, pattern = "^muffle")
[10:26:16.006]                   }
[10:26:16.006]                 }
[10:26:16.006]                 else {
[10:26:16.006]                   if (TRUE) {
[10:26:16.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:16.006]                     {
[10:26:16.006]                       inherits <- base::inherits
[10:26:16.006]                       invokeRestart <- base::invokeRestart
[10:26:16.006]                       is.null <- base::is.null
[10:26:16.006]                       muffled <- FALSE
[10:26:16.006]                       if (inherits(cond, "message")) {
[10:26:16.006]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:16.006]                         if (muffled) 
[10:26:16.006]                           invokeRestart("muffleMessage")
[10:26:16.006]                       }
[10:26:16.006]                       else if (inherits(cond, "warning")) {
[10:26:16.006]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:16.006]                         if (muffled) 
[10:26:16.006]                           invokeRestart("muffleWarning")
[10:26:16.006]                       }
[10:26:16.006]                       else if (inherits(cond, "condition")) {
[10:26:16.006]                         if (!is.null(pattern)) {
[10:26:16.006]                           computeRestarts <- base::computeRestarts
[10:26:16.006]                           grepl <- base::grepl
[10:26:16.006]                           restarts <- computeRestarts(cond)
[10:26:16.006]                           for (restart in restarts) {
[10:26:16.006]                             name <- restart$name
[10:26:16.006]                             if (is.null(name)) 
[10:26:16.006]                               next
[10:26:16.006]                             if (!grepl(pattern, name)) 
[10:26:16.006]                               next
[10:26:16.006]                             invokeRestart(restart)
[10:26:16.006]                             muffled <- TRUE
[10:26:16.006]                             break
[10:26:16.006]                           }
[10:26:16.006]                         }
[10:26:16.006]                       }
[10:26:16.006]                       invisible(muffled)
[10:26:16.006]                     }
[10:26:16.006]                     muffleCondition(cond, pattern = "^muffle")
[10:26:16.006]                   }
[10:26:16.006]                 }
[10:26:16.006]             }
[10:26:16.006]         }))
[10:26:16.006]     }, error = function(ex) {
[10:26:16.006]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:16.006]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:16.006]                 ...future.rng), started = ...future.startTime, 
[10:26:16.006]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:16.006]             version = "1.8"), class = "FutureResult")
[10:26:16.006]     }, finally = {
[10:26:16.006]         if (!identical(...future.workdir, getwd())) 
[10:26:16.006]             setwd(...future.workdir)
[10:26:16.006]         {
[10:26:16.006]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:16.006]                 ...future.oldOptions$nwarnings <- NULL
[10:26:16.006]             }
[10:26:16.006]             base::options(...future.oldOptions)
[10:26:16.006]             if (.Platform$OS.type == "windows") {
[10:26:16.006]                 old_names <- names(...future.oldEnvVars)
[10:26:16.006]                 envs <- base::Sys.getenv()
[10:26:16.006]                 names <- names(envs)
[10:26:16.006]                 common <- intersect(names, old_names)
[10:26:16.006]                 added <- setdiff(names, old_names)
[10:26:16.006]                 removed <- setdiff(old_names, names)
[10:26:16.006]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:16.006]                   envs[common]]
[10:26:16.006]                 NAMES <- toupper(changed)
[10:26:16.006]                 args <- list()
[10:26:16.006]                 for (kk in seq_along(NAMES)) {
[10:26:16.006]                   name <- changed[[kk]]
[10:26:16.006]                   NAME <- NAMES[[kk]]
[10:26:16.006]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.006]                     next
[10:26:16.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:16.006]                 }
[10:26:16.006]                 NAMES <- toupper(added)
[10:26:16.006]                 for (kk in seq_along(NAMES)) {
[10:26:16.006]                   name <- added[[kk]]
[10:26:16.006]                   NAME <- NAMES[[kk]]
[10:26:16.006]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.006]                     next
[10:26:16.006]                   args[[name]] <- ""
[10:26:16.006]                 }
[10:26:16.006]                 NAMES <- toupper(removed)
[10:26:16.006]                 for (kk in seq_along(NAMES)) {
[10:26:16.006]                   name <- removed[[kk]]
[10:26:16.006]                   NAME <- NAMES[[kk]]
[10:26:16.006]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.006]                     next
[10:26:16.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:16.006]                 }
[10:26:16.006]                 if (length(args) > 0) 
[10:26:16.006]                   base::do.call(base::Sys.setenv, args = args)
[10:26:16.006]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:16.006]             }
[10:26:16.006]             else {
[10:26:16.006]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:16.006]             }
[10:26:16.006]             {
[10:26:16.006]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:16.006]                   0L) {
[10:26:16.006]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:16.006]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:16.006]                   base::options(opts)
[10:26:16.006]                 }
[10:26:16.006]                 {
[10:26:16.006]                   {
[10:26:16.006]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:16.006]                     NULL
[10:26:16.006]                   }
[10:26:16.006]                   options(future.plan = NULL)
[10:26:16.006]                   if (is.na(NA_character_)) 
[10:26:16.006]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:16.006]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:16.006]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:16.006]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:16.006]                     envir = parent.frame()) 
[10:26:16.006]                   {
[10:26:16.006]                     if (is.function(workers)) 
[10:26:16.006]                       workers <- workers()
[10:26:16.006]                     workers <- structure(as.integer(workers), 
[10:26:16.006]                       class = class(workers))
[10:26:16.006]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:16.006]                       workers >= 1)
[10:26:16.006]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:16.006]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:16.006]                     }
[10:26:16.006]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:16.006]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:16.006]                       envir = envir)
[10:26:16.006]                     if (!future$lazy) 
[10:26:16.006]                       future <- run(future)
[10:26:16.006]                     invisible(future)
[10:26:16.006]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:16.006]                 }
[10:26:16.006]             }
[10:26:16.006]         }
[10:26:16.006]     })
[10:26:16.006]     if (TRUE) {
[10:26:16.006]         base::sink(type = "output", split = FALSE)
[10:26:16.006]         if (TRUE) {
[10:26:16.006]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:16.006]         }
[10:26:16.006]         else {
[10:26:16.006]             ...future.result["stdout"] <- base::list(NULL)
[10:26:16.006]         }
[10:26:16.006]         base::close(...future.stdout)
[10:26:16.006]         ...future.stdout <- NULL
[10:26:16.006]     }
[10:26:16.006]     ...future.result$conditions <- ...future.conditions
[10:26:16.006]     ...future.result$finished <- base::Sys.time()
[10:26:16.006]     ...future.result
[10:26:16.006] }
[10:26:16.009] MultisessionFuture started
[10:26:16.009] - Launch lazy future ... done
[10:26:16.009] run() for ‘MultisessionFuture’ ... done
[10:26:16.056] receiveMessageFromWorker() for ClusterFuture ...
[10:26:16.056] - Validating connection of MultisessionFuture
[10:26:16.056] - received message: FutureResult
[10:26:16.056] - Received FutureResult
[10:26:16.057] - Erased future from FutureRegistry
[10:26:16.057] result() for ClusterFuture ...
[10:26:16.057] - result already collected: FutureResult
[10:26:16.057] result() for ClusterFuture ... done
[10:26:16.057] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:16.057] Future #1
[10:26:16.057] result() for ClusterFuture ...
[10:26:16.057] - result already collected: FutureResult
[10:26:16.057] result() for ClusterFuture ... done
[10:26:16.057] result() for ClusterFuture ...
[10:26:16.058] - result already collected: FutureResult
[10:26:16.058] result() for ClusterFuture ... done
[10:26:16.058] A MultisessionFuture was resolved
[10:26:16.058]  length: 0 (resolved future 1)
[10:26:16.058] resolve() on list ... DONE
[10:26:16.058] - globals: [1] ‘a’
[10:26:16.058] Resolving futures part of globals (recursively) ... DONE
[10:26:16.060] The total size of the 1 globals is 1.56 MiB (1641008 bytes)
[10:26:16.061] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.56 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.56 MiB of class ‘environment’)
[10:26:16.061] - globals: [1] ‘a’
[10:26:16.061] - packages: [1] ‘future’
[10:26:16.061] getGlobalsAndPackages() ... DONE
[10:26:16.061] run() for ‘Future’ ...
[10:26:16.061] - state: ‘created’
[10:26:16.061] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:16.075] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:16.075] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:16.075]   - Field: ‘node’
[10:26:16.075]   - Field: ‘label’
[10:26:16.075]   - Field: ‘local’
[10:26:16.075]   - Field: ‘owner’
[10:26:16.076]   - Field: ‘envir’
[10:26:16.076]   - Field: ‘workers’
[10:26:16.076]   - Field: ‘packages’
[10:26:16.076]   - Field: ‘gc’
[10:26:16.076]   - Field: ‘conditions’
[10:26:16.076]   - Field: ‘persistent’
[10:26:16.076]   - Field: ‘expr’
[10:26:16.076]   - Field: ‘uuid’
[10:26:16.076]   - Field: ‘seed’
[10:26:16.076]   - Field: ‘version’
[10:26:16.076]   - Field: ‘result’
[10:26:16.077]   - Field: ‘asynchronous’
[10:26:16.077]   - Field: ‘calls’
[10:26:16.077]   - Field: ‘globals’
[10:26:16.077]   - Field: ‘stdout’
[10:26:16.077]   - Field: ‘earlySignal’
[10:26:16.077]   - Field: ‘lazy’
[10:26:16.077]   - Field: ‘state’
[10:26:16.077] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:16.077] - Launch lazy future ...
[10:26:16.078] Packages needed by the future expression (n = 1): ‘future’
[10:26:16.078] Packages needed by future strategies (n = 0): <none>
[10:26:16.078] {
[10:26:16.078]     {
[10:26:16.078]         {
[10:26:16.078]             ...future.startTime <- base::Sys.time()
[10:26:16.078]             {
[10:26:16.078]                 {
[10:26:16.078]                   {
[10:26:16.078]                     {
[10:26:16.078]                       {
[10:26:16.078]                         base::local({
[10:26:16.078]                           has_future <- base::requireNamespace("future", 
[10:26:16.078]                             quietly = TRUE)
[10:26:16.078]                           if (has_future) {
[10:26:16.078]                             ns <- base::getNamespace("future")
[10:26:16.078]                             version <- ns[[".package"]][["version"]]
[10:26:16.078]                             if (is.null(version)) 
[10:26:16.078]                               version <- utils::packageVersion("future")
[10:26:16.078]                           }
[10:26:16.078]                           else {
[10:26:16.078]                             version <- NULL
[10:26:16.078]                           }
[10:26:16.078]                           if (!has_future || version < "1.8.0") {
[10:26:16.078]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:16.078]                               "", base::R.version$version.string), 
[10:26:16.078]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:16.078]                                 base::R.version$platform, 8 * 
[10:26:16.078]                                   base::.Machine$sizeof.pointer), 
[10:26:16.078]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:16.078]                                 "release", "version")], collapse = " "), 
[10:26:16.078]                               hostname = base::Sys.info()[["nodename"]])
[10:26:16.078]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:16.078]                               info)
[10:26:16.078]                             info <- base::paste(info, collapse = "; ")
[10:26:16.078]                             if (!has_future) {
[10:26:16.078]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:16.078]                                 info)
[10:26:16.078]                             }
[10:26:16.078]                             else {
[10:26:16.078]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:16.078]                                 info, version)
[10:26:16.078]                             }
[10:26:16.078]                             base::stop(msg)
[10:26:16.078]                           }
[10:26:16.078]                         })
[10:26:16.078]                       }
[10:26:16.078]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:16.078]                       base::options(mc.cores = 1L)
[10:26:16.078]                     }
[10:26:16.078]                     base::local({
[10:26:16.078]                       for (pkg in "future") {
[10:26:16.078]                         base::loadNamespace(pkg)
[10:26:16.078]                         base::library(pkg, character.only = TRUE)
[10:26:16.078]                       }
[10:26:16.078]                     })
[10:26:16.078]                   }
[10:26:16.078]                   options(future.plan = NULL)
[10:26:16.078]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:16.078]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:16.078]                 }
[10:26:16.078]                 ...future.workdir <- getwd()
[10:26:16.078]             }
[10:26:16.078]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:16.078]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:16.078]         }
[10:26:16.078]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:16.078]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:16.078]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:16.078]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:16.078]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:16.078]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:16.078]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:16.078]             base::names(...future.oldOptions))
[10:26:16.078]     }
[10:26:16.078]     if (FALSE) {
[10:26:16.078]     }
[10:26:16.078]     else {
[10:26:16.078]         if (TRUE) {
[10:26:16.078]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:16.078]                 open = "w")
[10:26:16.078]         }
[10:26:16.078]         else {
[10:26:16.078]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:16.078]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:16.078]         }
[10:26:16.078]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:16.078]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:16.078]             base::sink(type = "output", split = FALSE)
[10:26:16.078]             base::close(...future.stdout)
[10:26:16.078]         }, add = TRUE)
[10:26:16.078]     }
[10:26:16.078]     ...future.frame <- base::sys.nframe()
[10:26:16.078]     ...future.conditions <- base::list()
[10:26:16.078]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:16.078]     if (FALSE) {
[10:26:16.078]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:16.078]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:16.078]     }
[10:26:16.078]     ...future.result <- base::tryCatch({
[10:26:16.078]         base::withCallingHandlers({
[10:26:16.078]             ...future.value <- base::withVisible(base::local({
[10:26:16.078]                 ...future.makeSendCondition <- base::local({
[10:26:16.078]                   sendCondition <- NULL
[10:26:16.078]                   function(frame = 1L) {
[10:26:16.078]                     if (is.function(sendCondition)) 
[10:26:16.078]                       return(sendCondition)
[10:26:16.078]                     ns <- getNamespace("parallel")
[10:26:16.078]                     if (exists("sendData", mode = "function", 
[10:26:16.078]                       envir = ns)) {
[10:26:16.078]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:16.078]                         envir = ns)
[10:26:16.078]                       envir <- sys.frame(frame)
[10:26:16.078]                       master <- NULL
[10:26:16.078]                       while (!identical(envir, .GlobalEnv) && 
[10:26:16.078]                         !identical(envir, emptyenv())) {
[10:26:16.078]                         if (exists("master", mode = "list", envir = envir, 
[10:26:16.078]                           inherits = FALSE)) {
[10:26:16.078]                           master <- get("master", mode = "list", 
[10:26:16.078]                             envir = envir, inherits = FALSE)
[10:26:16.078]                           if (inherits(master, c("SOCKnode", 
[10:26:16.078]                             "SOCK0node"))) {
[10:26:16.078]                             sendCondition <<- function(cond) {
[10:26:16.078]                               data <- list(type = "VALUE", value = cond, 
[10:26:16.078]                                 success = TRUE)
[10:26:16.078]                               parallel_sendData(master, data)
[10:26:16.078]                             }
[10:26:16.078]                             return(sendCondition)
[10:26:16.078]                           }
[10:26:16.078]                         }
[10:26:16.078]                         frame <- frame + 1L
[10:26:16.078]                         envir <- sys.frame(frame)
[10:26:16.078]                       }
[10:26:16.078]                     }
[10:26:16.078]                     sendCondition <<- function(cond) NULL
[10:26:16.078]                   }
[10:26:16.078]                 })
[10:26:16.078]                 withCallingHandlers({
[10:26:16.078]                   value(a) + 1
[10:26:16.078]                 }, immediateCondition = function(cond) {
[10:26:16.078]                   sendCondition <- ...future.makeSendCondition()
[10:26:16.078]                   sendCondition(cond)
[10:26:16.078]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:16.078]                   {
[10:26:16.078]                     inherits <- base::inherits
[10:26:16.078]                     invokeRestart <- base::invokeRestart
[10:26:16.078]                     is.null <- base::is.null
[10:26:16.078]                     muffled <- FALSE
[10:26:16.078]                     if (inherits(cond, "message")) {
[10:26:16.078]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:16.078]                       if (muffled) 
[10:26:16.078]                         invokeRestart("muffleMessage")
[10:26:16.078]                     }
[10:26:16.078]                     else if (inherits(cond, "warning")) {
[10:26:16.078]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:16.078]                       if (muffled) 
[10:26:16.078]                         invokeRestart("muffleWarning")
[10:26:16.078]                     }
[10:26:16.078]                     else if (inherits(cond, "condition")) {
[10:26:16.078]                       if (!is.null(pattern)) {
[10:26:16.078]                         computeRestarts <- base::computeRestarts
[10:26:16.078]                         grepl <- base::grepl
[10:26:16.078]                         restarts <- computeRestarts(cond)
[10:26:16.078]                         for (restart in restarts) {
[10:26:16.078]                           name <- restart$name
[10:26:16.078]                           if (is.null(name)) 
[10:26:16.078]                             next
[10:26:16.078]                           if (!grepl(pattern, name)) 
[10:26:16.078]                             next
[10:26:16.078]                           invokeRestart(restart)
[10:26:16.078]                           muffled <- TRUE
[10:26:16.078]                           break
[10:26:16.078]                         }
[10:26:16.078]                       }
[10:26:16.078]                     }
[10:26:16.078]                     invisible(muffled)
[10:26:16.078]                   }
[10:26:16.078]                   muffleCondition(cond)
[10:26:16.078]                 })
[10:26:16.078]             }))
[10:26:16.078]             future::FutureResult(value = ...future.value$value, 
[10:26:16.078]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:16.078]                   ...future.rng), globalenv = if (FALSE) 
[10:26:16.078]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:16.078]                     ...future.globalenv.names))
[10:26:16.078]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:16.078]         }, condition = base::local({
[10:26:16.078]             c <- base::c
[10:26:16.078]             inherits <- base::inherits
[10:26:16.078]             invokeRestart <- base::invokeRestart
[10:26:16.078]             length <- base::length
[10:26:16.078]             list <- base::list
[10:26:16.078]             seq.int <- base::seq.int
[10:26:16.078]             signalCondition <- base::signalCondition
[10:26:16.078]             sys.calls <- base::sys.calls
[10:26:16.078]             `[[` <- base::`[[`
[10:26:16.078]             `+` <- base::`+`
[10:26:16.078]             `<<-` <- base::`<<-`
[10:26:16.078]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:16.078]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:16.078]                   3L)]
[10:26:16.078]             }
[10:26:16.078]             function(cond) {
[10:26:16.078]                 is_error <- inherits(cond, "error")
[10:26:16.078]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:16.078]                   NULL)
[10:26:16.078]                 if (is_error) {
[10:26:16.078]                   sessionInformation <- function() {
[10:26:16.078]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:16.078]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:16.078]                       search = base::search(), system = base::Sys.info())
[10:26:16.078]                   }
[10:26:16.078]                   ...future.conditions[[length(...future.conditions) + 
[10:26:16.078]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:16.078]                     cond$call), session = sessionInformation(), 
[10:26:16.078]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:16.078]                   signalCondition(cond)
[10:26:16.078]                 }
[10:26:16.078]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:16.078]                 "immediateCondition"))) {
[10:26:16.078]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:16.078]                   ...future.conditions[[length(...future.conditions) + 
[10:26:16.078]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:16.078]                   if (TRUE && !signal) {
[10:26:16.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:16.078]                     {
[10:26:16.078]                       inherits <- base::inherits
[10:26:16.078]                       invokeRestart <- base::invokeRestart
[10:26:16.078]                       is.null <- base::is.null
[10:26:16.078]                       muffled <- FALSE
[10:26:16.078]                       if (inherits(cond, "message")) {
[10:26:16.078]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:16.078]                         if (muffled) 
[10:26:16.078]                           invokeRestart("muffleMessage")
[10:26:16.078]                       }
[10:26:16.078]                       else if (inherits(cond, "warning")) {
[10:26:16.078]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:16.078]                         if (muffled) 
[10:26:16.078]                           invokeRestart("muffleWarning")
[10:26:16.078]                       }
[10:26:16.078]                       else if (inherits(cond, "condition")) {
[10:26:16.078]                         if (!is.null(pattern)) {
[10:26:16.078]                           computeRestarts <- base::computeRestarts
[10:26:16.078]                           grepl <- base::grepl
[10:26:16.078]                           restarts <- computeRestarts(cond)
[10:26:16.078]                           for (restart in restarts) {
[10:26:16.078]                             name <- restart$name
[10:26:16.078]                             if (is.null(name)) 
[10:26:16.078]                               next
[10:26:16.078]                             if (!grepl(pattern, name)) 
[10:26:16.078]                               next
[10:26:16.078]                             invokeRestart(restart)
[10:26:16.078]                             muffled <- TRUE
[10:26:16.078]                             break
[10:26:16.078]                           }
[10:26:16.078]                         }
[10:26:16.078]                       }
[10:26:16.078]                       invisible(muffled)
[10:26:16.078]                     }
[10:26:16.078]                     muffleCondition(cond, pattern = "^muffle")
[10:26:16.078]                   }
[10:26:16.078]                 }
[10:26:16.078]                 else {
[10:26:16.078]                   if (TRUE) {
[10:26:16.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:16.078]                     {
[10:26:16.078]                       inherits <- base::inherits
[10:26:16.078]                       invokeRestart <- base::invokeRestart
[10:26:16.078]                       is.null <- base::is.null
[10:26:16.078]                       muffled <- FALSE
[10:26:16.078]                       if (inherits(cond, "message")) {
[10:26:16.078]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:16.078]                         if (muffled) 
[10:26:16.078]                           invokeRestart("muffleMessage")
[10:26:16.078]                       }
[10:26:16.078]                       else if (inherits(cond, "warning")) {
[10:26:16.078]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:16.078]                         if (muffled) 
[10:26:16.078]                           invokeRestart("muffleWarning")
[10:26:16.078]                       }
[10:26:16.078]                       else if (inherits(cond, "condition")) {
[10:26:16.078]                         if (!is.null(pattern)) {
[10:26:16.078]                           computeRestarts <- base::computeRestarts
[10:26:16.078]                           grepl <- base::grepl
[10:26:16.078]                           restarts <- computeRestarts(cond)
[10:26:16.078]                           for (restart in restarts) {
[10:26:16.078]                             name <- restart$name
[10:26:16.078]                             if (is.null(name)) 
[10:26:16.078]                               next
[10:26:16.078]                             if (!grepl(pattern, name)) 
[10:26:16.078]                               next
[10:26:16.078]                             invokeRestart(restart)
[10:26:16.078]                             muffled <- TRUE
[10:26:16.078]                             break
[10:26:16.078]                           }
[10:26:16.078]                         }
[10:26:16.078]                       }
[10:26:16.078]                       invisible(muffled)
[10:26:16.078]                     }
[10:26:16.078]                     muffleCondition(cond, pattern = "^muffle")
[10:26:16.078]                   }
[10:26:16.078]                 }
[10:26:16.078]             }
[10:26:16.078]         }))
[10:26:16.078]     }, error = function(ex) {
[10:26:16.078]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:16.078]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:16.078]                 ...future.rng), started = ...future.startTime, 
[10:26:16.078]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:16.078]             version = "1.8"), class = "FutureResult")
[10:26:16.078]     }, finally = {
[10:26:16.078]         if (!identical(...future.workdir, getwd())) 
[10:26:16.078]             setwd(...future.workdir)
[10:26:16.078]         {
[10:26:16.078]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:16.078]                 ...future.oldOptions$nwarnings <- NULL
[10:26:16.078]             }
[10:26:16.078]             base::options(...future.oldOptions)
[10:26:16.078]             if (.Platform$OS.type == "windows") {
[10:26:16.078]                 old_names <- names(...future.oldEnvVars)
[10:26:16.078]                 envs <- base::Sys.getenv()
[10:26:16.078]                 names <- names(envs)
[10:26:16.078]                 common <- intersect(names, old_names)
[10:26:16.078]                 added <- setdiff(names, old_names)
[10:26:16.078]                 removed <- setdiff(old_names, names)
[10:26:16.078]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:16.078]                   envs[common]]
[10:26:16.078]                 NAMES <- toupper(changed)
[10:26:16.078]                 args <- list()
[10:26:16.078]                 for (kk in seq_along(NAMES)) {
[10:26:16.078]                   name <- changed[[kk]]
[10:26:16.078]                   NAME <- NAMES[[kk]]
[10:26:16.078]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.078]                     next
[10:26:16.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:16.078]                 }
[10:26:16.078]                 NAMES <- toupper(added)
[10:26:16.078]                 for (kk in seq_along(NAMES)) {
[10:26:16.078]                   name <- added[[kk]]
[10:26:16.078]                   NAME <- NAMES[[kk]]
[10:26:16.078]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.078]                     next
[10:26:16.078]                   args[[name]] <- ""
[10:26:16.078]                 }
[10:26:16.078]                 NAMES <- toupper(removed)
[10:26:16.078]                 for (kk in seq_along(NAMES)) {
[10:26:16.078]                   name <- removed[[kk]]
[10:26:16.078]                   NAME <- NAMES[[kk]]
[10:26:16.078]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.078]                     next
[10:26:16.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:16.078]                 }
[10:26:16.078]                 if (length(args) > 0) 
[10:26:16.078]                   base::do.call(base::Sys.setenv, args = args)
[10:26:16.078]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:16.078]             }
[10:26:16.078]             else {
[10:26:16.078]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:16.078]             }
[10:26:16.078]             {
[10:26:16.078]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:16.078]                   0L) {
[10:26:16.078]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:16.078]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:16.078]                   base::options(opts)
[10:26:16.078]                 }
[10:26:16.078]                 {
[10:26:16.078]                   {
[10:26:16.078]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:16.078]                     NULL
[10:26:16.078]                   }
[10:26:16.078]                   options(future.plan = NULL)
[10:26:16.078]                   if (is.na(NA_character_)) 
[10:26:16.078]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:16.078]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:16.078]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:16.078]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:16.078]                     envir = parent.frame()) 
[10:26:16.078]                   {
[10:26:16.078]                     if (is.function(workers)) 
[10:26:16.078]                       workers <- workers()
[10:26:16.078]                     workers <- structure(as.integer(workers), 
[10:26:16.078]                       class = class(workers))
[10:26:16.078]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:16.078]                       workers >= 1)
[10:26:16.078]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:16.078]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:16.078]                     }
[10:26:16.078]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:16.078]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:16.078]                       envir = envir)
[10:26:16.078]                     if (!future$lazy) 
[10:26:16.078]                       future <- run(future)
[10:26:16.078]                     invisible(future)
[10:26:16.078]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:16.078]                 }
[10:26:16.078]             }
[10:26:16.078]         }
[10:26:16.078]     })
[10:26:16.078]     if (TRUE) {
[10:26:16.078]         base::sink(type = "output", split = FALSE)
[10:26:16.078]         if (TRUE) {
[10:26:16.078]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:16.078]         }
[10:26:16.078]         else {
[10:26:16.078]             ...future.result["stdout"] <- base::list(NULL)
[10:26:16.078]         }
[10:26:16.078]         base::close(...future.stdout)
[10:26:16.078]         ...future.stdout <- NULL
[10:26:16.078]     }
[10:26:16.078]     ...future.result$conditions <- ...future.conditions
[10:26:16.078]     ...future.result$finished <- base::Sys.time()
[10:26:16.078]     ...future.result
[10:26:16.078] }
[10:26:16.081] Exporting 1 global objects (1.56 MiB) to cluster node #1 ...
[10:26:16.083] Exporting ‘a’ (1.56 MiB) to cluster node #1 ...
[10:26:16.134] Exporting ‘a’ (1.56 MiB) to cluster node #1 ... DONE
[10:26:16.134] Exporting 1 global objects (1.56 MiB) to cluster node #1 ... DONE
[10:26:16.134] MultisessionFuture started
[10:26:16.134] - Launch lazy future ... done
[10:26:16.135] run() for ‘MultisessionFuture’ ... done
[10:26:16.135] result() for ClusterFuture ...
[10:26:16.135] receiveMessageFromWorker() for ClusterFuture ...
[10:26:16.135] - Validating connection of MultisessionFuture
[10:26:16.183] - received message: FutureResult
[10:26:16.183] - Received FutureResult
[10:26:16.183] - Erased future from FutureRegistry
[10:26:16.183] result() for ClusterFuture ...
[10:26:16.183] - result already collected: FutureResult
[10:26:16.183] result() for ClusterFuture ... done
[10:26:16.183] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:16.184] result() for ClusterFuture ... done
[10:26:16.184] result() for ClusterFuture ...
[10:26:16.184] - result already collected: FutureResult
[10:26:16.184] result() for ClusterFuture ... done
value(b) = 2
[10:26:16.184] result() for ClusterFuture ...
[10:26:16.184] - result already collected: FutureResult
[10:26:16.184] result() for ClusterFuture ... done
[10:26:16.184] result() for ClusterFuture ...
[10:26:16.184] - result already collected: FutureResult
[10:26:16.184] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:16.185] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:16.185] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:16.185] 
[10:26:16.185] Searching for globals ... DONE
[10:26:16.186] - globals: [0] <none>
[10:26:16.186] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:16.186] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:16.186] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:16.187] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:26:16.187] Searching for globals ... DONE
[10:26:16.187] Resolving globals: TRUE
[10:26:16.187] Resolving any globals that are futures ...
[10:26:16.187] - globals: [3] ‘+’, ‘value’, ‘a’
[10:26:16.187] Resolving any globals that are futures ... DONE
[10:26:16.188] Resolving futures part of globals (recursively) ...
[10:26:16.188] resolve() on list ...
[10:26:16.188]  recursive: 99
[10:26:16.188]  length: 1
[10:26:16.188]  elements: ‘a’
[10:26:16.188] run() for ‘Future’ ...
[10:26:16.188] - state: ‘created’
[10:26:16.189] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:16.202] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:16.202] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:16.202]   - Field: ‘node’
[10:26:16.203]   - Field: ‘label’
[10:26:16.203]   - Field: ‘local’
[10:26:16.203]   - Field: ‘owner’
[10:26:16.203]   - Field: ‘envir’
[10:26:16.203]   - Field: ‘workers’
[10:26:16.203]   - Field: ‘packages’
[10:26:16.203]   - Field: ‘gc’
[10:26:16.203]   - Field: ‘conditions’
[10:26:16.203]   - Field: ‘persistent’
[10:26:16.203]   - Field: ‘expr’
[10:26:16.203]   - Field: ‘uuid’
[10:26:16.204]   - Field: ‘seed’
[10:26:16.204]   - Field: ‘version’
[10:26:16.204]   - Field: ‘result’
[10:26:16.204]   - Field: ‘asynchronous’
[10:26:16.204]   - Field: ‘calls’
[10:26:16.204]   - Field: ‘globals’
[10:26:16.204]   - Field: ‘stdout’
[10:26:16.204]   - Field: ‘earlySignal’
[10:26:16.204]   - Field: ‘lazy’
[10:26:16.204]   - Field: ‘state’
[10:26:16.204] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:16.205] - Launch lazy future ...
[10:26:16.205] Packages needed by the future expression (n = 0): <none>
[10:26:16.205] Packages needed by future strategies (n = 0): <none>
[10:26:16.205] {
[10:26:16.205]     {
[10:26:16.205]         {
[10:26:16.205]             ...future.startTime <- base::Sys.time()
[10:26:16.205]             {
[10:26:16.205]                 {
[10:26:16.205]                   {
[10:26:16.205]                     {
[10:26:16.205]                       base::local({
[10:26:16.205]                         has_future <- base::requireNamespace("future", 
[10:26:16.205]                           quietly = TRUE)
[10:26:16.205]                         if (has_future) {
[10:26:16.205]                           ns <- base::getNamespace("future")
[10:26:16.205]                           version <- ns[[".package"]][["version"]]
[10:26:16.205]                           if (is.null(version)) 
[10:26:16.205]                             version <- utils::packageVersion("future")
[10:26:16.205]                         }
[10:26:16.205]                         else {
[10:26:16.205]                           version <- NULL
[10:26:16.205]                         }
[10:26:16.205]                         if (!has_future || version < "1.8.0") {
[10:26:16.205]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:16.205]                             "", base::R.version$version.string), 
[10:26:16.205]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:16.205]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:16.205]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:16.205]                               "release", "version")], collapse = " "), 
[10:26:16.205]                             hostname = base::Sys.info()[["nodename"]])
[10:26:16.205]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:16.205]                             info)
[10:26:16.205]                           info <- base::paste(info, collapse = "; ")
[10:26:16.205]                           if (!has_future) {
[10:26:16.205]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:16.205]                               info)
[10:26:16.205]                           }
[10:26:16.205]                           else {
[10:26:16.205]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:16.205]                               info, version)
[10:26:16.205]                           }
[10:26:16.205]                           base::stop(msg)
[10:26:16.205]                         }
[10:26:16.205]                       })
[10:26:16.205]                     }
[10:26:16.205]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:16.205]                     base::options(mc.cores = 1L)
[10:26:16.205]                   }
[10:26:16.205]                   options(future.plan = NULL)
[10:26:16.205]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:16.205]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:16.205]                 }
[10:26:16.205]                 ...future.workdir <- getwd()
[10:26:16.205]             }
[10:26:16.205]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:16.205]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:16.205]         }
[10:26:16.205]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:16.205]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:16.205]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:16.205]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:16.205]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:16.205]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:16.205]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:16.205]             base::names(...future.oldOptions))
[10:26:16.205]     }
[10:26:16.205]     if (FALSE) {
[10:26:16.205]     }
[10:26:16.205]     else {
[10:26:16.205]         if (TRUE) {
[10:26:16.205]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:16.205]                 open = "w")
[10:26:16.205]         }
[10:26:16.205]         else {
[10:26:16.205]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:16.205]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:16.205]         }
[10:26:16.205]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:16.205]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:16.205]             base::sink(type = "output", split = FALSE)
[10:26:16.205]             base::close(...future.stdout)
[10:26:16.205]         }, add = TRUE)
[10:26:16.205]     }
[10:26:16.205]     ...future.frame <- base::sys.nframe()
[10:26:16.205]     ...future.conditions <- base::list()
[10:26:16.205]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:16.205]     if (FALSE) {
[10:26:16.205]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:16.205]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:16.205]     }
[10:26:16.205]     ...future.result <- base::tryCatch({
[10:26:16.205]         base::withCallingHandlers({
[10:26:16.205]             ...future.value <- base::withVisible(base::local({
[10:26:16.205]                 ...future.makeSendCondition <- base::local({
[10:26:16.205]                   sendCondition <- NULL
[10:26:16.205]                   function(frame = 1L) {
[10:26:16.205]                     if (is.function(sendCondition)) 
[10:26:16.205]                       return(sendCondition)
[10:26:16.205]                     ns <- getNamespace("parallel")
[10:26:16.205]                     if (exists("sendData", mode = "function", 
[10:26:16.205]                       envir = ns)) {
[10:26:16.205]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:16.205]                         envir = ns)
[10:26:16.205]                       envir <- sys.frame(frame)
[10:26:16.205]                       master <- NULL
[10:26:16.205]                       while (!identical(envir, .GlobalEnv) && 
[10:26:16.205]                         !identical(envir, emptyenv())) {
[10:26:16.205]                         if (exists("master", mode = "list", envir = envir, 
[10:26:16.205]                           inherits = FALSE)) {
[10:26:16.205]                           master <- get("master", mode = "list", 
[10:26:16.205]                             envir = envir, inherits = FALSE)
[10:26:16.205]                           if (inherits(master, c("SOCKnode", 
[10:26:16.205]                             "SOCK0node"))) {
[10:26:16.205]                             sendCondition <<- function(cond) {
[10:26:16.205]                               data <- list(type = "VALUE", value = cond, 
[10:26:16.205]                                 success = TRUE)
[10:26:16.205]                               parallel_sendData(master, data)
[10:26:16.205]                             }
[10:26:16.205]                             return(sendCondition)
[10:26:16.205]                           }
[10:26:16.205]                         }
[10:26:16.205]                         frame <- frame + 1L
[10:26:16.205]                         envir <- sys.frame(frame)
[10:26:16.205]                       }
[10:26:16.205]                     }
[10:26:16.205]                     sendCondition <<- function(cond) NULL
[10:26:16.205]                   }
[10:26:16.205]                 })
[10:26:16.205]                 withCallingHandlers({
[10:26:16.205]                   1
[10:26:16.205]                 }, immediateCondition = function(cond) {
[10:26:16.205]                   sendCondition <- ...future.makeSendCondition()
[10:26:16.205]                   sendCondition(cond)
[10:26:16.205]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:16.205]                   {
[10:26:16.205]                     inherits <- base::inherits
[10:26:16.205]                     invokeRestart <- base::invokeRestart
[10:26:16.205]                     is.null <- base::is.null
[10:26:16.205]                     muffled <- FALSE
[10:26:16.205]                     if (inherits(cond, "message")) {
[10:26:16.205]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:16.205]                       if (muffled) 
[10:26:16.205]                         invokeRestart("muffleMessage")
[10:26:16.205]                     }
[10:26:16.205]                     else if (inherits(cond, "warning")) {
[10:26:16.205]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:16.205]                       if (muffled) 
[10:26:16.205]                         invokeRestart("muffleWarning")
[10:26:16.205]                     }
[10:26:16.205]                     else if (inherits(cond, "condition")) {
[10:26:16.205]                       if (!is.null(pattern)) {
[10:26:16.205]                         computeRestarts <- base::computeRestarts
[10:26:16.205]                         grepl <- base::grepl
[10:26:16.205]                         restarts <- computeRestarts(cond)
[10:26:16.205]                         for (restart in restarts) {
[10:26:16.205]                           name <- restart$name
[10:26:16.205]                           if (is.null(name)) 
[10:26:16.205]                             next
[10:26:16.205]                           if (!grepl(pattern, name)) 
[10:26:16.205]                             next
[10:26:16.205]                           invokeRestart(restart)
[10:26:16.205]                           muffled <- TRUE
[10:26:16.205]                           break
[10:26:16.205]                         }
[10:26:16.205]                       }
[10:26:16.205]                     }
[10:26:16.205]                     invisible(muffled)
[10:26:16.205]                   }
[10:26:16.205]                   muffleCondition(cond)
[10:26:16.205]                 })
[10:26:16.205]             }))
[10:26:16.205]             future::FutureResult(value = ...future.value$value, 
[10:26:16.205]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:16.205]                   ...future.rng), globalenv = if (FALSE) 
[10:26:16.205]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:16.205]                     ...future.globalenv.names))
[10:26:16.205]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:16.205]         }, condition = base::local({
[10:26:16.205]             c <- base::c
[10:26:16.205]             inherits <- base::inherits
[10:26:16.205]             invokeRestart <- base::invokeRestart
[10:26:16.205]             length <- base::length
[10:26:16.205]             list <- base::list
[10:26:16.205]             seq.int <- base::seq.int
[10:26:16.205]             signalCondition <- base::signalCondition
[10:26:16.205]             sys.calls <- base::sys.calls
[10:26:16.205]             `[[` <- base::`[[`
[10:26:16.205]             `+` <- base::`+`
[10:26:16.205]             `<<-` <- base::`<<-`
[10:26:16.205]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:16.205]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:16.205]                   3L)]
[10:26:16.205]             }
[10:26:16.205]             function(cond) {
[10:26:16.205]                 is_error <- inherits(cond, "error")
[10:26:16.205]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:16.205]                   NULL)
[10:26:16.205]                 if (is_error) {
[10:26:16.205]                   sessionInformation <- function() {
[10:26:16.205]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:16.205]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:16.205]                       search = base::search(), system = base::Sys.info())
[10:26:16.205]                   }
[10:26:16.205]                   ...future.conditions[[length(...future.conditions) + 
[10:26:16.205]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:16.205]                     cond$call), session = sessionInformation(), 
[10:26:16.205]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:16.205]                   signalCondition(cond)
[10:26:16.205]                 }
[10:26:16.205]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:16.205]                 "immediateCondition"))) {
[10:26:16.205]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:16.205]                   ...future.conditions[[length(...future.conditions) + 
[10:26:16.205]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:16.205]                   if (TRUE && !signal) {
[10:26:16.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:16.205]                     {
[10:26:16.205]                       inherits <- base::inherits
[10:26:16.205]                       invokeRestart <- base::invokeRestart
[10:26:16.205]                       is.null <- base::is.null
[10:26:16.205]                       muffled <- FALSE
[10:26:16.205]                       if (inherits(cond, "message")) {
[10:26:16.205]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:16.205]                         if (muffled) 
[10:26:16.205]                           invokeRestart("muffleMessage")
[10:26:16.205]                       }
[10:26:16.205]                       else if (inherits(cond, "warning")) {
[10:26:16.205]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:16.205]                         if (muffled) 
[10:26:16.205]                           invokeRestart("muffleWarning")
[10:26:16.205]                       }
[10:26:16.205]                       else if (inherits(cond, "condition")) {
[10:26:16.205]                         if (!is.null(pattern)) {
[10:26:16.205]                           computeRestarts <- base::computeRestarts
[10:26:16.205]                           grepl <- base::grepl
[10:26:16.205]                           restarts <- computeRestarts(cond)
[10:26:16.205]                           for (restart in restarts) {
[10:26:16.205]                             name <- restart$name
[10:26:16.205]                             if (is.null(name)) 
[10:26:16.205]                               next
[10:26:16.205]                             if (!grepl(pattern, name)) 
[10:26:16.205]                               next
[10:26:16.205]                             invokeRestart(restart)
[10:26:16.205]                             muffled <- TRUE
[10:26:16.205]                             break
[10:26:16.205]                           }
[10:26:16.205]                         }
[10:26:16.205]                       }
[10:26:16.205]                       invisible(muffled)
[10:26:16.205]                     }
[10:26:16.205]                     muffleCondition(cond, pattern = "^muffle")
[10:26:16.205]                   }
[10:26:16.205]                 }
[10:26:16.205]                 else {
[10:26:16.205]                   if (TRUE) {
[10:26:16.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:16.205]                     {
[10:26:16.205]                       inherits <- base::inherits
[10:26:16.205]                       invokeRestart <- base::invokeRestart
[10:26:16.205]                       is.null <- base::is.null
[10:26:16.205]                       muffled <- FALSE
[10:26:16.205]                       if (inherits(cond, "message")) {
[10:26:16.205]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:16.205]                         if (muffled) 
[10:26:16.205]                           invokeRestart("muffleMessage")
[10:26:16.205]                       }
[10:26:16.205]                       else if (inherits(cond, "warning")) {
[10:26:16.205]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:16.205]                         if (muffled) 
[10:26:16.205]                           invokeRestart("muffleWarning")
[10:26:16.205]                       }
[10:26:16.205]                       else if (inherits(cond, "condition")) {
[10:26:16.205]                         if (!is.null(pattern)) {
[10:26:16.205]                           computeRestarts <- base::computeRestarts
[10:26:16.205]                           grepl <- base::grepl
[10:26:16.205]                           restarts <- computeRestarts(cond)
[10:26:16.205]                           for (restart in restarts) {
[10:26:16.205]                             name <- restart$name
[10:26:16.205]                             if (is.null(name)) 
[10:26:16.205]                               next
[10:26:16.205]                             if (!grepl(pattern, name)) 
[10:26:16.205]                               next
[10:26:16.205]                             invokeRestart(restart)
[10:26:16.205]                             muffled <- TRUE
[10:26:16.205]                             break
[10:26:16.205]                           }
[10:26:16.205]                         }
[10:26:16.205]                       }
[10:26:16.205]                       invisible(muffled)
[10:26:16.205]                     }
[10:26:16.205]                     muffleCondition(cond, pattern = "^muffle")
[10:26:16.205]                   }
[10:26:16.205]                 }
[10:26:16.205]             }
[10:26:16.205]         }))
[10:26:16.205]     }, error = function(ex) {
[10:26:16.205]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:16.205]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:16.205]                 ...future.rng), started = ...future.startTime, 
[10:26:16.205]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:16.205]             version = "1.8"), class = "FutureResult")
[10:26:16.205]     }, finally = {
[10:26:16.205]         if (!identical(...future.workdir, getwd())) 
[10:26:16.205]             setwd(...future.workdir)
[10:26:16.205]         {
[10:26:16.205]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:16.205]                 ...future.oldOptions$nwarnings <- NULL
[10:26:16.205]             }
[10:26:16.205]             base::options(...future.oldOptions)
[10:26:16.205]             if (.Platform$OS.type == "windows") {
[10:26:16.205]                 old_names <- names(...future.oldEnvVars)
[10:26:16.205]                 envs <- base::Sys.getenv()
[10:26:16.205]                 names <- names(envs)
[10:26:16.205]                 common <- intersect(names, old_names)
[10:26:16.205]                 added <- setdiff(names, old_names)
[10:26:16.205]                 removed <- setdiff(old_names, names)
[10:26:16.205]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:16.205]                   envs[common]]
[10:26:16.205]                 NAMES <- toupper(changed)
[10:26:16.205]                 args <- list()
[10:26:16.205]                 for (kk in seq_along(NAMES)) {
[10:26:16.205]                   name <- changed[[kk]]
[10:26:16.205]                   NAME <- NAMES[[kk]]
[10:26:16.205]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.205]                     next
[10:26:16.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:16.205]                 }
[10:26:16.205]                 NAMES <- toupper(added)
[10:26:16.205]                 for (kk in seq_along(NAMES)) {
[10:26:16.205]                   name <- added[[kk]]
[10:26:16.205]                   NAME <- NAMES[[kk]]
[10:26:16.205]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.205]                     next
[10:26:16.205]                   args[[name]] <- ""
[10:26:16.205]                 }
[10:26:16.205]                 NAMES <- toupper(removed)
[10:26:16.205]                 for (kk in seq_along(NAMES)) {
[10:26:16.205]                   name <- removed[[kk]]
[10:26:16.205]                   NAME <- NAMES[[kk]]
[10:26:16.205]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.205]                     next
[10:26:16.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:16.205]                 }
[10:26:16.205]                 if (length(args) > 0) 
[10:26:16.205]                   base::do.call(base::Sys.setenv, args = args)
[10:26:16.205]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:16.205]             }
[10:26:16.205]             else {
[10:26:16.205]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:16.205]             }
[10:26:16.205]             {
[10:26:16.205]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:16.205]                   0L) {
[10:26:16.205]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:16.205]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:16.205]                   base::options(opts)
[10:26:16.205]                 }
[10:26:16.205]                 {
[10:26:16.205]                   {
[10:26:16.205]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:16.205]                     NULL
[10:26:16.205]                   }
[10:26:16.205]                   options(future.plan = NULL)
[10:26:16.205]                   if (is.na(NA_character_)) 
[10:26:16.205]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:16.205]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:16.205]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:16.205]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:16.205]                     envir = parent.frame()) 
[10:26:16.205]                   {
[10:26:16.205]                     if (is.function(workers)) 
[10:26:16.205]                       workers <- workers()
[10:26:16.205]                     workers <- structure(as.integer(workers), 
[10:26:16.205]                       class = class(workers))
[10:26:16.205]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:16.205]                       workers >= 1)
[10:26:16.205]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:16.205]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:16.205]                     }
[10:26:16.205]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:16.205]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:16.205]                       envir = envir)
[10:26:16.205]                     if (!future$lazy) 
[10:26:16.205]                       future <- run(future)
[10:26:16.205]                     invisible(future)
[10:26:16.205]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:16.205]                 }
[10:26:16.205]             }
[10:26:16.205]         }
[10:26:16.205]     })
[10:26:16.205]     if (TRUE) {
[10:26:16.205]         base::sink(type = "output", split = FALSE)
[10:26:16.205]         if (TRUE) {
[10:26:16.205]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:16.205]         }
[10:26:16.205]         else {
[10:26:16.205]             ...future.result["stdout"] <- base::list(NULL)
[10:26:16.205]         }
[10:26:16.205]         base::close(...future.stdout)
[10:26:16.205]         ...future.stdout <- NULL
[10:26:16.205]     }
[10:26:16.205]     ...future.result$conditions <- ...future.conditions
[10:26:16.205]     ...future.result$finished <- base::Sys.time()
[10:26:16.205]     ...future.result
[10:26:16.205] }
[10:26:16.208] MultisessionFuture started
[10:26:16.209] - Launch lazy future ... done
[10:26:16.209] run() for ‘MultisessionFuture’ ... done
[10:26:16.254] receiveMessageFromWorker() for ClusterFuture ...
[10:26:16.254] - Validating connection of MultisessionFuture
[10:26:16.254] - received message: FutureResult
[10:26:16.255] - Received FutureResult
[10:26:16.255] - Erased future from FutureRegistry
[10:26:16.255] result() for ClusterFuture ...
[10:26:16.255] - result already collected: FutureResult
[10:26:16.255] result() for ClusterFuture ... done
[10:26:16.255] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:16.255] Future #1
[10:26:16.255] result() for ClusterFuture ...
[10:26:16.255] - result already collected: FutureResult
[10:26:16.255] result() for ClusterFuture ... done
[10:26:16.255] result() for ClusterFuture ...
[10:26:16.256] - result already collected: FutureResult
[10:26:16.256] result() for ClusterFuture ... done
[10:26:16.256] A MultisessionFuture was resolved
[10:26:16.256]  length: 0 (resolved future 1)
[10:26:16.256] resolve() on list ... DONE
[10:26:16.256] - globals: [1] ‘a’
[10:26:16.256] Resolving futures part of globals (recursively) ... DONE
[10:26:16.258] The total size of the 1 globals is 1.56 MiB (1641008 bytes)
[10:26:16.259] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.56 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.56 MiB of class ‘environment’)
[10:26:16.259] - globals: [1] ‘a’
[10:26:16.259] - packages: [1] ‘future’
[10:26:16.259] getGlobalsAndPackages() ... DONE
[10:26:16.259] run() for ‘Future’ ...
[10:26:16.259] - state: ‘created’
[10:26:16.259] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:16.278] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:16.278] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:16.278]   - Field: ‘node’
[10:26:16.278]   - Field: ‘label’
[10:26:16.278]   - Field: ‘local’
[10:26:16.278]   - Field: ‘owner’
[10:26:16.278]   - Field: ‘envir’
[10:26:16.279]   - Field: ‘workers’
[10:26:16.279]   - Field: ‘packages’
[10:26:16.279]   - Field: ‘gc’
[10:26:16.279]   - Field: ‘conditions’
[10:26:16.279]   - Field: ‘persistent’
[10:26:16.279]   - Field: ‘expr’
[10:26:16.279]   - Field: ‘uuid’
[10:26:16.279]   - Field: ‘seed’
[10:26:16.279]   - Field: ‘version’
[10:26:16.279]   - Field: ‘result’
[10:26:16.279]   - Field: ‘asynchronous’
[10:26:16.280]   - Field: ‘calls’
[10:26:16.280]   - Field: ‘globals’
[10:26:16.280]   - Field: ‘stdout’
[10:26:16.280]   - Field: ‘earlySignal’
[10:26:16.280]   - Field: ‘lazy’
[10:26:16.280]   - Field: ‘state’
[10:26:16.280] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:16.280] - Launch lazy future ...
[10:26:16.280] Packages needed by the future expression (n = 1): ‘future’
[10:26:16.281] Packages needed by future strategies (n = 0): <none>
[10:26:16.281] {
[10:26:16.281]     {
[10:26:16.281]         {
[10:26:16.281]             ...future.startTime <- base::Sys.time()
[10:26:16.281]             {
[10:26:16.281]                 {
[10:26:16.281]                   {
[10:26:16.281]                     {
[10:26:16.281]                       {
[10:26:16.281]                         base::local({
[10:26:16.281]                           has_future <- base::requireNamespace("future", 
[10:26:16.281]                             quietly = TRUE)
[10:26:16.281]                           if (has_future) {
[10:26:16.281]                             ns <- base::getNamespace("future")
[10:26:16.281]                             version <- ns[[".package"]][["version"]]
[10:26:16.281]                             if (is.null(version)) 
[10:26:16.281]                               version <- utils::packageVersion("future")
[10:26:16.281]                           }
[10:26:16.281]                           else {
[10:26:16.281]                             version <- NULL
[10:26:16.281]                           }
[10:26:16.281]                           if (!has_future || version < "1.8.0") {
[10:26:16.281]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:16.281]                               "", base::R.version$version.string), 
[10:26:16.281]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:16.281]                                 base::R.version$platform, 8 * 
[10:26:16.281]                                   base::.Machine$sizeof.pointer), 
[10:26:16.281]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:16.281]                                 "release", "version")], collapse = " "), 
[10:26:16.281]                               hostname = base::Sys.info()[["nodename"]])
[10:26:16.281]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:16.281]                               info)
[10:26:16.281]                             info <- base::paste(info, collapse = "; ")
[10:26:16.281]                             if (!has_future) {
[10:26:16.281]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:16.281]                                 info)
[10:26:16.281]                             }
[10:26:16.281]                             else {
[10:26:16.281]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:16.281]                                 info, version)
[10:26:16.281]                             }
[10:26:16.281]                             base::stop(msg)
[10:26:16.281]                           }
[10:26:16.281]                         })
[10:26:16.281]                       }
[10:26:16.281]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:16.281]                       base::options(mc.cores = 1L)
[10:26:16.281]                     }
[10:26:16.281]                     base::local({
[10:26:16.281]                       for (pkg in "future") {
[10:26:16.281]                         base::loadNamespace(pkg)
[10:26:16.281]                         base::library(pkg, character.only = TRUE)
[10:26:16.281]                       }
[10:26:16.281]                     })
[10:26:16.281]                   }
[10:26:16.281]                   options(future.plan = NULL)
[10:26:16.281]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:16.281]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:16.281]                 }
[10:26:16.281]                 ...future.workdir <- getwd()
[10:26:16.281]             }
[10:26:16.281]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:16.281]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:16.281]         }
[10:26:16.281]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:16.281]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:16.281]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:16.281]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:16.281]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:16.281]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:16.281]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:16.281]             base::names(...future.oldOptions))
[10:26:16.281]     }
[10:26:16.281]     if (FALSE) {
[10:26:16.281]     }
[10:26:16.281]     else {
[10:26:16.281]         if (TRUE) {
[10:26:16.281]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:16.281]                 open = "w")
[10:26:16.281]         }
[10:26:16.281]         else {
[10:26:16.281]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:16.281]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:16.281]         }
[10:26:16.281]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:16.281]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:16.281]             base::sink(type = "output", split = FALSE)
[10:26:16.281]             base::close(...future.stdout)
[10:26:16.281]         }, add = TRUE)
[10:26:16.281]     }
[10:26:16.281]     ...future.frame <- base::sys.nframe()
[10:26:16.281]     ...future.conditions <- base::list()
[10:26:16.281]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:16.281]     if (FALSE) {
[10:26:16.281]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:16.281]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:16.281]     }
[10:26:16.281]     ...future.result <- base::tryCatch({
[10:26:16.281]         base::withCallingHandlers({
[10:26:16.281]             ...future.value <- base::withVisible(base::local({
[10:26:16.281]                 ...future.makeSendCondition <- base::local({
[10:26:16.281]                   sendCondition <- NULL
[10:26:16.281]                   function(frame = 1L) {
[10:26:16.281]                     if (is.function(sendCondition)) 
[10:26:16.281]                       return(sendCondition)
[10:26:16.281]                     ns <- getNamespace("parallel")
[10:26:16.281]                     if (exists("sendData", mode = "function", 
[10:26:16.281]                       envir = ns)) {
[10:26:16.281]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:16.281]                         envir = ns)
[10:26:16.281]                       envir <- sys.frame(frame)
[10:26:16.281]                       master <- NULL
[10:26:16.281]                       while (!identical(envir, .GlobalEnv) && 
[10:26:16.281]                         !identical(envir, emptyenv())) {
[10:26:16.281]                         if (exists("master", mode = "list", envir = envir, 
[10:26:16.281]                           inherits = FALSE)) {
[10:26:16.281]                           master <- get("master", mode = "list", 
[10:26:16.281]                             envir = envir, inherits = FALSE)
[10:26:16.281]                           if (inherits(master, c("SOCKnode", 
[10:26:16.281]                             "SOCK0node"))) {
[10:26:16.281]                             sendCondition <<- function(cond) {
[10:26:16.281]                               data <- list(type = "VALUE", value = cond, 
[10:26:16.281]                                 success = TRUE)
[10:26:16.281]                               parallel_sendData(master, data)
[10:26:16.281]                             }
[10:26:16.281]                             return(sendCondition)
[10:26:16.281]                           }
[10:26:16.281]                         }
[10:26:16.281]                         frame <- frame + 1L
[10:26:16.281]                         envir <- sys.frame(frame)
[10:26:16.281]                       }
[10:26:16.281]                     }
[10:26:16.281]                     sendCondition <<- function(cond) NULL
[10:26:16.281]                   }
[10:26:16.281]                 })
[10:26:16.281]                 withCallingHandlers({
[10:26:16.281]                   value(a) + 1
[10:26:16.281]                 }, immediateCondition = function(cond) {
[10:26:16.281]                   sendCondition <- ...future.makeSendCondition()
[10:26:16.281]                   sendCondition(cond)
[10:26:16.281]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:16.281]                   {
[10:26:16.281]                     inherits <- base::inherits
[10:26:16.281]                     invokeRestart <- base::invokeRestart
[10:26:16.281]                     is.null <- base::is.null
[10:26:16.281]                     muffled <- FALSE
[10:26:16.281]                     if (inherits(cond, "message")) {
[10:26:16.281]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:16.281]                       if (muffled) 
[10:26:16.281]                         invokeRestart("muffleMessage")
[10:26:16.281]                     }
[10:26:16.281]                     else if (inherits(cond, "warning")) {
[10:26:16.281]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:16.281]                       if (muffled) 
[10:26:16.281]                         invokeRestart("muffleWarning")
[10:26:16.281]                     }
[10:26:16.281]                     else if (inherits(cond, "condition")) {
[10:26:16.281]                       if (!is.null(pattern)) {
[10:26:16.281]                         computeRestarts <- base::computeRestarts
[10:26:16.281]                         grepl <- base::grepl
[10:26:16.281]                         restarts <- computeRestarts(cond)
[10:26:16.281]                         for (restart in restarts) {
[10:26:16.281]                           name <- restart$name
[10:26:16.281]                           if (is.null(name)) 
[10:26:16.281]                             next
[10:26:16.281]                           if (!grepl(pattern, name)) 
[10:26:16.281]                             next
[10:26:16.281]                           invokeRestart(restart)
[10:26:16.281]                           muffled <- TRUE
[10:26:16.281]                           break
[10:26:16.281]                         }
[10:26:16.281]                       }
[10:26:16.281]                     }
[10:26:16.281]                     invisible(muffled)
[10:26:16.281]                   }
[10:26:16.281]                   muffleCondition(cond)
[10:26:16.281]                 })
[10:26:16.281]             }))
[10:26:16.281]             future::FutureResult(value = ...future.value$value, 
[10:26:16.281]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:16.281]                   ...future.rng), globalenv = if (FALSE) 
[10:26:16.281]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:16.281]                     ...future.globalenv.names))
[10:26:16.281]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:16.281]         }, condition = base::local({
[10:26:16.281]             c <- base::c
[10:26:16.281]             inherits <- base::inherits
[10:26:16.281]             invokeRestart <- base::invokeRestart
[10:26:16.281]             length <- base::length
[10:26:16.281]             list <- base::list
[10:26:16.281]             seq.int <- base::seq.int
[10:26:16.281]             signalCondition <- base::signalCondition
[10:26:16.281]             sys.calls <- base::sys.calls
[10:26:16.281]             `[[` <- base::`[[`
[10:26:16.281]             `+` <- base::`+`
[10:26:16.281]             `<<-` <- base::`<<-`
[10:26:16.281]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:16.281]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:16.281]                   3L)]
[10:26:16.281]             }
[10:26:16.281]             function(cond) {
[10:26:16.281]                 is_error <- inherits(cond, "error")
[10:26:16.281]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:16.281]                   NULL)
[10:26:16.281]                 if (is_error) {
[10:26:16.281]                   sessionInformation <- function() {
[10:26:16.281]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:16.281]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:16.281]                       search = base::search(), system = base::Sys.info())
[10:26:16.281]                   }
[10:26:16.281]                   ...future.conditions[[length(...future.conditions) + 
[10:26:16.281]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:16.281]                     cond$call), session = sessionInformation(), 
[10:26:16.281]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:16.281]                   signalCondition(cond)
[10:26:16.281]                 }
[10:26:16.281]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:16.281]                 "immediateCondition"))) {
[10:26:16.281]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:16.281]                   ...future.conditions[[length(...future.conditions) + 
[10:26:16.281]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:16.281]                   if (TRUE && !signal) {
[10:26:16.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:16.281]                     {
[10:26:16.281]                       inherits <- base::inherits
[10:26:16.281]                       invokeRestart <- base::invokeRestart
[10:26:16.281]                       is.null <- base::is.null
[10:26:16.281]                       muffled <- FALSE
[10:26:16.281]                       if (inherits(cond, "message")) {
[10:26:16.281]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:16.281]                         if (muffled) 
[10:26:16.281]                           invokeRestart("muffleMessage")
[10:26:16.281]                       }
[10:26:16.281]                       else if (inherits(cond, "warning")) {
[10:26:16.281]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:16.281]                         if (muffled) 
[10:26:16.281]                           invokeRestart("muffleWarning")
[10:26:16.281]                       }
[10:26:16.281]                       else if (inherits(cond, "condition")) {
[10:26:16.281]                         if (!is.null(pattern)) {
[10:26:16.281]                           computeRestarts <- base::computeRestarts
[10:26:16.281]                           grepl <- base::grepl
[10:26:16.281]                           restarts <- computeRestarts(cond)
[10:26:16.281]                           for (restart in restarts) {
[10:26:16.281]                             name <- restart$name
[10:26:16.281]                             if (is.null(name)) 
[10:26:16.281]                               next
[10:26:16.281]                             if (!grepl(pattern, name)) 
[10:26:16.281]                               next
[10:26:16.281]                             invokeRestart(restart)
[10:26:16.281]                             muffled <- TRUE
[10:26:16.281]                             break
[10:26:16.281]                           }
[10:26:16.281]                         }
[10:26:16.281]                       }
[10:26:16.281]                       invisible(muffled)
[10:26:16.281]                     }
[10:26:16.281]                     muffleCondition(cond, pattern = "^muffle")
[10:26:16.281]                   }
[10:26:16.281]                 }
[10:26:16.281]                 else {
[10:26:16.281]                   if (TRUE) {
[10:26:16.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:16.281]                     {
[10:26:16.281]                       inherits <- base::inherits
[10:26:16.281]                       invokeRestart <- base::invokeRestart
[10:26:16.281]                       is.null <- base::is.null
[10:26:16.281]                       muffled <- FALSE
[10:26:16.281]                       if (inherits(cond, "message")) {
[10:26:16.281]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:16.281]                         if (muffled) 
[10:26:16.281]                           invokeRestart("muffleMessage")
[10:26:16.281]                       }
[10:26:16.281]                       else if (inherits(cond, "warning")) {
[10:26:16.281]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:16.281]                         if (muffled) 
[10:26:16.281]                           invokeRestart("muffleWarning")
[10:26:16.281]                       }
[10:26:16.281]                       else if (inherits(cond, "condition")) {
[10:26:16.281]                         if (!is.null(pattern)) {
[10:26:16.281]                           computeRestarts <- base::computeRestarts
[10:26:16.281]                           grepl <- base::grepl
[10:26:16.281]                           restarts <- computeRestarts(cond)
[10:26:16.281]                           for (restart in restarts) {
[10:26:16.281]                             name <- restart$name
[10:26:16.281]                             if (is.null(name)) 
[10:26:16.281]                               next
[10:26:16.281]                             if (!grepl(pattern, name)) 
[10:26:16.281]                               next
[10:26:16.281]                             invokeRestart(restart)
[10:26:16.281]                             muffled <- TRUE
[10:26:16.281]                             break
[10:26:16.281]                           }
[10:26:16.281]                         }
[10:26:16.281]                       }
[10:26:16.281]                       invisible(muffled)
[10:26:16.281]                     }
[10:26:16.281]                     muffleCondition(cond, pattern = "^muffle")
[10:26:16.281]                   }
[10:26:16.281]                 }
[10:26:16.281]             }
[10:26:16.281]         }))
[10:26:16.281]     }, error = function(ex) {
[10:26:16.281]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:16.281]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:16.281]                 ...future.rng), started = ...future.startTime, 
[10:26:16.281]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:16.281]             version = "1.8"), class = "FutureResult")
[10:26:16.281]     }, finally = {
[10:26:16.281]         if (!identical(...future.workdir, getwd())) 
[10:26:16.281]             setwd(...future.workdir)
[10:26:16.281]         {
[10:26:16.281]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:16.281]                 ...future.oldOptions$nwarnings <- NULL
[10:26:16.281]             }
[10:26:16.281]             base::options(...future.oldOptions)
[10:26:16.281]             if (.Platform$OS.type == "windows") {
[10:26:16.281]                 old_names <- names(...future.oldEnvVars)
[10:26:16.281]                 envs <- base::Sys.getenv()
[10:26:16.281]                 names <- names(envs)
[10:26:16.281]                 common <- intersect(names, old_names)
[10:26:16.281]                 added <- setdiff(names, old_names)
[10:26:16.281]                 removed <- setdiff(old_names, names)
[10:26:16.281]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:16.281]                   envs[common]]
[10:26:16.281]                 NAMES <- toupper(changed)
[10:26:16.281]                 args <- list()
[10:26:16.281]                 for (kk in seq_along(NAMES)) {
[10:26:16.281]                   name <- changed[[kk]]
[10:26:16.281]                   NAME <- NAMES[[kk]]
[10:26:16.281]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.281]                     next
[10:26:16.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:16.281]                 }
[10:26:16.281]                 NAMES <- toupper(added)
[10:26:16.281]                 for (kk in seq_along(NAMES)) {
[10:26:16.281]                   name <- added[[kk]]
[10:26:16.281]                   NAME <- NAMES[[kk]]
[10:26:16.281]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.281]                     next
[10:26:16.281]                   args[[name]] <- ""
[10:26:16.281]                 }
[10:26:16.281]                 NAMES <- toupper(removed)
[10:26:16.281]                 for (kk in seq_along(NAMES)) {
[10:26:16.281]                   name <- removed[[kk]]
[10:26:16.281]                   NAME <- NAMES[[kk]]
[10:26:16.281]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.281]                     next
[10:26:16.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:16.281]                 }
[10:26:16.281]                 if (length(args) > 0) 
[10:26:16.281]                   base::do.call(base::Sys.setenv, args = args)
[10:26:16.281]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:16.281]             }
[10:26:16.281]             else {
[10:26:16.281]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:16.281]             }
[10:26:16.281]             {
[10:26:16.281]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:16.281]                   0L) {
[10:26:16.281]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:16.281]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:16.281]                   base::options(opts)
[10:26:16.281]                 }
[10:26:16.281]                 {
[10:26:16.281]                   {
[10:26:16.281]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:16.281]                     NULL
[10:26:16.281]                   }
[10:26:16.281]                   options(future.plan = NULL)
[10:26:16.281]                   if (is.na(NA_character_)) 
[10:26:16.281]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:16.281]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:16.281]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:16.281]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:16.281]                     envir = parent.frame()) 
[10:26:16.281]                   {
[10:26:16.281]                     if (is.function(workers)) 
[10:26:16.281]                       workers <- workers()
[10:26:16.281]                     workers <- structure(as.integer(workers), 
[10:26:16.281]                       class = class(workers))
[10:26:16.281]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:16.281]                       workers >= 1)
[10:26:16.281]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:16.281]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:16.281]                     }
[10:26:16.281]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:16.281]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:16.281]                       envir = envir)
[10:26:16.281]                     if (!future$lazy) 
[10:26:16.281]                       future <- run(future)
[10:26:16.281]                     invisible(future)
[10:26:16.281]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:16.281]                 }
[10:26:16.281]             }
[10:26:16.281]         }
[10:26:16.281]     })
[10:26:16.281]     if (TRUE) {
[10:26:16.281]         base::sink(type = "output", split = FALSE)
[10:26:16.281]         if (TRUE) {
[10:26:16.281]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:16.281]         }
[10:26:16.281]         else {
[10:26:16.281]             ...future.result["stdout"] <- base::list(NULL)
[10:26:16.281]         }
[10:26:16.281]         base::close(...future.stdout)
[10:26:16.281]         ...future.stdout <- NULL
[10:26:16.281]     }
[10:26:16.281]     ...future.result$conditions <- ...future.conditions
[10:26:16.281]     ...future.result$finished <- base::Sys.time()
[10:26:16.281]     ...future.result
[10:26:16.281] }
[10:26:16.284] Exporting 1 global objects (1.56 MiB) to cluster node #1 ...
[10:26:16.285] Exporting ‘a’ (1.56 MiB) to cluster node #1 ...
[10:26:16.338] Exporting ‘a’ (1.56 MiB) to cluster node #1 ... DONE
[10:26:16.338] Exporting 1 global objects (1.56 MiB) to cluster node #1 ... DONE
[10:26:16.339] MultisessionFuture started
[10:26:16.339] - Launch lazy future ... done
[10:26:16.339] run() for ‘MultisessionFuture’ ... done
[10:26:16.339] result() for ClusterFuture ...
[10:26:16.339] receiveMessageFromWorker() for ClusterFuture ...
[10:26:16.339] - Validating connection of MultisessionFuture
[10:26:16.387] - received message: FutureResult
[10:26:16.387] - Received FutureResult
[10:26:16.387] - Erased future from FutureRegistry
[10:26:16.387] result() for ClusterFuture ...
[10:26:16.387] - result already collected: FutureResult
[10:26:16.387] result() for ClusterFuture ... done
[10:26:16.387] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:16.387] result() for ClusterFuture ... done
[10:26:16.388] result() for ClusterFuture ...
[10:26:16.388] - result already collected: FutureResult
[10:26:16.388] result() for ClusterFuture ... done
value(b) = 2
[10:26:16.388] result() for ClusterFuture ...
[10:26:16.388] - result already collected: FutureResult
[10:26:16.388] result() for ClusterFuture ... done
[10:26:16.388] result() for ClusterFuture ...
[10:26:16.388] - result already collected: FutureResult
[10:26:16.388] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:16.389] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:16.389] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:16.390] - globals found: [2] ‘{’, ‘pkg’
[10:26:16.390] Searching for globals ... DONE
[10:26:16.390] Resolving globals: TRUE
[10:26:16.390] Resolving any globals that are futures ...
[10:26:16.390] - globals: [2] ‘{’, ‘pkg’
[10:26:16.390] Resolving any globals that are futures ... DONE
[10:26:16.390] Resolving futures part of globals (recursively) ...
[10:26:16.391] resolve() on list ...
[10:26:16.391]  recursive: 99
[10:26:16.391]  length: 1
[10:26:16.391]  elements: ‘pkg’
[10:26:16.391]  length: 0 (resolved future 1)
[10:26:16.391] resolve() on list ... DONE
[10:26:16.391] - globals: [1] ‘pkg’
[10:26:16.391] Resolving futures part of globals (recursively) ... DONE
[10:26:16.391] The total size of the 1 globals is 112 bytes (112 bytes)
[10:26:16.392] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[10:26:16.392] - globals: [1] ‘pkg’
[10:26:16.392] 
[10:26:16.392] getGlobalsAndPackages() ... DONE
[10:26:16.392] Packages needed by the future expression (n = 0): <none>
[10:26:16.393] Packages needed by future strategies (n = 0): <none>
[10:26:16.393] {
[10:26:16.393]     {
[10:26:16.393]         {
[10:26:16.393]             ...future.startTime <- base::Sys.time()
[10:26:16.393]             {
[10:26:16.393]                 {
[10:26:16.393]                   {
[10:26:16.393]                     base::local({
[10:26:16.393]                       has_future <- base::requireNamespace("future", 
[10:26:16.393]                         quietly = TRUE)
[10:26:16.393]                       if (has_future) {
[10:26:16.393]                         ns <- base::getNamespace("future")
[10:26:16.393]                         version <- ns[[".package"]][["version"]]
[10:26:16.393]                         if (is.null(version)) 
[10:26:16.393]                           version <- utils::packageVersion("future")
[10:26:16.393]                       }
[10:26:16.393]                       else {
[10:26:16.393]                         version <- NULL
[10:26:16.393]                       }
[10:26:16.393]                       if (!has_future || version < "1.8.0") {
[10:26:16.393]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:16.393]                           "", base::R.version$version.string), 
[10:26:16.393]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:16.393]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:16.393]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:16.393]                             "release", "version")], collapse = " "), 
[10:26:16.393]                           hostname = base::Sys.info()[["nodename"]])
[10:26:16.393]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:16.393]                           info)
[10:26:16.393]                         info <- base::paste(info, collapse = "; ")
[10:26:16.393]                         if (!has_future) {
[10:26:16.393]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:16.393]                             info)
[10:26:16.393]                         }
[10:26:16.393]                         else {
[10:26:16.393]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:16.393]                             info, version)
[10:26:16.393]                         }
[10:26:16.393]                         base::stop(msg)
[10:26:16.393]                       }
[10:26:16.393]                     })
[10:26:16.393]                   }
[10:26:16.393]                   options(future.plan = NULL)
[10:26:16.393]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:16.393]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:16.393]                 }
[10:26:16.393]                 ...future.workdir <- getwd()
[10:26:16.393]             }
[10:26:16.393]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:16.393]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:16.393]         }
[10:26:16.393]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:16.393]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:16.393]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:16.393]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:16.393]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:16.393]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:16.393]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:16.393]             base::names(...future.oldOptions))
[10:26:16.393]     }
[10:26:16.393]     if (FALSE) {
[10:26:16.393]     }
[10:26:16.393]     else {
[10:26:16.393]         if (TRUE) {
[10:26:16.393]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:16.393]                 open = "w")
[10:26:16.393]         }
[10:26:16.393]         else {
[10:26:16.393]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:16.393]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:16.393]         }
[10:26:16.393]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:16.393]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:16.393]             base::sink(type = "output", split = FALSE)
[10:26:16.393]             base::close(...future.stdout)
[10:26:16.393]         }, add = TRUE)
[10:26:16.393]     }
[10:26:16.393]     ...future.frame <- base::sys.nframe()
[10:26:16.393]     ...future.conditions <- base::list()
[10:26:16.393]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:16.393]     if (FALSE) {
[10:26:16.393]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:16.393]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:16.393]     }
[10:26:16.393]     ...future.result <- base::tryCatch({
[10:26:16.393]         base::withCallingHandlers({
[10:26:16.393]             ...future.value <- base::withVisible(base::local({
[10:26:16.393]                 pkg
[10:26:16.393]             }))
[10:26:16.393]             future::FutureResult(value = ...future.value$value, 
[10:26:16.393]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:16.393]                   ...future.rng), globalenv = if (FALSE) 
[10:26:16.393]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:16.393]                     ...future.globalenv.names))
[10:26:16.393]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:16.393]         }, condition = base::local({
[10:26:16.393]             c <- base::c
[10:26:16.393]             inherits <- base::inherits
[10:26:16.393]             invokeRestart <- base::invokeRestart
[10:26:16.393]             length <- base::length
[10:26:16.393]             list <- base::list
[10:26:16.393]             seq.int <- base::seq.int
[10:26:16.393]             signalCondition <- base::signalCondition
[10:26:16.393]             sys.calls <- base::sys.calls
[10:26:16.393]             `[[` <- base::`[[`
[10:26:16.393]             `+` <- base::`+`
[10:26:16.393]             `<<-` <- base::`<<-`
[10:26:16.393]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:16.393]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:16.393]                   3L)]
[10:26:16.393]             }
[10:26:16.393]             function(cond) {
[10:26:16.393]                 is_error <- inherits(cond, "error")
[10:26:16.393]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:16.393]                   NULL)
[10:26:16.393]                 if (is_error) {
[10:26:16.393]                   sessionInformation <- function() {
[10:26:16.393]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:16.393]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:16.393]                       search = base::search(), system = base::Sys.info())
[10:26:16.393]                   }
[10:26:16.393]                   ...future.conditions[[length(...future.conditions) + 
[10:26:16.393]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:16.393]                     cond$call), session = sessionInformation(), 
[10:26:16.393]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:16.393]                   signalCondition(cond)
[10:26:16.393]                 }
[10:26:16.393]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:16.393]                 "immediateCondition"))) {
[10:26:16.393]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:16.393]                   ...future.conditions[[length(...future.conditions) + 
[10:26:16.393]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:16.393]                   if (TRUE && !signal) {
[10:26:16.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:16.393]                     {
[10:26:16.393]                       inherits <- base::inherits
[10:26:16.393]                       invokeRestart <- base::invokeRestart
[10:26:16.393]                       is.null <- base::is.null
[10:26:16.393]                       muffled <- FALSE
[10:26:16.393]                       if (inherits(cond, "message")) {
[10:26:16.393]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:16.393]                         if (muffled) 
[10:26:16.393]                           invokeRestart("muffleMessage")
[10:26:16.393]                       }
[10:26:16.393]                       else if (inherits(cond, "warning")) {
[10:26:16.393]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:16.393]                         if (muffled) 
[10:26:16.393]                           invokeRestart("muffleWarning")
[10:26:16.393]                       }
[10:26:16.393]                       else if (inherits(cond, "condition")) {
[10:26:16.393]                         if (!is.null(pattern)) {
[10:26:16.393]                           computeRestarts <- base::computeRestarts
[10:26:16.393]                           grepl <- base::grepl
[10:26:16.393]                           restarts <- computeRestarts(cond)
[10:26:16.393]                           for (restart in restarts) {
[10:26:16.393]                             name <- restart$name
[10:26:16.393]                             if (is.null(name)) 
[10:26:16.393]                               next
[10:26:16.393]                             if (!grepl(pattern, name)) 
[10:26:16.393]                               next
[10:26:16.393]                             invokeRestart(restart)
[10:26:16.393]                             muffled <- TRUE
[10:26:16.393]                             break
[10:26:16.393]                           }
[10:26:16.393]                         }
[10:26:16.393]                       }
[10:26:16.393]                       invisible(muffled)
[10:26:16.393]                     }
[10:26:16.393]                     muffleCondition(cond, pattern = "^muffle")
[10:26:16.393]                   }
[10:26:16.393]                 }
[10:26:16.393]                 else {
[10:26:16.393]                   if (TRUE) {
[10:26:16.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:16.393]                     {
[10:26:16.393]                       inherits <- base::inherits
[10:26:16.393]                       invokeRestart <- base::invokeRestart
[10:26:16.393]                       is.null <- base::is.null
[10:26:16.393]                       muffled <- FALSE
[10:26:16.393]                       if (inherits(cond, "message")) {
[10:26:16.393]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:16.393]                         if (muffled) 
[10:26:16.393]                           invokeRestart("muffleMessage")
[10:26:16.393]                       }
[10:26:16.393]                       else if (inherits(cond, "warning")) {
[10:26:16.393]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:16.393]                         if (muffled) 
[10:26:16.393]                           invokeRestart("muffleWarning")
[10:26:16.393]                       }
[10:26:16.393]                       else if (inherits(cond, "condition")) {
[10:26:16.393]                         if (!is.null(pattern)) {
[10:26:16.393]                           computeRestarts <- base::computeRestarts
[10:26:16.393]                           grepl <- base::grepl
[10:26:16.393]                           restarts <- computeRestarts(cond)
[10:26:16.393]                           for (restart in restarts) {
[10:26:16.393]                             name <- restart$name
[10:26:16.393]                             if (is.null(name)) 
[10:26:16.393]                               next
[10:26:16.393]                             if (!grepl(pattern, name)) 
[10:26:16.393]                               next
[10:26:16.393]                             invokeRestart(restart)
[10:26:16.393]                             muffled <- TRUE
[10:26:16.393]                             break
[10:26:16.393]                           }
[10:26:16.393]                         }
[10:26:16.393]                       }
[10:26:16.393]                       invisible(muffled)
[10:26:16.393]                     }
[10:26:16.393]                     muffleCondition(cond, pattern = "^muffle")
[10:26:16.393]                   }
[10:26:16.393]                 }
[10:26:16.393]             }
[10:26:16.393]         }))
[10:26:16.393]     }, error = function(ex) {
[10:26:16.393]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:16.393]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:16.393]                 ...future.rng), started = ...future.startTime, 
[10:26:16.393]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:16.393]             version = "1.8"), class = "FutureResult")
[10:26:16.393]     }, finally = {
[10:26:16.393]         if (!identical(...future.workdir, getwd())) 
[10:26:16.393]             setwd(...future.workdir)
[10:26:16.393]         {
[10:26:16.393]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:16.393]                 ...future.oldOptions$nwarnings <- NULL
[10:26:16.393]             }
[10:26:16.393]             base::options(...future.oldOptions)
[10:26:16.393]             if (.Platform$OS.type == "windows") {
[10:26:16.393]                 old_names <- names(...future.oldEnvVars)
[10:26:16.393]                 envs <- base::Sys.getenv()
[10:26:16.393]                 names <- names(envs)
[10:26:16.393]                 common <- intersect(names, old_names)
[10:26:16.393]                 added <- setdiff(names, old_names)
[10:26:16.393]                 removed <- setdiff(old_names, names)
[10:26:16.393]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:16.393]                   envs[common]]
[10:26:16.393]                 NAMES <- toupper(changed)
[10:26:16.393]                 args <- list()
[10:26:16.393]                 for (kk in seq_along(NAMES)) {
[10:26:16.393]                   name <- changed[[kk]]
[10:26:16.393]                   NAME <- NAMES[[kk]]
[10:26:16.393]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.393]                     next
[10:26:16.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:16.393]                 }
[10:26:16.393]                 NAMES <- toupper(added)
[10:26:16.393]                 for (kk in seq_along(NAMES)) {
[10:26:16.393]                   name <- added[[kk]]
[10:26:16.393]                   NAME <- NAMES[[kk]]
[10:26:16.393]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.393]                     next
[10:26:16.393]                   args[[name]] <- ""
[10:26:16.393]                 }
[10:26:16.393]                 NAMES <- toupper(removed)
[10:26:16.393]                 for (kk in seq_along(NAMES)) {
[10:26:16.393]                   name <- removed[[kk]]
[10:26:16.393]                   NAME <- NAMES[[kk]]
[10:26:16.393]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.393]                     next
[10:26:16.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:16.393]                 }
[10:26:16.393]                 if (length(args) > 0) 
[10:26:16.393]                   base::do.call(base::Sys.setenv, args = args)
[10:26:16.393]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:16.393]             }
[10:26:16.393]             else {
[10:26:16.393]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:16.393]             }
[10:26:16.393]             {
[10:26:16.393]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:16.393]                   0L) {
[10:26:16.393]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:16.393]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:16.393]                   base::options(opts)
[10:26:16.393]                 }
[10:26:16.393]                 {
[10:26:16.393]                   {
[10:26:16.393]                     NULL
[10:26:16.393]                     RNGkind("Mersenne-Twister")
[10:26:16.393]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:16.393]                       inherits = FALSE)
[10:26:16.393]                   }
[10:26:16.393]                   options(future.plan = NULL)
[10:26:16.393]                   if (is.na(NA_character_)) 
[10:26:16.393]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:16.393]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:16.393]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:16.393]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:16.393]                     envir = parent.frame()) 
[10:26:16.393]                   {
[10:26:16.393]                     if (is.function(workers)) 
[10:26:16.393]                       workers <- workers()
[10:26:16.393]                     workers <- structure(as.integer(workers), 
[10:26:16.393]                       class = class(workers))
[10:26:16.393]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:16.393]                       workers >= 1)
[10:26:16.393]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:16.393]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:16.393]                     }
[10:26:16.393]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:16.393]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:16.393]                       envir = envir)
[10:26:16.393]                     if (!future$lazy) 
[10:26:16.393]                       future <- run(future)
[10:26:16.393]                     invisible(future)
[10:26:16.393]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:16.393]                 }
[10:26:16.393]             }
[10:26:16.393]         }
[10:26:16.393]     })
[10:26:16.393]     if (TRUE) {
[10:26:16.393]         base::sink(type = "output", split = FALSE)
[10:26:16.393]         if (TRUE) {
[10:26:16.393]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:16.393]         }
[10:26:16.393]         else {
[10:26:16.393]             ...future.result["stdout"] <- base::list(NULL)
[10:26:16.393]         }
[10:26:16.393]         base::close(...future.stdout)
[10:26:16.393]         ...future.stdout <- NULL
[10:26:16.393]     }
[10:26:16.393]     ...future.result$conditions <- ...future.conditions
[10:26:16.393]     ...future.result$finished <- base::Sys.time()
[10:26:16.393]     ...future.result
[10:26:16.393] }
[10:26:16.395] assign_globals() ...
[10:26:16.395] List of 1
[10:26:16.395]  $ pkg: chr "foo"
[10:26:16.395]  - attr(*, "where")=List of 1
[10:26:16.395]   ..$ pkg:<environment: R_EmptyEnv> 
[10:26:16.395]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:16.395]  - attr(*, "resolved")= logi TRUE
[10:26:16.395]  - attr(*, "total_size")= num 112
[10:26:16.397] - copied ‘pkg’ to environment
[10:26:16.397] assign_globals() ... done
[10:26:16.397] plan(): Setting new future strategy stack:
[10:26:16.397] List of future strategies:
[10:26:16.397] 1. sequential:
[10:26:16.397]    - args: function (..., envir = parent.frame())
[10:26:16.397]    - tweaked: FALSE
[10:26:16.397]    - call: NULL
[10:26:16.398] plan(): nbrOfWorkers() = 1
[10:26:16.399] plan(): Setting new future strategy stack:
[10:26:16.399] List of future strategies:
[10:26:16.399] 1. multisession:
[10:26:16.399]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:16.399]    - tweaked: FALSE
[10:26:16.399]    - call: plan(strategy)
[10:26:16.402] plan(): nbrOfWorkers() = 2
[10:26:16.402] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:16.403] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:16.403] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:16.405] - globals found: [3] ‘{’, ‘<-’, ‘+’
[10:26:16.405] Searching for globals ... DONE
[10:26:16.405] Resolving globals: TRUE
[10:26:16.405] Resolving any globals that are futures ...
[10:26:16.405] - globals: [3] ‘{’, ‘<-’, ‘+’
[10:26:16.405] Resolving any globals that are futures ... DONE
[10:26:16.405] 
[10:26:16.406] 
[10:26:16.406] getGlobalsAndPackages() ... DONE
[10:26:16.406] run() for ‘Future’ ...
[10:26:16.406] - state: ‘created’
[10:26:16.406] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:16.420] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:16.421] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:16.421]   - Field: ‘node’
[10:26:16.421]   - Field: ‘label’
[10:26:16.421]   - Field: ‘local’
[10:26:16.421]   - Field: ‘owner’
[10:26:16.421]   - Field: ‘envir’
[10:26:16.421]   - Field: ‘workers’
[10:26:16.421]   - Field: ‘packages’
[10:26:16.421]   - Field: ‘gc’
[10:26:16.421]   - Field: ‘conditions’
[10:26:16.422]   - Field: ‘persistent’
[10:26:16.422]   - Field: ‘expr’
[10:26:16.422]   - Field: ‘uuid’
[10:26:16.422]   - Field: ‘seed’
[10:26:16.422]   - Field: ‘version’
[10:26:16.422]   - Field: ‘result’
[10:26:16.422]   - Field: ‘asynchronous’
[10:26:16.422]   - Field: ‘calls’
[10:26:16.422]   - Field: ‘globals’
[10:26:16.422]   - Field: ‘stdout’
[10:26:16.422]   - Field: ‘earlySignal’
[10:26:16.423]   - Field: ‘lazy’
[10:26:16.423]   - Field: ‘state’
[10:26:16.423] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:16.423] - Launch lazy future ...
[10:26:16.423] Packages needed by the future expression (n = 0): <none>
[10:26:16.423] Packages needed by future strategies (n = 0): <none>
[10:26:16.424] {
[10:26:16.424]     {
[10:26:16.424]         {
[10:26:16.424]             ...future.startTime <- base::Sys.time()
[10:26:16.424]             {
[10:26:16.424]                 {
[10:26:16.424]                   {
[10:26:16.424]                     {
[10:26:16.424]                       base::local({
[10:26:16.424]                         has_future <- base::requireNamespace("future", 
[10:26:16.424]                           quietly = TRUE)
[10:26:16.424]                         if (has_future) {
[10:26:16.424]                           ns <- base::getNamespace("future")
[10:26:16.424]                           version <- ns[[".package"]][["version"]]
[10:26:16.424]                           if (is.null(version)) 
[10:26:16.424]                             version <- utils::packageVersion("future")
[10:26:16.424]                         }
[10:26:16.424]                         else {
[10:26:16.424]                           version <- NULL
[10:26:16.424]                         }
[10:26:16.424]                         if (!has_future || version < "1.8.0") {
[10:26:16.424]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:16.424]                             "", base::R.version$version.string), 
[10:26:16.424]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:16.424]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:16.424]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:16.424]                               "release", "version")], collapse = " "), 
[10:26:16.424]                             hostname = base::Sys.info()[["nodename"]])
[10:26:16.424]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:16.424]                             info)
[10:26:16.424]                           info <- base::paste(info, collapse = "; ")
[10:26:16.424]                           if (!has_future) {
[10:26:16.424]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:16.424]                               info)
[10:26:16.424]                           }
[10:26:16.424]                           else {
[10:26:16.424]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:16.424]                               info, version)
[10:26:16.424]                           }
[10:26:16.424]                           base::stop(msg)
[10:26:16.424]                         }
[10:26:16.424]                       })
[10:26:16.424]                     }
[10:26:16.424]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:16.424]                     base::options(mc.cores = 1L)
[10:26:16.424]                   }
[10:26:16.424]                   options(future.plan = NULL)
[10:26:16.424]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:16.424]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:16.424]                 }
[10:26:16.424]                 ...future.workdir <- getwd()
[10:26:16.424]             }
[10:26:16.424]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:16.424]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:16.424]         }
[10:26:16.424]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:16.424]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:16.424]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:16.424]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:16.424]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:16.424]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:16.424]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:16.424]             base::names(...future.oldOptions))
[10:26:16.424]     }
[10:26:16.424]     if (FALSE) {
[10:26:16.424]     }
[10:26:16.424]     else {
[10:26:16.424]         if (TRUE) {
[10:26:16.424]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:16.424]                 open = "w")
[10:26:16.424]         }
[10:26:16.424]         else {
[10:26:16.424]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:16.424]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:16.424]         }
[10:26:16.424]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:16.424]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:16.424]             base::sink(type = "output", split = FALSE)
[10:26:16.424]             base::close(...future.stdout)
[10:26:16.424]         }, add = TRUE)
[10:26:16.424]     }
[10:26:16.424]     ...future.frame <- base::sys.nframe()
[10:26:16.424]     ...future.conditions <- base::list()
[10:26:16.424]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:16.424]     if (FALSE) {
[10:26:16.424]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:16.424]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:16.424]     }
[10:26:16.424]     ...future.result <- base::tryCatch({
[10:26:16.424]         base::withCallingHandlers({
[10:26:16.424]             ...future.value <- base::withVisible(base::local({
[10:26:16.424]                 ...future.makeSendCondition <- base::local({
[10:26:16.424]                   sendCondition <- NULL
[10:26:16.424]                   function(frame = 1L) {
[10:26:16.424]                     if (is.function(sendCondition)) 
[10:26:16.424]                       return(sendCondition)
[10:26:16.424]                     ns <- getNamespace("parallel")
[10:26:16.424]                     if (exists("sendData", mode = "function", 
[10:26:16.424]                       envir = ns)) {
[10:26:16.424]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:16.424]                         envir = ns)
[10:26:16.424]                       envir <- sys.frame(frame)
[10:26:16.424]                       master <- NULL
[10:26:16.424]                       while (!identical(envir, .GlobalEnv) && 
[10:26:16.424]                         !identical(envir, emptyenv())) {
[10:26:16.424]                         if (exists("master", mode = "list", envir = envir, 
[10:26:16.424]                           inherits = FALSE)) {
[10:26:16.424]                           master <- get("master", mode = "list", 
[10:26:16.424]                             envir = envir, inherits = FALSE)
[10:26:16.424]                           if (inherits(master, c("SOCKnode", 
[10:26:16.424]                             "SOCK0node"))) {
[10:26:16.424]                             sendCondition <<- function(cond) {
[10:26:16.424]                               data <- list(type = "VALUE", value = cond, 
[10:26:16.424]                                 success = TRUE)
[10:26:16.424]                               parallel_sendData(master, data)
[10:26:16.424]                             }
[10:26:16.424]                             return(sendCondition)
[10:26:16.424]                           }
[10:26:16.424]                         }
[10:26:16.424]                         frame <- frame + 1L
[10:26:16.424]                         envir <- sys.frame(frame)
[10:26:16.424]                       }
[10:26:16.424]                     }
[10:26:16.424]                     sendCondition <<- function(cond) NULL
[10:26:16.424]                   }
[10:26:16.424]                 })
[10:26:16.424]                 withCallingHandlers({
[10:26:16.424]                   {
[10:26:16.424]                     x <- 0
[10:26:16.424]                     x <- x + 1
[10:26:16.424]                     x
[10:26:16.424]                   }
[10:26:16.424]                 }, immediateCondition = function(cond) {
[10:26:16.424]                   sendCondition <- ...future.makeSendCondition()
[10:26:16.424]                   sendCondition(cond)
[10:26:16.424]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:16.424]                   {
[10:26:16.424]                     inherits <- base::inherits
[10:26:16.424]                     invokeRestart <- base::invokeRestart
[10:26:16.424]                     is.null <- base::is.null
[10:26:16.424]                     muffled <- FALSE
[10:26:16.424]                     if (inherits(cond, "message")) {
[10:26:16.424]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:16.424]                       if (muffled) 
[10:26:16.424]                         invokeRestart("muffleMessage")
[10:26:16.424]                     }
[10:26:16.424]                     else if (inherits(cond, "warning")) {
[10:26:16.424]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:16.424]                       if (muffled) 
[10:26:16.424]                         invokeRestart("muffleWarning")
[10:26:16.424]                     }
[10:26:16.424]                     else if (inherits(cond, "condition")) {
[10:26:16.424]                       if (!is.null(pattern)) {
[10:26:16.424]                         computeRestarts <- base::computeRestarts
[10:26:16.424]                         grepl <- base::grepl
[10:26:16.424]                         restarts <- computeRestarts(cond)
[10:26:16.424]                         for (restart in restarts) {
[10:26:16.424]                           name <- restart$name
[10:26:16.424]                           if (is.null(name)) 
[10:26:16.424]                             next
[10:26:16.424]                           if (!grepl(pattern, name)) 
[10:26:16.424]                             next
[10:26:16.424]                           invokeRestart(restart)
[10:26:16.424]                           muffled <- TRUE
[10:26:16.424]                           break
[10:26:16.424]                         }
[10:26:16.424]                       }
[10:26:16.424]                     }
[10:26:16.424]                     invisible(muffled)
[10:26:16.424]                   }
[10:26:16.424]                   muffleCondition(cond)
[10:26:16.424]                 })
[10:26:16.424]             }))
[10:26:16.424]             future::FutureResult(value = ...future.value$value, 
[10:26:16.424]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:16.424]                   ...future.rng), globalenv = if (FALSE) 
[10:26:16.424]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:16.424]                     ...future.globalenv.names))
[10:26:16.424]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:16.424]         }, condition = base::local({
[10:26:16.424]             c <- base::c
[10:26:16.424]             inherits <- base::inherits
[10:26:16.424]             invokeRestart <- base::invokeRestart
[10:26:16.424]             length <- base::length
[10:26:16.424]             list <- base::list
[10:26:16.424]             seq.int <- base::seq.int
[10:26:16.424]             signalCondition <- base::signalCondition
[10:26:16.424]             sys.calls <- base::sys.calls
[10:26:16.424]             `[[` <- base::`[[`
[10:26:16.424]             `+` <- base::`+`
[10:26:16.424]             `<<-` <- base::`<<-`
[10:26:16.424]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:16.424]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:16.424]                   3L)]
[10:26:16.424]             }
[10:26:16.424]             function(cond) {
[10:26:16.424]                 is_error <- inherits(cond, "error")
[10:26:16.424]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:16.424]                   NULL)
[10:26:16.424]                 if (is_error) {
[10:26:16.424]                   sessionInformation <- function() {
[10:26:16.424]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:16.424]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:16.424]                       search = base::search(), system = base::Sys.info())
[10:26:16.424]                   }
[10:26:16.424]                   ...future.conditions[[length(...future.conditions) + 
[10:26:16.424]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:16.424]                     cond$call), session = sessionInformation(), 
[10:26:16.424]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:16.424]                   signalCondition(cond)
[10:26:16.424]                 }
[10:26:16.424]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:16.424]                 "immediateCondition"))) {
[10:26:16.424]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:16.424]                   ...future.conditions[[length(...future.conditions) + 
[10:26:16.424]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:16.424]                   if (TRUE && !signal) {
[10:26:16.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:16.424]                     {
[10:26:16.424]                       inherits <- base::inherits
[10:26:16.424]                       invokeRestart <- base::invokeRestart
[10:26:16.424]                       is.null <- base::is.null
[10:26:16.424]                       muffled <- FALSE
[10:26:16.424]                       if (inherits(cond, "message")) {
[10:26:16.424]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:16.424]                         if (muffled) 
[10:26:16.424]                           invokeRestart("muffleMessage")
[10:26:16.424]                       }
[10:26:16.424]                       else if (inherits(cond, "warning")) {
[10:26:16.424]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:16.424]                         if (muffled) 
[10:26:16.424]                           invokeRestart("muffleWarning")
[10:26:16.424]                       }
[10:26:16.424]                       else if (inherits(cond, "condition")) {
[10:26:16.424]                         if (!is.null(pattern)) {
[10:26:16.424]                           computeRestarts <- base::computeRestarts
[10:26:16.424]                           grepl <- base::grepl
[10:26:16.424]                           restarts <- computeRestarts(cond)
[10:26:16.424]                           for (restart in restarts) {
[10:26:16.424]                             name <- restart$name
[10:26:16.424]                             if (is.null(name)) 
[10:26:16.424]                               next
[10:26:16.424]                             if (!grepl(pattern, name)) 
[10:26:16.424]                               next
[10:26:16.424]                             invokeRestart(restart)
[10:26:16.424]                             muffled <- TRUE
[10:26:16.424]                             break
[10:26:16.424]                           }
[10:26:16.424]                         }
[10:26:16.424]                       }
[10:26:16.424]                       invisible(muffled)
[10:26:16.424]                     }
[10:26:16.424]                     muffleCondition(cond, pattern = "^muffle")
[10:26:16.424]                   }
[10:26:16.424]                 }
[10:26:16.424]                 else {
[10:26:16.424]                   if (TRUE) {
[10:26:16.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:16.424]                     {
[10:26:16.424]                       inherits <- base::inherits
[10:26:16.424]                       invokeRestart <- base::invokeRestart
[10:26:16.424]                       is.null <- base::is.null
[10:26:16.424]                       muffled <- FALSE
[10:26:16.424]                       if (inherits(cond, "message")) {
[10:26:16.424]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:16.424]                         if (muffled) 
[10:26:16.424]                           invokeRestart("muffleMessage")
[10:26:16.424]                       }
[10:26:16.424]                       else if (inherits(cond, "warning")) {
[10:26:16.424]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:16.424]                         if (muffled) 
[10:26:16.424]                           invokeRestart("muffleWarning")
[10:26:16.424]                       }
[10:26:16.424]                       else if (inherits(cond, "condition")) {
[10:26:16.424]                         if (!is.null(pattern)) {
[10:26:16.424]                           computeRestarts <- base::computeRestarts
[10:26:16.424]                           grepl <- base::grepl
[10:26:16.424]                           restarts <- computeRestarts(cond)
[10:26:16.424]                           for (restart in restarts) {
[10:26:16.424]                             name <- restart$name
[10:26:16.424]                             if (is.null(name)) 
[10:26:16.424]                               next
[10:26:16.424]                             if (!grepl(pattern, name)) 
[10:26:16.424]                               next
[10:26:16.424]                             invokeRestart(restart)
[10:26:16.424]                             muffled <- TRUE
[10:26:16.424]                             break
[10:26:16.424]                           }
[10:26:16.424]                         }
[10:26:16.424]                       }
[10:26:16.424]                       invisible(muffled)
[10:26:16.424]                     }
[10:26:16.424]                     muffleCondition(cond, pattern = "^muffle")
[10:26:16.424]                   }
[10:26:16.424]                 }
[10:26:16.424]             }
[10:26:16.424]         }))
[10:26:16.424]     }, error = function(ex) {
[10:26:16.424]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:16.424]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:16.424]                 ...future.rng), started = ...future.startTime, 
[10:26:16.424]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:16.424]             version = "1.8"), class = "FutureResult")
[10:26:16.424]     }, finally = {
[10:26:16.424]         if (!identical(...future.workdir, getwd())) 
[10:26:16.424]             setwd(...future.workdir)
[10:26:16.424]         {
[10:26:16.424]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:16.424]                 ...future.oldOptions$nwarnings <- NULL
[10:26:16.424]             }
[10:26:16.424]             base::options(...future.oldOptions)
[10:26:16.424]             if (.Platform$OS.type == "windows") {
[10:26:16.424]                 old_names <- names(...future.oldEnvVars)
[10:26:16.424]                 envs <- base::Sys.getenv()
[10:26:16.424]                 names <- names(envs)
[10:26:16.424]                 common <- intersect(names, old_names)
[10:26:16.424]                 added <- setdiff(names, old_names)
[10:26:16.424]                 removed <- setdiff(old_names, names)
[10:26:16.424]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:16.424]                   envs[common]]
[10:26:16.424]                 NAMES <- toupper(changed)
[10:26:16.424]                 args <- list()
[10:26:16.424]                 for (kk in seq_along(NAMES)) {
[10:26:16.424]                   name <- changed[[kk]]
[10:26:16.424]                   NAME <- NAMES[[kk]]
[10:26:16.424]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.424]                     next
[10:26:16.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:16.424]                 }
[10:26:16.424]                 NAMES <- toupper(added)
[10:26:16.424]                 for (kk in seq_along(NAMES)) {
[10:26:16.424]                   name <- added[[kk]]
[10:26:16.424]                   NAME <- NAMES[[kk]]
[10:26:16.424]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.424]                     next
[10:26:16.424]                   args[[name]] <- ""
[10:26:16.424]                 }
[10:26:16.424]                 NAMES <- toupper(removed)
[10:26:16.424]                 for (kk in seq_along(NAMES)) {
[10:26:16.424]                   name <- removed[[kk]]
[10:26:16.424]                   NAME <- NAMES[[kk]]
[10:26:16.424]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.424]                     next
[10:26:16.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:16.424]                 }
[10:26:16.424]                 if (length(args) > 0) 
[10:26:16.424]                   base::do.call(base::Sys.setenv, args = args)
[10:26:16.424]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:16.424]             }
[10:26:16.424]             else {
[10:26:16.424]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:16.424]             }
[10:26:16.424]             {
[10:26:16.424]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:16.424]                   0L) {
[10:26:16.424]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:16.424]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:16.424]                   base::options(opts)
[10:26:16.424]                 }
[10:26:16.424]                 {
[10:26:16.424]                   {
[10:26:16.424]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:16.424]                     NULL
[10:26:16.424]                   }
[10:26:16.424]                   options(future.plan = NULL)
[10:26:16.424]                   if (is.na(NA_character_)) 
[10:26:16.424]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:16.424]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:16.424]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:16.424]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:16.424]                     envir = parent.frame()) 
[10:26:16.424]                   {
[10:26:16.424]                     if (is.function(workers)) 
[10:26:16.424]                       workers <- workers()
[10:26:16.424]                     workers <- structure(as.integer(workers), 
[10:26:16.424]                       class = class(workers))
[10:26:16.424]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:16.424]                       workers >= 1)
[10:26:16.424]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:16.424]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:16.424]                     }
[10:26:16.424]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:16.424]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:16.424]                       envir = envir)
[10:26:16.424]                     if (!future$lazy) 
[10:26:16.424]                       future <- run(future)
[10:26:16.424]                     invisible(future)
[10:26:16.424]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:16.424]                 }
[10:26:16.424]             }
[10:26:16.424]         }
[10:26:16.424]     })
[10:26:16.424]     if (TRUE) {
[10:26:16.424]         base::sink(type = "output", split = FALSE)
[10:26:16.424]         if (TRUE) {
[10:26:16.424]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:16.424]         }
[10:26:16.424]         else {
[10:26:16.424]             ...future.result["stdout"] <- base::list(NULL)
[10:26:16.424]         }
[10:26:16.424]         base::close(...future.stdout)
[10:26:16.424]         ...future.stdout <- NULL
[10:26:16.424]     }
[10:26:16.424]     ...future.result$conditions <- ...future.conditions
[10:26:16.424]     ...future.result$finished <- base::Sys.time()
[10:26:16.424]     ...future.result
[10:26:16.424] }
[10:26:16.427] MultisessionFuture started
[10:26:16.427] - Launch lazy future ... done
[10:26:16.427] run() for ‘MultisessionFuture’ ... done
[10:26:16.427] result() for ClusterFuture ...
[10:26:16.427] receiveMessageFromWorker() for ClusterFuture ...
[10:26:16.427] - Validating connection of MultisessionFuture
[10:26:16.474] - received message: FutureResult
[10:26:16.475] - Received FutureResult
[10:26:16.475] - Erased future from FutureRegistry
[10:26:16.475] result() for ClusterFuture ...
[10:26:16.475] - result already collected: FutureResult
[10:26:16.475] result() for ClusterFuture ... done
[10:26:16.475] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:16.475] result() for ClusterFuture ... done
[10:26:16.475] result() for ClusterFuture ...
[10:26:16.475] - result already collected: FutureResult
[10:26:16.475] result() for ClusterFuture ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:16.476] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:16.476] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:16.477] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[10:26:16.477] Searching for globals ... DONE
[10:26:16.477] Resolving globals: TRUE
[10:26:16.478] Resolving any globals that are futures ...
[10:26:16.478] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[10:26:16.478] Resolving any globals that are futures ... DONE
[10:26:16.478] Resolving futures part of globals (recursively) ...
[10:26:16.478] resolve() on list ...
[10:26:16.478]  recursive: 99
[10:26:16.479]  length: 1
[10:26:16.479]  elements: ‘x’
[10:26:16.479]  length: 0 (resolved future 1)
[10:26:16.479] resolve() on list ... DONE
[10:26:16.479] - globals: [1] ‘x’
[10:26:16.479] Resolving futures part of globals (recursively) ... DONE
[10:26:16.479] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:16.480] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[10:26:16.480] - globals: [1] ‘x’
[10:26:16.480] 
[10:26:16.480] getGlobalsAndPackages() ... DONE
[10:26:16.480] run() for ‘Future’ ...
[10:26:16.480] - state: ‘created’
[10:26:16.480] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:16.494] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:16.494] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:16.494]   - Field: ‘node’
[10:26:16.494]   - Field: ‘label’
[10:26:16.494]   - Field: ‘local’
[10:26:16.494]   - Field: ‘owner’
[10:26:16.494]   - Field: ‘envir’
[10:26:16.494]   - Field: ‘workers’
[10:26:16.495]   - Field: ‘packages’
[10:26:16.495]   - Field: ‘gc’
[10:26:16.495]   - Field: ‘conditions’
[10:26:16.495]   - Field: ‘persistent’
[10:26:16.495]   - Field: ‘expr’
[10:26:16.495]   - Field: ‘uuid’
[10:26:16.495]   - Field: ‘seed’
[10:26:16.495]   - Field: ‘version’
[10:26:16.495]   - Field: ‘result’
[10:26:16.495]   - Field: ‘asynchronous’
[10:26:16.495]   - Field: ‘calls’
[10:26:16.496]   - Field: ‘globals’
[10:26:16.496]   - Field: ‘stdout’
[10:26:16.496]   - Field: ‘earlySignal’
[10:26:16.496]   - Field: ‘lazy’
[10:26:16.496]   - Field: ‘state’
[10:26:16.496] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:16.496] - Launch lazy future ...
[10:26:16.496] Packages needed by the future expression (n = 0): <none>
[10:26:16.497] Packages needed by future strategies (n = 0): <none>
[10:26:16.497] {
[10:26:16.497]     {
[10:26:16.497]         {
[10:26:16.497]             ...future.startTime <- base::Sys.time()
[10:26:16.497]             {
[10:26:16.497]                 {
[10:26:16.497]                   {
[10:26:16.497]                     {
[10:26:16.497]                       base::local({
[10:26:16.497]                         has_future <- base::requireNamespace("future", 
[10:26:16.497]                           quietly = TRUE)
[10:26:16.497]                         if (has_future) {
[10:26:16.497]                           ns <- base::getNamespace("future")
[10:26:16.497]                           version <- ns[[".package"]][["version"]]
[10:26:16.497]                           if (is.null(version)) 
[10:26:16.497]                             version <- utils::packageVersion("future")
[10:26:16.497]                         }
[10:26:16.497]                         else {
[10:26:16.497]                           version <- NULL
[10:26:16.497]                         }
[10:26:16.497]                         if (!has_future || version < "1.8.0") {
[10:26:16.497]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:16.497]                             "", base::R.version$version.string), 
[10:26:16.497]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:16.497]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:16.497]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:16.497]                               "release", "version")], collapse = " "), 
[10:26:16.497]                             hostname = base::Sys.info()[["nodename"]])
[10:26:16.497]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:16.497]                             info)
[10:26:16.497]                           info <- base::paste(info, collapse = "; ")
[10:26:16.497]                           if (!has_future) {
[10:26:16.497]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:16.497]                               info)
[10:26:16.497]                           }
[10:26:16.497]                           else {
[10:26:16.497]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:16.497]                               info, version)
[10:26:16.497]                           }
[10:26:16.497]                           base::stop(msg)
[10:26:16.497]                         }
[10:26:16.497]                       })
[10:26:16.497]                     }
[10:26:16.497]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:16.497]                     base::options(mc.cores = 1L)
[10:26:16.497]                   }
[10:26:16.497]                   options(future.plan = NULL)
[10:26:16.497]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:16.497]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:16.497]                 }
[10:26:16.497]                 ...future.workdir <- getwd()
[10:26:16.497]             }
[10:26:16.497]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:16.497]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:16.497]         }
[10:26:16.497]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:16.497]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:16.497]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:16.497]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:16.497]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:16.497]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:16.497]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:16.497]             base::names(...future.oldOptions))
[10:26:16.497]     }
[10:26:16.497]     if (FALSE) {
[10:26:16.497]     }
[10:26:16.497]     else {
[10:26:16.497]         if (TRUE) {
[10:26:16.497]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:16.497]                 open = "w")
[10:26:16.497]         }
[10:26:16.497]         else {
[10:26:16.497]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:16.497]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:16.497]         }
[10:26:16.497]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:16.497]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:16.497]             base::sink(type = "output", split = FALSE)
[10:26:16.497]             base::close(...future.stdout)
[10:26:16.497]         }, add = TRUE)
[10:26:16.497]     }
[10:26:16.497]     ...future.frame <- base::sys.nframe()
[10:26:16.497]     ...future.conditions <- base::list()
[10:26:16.497]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:16.497]     if (FALSE) {
[10:26:16.497]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:16.497]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:16.497]     }
[10:26:16.497]     ...future.result <- base::tryCatch({
[10:26:16.497]         base::withCallingHandlers({
[10:26:16.497]             ...future.value <- base::withVisible(base::local({
[10:26:16.497]                 ...future.makeSendCondition <- base::local({
[10:26:16.497]                   sendCondition <- NULL
[10:26:16.497]                   function(frame = 1L) {
[10:26:16.497]                     if (is.function(sendCondition)) 
[10:26:16.497]                       return(sendCondition)
[10:26:16.497]                     ns <- getNamespace("parallel")
[10:26:16.497]                     if (exists("sendData", mode = "function", 
[10:26:16.497]                       envir = ns)) {
[10:26:16.497]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:16.497]                         envir = ns)
[10:26:16.497]                       envir <- sys.frame(frame)
[10:26:16.497]                       master <- NULL
[10:26:16.497]                       while (!identical(envir, .GlobalEnv) && 
[10:26:16.497]                         !identical(envir, emptyenv())) {
[10:26:16.497]                         if (exists("master", mode = "list", envir = envir, 
[10:26:16.497]                           inherits = FALSE)) {
[10:26:16.497]                           master <- get("master", mode = "list", 
[10:26:16.497]                             envir = envir, inherits = FALSE)
[10:26:16.497]                           if (inherits(master, c("SOCKnode", 
[10:26:16.497]                             "SOCK0node"))) {
[10:26:16.497]                             sendCondition <<- function(cond) {
[10:26:16.497]                               data <- list(type = "VALUE", value = cond, 
[10:26:16.497]                                 success = TRUE)
[10:26:16.497]                               parallel_sendData(master, data)
[10:26:16.497]                             }
[10:26:16.497]                             return(sendCondition)
[10:26:16.497]                           }
[10:26:16.497]                         }
[10:26:16.497]                         frame <- frame + 1L
[10:26:16.497]                         envir <- sys.frame(frame)
[10:26:16.497]                       }
[10:26:16.497]                     }
[10:26:16.497]                     sendCondition <<- function(cond) NULL
[10:26:16.497]                   }
[10:26:16.497]                 })
[10:26:16.497]                 withCallingHandlers({
[10:26:16.497]                   {
[10:26:16.497]                     x <- x + 1
[10:26:16.497]                     x
[10:26:16.497]                   }
[10:26:16.497]                 }, immediateCondition = function(cond) {
[10:26:16.497]                   sendCondition <- ...future.makeSendCondition()
[10:26:16.497]                   sendCondition(cond)
[10:26:16.497]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:16.497]                   {
[10:26:16.497]                     inherits <- base::inherits
[10:26:16.497]                     invokeRestart <- base::invokeRestart
[10:26:16.497]                     is.null <- base::is.null
[10:26:16.497]                     muffled <- FALSE
[10:26:16.497]                     if (inherits(cond, "message")) {
[10:26:16.497]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:16.497]                       if (muffled) 
[10:26:16.497]                         invokeRestart("muffleMessage")
[10:26:16.497]                     }
[10:26:16.497]                     else if (inherits(cond, "warning")) {
[10:26:16.497]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:16.497]                       if (muffled) 
[10:26:16.497]                         invokeRestart("muffleWarning")
[10:26:16.497]                     }
[10:26:16.497]                     else if (inherits(cond, "condition")) {
[10:26:16.497]                       if (!is.null(pattern)) {
[10:26:16.497]                         computeRestarts <- base::computeRestarts
[10:26:16.497]                         grepl <- base::grepl
[10:26:16.497]                         restarts <- computeRestarts(cond)
[10:26:16.497]                         for (restart in restarts) {
[10:26:16.497]                           name <- restart$name
[10:26:16.497]                           if (is.null(name)) 
[10:26:16.497]                             next
[10:26:16.497]                           if (!grepl(pattern, name)) 
[10:26:16.497]                             next
[10:26:16.497]                           invokeRestart(restart)
[10:26:16.497]                           muffled <- TRUE
[10:26:16.497]                           break
[10:26:16.497]                         }
[10:26:16.497]                       }
[10:26:16.497]                     }
[10:26:16.497]                     invisible(muffled)
[10:26:16.497]                   }
[10:26:16.497]                   muffleCondition(cond)
[10:26:16.497]                 })
[10:26:16.497]             }))
[10:26:16.497]             future::FutureResult(value = ...future.value$value, 
[10:26:16.497]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:16.497]                   ...future.rng), globalenv = if (FALSE) 
[10:26:16.497]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:16.497]                     ...future.globalenv.names))
[10:26:16.497]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:16.497]         }, condition = base::local({
[10:26:16.497]             c <- base::c
[10:26:16.497]             inherits <- base::inherits
[10:26:16.497]             invokeRestart <- base::invokeRestart
[10:26:16.497]             length <- base::length
[10:26:16.497]             list <- base::list
[10:26:16.497]             seq.int <- base::seq.int
[10:26:16.497]             signalCondition <- base::signalCondition
[10:26:16.497]             sys.calls <- base::sys.calls
[10:26:16.497]             `[[` <- base::`[[`
[10:26:16.497]             `+` <- base::`+`
[10:26:16.497]             `<<-` <- base::`<<-`
[10:26:16.497]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:16.497]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:16.497]                   3L)]
[10:26:16.497]             }
[10:26:16.497]             function(cond) {
[10:26:16.497]                 is_error <- inherits(cond, "error")
[10:26:16.497]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:16.497]                   NULL)
[10:26:16.497]                 if (is_error) {
[10:26:16.497]                   sessionInformation <- function() {
[10:26:16.497]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:16.497]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:16.497]                       search = base::search(), system = base::Sys.info())
[10:26:16.497]                   }
[10:26:16.497]                   ...future.conditions[[length(...future.conditions) + 
[10:26:16.497]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:16.497]                     cond$call), session = sessionInformation(), 
[10:26:16.497]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:16.497]                   signalCondition(cond)
[10:26:16.497]                 }
[10:26:16.497]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:16.497]                 "immediateCondition"))) {
[10:26:16.497]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:16.497]                   ...future.conditions[[length(...future.conditions) + 
[10:26:16.497]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:16.497]                   if (TRUE && !signal) {
[10:26:16.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:16.497]                     {
[10:26:16.497]                       inherits <- base::inherits
[10:26:16.497]                       invokeRestart <- base::invokeRestart
[10:26:16.497]                       is.null <- base::is.null
[10:26:16.497]                       muffled <- FALSE
[10:26:16.497]                       if (inherits(cond, "message")) {
[10:26:16.497]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:16.497]                         if (muffled) 
[10:26:16.497]                           invokeRestart("muffleMessage")
[10:26:16.497]                       }
[10:26:16.497]                       else if (inherits(cond, "warning")) {
[10:26:16.497]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:16.497]                         if (muffled) 
[10:26:16.497]                           invokeRestart("muffleWarning")
[10:26:16.497]                       }
[10:26:16.497]                       else if (inherits(cond, "condition")) {
[10:26:16.497]                         if (!is.null(pattern)) {
[10:26:16.497]                           computeRestarts <- base::computeRestarts
[10:26:16.497]                           grepl <- base::grepl
[10:26:16.497]                           restarts <- computeRestarts(cond)
[10:26:16.497]                           for (restart in restarts) {
[10:26:16.497]                             name <- restart$name
[10:26:16.497]                             if (is.null(name)) 
[10:26:16.497]                               next
[10:26:16.497]                             if (!grepl(pattern, name)) 
[10:26:16.497]                               next
[10:26:16.497]                             invokeRestart(restart)
[10:26:16.497]                             muffled <- TRUE
[10:26:16.497]                             break
[10:26:16.497]                           }
[10:26:16.497]                         }
[10:26:16.497]                       }
[10:26:16.497]                       invisible(muffled)
[10:26:16.497]                     }
[10:26:16.497]                     muffleCondition(cond, pattern = "^muffle")
[10:26:16.497]                   }
[10:26:16.497]                 }
[10:26:16.497]                 else {
[10:26:16.497]                   if (TRUE) {
[10:26:16.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:16.497]                     {
[10:26:16.497]                       inherits <- base::inherits
[10:26:16.497]                       invokeRestart <- base::invokeRestart
[10:26:16.497]                       is.null <- base::is.null
[10:26:16.497]                       muffled <- FALSE
[10:26:16.497]                       if (inherits(cond, "message")) {
[10:26:16.497]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:16.497]                         if (muffled) 
[10:26:16.497]                           invokeRestart("muffleMessage")
[10:26:16.497]                       }
[10:26:16.497]                       else if (inherits(cond, "warning")) {
[10:26:16.497]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:16.497]                         if (muffled) 
[10:26:16.497]                           invokeRestart("muffleWarning")
[10:26:16.497]                       }
[10:26:16.497]                       else if (inherits(cond, "condition")) {
[10:26:16.497]                         if (!is.null(pattern)) {
[10:26:16.497]                           computeRestarts <- base::computeRestarts
[10:26:16.497]                           grepl <- base::grepl
[10:26:16.497]                           restarts <- computeRestarts(cond)
[10:26:16.497]                           for (restart in restarts) {
[10:26:16.497]                             name <- restart$name
[10:26:16.497]                             if (is.null(name)) 
[10:26:16.497]                               next
[10:26:16.497]                             if (!grepl(pattern, name)) 
[10:26:16.497]                               next
[10:26:16.497]                             invokeRestart(restart)
[10:26:16.497]                             muffled <- TRUE
[10:26:16.497]                             break
[10:26:16.497]                           }
[10:26:16.497]                         }
[10:26:16.497]                       }
[10:26:16.497]                       invisible(muffled)
[10:26:16.497]                     }
[10:26:16.497]                     muffleCondition(cond, pattern = "^muffle")
[10:26:16.497]                   }
[10:26:16.497]                 }
[10:26:16.497]             }
[10:26:16.497]         }))
[10:26:16.497]     }, error = function(ex) {
[10:26:16.497]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:16.497]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:16.497]                 ...future.rng), started = ...future.startTime, 
[10:26:16.497]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:16.497]             version = "1.8"), class = "FutureResult")
[10:26:16.497]     }, finally = {
[10:26:16.497]         if (!identical(...future.workdir, getwd())) 
[10:26:16.497]             setwd(...future.workdir)
[10:26:16.497]         {
[10:26:16.497]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:16.497]                 ...future.oldOptions$nwarnings <- NULL
[10:26:16.497]             }
[10:26:16.497]             base::options(...future.oldOptions)
[10:26:16.497]             if (.Platform$OS.type == "windows") {
[10:26:16.497]                 old_names <- names(...future.oldEnvVars)
[10:26:16.497]                 envs <- base::Sys.getenv()
[10:26:16.497]                 names <- names(envs)
[10:26:16.497]                 common <- intersect(names, old_names)
[10:26:16.497]                 added <- setdiff(names, old_names)
[10:26:16.497]                 removed <- setdiff(old_names, names)
[10:26:16.497]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:16.497]                   envs[common]]
[10:26:16.497]                 NAMES <- toupper(changed)
[10:26:16.497]                 args <- list()
[10:26:16.497]                 for (kk in seq_along(NAMES)) {
[10:26:16.497]                   name <- changed[[kk]]
[10:26:16.497]                   NAME <- NAMES[[kk]]
[10:26:16.497]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.497]                     next
[10:26:16.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:16.497]                 }
[10:26:16.497]                 NAMES <- toupper(added)
[10:26:16.497]                 for (kk in seq_along(NAMES)) {
[10:26:16.497]                   name <- added[[kk]]
[10:26:16.497]                   NAME <- NAMES[[kk]]
[10:26:16.497]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.497]                     next
[10:26:16.497]                   args[[name]] <- ""
[10:26:16.497]                 }
[10:26:16.497]                 NAMES <- toupper(removed)
[10:26:16.497]                 for (kk in seq_along(NAMES)) {
[10:26:16.497]                   name <- removed[[kk]]
[10:26:16.497]                   NAME <- NAMES[[kk]]
[10:26:16.497]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.497]                     next
[10:26:16.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:16.497]                 }
[10:26:16.497]                 if (length(args) > 0) 
[10:26:16.497]                   base::do.call(base::Sys.setenv, args = args)
[10:26:16.497]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:16.497]             }
[10:26:16.497]             else {
[10:26:16.497]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:16.497]             }
[10:26:16.497]             {
[10:26:16.497]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:16.497]                   0L) {
[10:26:16.497]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:16.497]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:16.497]                   base::options(opts)
[10:26:16.497]                 }
[10:26:16.497]                 {
[10:26:16.497]                   {
[10:26:16.497]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:16.497]                     NULL
[10:26:16.497]                   }
[10:26:16.497]                   options(future.plan = NULL)
[10:26:16.497]                   if (is.na(NA_character_)) 
[10:26:16.497]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:16.497]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:16.497]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:16.497]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:16.497]                     envir = parent.frame()) 
[10:26:16.497]                   {
[10:26:16.497]                     if (is.function(workers)) 
[10:26:16.497]                       workers <- workers()
[10:26:16.497]                     workers <- structure(as.integer(workers), 
[10:26:16.497]                       class = class(workers))
[10:26:16.497]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:16.497]                       workers >= 1)
[10:26:16.497]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:16.497]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:16.497]                     }
[10:26:16.497]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:16.497]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:16.497]                       envir = envir)
[10:26:16.497]                     if (!future$lazy) 
[10:26:16.497]                       future <- run(future)
[10:26:16.497]                     invisible(future)
[10:26:16.497]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:16.497]                 }
[10:26:16.497]             }
[10:26:16.497]         }
[10:26:16.497]     })
[10:26:16.497]     if (TRUE) {
[10:26:16.497]         base::sink(type = "output", split = FALSE)
[10:26:16.497]         if (TRUE) {
[10:26:16.497]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:16.497]         }
[10:26:16.497]         else {
[10:26:16.497]             ...future.result["stdout"] <- base::list(NULL)
[10:26:16.497]         }
[10:26:16.497]         base::close(...future.stdout)
[10:26:16.497]         ...future.stdout <- NULL
[10:26:16.497]     }
[10:26:16.497]     ...future.result$conditions <- ...future.conditions
[10:26:16.497]     ...future.result$finished <- base::Sys.time()
[10:26:16.497]     ...future.result
[10:26:16.497] }
[10:26:16.499] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[10:26:16.500] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[10:26:16.500] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[10:26:16.500] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[10:26:16.500] MultisessionFuture started
[10:26:16.501] - Launch lazy future ... done
[10:26:16.501] run() for ‘MultisessionFuture’ ... done
[10:26:16.501] result() for ClusterFuture ...
[10:26:16.501] receiveMessageFromWorker() for ClusterFuture ...
[10:26:16.501] - Validating connection of MultisessionFuture
[10:26:16.546] - received message: FutureResult
[10:26:16.546] - Received FutureResult
[10:26:16.546] - Erased future from FutureRegistry
[10:26:16.547] result() for ClusterFuture ...
[10:26:16.547] - result already collected: FutureResult
[10:26:16.547] result() for ClusterFuture ... done
[10:26:16.547] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:16.547] result() for ClusterFuture ... done
[10:26:16.547] result() for ClusterFuture ...
[10:26:16.547] - result already collected: FutureResult
[10:26:16.547] result() for ClusterFuture ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:26:16.548] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:16.548] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:26:16.549] - globals found: [3] ‘{’, ‘<-’, ‘x’
[10:26:16.549] Searching for globals ... DONE
[10:26:16.550] Resolving globals: TRUE
[10:26:16.550] Resolving any globals that are futures ...
[10:26:16.550] - globals: [3] ‘{’, ‘<-’, ‘x’
[10:26:16.550] Resolving any globals that are futures ... DONE
[10:26:16.550] Resolving futures part of globals (recursively) ...
[10:26:16.550] resolve() on list ...
[10:26:16.550]  recursive: 99
[10:26:16.551]  length: 1
[10:26:16.551]  elements: ‘x’
[10:26:16.551]  length: 0 (resolved future 1)
[10:26:16.551] resolve() on list ... DONE
[10:26:16.551] - globals: [1] ‘x’
[10:26:16.551] Resolving futures part of globals (recursively) ... DONE
[10:26:16.551] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[10:26:16.551] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[10:26:16.552] - globals: [1] ‘x’
[10:26:16.552] 
[10:26:16.552] getGlobalsAndPackages() ... DONE
[10:26:16.552] run() for ‘Future’ ...
[10:26:16.552] - state: ‘created’
[10:26:16.552] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:16.566] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:16.566] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:16.566]   - Field: ‘node’
[10:26:16.566]   - Field: ‘label’
[10:26:16.566]   - Field: ‘local’
[10:26:16.566]   - Field: ‘owner’
[10:26:16.566]   - Field: ‘envir’
[10:26:16.566]   - Field: ‘workers’
[10:26:16.567]   - Field: ‘packages’
[10:26:16.567]   - Field: ‘gc’
[10:26:16.567]   - Field: ‘conditions’
[10:26:16.567]   - Field: ‘persistent’
[10:26:16.567]   - Field: ‘expr’
[10:26:16.567]   - Field: ‘uuid’
[10:26:16.567]   - Field: ‘seed’
[10:26:16.567]   - Field: ‘version’
[10:26:16.567]   - Field: ‘result’
[10:26:16.567]   - Field: ‘asynchronous’
[10:26:16.567]   - Field: ‘calls’
[10:26:16.568]   - Field: ‘globals’
[10:26:16.568]   - Field: ‘stdout’
[10:26:16.568]   - Field: ‘earlySignal’
[10:26:16.568]   - Field: ‘lazy’
[10:26:16.568]   - Field: ‘state’
[10:26:16.568] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:16.568] - Launch lazy future ...
[10:26:16.568] Packages needed by the future expression (n = 0): <none>
[10:26:16.568] Packages needed by future strategies (n = 0): <none>
[10:26:16.569] {
[10:26:16.569]     {
[10:26:16.569]         {
[10:26:16.569]             ...future.startTime <- base::Sys.time()
[10:26:16.569]             {
[10:26:16.569]                 {
[10:26:16.569]                   {
[10:26:16.569]                     {
[10:26:16.569]                       base::local({
[10:26:16.569]                         has_future <- base::requireNamespace("future", 
[10:26:16.569]                           quietly = TRUE)
[10:26:16.569]                         if (has_future) {
[10:26:16.569]                           ns <- base::getNamespace("future")
[10:26:16.569]                           version <- ns[[".package"]][["version"]]
[10:26:16.569]                           if (is.null(version)) 
[10:26:16.569]                             version <- utils::packageVersion("future")
[10:26:16.569]                         }
[10:26:16.569]                         else {
[10:26:16.569]                           version <- NULL
[10:26:16.569]                         }
[10:26:16.569]                         if (!has_future || version < "1.8.0") {
[10:26:16.569]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:16.569]                             "", base::R.version$version.string), 
[10:26:16.569]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:16.569]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:16.569]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:16.569]                               "release", "version")], collapse = " "), 
[10:26:16.569]                             hostname = base::Sys.info()[["nodename"]])
[10:26:16.569]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:16.569]                             info)
[10:26:16.569]                           info <- base::paste(info, collapse = "; ")
[10:26:16.569]                           if (!has_future) {
[10:26:16.569]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:16.569]                               info)
[10:26:16.569]                           }
[10:26:16.569]                           else {
[10:26:16.569]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:16.569]                               info, version)
[10:26:16.569]                           }
[10:26:16.569]                           base::stop(msg)
[10:26:16.569]                         }
[10:26:16.569]                       })
[10:26:16.569]                     }
[10:26:16.569]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:16.569]                     base::options(mc.cores = 1L)
[10:26:16.569]                   }
[10:26:16.569]                   options(future.plan = NULL)
[10:26:16.569]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:16.569]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:16.569]                 }
[10:26:16.569]                 ...future.workdir <- getwd()
[10:26:16.569]             }
[10:26:16.569]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:16.569]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:16.569]         }
[10:26:16.569]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:16.569]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:26:16.569]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:16.569]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:26:16.569]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:16.569]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:16.569]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:16.569]             base::names(...future.oldOptions))
[10:26:16.569]     }
[10:26:16.569]     if (FALSE) {
[10:26:16.569]     }
[10:26:16.569]     else {
[10:26:16.569]         if (TRUE) {
[10:26:16.569]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:16.569]                 open = "w")
[10:26:16.569]         }
[10:26:16.569]         else {
[10:26:16.569]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:16.569]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:16.569]         }
[10:26:16.569]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:16.569]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:16.569]             base::sink(type = "output", split = FALSE)
[10:26:16.569]             base::close(...future.stdout)
[10:26:16.569]         }, add = TRUE)
[10:26:16.569]     }
[10:26:16.569]     ...future.frame <- base::sys.nframe()
[10:26:16.569]     ...future.conditions <- base::list()
[10:26:16.569]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:16.569]     if (FALSE) {
[10:26:16.569]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:16.569]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:16.569]     }
[10:26:16.569]     ...future.result <- base::tryCatch({
[10:26:16.569]         base::withCallingHandlers({
[10:26:16.569]             ...future.value <- base::withVisible(base::local({
[10:26:16.569]                 ...future.makeSendCondition <- base::local({
[10:26:16.569]                   sendCondition <- NULL
[10:26:16.569]                   function(frame = 1L) {
[10:26:16.569]                     if (is.function(sendCondition)) 
[10:26:16.569]                       return(sendCondition)
[10:26:16.569]                     ns <- getNamespace("parallel")
[10:26:16.569]                     if (exists("sendData", mode = "function", 
[10:26:16.569]                       envir = ns)) {
[10:26:16.569]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:16.569]                         envir = ns)
[10:26:16.569]                       envir <- sys.frame(frame)
[10:26:16.569]                       master <- NULL
[10:26:16.569]                       while (!identical(envir, .GlobalEnv) && 
[10:26:16.569]                         !identical(envir, emptyenv())) {
[10:26:16.569]                         if (exists("master", mode = "list", envir = envir, 
[10:26:16.569]                           inherits = FALSE)) {
[10:26:16.569]                           master <- get("master", mode = "list", 
[10:26:16.569]                             envir = envir, inherits = FALSE)
[10:26:16.569]                           if (inherits(master, c("SOCKnode", 
[10:26:16.569]                             "SOCK0node"))) {
[10:26:16.569]                             sendCondition <<- function(cond) {
[10:26:16.569]                               data <- list(type = "VALUE", value = cond, 
[10:26:16.569]                                 success = TRUE)
[10:26:16.569]                               parallel_sendData(master, data)
[10:26:16.569]                             }
[10:26:16.569]                             return(sendCondition)
[10:26:16.569]                           }
[10:26:16.569]                         }
[10:26:16.569]                         frame <- frame + 1L
[10:26:16.569]                         envir <- sys.frame(frame)
[10:26:16.569]                       }
[10:26:16.569]                     }
[10:26:16.569]                     sendCondition <<- function(cond) NULL
[10:26:16.569]                   }
[10:26:16.569]                 })
[10:26:16.569]                 withCallingHandlers({
[10:26:16.569]                   {
[10:26:16.569]                     x <- x()
[10:26:16.569]                     x
[10:26:16.569]                   }
[10:26:16.569]                 }, immediateCondition = function(cond) {
[10:26:16.569]                   sendCondition <- ...future.makeSendCondition()
[10:26:16.569]                   sendCondition(cond)
[10:26:16.569]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:16.569]                   {
[10:26:16.569]                     inherits <- base::inherits
[10:26:16.569]                     invokeRestart <- base::invokeRestart
[10:26:16.569]                     is.null <- base::is.null
[10:26:16.569]                     muffled <- FALSE
[10:26:16.569]                     if (inherits(cond, "message")) {
[10:26:16.569]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:16.569]                       if (muffled) 
[10:26:16.569]                         invokeRestart("muffleMessage")
[10:26:16.569]                     }
[10:26:16.569]                     else if (inherits(cond, "warning")) {
[10:26:16.569]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:16.569]                       if (muffled) 
[10:26:16.569]                         invokeRestart("muffleWarning")
[10:26:16.569]                     }
[10:26:16.569]                     else if (inherits(cond, "condition")) {
[10:26:16.569]                       if (!is.null(pattern)) {
[10:26:16.569]                         computeRestarts <- base::computeRestarts
[10:26:16.569]                         grepl <- base::grepl
[10:26:16.569]                         restarts <- computeRestarts(cond)
[10:26:16.569]                         for (restart in restarts) {
[10:26:16.569]                           name <- restart$name
[10:26:16.569]                           if (is.null(name)) 
[10:26:16.569]                             next
[10:26:16.569]                           if (!grepl(pattern, name)) 
[10:26:16.569]                             next
[10:26:16.569]                           invokeRestart(restart)
[10:26:16.569]                           muffled <- TRUE
[10:26:16.569]                           break
[10:26:16.569]                         }
[10:26:16.569]                       }
[10:26:16.569]                     }
[10:26:16.569]                     invisible(muffled)
[10:26:16.569]                   }
[10:26:16.569]                   muffleCondition(cond)
[10:26:16.569]                 })
[10:26:16.569]             }))
[10:26:16.569]             future::FutureResult(value = ...future.value$value, 
[10:26:16.569]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:16.569]                   ...future.rng), globalenv = if (FALSE) 
[10:26:16.569]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:16.569]                     ...future.globalenv.names))
[10:26:16.569]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:16.569]         }, condition = base::local({
[10:26:16.569]             c <- base::c
[10:26:16.569]             inherits <- base::inherits
[10:26:16.569]             invokeRestart <- base::invokeRestart
[10:26:16.569]             length <- base::length
[10:26:16.569]             list <- base::list
[10:26:16.569]             seq.int <- base::seq.int
[10:26:16.569]             signalCondition <- base::signalCondition
[10:26:16.569]             sys.calls <- base::sys.calls
[10:26:16.569]             `[[` <- base::`[[`
[10:26:16.569]             `+` <- base::`+`
[10:26:16.569]             `<<-` <- base::`<<-`
[10:26:16.569]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:16.569]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:16.569]                   3L)]
[10:26:16.569]             }
[10:26:16.569]             function(cond) {
[10:26:16.569]                 is_error <- inherits(cond, "error")
[10:26:16.569]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:16.569]                   NULL)
[10:26:16.569]                 if (is_error) {
[10:26:16.569]                   sessionInformation <- function() {
[10:26:16.569]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:16.569]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:16.569]                       search = base::search(), system = base::Sys.info())
[10:26:16.569]                   }
[10:26:16.569]                   ...future.conditions[[length(...future.conditions) + 
[10:26:16.569]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:16.569]                     cond$call), session = sessionInformation(), 
[10:26:16.569]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:16.569]                   signalCondition(cond)
[10:26:16.569]                 }
[10:26:16.569]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:16.569]                 "immediateCondition"))) {
[10:26:16.569]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:16.569]                   ...future.conditions[[length(...future.conditions) + 
[10:26:16.569]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:16.569]                   if (TRUE && !signal) {
[10:26:16.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:16.569]                     {
[10:26:16.569]                       inherits <- base::inherits
[10:26:16.569]                       invokeRestart <- base::invokeRestart
[10:26:16.569]                       is.null <- base::is.null
[10:26:16.569]                       muffled <- FALSE
[10:26:16.569]                       if (inherits(cond, "message")) {
[10:26:16.569]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:16.569]                         if (muffled) 
[10:26:16.569]                           invokeRestart("muffleMessage")
[10:26:16.569]                       }
[10:26:16.569]                       else if (inherits(cond, "warning")) {
[10:26:16.569]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:16.569]                         if (muffled) 
[10:26:16.569]                           invokeRestart("muffleWarning")
[10:26:16.569]                       }
[10:26:16.569]                       else if (inherits(cond, "condition")) {
[10:26:16.569]                         if (!is.null(pattern)) {
[10:26:16.569]                           computeRestarts <- base::computeRestarts
[10:26:16.569]                           grepl <- base::grepl
[10:26:16.569]                           restarts <- computeRestarts(cond)
[10:26:16.569]                           for (restart in restarts) {
[10:26:16.569]                             name <- restart$name
[10:26:16.569]                             if (is.null(name)) 
[10:26:16.569]                               next
[10:26:16.569]                             if (!grepl(pattern, name)) 
[10:26:16.569]                               next
[10:26:16.569]                             invokeRestart(restart)
[10:26:16.569]                             muffled <- TRUE
[10:26:16.569]                             break
[10:26:16.569]                           }
[10:26:16.569]                         }
[10:26:16.569]                       }
[10:26:16.569]                       invisible(muffled)
[10:26:16.569]                     }
[10:26:16.569]                     muffleCondition(cond, pattern = "^muffle")
[10:26:16.569]                   }
[10:26:16.569]                 }
[10:26:16.569]                 else {
[10:26:16.569]                   if (TRUE) {
[10:26:16.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:16.569]                     {
[10:26:16.569]                       inherits <- base::inherits
[10:26:16.569]                       invokeRestart <- base::invokeRestart
[10:26:16.569]                       is.null <- base::is.null
[10:26:16.569]                       muffled <- FALSE
[10:26:16.569]                       if (inherits(cond, "message")) {
[10:26:16.569]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:16.569]                         if (muffled) 
[10:26:16.569]                           invokeRestart("muffleMessage")
[10:26:16.569]                       }
[10:26:16.569]                       else if (inherits(cond, "warning")) {
[10:26:16.569]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:16.569]                         if (muffled) 
[10:26:16.569]                           invokeRestart("muffleWarning")
[10:26:16.569]                       }
[10:26:16.569]                       else if (inherits(cond, "condition")) {
[10:26:16.569]                         if (!is.null(pattern)) {
[10:26:16.569]                           computeRestarts <- base::computeRestarts
[10:26:16.569]                           grepl <- base::grepl
[10:26:16.569]                           restarts <- computeRestarts(cond)
[10:26:16.569]                           for (restart in restarts) {
[10:26:16.569]                             name <- restart$name
[10:26:16.569]                             if (is.null(name)) 
[10:26:16.569]                               next
[10:26:16.569]                             if (!grepl(pattern, name)) 
[10:26:16.569]                               next
[10:26:16.569]                             invokeRestart(restart)
[10:26:16.569]                             muffled <- TRUE
[10:26:16.569]                             break
[10:26:16.569]                           }
[10:26:16.569]                         }
[10:26:16.569]                       }
[10:26:16.569]                       invisible(muffled)
[10:26:16.569]                     }
[10:26:16.569]                     muffleCondition(cond, pattern = "^muffle")
[10:26:16.569]                   }
[10:26:16.569]                 }
[10:26:16.569]             }
[10:26:16.569]         }))
[10:26:16.569]     }, error = function(ex) {
[10:26:16.569]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:16.569]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:16.569]                 ...future.rng), started = ...future.startTime, 
[10:26:16.569]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:16.569]             version = "1.8"), class = "FutureResult")
[10:26:16.569]     }, finally = {
[10:26:16.569]         if (!identical(...future.workdir, getwd())) 
[10:26:16.569]             setwd(...future.workdir)
[10:26:16.569]         {
[10:26:16.569]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:16.569]                 ...future.oldOptions$nwarnings <- NULL
[10:26:16.569]             }
[10:26:16.569]             base::options(...future.oldOptions)
[10:26:16.569]             if (.Platform$OS.type == "windows") {
[10:26:16.569]                 old_names <- names(...future.oldEnvVars)
[10:26:16.569]                 envs <- base::Sys.getenv()
[10:26:16.569]                 names <- names(envs)
[10:26:16.569]                 common <- intersect(names, old_names)
[10:26:16.569]                 added <- setdiff(names, old_names)
[10:26:16.569]                 removed <- setdiff(old_names, names)
[10:26:16.569]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:16.569]                   envs[common]]
[10:26:16.569]                 NAMES <- toupper(changed)
[10:26:16.569]                 args <- list()
[10:26:16.569]                 for (kk in seq_along(NAMES)) {
[10:26:16.569]                   name <- changed[[kk]]
[10:26:16.569]                   NAME <- NAMES[[kk]]
[10:26:16.569]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.569]                     next
[10:26:16.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:16.569]                 }
[10:26:16.569]                 NAMES <- toupper(added)
[10:26:16.569]                 for (kk in seq_along(NAMES)) {
[10:26:16.569]                   name <- added[[kk]]
[10:26:16.569]                   NAME <- NAMES[[kk]]
[10:26:16.569]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.569]                     next
[10:26:16.569]                   args[[name]] <- ""
[10:26:16.569]                 }
[10:26:16.569]                 NAMES <- toupper(removed)
[10:26:16.569]                 for (kk in seq_along(NAMES)) {
[10:26:16.569]                   name <- removed[[kk]]
[10:26:16.569]                   NAME <- NAMES[[kk]]
[10:26:16.569]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:16.569]                     next
[10:26:16.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:16.569]                 }
[10:26:16.569]                 if (length(args) > 0) 
[10:26:16.569]                   base::do.call(base::Sys.setenv, args = args)
[10:26:16.569]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:16.569]             }
[10:26:16.569]             else {
[10:26:16.569]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:16.569]             }
[10:26:16.569]             {
[10:26:16.569]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:16.569]                   0L) {
[10:26:16.569]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:16.569]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:16.569]                   base::options(opts)
[10:26:16.569]                 }
[10:26:16.569]                 {
[10:26:16.569]                   {
[10:26:16.569]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:16.569]                     NULL
[10:26:16.569]                   }
[10:26:16.569]                   options(future.plan = NULL)
[10:26:16.569]                   if (is.na(NA_character_)) 
[10:26:16.569]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:16.569]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:16.569]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:16.569]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:16.569]                     envir = parent.frame()) 
[10:26:16.569]                   {
[10:26:16.569]                     if (is.function(workers)) 
[10:26:16.569]                       workers <- workers()
[10:26:16.569]                     workers <- structure(as.integer(workers), 
[10:26:16.569]                       class = class(workers))
[10:26:16.569]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:16.569]                       workers >= 1)
[10:26:16.569]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:16.569]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:16.569]                     }
[10:26:16.569]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:16.569]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:16.569]                       envir = envir)
[10:26:16.569]                     if (!future$lazy) 
[10:26:16.569]                       future <- run(future)
[10:26:16.569]                     invisible(future)
[10:26:16.569]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:16.569]                 }
[10:26:16.569]             }
[10:26:16.569]         }
[10:26:16.569]     })
[10:26:16.569]     if (TRUE) {
[10:26:16.569]         base::sink(type = "output", split = FALSE)
[10:26:16.569]         if (TRUE) {
[10:26:16.569]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:16.569]         }
[10:26:16.569]         else {
[10:26:16.569]             ...future.result["stdout"] <- base::list(NULL)
[10:26:16.569]         }
[10:26:16.569]         base::close(...future.stdout)
[10:26:16.569]         ...future.stdout <- NULL
[10:26:16.569]     }
[10:26:16.569]     ...future.result$conditions <- ...future.conditions
[10:26:16.569]     ...future.result$finished <- base::Sys.time()
[10:26:16.569]     ...future.result
[10:26:16.569] }
[10:26:16.571] Exporting 1 global objects (1.01 KiB) to cluster node #1 ...
[10:26:16.572] Exporting ‘x’ (1.01 KiB) to cluster node #1 ...
[10:26:16.572] Exporting ‘x’ (1.01 KiB) to cluster node #1 ... DONE
[10:26:16.572] Exporting 1 global objects (1.01 KiB) to cluster node #1 ... DONE
[10:26:16.573] MultisessionFuture started
[10:26:16.573] - Launch lazy future ... done
[10:26:16.573] run() for ‘MultisessionFuture’ ... done
[10:26:16.573] result() for ClusterFuture ...
[10:26:16.573] receiveMessageFromWorker() for ClusterFuture ...
[10:26:16.573] - Validating connection of MultisessionFuture
[10:26:16.618] - received message: FutureResult
[10:26:16.618] - Received FutureResult
[10:26:16.618] - Erased future from FutureRegistry
[10:26:16.619] result() for ClusterFuture ...
[10:26:16.619] - result already collected: FutureResult
[10:26:16.619] result() for ClusterFuture ... done
[10:26:16.619] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:16.619] result() for ClusterFuture ... done
[10:26:16.619] result() for ClusterFuture ...
[10:26:16.619] - result already collected: FutureResult
[10:26:16.619] result() for ClusterFuture ... done
value(f) = ‘TRUE’
Testing with 2 cores ... DONE
> 
> message("*** Tricky use cases related to globals ... DONE")
*** Tricky use cases related to globals ... DONE
> 
> source("incl/end.R")
[10:26:16.620] plan(): Setting new future strategy stack:
[10:26:16.620] List of future strategies:
[10:26:16.620] 1. FutureStrategy:
[10:26:16.620]    - args: function (..., envir = parent.frame())
[10:26:16.620]    - tweaked: FALSE
[10:26:16.620]    - call: future::plan(oplan)
[10:26:16.621] plan(): nbrOfWorkers() = 1
> 
