
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:05:06.155] plan(): Setting new future strategy stack:
[16:05:06.156] List of future strategies:
[16:05:06.156] 1. sequential:
[16:05:06.156]    - args: function (..., envir = parent.frame())
[16:05:06.156]    - tweaked: FALSE
[16:05:06.156]    - call: future::plan("sequential")
[16:05:06.170] plan(): nbrOfWorkers() = 1
> library("listenv")
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Tricky use cases related to globals ...")
*** Tricky use cases related to globals ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   message("- Local variables with the same name as globals ...")
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     methods <- c("conservative", "ordered")
+     for (method in methods) {
+       options(future.globals.method = method)
+       message(sprintf("Method for identifying globals: '%s' ...", method))
+ 
+       a <- 3
+ 
+       yTruth <- local({
+         b <- a
+         a <- 2
+         a * b
+       })
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       }
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       a <- 3
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       } %lazy% TRUE
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         }
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         } %lazy% TRUE
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Assert that `a` is resolved and turned into a constant future
+       ## at the moment when future `b` is created.
+       ## Requires options(future.globals.resolve = TRUE).
+       a <- future(1)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+ 
+       ## BUG FIX: In future (<= 1.0.0) a global 'pkg' would be
+       ## overwritten by the name of the last package attached
+       ## by the future.
+       pkg <- "foo"
+       f <- sequential({ pkg })
+       v <- value(f)
+       message(sprintf("value(f) = %s", sQuote(v)))
+       stopifnot(pkg == "foo", v == "foo")
+       
+       message(sprintf("Method for identifying globals: '%s' ... DONE", method))
+     }
+ 
+     ## BUG FIX: In globals (<= 0.10.3) a global 'x' in LHS of an assignment
+     ## would be missed.
+     options(future.globals.method = "ordered")
+ 
+     ## A local
+     x <- 1
+     f <- future({ x <- 0; x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 1)
+     
+     ## A global
+     x <- 1
+     f <- future({ x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 2)
+ 
+     ## A global
+     x <- function() TRUE
+     f <- future({ x <- x(); x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == TRUE)
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- Local variables with the same name as globals ...
- plan('sequential') ...
[16:05:06.263] plan(): Setting new future strategy stack:
[16:05:06.263] List of future strategies:
[16:05:06.263] 1. sequential:
[16:05:06.263]    - args: function (..., envir = parent.frame())
[16:05:06.263]    - tweaked: FALSE
[16:05:06.263]    - call: plan(strategy)
[16:05:06.275] plan(): nbrOfWorkers() = 1
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.277] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.277] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:06.284] - globals found: [3] ‘{’, ‘<-’, ‘*’
[16:05:06.284] Searching for globals ... DONE
[16:05:06.284] Resolving globals: TRUE
[16:05:06.284] Resolving any globals that are futures ...
[16:05:06.284] - globals: [3] ‘{’, ‘<-’, ‘*’
[16:05:06.284] Resolving any globals that are futures ... DONE
[16:05:06.285] 
[16:05:06.285] 
[16:05:06.285] getGlobalsAndPackages() ... DONE
[16:05:06.286] run() for ‘Future’ ...
[16:05:06.286] - state: ‘created’
[16:05:06.286] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.286] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.286] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.287]   - Field: ‘label’
[16:05:06.287]   - Field: ‘local’
[16:05:06.287]   - Field: ‘owner’
[16:05:06.287]   - Field: ‘envir’
[16:05:06.287]   - Field: ‘packages’
[16:05:06.287]   - Field: ‘gc’
[16:05:06.287]   - Field: ‘conditions’
[16:05:06.287]   - Field: ‘expr’
[16:05:06.287]   - Field: ‘uuid’
[16:05:06.288]   - Field: ‘seed’
[16:05:06.288]   - Field: ‘version’
[16:05:06.288]   - Field: ‘result’
[16:05:06.288]   - Field: ‘asynchronous’
[16:05:06.288]   - Field: ‘calls’
[16:05:06.288]   - Field: ‘globals’
[16:05:06.288]   - Field: ‘stdout’
[16:05:06.288]   - Field: ‘earlySignal’
[16:05:06.288]   - Field: ‘lazy’
[16:05:06.288]   - Field: ‘state’
[16:05:06.288] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.289] - Launch lazy future ...
[16:05:06.289] Packages needed by the future expression (n = 0): <none>
[16:05:06.289] Packages needed by future strategies (n = 0): <none>
[16:05:06.290] {
[16:05:06.290]     {
[16:05:06.290]         {
[16:05:06.290]             ...future.startTime <- base::Sys.time()
[16:05:06.290]             {
[16:05:06.290]                 {
[16:05:06.290]                   {
[16:05:06.290]                     base::local({
[16:05:06.290]                       has_future <- base::requireNamespace("future", 
[16:05:06.290]                         quietly = TRUE)
[16:05:06.290]                       if (has_future) {
[16:05:06.290]                         ns <- base::getNamespace("future")
[16:05:06.290]                         version <- ns[[".package"]][["version"]]
[16:05:06.290]                         if (is.null(version)) 
[16:05:06.290]                           version <- utils::packageVersion("future")
[16:05:06.290]                       }
[16:05:06.290]                       else {
[16:05:06.290]                         version <- NULL
[16:05:06.290]                       }
[16:05:06.290]                       if (!has_future || version < "1.8.0") {
[16:05:06.290]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.290]                           "", base::R.version$version.string), 
[16:05:06.290]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.290]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.290]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.290]                             "release", "version")], collapse = " "), 
[16:05:06.290]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.290]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.290]                           info)
[16:05:06.290]                         info <- base::paste(info, collapse = "; ")
[16:05:06.290]                         if (!has_future) {
[16:05:06.290]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.290]                             info)
[16:05:06.290]                         }
[16:05:06.290]                         else {
[16:05:06.290]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.290]                             info, version)
[16:05:06.290]                         }
[16:05:06.290]                         base::stop(msg)
[16:05:06.290]                       }
[16:05:06.290]                     })
[16:05:06.290]                   }
[16:05:06.290]                   options(future.plan = NULL)
[16:05:06.290]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.290]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.290]                 }
[16:05:06.290]                 ...future.workdir <- getwd()
[16:05:06.290]             }
[16:05:06.290]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.290]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.290]         }
[16:05:06.290]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.290]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:06.290]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.290]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.290]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.290]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.290]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.290]             base::names(...future.oldOptions))
[16:05:06.290]     }
[16:05:06.290]     if (FALSE) {
[16:05:06.290]     }
[16:05:06.290]     else {
[16:05:06.290]         if (TRUE) {
[16:05:06.290]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.290]                 open = "w")
[16:05:06.290]         }
[16:05:06.290]         else {
[16:05:06.290]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.290]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.290]         }
[16:05:06.290]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.290]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.290]             base::sink(type = "output", split = FALSE)
[16:05:06.290]             base::close(...future.stdout)
[16:05:06.290]         }, add = TRUE)
[16:05:06.290]     }
[16:05:06.290]     ...future.frame <- base::sys.nframe()
[16:05:06.290]     ...future.conditions <- base::list()
[16:05:06.290]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.290]     if (FALSE) {
[16:05:06.290]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.290]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.290]     }
[16:05:06.290]     ...future.result <- base::tryCatch({
[16:05:06.290]         base::withCallingHandlers({
[16:05:06.290]             ...future.value <- base::withVisible(base::local({
[16:05:06.290]                 b <- a
[16:05:06.290]                 a <- 2
[16:05:06.290]                 a * b
[16:05:06.290]             }))
[16:05:06.290]             future::FutureResult(value = ...future.value$value, 
[16:05:06.290]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.290]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.290]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.290]                     ...future.globalenv.names))
[16:05:06.290]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.290]         }, condition = base::local({
[16:05:06.290]             c <- base::c
[16:05:06.290]             inherits <- base::inherits
[16:05:06.290]             invokeRestart <- base::invokeRestart
[16:05:06.290]             length <- base::length
[16:05:06.290]             list <- base::list
[16:05:06.290]             seq.int <- base::seq.int
[16:05:06.290]             signalCondition <- base::signalCondition
[16:05:06.290]             sys.calls <- base::sys.calls
[16:05:06.290]             `[[` <- base::`[[`
[16:05:06.290]             `+` <- base::`+`
[16:05:06.290]             `<<-` <- base::`<<-`
[16:05:06.290]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.290]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.290]                   3L)]
[16:05:06.290]             }
[16:05:06.290]             function(cond) {
[16:05:06.290]                 is_error <- inherits(cond, "error")
[16:05:06.290]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.290]                   NULL)
[16:05:06.290]                 if (is_error) {
[16:05:06.290]                   sessionInformation <- function() {
[16:05:06.290]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.290]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.290]                       search = base::search(), system = base::Sys.info())
[16:05:06.290]                   }
[16:05:06.290]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.290]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.290]                     cond$call), session = sessionInformation(), 
[16:05:06.290]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.290]                   signalCondition(cond)
[16:05:06.290]                 }
[16:05:06.290]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.290]                 "immediateCondition"))) {
[16:05:06.290]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.290]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.290]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.290]                   if (TRUE && !signal) {
[16:05:06.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.290]                     {
[16:05:06.290]                       inherits <- base::inherits
[16:05:06.290]                       invokeRestart <- base::invokeRestart
[16:05:06.290]                       is.null <- base::is.null
[16:05:06.290]                       muffled <- FALSE
[16:05:06.290]                       if (inherits(cond, "message")) {
[16:05:06.290]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.290]                         if (muffled) 
[16:05:06.290]                           invokeRestart("muffleMessage")
[16:05:06.290]                       }
[16:05:06.290]                       else if (inherits(cond, "warning")) {
[16:05:06.290]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.290]                         if (muffled) 
[16:05:06.290]                           invokeRestart("muffleWarning")
[16:05:06.290]                       }
[16:05:06.290]                       else if (inherits(cond, "condition")) {
[16:05:06.290]                         if (!is.null(pattern)) {
[16:05:06.290]                           computeRestarts <- base::computeRestarts
[16:05:06.290]                           grepl <- base::grepl
[16:05:06.290]                           restarts <- computeRestarts(cond)
[16:05:06.290]                           for (restart in restarts) {
[16:05:06.290]                             name <- restart$name
[16:05:06.290]                             if (is.null(name)) 
[16:05:06.290]                               next
[16:05:06.290]                             if (!grepl(pattern, name)) 
[16:05:06.290]                               next
[16:05:06.290]                             invokeRestart(restart)
[16:05:06.290]                             muffled <- TRUE
[16:05:06.290]                             break
[16:05:06.290]                           }
[16:05:06.290]                         }
[16:05:06.290]                       }
[16:05:06.290]                       invisible(muffled)
[16:05:06.290]                     }
[16:05:06.290]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.290]                   }
[16:05:06.290]                 }
[16:05:06.290]                 else {
[16:05:06.290]                   if (TRUE) {
[16:05:06.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.290]                     {
[16:05:06.290]                       inherits <- base::inherits
[16:05:06.290]                       invokeRestart <- base::invokeRestart
[16:05:06.290]                       is.null <- base::is.null
[16:05:06.290]                       muffled <- FALSE
[16:05:06.290]                       if (inherits(cond, "message")) {
[16:05:06.290]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.290]                         if (muffled) 
[16:05:06.290]                           invokeRestart("muffleMessage")
[16:05:06.290]                       }
[16:05:06.290]                       else if (inherits(cond, "warning")) {
[16:05:06.290]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.290]                         if (muffled) 
[16:05:06.290]                           invokeRestart("muffleWarning")
[16:05:06.290]                       }
[16:05:06.290]                       else if (inherits(cond, "condition")) {
[16:05:06.290]                         if (!is.null(pattern)) {
[16:05:06.290]                           computeRestarts <- base::computeRestarts
[16:05:06.290]                           grepl <- base::grepl
[16:05:06.290]                           restarts <- computeRestarts(cond)
[16:05:06.290]                           for (restart in restarts) {
[16:05:06.290]                             name <- restart$name
[16:05:06.290]                             if (is.null(name)) 
[16:05:06.290]                               next
[16:05:06.290]                             if (!grepl(pattern, name)) 
[16:05:06.290]                               next
[16:05:06.290]                             invokeRestart(restart)
[16:05:06.290]                             muffled <- TRUE
[16:05:06.290]                             break
[16:05:06.290]                           }
[16:05:06.290]                         }
[16:05:06.290]                       }
[16:05:06.290]                       invisible(muffled)
[16:05:06.290]                     }
[16:05:06.290]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.290]                   }
[16:05:06.290]                 }
[16:05:06.290]             }
[16:05:06.290]         }))
[16:05:06.290]     }, error = function(ex) {
[16:05:06.290]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.290]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.290]                 ...future.rng), started = ...future.startTime, 
[16:05:06.290]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.290]             version = "1.8"), class = "FutureResult")
[16:05:06.290]     }, finally = {
[16:05:06.290]         if (!identical(...future.workdir, getwd())) 
[16:05:06.290]             setwd(...future.workdir)
[16:05:06.290]         {
[16:05:06.290]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.290]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.290]             }
[16:05:06.290]             base::options(...future.oldOptions)
[16:05:06.290]             if (.Platform$OS.type == "windows") {
[16:05:06.290]                 old_names <- names(...future.oldEnvVars)
[16:05:06.290]                 envs <- base::Sys.getenv()
[16:05:06.290]                 names <- names(envs)
[16:05:06.290]                 common <- intersect(names, old_names)
[16:05:06.290]                 added <- setdiff(names, old_names)
[16:05:06.290]                 removed <- setdiff(old_names, names)
[16:05:06.290]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.290]                   envs[common]]
[16:05:06.290]                 NAMES <- toupper(changed)
[16:05:06.290]                 args <- list()
[16:05:06.290]                 for (kk in seq_along(NAMES)) {
[16:05:06.290]                   name <- changed[[kk]]
[16:05:06.290]                   NAME <- NAMES[[kk]]
[16:05:06.290]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.290]                     next
[16:05:06.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.290]                 }
[16:05:06.290]                 NAMES <- toupper(added)
[16:05:06.290]                 for (kk in seq_along(NAMES)) {
[16:05:06.290]                   name <- added[[kk]]
[16:05:06.290]                   NAME <- NAMES[[kk]]
[16:05:06.290]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.290]                     next
[16:05:06.290]                   args[[name]] <- ""
[16:05:06.290]                 }
[16:05:06.290]                 NAMES <- toupper(removed)
[16:05:06.290]                 for (kk in seq_along(NAMES)) {
[16:05:06.290]                   name <- removed[[kk]]
[16:05:06.290]                   NAME <- NAMES[[kk]]
[16:05:06.290]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.290]                     next
[16:05:06.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.290]                 }
[16:05:06.290]                 if (length(args) > 0) 
[16:05:06.290]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.290]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.290]             }
[16:05:06.290]             else {
[16:05:06.290]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.290]             }
[16:05:06.290]             {
[16:05:06.290]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.290]                   0L) {
[16:05:06.290]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.290]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.290]                   base::options(opts)
[16:05:06.290]                 }
[16:05:06.290]                 {
[16:05:06.290]                   {
[16:05:06.290]                     NULL
[16:05:06.290]                     RNGkind("Mersenne-Twister")
[16:05:06.290]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.290]                       inherits = FALSE)
[16:05:06.290]                   }
[16:05:06.290]                   options(future.plan = NULL)
[16:05:06.290]                   if (is.na(NA_character_)) 
[16:05:06.290]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.290]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.290]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.290]                   {
[16:05:06.290]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.290]                     if (!future$lazy) 
[16:05:06.290]                       future <- run(future)
[16:05:06.290]                     invisible(future)
[16:05:06.290]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.290]                 }
[16:05:06.290]             }
[16:05:06.290]         }
[16:05:06.290]     })
[16:05:06.290]     if (TRUE) {
[16:05:06.290]         base::sink(type = "output", split = FALSE)
[16:05:06.290]         if (TRUE) {
[16:05:06.290]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.290]         }
[16:05:06.290]         else {
[16:05:06.290]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.290]         }
[16:05:06.290]         base::close(...future.stdout)
[16:05:06.290]         ...future.stdout <- NULL
[16:05:06.290]     }
[16:05:06.290]     ...future.result$conditions <- ...future.conditions
[16:05:06.290]     ...future.result$finished <- base::Sys.time()
[16:05:06.290]     ...future.result
[16:05:06.290] }
[16:05:06.292] plan(): Setting new future strategy stack:
[16:05:06.292] List of future strategies:
[16:05:06.292] 1. sequential:
[16:05:06.292]    - args: function (..., envir = parent.frame())
[16:05:06.292]    - tweaked: FALSE
[16:05:06.292]    - call: NULL
[16:05:06.293] plan(): nbrOfWorkers() = 1
[16:05:06.294] plan(): Setting new future strategy stack:
[16:05:06.294] List of future strategies:
[16:05:06.294] 1. sequential:
[16:05:06.294]    - args: function (..., envir = parent.frame())
[16:05:06.294]    - tweaked: FALSE
[16:05:06.294]    - call: plan(strategy)
[16:05:06.294] plan(): nbrOfWorkers() = 1
[16:05:06.294] SequentialFuture started (and completed)
[16:05:06.295] - Launch lazy future ... done
[16:05:06.295] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.296] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.296] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:06.297] - globals found: [3] ‘{’, ‘<-’, ‘*’
[16:05:06.297] Searching for globals ... DONE
[16:05:06.297] Resolving globals: TRUE
[16:05:06.298] Resolving any globals that are futures ...
[16:05:06.298] - globals: [3] ‘{’, ‘<-’, ‘*’
[16:05:06.298] Resolving any globals that are futures ... DONE
[16:05:06.298] 
[16:05:06.298] 
[16:05:06.298] getGlobalsAndPackages() ... DONE
[16:05:06.300] run() for ‘Future’ ...
[16:05:06.301] - state: ‘created’
[16:05:06.301] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.301] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.301] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.301]   - Field: ‘label’
[16:05:06.301]   - Field: ‘local’
[16:05:06.301]   - Field: ‘owner’
[16:05:06.301]   - Field: ‘envir’
[16:05:06.302]   - Field: ‘packages’
[16:05:06.302]   - Field: ‘gc’
[16:05:06.302]   - Field: ‘conditions’
[16:05:06.302]   - Field: ‘expr’
[16:05:06.302]   - Field: ‘uuid’
[16:05:06.302]   - Field: ‘seed’
[16:05:06.302]   - Field: ‘version’
[16:05:06.302]   - Field: ‘result’
[16:05:06.302]   - Field: ‘asynchronous’
[16:05:06.302]   - Field: ‘calls’
[16:05:06.303]   - Field: ‘globals’
[16:05:06.303]   - Field: ‘stdout’
[16:05:06.303]   - Field: ‘earlySignal’
[16:05:06.303]   - Field: ‘lazy’
[16:05:06.303]   - Field: ‘state’
[16:05:06.303] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.303] - Launch lazy future ...
[16:05:06.303] Packages needed by the future expression (n = 0): <none>
[16:05:06.303] Packages needed by future strategies (n = 0): <none>
[16:05:06.304] {
[16:05:06.304]     {
[16:05:06.304]         {
[16:05:06.304]             ...future.startTime <- base::Sys.time()
[16:05:06.304]             {
[16:05:06.304]                 {
[16:05:06.304]                   {
[16:05:06.304]                     base::local({
[16:05:06.304]                       has_future <- base::requireNamespace("future", 
[16:05:06.304]                         quietly = TRUE)
[16:05:06.304]                       if (has_future) {
[16:05:06.304]                         ns <- base::getNamespace("future")
[16:05:06.304]                         version <- ns[[".package"]][["version"]]
[16:05:06.304]                         if (is.null(version)) 
[16:05:06.304]                           version <- utils::packageVersion("future")
[16:05:06.304]                       }
[16:05:06.304]                       else {
[16:05:06.304]                         version <- NULL
[16:05:06.304]                       }
[16:05:06.304]                       if (!has_future || version < "1.8.0") {
[16:05:06.304]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.304]                           "", base::R.version$version.string), 
[16:05:06.304]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.304]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.304]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.304]                             "release", "version")], collapse = " "), 
[16:05:06.304]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.304]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.304]                           info)
[16:05:06.304]                         info <- base::paste(info, collapse = "; ")
[16:05:06.304]                         if (!has_future) {
[16:05:06.304]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.304]                             info)
[16:05:06.304]                         }
[16:05:06.304]                         else {
[16:05:06.304]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.304]                             info, version)
[16:05:06.304]                         }
[16:05:06.304]                         base::stop(msg)
[16:05:06.304]                       }
[16:05:06.304]                     })
[16:05:06.304]                   }
[16:05:06.304]                   options(future.plan = NULL)
[16:05:06.304]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.304]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.304]                 }
[16:05:06.304]                 ...future.workdir <- getwd()
[16:05:06.304]             }
[16:05:06.304]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.304]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.304]         }
[16:05:06.304]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.304]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:06.304]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.304]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.304]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.304]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.304]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.304]             base::names(...future.oldOptions))
[16:05:06.304]     }
[16:05:06.304]     if (FALSE) {
[16:05:06.304]     }
[16:05:06.304]     else {
[16:05:06.304]         if (TRUE) {
[16:05:06.304]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.304]                 open = "w")
[16:05:06.304]         }
[16:05:06.304]         else {
[16:05:06.304]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.304]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.304]         }
[16:05:06.304]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.304]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.304]             base::sink(type = "output", split = FALSE)
[16:05:06.304]             base::close(...future.stdout)
[16:05:06.304]         }, add = TRUE)
[16:05:06.304]     }
[16:05:06.304]     ...future.frame <- base::sys.nframe()
[16:05:06.304]     ...future.conditions <- base::list()
[16:05:06.304]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.304]     if (FALSE) {
[16:05:06.304]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.304]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.304]     }
[16:05:06.304]     ...future.result <- base::tryCatch({
[16:05:06.304]         base::withCallingHandlers({
[16:05:06.304]             ...future.value <- base::withVisible(base::local({
[16:05:06.304]                 b <- a
[16:05:06.304]                 a <- 2
[16:05:06.304]                 a * b
[16:05:06.304]             }))
[16:05:06.304]             future::FutureResult(value = ...future.value$value, 
[16:05:06.304]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.304]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.304]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.304]                     ...future.globalenv.names))
[16:05:06.304]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.304]         }, condition = base::local({
[16:05:06.304]             c <- base::c
[16:05:06.304]             inherits <- base::inherits
[16:05:06.304]             invokeRestart <- base::invokeRestart
[16:05:06.304]             length <- base::length
[16:05:06.304]             list <- base::list
[16:05:06.304]             seq.int <- base::seq.int
[16:05:06.304]             signalCondition <- base::signalCondition
[16:05:06.304]             sys.calls <- base::sys.calls
[16:05:06.304]             `[[` <- base::`[[`
[16:05:06.304]             `+` <- base::`+`
[16:05:06.304]             `<<-` <- base::`<<-`
[16:05:06.304]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.304]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.304]                   3L)]
[16:05:06.304]             }
[16:05:06.304]             function(cond) {
[16:05:06.304]                 is_error <- inherits(cond, "error")
[16:05:06.304]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.304]                   NULL)
[16:05:06.304]                 if (is_error) {
[16:05:06.304]                   sessionInformation <- function() {
[16:05:06.304]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.304]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.304]                       search = base::search(), system = base::Sys.info())
[16:05:06.304]                   }
[16:05:06.304]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.304]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.304]                     cond$call), session = sessionInformation(), 
[16:05:06.304]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.304]                   signalCondition(cond)
[16:05:06.304]                 }
[16:05:06.304]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.304]                 "immediateCondition"))) {
[16:05:06.304]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.304]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.304]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.304]                   if (TRUE && !signal) {
[16:05:06.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.304]                     {
[16:05:06.304]                       inherits <- base::inherits
[16:05:06.304]                       invokeRestart <- base::invokeRestart
[16:05:06.304]                       is.null <- base::is.null
[16:05:06.304]                       muffled <- FALSE
[16:05:06.304]                       if (inherits(cond, "message")) {
[16:05:06.304]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.304]                         if (muffled) 
[16:05:06.304]                           invokeRestart("muffleMessage")
[16:05:06.304]                       }
[16:05:06.304]                       else if (inherits(cond, "warning")) {
[16:05:06.304]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.304]                         if (muffled) 
[16:05:06.304]                           invokeRestart("muffleWarning")
[16:05:06.304]                       }
[16:05:06.304]                       else if (inherits(cond, "condition")) {
[16:05:06.304]                         if (!is.null(pattern)) {
[16:05:06.304]                           computeRestarts <- base::computeRestarts
[16:05:06.304]                           grepl <- base::grepl
[16:05:06.304]                           restarts <- computeRestarts(cond)
[16:05:06.304]                           for (restart in restarts) {
[16:05:06.304]                             name <- restart$name
[16:05:06.304]                             if (is.null(name)) 
[16:05:06.304]                               next
[16:05:06.304]                             if (!grepl(pattern, name)) 
[16:05:06.304]                               next
[16:05:06.304]                             invokeRestart(restart)
[16:05:06.304]                             muffled <- TRUE
[16:05:06.304]                             break
[16:05:06.304]                           }
[16:05:06.304]                         }
[16:05:06.304]                       }
[16:05:06.304]                       invisible(muffled)
[16:05:06.304]                     }
[16:05:06.304]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.304]                   }
[16:05:06.304]                 }
[16:05:06.304]                 else {
[16:05:06.304]                   if (TRUE) {
[16:05:06.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.304]                     {
[16:05:06.304]                       inherits <- base::inherits
[16:05:06.304]                       invokeRestart <- base::invokeRestart
[16:05:06.304]                       is.null <- base::is.null
[16:05:06.304]                       muffled <- FALSE
[16:05:06.304]                       if (inherits(cond, "message")) {
[16:05:06.304]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.304]                         if (muffled) 
[16:05:06.304]                           invokeRestart("muffleMessage")
[16:05:06.304]                       }
[16:05:06.304]                       else if (inherits(cond, "warning")) {
[16:05:06.304]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.304]                         if (muffled) 
[16:05:06.304]                           invokeRestart("muffleWarning")
[16:05:06.304]                       }
[16:05:06.304]                       else if (inherits(cond, "condition")) {
[16:05:06.304]                         if (!is.null(pattern)) {
[16:05:06.304]                           computeRestarts <- base::computeRestarts
[16:05:06.304]                           grepl <- base::grepl
[16:05:06.304]                           restarts <- computeRestarts(cond)
[16:05:06.304]                           for (restart in restarts) {
[16:05:06.304]                             name <- restart$name
[16:05:06.304]                             if (is.null(name)) 
[16:05:06.304]                               next
[16:05:06.304]                             if (!grepl(pattern, name)) 
[16:05:06.304]                               next
[16:05:06.304]                             invokeRestart(restart)
[16:05:06.304]                             muffled <- TRUE
[16:05:06.304]                             break
[16:05:06.304]                           }
[16:05:06.304]                         }
[16:05:06.304]                       }
[16:05:06.304]                       invisible(muffled)
[16:05:06.304]                     }
[16:05:06.304]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.304]                   }
[16:05:06.304]                 }
[16:05:06.304]             }
[16:05:06.304]         }))
[16:05:06.304]     }, error = function(ex) {
[16:05:06.304]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.304]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.304]                 ...future.rng), started = ...future.startTime, 
[16:05:06.304]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.304]             version = "1.8"), class = "FutureResult")
[16:05:06.304]     }, finally = {
[16:05:06.304]         if (!identical(...future.workdir, getwd())) 
[16:05:06.304]             setwd(...future.workdir)
[16:05:06.304]         {
[16:05:06.304]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.304]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.304]             }
[16:05:06.304]             base::options(...future.oldOptions)
[16:05:06.304]             if (.Platform$OS.type == "windows") {
[16:05:06.304]                 old_names <- names(...future.oldEnvVars)
[16:05:06.304]                 envs <- base::Sys.getenv()
[16:05:06.304]                 names <- names(envs)
[16:05:06.304]                 common <- intersect(names, old_names)
[16:05:06.304]                 added <- setdiff(names, old_names)
[16:05:06.304]                 removed <- setdiff(old_names, names)
[16:05:06.304]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.304]                   envs[common]]
[16:05:06.304]                 NAMES <- toupper(changed)
[16:05:06.304]                 args <- list()
[16:05:06.304]                 for (kk in seq_along(NAMES)) {
[16:05:06.304]                   name <- changed[[kk]]
[16:05:06.304]                   NAME <- NAMES[[kk]]
[16:05:06.304]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.304]                     next
[16:05:06.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.304]                 }
[16:05:06.304]                 NAMES <- toupper(added)
[16:05:06.304]                 for (kk in seq_along(NAMES)) {
[16:05:06.304]                   name <- added[[kk]]
[16:05:06.304]                   NAME <- NAMES[[kk]]
[16:05:06.304]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.304]                     next
[16:05:06.304]                   args[[name]] <- ""
[16:05:06.304]                 }
[16:05:06.304]                 NAMES <- toupper(removed)
[16:05:06.304]                 for (kk in seq_along(NAMES)) {
[16:05:06.304]                   name <- removed[[kk]]
[16:05:06.304]                   NAME <- NAMES[[kk]]
[16:05:06.304]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.304]                     next
[16:05:06.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.304]                 }
[16:05:06.304]                 if (length(args) > 0) 
[16:05:06.304]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.304]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.304]             }
[16:05:06.304]             else {
[16:05:06.304]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.304]             }
[16:05:06.304]             {
[16:05:06.304]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.304]                   0L) {
[16:05:06.304]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.304]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.304]                   base::options(opts)
[16:05:06.304]                 }
[16:05:06.304]                 {
[16:05:06.304]                   {
[16:05:06.304]                     NULL
[16:05:06.304]                     RNGkind("Mersenne-Twister")
[16:05:06.304]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.304]                       inherits = FALSE)
[16:05:06.304]                   }
[16:05:06.304]                   options(future.plan = NULL)
[16:05:06.304]                   if (is.na(NA_character_)) 
[16:05:06.304]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.304]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.304]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.304]                   {
[16:05:06.304]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.304]                     if (!future$lazy) 
[16:05:06.304]                       future <- run(future)
[16:05:06.304]                     invisible(future)
[16:05:06.304]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.304]                 }
[16:05:06.304]             }
[16:05:06.304]         }
[16:05:06.304]     })
[16:05:06.304]     if (TRUE) {
[16:05:06.304]         base::sink(type = "output", split = FALSE)
[16:05:06.304]         if (TRUE) {
[16:05:06.304]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.304]         }
[16:05:06.304]         else {
[16:05:06.304]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.304]         }
[16:05:06.304]         base::close(...future.stdout)
[16:05:06.304]         ...future.stdout <- NULL
[16:05:06.304]     }
[16:05:06.304]     ...future.result$conditions <- ...future.conditions
[16:05:06.304]     ...future.result$finished <- base::Sys.time()
[16:05:06.304]     ...future.result
[16:05:06.304] }
[16:05:06.305] plan(): Setting new future strategy stack:
[16:05:06.306] List of future strategies:
[16:05:06.306] 1. sequential:
[16:05:06.306]    - args: function (..., envir = parent.frame())
[16:05:06.306]    - tweaked: FALSE
[16:05:06.306]    - call: NULL
[16:05:06.306] plan(): nbrOfWorkers() = 1
[16:05:06.307] plan(): Setting new future strategy stack:
[16:05:06.307] List of future strategies:
[16:05:06.307] 1. sequential:
[16:05:06.307]    - args: function (..., envir = parent.frame())
[16:05:06.307]    - tweaked: FALSE
[16:05:06.307]    - call: plan(strategy)
[16:05:06.307] plan(): nbrOfWorkers() = 1
[16:05:06.307] SequentialFuture started (and completed)
[16:05:06.308] signalConditions() ...
[16:05:06.308]  - include = ‘immediateCondition’
[16:05:06.308]  - exclude = 
[16:05:06.308]  - resignal = FALSE
[16:05:06.308]  - Number of conditions: 1
[16:05:06.308] signalConditions() ... done
[16:05:06.308] - Launch lazy future ... done
[16:05:06.308] run() for ‘SequentialFuture’ ... done
[16:05:06.308] signalConditions() ...
[16:05:06.308]  - include = ‘immediateCondition’
[16:05:06.308]  - exclude = 
[16:05:06.309]  - resignal = FALSE
[16:05:06.309]  - Number of conditions: 1
[16:05:06.309] signalConditions() ... done
[16:05:06.309] Future state: ‘finished’
[16:05:06.309] signalConditions() ...
[16:05:06.309]  - include = ‘condition’
[16:05:06.309]  - exclude = ‘immediateCondition’
[16:05:06.309]  - resignal = TRUE
[16:05:06.309]  - Number of conditions: 1
[16:05:06.309]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:05:06.309] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "11666ca4073c" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:05:06"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.326] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.326] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:06.327] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:06.327] Searching for globals ... DONE
[16:05:06.328] Resolving globals: TRUE
[16:05:06.328] Resolving any globals that are futures ...
[16:05:06.328] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:06.328] Resolving any globals that are futures ... DONE
[16:05:06.328] Resolving futures part of globals (recursively) ...
[16:05:06.330] resolve() on list ...
[16:05:06.331]  recursive: 99
[16:05:06.331]  length: 1
[16:05:06.331]  elements: ‘ii’
[16:05:06.331]  length: 0 (resolved future 1)
[16:05:06.331] resolve() on list ... DONE
[16:05:06.331] - globals: [1] ‘ii’
[16:05:06.331] Resolving futures part of globals (recursively) ... DONE
[16:05:06.332] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:06.332] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:06.333] - globals: [1] ‘ii’
[16:05:06.333] 
[16:05:06.333] getGlobalsAndPackages() ... DONE
[16:05:06.333] run() for ‘Future’ ...
[16:05:06.333] - state: ‘created’
[16:05:06.333] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.333] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.334] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.334]   - Field: ‘label’
[16:05:06.334]   - Field: ‘local’
[16:05:06.334]   - Field: ‘owner’
[16:05:06.334]   - Field: ‘envir’
[16:05:06.334]   - Field: ‘packages’
[16:05:06.334]   - Field: ‘gc’
[16:05:06.334]   - Field: ‘conditions’
[16:05:06.334]   - Field: ‘expr’
[16:05:06.334]   - Field: ‘uuid’
[16:05:06.335]   - Field: ‘seed’
[16:05:06.335]   - Field: ‘version’
[16:05:06.335]   - Field: ‘result’
[16:05:06.335]   - Field: ‘asynchronous’
[16:05:06.335]   - Field: ‘calls’
[16:05:06.335]   - Field: ‘globals’
[16:05:06.335]   - Field: ‘stdout’
[16:05:06.335]   - Field: ‘earlySignal’
[16:05:06.335]   - Field: ‘lazy’
[16:05:06.335]   - Field: ‘state’
[16:05:06.336] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.336] - Launch lazy future ...
[16:05:06.336] Packages needed by the future expression (n = 0): <none>
[16:05:06.336] Packages needed by future strategies (n = 0): <none>
[16:05:06.336] {
[16:05:06.336]     {
[16:05:06.336]         {
[16:05:06.336]             ...future.startTime <- base::Sys.time()
[16:05:06.336]             {
[16:05:06.336]                 {
[16:05:06.336]                   {
[16:05:06.336]                     base::local({
[16:05:06.336]                       has_future <- base::requireNamespace("future", 
[16:05:06.336]                         quietly = TRUE)
[16:05:06.336]                       if (has_future) {
[16:05:06.336]                         ns <- base::getNamespace("future")
[16:05:06.336]                         version <- ns[[".package"]][["version"]]
[16:05:06.336]                         if (is.null(version)) 
[16:05:06.336]                           version <- utils::packageVersion("future")
[16:05:06.336]                       }
[16:05:06.336]                       else {
[16:05:06.336]                         version <- NULL
[16:05:06.336]                       }
[16:05:06.336]                       if (!has_future || version < "1.8.0") {
[16:05:06.336]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.336]                           "", base::R.version$version.string), 
[16:05:06.336]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.336]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.336]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.336]                             "release", "version")], collapse = " "), 
[16:05:06.336]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.336]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.336]                           info)
[16:05:06.336]                         info <- base::paste(info, collapse = "; ")
[16:05:06.336]                         if (!has_future) {
[16:05:06.336]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.336]                             info)
[16:05:06.336]                         }
[16:05:06.336]                         else {
[16:05:06.336]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.336]                             info, version)
[16:05:06.336]                         }
[16:05:06.336]                         base::stop(msg)
[16:05:06.336]                       }
[16:05:06.336]                     })
[16:05:06.336]                   }
[16:05:06.336]                   options(future.plan = NULL)
[16:05:06.336]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.336]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.336]                 }
[16:05:06.336]                 ...future.workdir <- getwd()
[16:05:06.336]             }
[16:05:06.336]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.336]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.336]         }
[16:05:06.336]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.336]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:06.336]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.336]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.336]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.336]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.336]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.336]             base::names(...future.oldOptions))
[16:05:06.336]     }
[16:05:06.336]     if (FALSE) {
[16:05:06.336]     }
[16:05:06.336]     else {
[16:05:06.336]         if (TRUE) {
[16:05:06.336]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.336]                 open = "w")
[16:05:06.336]         }
[16:05:06.336]         else {
[16:05:06.336]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.336]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.336]         }
[16:05:06.336]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.336]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.336]             base::sink(type = "output", split = FALSE)
[16:05:06.336]             base::close(...future.stdout)
[16:05:06.336]         }, add = TRUE)
[16:05:06.336]     }
[16:05:06.336]     ...future.frame <- base::sys.nframe()
[16:05:06.336]     ...future.conditions <- base::list()
[16:05:06.336]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.336]     if (FALSE) {
[16:05:06.336]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.336]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.336]     }
[16:05:06.336]     ...future.result <- base::tryCatch({
[16:05:06.336]         base::withCallingHandlers({
[16:05:06.336]             ...future.value <- base::withVisible(base::local({
[16:05:06.336]                 b <- a * ii
[16:05:06.336]                 a <- 0
[16:05:06.336]                 b
[16:05:06.336]             }))
[16:05:06.336]             future::FutureResult(value = ...future.value$value, 
[16:05:06.336]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.336]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.336]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.336]                     ...future.globalenv.names))
[16:05:06.336]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.336]         }, condition = base::local({
[16:05:06.336]             c <- base::c
[16:05:06.336]             inherits <- base::inherits
[16:05:06.336]             invokeRestart <- base::invokeRestart
[16:05:06.336]             length <- base::length
[16:05:06.336]             list <- base::list
[16:05:06.336]             seq.int <- base::seq.int
[16:05:06.336]             signalCondition <- base::signalCondition
[16:05:06.336]             sys.calls <- base::sys.calls
[16:05:06.336]             `[[` <- base::`[[`
[16:05:06.336]             `+` <- base::`+`
[16:05:06.336]             `<<-` <- base::`<<-`
[16:05:06.336]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.336]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.336]                   3L)]
[16:05:06.336]             }
[16:05:06.336]             function(cond) {
[16:05:06.336]                 is_error <- inherits(cond, "error")
[16:05:06.336]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.336]                   NULL)
[16:05:06.336]                 if (is_error) {
[16:05:06.336]                   sessionInformation <- function() {
[16:05:06.336]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.336]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.336]                       search = base::search(), system = base::Sys.info())
[16:05:06.336]                   }
[16:05:06.336]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.336]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.336]                     cond$call), session = sessionInformation(), 
[16:05:06.336]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.336]                   signalCondition(cond)
[16:05:06.336]                 }
[16:05:06.336]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.336]                 "immediateCondition"))) {
[16:05:06.336]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.336]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.336]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.336]                   if (TRUE && !signal) {
[16:05:06.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.336]                     {
[16:05:06.336]                       inherits <- base::inherits
[16:05:06.336]                       invokeRestart <- base::invokeRestart
[16:05:06.336]                       is.null <- base::is.null
[16:05:06.336]                       muffled <- FALSE
[16:05:06.336]                       if (inherits(cond, "message")) {
[16:05:06.336]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.336]                         if (muffled) 
[16:05:06.336]                           invokeRestart("muffleMessage")
[16:05:06.336]                       }
[16:05:06.336]                       else if (inherits(cond, "warning")) {
[16:05:06.336]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.336]                         if (muffled) 
[16:05:06.336]                           invokeRestart("muffleWarning")
[16:05:06.336]                       }
[16:05:06.336]                       else if (inherits(cond, "condition")) {
[16:05:06.336]                         if (!is.null(pattern)) {
[16:05:06.336]                           computeRestarts <- base::computeRestarts
[16:05:06.336]                           grepl <- base::grepl
[16:05:06.336]                           restarts <- computeRestarts(cond)
[16:05:06.336]                           for (restart in restarts) {
[16:05:06.336]                             name <- restart$name
[16:05:06.336]                             if (is.null(name)) 
[16:05:06.336]                               next
[16:05:06.336]                             if (!grepl(pattern, name)) 
[16:05:06.336]                               next
[16:05:06.336]                             invokeRestart(restart)
[16:05:06.336]                             muffled <- TRUE
[16:05:06.336]                             break
[16:05:06.336]                           }
[16:05:06.336]                         }
[16:05:06.336]                       }
[16:05:06.336]                       invisible(muffled)
[16:05:06.336]                     }
[16:05:06.336]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.336]                   }
[16:05:06.336]                 }
[16:05:06.336]                 else {
[16:05:06.336]                   if (TRUE) {
[16:05:06.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.336]                     {
[16:05:06.336]                       inherits <- base::inherits
[16:05:06.336]                       invokeRestart <- base::invokeRestart
[16:05:06.336]                       is.null <- base::is.null
[16:05:06.336]                       muffled <- FALSE
[16:05:06.336]                       if (inherits(cond, "message")) {
[16:05:06.336]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.336]                         if (muffled) 
[16:05:06.336]                           invokeRestart("muffleMessage")
[16:05:06.336]                       }
[16:05:06.336]                       else if (inherits(cond, "warning")) {
[16:05:06.336]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.336]                         if (muffled) 
[16:05:06.336]                           invokeRestart("muffleWarning")
[16:05:06.336]                       }
[16:05:06.336]                       else if (inherits(cond, "condition")) {
[16:05:06.336]                         if (!is.null(pattern)) {
[16:05:06.336]                           computeRestarts <- base::computeRestarts
[16:05:06.336]                           grepl <- base::grepl
[16:05:06.336]                           restarts <- computeRestarts(cond)
[16:05:06.336]                           for (restart in restarts) {
[16:05:06.336]                             name <- restart$name
[16:05:06.336]                             if (is.null(name)) 
[16:05:06.336]                               next
[16:05:06.336]                             if (!grepl(pattern, name)) 
[16:05:06.336]                               next
[16:05:06.336]                             invokeRestart(restart)
[16:05:06.336]                             muffled <- TRUE
[16:05:06.336]                             break
[16:05:06.336]                           }
[16:05:06.336]                         }
[16:05:06.336]                       }
[16:05:06.336]                       invisible(muffled)
[16:05:06.336]                     }
[16:05:06.336]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.336]                   }
[16:05:06.336]                 }
[16:05:06.336]             }
[16:05:06.336]         }))
[16:05:06.336]     }, error = function(ex) {
[16:05:06.336]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.336]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.336]                 ...future.rng), started = ...future.startTime, 
[16:05:06.336]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.336]             version = "1.8"), class = "FutureResult")
[16:05:06.336]     }, finally = {
[16:05:06.336]         if (!identical(...future.workdir, getwd())) 
[16:05:06.336]             setwd(...future.workdir)
[16:05:06.336]         {
[16:05:06.336]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.336]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.336]             }
[16:05:06.336]             base::options(...future.oldOptions)
[16:05:06.336]             if (.Platform$OS.type == "windows") {
[16:05:06.336]                 old_names <- names(...future.oldEnvVars)
[16:05:06.336]                 envs <- base::Sys.getenv()
[16:05:06.336]                 names <- names(envs)
[16:05:06.336]                 common <- intersect(names, old_names)
[16:05:06.336]                 added <- setdiff(names, old_names)
[16:05:06.336]                 removed <- setdiff(old_names, names)
[16:05:06.336]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.336]                   envs[common]]
[16:05:06.336]                 NAMES <- toupper(changed)
[16:05:06.336]                 args <- list()
[16:05:06.336]                 for (kk in seq_along(NAMES)) {
[16:05:06.336]                   name <- changed[[kk]]
[16:05:06.336]                   NAME <- NAMES[[kk]]
[16:05:06.336]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.336]                     next
[16:05:06.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.336]                 }
[16:05:06.336]                 NAMES <- toupper(added)
[16:05:06.336]                 for (kk in seq_along(NAMES)) {
[16:05:06.336]                   name <- added[[kk]]
[16:05:06.336]                   NAME <- NAMES[[kk]]
[16:05:06.336]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.336]                     next
[16:05:06.336]                   args[[name]] <- ""
[16:05:06.336]                 }
[16:05:06.336]                 NAMES <- toupper(removed)
[16:05:06.336]                 for (kk in seq_along(NAMES)) {
[16:05:06.336]                   name <- removed[[kk]]
[16:05:06.336]                   NAME <- NAMES[[kk]]
[16:05:06.336]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.336]                     next
[16:05:06.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.336]                 }
[16:05:06.336]                 if (length(args) > 0) 
[16:05:06.336]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.336]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.336]             }
[16:05:06.336]             else {
[16:05:06.336]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.336]             }
[16:05:06.336]             {
[16:05:06.336]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.336]                   0L) {
[16:05:06.336]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.336]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.336]                   base::options(opts)
[16:05:06.336]                 }
[16:05:06.336]                 {
[16:05:06.336]                   {
[16:05:06.336]                     NULL
[16:05:06.336]                     RNGkind("Mersenne-Twister")
[16:05:06.336]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.336]                       inherits = FALSE)
[16:05:06.336]                   }
[16:05:06.336]                   options(future.plan = NULL)
[16:05:06.336]                   if (is.na(NA_character_)) 
[16:05:06.336]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.336]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.336]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.336]                   {
[16:05:06.336]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.336]                     if (!future$lazy) 
[16:05:06.336]                       future <- run(future)
[16:05:06.336]                     invisible(future)
[16:05:06.336]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.336]                 }
[16:05:06.336]             }
[16:05:06.336]         }
[16:05:06.336]     })
[16:05:06.336]     if (TRUE) {
[16:05:06.336]         base::sink(type = "output", split = FALSE)
[16:05:06.336]         if (TRUE) {
[16:05:06.336]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.336]         }
[16:05:06.336]         else {
[16:05:06.336]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.336]         }
[16:05:06.336]         base::close(...future.stdout)
[16:05:06.336]         ...future.stdout <- NULL
[16:05:06.336]     }
[16:05:06.336]     ...future.result$conditions <- ...future.conditions
[16:05:06.336]     ...future.result$finished <- base::Sys.time()
[16:05:06.336]     ...future.result
[16:05:06.336] }
[16:05:06.338] assign_globals() ...
[16:05:06.338] List of 1
[16:05:06.338]  $ ii: int 1
[16:05:06.338]  - attr(*, "where")=List of 1
[16:05:06.338]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:06.338]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.338]  - attr(*, "resolved")= logi TRUE
[16:05:06.338]  - attr(*, "total_size")= num 56
[16:05:06.338]  - attr(*, "already-done")= logi TRUE
[16:05:06.341] - copied ‘ii’ to environment
[16:05:06.341] assign_globals() ... done
[16:05:06.341] plan(): Setting new future strategy stack:
[16:05:06.341] List of future strategies:
[16:05:06.341] 1. sequential:
[16:05:06.341]    - args: function (..., envir = parent.frame())
[16:05:06.341]    - tweaked: FALSE
[16:05:06.341]    - call: NULL
[16:05:06.341] plan(): nbrOfWorkers() = 1
[16:05:06.342] plan(): Setting new future strategy stack:
[16:05:06.342] List of future strategies:
[16:05:06.342] 1. sequential:
[16:05:06.342]    - args: function (..., envir = parent.frame())
[16:05:06.342]    - tweaked: FALSE
[16:05:06.342]    - call: plan(strategy)
[16:05:06.343] plan(): nbrOfWorkers() = 1
[16:05:06.343] SequentialFuture started (and completed)
[16:05:06.343] - Launch lazy future ... done
[16:05:06.343] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.343] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.344] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:06.345] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:06.345] Searching for globals ... DONE
[16:05:06.345] Resolving globals: TRUE
[16:05:06.345] Resolving any globals that are futures ...
[16:05:06.345] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:06.345] Resolving any globals that are futures ... DONE
[16:05:06.346] Resolving futures part of globals (recursively) ...
[16:05:06.346] resolve() on list ...
[16:05:06.346]  recursive: 99
[16:05:06.346]  length: 1
[16:05:06.346]  elements: ‘ii’
[16:05:06.346]  length: 0 (resolved future 1)
[16:05:06.346] resolve() on list ... DONE
[16:05:06.346] - globals: [1] ‘ii’
[16:05:06.347] Resolving futures part of globals (recursively) ... DONE
[16:05:06.347] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:06.347] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:06.347] - globals: [1] ‘ii’
[16:05:06.347] 
[16:05:06.347] getGlobalsAndPackages() ... DONE
[16:05:06.348] run() for ‘Future’ ...
[16:05:06.348] - state: ‘created’
[16:05:06.348] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.348] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.348] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.348]   - Field: ‘label’
[16:05:06.348]   - Field: ‘local’
[16:05:06.348]   - Field: ‘owner’
[16:05:06.349]   - Field: ‘envir’
[16:05:06.349]   - Field: ‘packages’
[16:05:06.349]   - Field: ‘gc’
[16:05:06.349]   - Field: ‘conditions’
[16:05:06.349]   - Field: ‘expr’
[16:05:06.349]   - Field: ‘uuid’
[16:05:06.349]   - Field: ‘seed’
[16:05:06.349]   - Field: ‘version’
[16:05:06.349]   - Field: ‘result’
[16:05:06.349]   - Field: ‘asynchronous’
[16:05:06.349]   - Field: ‘calls’
[16:05:06.349]   - Field: ‘globals’
[16:05:06.350]   - Field: ‘stdout’
[16:05:06.350]   - Field: ‘earlySignal’
[16:05:06.350]   - Field: ‘lazy’
[16:05:06.350]   - Field: ‘state’
[16:05:06.350] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.350] - Launch lazy future ...
[16:05:06.350] Packages needed by the future expression (n = 0): <none>
[16:05:06.350] Packages needed by future strategies (n = 0): <none>
[16:05:06.351] {
[16:05:06.351]     {
[16:05:06.351]         {
[16:05:06.351]             ...future.startTime <- base::Sys.time()
[16:05:06.351]             {
[16:05:06.351]                 {
[16:05:06.351]                   {
[16:05:06.351]                     base::local({
[16:05:06.351]                       has_future <- base::requireNamespace("future", 
[16:05:06.351]                         quietly = TRUE)
[16:05:06.351]                       if (has_future) {
[16:05:06.351]                         ns <- base::getNamespace("future")
[16:05:06.351]                         version <- ns[[".package"]][["version"]]
[16:05:06.351]                         if (is.null(version)) 
[16:05:06.351]                           version <- utils::packageVersion("future")
[16:05:06.351]                       }
[16:05:06.351]                       else {
[16:05:06.351]                         version <- NULL
[16:05:06.351]                       }
[16:05:06.351]                       if (!has_future || version < "1.8.0") {
[16:05:06.351]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.351]                           "", base::R.version$version.string), 
[16:05:06.351]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.351]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.351]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.351]                             "release", "version")], collapse = " "), 
[16:05:06.351]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.351]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.351]                           info)
[16:05:06.351]                         info <- base::paste(info, collapse = "; ")
[16:05:06.351]                         if (!has_future) {
[16:05:06.351]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.351]                             info)
[16:05:06.351]                         }
[16:05:06.351]                         else {
[16:05:06.351]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.351]                             info, version)
[16:05:06.351]                         }
[16:05:06.351]                         base::stop(msg)
[16:05:06.351]                       }
[16:05:06.351]                     })
[16:05:06.351]                   }
[16:05:06.351]                   options(future.plan = NULL)
[16:05:06.351]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.351]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.351]                 }
[16:05:06.351]                 ...future.workdir <- getwd()
[16:05:06.351]             }
[16:05:06.351]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.351]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.351]         }
[16:05:06.351]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.351]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:06.351]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.351]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.351]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.351]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.351]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.351]             base::names(...future.oldOptions))
[16:05:06.351]     }
[16:05:06.351]     if (FALSE) {
[16:05:06.351]     }
[16:05:06.351]     else {
[16:05:06.351]         if (TRUE) {
[16:05:06.351]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.351]                 open = "w")
[16:05:06.351]         }
[16:05:06.351]         else {
[16:05:06.351]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.351]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.351]         }
[16:05:06.351]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.351]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.351]             base::sink(type = "output", split = FALSE)
[16:05:06.351]             base::close(...future.stdout)
[16:05:06.351]         }, add = TRUE)
[16:05:06.351]     }
[16:05:06.351]     ...future.frame <- base::sys.nframe()
[16:05:06.351]     ...future.conditions <- base::list()
[16:05:06.351]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.351]     if (FALSE) {
[16:05:06.351]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.351]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.351]     }
[16:05:06.351]     ...future.result <- base::tryCatch({
[16:05:06.351]         base::withCallingHandlers({
[16:05:06.351]             ...future.value <- base::withVisible(base::local({
[16:05:06.351]                 b <- a * ii
[16:05:06.351]                 a <- 0
[16:05:06.351]                 b
[16:05:06.351]             }))
[16:05:06.351]             future::FutureResult(value = ...future.value$value, 
[16:05:06.351]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.351]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.351]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.351]                     ...future.globalenv.names))
[16:05:06.351]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.351]         }, condition = base::local({
[16:05:06.351]             c <- base::c
[16:05:06.351]             inherits <- base::inherits
[16:05:06.351]             invokeRestart <- base::invokeRestart
[16:05:06.351]             length <- base::length
[16:05:06.351]             list <- base::list
[16:05:06.351]             seq.int <- base::seq.int
[16:05:06.351]             signalCondition <- base::signalCondition
[16:05:06.351]             sys.calls <- base::sys.calls
[16:05:06.351]             `[[` <- base::`[[`
[16:05:06.351]             `+` <- base::`+`
[16:05:06.351]             `<<-` <- base::`<<-`
[16:05:06.351]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.351]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.351]                   3L)]
[16:05:06.351]             }
[16:05:06.351]             function(cond) {
[16:05:06.351]                 is_error <- inherits(cond, "error")
[16:05:06.351]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.351]                   NULL)
[16:05:06.351]                 if (is_error) {
[16:05:06.351]                   sessionInformation <- function() {
[16:05:06.351]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.351]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.351]                       search = base::search(), system = base::Sys.info())
[16:05:06.351]                   }
[16:05:06.351]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.351]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.351]                     cond$call), session = sessionInformation(), 
[16:05:06.351]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.351]                   signalCondition(cond)
[16:05:06.351]                 }
[16:05:06.351]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.351]                 "immediateCondition"))) {
[16:05:06.351]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.351]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.351]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.351]                   if (TRUE && !signal) {
[16:05:06.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.351]                     {
[16:05:06.351]                       inherits <- base::inherits
[16:05:06.351]                       invokeRestart <- base::invokeRestart
[16:05:06.351]                       is.null <- base::is.null
[16:05:06.351]                       muffled <- FALSE
[16:05:06.351]                       if (inherits(cond, "message")) {
[16:05:06.351]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.351]                         if (muffled) 
[16:05:06.351]                           invokeRestart("muffleMessage")
[16:05:06.351]                       }
[16:05:06.351]                       else if (inherits(cond, "warning")) {
[16:05:06.351]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.351]                         if (muffled) 
[16:05:06.351]                           invokeRestart("muffleWarning")
[16:05:06.351]                       }
[16:05:06.351]                       else if (inherits(cond, "condition")) {
[16:05:06.351]                         if (!is.null(pattern)) {
[16:05:06.351]                           computeRestarts <- base::computeRestarts
[16:05:06.351]                           grepl <- base::grepl
[16:05:06.351]                           restarts <- computeRestarts(cond)
[16:05:06.351]                           for (restart in restarts) {
[16:05:06.351]                             name <- restart$name
[16:05:06.351]                             if (is.null(name)) 
[16:05:06.351]                               next
[16:05:06.351]                             if (!grepl(pattern, name)) 
[16:05:06.351]                               next
[16:05:06.351]                             invokeRestart(restart)
[16:05:06.351]                             muffled <- TRUE
[16:05:06.351]                             break
[16:05:06.351]                           }
[16:05:06.351]                         }
[16:05:06.351]                       }
[16:05:06.351]                       invisible(muffled)
[16:05:06.351]                     }
[16:05:06.351]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.351]                   }
[16:05:06.351]                 }
[16:05:06.351]                 else {
[16:05:06.351]                   if (TRUE) {
[16:05:06.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.351]                     {
[16:05:06.351]                       inherits <- base::inherits
[16:05:06.351]                       invokeRestart <- base::invokeRestart
[16:05:06.351]                       is.null <- base::is.null
[16:05:06.351]                       muffled <- FALSE
[16:05:06.351]                       if (inherits(cond, "message")) {
[16:05:06.351]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.351]                         if (muffled) 
[16:05:06.351]                           invokeRestart("muffleMessage")
[16:05:06.351]                       }
[16:05:06.351]                       else if (inherits(cond, "warning")) {
[16:05:06.351]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.351]                         if (muffled) 
[16:05:06.351]                           invokeRestart("muffleWarning")
[16:05:06.351]                       }
[16:05:06.351]                       else if (inherits(cond, "condition")) {
[16:05:06.351]                         if (!is.null(pattern)) {
[16:05:06.351]                           computeRestarts <- base::computeRestarts
[16:05:06.351]                           grepl <- base::grepl
[16:05:06.351]                           restarts <- computeRestarts(cond)
[16:05:06.351]                           for (restart in restarts) {
[16:05:06.351]                             name <- restart$name
[16:05:06.351]                             if (is.null(name)) 
[16:05:06.351]                               next
[16:05:06.351]                             if (!grepl(pattern, name)) 
[16:05:06.351]                               next
[16:05:06.351]                             invokeRestart(restart)
[16:05:06.351]                             muffled <- TRUE
[16:05:06.351]                             break
[16:05:06.351]                           }
[16:05:06.351]                         }
[16:05:06.351]                       }
[16:05:06.351]                       invisible(muffled)
[16:05:06.351]                     }
[16:05:06.351]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.351]                   }
[16:05:06.351]                 }
[16:05:06.351]             }
[16:05:06.351]         }))
[16:05:06.351]     }, error = function(ex) {
[16:05:06.351]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.351]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.351]                 ...future.rng), started = ...future.startTime, 
[16:05:06.351]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.351]             version = "1.8"), class = "FutureResult")
[16:05:06.351]     }, finally = {
[16:05:06.351]         if (!identical(...future.workdir, getwd())) 
[16:05:06.351]             setwd(...future.workdir)
[16:05:06.351]         {
[16:05:06.351]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.351]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.351]             }
[16:05:06.351]             base::options(...future.oldOptions)
[16:05:06.351]             if (.Platform$OS.type == "windows") {
[16:05:06.351]                 old_names <- names(...future.oldEnvVars)
[16:05:06.351]                 envs <- base::Sys.getenv()
[16:05:06.351]                 names <- names(envs)
[16:05:06.351]                 common <- intersect(names, old_names)
[16:05:06.351]                 added <- setdiff(names, old_names)
[16:05:06.351]                 removed <- setdiff(old_names, names)
[16:05:06.351]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.351]                   envs[common]]
[16:05:06.351]                 NAMES <- toupper(changed)
[16:05:06.351]                 args <- list()
[16:05:06.351]                 for (kk in seq_along(NAMES)) {
[16:05:06.351]                   name <- changed[[kk]]
[16:05:06.351]                   NAME <- NAMES[[kk]]
[16:05:06.351]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.351]                     next
[16:05:06.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.351]                 }
[16:05:06.351]                 NAMES <- toupper(added)
[16:05:06.351]                 for (kk in seq_along(NAMES)) {
[16:05:06.351]                   name <- added[[kk]]
[16:05:06.351]                   NAME <- NAMES[[kk]]
[16:05:06.351]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.351]                     next
[16:05:06.351]                   args[[name]] <- ""
[16:05:06.351]                 }
[16:05:06.351]                 NAMES <- toupper(removed)
[16:05:06.351]                 for (kk in seq_along(NAMES)) {
[16:05:06.351]                   name <- removed[[kk]]
[16:05:06.351]                   NAME <- NAMES[[kk]]
[16:05:06.351]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.351]                     next
[16:05:06.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.351]                 }
[16:05:06.351]                 if (length(args) > 0) 
[16:05:06.351]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.351]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.351]             }
[16:05:06.351]             else {
[16:05:06.351]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.351]             }
[16:05:06.351]             {
[16:05:06.351]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.351]                   0L) {
[16:05:06.351]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.351]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.351]                   base::options(opts)
[16:05:06.351]                 }
[16:05:06.351]                 {
[16:05:06.351]                   {
[16:05:06.351]                     NULL
[16:05:06.351]                     RNGkind("Mersenne-Twister")
[16:05:06.351]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.351]                       inherits = FALSE)
[16:05:06.351]                   }
[16:05:06.351]                   options(future.plan = NULL)
[16:05:06.351]                   if (is.na(NA_character_)) 
[16:05:06.351]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.351]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.351]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.351]                   {
[16:05:06.351]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.351]                     if (!future$lazy) 
[16:05:06.351]                       future <- run(future)
[16:05:06.351]                     invisible(future)
[16:05:06.351]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.351]                 }
[16:05:06.351]             }
[16:05:06.351]         }
[16:05:06.351]     })
[16:05:06.351]     if (TRUE) {
[16:05:06.351]         base::sink(type = "output", split = FALSE)
[16:05:06.351]         if (TRUE) {
[16:05:06.351]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.351]         }
[16:05:06.351]         else {
[16:05:06.351]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.351]         }
[16:05:06.351]         base::close(...future.stdout)
[16:05:06.351]         ...future.stdout <- NULL
[16:05:06.351]     }
[16:05:06.351]     ...future.result$conditions <- ...future.conditions
[16:05:06.351]     ...future.result$finished <- base::Sys.time()
[16:05:06.351]     ...future.result
[16:05:06.351] }
[16:05:06.352] assign_globals() ...
[16:05:06.352] List of 1
[16:05:06.352]  $ ii: int 2
[16:05:06.352]  - attr(*, "where")=List of 1
[16:05:06.352]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:06.352]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.352]  - attr(*, "resolved")= logi TRUE
[16:05:06.352]  - attr(*, "total_size")= num 56
[16:05:06.352]  - attr(*, "already-done")= logi TRUE
[16:05:06.355] - copied ‘ii’ to environment
[16:05:06.355] assign_globals() ... done
[16:05:06.355] plan(): Setting new future strategy stack:
[16:05:06.355] List of future strategies:
[16:05:06.355] 1. sequential:
[16:05:06.355]    - args: function (..., envir = parent.frame())
[16:05:06.355]    - tweaked: FALSE
[16:05:06.355]    - call: NULL
[16:05:06.356] plan(): nbrOfWorkers() = 1
[16:05:06.356] plan(): Setting new future strategy stack:
[16:05:06.356] List of future strategies:
[16:05:06.356] 1. sequential:
[16:05:06.356]    - args: function (..., envir = parent.frame())
[16:05:06.356]    - tweaked: FALSE
[16:05:06.356]    - call: plan(strategy)
[16:05:06.357] plan(): nbrOfWorkers() = 1
[16:05:06.357] SequentialFuture started (and completed)
[16:05:06.357] - Launch lazy future ... done
[16:05:06.357] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.358] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.358] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:06.361] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:06.361] Searching for globals ... DONE
[16:05:06.361] Resolving globals: TRUE
[16:05:06.361] Resolving any globals that are futures ...
[16:05:06.361] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:06.361] Resolving any globals that are futures ... DONE
[16:05:06.361] Resolving futures part of globals (recursively) ...
[16:05:06.362] resolve() on list ...
[16:05:06.362]  recursive: 99
[16:05:06.362]  length: 1
[16:05:06.362]  elements: ‘ii’
[16:05:06.362]  length: 0 (resolved future 1)
[16:05:06.362] resolve() on list ... DONE
[16:05:06.362] - globals: [1] ‘ii’
[16:05:06.362] Resolving futures part of globals (recursively) ... DONE
[16:05:06.363] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:06.363] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:06.363] - globals: [1] ‘ii’
[16:05:06.363] 
[16:05:06.363] getGlobalsAndPackages() ... DONE
[16:05:06.363] run() for ‘Future’ ...
[16:05:06.364] - state: ‘created’
[16:05:06.364] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.364] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.364] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.364]   - Field: ‘label’
[16:05:06.364]   - Field: ‘local’
[16:05:06.364]   - Field: ‘owner’
[16:05:06.364]   - Field: ‘envir’
[16:05:06.364]   - Field: ‘packages’
[16:05:06.365]   - Field: ‘gc’
[16:05:06.365]   - Field: ‘conditions’
[16:05:06.365]   - Field: ‘expr’
[16:05:06.365]   - Field: ‘uuid’
[16:05:06.365]   - Field: ‘seed’
[16:05:06.365]   - Field: ‘version’
[16:05:06.365]   - Field: ‘result’
[16:05:06.365]   - Field: ‘asynchronous’
[16:05:06.365]   - Field: ‘calls’
[16:05:06.365]   - Field: ‘globals’
[16:05:06.365]   - Field: ‘stdout’
[16:05:06.366]   - Field: ‘earlySignal’
[16:05:06.366]   - Field: ‘lazy’
[16:05:06.366]   - Field: ‘state’
[16:05:06.366] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.366] - Launch lazy future ...
[16:05:06.366] Packages needed by the future expression (n = 0): <none>
[16:05:06.366] Packages needed by future strategies (n = 0): <none>
[16:05:06.367] {
[16:05:06.367]     {
[16:05:06.367]         {
[16:05:06.367]             ...future.startTime <- base::Sys.time()
[16:05:06.367]             {
[16:05:06.367]                 {
[16:05:06.367]                   {
[16:05:06.367]                     base::local({
[16:05:06.367]                       has_future <- base::requireNamespace("future", 
[16:05:06.367]                         quietly = TRUE)
[16:05:06.367]                       if (has_future) {
[16:05:06.367]                         ns <- base::getNamespace("future")
[16:05:06.367]                         version <- ns[[".package"]][["version"]]
[16:05:06.367]                         if (is.null(version)) 
[16:05:06.367]                           version <- utils::packageVersion("future")
[16:05:06.367]                       }
[16:05:06.367]                       else {
[16:05:06.367]                         version <- NULL
[16:05:06.367]                       }
[16:05:06.367]                       if (!has_future || version < "1.8.0") {
[16:05:06.367]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.367]                           "", base::R.version$version.string), 
[16:05:06.367]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.367]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.367]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.367]                             "release", "version")], collapse = " "), 
[16:05:06.367]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.367]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.367]                           info)
[16:05:06.367]                         info <- base::paste(info, collapse = "; ")
[16:05:06.367]                         if (!has_future) {
[16:05:06.367]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.367]                             info)
[16:05:06.367]                         }
[16:05:06.367]                         else {
[16:05:06.367]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.367]                             info, version)
[16:05:06.367]                         }
[16:05:06.367]                         base::stop(msg)
[16:05:06.367]                       }
[16:05:06.367]                     })
[16:05:06.367]                   }
[16:05:06.367]                   options(future.plan = NULL)
[16:05:06.367]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.367]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.367]                 }
[16:05:06.367]                 ...future.workdir <- getwd()
[16:05:06.367]             }
[16:05:06.367]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.367]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.367]         }
[16:05:06.367]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.367]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:06.367]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.367]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.367]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.367]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.367]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.367]             base::names(...future.oldOptions))
[16:05:06.367]     }
[16:05:06.367]     if (FALSE) {
[16:05:06.367]     }
[16:05:06.367]     else {
[16:05:06.367]         if (TRUE) {
[16:05:06.367]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.367]                 open = "w")
[16:05:06.367]         }
[16:05:06.367]         else {
[16:05:06.367]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.367]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.367]         }
[16:05:06.367]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.367]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.367]             base::sink(type = "output", split = FALSE)
[16:05:06.367]             base::close(...future.stdout)
[16:05:06.367]         }, add = TRUE)
[16:05:06.367]     }
[16:05:06.367]     ...future.frame <- base::sys.nframe()
[16:05:06.367]     ...future.conditions <- base::list()
[16:05:06.367]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.367]     if (FALSE) {
[16:05:06.367]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.367]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.367]     }
[16:05:06.367]     ...future.result <- base::tryCatch({
[16:05:06.367]         base::withCallingHandlers({
[16:05:06.367]             ...future.value <- base::withVisible(base::local({
[16:05:06.367]                 b <- a * ii
[16:05:06.367]                 a <- 0
[16:05:06.367]                 b
[16:05:06.367]             }))
[16:05:06.367]             future::FutureResult(value = ...future.value$value, 
[16:05:06.367]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.367]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.367]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.367]                     ...future.globalenv.names))
[16:05:06.367]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.367]         }, condition = base::local({
[16:05:06.367]             c <- base::c
[16:05:06.367]             inherits <- base::inherits
[16:05:06.367]             invokeRestart <- base::invokeRestart
[16:05:06.367]             length <- base::length
[16:05:06.367]             list <- base::list
[16:05:06.367]             seq.int <- base::seq.int
[16:05:06.367]             signalCondition <- base::signalCondition
[16:05:06.367]             sys.calls <- base::sys.calls
[16:05:06.367]             `[[` <- base::`[[`
[16:05:06.367]             `+` <- base::`+`
[16:05:06.367]             `<<-` <- base::`<<-`
[16:05:06.367]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.367]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.367]                   3L)]
[16:05:06.367]             }
[16:05:06.367]             function(cond) {
[16:05:06.367]                 is_error <- inherits(cond, "error")
[16:05:06.367]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.367]                   NULL)
[16:05:06.367]                 if (is_error) {
[16:05:06.367]                   sessionInformation <- function() {
[16:05:06.367]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.367]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.367]                       search = base::search(), system = base::Sys.info())
[16:05:06.367]                   }
[16:05:06.367]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.367]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.367]                     cond$call), session = sessionInformation(), 
[16:05:06.367]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.367]                   signalCondition(cond)
[16:05:06.367]                 }
[16:05:06.367]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.367]                 "immediateCondition"))) {
[16:05:06.367]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.367]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.367]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.367]                   if (TRUE && !signal) {
[16:05:06.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.367]                     {
[16:05:06.367]                       inherits <- base::inherits
[16:05:06.367]                       invokeRestart <- base::invokeRestart
[16:05:06.367]                       is.null <- base::is.null
[16:05:06.367]                       muffled <- FALSE
[16:05:06.367]                       if (inherits(cond, "message")) {
[16:05:06.367]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.367]                         if (muffled) 
[16:05:06.367]                           invokeRestart("muffleMessage")
[16:05:06.367]                       }
[16:05:06.367]                       else if (inherits(cond, "warning")) {
[16:05:06.367]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.367]                         if (muffled) 
[16:05:06.367]                           invokeRestart("muffleWarning")
[16:05:06.367]                       }
[16:05:06.367]                       else if (inherits(cond, "condition")) {
[16:05:06.367]                         if (!is.null(pattern)) {
[16:05:06.367]                           computeRestarts <- base::computeRestarts
[16:05:06.367]                           grepl <- base::grepl
[16:05:06.367]                           restarts <- computeRestarts(cond)
[16:05:06.367]                           for (restart in restarts) {
[16:05:06.367]                             name <- restart$name
[16:05:06.367]                             if (is.null(name)) 
[16:05:06.367]                               next
[16:05:06.367]                             if (!grepl(pattern, name)) 
[16:05:06.367]                               next
[16:05:06.367]                             invokeRestart(restart)
[16:05:06.367]                             muffled <- TRUE
[16:05:06.367]                             break
[16:05:06.367]                           }
[16:05:06.367]                         }
[16:05:06.367]                       }
[16:05:06.367]                       invisible(muffled)
[16:05:06.367]                     }
[16:05:06.367]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.367]                   }
[16:05:06.367]                 }
[16:05:06.367]                 else {
[16:05:06.367]                   if (TRUE) {
[16:05:06.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.367]                     {
[16:05:06.367]                       inherits <- base::inherits
[16:05:06.367]                       invokeRestart <- base::invokeRestart
[16:05:06.367]                       is.null <- base::is.null
[16:05:06.367]                       muffled <- FALSE
[16:05:06.367]                       if (inherits(cond, "message")) {
[16:05:06.367]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.367]                         if (muffled) 
[16:05:06.367]                           invokeRestart("muffleMessage")
[16:05:06.367]                       }
[16:05:06.367]                       else if (inherits(cond, "warning")) {
[16:05:06.367]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.367]                         if (muffled) 
[16:05:06.367]                           invokeRestart("muffleWarning")
[16:05:06.367]                       }
[16:05:06.367]                       else if (inherits(cond, "condition")) {
[16:05:06.367]                         if (!is.null(pattern)) {
[16:05:06.367]                           computeRestarts <- base::computeRestarts
[16:05:06.367]                           grepl <- base::grepl
[16:05:06.367]                           restarts <- computeRestarts(cond)
[16:05:06.367]                           for (restart in restarts) {
[16:05:06.367]                             name <- restart$name
[16:05:06.367]                             if (is.null(name)) 
[16:05:06.367]                               next
[16:05:06.367]                             if (!grepl(pattern, name)) 
[16:05:06.367]                               next
[16:05:06.367]                             invokeRestart(restart)
[16:05:06.367]                             muffled <- TRUE
[16:05:06.367]                             break
[16:05:06.367]                           }
[16:05:06.367]                         }
[16:05:06.367]                       }
[16:05:06.367]                       invisible(muffled)
[16:05:06.367]                     }
[16:05:06.367]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.367]                   }
[16:05:06.367]                 }
[16:05:06.367]             }
[16:05:06.367]         }))
[16:05:06.367]     }, error = function(ex) {
[16:05:06.367]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.367]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.367]                 ...future.rng), started = ...future.startTime, 
[16:05:06.367]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.367]             version = "1.8"), class = "FutureResult")
[16:05:06.367]     }, finally = {
[16:05:06.367]         if (!identical(...future.workdir, getwd())) 
[16:05:06.367]             setwd(...future.workdir)
[16:05:06.367]         {
[16:05:06.367]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.367]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.367]             }
[16:05:06.367]             base::options(...future.oldOptions)
[16:05:06.367]             if (.Platform$OS.type == "windows") {
[16:05:06.367]                 old_names <- names(...future.oldEnvVars)
[16:05:06.367]                 envs <- base::Sys.getenv()
[16:05:06.367]                 names <- names(envs)
[16:05:06.367]                 common <- intersect(names, old_names)
[16:05:06.367]                 added <- setdiff(names, old_names)
[16:05:06.367]                 removed <- setdiff(old_names, names)
[16:05:06.367]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.367]                   envs[common]]
[16:05:06.367]                 NAMES <- toupper(changed)
[16:05:06.367]                 args <- list()
[16:05:06.367]                 for (kk in seq_along(NAMES)) {
[16:05:06.367]                   name <- changed[[kk]]
[16:05:06.367]                   NAME <- NAMES[[kk]]
[16:05:06.367]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.367]                     next
[16:05:06.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.367]                 }
[16:05:06.367]                 NAMES <- toupper(added)
[16:05:06.367]                 for (kk in seq_along(NAMES)) {
[16:05:06.367]                   name <- added[[kk]]
[16:05:06.367]                   NAME <- NAMES[[kk]]
[16:05:06.367]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.367]                     next
[16:05:06.367]                   args[[name]] <- ""
[16:05:06.367]                 }
[16:05:06.367]                 NAMES <- toupper(removed)
[16:05:06.367]                 for (kk in seq_along(NAMES)) {
[16:05:06.367]                   name <- removed[[kk]]
[16:05:06.367]                   NAME <- NAMES[[kk]]
[16:05:06.367]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.367]                     next
[16:05:06.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.367]                 }
[16:05:06.367]                 if (length(args) > 0) 
[16:05:06.367]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.367]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.367]             }
[16:05:06.367]             else {
[16:05:06.367]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.367]             }
[16:05:06.367]             {
[16:05:06.367]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.367]                   0L) {
[16:05:06.367]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.367]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.367]                   base::options(opts)
[16:05:06.367]                 }
[16:05:06.367]                 {
[16:05:06.367]                   {
[16:05:06.367]                     NULL
[16:05:06.367]                     RNGkind("Mersenne-Twister")
[16:05:06.367]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.367]                       inherits = FALSE)
[16:05:06.367]                   }
[16:05:06.367]                   options(future.plan = NULL)
[16:05:06.367]                   if (is.na(NA_character_)) 
[16:05:06.367]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.367]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.367]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.367]                   {
[16:05:06.367]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.367]                     if (!future$lazy) 
[16:05:06.367]                       future <- run(future)
[16:05:06.367]                     invisible(future)
[16:05:06.367]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.367]                 }
[16:05:06.367]             }
[16:05:06.367]         }
[16:05:06.367]     })
[16:05:06.367]     if (TRUE) {
[16:05:06.367]         base::sink(type = "output", split = FALSE)
[16:05:06.367]         if (TRUE) {
[16:05:06.367]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.367]         }
[16:05:06.367]         else {
[16:05:06.367]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.367]         }
[16:05:06.367]         base::close(...future.stdout)
[16:05:06.367]         ...future.stdout <- NULL
[16:05:06.367]     }
[16:05:06.367]     ...future.result$conditions <- ...future.conditions
[16:05:06.367]     ...future.result$finished <- base::Sys.time()
[16:05:06.367]     ...future.result
[16:05:06.367] }
[16:05:06.368] assign_globals() ...
[16:05:06.368] List of 1
[16:05:06.368]  $ ii: int 3
[16:05:06.368]  - attr(*, "where")=List of 1
[16:05:06.368]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:06.368]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.368]  - attr(*, "resolved")= logi TRUE
[16:05:06.368]  - attr(*, "total_size")= num 56
[16:05:06.368]  - attr(*, "already-done")= logi TRUE
[16:05:06.371] - copied ‘ii’ to environment
[16:05:06.371] assign_globals() ... done
[16:05:06.371] plan(): Setting new future strategy stack:
[16:05:06.371] List of future strategies:
[16:05:06.371] 1. sequential:
[16:05:06.371]    - args: function (..., envir = parent.frame())
[16:05:06.371]    - tweaked: FALSE
[16:05:06.371]    - call: NULL
[16:05:06.372] plan(): nbrOfWorkers() = 1
[16:05:06.372] plan(): Setting new future strategy stack:
[16:05:06.373] List of future strategies:
[16:05:06.373] 1. sequential:
[16:05:06.373]    - args: function (..., envir = parent.frame())
[16:05:06.373]    - tweaked: FALSE
[16:05:06.373]    - call: plan(strategy)
[16:05:06.373] plan(): nbrOfWorkers() = 1
[16:05:06.373] SequentialFuture started (and completed)
[16:05:06.373] - Launch lazy future ... done
[16:05:06.373] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.374] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.375] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:06.376] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:06.376] Searching for globals ... DONE
[16:05:06.376] Resolving globals: TRUE
[16:05:06.376] Resolving any globals that are futures ...
[16:05:06.376] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:06.376] Resolving any globals that are futures ... DONE
[16:05:06.377] Resolving futures part of globals (recursively) ...
[16:05:06.377] resolve() on list ...
[16:05:06.377]  recursive: 99
[16:05:06.377]  length: 1
[16:05:06.377]  elements: ‘ii’
[16:05:06.377]  length: 0 (resolved future 1)
[16:05:06.377] resolve() on list ... DONE
[16:05:06.377] - globals: [1] ‘ii’
[16:05:06.378] Resolving futures part of globals (recursively) ... DONE
[16:05:06.378] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:06.378] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:06.378] - globals: [1] ‘ii’
[16:05:06.378] 
[16:05:06.378] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.379] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.379] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:06.380] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:06.381] Searching for globals ... DONE
[16:05:06.381] Resolving globals: TRUE
[16:05:06.381] Resolving any globals that are futures ...
[16:05:06.381] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:06.381] Resolving any globals that are futures ... DONE
[16:05:06.381] Resolving futures part of globals (recursively) ...
[16:05:06.381] resolve() on list ...
[16:05:06.382]  recursive: 99
[16:05:06.382]  length: 1
[16:05:06.382]  elements: ‘ii’
[16:05:06.382]  length: 0 (resolved future 1)
[16:05:06.382] resolve() on list ... DONE
[16:05:06.382] - globals: [1] ‘ii’
[16:05:06.382] Resolving futures part of globals (recursively) ... DONE
[16:05:06.382] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:06.383] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:06.383] - globals: [1] ‘ii’
[16:05:06.383] 
[16:05:06.383] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.384] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.384] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:06.387] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:06.387] Searching for globals ... DONE
[16:05:06.387] Resolving globals: TRUE
[16:05:06.387] Resolving any globals that are futures ...
[16:05:06.387] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:06.387] Resolving any globals that are futures ... DONE
[16:05:06.388] Resolving futures part of globals (recursively) ...
[16:05:06.388] resolve() on list ...
[16:05:06.388]  recursive: 99
[16:05:06.388]  length: 1
[16:05:06.388]  elements: ‘ii’
[16:05:06.388]  length: 0 (resolved future 1)
[16:05:06.388] resolve() on list ... DONE
[16:05:06.388] - globals: [1] ‘ii’
[16:05:06.389] Resolving futures part of globals (recursively) ... DONE
[16:05:06.389] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:06.389] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:06.389] - globals: [1] ‘ii’
[16:05:06.389] 
[16:05:06.389] getGlobalsAndPackages() ... DONE
[16:05:06.390] run() for ‘Future’ ...
[16:05:06.390] - state: ‘created’
[16:05:06.390] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.390] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.390] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.390]   - Field: ‘label’
[16:05:06.390]   - Field: ‘local’
[16:05:06.391]   - Field: ‘owner’
[16:05:06.391]   - Field: ‘envir’
[16:05:06.391]   - Field: ‘packages’
[16:05:06.391]   - Field: ‘gc’
[16:05:06.391]   - Field: ‘conditions’
[16:05:06.391]   - Field: ‘expr’
[16:05:06.391]   - Field: ‘uuid’
[16:05:06.391]   - Field: ‘seed’
[16:05:06.391]   - Field: ‘version’
[16:05:06.391]   - Field: ‘result’
[16:05:06.392]   - Field: ‘asynchronous’
[16:05:06.392]   - Field: ‘calls’
[16:05:06.392]   - Field: ‘globals’
[16:05:06.392]   - Field: ‘stdout’
[16:05:06.392]   - Field: ‘earlySignal’
[16:05:06.392]   - Field: ‘lazy’
[16:05:06.392]   - Field: ‘state’
[16:05:06.392] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.392] - Launch lazy future ...
[16:05:06.392] Packages needed by the future expression (n = 0): <none>
[16:05:06.393] Packages needed by future strategies (n = 0): <none>
[16:05:06.393] {
[16:05:06.393]     {
[16:05:06.393]         {
[16:05:06.393]             ...future.startTime <- base::Sys.time()
[16:05:06.393]             {
[16:05:06.393]                 {
[16:05:06.393]                   {
[16:05:06.393]                     base::local({
[16:05:06.393]                       has_future <- base::requireNamespace("future", 
[16:05:06.393]                         quietly = TRUE)
[16:05:06.393]                       if (has_future) {
[16:05:06.393]                         ns <- base::getNamespace("future")
[16:05:06.393]                         version <- ns[[".package"]][["version"]]
[16:05:06.393]                         if (is.null(version)) 
[16:05:06.393]                           version <- utils::packageVersion("future")
[16:05:06.393]                       }
[16:05:06.393]                       else {
[16:05:06.393]                         version <- NULL
[16:05:06.393]                       }
[16:05:06.393]                       if (!has_future || version < "1.8.0") {
[16:05:06.393]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.393]                           "", base::R.version$version.string), 
[16:05:06.393]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.393]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.393]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.393]                             "release", "version")], collapse = " "), 
[16:05:06.393]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.393]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.393]                           info)
[16:05:06.393]                         info <- base::paste(info, collapse = "; ")
[16:05:06.393]                         if (!has_future) {
[16:05:06.393]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.393]                             info)
[16:05:06.393]                         }
[16:05:06.393]                         else {
[16:05:06.393]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.393]                             info, version)
[16:05:06.393]                         }
[16:05:06.393]                         base::stop(msg)
[16:05:06.393]                       }
[16:05:06.393]                     })
[16:05:06.393]                   }
[16:05:06.393]                   options(future.plan = NULL)
[16:05:06.393]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.393]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.393]                 }
[16:05:06.393]                 ...future.workdir <- getwd()
[16:05:06.393]             }
[16:05:06.393]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.393]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.393]         }
[16:05:06.393]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.393]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:06.393]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.393]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.393]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.393]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.393]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.393]             base::names(...future.oldOptions))
[16:05:06.393]     }
[16:05:06.393]     if (FALSE) {
[16:05:06.393]     }
[16:05:06.393]     else {
[16:05:06.393]         if (TRUE) {
[16:05:06.393]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.393]                 open = "w")
[16:05:06.393]         }
[16:05:06.393]         else {
[16:05:06.393]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.393]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.393]         }
[16:05:06.393]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.393]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.393]             base::sink(type = "output", split = FALSE)
[16:05:06.393]             base::close(...future.stdout)
[16:05:06.393]         }, add = TRUE)
[16:05:06.393]     }
[16:05:06.393]     ...future.frame <- base::sys.nframe()
[16:05:06.393]     ...future.conditions <- base::list()
[16:05:06.393]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.393]     if (FALSE) {
[16:05:06.393]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.393]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.393]     }
[16:05:06.393]     ...future.result <- base::tryCatch({
[16:05:06.393]         base::withCallingHandlers({
[16:05:06.393]             ...future.value <- base::withVisible(base::local({
[16:05:06.393]                 b <- a * ii
[16:05:06.393]                 a <- 0
[16:05:06.393]                 b
[16:05:06.393]             }))
[16:05:06.393]             future::FutureResult(value = ...future.value$value, 
[16:05:06.393]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.393]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.393]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.393]                     ...future.globalenv.names))
[16:05:06.393]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.393]         }, condition = base::local({
[16:05:06.393]             c <- base::c
[16:05:06.393]             inherits <- base::inherits
[16:05:06.393]             invokeRestart <- base::invokeRestart
[16:05:06.393]             length <- base::length
[16:05:06.393]             list <- base::list
[16:05:06.393]             seq.int <- base::seq.int
[16:05:06.393]             signalCondition <- base::signalCondition
[16:05:06.393]             sys.calls <- base::sys.calls
[16:05:06.393]             `[[` <- base::`[[`
[16:05:06.393]             `+` <- base::`+`
[16:05:06.393]             `<<-` <- base::`<<-`
[16:05:06.393]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.393]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.393]                   3L)]
[16:05:06.393]             }
[16:05:06.393]             function(cond) {
[16:05:06.393]                 is_error <- inherits(cond, "error")
[16:05:06.393]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.393]                   NULL)
[16:05:06.393]                 if (is_error) {
[16:05:06.393]                   sessionInformation <- function() {
[16:05:06.393]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.393]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.393]                       search = base::search(), system = base::Sys.info())
[16:05:06.393]                   }
[16:05:06.393]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.393]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.393]                     cond$call), session = sessionInformation(), 
[16:05:06.393]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.393]                   signalCondition(cond)
[16:05:06.393]                 }
[16:05:06.393]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.393]                 "immediateCondition"))) {
[16:05:06.393]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.393]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.393]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.393]                   if (TRUE && !signal) {
[16:05:06.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.393]                     {
[16:05:06.393]                       inherits <- base::inherits
[16:05:06.393]                       invokeRestart <- base::invokeRestart
[16:05:06.393]                       is.null <- base::is.null
[16:05:06.393]                       muffled <- FALSE
[16:05:06.393]                       if (inherits(cond, "message")) {
[16:05:06.393]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.393]                         if (muffled) 
[16:05:06.393]                           invokeRestart("muffleMessage")
[16:05:06.393]                       }
[16:05:06.393]                       else if (inherits(cond, "warning")) {
[16:05:06.393]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.393]                         if (muffled) 
[16:05:06.393]                           invokeRestart("muffleWarning")
[16:05:06.393]                       }
[16:05:06.393]                       else if (inherits(cond, "condition")) {
[16:05:06.393]                         if (!is.null(pattern)) {
[16:05:06.393]                           computeRestarts <- base::computeRestarts
[16:05:06.393]                           grepl <- base::grepl
[16:05:06.393]                           restarts <- computeRestarts(cond)
[16:05:06.393]                           for (restart in restarts) {
[16:05:06.393]                             name <- restart$name
[16:05:06.393]                             if (is.null(name)) 
[16:05:06.393]                               next
[16:05:06.393]                             if (!grepl(pattern, name)) 
[16:05:06.393]                               next
[16:05:06.393]                             invokeRestart(restart)
[16:05:06.393]                             muffled <- TRUE
[16:05:06.393]                             break
[16:05:06.393]                           }
[16:05:06.393]                         }
[16:05:06.393]                       }
[16:05:06.393]                       invisible(muffled)
[16:05:06.393]                     }
[16:05:06.393]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.393]                   }
[16:05:06.393]                 }
[16:05:06.393]                 else {
[16:05:06.393]                   if (TRUE) {
[16:05:06.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.393]                     {
[16:05:06.393]                       inherits <- base::inherits
[16:05:06.393]                       invokeRestart <- base::invokeRestart
[16:05:06.393]                       is.null <- base::is.null
[16:05:06.393]                       muffled <- FALSE
[16:05:06.393]                       if (inherits(cond, "message")) {
[16:05:06.393]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.393]                         if (muffled) 
[16:05:06.393]                           invokeRestart("muffleMessage")
[16:05:06.393]                       }
[16:05:06.393]                       else if (inherits(cond, "warning")) {
[16:05:06.393]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.393]                         if (muffled) 
[16:05:06.393]                           invokeRestart("muffleWarning")
[16:05:06.393]                       }
[16:05:06.393]                       else if (inherits(cond, "condition")) {
[16:05:06.393]                         if (!is.null(pattern)) {
[16:05:06.393]                           computeRestarts <- base::computeRestarts
[16:05:06.393]                           grepl <- base::grepl
[16:05:06.393]                           restarts <- computeRestarts(cond)
[16:05:06.393]                           for (restart in restarts) {
[16:05:06.393]                             name <- restart$name
[16:05:06.393]                             if (is.null(name)) 
[16:05:06.393]                               next
[16:05:06.393]                             if (!grepl(pattern, name)) 
[16:05:06.393]                               next
[16:05:06.393]                             invokeRestart(restart)
[16:05:06.393]                             muffled <- TRUE
[16:05:06.393]                             break
[16:05:06.393]                           }
[16:05:06.393]                         }
[16:05:06.393]                       }
[16:05:06.393]                       invisible(muffled)
[16:05:06.393]                     }
[16:05:06.393]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.393]                   }
[16:05:06.393]                 }
[16:05:06.393]             }
[16:05:06.393]         }))
[16:05:06.393]     }, error = function(ex) {
[16:05:06.393]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.393]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.393]                 ...future.rng), started = ...future.startTime, 
[16:05:06.393]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.393]             version = "1.8"), class = "FutureResult")
[16:05:06.393]     }, finally = {
[16:05:06.393]         if (!identical(...future.workdir, getwd())) 
[16:05:06.393]             setwd(...future.workdir)
[16:05:06.393]         {
[16:05:06.393]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.393]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.393]             }
[16:05:06.393]             base::options(...future.oldOptions)
[16:05:06.393]             if (.Platform$OS.type == "windows") {
[16:05:06.393]                 old_names <- names(...future.oldEnvVars)
[16:05:06.393]                 envs <- base::Sys.getenv()
[16:05:06.393]                 names <- names(envs)
[16:05:06.393]                 common <- intersect(names, old_names)
[16:05:06.393]                 added <- setdiff(names, old_names)
[16:05:06.393]                 removed <- setdiff(old_names, names)
[16:05:06.393]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.393]                   envs[common]]
[16:05:06.393]                 NAMES <- toupper(changed)
[16:05:06.393]                 args <- list()
[16:05:06.393]                 for (kk in seq_along(NAMES)) {
[16:05:06.393]                   name <- changed[[kk]]
[16:05:06.393]                   NAME <- NAMES[[kk]]
[16:05:06.393]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.393]                     next
[16:05:06.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.393]                 }
[16:05:06.393]                 NAMES <- toupper(added)
[16:05:06.393]                 for (kk in seq_along(NAMES)) {
[16:05:06.393]                   name <- added[[kk]]
[16:05:06.393]                   NAME <- NAMES[[kk]]
[16:05:06.393]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.393]                     next
[16:05:06.393]                   args[[name]] <- ""
[16:05:06.393]                 }
[16:05:06.393]                 NAMES <- toupper(removed)
[16:05:06.393]                 for (kk in seq_along(NAMES)) {
[16:05:06.393]                   name <- removed[[kk]]
[16:05:06.393]                   NAME <- NAMES[[kk]]
[16:05:06.393]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.393]                     next
[16:05:06.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.393]                 }
[16:05:06.393]                 if (length(args) > 0) 
[16:05:06.393]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.393]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.393]             }
[16:05:06.393]             else {
[16:05:06.393]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.393]             }
[16:05:06.393]             {
[16:05:06.393]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.393]                   0L) {
[16:05:06.393]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.393]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.393]                   base::options(opts)
[16:05:06.393]                 }
[16:05:06.393]                 {
[16:05:06.393]                   {
[16:05:06.393]                     NULL
[16:05:06.393]                     RNGkind("Mersenne-Twister")
[16:05:06.393]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.393]                       inherits = FALSE)
[16:05:06.393]                   }
[16:05:06.393]                   options(future.plan = NULL)
[16:05:06.393]                   if (is.na(NA_character_)) 
[16:05:06.393]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.393]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.393]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.393]                   {
[16:05:06.393]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.393]                     if (!future$lazy) 
[16:05:06.393]                       future <- run(future)
[16:05:06.393]                     invisible(future)
[16:05:06.393]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.393]                 }
[16:05:06.393]             }
[16:05:06.393]         }
[16:05:06.393]     })
[16:05:06.393]     if (TRUE) {
[16:05:06.393]         base::sink(type = "output", split = FALSE)
[16:05:06.393]         if (TRUE) {
[16:05:06.393]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.393]         }
[16:05:06.393]         else {
[16:05:06.393]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.393]         }
[16:05:06.393]         base::close(...future.stdout)
[16:05:06.393]         ...future.stdout <- NULL
[16:05:06.393]     }
[16:05:06.393]     ...future.result$conditions <- ...future.conditions
[16:05:06.393]     ...future.result$finished <- base::Sys.time()
[16:05:06.393]     ...future.result
[16:05:06.393] }
[16:05:06.395] assign_globals() ...
[16:05:06.395] List of 1
[16:05:06.395]  $ ii: int 1
[16:05:06.395]  - attr(*, "where")=List of 1
[16:05:06.395]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:06.395]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.395]  - attr(*, "resolved")= logi TRUE
[16:05:06.395]  - attr(*, "total_size")= num 56
[16:05:06.395]  - attr(*, "already-done")= logi TRUE
[16:05:06.397] - copied ‘ii’ to environment
[16:05:06.397] assign_globals() ... done
[16:05:06.398] plan(): Setting new future strategy stack:
[16:05:06.398] List of future strategies:
[16:05:06.398] 1. sequential:
[16:05:06.398]    - args: function (..., envir = parent.frame())
[16:05:06.398]    - tweaked: FALSE
[16:05:06.398]    - call: NULL
[16:05:06.398] plan(): nbrOfWorkers() = 1
[16:05:06.399] plan(): Setting new future strategy stack:
[16:05:06.399] List of future strategies:
[16:05:06.399] 1. sequential:
[16:05:06.399]    - args: function (..., envir = parent.frame())
[16:05:06.399]    - tweaked: FALSE
[16:05:06.399]    - call: plan(strategy)
[16:05:06.399] plan(): nbrOfWorkers() = 1
[16:05:06.400] SequentialFuture started (and completed)
[16:05:06.400] signalConditions() ...
[16:05:06.400]  - include = ‘immediateCondition’
[16:05:06.400]  - exclude = 
[16:05:06.400]  - resignal = FALSE
[16:05:06.400]  - Number of conditions: 1
[16:05:06.400] signalConditions() ... done
[16:05:06.400] - Launch lazy future ... done
[16:05:06.400] run() for ‘SequentialFuture’ ... done
[16:05:06.400] signalConditions() ...
[16:05:06.401]  - include = ‘immediateCondition’
[16:05:06.401]  - exclude = 
[16:05:06.401]  - resignal = FALSE
[16:05:06.401]  - Number of conditions: 1
[16:05:06.401] signalConditions() ... done
[16:05:06.401] Future state: ‘finished’
[16:05:06.401] signalConditions() ...
[16:05:06.401]  - include = ‘condition’
[16:05:06.401]  - exclude = ‘immediateCondition’
[16:05:06.401]  - resignal = TRUE
[16:05:06.401]  - Number of conditions: 1
[16:05:06.402]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:05:06.402] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a * ii ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a * ii ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "11666ca4073c" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:05:06"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.417] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.417] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:06.417] 
[16:05:06.417] Searching for globals ... DONE
[16:05:06.418] - globals: [0] <none>
[16:05:06.418] getGlobalsAndPackages() ... DONE
[16:05:06.418] run() for ‘Future’ ...
[16:05:06.418] - state: ‘created’
[16:05:06.418] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.418] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.419] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.419]   - Field: ‘label’
[16:05:06.419]   - Field: ‘local’
[16:05:06.419]   - Field: ‘owner’
[16:05:06.419]   - Field: ‘envir’
[16:05:06.419]   - Field: ‘packages’
[16:05:06.419]   - Field: ‘gc’
[16:05:06.419]   - Field: ‘conditions’
[16:05:06.419]   - Field: ‘expr’
[16:05:06.419]   - Field: ‘uuid’
[16:05:06.420]   - Field: ‘seed’
[16:05:06.420]   - Field: ‘version’
[16:05:06.420]   - Field: ‘result’
[16:05:06.420]   - Field: ‘asynchronous’
[16:05:06.420]   - Field: ‘calls’
[16:05:06.420]   - Field: ‘globals’
[16:05:06.420]   - Field: ‘stdout’
[16:05:06.420]   - Field: ‘earlySignal’
[16:05:06.420]   - Field: ‘lazy’
[16:05:06.420]   - Field: ‘state’
[16:05:06.420] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.421] - Launch lazy future ...
[16:05:06.421] Packages needed by the future expression (n = 0): <none>
[16:05:06.421] Packages needed by future strategies (n = 0): <none>
[16:05:06.421] {
[16:05:06.421]     {
[16:05:06.421]         {
[16:05:06.421]             ...future.startTime <- base::Sys.time()
[16:05:06.421]             {
[16:05:06.421]                 {
[16:05:06.421]                   {
[16:05:06.421]                     base::local({
[16:05:06.421]                       has_future <- base::requireNamespace("future", 
[16:05:06.421]                         quietly = TRUE)
[16:05:06.421]                       if (has_future) {
[16:05:06.421]                         ns <- base::getNamespace("future")
[16:05:06.421]                         version <- ns[[".package"]][["version"]]
[16:05:06.421]                         if (is.null(version)) 
[16:05:06.421]                           version <- utils::packageVersion("future")
[16:05:06.421]                       }
[16:05:06.421]                       else {
[16:05:06.421]                         version <- NULL
[16:05:06.421]                       }
[16:05:06.421]                       if (!has_future || version < "1.8.0") {
[16:05:06.421]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.421]                           "", base::R.version$version.string), 
[16:05:06.421]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.421]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.421]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.421]                             "release", "version")], collapse = " "), 
[16:05:06.421]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.421]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.421]                           info)
[16:05:06.421]                         info <- base::paste(info, collapse = "; ")
[16:05:06.421]                         if (!has_future) {
[16:05:06.421]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.421]                             info)
[16:05:06.421]                         }
[16:05:06.421]                         else {
[16:05:06.421]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.421]                             info, version)
[16:05:06.421]                         }
[16:05:06.421]                         base::stop(msg)
[16:05:06.421]                       }
[16:05:06.421]                     })
[16:05:06.421]                   }
[16:05:06.421]                   options(future.plan = NULL)
[16:05:06.421]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.421]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.421]                 }
[16:05:06.421]                 ...future.workdir <- getwd()
[16:05:06.421]             }
[16:05:06.421]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.421]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.421]         }
[16:05:06.421]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.421]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:06.421]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.421]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.421]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.421]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.421]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.421]             base::names(...future.oldOptions))
[16:05:06.421]     }
[16:05:06.421]     if (FALSE) {
[16:05:06.421]     }
[16:05:06.421]     else {
[16:05:06.421]         if (TRUE) {
[16:05:06.421]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.421]                 open = "w")
[16:05:06.421]         }
[16:05:06.421]         else {
[16:05:06.421]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.421]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.421]         }
[16:05:06.421]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.421]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.421]             base::sink(type = "output", split = FALSE)
[16:05:06.421]             base::close(...future.stdout)
[16:05:06.421]         }, add = TRUE)
[16:05:06.421]     }
[16:05:06.421]     ...future.frame <- base::sys.nframe()
[16:05:06.421]     ...future.conditions <- base::list()
[16:05:06.421]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.421]     if (FALSE) {
[16:05:06.421]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.421]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.421]     }
[16:05:06.421]     ...future.result <- base::tryCatch({
[16:05:06.421]         base::withCallingHandlers({
[16:05:06.421]             ...future.value <- base::withVisible(base::local(1))
[16:05:06.421]             future::FutureResult(value = ...future.value$value, 
[16:05:06.421]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.421]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.421]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.421]                     ...future.globalenv.names))
[16:05:06.421]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.421]         }, condition = base::local({
[16:05:06.421]             c <- base::c
[16:05:06.421]             inherits <- base::inherits
[16:05:06.421]             invokeRestart <- base::invokeRestart
[16:05:06.421]             length <- base::length
[16:05:06.421]             list <- base::list
[16:05:06.421]             seq.int <- base::seq.int
[16:05:06.421]             signalCondition <- base::signalCondition
[16:05:06.421]             sys.calls <- base::sys.calls
[16:05:06.421]             `[[` <- base::`[[`
[16:05:06.421]             `+` <- base::`+`
[16:05:06.421]             `<<-` <- base::`<<-`
[16:05:06.421]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.421]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.421]                   3L)]
[16:05:06.421]             }
[16:05:06.421]             function(cond) {
[16:05:06.421]                 is_error <- inherits(cond, "error")
[16:05:06.421]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.421]                   NULL)
[16:05:06.421]                 if (is_error) {
[16:05:06.421]                   sessionInformation <- function() {
[16:05:06.421]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.421]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.421]                       search = base::search(), system = base::Sys.info())
[16:05:06.421]                   }
[16:05:06.421]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.421]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.421]                     cond$call), session = sessionInformation(), 
[16:05:06.421]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.421]                   signalCondition(cond)
[16:05:06.421]                 }
[16:05:06.421]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.421]                 "immediateCondition"))) {
[16:05:06.421]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.421]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.421]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.421]                   if (TRUE && !signal) {
[16:05:06.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.421]                     {
[16:05:06.421]                       inherits <- base::inherits
[16:05:06.421]                       invokeRestart <- base::invokeRestart
[16:05:06.421]                       is.null <- base::is.null
[16:05:06.421]                       muffled <- FALSE
[16:05:06.421]                       if (inherits(cond, "message")) {
[16:05:06.421]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.421]                         if (muffled) 
[16:05:06.421]                           invokeRestart("muffleMessage")
[16:05:06.421]                       }
[16:05:06.421]                       else if (inherits(cond, "warning")) {
[16:05:06.421]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.421]                         if (muffled) 
[16:05:06.421]                           invokeRestart("muffleWarning")
[16:05:06.421]                       }
[16:05:06.421]                       else if (inherits(cond, "condition")) {
[16:05:06.421]                         if (!is.null(pattern)) {
[16:05:06.421]                           computeRestarts <- base::computeRestarts
[16:05:06.421]                           grepl <- base::grepl
[16:05:06.421]                           restarts <- computeRestarts(cond)
[16:05:06.421]                           for (restart in restarts) {
[16:05:06.421]                             name <- restart$name
[16:05:06.421]                             if (is.null(name)) 
[16:05:06.421]                               next
[16:05:06.421]                             if (!grepl(pattern, name)) 
[16:05:06.421]                               next
[16:05:06.421]                             invokeRestart(restart)
[16:05:06.421]                             muffled <- TRUE
[16:05:06.421]                             break
[16:05:06.421]                           }
[16:05:06.421]                         }
[16:05:06.421]                       }
[16:05:06.421]                       invisible(muffled)
[16:05:06.421]                     }
[16:05:06.421]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.421]                   }
[16:05:06.421]                 }
[16:05:06.421]                 else {
[16:05:06.421]                   if (TRUE) {
[16:05:06.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.421]                     {
[16:05:06.421]                       inherits <- base::inherits
[16:05:06.421]                       invokeRestart <- base::invokeRestart
[16:05:06.421]                       is.null <- base::is.null
[16:05:06.421]                       muffled <- FALSE
[16:05:06.421]                       if (inherits(cond, "message")) {
[16:05:06.421]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.421]                         if (muffled) 
[16:05:06.421]                           invokeRestart("muffleMessage")
[16:05:06.421]                       }
[16:05:06.421]                       else if (inherits(cond, "warning")) {
[16:05:06.421]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.421]                         if (muffled) 
[16:05:06.421]                           invokeRestart("muffleWarning")
[16:05:06.421]                       }
[16:05:06.421]                       else if (inherits(cond, "condition")) {
[16:05:06.421]                         if (!is.null(pattern)) {
[16:05:06.421]                           computeRestarts <- base::computeRestarts
[16:05:06.421]                           grepl <- base::grepl
[16:05:06.421]                           restarts <- computeRestarts(cond)
[16:05:06.421]                           for (restart in restarts) {
[16:05:06.421]                             name <- restart$name
[16:05:06.421]                             if (is.null(name)) 
[16:05:06.421]                               next
[16:05:06.421]                             if (!grepl(pattern, name)) 
[16:05:06.421]                               next
[16:05:06.421]                             invokeRestart(restart)
[16:05:06.421]                             muffled <- TRUE
[16:05:06.421]                             break
[16:05:06.421]                           }
[16:05:06.421]                         }
[16:05:06.421]                       }
[16:05:06.421]                       invisible(muffled)
[16:05:06.421]                     }
[16:05:06.421]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.421]                   }
[16:05:06.421]                 }
[16:05:06.421]             }
[16:05:06.421]         }))
[16:05:06.421]     }, error = function(ex) {
[16:05:06.421]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.421]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.421]                 ...future.rng), started = ...future.startTime, 
[16:05:06.421]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.421]             version = "1.8"), class = "FutureResult")
[16:05:06.421]     }, finally = {
[16:05:06.421]         if (!identical(...future.workdir, getwd())) 
[16:05:06.421]             setwd(...future.workdir)
[16:05:06.421]         {
[16:05:06.421]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.421]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.421]             }
[16:05:06.421]             base::options(...future.oldOptions)
[16:05:06.421]             if (.Platform$OS.type == "windows") {
[16:05:06.421]                 old_names <- names(...future.oldEnvVars)
[16:05:06.421]                 envs <- base::Sys.getenv()
[16:05:06.421]                 names <- names(envs)
[16:05:06.421]                 common <- intersect(names, old_names)
[16:05:06.421]                 added <- setdiff(names, old_names)
[16:05:06.421]                 removed <- setdiff(old_names, names)
[16:05:06.421]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.421]                   envs[common]]
[16:05:06.421]                 NAMES <- toupper(changed)
[16:05:06.421]                 args <- list()
[16:05:06.421]                 for (kk in seq_along(NAMES)) {
[16:05:06.421]                   name <- changed[[kk]]
[16:05:06.421]                   NAME <- NAMES[[kk]]
[16:05:06.421]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.421]                     next
[16:05:06.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.421]                 }
[16:05:06.421]                 NAMES <- toupper(added)
[16:05:06.421]                 for (kk in seq_along(NAMES)) {
[16:05:06.421]                   name <- added[[kk]]
[16:05:06.421]                   NAME <- NAMES[[kk]]
[16:05:06.421]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.421]                     next
[16:05:06.421]                   args[[name]] <- ""
[16:05:06.421]                 }
[16:05:06.421]                 NAMES <- toupper(removed)
[16:05:06.421]                 for (kk in seq_along(NAMES)) {
[16:05:06.421]                   name <- removed[[kk]]
[16:05:06.421]                   NAME <- NAMES[[kk]]
[16:05:06.421]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.421]                     next
[16:05:06.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.421]                 }
[16:05:06.421]                 if (length(args) > 0) 
[16:05:06.421]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.421]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.421]             }
[16:05:06.421]             else {
[16:05:06.421]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.421]             }
[16:05:06.421]             {
[16:05:06.421]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.421]                   0L) {
[16:05:06.421]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.421]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.421]                   base::options(opts)
[16:05:06.421]                 }
[16:05:06.421]                 {
[16:05:06.421]                   {
[16:05:06.421]                     NULL
[16:05:06.421]                     RNGkind("Mersenne-Twister")
[16:05:06.421]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.421]                       inherits = FALSE)
[16:05:06.421]                   }
[16:05:06.421]                   options(future.plan = NULL)
[16:05:06.421]                   if (is.na(NA_character_)) 
[16:05:06.421]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.421]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.421]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.421]                   {
[16:05:06.421]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.421]                     if (!future$lazy) 
[16:05:06.421]                       future <- run(future)
[16:05:06.421]                     invisible(future)
[16:05:06.421]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.421]                 }
[16:05:06.421]             }
[16:05:06.421]         }
[16:05:06.421]     })
[16:05:06.421]     if (TRUE) {
[16:05:06.421]         base::sink(type = "output", split = FALSE)
[16:05:06.421]         if (TRUE) {
[16:05:06.421]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.421]         }
[16:05:06.421]         else {
[16:05:06.421]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.421]         }
[16:05:06.421]         base::close(...future.stdout)
[16:05:06.421]         ...future.stdout <- NULL
[16:05:06.421]     }
[16:05:06.421]     ...future.result$conditions <- ...future.conditions
[16:05:06.421]     ...future.result$finished <- base::Sys.time()
[16:05:06.421]     ...future.result
[16:05:06.421] }
[16:05:06.423] plan(): Setting new future strategy stack:
[16:05:06.423] List of future strategies:
[16:05:06.423] 1. sequential:
[16:05:06.423]    - args: function (..., envir = parent.frame())
[16:05:06.423]    - tweaked: FALSE
[16:05:06.423]    - call: NULL
[16:05:06.423] plan(): nbrOfWorkers() = 1
[16:05:06.424] plan(): Setting new future strategy stack:
[16:05:06.424] List of future strategies:
[16:05:06.424] 1. sequential:
[16:05:06.424]    - args: function (..., envir = parent.frame())
[16:05:06.424]    - tweaked: FALSE
[16:05:06.424]    - call: plan(strategy)
[16:05:06.425] plan(): nbrOfWorkers() = 1
[16:05:06.425] SequentialFuture started (and completed)
[16:05:06.425] - Launch lazy future ... done
[16:05:06.425] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.425] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.425] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:06.426] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:06.426] Searching for globals ... DONE
[16:05:06.426] Resolving globals: TRUE
[16:05:06.427] Resolving any globals that are futures ...
[16:05:06.427] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:06.427] Resolving any globals that are futures ... DONE
[16:05:06.427] Resolving futures part of globals (recursively) ...
[16:05:06.427] resolve() on list ...
[16:05:06.427]  recursive: 99
[16:05:06.427]  length: 1
[16:05:06.428]  elements: ‘a’
[16:05:06.428] resolved() for ‘SequentialFuture’ ...
[16:05:06.428] - state: ‘finished’
[16:05:06.428] - run: TRUE
[16:05:06.428] - result: ‘FutureResult’
[16:05:06.428] resolved() for ‘SequentialFuture’ ... done
[16:05:06.428] Future #1
[16:05:06.429] resolved() for ‘SequentialFuture’ ...
[16:05:06.429] - state: ‘finished’
[16:05:06.429] - run: TRUE
[16:05:06.429] - result: ‘FutureResult’
[16:05:06.429] resolved() for ‘SequentialFuture’ ... done
[16:05:06.429] A SequentialFuture was resolved
[16:05:06.429]  length: 0 (resolved future 1)
[16:05:06.429] resolve() on list ... DONE
[16:05:06.429] - globals: [1] ‘a’
[16:05:06.429] Resolving futures part of globals (recursively) ... DONE
[16:05:06.430] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[16:05:06.430] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[16:05:06.431] - globals: [1] ‘a’
[16:05:06.431] - packages: [1] ‘future’
[16:05:06.431] getGlobalsAndPackages() ... DONE
[16:05:06.431] run() for ‘Future’ ...
[16:05:06.431] - state: ‘created’
[16:05:06.431] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.432] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.432] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.432]   - Field: ‘label’
[16:05:06.432]   - Field: ‘local’
[16:05:06.432]   - Field: ‘owner’
[16:05:06.432]   - Field: ‘envir’
[16:05:06.432]   - Field: ‘packages’
[16:05:06.432]   - Field: ‘gc’
[16:05:06.432]   - Field: ‘conditions’
[16:05:06.432]   - Field: ‘expr’
[16:05:06.433]   - Field: ‘uuid’
[16:05:06.433]   - Field: ‘seed’
[16:05:06.433]   - Field: ‘version’
[16:05:06.433]   - Field: ‘result’
[16:05:06.433]   - Field: ‘asynchronous’
[16:05:06.433]   - Field: ‘calls’
[16:05:06.433]   - Field: ‘globals’
[16:05:06.433]   - Field: ‘stdout’
[16:05:06.433]   - Field: ‘earlySignal’
[16:05:06.433]   - Field: ‘lazy’
[16:05:06.433]   - Field: ‘state’
[16:05:06.434] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.434] - Launch lazy future ...
[16:05:06.434] Packages needed by the future expression (n = 1): ‘future’
[16:05:06.434] Packages needed by future strategies (n = 0): <none>
[16:05:06.434] {
[16:05:06.434]     {
[16:05:06.434]         {
[16:05:06.434]             ...future.startTime <- base::Sys.time()
[16:05:06.434]             {
[16:05:06.434]                 {
[16:05:06.434]                   {
[16:05:06.434]                     {
[16:05:06.434]                       base::local({
[16:05:06.434]                         has_future <- base::requireNamespace("future", 
[16:05:06.434]                           quietly = TRUE)
[16:05:06.434]                         if (has_future) {
[16:05:06.434]                           ns <- base::getNamespace("future")
[16:05:06.434]                           version <- ns[[".package"]][["version"]]
[16:05:06.434]                           if (is.null(version)) 
[16:05:06.434]                             version <- utils::packageVersion("future")
[16:05:06.434]                         }
[16:05:06.434]                         else {
[16:05:06.434]                           version <- NULL
[16:05:06.434]                         }
[16:05:06.434]                         if (!has_future || version < "1.8.0") {
[16:05:06.434]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.434]                             "", base::R.version$version.string), 
[16:05:06.434]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:06.434]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.434]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.434]                               "release", "version")], collapse = " "), 
[16:05:06.434]                             hostname = base::Sys.info()[["nodename"]])
[16:05:06.434]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.434]                             info)
[16:05:06.434]                           info <- base::paste(info, collapse = "; ")
[16:05:06.434]                           if (!has_future) {
[16:05:06.434]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.434]                               info)
[16:05:06.434]                           }
[16:05:06.434]                           else {
[16:05:06.434]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.434]                               info, version)
[16:05:06.434]                           }
[16:05:06.434]                           base::stop(msg)
[16:05:06.434]                         }
[16:05:06.434]                       })
[16:05:06.434]                     }
[16:05:06.434]                     base::local({
[16:05:06.434]                       for (pkg in "future") {
[16:05:06.434]                         base::loadNamespace(pkg)
[16:05:06.434]                         base::library(pkg, character.only = TRUE)
[16:05:06.434]                       }
[16:05:06.434]                     })
[16:05:06.434]                   }
[16:05:06.434]                   options(future.plan = NULL)
[16:05:06.434]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.434]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.434]                 }
[16:05:06.434]                 ...future.workdir <- getwd()
[16:05:06.434]             }
[16:05:06.434]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.434]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.434]         }
[16:05:06.434]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.434]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:06.434]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.434]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.434]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.434]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.434]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.434]             base::names(...future.oldOptions))
[16:05:06.434]     }
[16:05:06.434]     if (FALSE) {
[16:05:06.434]     }
[16:05:06.434]     else {
[16:05:06.434]         if (TRUE) {
[16:05:06.434]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.434]                 open = "w")
[16:05:06.434]         }
[16:05:06.434]         else {
[16:05:06.434]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.434]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.434]         }
[16:05:06.434]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.434]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.434]             base::sink(type = "output", split = FALSE)
[16:05:06.434]             base::close(...future.stdout)
[16:05:06.434]         }, add = TRUE)
[16:05:06.434]     }
[16:05:06.434]     ...future.frame <- base::sys.nframe()
[16:05:06.434]     ...future.conditions <- base::list()
[16:05:06.434]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.434]     if (FALSE) {
[16:05:06.434]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.434]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.434]     }
[16:05:06.434]     ...future.result <- base::tryCatch({
[16:05:06.434]         base::withCallingHandlers({
[16:05:06.434]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:05:06.434]                 1))
[16:05:06.434]             future::FutureResult(value = ...future.value$value, 
[16:05:06.434]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.434]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.434]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.434]                     ...future.globalenv.names))
[16:05:06.434]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.434]         }, condition = base::local({
[16:05:06.434]             c <- base::c
[16:05:06.434]             inherits <- base::inherits
[16:05:06.434]             invokeRestart <- base::invokeRestart
[16:05:06.434]             length <- base::length
[16:05:06.434]             list <- base::list
[16:05:06.434]             seq.int <- base::seq.int
[16:05:06.434]             signalCondition <- base::signalCondition
[16:05:06.434]             sys.calls <- base::sys.calls
[16:05:06.434]             `[[` <- base::`[[`
[16:05:06.434]             `+` <- base::`+`
[16:05:06.434]             `<<-` <- base::`<<-`
[16:05:06.434]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.434]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.434]                   3L)]
[16:05:06.434]             }
[16:05:06.434]             function(cond) {
[16:05:06.434]                 is_error <- inherits(cond, "error")
[16:05:06.434]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.434]                   NULL)
[16:05:06.434]                 if (is_error) {
[16:05:06.434]                   sessionInformation <- function() {
[16:05:06.434]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.434]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.434]                       search = base::search(), system = base::Sys.info())
[16:05:06.434]                   }
[16:05:06.434]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.434]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.434]                     cond$call), session = sessionInformation(), 
[16:05:06.434]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.434]                   signalCondition(cond)
[16:05:06.434]                 }
[16:05:06.434]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.434]                 "immediateCondition"))) {
[16:05:06.434]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.434]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.434]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.434]                   if (TRUE && !signal) {
[16:05:06.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.434]                     {
[16:05:06.434]                       inherits <- base::inherits
[16:05:06.434]                       invokeRestart <- base::invokeRestart
[16:05:06.434]                       is.null <- base::is.null
[16:05:06.434]                       muffled <- FALSE
[16:05:06.434]                       if (inherits(cond, "message")) {
[16:05:06.434]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.434]                         if (muffled) 
[16:05:06.434]                           invokeRestart("muffleMessage")
[16:05:06.434]                       }
[16:05:06.434]                       else if (inherits(cond, "warning")) {
[16:05:06.434]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.434]                         if (muffled) 
[16:05:06.434]                           invokeRestart("muffleWarning")
[16:05:06.434]                       }
[16:05:06.434]                       else if (inherits(cond, "condition")) {
[16:05:06.434]                         if (!is.null(pattern)) {
[16:05:06.434]                           computeRestarts <- base::computeRestarts
[16:05:06.434]                           grepl <- base::grepl
[16:05:06.434]                           restarts <- computeRestarts(cond)
[16:05:06.434]                           for (restart in restarts) {
[16:05:06.434]                             name <- restart$name
[16:05:06.434]                             if (is.null(name)) 
[16:05:06.434]                               next
[16:05:06.434]                             if (!grepl(pattern, name)) 
[16:05:06.434]                               next
[16:05:06.434]                             invokeRestart(restart)
[16:05:06.434]                             muffled <- TRUE
[16:05:06.434]                             break
[16:05:06.434]                           }
[16:05:06.434]                         }
[16:05:06.434]                       }
[16:05:06.434]                       invisible(muffled)
[16:05:06.434]                     }
[16:05:06.434]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.434]                   }
[16:05:06.434]                 }
[16:05:06.434]                 else {
[16:05:06.434]                   if (TRUE) {
[16:05:06.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.434]                     {
[16:05:06.434]                       inherits <- base::inherits
[16:05:06.434]                       invokeRestart <- base::invokeRestart
[16:05:06.434]                       is.null <- base::is.null
[16:05:06.434]                       muffled <- FALSE
[16:05:06.434]                       if (inherits(cond, "message")) {
[16:05:06.434]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.434]                         if (muffled) 
[16:05:06.434]                           invokeRestart("muffleMessage")
[16:05:06.434]                       }
[16:05:06.434]                       else if (inherits(cond, "warning")) {
[16:05:06.434]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.434]                         if (muffled) 
[16:05:06.434]                           invokeRestart("muffleWarning")
[16:05:06.434]                       }
[16:05:06.434]                       else if (inherits(cond, "condition")) {
[16:05:06.434]                         if (!is.null(pattern)) {
[16:05:06.434]                           computeRestarts <- base::computeRestarts
[16:05:06.434]                           grepl <- base::grepl
[16:05:06.434]                           restarts <- computeRestarts(cond)
[16:05:06.434]                           for (restart in restarts) {
[16:05:06.434]                             name <- restart$name
[16:05:06.434]                             if (is.null(name)) 
[16:05:06.434]                               next
[16:05:06.434]                             if (!grepl(pattern, name)) 
[16:05:06.434]                               next
[16:05:06.434]                             invokeRestart(restart)
[16:05:06.434]                             muffled <- TRUE
[16:05:06.434]                             break
[16:05:06.434]                           }
[16:05:06.434]                         }
[16:05:06.434]                       }
[16:05:06.434]                       invisible(muffled)
[16:05:06.434]                     }
[16:05:06.434]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.434]                   }
[16:05:06.434]                 }
[16:05:06.434]             }
[16:05:06.434]         }))
[16:05:06.434]     }, error = function(ex) {
[16:05:06.434]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.434]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.434]                 ...future.rng), started = ...future.startTime, 
[16:05:06.434]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.434]             version = "1.8"), class = "FutureResult")
[16:05:06.434]     }, finally = {
[16:05:06.434]         if (!identical(...future.workdir, getwd())) 
[16:05:06.434]             setwd(...future.workdir)
[16:05:06.434]         {
[16:05:06.434]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.434]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.434]             }
[16:05:06.434]             base::options(...future.oldOptions)
[16:05:06.434]             if (.Platform$OS.type == "windows") {
[16:05:06.434]                 old_names <- names(...future.oldEnvVars)
[16:05:06.434]                 envs <- base::Sys.getenv()
[16:05:06.434]                 names <- names(envs)
[16:05:06.434]                 common <- intersect(names, old_names)
[16:05:06.434]                 added <- setdiff(names, old_names)
[16:05:06.434]                 removed <- setdiff(old_names, names)
[16:05:06.434]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.434]                   envs[common]]
[16:05:06.434]                 NAMES <- toupper(changed)
[16:05:06.434]                 args <- list()
[16:05:06.434]                 for (kk in seq_along(NAMES)) {
[16:05:06.434]                   name <- changed[[kk]]
[16:05:06.434]                   NAME <- NAMES[[kk]]
[16:05:06.434]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.434]                     next
[16:05:06.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.434]                 }
[16:05:06.434]                 NAMES <- toupper(added)
[16:05:06.434]                 for (kk in seq_along(NAMES)) {
[16:05:06.434]                   name <- added[[kk]]
[16:05:06.434]                   NAME <- NAMES[[kk]]
[16:05:06.434]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.434]                     next
[16:05:06.434]                   args[[name]] <- ""
[16:05:06.434]                 }
[16:05:06.434]                 NAMES <- toupper(removed)
[16:05:06.434]                 for (kk in seq_along(NAMES)) {
[16:05:06.434]                   name <- removed[[kk]]
[16:05:06.434]                   NAME <- NAMES[[kk]]
[16:05:06.434]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.434]                     next
[16:05:06.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.434]                 }
[16:05:06.434]                 if (length(args) > 0) 
[16:05:06.434]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.434]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.434]             }
[16:05:06.434]             else {
[16:05:06.434]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.434]             }
[16:05:06.434]             {
[16:05:06.434]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.434]                   0L) {
[16:05:06.434]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.434]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.434]                   base::options(opts)
[16:05:06.434]                 }
[16:05:06.434]                 {
[16:05:06.434]                   {
[16:05:06.434]                     NULL
[16:05:06.434]                     RNGkind("Mersenne-Twister")
[16:05:06.434]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.434]                       inherits = FALSE)
[16:05:06.434]                   }
[16:05:06.434]                   options(future.plan = NULL)
[16:05:06.434]                   if (is.na(NA_character_)) 
[16:05:06.434]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.434]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.434]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.434]                   {
[16:05:06.434]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.434]                     if (!future$lazy) 
[16:05:06.434]                       future <- run(future)
[16:05:06.434]                     invisible(future)
[16:05:06.434]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.434]                 }
[16:05:06.434]             }
[16:05:06.434]         }
[16:05:06.434]     })
[16:05:06.434]     if (TRUE) {
[16:05:06.434]         base::sink(type = "output", split = FALSE)
[16:05:06.434]         if (TRUE) {
[16:05:06.434]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.434]         }
[16:05:06.434]         else {
[16:05:06.434]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.434]         }
[16:05:06.434]         base::close(...future.stdout)
[16:05:06.434]         ...future.stdout <- NULL
[16:05:06.434]     }
[16:05:06.434]     ...future.result$conditions <- ...future.conditions
[16:05:06.434]     ...future.result$finished <- base::Sys.time()
[16:05:06.434]     ...future.result
[16:05:06.434] }
[16:05:06.436] assign_globals() ...
[16:05:06.436] List of 1
[16:05:06.436]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a05414b178> 
[16:05:06.436]  - attr(*, "where")=List of 1
[16:05:06.436]   ..$ a:<environment: R_EmptyEnv> 
[16:05:06.436]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.436]  - attr(*, "resolved")= logi TRUE
[16:05:06.436]  - attr(*, "total_size")= num 10424
[16:05:06.436]  - attr(*, "already-done")= logi TRUE
[16:05:06.439] - copied ‘a’ to environment
[16:05:06.439] assign_globals() ... done
[16:05:06.439] plan(): Setting new future strategy stack:
[16:05:06.441] List of future strategies:
[16:05:06.441] 1. sequential:
[16:05:06.441]    - args: function (..., envir = parent.frame())
[16:05:06.441]    - tweaked: FALSE
[16:05:06.441]    - call: NULL
[16:05:06.441] plan(): nbrOfWorkers() = 1
[16:05:06.442] plan(): Setting new future strategy stack:
[16:05:06.442] List of future strategies:
[16:05:06.442] 1. sequential:
[16:05:06.442]    - args: function (..., envir = parent.frame())
[16:05:06.442]    - tweaked: FALSE
[16:05:06.442]    - call: plan(strategy)
[16:05:06.442] plan(): nbrOfWorkers() = 1
[16:05:06.443] SequentialFuture started (and completed)
[16:05:06.443] - Launch lazy future ... done
[16:05:06.443] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.443] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.443] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:06.444] 
[16:05:06.444] Searching for globals ... DONE
[16:05:06.444] - globals: [0] <none>
[16:05:06.444] getGlobalsAndPackages() ... DONE
[16:05:06.444] run() for ‘Future’ ...
[16:05:06.444] - state: ‘created’
[16:05:06.445] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.445] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.445] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.445]   - Field: ‘label’
[16:05:06.445]   - Field: ‘local’
[16:05:06.445]   - Field: ‘owner’
[16:05:06.445]   - Field: ‘envir’
[16:05:06.445]   - Field: ‘packages’
[16:05:06.446]   - Field: ‘gc’
[16:05:06.446]   - Field: ‘conditions’
[16:05:06.446]   - Field: ‘expr’
[16:05:06.446]   - Field: ‘uuid’
[16:05:06.446]   - Field: ‘seed’
[16:05:06.446]   - Field: ‘version’
[16:05:06.446]   - Field: ‘result’
[16:05:06.446]   - Field: ‘asynchronous’
[16:05:06.446]   - Field: ‘calls’
[16:05:06.446]   - Field: ‘globals’
[16:05:06.446]   - Field: ‘stdout’
[16:05:06.447]   - Field: ‘earlySignal’
[16:05:06.447]   - Field: ‘lazy’
[16:05:06.447]   - Field: ‘state’
[16:05:06.447] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.447] - Launch lazy future ...
[16:05:06.447] Packages needed by the future expression (n = 0): <none>
[16:05:06.447] Packages needed by future strategies (n = 0): <none>
[16:05:06.448] {
[16:05:06.448]     {
[16:05:06.448]         {
[16:05:06.448]             ...future.startTime <- base::Sys.time()
[16:05:06.448]             {
[16:05:06.448]                 {
[16:05:06.448]                   {
[16:05:06.448]                     base::local({
[16:05:06.448]                       has_future <- base::requireNamespace("future", 
[16:05:06.448]                         quietly = TRUE)
[16:05:06.448]                       if (has_future) {
[16:05:06.448]                         ns <- base::getNamespace("future")
[16:05:06.448]                         version <- ns[[".package"]][["version"]]
[16:05:06.448]                         if (is.null(version)) 
[16:05:06.448]                           version <- utils::packageVersion("future")
[16:05:06.448]                       }
[16:05:06.448]                       else {
[16:05:06.448]                         version <- NULL
[16:05:06.448]                       }
[16:05:06.448]                       if (!has_future || version < "1.8.0") {
[16:05:06.448]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.448]                           "", base::R.version$version.string), 
[16:05:06.448]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.448]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.448]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.448]                             "release", "version")], collapse = " "), 
[16:05:06.448]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.448]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.448]                           info)
[16:05:06.448]                         info <- base::paste(info, collapse = "; ")
[16:05:06.448]                         if (!has_future) {
[16:05:06.448]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.448]                             info)
[16:05:06.448]                         }
[16:05:06.448]                         else {
[16:05:06.448]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.448]                             info, version)
[16:05:06.448]                         }
[16:05:06.448]                         base::stop(msg)
[16:05:06.448]                       }
[16:05:06.448]                     })
[16:05:06.448]                   }
[16:05:06.448]                   options(future.plan = NULL)
[16:05:06.448]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.448]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.448]                 }
[16:05:06.448]                 ...future.workdir <- getwd()
[16:05:06.448]             }
[16:05:06.448]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.448]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.448]         }
[16:05:06.448]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.448]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:06.448]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.448]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.448]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.448]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.448]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.448]             base::names(...future.oldOptions))
[16:05:06.448]     }
[16:05:06.448]     if (FALSE) {
[16:05:06.448]     }
[16:05:06.448]     else {
[16:05:06.448]         if (TRUE) {
[16:05:06.448]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.448]                 open = "w")
[16:05:06.448]         }
[16:05:06.448]         else {
[16:05:06.448]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.448]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.448]         }
[16:05:06.448]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.448]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.448]             base::sink(type = "output", split = FALSE)
[16:05:06.448]             base::close(...future.stdout)
[16:05:06.448]         }, add = TRUE)
[16:05:06.448]     }
[16:05:06.448]     ...future.frame <- base::sys.nframe()
[16:05:06.448]     ...future.conditions <- base::list()
[16:05:06.448]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.448]     if (FALSE) {
[16:05:06.448]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.448]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.448]     }
[16:05:06.448]     ...future.result <- base::tryCatch({
[16:05:06.448]         base::withCallingHandlers({
[16:05:06.448]             ...future.value <- base::withVisible(base::local(1))
[16:05:06.448]             future::FutureResult(value = ...future.value$value, 
[16:05:06.448]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.448]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.448]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.448]                     ...future.globalenv.names))
[16:05:06.448]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.448]         }, condition = base::local({
[16:05:06.448]             c <- base::c
[16:05:06.448]             inherits <- base::inherits
[16:05:06.448]             invokeRestart <- base::invokeRestart
[16:05:06.448]             length <- base::length
[16:05:06.448]             list <- base::list
[16:05:06.448]             seq.int <- base::seq.int
[16:05:06.448]             signalCondition <- base::signalCondition
[16:05:06.448]             sys.calls <- base::sys.calls
[16:05:06.448]             `[[` <- base::`[[`
[16:05:06.448]             `+` <- base::`+`
[16:05:06.448]             `<<-` <- base::`<<-`
[16:05:06.448]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.448]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.448]                   3L)]
[16:05:06.448]             }
[16:05:06.448]             function(cond) {
[16:05:06.448]                 is_error <- inherits(cond, "error")
[16:05:06.448]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.448]                   NULL)
[16:05:06.448]                 if (is_error) {
[16:05:06.448]                   sessionInformation <- function() {
[16:05:06.448]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.448]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.448]                       search = base::search(), system = base::Sys.info())
[16:05:06.448]                   }
[16:05:06.448]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.448]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.448]                     cond$call), session = sessionInformation(), 
[16:05:06.448]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.448]                   signalCondition(cond)
[16:05:06.448]                 }
[16:05:06.448]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.448]                 "immediateCondition"))) {
[16:05:06.448]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.448]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.448]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.448]                   if (TRUE && !signal) {
[16:05:06.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.448]                     {
[16:05:06.448]                       inherits <- base::inherits
[16:05:06.448]                       invokeRestart <- base::invokeRestart
[16:05:06.448]                       is.null <- base::is.null
[16:05:06.448]                       muffled <- FALSE
[16:05:06.448]                       if (inherits(cond, "message")) {
[16:05:06.448]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.448]                         if (muffled) 
[16:05:06.448]                           invokeRestart("muffleMessage")
[16:05:06.448]                       }
[16:05:06.448]                       else if (inherits(cond, "warning")) {
[16:05:06.448]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.448]                         if (muffled) 
[16:05:06.448]                           invokeRestart("muffleWarning")
[16:05:06.448]                       }
[16:05:06.448]                       else if (inherits(cond, "condition")) {
[16:05:06.448]                         if (!is.null(pattern)) {
[16:05:06.448]                           computeRestarts <- base::computeRestarts
[16:05:06.448]                           grepl <- base::grepl
[16:05:06.448]                           restarts <- computeRestarts(cond)
[16:05:06.448]                           for (restart in restarts) {
[16:05:06.448]                             name <- restart$name
[16:05:06.448]                             if (is.null(name)) 
[16:05:06.448]                               next
[16:05:06.448]                             if (!grepl(pattern, name)) 
[16:05:06.448]                               next
[16:05:06.448]                             invokeRestart(restart)
[16:05:06.448]                             muffled <- TRUE
[16:05:06.448]                             break
[16:05:06.448]                           }
[16:05:06.448]                         }
[16:05:06.448]                       }
[16:05:06.448]                       invisible(muffled)
[16:05:06.448]                     }
[16:05:06.448]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.448]                   }
[16:05:06.448]                 }
[16:05:06.448]                 else {
[16:05:06.448]                   if (TRUE) {
[16:05:06.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.448]                     {
[16:05:06.448]                       inherits <- base::inherits
[16:05:06.448]                       invokeRestart <- base::invokeRestart
[16:05:06.448]                       is.null <- base::is.null
[16:05:06.448]                       muffled <- FALSE
[16:05:06.448]                       if (inherits(cond, "message")) {
[16:05:06.448]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.448]                         if (muffled) 
[16:05:06.448]                           invokeRestart("muffleMessage")
[16:05:06.448]                       }
[16:05:06.448]                       else if (inherits(cond, "warning")) {
[16:05:06.448]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.448]                         if (muffled) 
[16:05:06.448]                           invokeRestart("muffleWarning")
[16:05:06.448]                       }
[16:05:06.448]                       else if (inherits(cond, "condition")) {
[16:05:06.448]                         if (!is.null(pattern)) {
[16:05:06.448]                           computeRestarts <- base::computeRestarts
[16:05:06.448]                           grepl <- base::grepl
[16:05:06.448]                           restarts <- computeRestarts(cond)
[16:05:06.448]                           for (restart in restarts) {
[16:05:06.448]                             name <- restart$name
[16:05:06.448]                             if (is.null(name)) 
[16:05:06.448]                               next
[16:05:06.448]                             if (!grepl(pattern, name)) 
[16:05:06.448]                               next
[16:05:06.448]                             invokeRestart(restart)
[16:05:06.448]                             muffled <- TRUE
[16:05:06.448]                             break
[16:05:06.448]                           }
[16:05:06.448]                         }
[16:05:06.448]                       }
[16:05:06.448]                       invisible(muffled)
[16:05:06.448]                     }
[16:05:06.448]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.448]                   }
[16:05:06.448]                 }
[16:05:06.448]             }
[16:05:06.448]         }))
[16:05:06.448]     }, error = function(ex) {
[16:05:06.448]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.448]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.448]                 ...future.rng), started = ...future.startTime, 
[16:05:06.448]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.448]             version = "1.8"), class = "FutureResult")
[16:05:06.448]     }, finally = {
[16:05:06.448]         if (!identical(...future.workdir, getwd())) 
[16:05:06.448]             setwd(...future.workdir)
[16:05:06.448]         {
[16:05:06.448]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.448]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.448]             }
[16:05:06.448]             base::options(...future.oldOptions)
[16:05:06.448]             if (.Platform$OS.type == "windows") {
[16:05:06.448]                 old_names <- names(...future.oldEnvVars)
[16:05:06.448]                 envs <- base::Sys.getenv()
[16:05:06.448]                 names <- names(envs)
[16:05:06.448]                 common <- intersect(names, old_names)
[16:05:06.448]                 added <- setdiff(names, old_names)
[16:05:06.448]                 removed <- setdiff(old_names, names)
[16:05:06.448]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.448]                   envs[common]]
[16:05:06.448]                 NAMES <- toupper(changed)
[16:05:06.448]                 args <- list()
[16:05:06.448]                 for (kk in seq_along(NAMES)) {
[16:05:06.448]                   name <- changed[[kk]]
[16:05:06.448]                   NAME <- NAMES[[kk]]
[16:05:06.448]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.448]                     next
[16:05:06.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.448]                 }
[16:05:06.448]                 NAMES <- toupper(added)
[16:05:06.448]                 for (kk in seq_along(NAMES)) {
[16:05:06.448]                   name <- added[[kk]]
[16:05:06.448]                   NAME <- NAMES[[kk]]
[16:05:06.448]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.448]                     next
[16:05:06.448]                   args[[name]] <- ""
[16:05:06.448]                 }
[16:05:06.448]                 NAMES <- toupper(removed)
[16:05:06.448]                 for (kk in seq_along(NAMES)) {
[16:05:06.448]                   name <- removed[[kk]]
[16:05:06.448]                   NAME <- NAMES[[kk]]
[16:05:06.448]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.448]                     next
[16:05:06.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.448]                 }
[16:05:06.448]                 if (length(args) > 0) 
[16:05:06.448]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.448]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.448]             }
[16:05:06.448]             else {
[16:05:06.448]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.448]             }
[16:05:06.448]             {
[16:05:06.448]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.448]                   0L) {
[16:05:06.448]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.448]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.448]                   base::options(opts)
[16:05:06.448]                 }
[16:05:06.448]                 {
[16:05:06.448]                   {
[16:05:06.448]                     NULL
[16:05:06.448]                     RNGkind("Mersenne-Twister")
[16:05:06.448]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.448]                       inherits = FALSE)
[16:05:06.448]                   }
[16:05:06.448]                   options(future.plan = NULL)
[16:05:06.448]                   if (is.na(NA_character_)) 
[16:05:06.448]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.448]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.448]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.448]                   {
[16:05:06.448]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.448]                     if (!future$lazy) 
[16:05:06.448]                       future <- run(future)
[16:05:06.448]                     invisible(future)
[16:05:06.448]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.448]                 }
[16:05:06.448]             }
[16:05:06.448]         }
[16:05:06.448]     })
[16:05:06.448]     if (TRUE) {
[16:05:06.448]         base::sink(type = "output", split = FALSE)
[16:05:06.448]         if (TRUE) {
[16:05:06.448]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.448]         }
[16:05:06.448]         else {
[16:05:06.448]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.448]         }
[16:05:06.448]         base::close(...future.stdout)
[16:05:06.448]         ...future.stdout <- NULL
[16:05:06.448]     }
[16:05:06.448]     ...future.result$conditions <- ...future.conditions
[16:05:06.448]     ...future.result$finished <- base::Sys.time()
[16:05:06.448]     ...future.result
[16:05:06.448] }
[16:05:06.449] plan(): Setting new future strategy stack:
[16:05:06.450] List of future strategies:
[16:05:06.450] 1. sequential:
[16:05:06.450]    - args: function (..., envir = parent.frame())
[16:05:06.450]    - tweaked: FALSE
[16:05:06.450]    - call: NULL
[16:05:06.450] plan(): nbrOfWorkers() = 1
[16:05:06.451] plan(): Setting new future strategy stack:
[16:05:06.451] List of future strategies:
[16:05:06.451] 1. sequential:
[16:05:06.451]    - args: function (..., envir = parent.frame())
[16:05:06.451]    - tweaked: FALSE
[16:05:06.451]    - call: plan(strategy)
[16:05:06.451] plan(): nbrOfWorkers() = 1
[16:05:06.451] SequentialFuture started (and completed)
[16:05:06.451] - Launch lazy future ... done
[16:05:06.451] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.452] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.452] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:06.453] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:06.453] Searching for globals ... DONE
[16:05:06.453] Resolving globals: TRUE
[16:05:06.453] Resolving any globals that are futures ...
[16:05:06.453] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:06.453] Resolving any globals that are futures ... DONE
[16:05:06.453] Resolving futures part of globals (recursively) ...
[16:05:06.454] resolve() on list ...
[16:05:06.454]  recursive: 99
[16:05:06.454]  length: 1
[16:05:06.454]  elements: ‘a’
[16:05:06.454] resolved() for ‘SequentialFuture’ ...
[16:05:06.454] - state: ‘finished’
[16:05:06.454] - run: TRUE
[16:05:06.454] - result: ‘FutureResult’
[16:05:06.454] resolved() for ‘SequentialFuture’ ... done
[16:05:06.455] Future #1
[16:05:06.455] resolved() for ‘SequentialFuture’ ...
[16:05:06.455] - state: ‘finished’
[16:05:06.455] - run: TRUE
[16:05:06.455] - result: ‘FutureResult’
[16:05:06.455] resolved() for ‘SequentialFuture’ ... done
[16:05:06.455] A SequentialFuture was resolved
[16:05:06.455]  length: 0 (resolved future 1)
[16:05:06.455] resolve() on list ... DONE
[16:05:06.456] - globals: [1] ‘a’
[16:05:06.456] Resolving futures part of globals (recursively) ... DONE
[16:05:06.456] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[16:05:06.457] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[16:05:06.457] - globals: [1] ‘a’
[16:05:06.457] - packages: [1] ‘future’
[16:05:06.457] getGlobalsAndPackages() ... DONE
[16:05:06.457] run() for ‘Future’ ...
[16:05:06.457] - state: ‘created’
[16:05:06.458] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.458] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.458] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.458]   - Field: ‘label’
[16:05:06.458]   - Field: ‘local’
[16:05:06.458]   - Field: ‘owner’
[16:05:06.458]   - Field: ‘envir’
[16:05:06.458]   - Field: ‘packages’
[16:05:06.458]   - Field: ‘gc’
[16:05:06.459]   - Field: ‘conditions’
[16:05:06.459]   - Field: ‘expr’
[16:05:06.459]   - Field: ‘uuid’
[16:05:06.459]   - Field: ‘seed’
[16:05:06.459]   - Field: ‘version’
[16:05:06.459]   - Field: ‘result’
[16:05:06.459]   - Field: ‘asynchronous’
[16:05:06.459]   - Field: ‘calls’
[16:05:06.459]   - Field: ‘globals’
[16:05:06.459]   - Field: ‘stdout’
[16:05:06.460]   - Field: ‘earlySignal’
[16:05:06.460]   - Field: ‘lazy’
[16:05:06.460]   - Field: ‘state’
[16:05:06.460] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.460] - Launch lazy future ...
[16:05:06.460] Packages needed by the future expression (n = 1): ‘future’
[16:05:06.460] Packages needed by future strategies (n = 0): <none>
[16:05:06.461] {
[16:05:06.461]     {
[16:05:06.461]         {
[16:05:06.461]             ...future.startTime <- base::Sys.time()
[16:05:06.461]             {
[16:05:06.461]                 {
[16:05:06.461]                   {
[16:05:06.461]                     {
[16:05:06.461]                       base::local({
[16:05:06.461]                         has_future <- base::requireNamespace("future", 
[16:05:06.461]                           quietly = TRUE)
[16:05:06.461]                         if (has_future) {
[16:05:06.461]                           ns <- base::getNamespace("future")
[16:05:06.461]                           version <- ns[[".package"]][["version"]]
[16:05:06.461]                           if (is.null(version)) 
[16:05:06.461]                             version <- utils::packageVersion("future")
[16:05:06.461]                         }
[16:05:06.461]                         else {
[16:05:06.461]                           version <- NULL
[16:05:06.461]                         }
[16:05:06.461]                         if (!has_future || version < "1.8.0") {
[16:05:06.461]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.461]                             "", base::R.version$version.string), 
[16:05:06.461]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:06.461]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.461]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.461]                               "release", "version")], collapse = " "), 
[16:05:06.461]                             hostname = base::Sys.info()[["nodename"]])
[16:05:06.461]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.461]                             info)
[16:05:06.461]                           info <- base::paste(info, collapse = "; ")
[16:05:06.461]                           if (!has_future) {
[16:05:06.461]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.461]                               info)
[16:05:06.461]                           }
[16:05:06.461]                           else {
[16:05:06.461]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.461]                               info, version)
[16:05:06.461]                           }
[16:05:06.461]                           base::stop(msg)
[16:05:06.461]                         }
[16:05:06.461]                       })
[16:05:06.461]                     }
[16:05:06.461]                     base::local({
[16:05:06.461]                       for (pkg in "future") {
[16:05:06.461]                         base::loadNamespace(pkg)
[16:05:06.461]                         base::library(pkg, character.only = TRUE)
[16:05:06.461]                       }
[16:05:06.461]                     })
[16:05:06.461]                   }
[16:05:06.461]                   options(future.plan = NULL)
[16:05:06.461]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.461]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.461]                 }
[16:05:06.461]                 ...future.workdir <- getwd()
[16:05:06.461]             }
[16:05:06.461]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.461]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.461]         }
[16:05:06.461]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.461]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:06.461]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.461]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.461]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.461]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.461]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.461]             base::names(...future.oldOptions))
[16:05:06.461]     }
[16:05:06.461]     if (FALSE) {
[16:05:06.461]     }
[16:05:06.461]     else {
[16:05:06.461]         if (TRUE) {
[16:05:06.461]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.461]                 open = "w")
[16:05:06.461]         }
[16:05:06.461]         else {
[16:05:06.461]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.461]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.461]         }
[16:05:06.461]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.461]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.461]             base::sink(type = "output", split = FALSE)
[16:05:06.461]             base::close(...future.stdout)
[16:05:06.461]         }, add = TRUE)
[16:05:06.461]     }
[16:05:06.461]     ...future.frame <- base::sys.nframe()
[16:05:06.461]     ...future.conditions <- base::list()
[16:05:06.461]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.461]     if (FALSE) {
[16:05:06.461]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.461]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.461]     }
[16:05:06.461]     ...future.result <- base::tryCatch({
[16:05:06.461]         base::withCallingHandlers({
[16:05:06.461]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:05:06.461]                 1))
[16:05:06.461]             future::FutureResult(value = ...future.value$value, 
[16:05:06.461]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.461]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.461]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.461]                     ...future.globalenv.names))
[16:05:06.461]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.461]         }, condition = base::local({
[16:05:06.461]             c <- base::c
[16:05:06.461]             inherits <- base::inherits
[16:05:06.461]             invokeRestart <- base::invokeRestart
[16:05:06.461]             length <- base::length
[16:05:06.461]             list <- base::list
[16:05:06.461]             seq.int <- base::seq.int
[16:05:06.461]             signalCondition <- base::signalCondition
[16:05:06.461]             sys.calls <- base::sys.calls
[16:05:06.461]             `[[` <- base::`[[`
[16:05:06.461]             `+` <- base::`+`
[16:05:06.461]             `<<-` <- base::`<<-`
[16:05:06.461]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.461]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.461]                   3L)]
[16:05:06.461]             }
[16:05:06.461]             function(cond) {
[16:05:06.461]                 is_error <- inherits(cond, "error")
[16:05:06.461]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.461]                   NULL)
[16:05:06.461]                 if (is_error) {
[16:05:06.461]                   sessionInformation <- function() {
[16:05:06.461]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.461]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.461]                       search = base::search(), system = base::Sys.info())
[16:05:06.461]                   }
[16:05:06.461]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.461]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.461]                     cond$call), session = sessionInformation(), 
[16:05:06.461]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.461]                   signalCondition(cond)
[16:05:06.461]                 }
[16:05:06.461]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.461]                 "immediateCondition"))) {
[16:05:06.461]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.461]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.461]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.461]                   if (TRUE && !signal) {
[16:05:06.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.461]                     {
[16:05:06.461]                       inherits <- base::inherits
[16:05:06.461]                       invokeRestart <- base::invokeRestart
[16:05:06.461]                       is.null <- base::is.null
[16:05:06.461]                       muffled <- FALSE
[16:05:06.461]                       if (inherits(cond, "message")) {
[16:05:06.461]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.461]                         if (muffled) 
[16:05:06.461]                           invokeRestart("muffleMessage")
[16:05:06.461]                       }
[16:05:06.461]                       else if (inherits(cond, "warning")) {
[16:05:06.461]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.461]                         if (muffled) 
[16:05:06.461]                           invokeRestart("muffleWarning")
[16:05:06.461]                       }
[16:05:06.461]                       else if (inherits(cond, "condition")) {
[16:05:06.461]                         if (!is.null(pattern)) {
[16:05:06.461]                           computeRestarts <- base::computeRestarts
[16:05:06.461]                           grepl <- base::grepl
[16:05:06.461]                           restarts <- computeRestarts(cond)
[16:05:06.461]                           for (restart in restarts) {
[16:05:06.461]                             name <- restart$name
[16:05:06.461]                             if (is.null(name)) 
[16:05:06.461]                               next
[16:05:06.461]                             if (!grepl(pattern, name)) 
[16:05:06.461]                               next
[16:05:06.461]                             invokeRestart(restart)
[16:05:06.461]                             muffled <- TRUE
[16:05:06.461]                             break
[16:05:06.461]                           }
[16:05:06.461]                         }
[16:05:06.461]                       }
[16:05:06.461]                       invisible(muffled)
[16:05:06.461]                     }
[16:05:06.461]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.461]                   }
[16:05:06.461]                 }
[16:05:06.461]                 else {
[16:05:06.461]                   if (TRUE) {
[16:05:06.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.461]                     {
[16:05:06.461]                       inherits <- base::inherits
[16:05:06.461]                       invokeRestart <- base::invokeRestart
[16:05:06.461]                       is.null <- base::is.null
[16:05:06.461]                       muffled <- FALSE
[16:05:06.461]                       if (inherits(cond, "message")) {
[16:05:06.461]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.461]                         if (muffled) 
[16:05:06.461]                           invokeRestart("muffleMessage")
[16:05:06.461]                       }
[16:05:06.461]                       else if (inherits(cond, "warning")) {
[16:05:06.461]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.461]                         if (muffled) 
[16:05:06.461]                           invokeRestart("muffleWarning")
[16:05:06.461]                       }
[16:05:06.461]                       else if (inherits(cond, "condition")) {
[16:05:06.461]                         if (!is.null(pattern)) {
[16:05:06.461]                           computeRestarts <- base::computeRestarts
[16:05:06.461]                           grepl <- base::grepl
[16:05:06.461]                           restarts <- computeRestarts(cond)
[16:05:06.461]                           for (restart in restarts) {
[16:05:06.461]                             name <- restart$name
[16:05:06.461]                             if (is.null(name)) 
[16:05:06.461]                               next
[16:05:06.461]                             if (!grepl(pattern, name)) 
[16:05:06.461]                               next
[16:05:06.461]                             invokeRestart(restart)
[16:05:06.461]                             muffled <- TRUE
[16:05:06.461]                             break
[16:05:06.461]                           }
[16:05:06.461]                         }
[16:05:06.461]                       }
[16:05:06.461]                       invisible(muffled)
[16:05:06.461]                     }
[16:05:06.461]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.461]                   }
[16:05:06.461]                 }
[16:05:06.461]             }
[16:05:06.461]         }))
[16:05:06.461]     }, error = function(ex) {
[16:05:06.461]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.461]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.461]                 ...future.rng), started = ...future.startTime, 
[16:05:06.461]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.461]             version = "1.8"), class = "FutureResult")
[16:05:06.461]     }, finally = {
[16:05:06.461]         if (!identical(...future.workdir, getwd())) 
[16:05:06.461]             setwd(...future.workdir)
[16:05:06.461]         {
[16:05:06.461]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.461]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.461]             }
[16:05:06.461]             base::options(...future.oldOptions)
[16:05:06.461]             if (.Platform$OS.type == "windows") {
[16:05:06.461]                 old_names <- names(...future.oldEnvVars)
[16:05:06.461]                 envs <- base::Sys.getenv()
[16:05:06.461]                 names <- names(envs)
[16:05:06.461]                 common <- intersect(names, old_names)
[16:05:06.461]                 added <- setdiff(names, old_names)
[16:05:06.461]                 removed <- setdiff(old_names, names)
[16:05:06.461]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.461]                   envs[common]]
[16:05:06.461]                 NAMES <- toupper(changed)
[16:05:06.461]                 args <- list()
[16:05:06.461]                 for (kk in seq_along(NAMES)) {
[16:05:06.461]                   name <- changed[[kk]]
[16:05:06.461]                   NAME <- NAMES[[kk]]
[16:05:06.461]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.461]                     next
[16:05:06.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.461]                 }
[16:05:06.461]                 NAMES <- toupper(added)
[16:05:06.461]                 for (kk in seq_along(NAMES)) {
[16:05:06.461]                   name <- added[[kk]]
[16:05:06.461]                   NAME <- NAMES[[kk]]
[16:05:06.461]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.461]                     next
[16:05:06.461]                   args[[name]] <- ""
[16:05:06.461]                 }
[16:05:06.461]                 NAMES <- toupper(removed)
[16:05:06.461]                 for (kk in seq_along(NAMES)) {
[16:05:06.461]                   name <- removed[[kk]]
[16:05:06.461]                   NAME <- NAMES[[kk]]
[16:05:06.461]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.461]                     next
[16:05:06.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.461]                 }
[16:05:06.461]                 if (length(args) > 0) 
[16:05:06.461]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.461]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.461]             }
[16:05:06.461]             else {
[16:05:06.461]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.461]             }
[16:05:06.461]             {
[16:05:06.461]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.461]                   0L) {
[16:05:06.461]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.461]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.461]                   base::options(opts)
[16:05:06.461]                 }
[16:05:06.461]                 {
[16:05:06.461]                   {
[16:05:06.461]                     NULL
[16:05:06.461]                     RNGkind("Mersenne-Twister")
[16:05:06.461]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.461]                       inherits = FALSE)
[16:05:06.461]                   }
[16:05:06.461]                   options(future.plan = NULL)
[16:05:06.461]                   if (is.na(NA_character_)) 
[16:05:06.461]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.461]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.461]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.461]                   {
[16:05:06.461]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.461]                     if (!future$lazy) 
[16:05:06.461]                       future <- run(future)
[16:05:06.461]                     invisible(future)
[16:05:06.461]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.461]                 }
[16:05:06.461]             }
[16:05:06.461]         }
[16:05:06.461]     })
[16:05:06.461]     if (TRUE) {
[16:05:06.461]         base::sink(type = "output", split = FALSE)
[16:05:06.461]         if (TRUE) {
[16:05:06.461]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.461]         }
[16:05:06.461]         else {
[16:05:06.461]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.461]         }
[16:05:06.461]         base::close(...future.stdout)
[16:05:06.461]         ...future.stdout <- NULL
[16:05:06.461]     }
[16:05:06.461]     ...future.result$conditions <- ...future.conditions
[16:05:06.461]     ...future.result$finished <- base::Sys.time()
[16:05:06.461]     ...future.result
[16:05:06.461] }
[16:05:06.462] assign_globals() ...
[16:05:06.462] List of 1
[16:05:06.462]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a05488d920> 
[16:05:06.462]  - attr(*, "where")=List of 1
[16:05:06.462]   ..$ a:<environment: R_EmptyEnv> 
[16:05:06.462]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.462]  - attr(*, "resolved")= logi TRUE
[16:05:06.462]  - attr(*, "total_size")= num 10424
[16:05:06.462]  - attr(*, "already-done")= logi TRUE
[16:05:06.465] - copied ‘a’ to environment
[16:05:06.465] assign_globals() ... done
[16:05:06.465] plan(): Setting new future strategy stack:
[16:05:06.465] List of future strategies:
[16:05:06.465] 1. sequential:
[16:05:06.465]    - args: function (..., envir = parent.frame())
[16:05:06.465]    - tweaked: FALSE
[16:05:06.465]    - call: NULL
[16:05:06.466] plan(): nbrOfWorkers() = 1
[16:05:06.467] plan(): Setting new future strategy stack:
[16:05:06.467] List of future strategies:
[16:05:06.467] 1. sequential:
[16:05:06.467]    - args: function (..., envir = parent.frame())
[16:05:06.467]    - tweaked: FALSE
[16:05:06.467]    - call: plan(strategy)
[16:05:06.467] plan(): nbrOfWorkers() = 1
[16:05:06.467] SequentialFuture started (and completed)
[16:05:06.467] - Launch lazy future ... done
[16:05:06.469] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.470] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.470] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:06.470] 
[16:05:06.471] Searching for globals ... DONE
[16:05:06.471] - globals: [0] <none>
[16:05:06.471] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.471] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.471] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:06.472] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:06.472] Searching for globals ... DONE
[16:05:06.472] Resolving globals: TRUE
[16:05:06.473] Resolving any globals that are futures ...
[16:05:06.473] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:06.473] Resolving any globals that are futures ... DONE
[16:05:06.473] Resolving futures part of globals (recursively) ...
[16:05:06.473] resolve() on list ...
[16:05:06.473]  recursive: 99
[16:05:06.473]  length: 1
[16:05:06.474]  elements: ‘a’
[16:05:06.474] run() for ‘Future’ ...
[16:05:06.474] - state: ‘created’
[16:05:06.474] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.474] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.474] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.474]   - Field: ‘label’
[16:05:06.474]   - Field: ‘local’
[16:05:06.475]   - Field: ‘owner’
[16:05:06.475]   - Field: ‘envir’
[16:05:06.475]   - Field: ‘packages’
[16:05:06.475]   - Field: ‘gc’
[16:05:06.475]   - Field: ‘conditions’
[16:05:06.475]   - Field: ‘expr’
[16:05:06.475]   - Field: ‘uuid’
[16:05:06.475]   - Field: ‘seed’
[16:05:06.475]   - Field: ‘version’
[16:05:06.475]   - Field: ‘result’
[16:05:06.476]   - Field: ‘asynchronous’
[16:05:06.476]   - Field: ‘calls’
[16:05:06.476]   - Field: ‘globals’
[16:05:06.476]   - Field: ‘stdout’
[16:05:06.476]   - Field: ‘earlySignal’
[16:05:06.476]   - Field: ‘lazy’
[16:05:06.476]   - Field: ‘state’
[16:05:06.476] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.476] - Launch lazy future ...
[16:05:06.476] Packages needed by the future expression (n = 0): <none>
[16:05:06.477] Packages needed by future strategies (n = 0): <none>
[16:05:06.477] {
[16:05:06.477]     {
[16:05:06.477]         {
[16:05:06.477]             ...future.startTime <- base::Sys.time()
[16:05:06.477]             {
[16:05:06.477]                 {
[16:05:06.477]                   {
[16:05:06.477]                     base::local({
[16:05:06.477]                       has_future <- base::requireNamespace("future", 
[16:05:06.477]                         quietly = TRUE)
[16:05:06.477]                       if (has_future) {
[16:05:06.477]                         ns <- base::getNamespace("future")
[16:05:06.477]                         version <- ns[[".package"]][["version"]]
[16:05:06.477]                         if (is.null(version)) 
[16:05:06.477]                           version <- utils::packageVersion("future")
[16:05:06.477]                       }
[16:05:06.477]                       else {
[16:05:06.477]                         version <- NULL
[16:05:06.477]                       }
[16:05:06.477]                       if (!has_future || version < "1.8.0") {
[16:05:06.477]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.477]                           "", base::R.version$version.string), 
[16:05:06.477]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.477]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.477]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.477]                             "release", "version")], collapse = " "), 
[16:05:06.477]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.477]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.477]                           info)
[16:05:06.477]                         info <- base::paste(info, collapse = "; ")
[16:05:06.477]                         if (!has_future) {
[16:05:06.477]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.477]                             info)
[16:05:06.477]                         }
[16:05:06.477]                         else {
[16:05:06.477]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.477]                             info, version)
[16:05:06.477]                         }
[16:05:06.477]                         base::stop(msg)
[16:05:06.477]                       }
[16:05:06.477]                     })
[16:05:06.477]                   }
[16:05:06.477]                   options(future.plan = NULL)
[16:05:06.477]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.477]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.477]                 }
[16:05:06.477]                 ...future.workdir <- getwd()
[16:05:06.477]             }
[16:05:06.477]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.477]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.477]         }
[16:05:06.477]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.477]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:06.477]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.477]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.477]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.477]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.477]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.477]             base::names(...future.oldOptions))
[16:05:06.477]     }
[16:05:06.477]     if (FALSE) {
[16:05:06.477]     }
[16:05:06.477]     else {
[16:05:06.477]         if (TRUE) {
[16:05:06.477]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.477]                 open = "w")
[16:05:06.477]         }
[16:05:06.477]         else {
[16:05:06.477]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.477]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.477]         }
[16:05:06.477]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.477]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.477]             base::sink(type = "output", split = FALSE)
[16:05:06.477]             base::close(...future.stdout)
[16:05:06.477]         }, add = TRUE)
[16:05:06.477]     }
[16:05:06.477]     ...future.frame <- base::sys.nframe()
[16:05:06.477]     ...future.conditions <- base::list()
[16:05:06.477]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.477]     if (FALSE) {
[16:05:06.477]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.477]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.477]     }
[16:05:06.477]     ...future.result <- base::tryCatch({
[16:05:06.477]         base::withCallingHandlers({
[16:05:06.477]             ...future.value <- base::withVisible(base::local(1))
[16:05:06.477]             future::FutureResult(value = ...future.value$value, 
[16:05:06.477]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.477]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.477]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.477]                     ...future.globalenv.names))
[16:05:06.477]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.477]         }, condition = base::local({
[16:05:06.477]             c <- base::c
[16:05:06.477]             inherits <- base::inherits
[16:05:06.477]             invokeRestart <- base::invokeRestart
[16:05:06.477]             length <- base::length
[16:05:06.477]             list <- base::list
[16:05:06.477]             seq.int <- base::seq.int
[16:05:06.477]             signalCondition <- base::signalCondition
[16:05:06.477]             sys.calls <- base::sys.calls
[16:05:06.477]             `[[` <- base::`[[`
[16:05:06.477]             `+` <- base::`+`
[16:05:06.477]             `<<-` <- base::`<<-`
[16:05:06.477]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.477]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.477]                   3L)]
[16:05:06.477]             }
[16:05:06.477]             function(cond) {
[16:05:06.477]                 is_error <- inherits(cond, "error")
[16:05:06.477]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.477]                   NULL)
[16:05:06.477]                 if (is_error) {
[16:05:06.477]                   sessionInformation <- function() {
[16:05:06.477]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.477]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.477]                       search = base::search(), system = base::Sys.info())
[16:05:06.477]                   }
[16:05:06.477]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.477]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.477]                     cond$call), session = sessionInformation(), 
[16:05:06.477]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.477]                   signalCondition(cond)
[16:05:06.477]                 }
[16:05:06.477]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.477]                 "immediateCondition"))) {
[16:05:06.477]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.477]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.477]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.477]                   if (TRUE && !signal) {
[16:05:06.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.477]                     {
[16:05:06.477]                       inherits <- base::inherits
[16:05:06.477]                       invokeRestart <- base::invokeRestart
[16:05:06.477]                       is.null <- base::is.null
[16:05:06.477]                       muffled <- FALSE
[16:05:06.477]                       if (inherits(cond, "message")) {
[16:05:06.477]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.477]                         if (muffled) 
[16:05:06.477]                           invokeRestart("muffleMessage")
[16:05:06.477]                       }
[16:05:06.477]                       else if (inherits(cond, "warning")) {
[16:05:06.477]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.477]                         if (muffled) 
[16:05:06.477]                           invokeRestart("muffleWarning")
[16:05:06.477]                       }
[16:05:06.477]                       else if (inherits(cond, "condition")) {
[16:05:06.477]                         if (!is.null(pattern)) {
[16:05:06.477]                           computeRestarts <- base::computeRestarts
[16:05:06.477]                           grepl <- base::grepl
[16:05:06.477]                           restarts <- computeRestarts(cond)
[16:05:06.477]                           for (restart in restarts) {
[16:05:06.477]                             name <- restart$name
[16:05:06.477]                             if (is.null(name)) 
[16:05:06.477]                               next
[16:05:06.477]                             if (!grepl(pattern, name)) 
[16:05:06.477]                               next
[16:05:06.477]                             invokeRestart(restart)
[16:05:06.477]                             muffled <- TRUE
[16:05:06.477]                             break
[16:05:06.477]                           }
[16:05:06.477]                         }
[16:05:06.477]                       }
[16:05:06.477]                       invisible(muffled)
[16:05:06.477]                     }
[16:05:06.477]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.477]                   }
[16:05:06.477]                 }
[16:05:06.477]                 else {
[16:05:06.477]                   if (TRUE) {
[16:05:06.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.477]                     {
[16:05:06.477]                       inherits <- base::inherits
[16:05:06.477]                       invokeRestart <- base::invokeRestart
[16:05:06.477]                       is.null <- base::is.null
[16:05:06.477]                       muffled <- FALSE
[16:05:06.477]                       if (inherits(cond, "message")) {
[16:05:06.477]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.477]                         if (muffled) 
[16:05:06.477]                           invokeRestart("muffleMessage")
[16:05:06.477]                       }
[16:05:06.477]                       else if (inherits(cond, "warning")) {
[16:05:06.477]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.477]                         if (muffled) 
[16:05:06.477]                           invokeRestart("muffleWarning")
[16:05:06.477]                       }
[16:05:06.477]                       else if (inherits(cond, "condition")) {
[16:05:06.477]                         if (!is.null(pattern)) {
[16:05:06.477]                           computeRestarts <- base::computeRestarts
[16:05:06.477]                           grepl <- base::grepl
[16:05:06.477]                           restarts <- computeRestarts(cond)
[16:05:06.477]                           for (restart in restarts) {
[16:05:06.477]                             name <- restart$name
[16:05:06.477]                             if (is.null(name)) 
[16:05:06.477]                               next
[16:05:06.477]                             if (!grepl(pattern, name)) 
[16:05:06.477]                               next
[16:05:06.477]                             invokeRestart(restart)
[16:05:06.477]                             muffled <- TRUE
[16:05:06.477]                             break
[16:05:06.477]                           }
[16:05:06.477]                         }
[16:05:06.477]                       }
[16:05:06.477]                       invisible(muffled)
[16:05:06.477]                     }
[16:05:06.477]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.477]                   }
[16:05:06.477]                 }
[16:05:06.477]             }
[16:05:06.477]         }))
[16:05:06.477]     }, error = function(ex) {
[16:05:06.477]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.477]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.477]                 ...future.rng), started = ...future.startTime, 
[16:05:06.477]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.477]             version = "1.8"), class = "FutureResult")
[16:05:06.477]     }, finally = {
[16:05:06.477]         if (!identical(...future.workdir, getwd())) 
[16:05:06.477]             setwd(...future.workdir)
[16:05:06.477]         {
[16:05:06.477]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.477]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.477]             }
[16:05:06.477]             base::options(...future.oldOptions)
[16:05:06.477]             if (.Platform$OS.type == "windows") {
[16:05:06.477]                 old_names <- names(...future.oldEnvVars)
[16:05:06.477]                 envs <- base::Sys.getenv()
[16:05:06.477]                 names <- names(envs)
[16:05:06.477]                 common <- intersect(names, old_names)
[16:05:06.477]                 added <- setdiff(names, old_names)
[16:05:06.477]                 removed <- setdiff(old_names, names)
[16:05:06.477]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.477]                   envs[common]]
[16:05:06.477]                 NAMES <- toupper(changed)
[16:05:06.477]                 args <- list()
[16:05:06.477]                 for (kk in seq_along(NAMES)) {
[16:05:06.477]                   name <- changed[[kk]]
[16:05:06.477]                   NAME <- NAMES[[kk]]
[16:05:06.477]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.477]                     next
[16:05:06.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.477]                 }
[16:05:06.477]                 NAMES <- toupper(added)
[16:05:06.477]                 for (kk in seq_along(NAMES)) {
[16:05:06.477]                   name <- added[[kk]]
[16:05:06.477]                   NAME <- NAMES[[kk]]
[16:05:06.477]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.477]                     next
[16:05:06.477]                   args[[name]] <- ""
[16:05:06.477]                 }
[16:05:06.477]                 NAMES <- toupper(removed)
[16:05:06.477]                 for (kk in seq_along(NAMES)) {
[16:05:06.477]                   name <- removed[[kk]]
[16:05:06.477]                   NAME <- NAMES[[kk]]
[16:05:06.477]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.477]                     next
[16:05:06.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.477]                 }
[16:05:06.477]                 if (length(args) > 0) 
[16:05:06.477]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.477]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.477]             }
[16:05:06.477]             else {
[16:05:06.477]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.477]             }
[16:05:06.477]             {
[16:05:06.477]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.477]                   0L) {
[16:05:06.477]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.477]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.477]                   base::options(opts)
[16:05:06.477]                 }
[16:05:06.477]                 {
[16:05:06.477]                   {
[16:05:06.477]                     NULL
[16:05:06.477]                     RNGkind("Mersenne-Twister")
[16:05:06.477]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.477]                       inherits = FALSE)
[16:05:06.477]                   }
[16:05:06.477]                   options(future.plan = NULL)
[16:05:06.477]                   if (is.na(NA_character_)) 
[16:05:06.477]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.477]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.477]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.477]                   {
[16:05:06.477]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.477]                     if (!future$lazy) 
[16:05:06.477]                       future <- run(future)
[16:05:06.477]                     invisible(future)
[16:05:06.477]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.477]                 }
[16:05:06.477]             }
[16:05:06.477]         }
[16:05:06.477]     })
[16:05:06.477]     if (TRUE) {
[16:05:06.477]         base::sink(type = "output", split = FALSE)
[16:05:06.477]         if (TRUE) {
[16:05:06.477]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.477]         }
[16:05:06.477]         else {
[16:05:06.477]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.477]         }
[16:05:06.477]         base::close(...future.stdout)
[16:05:06.477]         ...future.stdout <- NULL
[16:05:06.477]     }
[16:05:06.477]     ...future.result$conditions <- ...future.conditions
[16:05:06.477]     ...future.result$finished <- base::Sys.time()
[16:05:06.477]     ...future.result
[16:05:06.477] }
[16:05:06.479] plan(): Setting new future strategy stack:
[16:05:06.479] List of future strategies:
[16:05:06.479] 1. sequential:
[16:05:06.479]    - args: function (..., envir = parent.frame())
[16:05:06.479]    - tweaked: FALSE
[16:05:06.479]    - call: NULL
[16:05:06.479] plan(): nbrOfWorkers() = 1
[16:05:06.480] plan(): Setting new future strategy stack:
[16:05:06.480] List of future strategies:
[16:05:06.480] 1. sequential:
[16:05:06.480]    - args: function (..., envir = parent.frame())
[16:05:06.480]    - tweaked: FALSE
[16:05:06.480]    - call: plan(strategy)
[16:05:06.480] plan(): nbrOfWorkers() = 1
[16:05:06.481] SequentialFuture started (and completed)
[16:05:06.481] - Launch lazy future ... done
[16:05:06.481] run() for ‘SequentialFuture’ ... done
[16:05:06.481] resolved() for ‘SequentialFuture’ ...
[16:05:06.481] - state: ‘finished’
[16:05:06.481] - run: TRUE
[16:05:06.481] - result: ‘FutureResult’
[16:05:06.481] resolved() for ‘SequentialFuture’ ... done
[16:05:06.481] Future #1
[16:05:06.481] resolved() for ‘SequentialFuture’ ...
[16:05:06.482] - state: ‘finished’
[16:05:06.482] - run: TRUE
[16:05:06.482] - result: ‘FutureResult’
[16:05:06.482] resolved() for ‘SequentialFuture’ ... done
[16:05:06.482] A SequentialFuture was resolved
[16:05:06.482]  length: 0 (resolved future 1)
[16:05:06.482] resolve() on list ... DONE
[16:05:06.482] - globals: [1] ‘a’
[16:05:06.482] Resolving futures part of globals (recursively) ... DONE
[16:05:06.483] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[16:05:06.483] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[16:05:06.484] - globals: [1] ‘a’
[16:05:06.484] - packages: [1] ‘future’
[16:05:06.484] getGlobalsAndPackages() ... DONE
[16:05:06.484] run() for ‘Future’ ...
[16:05:06.484] - state: ‘created’
[16:05:06.484] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.485] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.485] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.485]   - Field: ‘label’
[16:05:06.485]   - Field: ‘local’
[16:05:06.485]   - Field: ‘owner’
[16:05:06.485]   - Field: ‘envir’
[16:05:06.485]   - Field: ‘packages’
[16:05:06.485]   - Field: ‘gc’
[16:05:06.485]   - Field: ‘conditions’
[16:05:06.485]   - Field: ‘expr’
[16:05:06.486]   - Field: ‘uuid’
[16:05:06.486]   - Field: ‘seed’
[16:05:06.486]   - Field: ‘version’
[16:05:06.486]   - Field: ‘result’
[16:05:06.486]   - Field: ‘asynchronous’
[16:05:06.486]   - Field: ‘calls’
[16:05:06.486]   - Field: ‘globals’
[16:05:06.486]   - Field: ‘stdout’
[16:05:06.486]   - Field: ‘earlySignal’
[16:05:06.486]   - Field: ‘lazy’
[16:05:06.486]   - Field: ‘state’
[16:05:06.487] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.487] - Launch lazy future ...
[16:05:06.487] Packages needed by the future expression (n = 1): ‘future’
[16:05:06.487] Packages needed by future strategies (n = 0): <none>
[16:05:06.487] {
[16:05:06.487]     {
[16:05:06.487]         {
[16:05:06.487]             ...future.startTime <- base::Sys.time()
[16:05:06.487]             {
[16:05:06.487]                 {
[16:05:06.487]                   {
[16:05:06.487]                     {
[16:05:06.487]                       base::local({
[16:05:06.487]                         has_future <- base::requireNamespace("future", 
[16:05:06.487]                           quietly = TRUE)
[16:05:06.487]                         if (has_future) {
[16:05:06.487]                           ns <- base::getNamespace("future")
[16:05:06.487]                           version <- ns[[".package"]][["version"]]
[16:05:06.487]                           if (is.null(version)) 
[16:05:06.487]                             version <- utils::packageVersion("future")
[16:05:06.487]                         }
[16:05:06.487]                         else {
[16:05:06.487]                           version <- NULL
[16:05:06.487]                         }
[16:05:06.487]                         if (!has_future || version < "1.8.0") {
[16:05:06.487]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.487]                             "", base::R.version$version.string), 
[16:05:06.487]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:06.487]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.487]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.487]                               "release", "version")], collapse = " "), 
[16:05:06.487]                             hostname = base::Sys.info()[["nodename"]])
[16:05:06.487]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.487]                             info)
[16:05:06.487]                           info <- base::paste(info, collapse = "; ")
[16:05:06.487]                           if (!has_future) {
[16:05:06.487]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.487]                               info)
[16:05:06.487]                           }
[16:05:06.487]                           else {
[16:05:06.487]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.487]                               info, version)
[16:05:06.487]                           }
[16:05:06.487]                           base::stop(msg)
[16:05:06.487]                         }
[16:05:06.487]                       })
[16:05:06.487]                     }
[16:05:06.487]                     base::local({
[16:05:06.487]                       for (pkg in "future") {
[16:05:06.487]                         base::loadNamespace(pkg)
[16:05:06.487]                         base::library(pkg, character.only = TRUE)
[16:05:06.487]                       }
[16:05:06.487]                     })
[16:05:06.487]                   }
[16:05:06.487]                   options(future.plan = NULL)
[16:05:06.487]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.487]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.487]                 }
[16:05:06.487]                 ...future.workdir <- getwd()
[16:05:06.487]             }
[16:05:06.487]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.487]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.487]         }
[16:05:06.487]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.487]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:06.487]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.487]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.487]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.487]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.487]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.487]             base::names(...future.oldOptions))
[16:05:06.487]     }
[16:05:06.487]     if (FALSE) {
[16:05:06.487]     }
[16:05:06.487]     else {
[16:05:06.487]         if (TRUE) {
[16:05:06.487]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.487]                 open = "w")
[16:05:06.487]         }
[16:05:06.487]         else {
[16:05:06.487]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.487]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.487]         }
[16:05:06.487]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.487]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.487]             base::sink(type = "output", split = FALSE)
[16:05:06.487]             base::close(...future.stdout)
[16:05:06.487]         }, add = TRUE)
[16:05:06.487]     }
[16:05:06.487]     ...future.frame <- base::sys.nframe()
[16:05:06.487]     ...future.conditions <- base::list()
[16:05:06.487]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.487]     if (FALSE) {
[16:05:06.487]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.487]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.487]     }
[16:05:06.487]     ...future.result <- base::tryCatch({
[16:05:06.487]         base::withCallingHandlers({
[16:05:06.487]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:05:06.487]                 1))
[16:05:06.487]             future::FutureResult(value = ...future.value$value, 
[16:05:06.487]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.487]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.487]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.487]                     ...future.globalenv.names))
[16:05:06.487]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.487]         }, condition = base::local({
[16:05:06.487]             c <- base::c
[16:05:06.487]             inherits <- base::inherits
[16:05:06.487]             invokeRestart <- base::invokeRestart
[16:05:06.487]             length <- base::length
[16:05:06.487]             list <- base::list
[16:05:06.487]             seq.int <- base::seq.int
[16:05:06.487]             signalCondition <- base::signalCondition
[16:05:06.487]             sys.calls <- base::sys.calls
[16:05:06.487]             `[[` <- base::`[[`
[16:05:06.487]             `+` <- base::`+`
[16:05:06.487]             `<<-` <- base::`<<-`
[16:05:06.487]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.487]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.487]                   3L)]
[16:05:06.487]             }
[16:05:06.487]             function(cond) {
[16:05:06.487]                 is_error <- inherits(cond, "error")
[16:05:06.487]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.487]                   NULL)
[16:05:06.487]                 if (is_error) {
[16:05:06.487]                   sessionInformation <- function() {
[16:05:06.487]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.487]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.487]                       search = base::search(), system = base::Sys.info())
[16:05:06.487]                   }
[16:05:06.487]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.487]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.487]                     cond$call), session = sessionInformation(), 
[16:05:06.487]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.487]                   signalCondition(cond)
[16:05:06.487]                 }
[16:05:06.487]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.487]                 "immediateCondition"))) {
[16:05:06.487]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.487]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.487]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.487]                   if (TRUE && !signal) {
[16:05:06.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.487]                     {
[16:05:06.487]                       inherits <- base::inherits
[16:05:06.487]                       invokeRestart <- base::invokeRestart
[16:05:06.487]                       is.null <- base::is.null
[16:05:06.487]                       muffled <- FALSE
[16:05:06.487]                       if (inherits(cond, "message")) {
[16:05:06.487]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.487]                         if (muffled) 
[16:05:06.487]                           invokeRestart("muffleMessage")
[16:05:06.487]                       }
[16:05:06.487]                       else if (inherits(cond, "warning")) {
[16:05:06.487]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.487]                         if (muffled) 
[16:05:06.487]                           invokeRestart("muffleWarning")
[16:05:06.487]                       }
[16:05:06.487]                       else if (inherits(cond, "condition")) {
[16:05:06.487]                         if (!is.null(pattern)) {
[16:05:06.487]                           computeRestarts <- base::computeRestarts
[16:05:06.487]                           grepl <- base::grepl
[16:05:06.487]                           restarts <- computeRestarts(cond)
[16:05:06.487]                           for (restart in restarts) {
[16:05:06.487]                             name <- restart$name
[16:05:06.487]                             if (is.null(name)) 
[16:05:06.487]                               next
[16:05:06.487]                             if (!grepl(pattern, name)) 
[16:05:06.487]                               next
[16:05:06.487]                             invokeRestart(restart)
[16:05:06.487]                             muffled <- TRUE
[16:05:06.487]                             break
[16:05:06.487]                           }
[16:05:06.487]                         }
[16:05:06.487]                       }
[16:05:06.487]                       invisible(muffled)
[16:05:06.487]                     }
[16:05:06.487]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.487]                   }
[16:05:06.487]                 }
[16:05:06.487]                 else {
[16:05:06.487]                   if (TRUE) {
[16:05:06.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.487]                     {
[16:05:06.487]                       inherits <- base::inherits
[16:05:06.487]                       invokeRestart <- base::invokeRestart
[16:05:06.487]                       is.null <- base::is.null
[16:05:06.487]                       muffled <- FALSE
[16:05:06.487]                       if (inherits(cond, "message")) {
[16:05:06.487]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.487]                         if (muffled) 
[16:05:06.487]                           invokeRestart("muffleMessage")
[16:05:06.487]                       }
[16:05:06.487]                       else if (inherits(cond, "warning")) {
[16:05:06.487]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.487]                         if (muffled) 
[16:05:06.487]                           invokeRestart("muffleWarning")
[16:05:06.487]                       }
[16:05:06.487]                       else if (inherits(cond, "condition")) {
[16:05:06.487]                         if (!is.null(pattern)) {
[16:05:06.487]                           computeRestarts <- base::computeRestarts
[16:05:06.487]                           grepl <- base::grepl
[16:05:06.487]                           restarts <- computeRestarts(cond)
[16:05:06.487]                           for (restart in restarts) {
[16:05:06.487]                             name <- restart$name
[16:05:06.487]                             if (is.null(name)) 
[16:05:06.487]                               next
[16:05:06.487]                             if (!grepl(pattern, name)) 
[16:05:06.487]                               next
[16:05:06.487]                             invokeRestart(restart)
[16:05:06.487]                             muffled <- TRUE
[16:05:06.487]                             break
[16:05:06.487]                           }
[16:05:06.487]                         }
[16:05:06.487]                       }
[16:05:06.487]                       invisible(muffled)
[16:05:06.487]                     }
[16:05:06.487]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.487]                   }
[16:05:06.487]                 }
[16:05:06.487]             }
[16:05:06.487]         }))
[16:05:06.487]     }, error = function(ex) {
[16:05:06.487]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.487]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.487]                 ...future.rng), started = ...future.startTime, 
[16:05:06.487]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.487]             version = "1.8"), class = "FutureResult")
[16:05:06.487]     }, finally = {
[16:05:06.487]         if (!identical(...future.workdir, getwd())) 
[16:05:06.487]             setwd(...future.workdir)
[16:05:06.487]         {
[16:05:06.487]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.487]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.487]             }
[16:05:06.487]             base::options(...future.oldOptions)
[16:05:06.487]             if (.Platform$OS.type == "windows") {
[16:05:06.487]                 old_names <- names(...future.oldEnvVars)
[16:05:06.487]                 envs <- base::Sys.getenv()
[16:05:06.487]                 names <- names(envs)
[16:05:06.487]                 common <- intersect(names, old_names)
[16:05:06.487]                 added <- setdiff(names, old_names)
[16:05:06.487]                 removed <- setdiff(old_names, names)
[16:05:06.487]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.487]                   envs[common]]
[16:05:06.487]                 NAMES <- toupper(changed)
[16:05:06.487]                 args <- list()
[16:05:06.487]                 for (kk in seq_along(NAMES)) {
[16:05:06.487]                   name <- changed[[kk]]
[16:05:06.487]                   NAME <- NAMES[[kk]]
[16:05:06.487]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.487]                     next
[16:05:06.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.487]                 }
[16:05:06.487]                 NAMES <- toupper(added)
[16:05:06.487]                 for (kk in seq_along(NAMES)) {
[16:05:06.487]                   name <- added[[kk]]
[16:05:06.487]                   NAME <- NAMES[[kk]]
[16:05:06.487]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.487]                     next
[16:05:06.487]                   args[[name]] <- ""
[16:05:06.487]                 }
[16:05:06.487]                 NAMES <- toupper(removed)
[16:05:06.487]                 for (kk in seq_along(NAMES)) {
[16:05:06.487]                   name <- removed[[kk]]
[16:05:06.487]                   NAME <- NAMES[[kk]]
[16:05:06.487]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.487]                     next
[16:05:06.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.487]                 }
[16:05:06.487]                 if (length(args) > 0) 
[16:05:06.487]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.487]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.487]             }
[16:05:06.487]             else {
[16:05:06.487]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.487]             }
[16:05:06.487]             {
[16:05:06.487]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.487]                   0L) {
[16:05:06.487]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.487]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.487]                   base::options(opts)
[16:05:06.487]                 }
[16:05:06.487]                 {
[16:05:06.487]                   {
[16:05:06.487]                     NULL
[16:05:06.487]                     RNGkind("Mersenne-Twister")
[16:05:06.487]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.487]                       inherits = FALSE)
[16:05:06.487]                   }
[16:05:06.487]                   options(future.plan = NULL)
[16:05:06.487]                   if (is.na(NA_character_)) 
[16:05:06.487]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.487]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.487]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.487]                   {
[16:05:06.487]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.487]                     if (!future$lazy) 
[16:05:06.487]                       future <- run(future)
[16:05:06.487]                     invisible(future)
[16:05:06.487]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.487]                 }
[16:05:06.487]             }
[16:05:06.487]         }
[16:05:06.487]     })
[16:05:06.487]     if (TRUE) {
[16:05:06.487]         base::sink(type = "output", split = FALSE)
[16:05:06.487]         if (TRUE) {
[16:05:06.487]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.487]         }
[16:05:06.487]         else {
[16:05:06.487]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.487]         }
[16:05:06.487]         base::close(...future.stdout)
[16:05:06.487]         ...future.stdout <- NULL
[16:05:06.487]     }
[16:05:06.487]     ...future.result$conditions <- ...future.conditions
[16:05:06.487]     ...future.result$finished <- base::Sys.time()
[16:05:06.487]     ...future.result
[16:05:06.487] }
[16:05:06.489] assign_globals() ...
[16:05:06.489] List of 1
[16:05:06.489]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a054e28470> 
[16:05:06.489]  - attr(*, "where")=List of 1
[16:05:06.489]   ..$ a:<environment: R_EmptyEnv> 
[16:05:06.489]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.489]  - attr(*, "resolved")= logi TRUE
[16:05:06.489]  - attr(*, "total_size")= num 10592
[16:05:06.489]  - attr(*, "already-done")= logi TRUE
[16:05:06.492] - copied ‘a’ to environment
[16:05:06.492] assign_globals() ... done
[16:05:06.492] plan(): Setting new future strategy stack:
[16:05:06.492] List of future strategies:
[16:05:06.492] 1. sequential:
[16:05:06.492]    - args: function (..., envir = parent.frame())
[16:05:06.492]    - tweaked: FALSE
[16:05:06.492]    - call: NULL
[16:05:06.493] plan(): nbrOfWorkers() = 1
[16:05:06.494] plan(): Setting new future strategy stack:
[16:05:06.494] List of future strategies:
[16:05:06.494] 1. sequential:
[16:05:06.494]    - args: function (..., envir = parent.frame())
[16:05:06.494]    - tweaked: FALSE
[16:05:06.494]    - call: plan(strategy)
[16:05:06.494] plan(): nbrOfWorkers() = 1
[16:05:06.494] SequentialFuture started (and completed)
[16:05:06.494] - Launch lazy future ... done
[16:05:06.494] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.495] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.495] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:06.496] 
[16:05:06.496] Searching for globals ... DONE
[16:05:06.496] - globals: [0] <none>
[16:05:06.496] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.498] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.498] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:06.499] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:06.499] Searching for globals ... DONE
[16:05:06.500] Resolving globals: TRUE
[16:05:06.500] Resolving any globals that are futures ...
[16:05:06.500] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:06.500] Resolving any globals that are futures ... DONE
[16:05:06.500] Resolving futures part of globals (recursively) ...
[16:05:06.500] resolve() on list ...
[16:05:06.500]  recursive: 99
[16:05:06.501]  length: 1
[16:05:06.501]  elements: ‘a’
[16:05:06.501] run() for ‘Future’ ...
[16:05:06.501] - state: ‘created’
[16:05:06.501] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.501] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.501] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.502]   - Field: ‘label’
[16:05:06.502]   - Field: ‘local’
[16:05:06.502]   - Field: ‘owner’
[16:05:06.502]   - Field: ‘envir’
[16:05:06.502]   - Field: ‘packages’
[16:05:06.502]   - Field: ‘gc’
[16:05:06.502]   - Field: ‘conditions’
[16:05:06.502]   - Field: ‘expr’
[16:05:06.502]   - Field: ‘uuid’
[16:05:06.502]   - Field: ‘seed’
[16:05:06.502]   - Field: ‘version’
[16:05:06.503]   - Field: ‘result’
[16:05:06.503]   - Field: ‘asynchronous’
[16:05:06.503]   - Field: ‘calls’
[16:05:06.503]   - Field: ‘globals’
[16:05:06.503]   - Field: ‘stdout’
[16:05:06.503]   - Field: ‘earlySignal’
[16:05:06.503]   - Field: ‘lazy’
[16:05:06.503]   - Field: ‘state’
[16:05:06.503] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.503] - Launch lazy future ...
[16:05:06.504] Packages needed by the future expression (n = 0): <none>
[16:05:06.504] Packages needed by future strategies (n = 0): <none>
[16:05:06.504] {
[16:05:06.504]     {
[16:05:06.504]         {
[16:05:06.504]             ...future.startTime <- base::Sys.time()
[16:05:06.504]             {
[16:05:06.504]                 {
[16:05:06.504]                   {
[16:05:06.504]                     base::local({
[16:05:06.504]                       has_future <- base::requireNamespace("future", 
[16:05:06.504]                         quietly = TRUE)
[16:05:06.504]                       if (has_future) {
[16:05:06.504]                         ns <- base::getNamespace("future")
[16:05:06.504]                         version <- ns[[".package"]][["version"]]
[16:05:06.504]                         if (is.null(version)) 
[16:05:06.504]                           version <- utils::packageVersion("future")
[16:05:06.504]                       }
[16:05:06.504]                       else {
[16:05:06.504]                         version <- NULL
[16:05:06.504]                       }
[16:05:06.504]                       if (!has_future || version < "1.8.0") {
[16:05:06.504]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.504]                           "", base::R.version$version.string), 
[16:05:06.504]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.504]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.504]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.504]                             "release", "version")], collapse = " "), 
[16:05:06.504]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.504]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.504]                           info)
[16:05:06.504]                         info <- base::paste(info, collapse = "; ")
[16:05:06.504]                         if (!has_future) {
[16:05:06.504]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.504]                             info)
[16:05:06.504]                         }
[16:05:06.504]                         else {
[16:05:06.504]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.504]                             info, version)
[16:05:06.504]                         }
[16:05:06.504]                         base::stop(msg)
[16:05:06.504]                       }
[16:05:06.504]                     })
[16:05:06.504]                   }
[16:05:06.504]                   options(future.plan = NULL)
[16:05:06.504]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.504]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.504]                 }
[16:05:06.504]                 ...future.workdir <- getwd()
[16:05:06.504]             }
[16:05:06.504]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.504]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.504]         }
[16:05:06.504]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.504]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:06.504]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.504]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.504]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.504]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.504]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.504]             base::names(...future.oldOptions))
[16:05:06.504]     }
[16:05:06.504]     if (FALSE) {
[16:05:06.504]     }
[16:05:06.504]     else {
[16:05:06.504]         if (TRUE) {
[16:05:06.504]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.504]                 open = "w")
[16:05:06.504]         }
[16:05:06.504]         else {
[16:05:06.504]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.504]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.504]         }
[16:05:06.504]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.504]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.504]             base::sink(type = "output", split = FALSE)
[16:05:06.504]             base::close(...future.stdout)
[16:05:06.504]         }, add = TRUE)
[16:05:06.504]     }
[16:05:06.504]     ...future.frame <- base::sys.nframe()
[16:05:06.504]     ...future.conditions <- base::list()
[16:05:06.504]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.504]     if (FALSE) {
[16:05:06.504]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.504]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.504]     }
[16:05:06.504]     ...future.result <- base::tryCatch({
[16:05:06.504]         base::withCallingHandlers({
[16:05:06.504]             ...future.value <- base::withVisible(base::local(1))
[16:05:06.504]             future::FutureResult(value = ...future.value$value, 
[16:05:06.504]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.504]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.504]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.504]                     ...future.globalenv.names))
[16:05:06.504]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.504]         }, condition = base::local({
[16:05:06.504]             c <- base::c
[16:05:06.504]             inherits <- base::inherits
[16:05:06.504]             invokeRestart <- base::invokeRestart
[16:05:06.504]             length <- base::length
[16:05:06.504]             list <- base::list
[16:05:06.504]             seq.int <- base::seq.int
[16:05:06.504]             signalCondition <- base::signalCondition
[16:05:06.504]             sys.calls <- base::sys.calls
[16:05:06.504]             `[[` <- base::`[[`
[16:05:06.504]             `+` <- base::`+`
[16:05:06.504]             `<<-` <- base::`<<-`
[16:05:06.504]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.504]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.504]                   3L)]
[16:05:06.504]             }
[16:05:06.504]             function(cond) {
[16:05:06.504]                 is_error <- inherits(cond, "error")
[16:05:06.504]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.504]                   NULL)
[16:05:06.504]                 if (is_error) {
[16:05:06.504]                   sessionInformation <- function() {
[16:05:06.504]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.504]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.504]                       search = base::search(), system = base::Sys.info())
[16:05:06.504]                   }
[16:05:06.504]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.504]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.504]                     cond$call), session = sessionInformation(), 
[16:05:06.504]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.504]                   signalCondition(cond)
[16:05:06.504]                 }
[16:05:06.504]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.504]                 "immediateCondition"))) {
[16:05:06.504]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.504]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.504]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.504]                   if (TRUE && !signal) {
[16:05:06.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.504]                     {
[16:05:06.504]                       inherits <- base::inherits
[16:05:06.504]                       invokeRestart <- base::invokeRestart
[16:05:06.504]                       is.null <- base::is.null
[16:05:06.504]                       muffled <- FALSE
[16:05:06.504]                       if (inherits(cond, "message")) {
[16:05:06.504]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.504]                         if (muffled) 
[16:05:06.504]                           invokeRestart("muffleMessage")
[16:05:06.504]                       }
[16:05:06.504]                       else if (inherits(cond, "warning")) {
[16:05:06.504]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.504]                         if (muffled) 
[16:05:06.504]                           invokeRestart("muffleWarning")
[16:05:06.504]                       }
[16:05:06.504]                       else if (inherits(cond, "condition")) {
[16:05:06.504]                         if (!is.null(pattern)) {
[16:05:06.504]                           computeRestarts <- base::computeRestarts
[16:05:06.504]                           grepl <- base::grepl
[16:05:06.504]                           restarts <- computeRestarts(cond)
[16:05:06.504]                           for (restart in restarts) {
[16:05:06.504]                             name <- restart$name
[16:05:06.504]                             if (is.null(name)) 
[16:05:06.504]                               next
[16:05:06.504]                             if (!grepl(pattern, name)) 
[16:05:06.504]                               next
[16:05:06.504]                             invokeRestart(restart)
[16:05:06.504]                             muffled <- TRUE
[16:05:06.504]                             break
[16:05:06.504]                           }
[16:05:06.504]                         }
[16:05:06.504]                       }
[16:05:06.504]                       invisible(muffled)
[16:05:06.504]                     }
[16:05:06.504]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.504]                   }
[16:05:06.504]                 }
[16:05:06.504]                 else {
[16:05:06.504]                   if (TRUE) {
[16:05:06.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.504]                     {
[16:05:06.504]                       inherits <- base::inherits
[16:05:06.504]                       invokeRestart <- base::invokeRestart
[16:05:06.504]                       is.null <- base::is.null
[16:05:06.504]                       muffled <- FALSE
[16:05:06.504]                       if (inherits(cond, "message")) {
[16:05:06.504]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.504]                         if (muffled) 
[16:05:06.504]                           invokeRestart("muffleMessage")
[16:05:06.504]                       }
[16:05:06.504]                       else if (inherits(cond, "warning")) {
[16:05:06.504]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.504]                         if (muffled) 
[16:05:06.504]                           invokeRestart("muffleWarning")
[16:05:06.504]                       }
[16:05:06.504]                       else if (inherits(cond, "condition")) {
[16:05:06.504]                         if (!is.null(pattern)) {
[16:05:06.504]                           computeRestarts <- base::computeRestarts
[16:05:06.504]                           grepl <- base::grepl
[16:05:06.504]                           restarts <- computeRestarts(cond)
[16:05:06.504]                           for (restart in restarts) {
[16:05:06.504]                             name <- restart$name
[16:05:06.504]                             if (is.null(name)) 
[16:05:06.504]                               next
[16:05:06.504]                             if (!grepl(pattern, name)) 
[16:05:06.504]                               next
[16:05:06.504]                             invokeRestart(restart)
[16:05:06.504]                             muffled <- TRUE
[16:05:06.504]                             break
[16:05:06.504]                           }
[16:05:06.504]                         }
[16:05:06.504]                       }
[16:05:06.504]                       invisible(muffled)
[16:05:06.504]                     }
[16:05:06.504]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.504]                   }
[16:05:06.504]                 }
[16:05:06.504]             }
[16:05:06.504]         }))
[16:05:06.504]     }, error = function(ex) {
[16:05:06.504]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.504]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.504]                 ...future.rng), started = ...future.startTime, 
[16:05:06.504]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.504]             version = "1.8"), class = "FutureResult")
[16:05:06.504]     }, finally = {
[16:05:06.504]         if (!identical(...future.workdir, getwd())) 
[16:05:06.504]             setwd(...future.workdir)
[16:05:06.504]         {
[16:05:06.504]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.504]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.504]             }
[16:05:06.504]             base::options(...future.oldOptions)
[16:05:06.504]             if (.Platform$OS.type == "windows") {
[16:05:06.504]                 old_names <- names(...future.oldEnvVars)
[16:05:06.504]                 envs <- base::Sys.getenv()
[16:05:06.504]                 names <- names(envs)
[16:05:06.504]                 common <- intersect(names, old_names)
[16:05:06.504]                 added <- setdiff(names, old_names)
[16:05:06.504]                 removed <- setdiff(old_names, names)
[16:05:06.504]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.504]                   envs[common]]
[16:05:06.504]                 NAMES <- toupper(changed)
[16:05:06.504]                 args <- list()
[16:05:06.504]                 for (kk in seq_along(NAMES)) {
[16:05:06.504]                   name <- changed[[kk]]
[16:05:06.504]                   NAME <- NAMES[[kk]]
[16:05:06.504]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.504]                     next
[16:05:06.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.504]                 }
[16:05:06.504]                 NAMES <- toupper(added)
[16:05:06.504]                 for (kk in seq_along(NAMES)) {
[16:05:06.504]                   name <- added[[kk]]
[16:05:06.504]                   NAME <- NAMES[[kk]]
[16:05:06.504]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.504]                     next
[16:05:06.504]                   args[[name]] <- ""
[16:05:06.504]                 }
[16:05:06.504]                 NAMES <- toupper(removed)
[16:05:06.504]                 for (kk in seq_along(NAMES)) {
[16:05:06.504]                   name <- removed[[kk]]
[16:05:06.504]                   NAME <- NAMES[[kk]]
[16:05:06.504]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.504]                     next
[16:05:06.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.504]                 }
[16:05:06.504]                 if (length(args) > 0) 
[16:05:06.504]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.504]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.504]             }
[16:05:06.504]             else {
[16:05:06.504]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.504]             }
[16:05:06.504]             {
[16:05:06.504]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.504]                   0L) {
[16:05:06.504]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.504]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.504]                   base::options(opts)
[16:05:06.504]                 }
[16:05:06.504]                 {
[16:05:06.504]                   {
[16:05:06.504]                     NULL
[16:05:06.504]                     RNGkind("Mersenne-Twister")
[16:05:06.504]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.504]                       inherits = FALSE)
[16:05:06.504]                   }
[16:05:06.504]                   options(future.plan = NULL)
[16:05:06.504]                   if (is.na(NA_character_)) 
[16:05:06.504]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.504]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.504]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.504]                   {
[16:05:06.504]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.504]                     if (!future$lazy) 
[16:05:06.504]                       future <- run(future)
[16:05:06.504]                     invisible(future)
[16:05:06.504]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.504]                 }
[16:05:06.504]             }
[16:05:06.504]         }
[16:05:06.504]     })
[16:05:06.504]     if (TRUE) {
[16:05:06.504]         base::sink(type = "output", split = FALSE)
[16:05:06.504]         if (TRUE) {
[16:05:06.504]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.504]         }
[16:05:06.504]         else {
[16:05:06.504]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.504]         }
[16:05:06.504]         base::close(...future.stdout)
[16:05:06.504]         ...future.stdout <- NULL
[16:05:06.504]     }
[16:05:06.504]     ...future.result$conditions <- ...future.conditions
[16:05:06.504]     ...future.result$finished <- base::Sys.time()
[16:05:06.504]     ...future.result
[16:05:06.504] }
[16:05:06.506] plan(): Setting new future strategy stack:
[16:05:06.506] List of future strategies:
[16:05:06.506] 1. sequential:
[16:05:06.506]    - args: function (..., envir = parent.frame())
[16:05:06.506]    - tweaked: FALSE
[16:05:06.506]    - call: NULL
[16:05:06.506] plan(): nbrOfWorkers() = 1
[16:05:06.507] plan(): Setting new future strategy stack:
[16:05:06.507] List of future strategies:
[16:05:06.507] 1. sequential:
[16:05:06.507]    - args: function (..., envir = parent.frame())
[16:05:06.507]    - tweaked: FALSE
[16:05:06.507]    - call: plan(strategy)
[16:05:06.508] plan(): nbrOfWorkers() = 1
[16:05:06.508] SequentialFuture started (and completed)
[16:05:06.508] - Launch lazy future ... done
[16:05:06.508] run() for ‘SequentialFuture’ ... done
[16:05:06.508] resolved() for ‘SequentialFuture’ ...
[16:05:06.508] - state: ‘finished’
[16:05:06.508] - run: TRUE
[16:05:06.508] - result: ‘FutureResult’
[16:05:06.508] resolved() for ‘SequentialFuture’ ... done
[16:05:06.509] Future #1
[16:05:06.509] resolved() for ‘SequentialFuture’ ...
[16:05:06.509] - state: ‘finished’
[16:05:06.509] - run: TRUE
[16:05:06.509] - result: ‘FutureResult’
[16:05:06.509] resolved() for ‘SequentialFuture’ ... done
[16:05:06.509] A SequentialFuture was resolved
[16:05:06.509]  length: 0 (resolved future 1)
[16:05:06.509] resolve() on list ... DONE
[16:05:06.509] - globals: [1] ‘a’
[16:05:06.510] Resolving futures part of globals (recursively) ... DONE
[16:05:06.510] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[16:05:06.511] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[16:05:06.511] - globals: [1] ‘a’
[16:05:06.511] - packages: [1] ‘future’
[16:05:06.511] getGlobalsAndPackages() ... DONE
[16:05:06.511] run() for ‘Future’ ...
[16:05:06.511] - state: ‘created’
[16:05:06.512] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.512] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.512] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.512]   - Field: ‘label’
[16:05:06.512]   - Field: ‘local’
[16:05:06.512]   - Field: ‘owner’
[16:05:06.512]   - Field: ‘envir’
[16:05:06.512]   - Field: ‘packages’
[16:05:06.513]   - Field: ‘gc’
[16:05:06.513]   - Field: ‘conditions’
[16:05:06.513]   - Field: ‘expr’
[16:05:06.513]   - Field: ‘uuid’
[16:05:06.513]   - Field: ‘seed’
[16:05:06.513]   - Field: ‘version’
[16:05:06.513]   - Field: ‘result’
[16:05:06.513]   - Field: ‘asynchronous’
[16:05:06.513]   - Field: ‘calls’
[16:05:06.513]   - Field: ‘globals’
[16:05:06.513]   - Field: ‘stdout’
[16:05:06.514]   - Field: ‘earlySignal’
[16:05:06.514]   - Field: ‘lazy’
[16:05:06.514]   - Field: ‘state’
[16:05:06.514] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.514] - Launch lazy future ...
[16:05:06.514] Packages needed by the future expression (n = 1): ‘future’
[16:05:06.514] Packages needed by future strategies (n = 0): <none>
[16:05:06.515] {
[16:05:06.515]     {
[16:05:06.515]         {
[16:05:06.515]             ...future.startTime <- base::Sys.time()
[16:05:06.515]             {
[16:05:06.515]                 {
[16:05:06.515]                   {
[16:05:06.515]                     {
[16:05:06.515]                       base::local({
[16:05:06.515]                         has_future <- base::requireNamespace("future", 
[16:05:06.515]                           quietly = TRUE)
[16:05:06.515]                         if (has_future) {
[16:05:06.515]                           ns <- base::getNamespace("future")
[16:05:06.515]                           version <- ns[[".package"]][["version"]]
[16:05:06.515]                           if (is.null(version)) 
[16:05:06.515]                             version <- utils::packageVersion("future")
[16:05:06.515]                         }
[16:05:06.515]                         else {
[16:05:06.515]                           version <- NULL
[16:05:06.515]                         }
[16:05:06.515]                         if (!has_future || version < "1.8.0") {
[16:05:06.515]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.515]                             "", base::R.version$version.string), 
[16:05:06.515]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:06.515]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.515]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.515]                               "release", "version")], collapse = " "), 
[16:05:06.515]                             hostname = base::Sys.info()[["nodename"]])
[16:05:06.515]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.515]                             info)
[16:05:06.515]                           info <- base::paste(info, collapse = "; ")
[16:05:06.515]                           if (!has_future) {
[16:05:06.515]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.515]                               info)
[16:05:06.515]                           }
[16:05:06.515]                           else {
[16:05:06.515]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.515]                               info, version)
[16:05:06.515]                           }
[16:05:06.515]                           base::stop(msg)
[16:05:06.515]                         }
[16:05:06.515]                       })
[16:05:06.515]                     }
[16:05:06.515]                     base::local({
[16:05:06.515]                       for (pkg in "future") {
[16:05:06.515]                         base::loadNamespace(pkg)
[16:05:06.515]                         base::library(pkg, character.only = TRUE)
[16:05:06.515]                       }
[16:05:06.515]                     })
[16:05:06.515]                   }
[16:05:06.515]                   options(future.plan = NULL)
[16:05:06.515]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.515]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.515]                 }
[16:05:06.515]                 ...future.workdir <- getwd()
[16:05:06.515]             }
[16:05:06.515]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.515]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.515]         }
[16:05:06.515]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.515]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:06.515]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.515]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.515]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.515]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.515]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.515]             base::names(...future.oldOptions))
[16:05:06.515]     }
[16:05:06.515]     if (FALSE) {
[16:05:06.515]     }
[16:05:06.515]     else {
[16:05:06.515]         if (TRUE) {
[16:05:06.515]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.515]                 open = "w")
[16:05:06.515]         }
[16:05:06.515]         else {
[16:05:06.515]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.515]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.515]         }
[16:05:06.515]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.515]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.515]             base::sink(type = "output", split = FALSE)
[16:05:06.515]             base::close(...future.stdout)
[16:05:06.515]         }, add = TRUE)
[16:05:06.515]     }
[16:05:06.515]     ...future.frame <- base::sys.nframe()
[16:05:06.515]     ...future.conditions <- base::list()
[16:05:06.515]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.515]     if (FALSE) {
[16:05:06.515]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.515]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.515]     }
[16:05:06.515]     ...future.result <- base::tryCatch({
[16:05:06.515]         base::withCallingHandlers({
[16:05:06.515]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:05:06.515]                 1))
[16:05:06.515]             future::FutureResult(value = ...future.value$value, 
[16:05:06.515]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.515]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.515]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.515]                     ...future.globalenv.names))
[16:05:06.515]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.515]         }, condition = base::local({
[16:05:06.515]             c <- base::c
[16:05:06.515]             inherits <- base::inherits
[16:05:06.515]             invokeRestart <- base::invokeRestart
[16:05:06.515]             length <- base::length
[16:05:06.515]             list <- base::list
[16:05:06.515]             seq.int <- base::seq.int
[16:05:06.515]             signalCondition <- base::signalCondition
[16:05:06.515]             sys.calls <- base::sys.calls
[16:05:06.515]             `[[` <- base::`[[`
[16:05:06.515]             `+` <- base::`+`
[16:05:06.515]             `<<-` <- base::`<<-`
[16:05:06.515]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.515]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.515]                   3L)]
[16:05:06.515]             }
[16:05:06.515]             function(cond) {
[16:05:06.515]                 is_error <- inherits(cond, "error")
[16:05:06.515]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.515]                   NULL)
[16:05:06.515]                 if (is_error) {
[16:05:06.515]                   sessionInformation <- function() {
[16:05:06.515]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.515]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.515]                       search = base::search(), system = base::Sys.info())
[16:05:06.515]                   }
[16:05:06.515]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.515]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.515]                     cond$call), session = sessionInformation(), 
[16:05:06.515]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.515]                   signalCondition(cond)
[16:05:06.515]                 }
[16:05:06.515]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.515]                 "immediateCondition"))) {
[16:05:06.515]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.515]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.515]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.515]                   if (TRUE && !signal) {
[16:05:06.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.515]                     {
[16:05:06.515]                       inherits <- base::inherits
[16:05:06.515]                       invokeRestart <- base::invokeRestart
[16:05:06.515]                       is.null <- base::is.null
[16:05:06.515]                       muffled <- FALSE
[16:05:06.515]                       if (inherits(cond, "message")) {
[16:05:06.515]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.515]                         if (muffled) 
[16:05:06.515]                           invokeRestart("muffleMessage")
[16:05:06.515]                       }
[16:05:06.515]                       else if (inherits(cond, "warning")) {
[16:05:06.515]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.515]                         if (muffled) 
[16:05:06.515]                           invokeRestart("muffleWarning")
[16:05:06.515]                       }
[16:05:06.515]                       else if (inherits(cond, "condition")) {
[16:05:06.515]                         if (!is.null(pattern)) {
[16:05:06.515]                           computeRestarts <- base::computeRestarts
[16:05:06.515]                           grepl <- base::grepl
[16:05:06.515]                           restarts <- computeRestarts(cond)
[16:05:06.515]                           for (restart in restarts) {
[16:05:06.515]                             name <- restart$name
[16:05:06.515]                             if (is.null(name)) 
[16:05:06.515]                               next
[16:05:06.515]                             if (!grepl(pattern, name)) 
[16:05:06.515]                               next
[16:05:06.515]                             invokeRestart(restart)
[16:05:06.515]                             muffled <- TRUE
[16:05:06.515]                             break
[16:05:06.515]                           }
[16:05:06.515]                         }
[16:05:06.515]                       }
[16:05:06.515]                       invisible(muffled)
[16:05:06.515]                     }
[16:05:06.515]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.515]                   }
[16:05:06.515]                 }
[16:05:06.515]                 else {
[16:05:06.515]                   if (TRUE) {
[16:05:06.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.515]                     {
[16:05:06.515]                       inherits <- base::inherits
[16:05:06.515]                       invokeRestart <- base::invokeRestart
[16:05:06.515]                       is.null <- base::is.null
[16:05:06.515]                       muffled <- FALSE
[16:05:06.515]                       if (inherits(cond, "message")) {
[16:05:06.515]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.515]                         if (muffled) 
[16:05:06.515]                           invokeRestart("muffleMessage")
[16:05:06.515]                       }
[16:05:06.515]                       else if (inherits(cond, "warning")) {
[16:05:06.515]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.515]                         if (muffled) 
[16:05:06.515]                           invokeRestart("muffleWarning")
[16:05:06.515]                       }
[16:05:06.515]                       else if (inherits(cond, "condition")) {
[16:05:06.515]                         if (!is.null(pattern)) {
[16:05:06.515]                           computeRestarts <- base::computeRestarts
[16:05:06.515]                           grepl <- base::grepl
[16:05:06.515]                           restarts <- computeRestarts(cond)
[16:05:06.515]                           for (restart in restarts) {
[16:05:06.515]                             name <- restart$name
[16:05:06.515]                             if (is.null(name)) 
[16:05:06.515]                               next
[16:05:06.515]                             if (!grepl(pattern, name)) 
[16:05:06.515]                               next
[16:05:06.515]                             invokeRestart(restart)
[16:05:06.515]                             muffled <- TRUE
[16:05:06.515]                             break
[16:05:06.515]                           }
[16:05:06.515]                         }
[16:05:06.515]                       }
[16:05:06.515]                       invisible(muffled)
[16:05:06.515]                     }
[16:05:06.515]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.515]                   }
[16:05:06.515]                 }
[16:05:06.515]             }
[16:05:06.515]         }))
[16:05:06.515]     }, error = function(ex) {
[16:05:06.515]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.515]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.515]                 ...future.rng), started = ...future.startTime, 
[16:05:06.515]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.515]             version = "1.8"), class = "FutureResult")
[16:05:06.515]     }, finally = {
[16:05:06.515]         if (!identical(...future.workdir, getwd())) 
[16:05:06.515]             setwd(...future.workdir)
[16:05:06.515]         {
[16:05:06.515]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.515]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.515]             }
[16:05:06.515]             base::options(...future.oldOptions)
[16:05:06.515]             if (.Platform$OS.type == "windows") {
[16:05:06.515]                 old_names <- names(...future.oldEnvVars)
[16:05:06.515]                 envs <- base::Sys.getenv()
[16:05:06.515]                 names <- names(envs)
[16:05:06.515]                 common <- intersect(names, old_names)
[16:05:06.515]                 added <- setdiff(names, old_names)
[16:05:06.515]                 removed <- setdiff(old_names, names)
[16:05:06.515]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.515]                   envs[common]]
[16:05:06.515]                 NAMES <- toupper(changed)
[16:05:06.515]                 args <- list()
[16:05:06.515]                 for (kk in seq_along(NAMES)) {
[16:05:06.515]                   name <- changed[[kk]]
[16:05:06.515]                   NAME <- NAMES[[kk]]
[16:05:06.515]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.515]                     next
[16:05:06.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.515]                 }
[16:05:06.515]                 NAMES <- toupper(added)
[16:05:06.515]                 for (kk in seq_along(NAMES)) {
[16:05:06.515]                   name <- added[[kk]]
[16:05:06.515]                   NAME <- NAMES[[kk]]
[16:05:06.515]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.515]                     next
[16:05:06.515]                   args[[name]] <- ""
[16:05:06.515]                 }
[16:05:06.515]                 NAMES <- toupper(removed)
[16:05:06.515]                 for (kk in seq_along(NAMES)) {
[16:05:06.515]                   name <- removed[[kk]]
[16:05:06.515]                   NAME <- NAMES[[kk]]
[16:05:06.515]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.515]                     next
[16:05:06.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.515]                 }
[16:05:06.515]                 if (length(args) > 0) 
[16:05:06.515]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.515]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.515]             }
[16:05:06.515]             else {
[16:05:06.515]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.515]             }
[16:05:06.515]             {
[16:05:06.515]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.515]                   0L) {
[16:05:06.515]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.515]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.515]                   base::options(opts)
[16:05:06.515]                 }
[16:05:06.515]                 {
[16:05:06.515]                   {
[16:05:06.515]                     NULL
[16:05:06.515]                     RNGkind("Mersenne-Twister")
[16:05:06.515]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.515]                       inherits = FALSE)
[16:05:06.515]                   }
[16:05:06.515]                   options(future.plan = NULL)
[16:05:06.515]                   if (is.na(NA_character_)) 
[16:05:06.515]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.515]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.515]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.515]                   {
[16:05:06.515]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.515]                     if (!future$lazy) 
[16:05:06.515]                       future <- run(future)
[16:05:06.515]                     invisible(future)
[16:05:06.515]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.515]                 }
[16:05:06.515]             }
[16:05:06.515]         }
[16:05:06.515]     })
[16:05:06.515]     if (TRUE) {
[16:05:06.515]         base::sink(type = "output", split = FALSE)
[16:05:06.515]         if (TRUE) {
[16:05:06.515]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.515]         }
[16:05:06.515]         else {
[16:05:06.515]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.515]         }
[16:05:06.515]         base::close(...future.stdout)
[16:05:06.515]         ...future.stdout <- NULL
[16:05:06.515]     }
[16:05:06.515]     ...future.result$conditions <- ...future.conditions
[16:05:06.515]     ...future.result$finished <- base::Sys.time()
[16:05:06.515]     ...future.result
[16:05:06.515] }
[16:05:06.516] assign_globals() ...
[16:05:06.516] List of 1
[16:05:06.516]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a055b19220> 
[16:05:06.516]  - attr(*, "where")=List of 1
[16:05:06.516]   ..$ a:<environment: R_EmptyEnv> 
[16:05:06.516]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.516]  - attr(*, "resolved")= logi TRUE
[16:05:06.516]  - attr(*, "total_size")= num 10592
[16:05:06.516]  - attr(*, "already-done")= logi TRUE
[16:05:06.519] - copied ‘a’ to environment
[16:05:06.519] assign_globals() ... done
[16:05:06.519] plan(): Setting new future strategy stack:
[16:05:06.519] List of future strategies:
[16:05:06.519] 1. sequential:
[16:05:06.519]    - args: function (..., envir = parent.frame())
[16:05:06.519]    - tweaked: FALSE
[16:05:06.519]    - call: NULL
[16:05:06.520] plan(): nbrOfWorkers() = 1
[16:05:06.521] plan(): Setting new future strategy stack:
[16:05:06.521] List of future strategies:
[16:05:06.521] 1. sequential:
[16:05:06.521]    - args: function (..., envir = parent.frame())
[16:05:06.521]    - tweaked: FALSE
[16:05:06.521]    - call: plan(strategy)
[16:05:06.521] plan(): nbrOfWorkers() = 1
[16:05:06.521] SequentialFuture started (and completed)
[16:05:06.521] - Launch lazy future ... done
[16:05:06.521] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.522] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.522] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:06.523] - globals found: [2] ‘{’, ‘pkg’
[16:05:06.523] Searching for globals ... DONE
[16:05:06.523] Resolving globals: TRUE
[16:05:06.523] Resolving any globals that are futures ...
[16:05:06.523] - globals: [2] ‘{’, ‘pkg’
[16:05:06.523] Resolving any globals that are futures ... DONE
[16:05:06.524] Resolving futures part of globals (recursively) ...
[16:05:06.524] resolve() on list ...
[16:05:06.524]  recursive: 99
[16:05:06.524]  length: 1
[16:05:06.524]  elements: ‘pkg’
[16:05:06.526]  length: 0 (resolved future 1)
[16:05:06.526] resolve() on list ... DONE
[16:05:06.526] - globals: [1] ‘pkg’
[16:05:06.526] Resolving futures part of globals (recursively) ... DONE
[16:05:06.526] The total size of the 1 globals is 112 bytes (112 bytes)
[16:05:06.527] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[16:05:06.527] - globals: [1] ‘pkg’
[16:05:06.527] 
[16:05:06.527] getGlobalsAndPackages() ... DONE
[16:05:06.527] Packages needed by the future expression (n = 0): <none>
[16:05:06.528] Packages needed by future strategies (n = 0): <none>
[16:05:06.528] {
[16:05:06.528]     {
[16:05:06.528]         {
[16:05:06.528]             ...future.startTime <- base::Sys.time()
[16:05:06.528]             {
[16:05:06.528]                 {
[16:05:06.528]                   {
[16:05:06.528]                     base::local({
[16:05:06.528]                       has_future <- base::requireNamespace("future", 
[16:05:06.528]                         quietly = TRUE)
[16:05:06.528]                       if (has_future) {
[16:05:06.528]                         ns <- base::getNamespace("future")
[16:05:06.528]                         version <- ns[[".package"]][["version"]]
[16:05:06.528]                         if (is.null(version)) 
[16:05:06.528]                           version <- utils::packageVersion("future")
[16:05:06.528]                       }
[16:05:06.528]                       else {
[16:05:06.528]                         version <- NULL
[16:05:06.528]                       }
[16:05:06.528]                       if (!has_future || version < "1.8.0") {
[16:05:06.528]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.528]                           "", base::R.version$version.string), 
[16:05:06.528]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.528]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.528]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.528]                             "release", "version")], collapse = " "), 
[16:05:06.528]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.528]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.528]                           info)
[16:05:06.528]                         info <- base::paste(info, collapse = "; ")
[16:05:06.528]                         if (!has_future) {
[16:05:06.528]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.528]                             info)
[16:05:06.528]                         }
[16:05:06.528]                         else {
[16:05:06.528]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.528]                             info, version)
[16:05:06.528]                         }
[16:05:06.528]                         base::stop(msg)
[16:05:06.528]                       }
[16:05:06.528]                     })
[16:05:06.528]                   }
[16:05:06.528]                   options(future.plan = NULL)
[16:05:06.528]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.528]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.528]                 }
[16:05:06.528]                 ...future.workdir <- getwd()
[16:05:06.528]             }
[16:05:06.528]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.528]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.528]         }
[16:05:06.528]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.528]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:06.528]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.528]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.528]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.528]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.528]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.528]             base::names(...future.oldOptions))
[16:05:06.528]     }
[16:05:06.528]     if (FALSE) {
[16:05:06.528]     }
[16:05:06.528]     else {
[16:05:06.528]         if (TRUE) {
[16:05:06.528]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.528]                 open = "w")
[16:05:06.528]         }
[16:05:06.528]         else {
[16:05:06.528]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.528]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.528]         }
[16:05:06.528]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.528]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.528]             base::sink(type = "output", split = FALSE)
[16:05:06.528]             base::close(...future.stdout)
[16:05:06.528]         }, add = TRUE)
[16:05:06.528]     }
[16:05:06.528]     ...future.frame <- base::sys.nframe()
[16:05:06.528]     ...future.conditions <- base::list()
[16:05:06.528]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.528]     if (FALSE) {
[16:05:06.528]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.528]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.528]     }
[16:05:06.528]     ...future.result <- base::tryCatch({
[16:05:06.528]         base::withCallingHandlers({
[16:05:06.528]             ...future.value <- base::withVisible(base::local({
[16:05:06.528]                 pkg
[16:05:06.528]             }))
[16:05:06.528]             future::FutureResult(value = ...future.value$value, 
[16:05:06.528]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.528]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.528]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.528]                     ...future.globalenv.names))
[16:05:06.528]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.528]         }, condition = base::local({
[16:05:06.528]             c <- base::c
[16:05:06.528]             inherits <- base::inherits
[16:05:06.528]             invokeRestart <- base::invokeRestart
[16:05:06.528]             length <- base::length
[16:05:06.528]             list <- base::list
[16:05:06.528]             seq.int <- base::seq.int
[16:05:06.528]             signalCondition <- base::signalCondition
[16:05:06.528]             sys.calls <- base::sys.calls
[16:05:06.528]             `[[` <- base::`[[`
[16:05:06.528]             `+` <- base::`+`
[16:05:06.528]             `<<-` <- base::`<<-`
[16:05:06.528]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.528]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.528]                   3L)]
[16:05:06.528]             }
[16:05:06.528]             function(cond) {
[16:05:06.528]                 is_error <- inherits(cond, "error")
[16:05:06.528]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.528]                   NULL)
[16:05:06.528]                 if (is_error) {
[16:05:06.528]                   sessionInformation <- function() {
[16:05:06.528]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.528]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.528]                       search = base::search(), system = base::Sys.info())
[16:05:06.528]                   }
[16:05:06.528]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.528]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.528]                     cond$call), session = sessionInformation(), 
[16:05:06.528]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.528]                   signalCondition(cond)
[16:05:06.528]                 }
[16:05:06.528]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.528]                 "immediateCondition"))) {
[16:05:06.528]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.528]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.528]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.528]                   if (TRUE && !signal) {
[16:05:06.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.528]                     {
[16:05:06.528]                       inherits <- base::inherits
[16:05:06.528]                       invokeRestart <- base::invokeRestart
[16:05:06.528]                       is.null <- base::is.null
[16:05:06.528]                       muffled <- FALSE
[16:05:06.528]                       if (inherits(cond, "message")) {
[16:05:06.528]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.528]                         if (muffled) 
[16:05:06.528]                           invokeRestart("muffleMessage")
[16:05:06.528]                       }
[16:05:06.528]                       else if (inherits(cond, "warning")) {
[16:05:06.528]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.528]                         if (muffled) 
[16:05:06.528]                           invokeRestart("muffleWarning")
[16:05:06.528]                       }
[16:05:06.528]                       else if (inherits(cond, "condition")) {
[16:05:06.528]                         if (!is.null(pattern)) {
[16:05:06.528]                           computeRestarts <- base::computeRestarts
[16:05:06.528]                           grepl <- base::grepl
[16:05:06.528]                           restarts <- computeRestarts(cond)
[16:05:06.528]                           for (restart in restarts) {
[16:05:06.528]                             name <- restart$name
[16:05:06.528]                             if (is.null(name)) 
[16:05:06.528]                               next
[16:05:06.528]                             if (!grepl(pattern, name)) 
[16:05:06.528]                               next
[16:05:06.528]                             invokeRestart(restart)
[16:05:06.528]                             muffled <- TRUE
[16:05:06.528]                             break
[16:05:06.528]                           }
[16:05:06.528]                         }
[16:05:06.528]                       }
[16:05:06.528]                       invisible(muffled)
[16:05:06.528]                     }
[16:05:06.528]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.528]                   }
[16:05:06.528]                 }
[16:05:06.528]                 else {
[16:05:06.528]                   if (TRUE) {
[16:05:06.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.528]                     {
[16:05:06.528]                       inherits <- base::inherits
[16:05:06.528]                       invokeRestart <- base::invokeRestart
[16:05:06.528]                       is.null <- base::is.null
[16:05:06.528]                       muffled <- FALSE
[16:05:06.528]                       if (inherits(cond, "message")) {
[16:05:06.528]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.528]                         if (muffled) 
[16:05:06.528]                           invokeRestart("muffleMessage")
[16:05:06.528]                       }
[16:05:06.528]                       else if (inherits(cond, "warning")) {
[16:05:06.528]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.528]                         if (muffled) 
[16:05:06.528]                           invokeRestart("muffleWarning")
[16:05:06.528]                       }
[16:05:06.528]                       else if (inherits(cond, "condition")) {
[16:05:06.528]                         if (!is.null(pattern)) {
[16:05:06.528]                           computeRestarts <- base::computeRestarts
[16:05:06.528]                           grepl <- base::grepl
[16:05:06.528]                           restarts <- computeRestarts(cond)
[16:05:06.528]                           for (restart in restarts) {
[16:05:06.528]                             name <- restart$name
[16:05:06.528]                             if (is.null(name)) 
[16:05:06.528]                               next
[16:05:06.528]                             if (!grepl(pattern, name)) 
[16:05:06.528]                               next
[16:05:06.528]                             invokeRestart(restart)
[16:05:06.528]                             muffled <- TRUE
[16:05:06.528]                             break
[16:05:06.528]                           }
[16:05:06.528]                         }
[16:05:06.528]                       }
[16:05:06.528]                       invisible(muffled)
[16:05:06.528]                     }
[16:05:06.528]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.528]                   }
[16:05:06.528]                 }
[16:05:06.528]             }
[16:05:06.528]         }))
[16:05:06.528]     }, error = function(ex) {
[16:05:06.528]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.528]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.528]                 ...future.rng), started = ...future.startTime, 
[16:05:06.528]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.528]             version = "1.8"), class = "FutureResult")
[16:05:06.528]     }, finally = {
[16:05:06.528]         if (!identical(...future.workdir, getwd())) 
[16:05:06.528]             setwd(...future.workdir)
[16:05:06.528]         {
[16:05:06.528]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.528]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.528]             }
[16:05:06.528]             base::options(...future.oldOptions)
[16:05:06.528]             if (.Platform$OS.type == "windows") {
[16:05:06.528]                 old_names <- names(...future.oldEnvVars)
[16:05:06.528]                 envs <- base::Sys.getenv()
[16:05:06.528]                 names <- names(envs)
[16:05:06.528]                 common <- intersect(names, old_names)
[16:05:06.528]                 added <- setdiff(names, old_names)
[16:05:06.528]                 removed <- setdiff(old_names, names)
[16:05:06.528]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.528]                   envs[common]]
[16:05:06.528]                 NAMES <- toupper(changed)
[16:05:06.528]                 args <- list()
[16:05:06.528]                 for (kk in seq_along(NAMES)) {
[16:05:06.528]                   name <- changed[[kk]]
[16:05:06.528]                   NAME <- NAMES[[kk]]
[16:05:06.528]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.528]                     next
[16:05:06.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.528]                 }
[16:05:06.528]                 NAMES <- toupper(added)
[16:05:06.528]                 for (kk in seq_along(NAMES)) {
[16:05:06.528]                   name <- added[[kk]]
[16:05:06.528]                   NAME <- NAMES[[kk]]
[16:05:06.528]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.528]                     next
[16:05:06.528]                   args[[name]] <- ""
[16:05:06.528]                 }
[16:05:06.528]                 NAMES <- toupper(removed)
[16:05:06.528]                 for (kk in seq_along(NAMES)) {
[16:05:06.528]                   name <- removed[[kk]]
[16:05:06.528]                   NAME <- NAMES[[kk]]
[16:05:06.528]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.528]                     next
[16:05:06.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.528]                 }
[16:05:06.528]                 if (length(args) > 0) 
[16:05:06.528]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.528]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.528]             }
[16:05:06.528]             else {
[16:05:06.528]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.528]             }
[16:05:06.528]             {
[16:05:06.528]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.528]                   0L) {
[16:05:06.528]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.528]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.528]                   base::options(opts)
[16:05:06.528]                 }
[16:05:06.528]                 {
[16:05:06.528]                   {
[16:05:06.528]                     NULL
[16:05:06.528]                     RNGkind("Mersenne-Twister")
[16:05:06.528]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.528]                       inherits = FALSE)
[16:05:06.528]                   }
[16:05:06.528]                   options(future.plan = NULL)
[16:05:06.528]                   if (is.na(NA_character_)) 
[16:05:06.528]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.528]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.528]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.528]                   {
[16:05:06.528]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.528]                     if (!future$lazy) 
[16:05:06.528]                       future <- run(future)
[16:05:06.528]                     invisible(future)
[16:05:06.528]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.528]                 }
[16:05:06.528]             }
[16:05:06.528]         }
[16:05:06.528]     })
[16:05:06.528]     if (TRUE) {
[16:05:06.528]         base::sink(type = "output", split = FALSE)
[16:05:06.528]         if (TRUE) {
[16:05:06.528]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.528]         }
[16:05:06.528]         else {
[16:05:06.528]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.528]         }
[16:05:06.528]         base::close(...future.stdout)
[16:05:06.528]         ...future.stdout <- NULL
[16:05:06.528]     }
[16:05:06.528]     ...future.result$conditions <- ...future.conditions
[16:05:06.528]     ...future.result$finished <- base::Sys.time()
[16:05:06.528]     ...future.result
[16:05:06.528] }
[16:05:06.530] assign_globals() ...
[16:05:06.530] List of 1
[16:05:06.530]  $ pkg: chr "foo"
[16:05:06.530]  - attr(*, "where")=List of 1
[16:05:06.530]   ..$ pkg:<environment: R_EmptyEnv> 
[16:05:06.530]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.530]  - attr(*, "resolved")= logi TRUE
[16:05:06.530]  - attr(*, "total_size")= num 112
[16:05:06.532] - copied ‘pkg’ to environment
[16:05:06.532] assign_globals() ... done
[16:05:06.532] plan(): Setting new future strategy stack:
[16:05:06.532] List of future strategies:
[16:05:06.532] 1. sequential:
[16:05:06.532]    - args: function (..., envir = parent.frame())
[16:05:06.532]    - tweaked: FALSE
[16:05:06.532]    - call: NULL
[16:05:06.533] plan(): nbrOfWorkers() = 1
[16:05:06.533] plan(): Setting new future strategy stack:
[16:05:06.533] List of future strategies:
[16:05:06.533] 1. sequential:
[16:05:06.533]    - args: function (..., envir = parent.frame())
[16:05:06.533]    - tweaked: FALSE
[16:05:06.533]    - call: plan(strategy)
[16:05:06.534] plan(): nbrOfWorkers() = 1
[16:05:06.534] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.535] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.535] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:06.537] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:05:06.537] Searching for globals ... DONE
[16:05:06.537] Resolving globals: TRUE
[16:05:06.538] Resolving any globals that are futures ...
[16:05:06.538] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:05:06.538] Resolving any globals that are futures ... DONE
[16:05:06.538] Resolving futures part of globals (recursively) ...
[16:05:06.538] resolve() on list ...
[16:05:06.538]  recursive: 99
[16:05:06.538]  length: 1
[16:05:06.539]  elements: ‘a’
[16:05:06.539]  length: 0 (resolved future 1)
[16:05:06.539] resolve() on list ... DONE
[16:05:06.539] - globals: [1] ‘a’
[16:05:06.539] Resolving futures part of globals (recursively) ... DONE
[16:05:06.539] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:06.539] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:05:06.540] - globals: [1] ‘a’
[16:05:06.540] 
[16:05:06.540] getGlobalsAndPackages() ... DONE
[16:05:06.540] run() for ‘Future’ ...
[16:05:06.540] - state: ‘created’
[16:05:06.540] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.540] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.541] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.541]   - Field: ‘label’
[16:05:06.541]   - Field: ‘local’
[16:05:06.541]   - Field: ‘owner’
[16:05:06.541]   - Field: ‘envir’
[16:05:06.541]   - Field: ‘packages’
[16:05:06.541]   - Field: ‘gc’
[16:05:06.541]   - Field: ‘conditions’
[16:05:06.541]   - Field: ‘expr’
[16:05:06.541]   - Field: ‘uuid’
[16:05:06.542]   - Field: ‘seed’
[16:05:06.542]   - Field: ‘version’
[16:05:06.542]   - Field: ‘result’
[16:05:06.542]   - Field: ‘asynchronous’
[16:05:06.542]   - Field: ‘calls’
[16:05:06.542]   - Field: ‘globals’
[16:05:06.542]   - Field: ‘stdout’
[16:05:06.542]   - Field: ‘earlySignal’
[16:05:06.542]   - Field: ‘lazy’
[16:05:06.542]   - Field: ‘state’
[16:05:06.543] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.543] - Launch lazy future ...
[16:05:06.543] Packages needed by the future expression (n = 0): <none>
[16:05:06.543] Packages needed by future strategies (n = 0): <none>
[16:05:06.543] {
[16:05:06.543]     {
[16:05:06.543]         {
[16:05:06.543]             ...future.startTime <- base::Sys.time()
[16:05:06.543]             {
[16:05:06.543]                 {
[16:05:06.543]                   {
[16:05:06.543]                     base::local({
[16:05:06.543]                       has_future <- base::requireNamespace("future", 
[16:05:06.543]                         quietly = TRUE)
[16:05:06.543]                       if (has_future) {
[16:05:06.543]                         ns <- base::getNamespace("future")
[16:05:06.543]                         version <- ns[[".package"]][["version"]]
[16:05:06.543]                         if (is.null(version)) 
[16:05:06.543]                           version <- utils::packageVersion("future")
[16:05:06.543]                       }
[16:05:06.543]                       else {
[16:05:06.543]                         version <- NULL
[16:05:06.543]                       }
[16:05:06.543]                       if (!has_future || version < "1.8.0") {
[16:05:06.543]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.543]                           "", base::R.version$version.string), 
[16:05:06.543]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.543]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.543]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.543]                             "release", "version")], collapse = " "), 
[16:05:06.543]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.543]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.543]                           info)
[16:05:06.543]                         info <- base::paste(info, collapse = "; ")
[16:05:06.543]                         if (!has_future) {
[16:05:06.543]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.543]                             info)
[16:05:06.543]                         }
[16:05:06.543]                         else {
[16:05:06.543]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.543]                             info, version)
[16:05:06.543]                         }
[16:05:06.543]                         base::stop(msg)
[16:05:06.543]                       }
[16:05:06.543]                     })
[16:05:06.543]                   }
[16:05:06.543]                   options(future.plan = NULL)
[16:05:06.543]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.543]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.543]                 }
[16:05:06.543]                 ...future.workdir <- getwd()
[16:05:06.543]             }
[16:05:06.543]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.543]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.543]         }
[16:05:06.543]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.543]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:06.543]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.543]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.543]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.543]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.543]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.543]             base::names(...future.oldOptions))
[16:05:06.543]     }
[16:05:06.543]     if (FALSE) {
[16:05:06.543]     }
[16:05:06.543]     else {
[16:05:06.543]         if (TRUE) {
[16:05:06.543]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.543]                 open = "w")
[16:05:06.543]         }
[16:05:06.543]         else {
[16:05:06.543]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.543]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.543]         }
[16:05:06.543]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.543]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.543]             base::sink(type = "output", split = FALSE)
[16:05:06.543]             base::close(...future.stdout)
[16:05:06.543]         }, add = TRUE)
[16:05:06.543]     }
[16:05:06.543]     ...future.frame <- base::sys.nframe()
[16:05:06.543]     ...future.conditions <- base::list()
[16:05:06.543]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.543]     if (FALSE) {
[16:05:06.543]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.543]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.543]     }
[16:05:06.543]     ...future.result <- base::tryCatch({
[16:05:06.543]         base::withCallingHandlers({
[16:05:06.543]             ...future.value <- base::withVisible(base::local({
[16:05:06.543]                 b <- a
[16:05:06.543]                 a <- 2
[16:05:06.543]                 a * b
[16:05:06.543]             }))
[16:05:06.543]             future::FutureResult(value = ...future.value$value, 
[16:05:06.543]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.543]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.543]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.543]                     ...future.globalenv.names))
[16:05:06.543]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.543]         }, condition = base::local({
[16:05:06.543]             c <- base::c
[16:05:06.543]             inherits <- base::inherits
[16:05:06.543]             invokeRestart <- base::invokeRestart
[16:05:06.543]             length <- base::length
[16:05:06.543]             list <- base::list
[16:05:06.543]             seq.int <- base::seq.int
[16:05:06.543]             signalCondition <- base::signalCondition
[16:05:06.543]             sys.calls <- base::sys.calls
[16:05:06.543]             `[[` <- base::`[[`
[16:05:06.543]             `+` <- base::`+`
[16:05:06.543]             `<<-` <- base::`<<-`
[16:05:06.543]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.543]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.543]                   3L)]
[16:05:06.543]             }
[16:05:06.543]             function(cond) {
[16:05:06.543]                 is_error <- inherits(cond, "error")
[16:05:06.543]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.543]                   NULL)
[16:05:06.543]                 if (is_error) {
[16:05:06.543]                   sessionInformation <- function() {
[16:05:06.543]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.543]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.543]                       search = base::search(), system = base::Sys.info())
[16:05:06.543]                   }
[16:05:06.543]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.543]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.543]                     cond$call), session = sessionInformation(), 
[16:05:06.543]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.543]                   signalCondition(cond)
[16:05:06.543]                 }
[16:05:06.543]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.543]                 "immediateCondition"))) {
[16:05:06.543]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.543]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.543]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.543]                   if (TRUE && !signal) {
[16:05:06.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.543]                     {
[16:05:06.543]                       inherits <- base::inherits
[16:05:06.543]                       invokeRestart <- base::invokeRestart
[16:05:06.543]                       is.null <- base::is.null
[16:05:06.543]                       muffled <- FALSE
[16:05:06.543]                       if (inherits(cond, "message")) {
[16:05:06.543]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.543]                         if (muffled) 
[16:05:06.543]                           invokeRestart("muffleMessage")
[16:05:06.543]                       }
[16:05:06.543]                       else if (inherits(cond, "warning")) {
[16:05:06.543]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.543]                         if (muffled) 
[16:05:06.543]                           invokeRestart("muffleWarning")
[16:05:06.543]                       }
[16:05:06.543]                       else if (inherits(cond, "condition")) {
[16:05:06.543]                         if (!is.null(pattern)) {
[16:05:06.543]                           computeRestarts <- base::computeRestarts
[16:05:06.543]                           grepl <- base::grepl
[16:05:06.543]                           restarts <- computeRestarts(cond)
[16:05:06.543]                           for (restart in restarts) {
[16:05:06.543]                             name <- restart$name
[16:05:06.543]                             if (is.null(name)) 
[16:05:06.543]                               next
[16:05:06.543]                             if (!grepl(pattern, name)) 
[16:05:06.543]                               next
[16:05:06.543]                             invokeRestart(restart)
[16:05:06.543]                             muffled <- TRUE
[16:05:06.543]                             break
[16:05:06.543]                           }
[16:05:06.543]                         }
[16:05:06.543]                       }
[16:05:06.543]                       invisible(muffled)
[16:05:06.543]                     }
[16:05:06.543]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.543]                   }
[16:05:06.543]                 }
[16:05:06.543]                 else {
[16:05:06.543]                   if (TRUE) {
[16:05:06.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.543]                     {
[16:05:06.543]                       inherits <- base::inherits
[16:05:06.543]                       invokeRestart <- base::invokeRestart
[16:05:06.543]                       is.null <- base::is.null
[16:05:06.543]                       muffled <- FALSE
[16:05:06.543]                       if (inherits(cond, "message")) {
[16:05:06.543]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.543]                         if (muffled) 
[16:05:06.543]                           invokeRestart("muffleMessage")
[16:05:06.543]                       }
[16:05:06.543]                       else if (inherits(cond, "warning")) {
[16:05:06.543]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.543]                         if (muffled) 
[16:05:06.543]                           invokeRestart("muffleWarning")
[16:05:06.543]                       }
[16:05:06.543]                       else if (inherits(cond, "condition")) {
[16:05:06.543]                         if (!is.null(pattern)) {
[16:05:06.543]                           computeRestarts <- base::computeRestarts
[16:05:06.543]                           grepl <- base::grepl
[16:05:06.543]                           restarts <- computeRestarts(cond)
[16:05:06.543]                           for (restart in restarts) {
[16:05:06.543]                             name <- restart$name
[16:05:06.543]                             if (is.null(name)) 
[16:05:06.543]                               next
[16:05:06.543]                             if (!grepl(pattern, name)) 
[16:05:06.543]                               next
[16:05:06.543]                             invokeRestart(restart)
[16:05:06.543]                             muffled <- TRUE
[16:05:06.543]                             break
[16:05:06.543]                           }
[16:05:06.543]                         }
[16:05:06.543]                       }
[16:05:06.543]                       invisible(muffled)
[16:05:06.543]                     }
[16:05:06.543]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.543]                   }
[16:05:06.543]                 }
[16:05:06.543]             }
[16:05:06.543]         }))
[16:05:06.543]     }, error = function(ex) {
[16:05:06.543]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.543]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.543]                 ...future.rng), started = ...future.startTime, 
[16:05:06.543]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.543]             version = "1.8"), class = "FutureResult")
[16:05:06.543]     }, finally = {
[16:05:06.543]         if (!identical(...future.workdir, getwd())) 
[16:05:06.543]             setwd(...future.workdir)
[16:05:06.543]         {
[16:05:06.543]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.543]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.543]             }
[16:05:06.543]             base::options(...future.oldOptions)
[16:05:06.543]             if (.Platform$OS.type == "windows") {
[16:05:06.543]                 old_names <- names(...future.oldEnvVars)
[16:05:06.543]                 envs <- base::Sys.getenv()
[16:05:06.543]                 names <- names(envs)
[16:05:06.543]                 common <- intersect(names, old_names)
[16:05:06.543]                 added <- setdiff(names, old_names)
[16:05:06.543]                 removed <- setdiff(old_names, names)
[16:05:06.543]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.543]                   envs[common]]
[16:05:06.543]                 NAMES <- toupper(changed)
[16:05:06.543]                 args <- list()
[16:05:06.543]                 for (kk in seq_along(NAMES)) {
[16:05:06.543]                   name <- changed[[kk]]
[16:05:06.543]                   NAME <- NAMES[[kk]]
[16:05:06.543]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.543]                     next
[16:05:06.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.543]                 }
[16:05:06.543]                 NAMES <- toupper(added)
[16:05:06.543]                 for (kk in seq_along(NAMES)) {
[16:05:06.543]                   name <- added[[kk]]
[16:05:06.543]                   NAME <- NAMES[[kk]]
[16:05:06.543]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.543]                     next
[16:05:06.543]                   args[[name]] <- ""
[16:05:06.543]                 }
[16:05:06.543]                 NAMES <- toupper(removed)
[16:05:06.543]                 for (kk in seq_along(NAMES)) {
[16:05:06.543]                   name <- removed[[kk]]
[16:05:06.543]                   NAME <- NAMES[[kk]]
[16:05:06.543]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.543]                     next
[16:05:06.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.543]                 }
[16:05:06.543]                 if (length(args) > 0) 
[16:05:06.543]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.543]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.543]             }
[16:05:06.543]             else {
[16:05:06.543]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.543]             }
[16:05:06.543]             {
[16:05:06.543]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.543]                   0L) {
[16:05:06.543]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.543]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.543]                   base::options(opts)
[16:05:06.543]                 }
[16:05:06.543]                 {
[16:05:06.543]                   {
[16:05:06.543]                     NULL
[16:05:06.543]                     RNGkind("Mersenne-Twister")
[16:05:06.543]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.543]                       inherits = FALSE)
[16:05:06.543]                   }
[16:05:06.543]                   options(future.plan = NULL)
[16:05:06.543]                   if (is.na(NA_character_)) 
[16:05:06.543]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.543]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.543]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.543]                   {
[16:05:06.543]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.543]                     if (!future$lazy) 
[16:05:06.543]                       future <- run(future)
[16:05:06.543]                     invisible(future)
[16:05:06.543]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.543]                 }
[16:05:06.543]             }
[16:05:06.543]         }
[16:05:06.543]     })
[16:05:06.543]     if (TRUE) {
[16:05:06.543]         base::sink(type = "output", split = FALSE)
[16:05:06.543]         if (TRUE) {
[16:05:06.543]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.543]         }
[16:05:06.543]         else {
[16:05:06.543]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.543]         }
[16:05:06.543]         base::close(...future.stdout)
[16:05:06.543]         ...future.stdout <- NULL
[16:05:06.543]     }
[16:05:06.543]     ...future.result$conditions <- ...future.conditions
[16:05:06.543]     ...future.result$finished <- base::Sys.time()
[16:05:06.543]     ...future.result
[16:05:06.543] }
[16:05:06.545] assign_globals() ...
[16:05:06.545] List of 1
[16:05:06.545]  $ a: num 3
[16:05:06.545]  - attr(*, "where")=List of 1
[16:05:06.545]   ..$ a:<environment: R_EmptyEnv> 
[16:05:06.545]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.545]  - attr(*, "resolved")= logi TRUE
[16:05:06.545]  - attr(*, "total_size")= num 56
[16:05:06.545]  - attr(*, "already-done")= logi TRUE
[16:05:06.547] - copied ‘a’ to environment
[16:05:06.548] assign_globals() ... done
[16:05:06.548] plan(): Setting new future strategy stack:
[16:05:06.548] List of future strategies:
[16:05:06.548] 1. sequential:
[16:05:06.548]    - args: function (..., envir = parent.frame())
[16:05:06.548]    - tweaked: FALSE
[16:05:06.548]    - call: NULL
[16:05:06.548] plan(): nbrOfWorkers() = 1
[16:05:06.549] plan(): Setting new future strategy stack:
[16:05:06.549] List of future strategies:
[16:05:06.549] 1. sequential:
[16:05:06.549]    - args: function (..., envir = parent.frame())
[16:05:06.549]    - tweaked: FALSE
[16:05:06.549]    - call: plan(strategy)
[16:05:06.549] plan(): nbrOfWorkers() = 1
[16:05:06.550] SequentialFuture started (and completed)
[16:05:06.550] - Launch lazy future ... done
[16:05:06.550] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.550] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.551] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:06.554] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:05:06.554] Searching for globals ... DONE
[16:05:06.554] Resolving globals: TRUE
[16:05:06.555] Resolving any globals that are futures ...
[16:05:06.555] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:05:06.555] Resolving any globals that are futures ... DONE
[16:05:06.555] Resolving futures part of globals (recursively) ...
[16:05:06.555] resolve() on list ...
[16:05:06.555]  recursive: 99
[16:05:06.556]  length: 1
[16:05:06.556]  elements: ‘a’
[16:05:06.556]  length: 0 (resolved future 1)
[16:05:06.556] resolve() on list ... DONE
[16:05:06.556] - globals: [1] ‘a’
[16:05:06.556] Resolving futures part of globals (recursively) ... DONE
[16:05:06.556] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:06.557] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:05:06.557] - globals: [1] ‘a’
[16:05:06.557] 
[16:05:06.557] getGlobalsAndPackages() ... DONE
[16:05:06.557] run() for ‘Future’ ...
[16:05:06.557] - state: ‘created’
[16:05:06.557] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.558] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.558] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.558]   - Field: ‘label’
[16:05:06.558]   - Field: ‘local’
[16:05:06.558]   - Field: ‘owner’
[16:05:06.558]   - Field: ‘envir’
[16:05:06.558]   - Field: ‘packages’
[16:05:06.558]   - Field: ‘gc’
[16:05:06.559]   - Field: ‘conditions’
[16:05:06.559]   - Field: ‘expr’
[16:05:06.559]   - Field: ‘uuid’
[16:05:06.559]   - Field: ‘seed’
[16:05:06.559]   - Field: ‘version’
[16:05:06.559]   - Field: ‘result’
[16:05:06.559]   - Field: ‘asynchronous’
[16:05:06.559]   - Field: ‘calls’
[16:05:06.559]   - Field: ‘globals’
[16:05:06.559]   - Field: ‘stdout’
[16:05:06.559]   - Field: ‘earlySignal’
[16:05:06.560]   - Field: ‘lazy’
[16:05:06.560]   - Field: ‘state’
[16:05:06.560] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.560] - Launch lazy future ...
[16:05:06.560] Packages needed by the future expression (n = 0): <none>
[16:05:06.560] Packages needed by future strategies (n = 0): <none>
[16:05:06.561] {
[16:05:06.561]     {
[16:05:06.561]         {
[16:05:06.561]             ...future.startTime <- base::Sys.time()
[16:05:06.561]             {
[16:05:06.561]                 {
[16:05:06.561]                   {
[16:05:06.561]                     base::local({
[16:05:06.561]                       has_future <- base::requireNamespace("future", 
[16:05:06.561]                         quietly = TRUE)
[16:05:06.561]                       if (has_future) {
[16:05:06.561]                         ns <- base::getNamespace("future")
[16:05:06.561]                         version <- ns[[".package"]][["version"]]
[16:05:06.561]                         if (is.null(version)) 
[16:05:06.561]                           version <- utils::packageVersion("future")
[16:05:06.561]                       }
[16:05:06.561]                       else {
[16:05:06.561]                         version <- NULL
[16:05:06.561]                       }
[16:05:06.561]                       if (!has_future || version < "1.8.0") {
[16:05:06.561]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.561]                           "", base::R.version$version.string), 
[16:05:06.561]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.561]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.561]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.561]                             "release", "version")], collapse = " "), 
[16:05:06.561]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.561]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.561]                           info)
[16:05:06.561]                         info <- base::paste(info, collapse = "; ")
[16:05:06.561]                         if (!has_future) {
[16:05:06.561]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.561]                             info)
[16:05:06.561]                         }
[16:05:06.561]                         else {
[16:05:06.561]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.561]                             info, version)
[16:05:06.561]                         }
[16:05:06.561]                         base::stop(msg)
[16:05:06.561]                       }
[16:05:06.561]                     })
[16:05:06.561]                   }
[16:05:06.561]                   options(future.plan = NULL)
[16:05:06.561]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.561]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.561]                 }
[16:05:06.561]                 ...future.workdir <- getwd()
[16:05:06.561]             }
[16:05:06.561]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.561]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.561]         }
[16:05:06.561]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.561]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:06.561]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.561]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.561]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.561]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.561]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.561]             base::names(...future.oldOptions))
[16:05:06.561]     }
[16:05:06.561]     if (FALSE) {
[16:05:06.561]     }
[16:05:06.561]     else {
[16:05:06.561]         if (TRUE) {
[16:05:06.561]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.561]                 open = "w")
[16:05:06.561]         }
[16:05:06.561]         else {
[16:05:06.561]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.561]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.561]         }
[16:05:06.561]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.561]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.561]             base::sink(type = "output", split = FALSE)
[16:05:06.561]             base::close(...future.stdout)
[16:05:06.561]         }, add = TRUE)
[16:05:06.561]     }
[16:05:06.561]     ...future.frame <- base::sys.nframe()
[16:05:06.561]     ...future.conditions <- base::list()
[16:05:06.561]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.561]     if (FALSE) {
[16:05:06.561]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.561]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.561]     }
[16:05:06.561]     ...future.result <- base::tryCatch({
[16:05:06.561]         base::withCallingHandlers({
[16:05:06.561]             ...future.value <- base::withVisible(base::local({
[16:05:06.561]                 b <- a
[16:05:06.561]                 a <- 2
[16:05:06.561]                 a * b
[16:05:06.561]             }))
[16:05:06.561]             future::FutureResult(value = ...future.value$value, 
[16:05:06.561]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.561]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.561]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.561]                     ...future.globalenv.names))
[16:05:06.561]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.561]         }, condition = base::local({
[16:05:06.561]             c <- base::c
[16:05:06.561]             inherits <- base::inherits
[16:05:06.561]             invokeRestart <- base::invokeRestart
[16:05:06.561]             length <- base::length
[16:05:06.561]             list <- base::list
[16:05:06.561]             seq.int <- base::seq.int
[16:05:06.561]             signalCondition <- base::signalCondition
[16:05:06.561]             sys.calls <- base::sys.calls
[16:05:06.561]             `[[` <- base::`[[`
[16:05:06.561]             `+` <- base::`+`
[16:05:06.561]             `<<-` <- base::`<<-`
[16:05:06.561]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.561]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.561]                   3L)]
[16:05:06.561]             }
[16:05:06.561]             function(cond) {
[16:05:06.561]                 is_error <- inherits(cond, "error")
[16:05:06.561]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.561]                   NULL)
[16:05:06.561]                 if (is_error) {
[16:05:06.561]                   sessionInformation <- function() {
[16:05:06.561]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.561]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.561]                       search = base::search(), system = base::Sys.info())
[16:05:06.561]                   }
[16:05:06.561]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.561]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.561]                     cond$call), session = sessionInformation(), 
[16:05:06.561]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.561]                   signalCondition(cond)
[16:05:06.561]                 }
[16:05:06.561]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.561]                 "immediateCondition"))) {
[16:05:06.561]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.561]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.561]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.561]                   if (TRUE && !signal) {
[16:05:06.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.561]                     {
[16:05:06.561]                       inherits <- base::inherits
[16:05:06.561]                       invokeRestart <- base::invokeRestart
[16:05:06.561]                       is.null <- base::is.null
[16:05:06.561]                       muffled <- FALSE
[16:05:06.561]                       if (inherits(cond, "message")) {
[16:05:06.561]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.561]                         if (muffled) 
[16:05:06.561]                           invokeRestart("muffleMessage")
[16:05:06.561]                       }
[16:05:06.561]                       else if (inherits(cond, "warning")) {
[16:05:06.561]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.561]                         if (muffled) 
[16:05:06.561]                           invokeRestart("muffleWarning")
[16:05:06.561]                       }
[16:05:06.561]                       else if (inherits(cond, "condition")) {
[16:05:06.561]                         if (!is.null(pattern)) {
[16:05:06.561]                           computeRestarts <- base::computeRestarts
[16:05:06.561]                           grepl <- base::grepl
[16:05:06.561]                           restarts <- computeRestarts(cond)
[16:05:06.561]                           for (restart in restarts) {
[16:05:06.561]                             name <- restart$name
[16:05:06.561]                             if (is.null(name)) 
[16:05:06.561]                               next
[16:05:06.561]                             if (!grepl(pattern, name)) 
[16:05:06.561]                               next
[16:05:06.561]                             invokeRestart(restart)
[16:05:06.561]                             muffled <- TRUE
[16:05:06.561]                             break
[16:05:06.561]                           }
[16:05:06.561]                         }
[16:05:06.561]                       }
[16:05:06.561]                       invisible(muffled)
[16:05:06.561]                     }
[16:05:06.561]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.561]                   }
[16:05:06.561]                 }
[16:05:06.561]                 else {
[16:05:06.561]                   if (TRUE) {
[16:05:06.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.561]                     {
[16:05:06.561]                       inherits <- base::inherits
[16:05:06.561]                       invokeRestart <- base::invokeRestart
[16:05:06.561]                       is.null <- base::is.null
[16:05:06.561]                       muffled <- FALSE
[16:05:06.561]                       if (inherits(cond, "message")) {
[16:05:06.561]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.561]                         if (muffled) 
[16:05:06.561]                           invokeRestart("muffleMessage")
[16:05:06.561]                       }
[16:05:06.561]                       else if (inherits(cond, "warning")) {
[16:05:06.561]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.561]                         if (muffled) 
[16:05:06.561]                           invokeRestart("muffleWarning")
[16:05:06.561]                       }
[16:05:06.561]                       else if (inherits(cond, "condition")) {
[16:05:06.561]                         if (!is.null(pattern)) {
[16:05:06.561]                           computeRestarts <- base::computeRestarts
[16:05:06.561]                           grepl <- base::grepl
[16:05:06.561]                           restarts <- computeRestarts(cond)
[16:05:06.561]                           for (restart in restarts) {
[16:05:06.561]                             name <- restart$name
[16:05:06.561]                             if (is.null(name)) 
[16:05:06.561]                               next
[16:05:06.561]                             if (!grepl(pattern, name)) 
[16:05:06.561]                               next
[16:05:06.561]                             invokeRestart(restart)
[16:05:06.561]                             muffled <- TRUE
[16:05:06.561]                             break
[16:05:06.561]                           }
[16:05:06.561]                         }
[16:05:06.561]                       }
[16:05:06.561]                       invisible(muffled)
[16:05:06.561]                     }
[16:05:06.561]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.561]                   }
[16:05:06.561]                 }
[16:05:06.561]             }
[16:05:06.561]         }))
[16:05:06.561]     }, error = function(ex) {
[16:05:06.561]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.561]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.561]                 ...future.rng), started = ...future.startTime, 
[16:05:06.561]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.561]             version = "1.8"), class = "FutureResult")
[16:05:06.561]     }, finally = {
[16:05:06.561]         if (!identical(...future.workdir, getwd())) 
[16:05:06.561]             setwd(...future.workdir)
[16:05:06.561]         {
[16:05:06.561]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.561]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.561]             }
[16:05:06.561]             base::options(...future.oldOptions)
[16:05:06.561]             if (.Platform$OS.type == "windows") {
[16:05:06.561]                 old_names <- names(...future.oldEnvVars)
[16:05:06.561]                 envs <- base::Sys.getenv()
[16:05:06.561]                 names <- names(envs)
[16:05:06.561]                 common <- intersect(names, old_names)
[16:05:06.561]                 added <- setdiff(names, old_names)
[16:05:06.561]                 removed <- setdiff(old_names, names)
[16:05:06.561]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.561]                   envs[common]]
[16:05:06.561]                 NAMES <- toupper(changed)
[16:05:06.561]                 args <- list()
[16:05:06.561]                 for (kk in seq_along(NAMES)) {
[16:05:06.561]                   name <- changed[[kk]]
[16:05:06.561]                   NAME <- NAMES[[kk]]
[16:05:06.561]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.561]                     next
[16:05:06.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.561]                 }
[16:05:06.561]                 NAMES <- toupper(added)
[16:05:06.561]                 for (kk in seq_along(NAMES)) {
[16:05:06.561]                   name <- added[[kk]]
[16:05:06.561]                   NAME <- NAMES[[kk]]
[16:05:06.561]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.561]                     next
[16:05:06.561]                   args[[name]] <- ""
[16:05:06.561]                 }
[16:05:06.561]                 NAMES <- toupper(removed)
[16:05:06.561]                 for (kk in seq_along(NAMES)) {
[16:05:06.561]                   name <- removed[[kk]]
[16:05:06.561]                   NAME <- NAMES[[kk]]
[16:05:06.561]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.561]                     next
[16:05:06.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.561]                 }
[16:05:06.561]                 if (length(args) > 0) 
[16:05:06.561]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.561]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.561]             }
[16:05:06.561]             else {
[16:05:06.561]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.561]             }
[16:05:06.561]             {
[16:05:06.561]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.561]                   0L) {
[16:05:06.561]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.561]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.561]                   base::options(opts)
[16:05:06.561]                 }
[16:05:06.561]                 {
[16:05:06.561]                   {
[16:05:06.561]                     NULL
[16:05:06.561]                     RNGkind("Mersenne-Twister")
[16:05:06.561]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.561]                       inherits = FALSE)
[16:05:06.561]                   }
[16:05:06.561]                   options(future.plan = NULL)
[16:05:06.561]                   if (is.na(NA_character_)) 
[16:05:06.561]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.561]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.561]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.561]                   {
[16:05:06.561]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.561]                     if (!future$lazy) 
[16:05:06.561]                       future <- run(future)
[16:05:06.561]                     invisible(future)
[16:05:06.561]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.561]                 }
[16:05:06.561]             }
[16:05:06.561]         }
[16:05:06.561]     })
[16:05:06.561]     if (TRUE) {
[16:05:06.561]         base::sink(type = "output", split = FALSE)
[16:05:06.561]         if (TRUE) {
[16:05:06.561]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.561]         }
[16:05:06.561]         else {
[16:05:06.561]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.561]         }
[16:05:06.561]         base::close(...future.stdout)
[16:05:06.561]         ...future.stdout <- NULL
[16:05:06.561]     }
[16:05:06.561]     ...future.result$conditions <- ...future.conditions
[16:05:06.561]     ...future.result$finished <- base::Sys.time()
[16:05:06.561]     ...future.result
[16:05:06.561] }
[16:05:06.562] assign_globals() ...
[16:05:06.562] List of 1
[16:05:06.562]  $ a: num 3
[16:05:06.562]  - attr(*, "where")=List of 1
[16:05:06.562]   ..$ a:<environment: R_EmptyEnv> 
[16:05:06.562]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.562]  - attr(*, "resolved")= logi TRUE
[16:05:06.562]  - attr(*, "total_size")= num 56
[16:05:06.562]  - attr(*, "already-done")= logi TRUE
[16:05:06.565] - copied ‘a’ to environment
[16:05:06.565] assign_globals() ... done
[16:05:06.565] plan(): Setting new future strategy stack:
[16:05:06.565] List of future strategies:
[16:05:06.565] 1. sequential:
[16:05:06.565]    - args: function (..., envir = parent.frame())
[16:05:06.565]    - tweaked: FALSE
[16:05:06.565]    - call: NULL
[16:05:06.566] plan(): nbrOfWorkers() = 1
[16:05:06.566] plan(): Setting new future strategy stack:
[16:05:06.567] List of future strategies:
[16:05:06.567] 1. sequential:
[16:05:06.567]    - args: function (..., envir = parent.frame())
[16:05:06.567]    - tweaked: FALSE
[16:05:06.567]    - call: plan(strategy)
[16:05:06.567] plan(): nbrOfWorkers() = 1
[16:05:06.567] SequentialFuture started (and completed)
[16:05:06.567] - Launch lazy future ... done
[16:05:06.567] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.568] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.568] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:06.570] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:06.570] Searching for globals ... DONE
[16:05:06.570] Resolving globals: TRUE
[16:05:06.570] Resolving any globals that are futures ...
[16:05:06.570] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:06.571] Resolving any globals that are futures ... DONE
[16:05:06.571] Resolving futures part of globals (recursively) ...
[16:05:06.571] resolve() on list ...
[16:05:06.571]  recursive: 99
[16:05:06.571]  length: 2
[16:05:06.571]  elements: ‘a’, ‘ii’
[16:05:06.572]  length: 1 (resolved future 1)
[16:05:06.572]  length: 0 (resolved future 2)
[16:05:06.572] resolve() on list ... DONE
[16:05:06.572] - globals: [2] ‘a’, ‘ii’
[16:05:06.572] Resolving futures part of globals (recursively) ... DONE
[16:05:06.572] The total size of the 2 globals is 112 bytes (112 bytes)
[16:05:06.572] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:05:06.573] - globals: [2] ‘a’, ‘ii’
[16:05:06.573] 
[16:05:06.573] getGlobalsAndPackages() ... DONE
[16:05:06.573] run() for ‘Future’ ...
[16:05:06.573] - state: ‘created’
[16:05:06.573] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.573] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.574] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.574]   - Field: ‘label’
[16:05:06.574]   - Field: ‘local’
[16:05:06.574]   - Field: ‘owner’
[16:05:06.574]   - Field: ‘envir’
[16:05:06.574]   - Field: ‘packages’
[16:05:06.574]   - Field: ‘gc’
[16:05:06.574]   - Field: ‘conditions’
[16:05:06.574]   - Field: ‘expr’
[16:05:06.574]   - Field: ‘uuid’
[16:05:06.575]   - Field: ‘seed’
[16:05:06.575]   - Field: ‘version’
[16:05:06.575]   - Field: ‘result’
[16:05:06.575]   - Field: ‘asynchronous’
[16:05:06.575]   - Field: ‘calls’
[16:05:06.575]   - Field: ‘globals’
[16:05:06.575]   - Field: ‘stdout’
[16:05:06.575]   - Field: ‘earlySignal’
[16:05:06.575]   - Field: ‘lazy’
[16:05:06.575]   - Field: ‘state’
[16:05:06.576] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.576] - Launch lazy future ...
[16:05:06.576] Packages needed by the future expression (n = 0): <none>
[16:05:06.576] Packages needed by future strategies (n = 0): <none>
[16:05:06.576] {
[16:05:06.576]     {
[16:05:06.576]         {
[16:05:06.576]             ...future.startTime <- base::Sys.time()
[16:05:06.576]             {
[16:05:06.576]                 {
[16:05:06.576]                   {
[16:05:06.576]                     base::local({
[16:05:06.576]                       has_future <- base::requireNamespace("future", 
[16:05:06.576]                         quietly = TRUE)
[16:05:06.576]                       if (has_future) {
[16:05:06.576]                         ns <- base::getNamespace("future")
[16:05:06.576]                         version <- ns[[".package"]][["version"]]
[16:05:06.576]                         if (is.null(version)) 
[16:05:06.576]                           version <- utils::packageVersion("future")
[16:05:06.576]                       }
[16:05:06.576]                       else {
[16:05:06.576]                         version <- NULL
[16:05:06.576]                       }
[16:05:06.576]                       if (!has_future || version < "1.8.0") {
[16:05:06.576]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.576]                           "", base::R.version$version.string), 
[16:05:06.576]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.576]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.576]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.576]                             "release", "version")], collapse = " "), 
[16:05:06.576]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.576]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.576]                           info)
[16:05:06.576]                         info <- base::paste(info, collapse = "; ")
[16:05:06.576]                         if (!has_future) {
[16:05:06.576]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.576]                             info)
[16:05:06.576]                         }
[16:05:06.576]                         else {
[16:05:06.576]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.576]                             info, version)
[16:05:06.576]                         }
[16:05:06.576]                         base::stop(msg)
[16:05:06.576]                       }
[16:05:06.576]                     })
[16:05:06.576]                   }
[16:05:06.576]                   options(future.plan = NULL)
[16:05:06.576]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.576]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.576]                 }
[16:05:06.576]                 ...future.workdir <- getwd()
[16:05:06.576]             }
[16:05:06.576]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.576]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.576]         }
[16:05:06.576]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.576]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:06.576]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.576]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.576]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.576]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.576]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.576]             base::names(...future.oldOptions))
[16:05:06.576]     }
[16:05:06.576]     if (FALSE) {
[16:05:06.576]     }
[16:05:06.576]     else {
[16:05:06.576]         if (TRUE) {
[16:05:06.576]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.576]                 open = "w")
[16:05:06.576]         }
[16:05:06.576]         else {
[16:05:06.576]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.576]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.576]         }
[16:05:06.576]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.576]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.576]             base::sink(type = "output", split = FALSE)
[16:05:06.576]             base::close(...future.stdout)
[16:05:06.576]         }, add = TRUE)
[16:05:06.576]     }
[16:05:06.576]     ...future.frame <- base::sys.nframe()
[16:05:06.576]     ...future.conditions <- base::list()
[16:05:06.576]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.576]     if (FALSE) {
[16:05:06.576]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.576]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.576]     }
[16:05:06.576]     ...future.result <- base::tryCatch({
[16:05:06.576]         base::withCallingHandlers({
[16:05:06.576]             ...future.value <- base::withVisible(base::local({
[16:05:06.576]                 b <- a * ii
[16:05:06.576]                 a <- 0
[16:05:06.576]                 b
[16:05:06.576]             }))
[16:05:06.576]             future::FutureResult(value = ...future.value$value, 
[16:05:06.576]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.576]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.576]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.576]                     ...future.globalenv.names))
[16:05:06.576]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.576]         }, condition = base::local({
[16:05:06.576]             c <- base::c
[16:05:06.576]             inherits <- base::inherits
[16:05:06.576]             invokeRestart <- base::invokeRestart
[16:05:06.576]             length <- base::length
[16:05:06.576]             list <- base::list
[16:05:06.576]             seq.int <- base::seq.int
[16:05:06.576]             signalCondition <- base::signalCondition
[16:05:06.576]             sys.calls <- base::sys.calls
[16:05:06.576]             `[[` <- base::`[[`
[16:05:06.576]             `+` <- base::`+`
[16:05:06.576]             `<<-` <- base::`<<-`
[16:05:06.576]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.576]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.576]                   3L)]
[16:05:06.576]             }
[16:05:06.576]             function(cond) {
[16:05:06.576]                 is_error <- inherits(cond, "error")
[16:05:06.576]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.576]                   NULL)
[16:05:06.576]                 if (is_error) {
[16:05:06.576]                   sessionInformation <- function() {
[16:05:06.576]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.576]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.576]                       search = base::search(), system = base::Sys.info())
[16:05:06.576]                   }
[16:05:06.576]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.576]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.576]                     cond$call), session = sessionInformation(), 
[16:05:06.576]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.576]                   signalCondition(cond)
[16:05:06.576]                 }
[16:05:06.576]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.576]                 "immediateCondition"))) {
[16:05:06.576]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.576]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.576]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.576]                   if (TRUE && !signal) {
[16:05:06.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.576]                     {
[16:05:06.576]                       inherits <- base::inherits
[16:05:06.576]                       invokeRestart <- base::invokeRestart
[16:05:06.576]                       is.null <- base::is.null
[16:05:06.576]                       muffled <- FALSE
[16:05:06.576]                       if (inherits(cond, "message")) {
[16:05:06.576]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.576]                         if (muffled) 
[16:05:06.576]                           invokeRestart("muffleMessage")
[16:05:06.576]                       }
[16:05:06.576]                       else if (inherits(cond, "warning")) {
[16:05:06.576]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.576]                         if (muffled) 
[16:05:06.576]                           invokeRestart("muffleWarning")
[16:05:06.576]                       }
[16:05:06.576]                       else if (inherits(cond, "condition")) {
[16:05:06.576]                         if (!is.null(pattern)) {
[16:05:06.576]                           computeRestarts <- base::computeRestarts
[16:05:06.576]                           grepl <- base::grepl
[16:05:06.576]                           restarts <- computeRestarts(cond)
[16:05:06.576]                           for (restart in restarts) {
[16:05:06.576]                             name <- restart$name
[16:05:06.576]                             if (is.null(name)) 
[16:05:06.576]                               next
[16:05:06.576]                             if (!grepl(pattern, name)) 
[16:05:06.576]                               next
[16:05:06.576]                             invokeRestart(restart)
[16:05:06.576]                             muffled <- TRUE
[16:05:06.576]                             break
[16:05:06.576]                           }
[16:05:06.576]                         }
[16:05:06.576]                       }
[16:05:06.576]                       invisible(muffled)
[16:05:06.576]                     }
[16:05:06.576]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.576]                   }
[16:05:06.576]                 }
[16:05:06.576]                 else {
[16:05:06.576]                   if (TRUE) {
[16:05:06.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.576]                     {
[16:05:06.576]                       inherits <- base::inherits
[16:05:06.576]                       invokeRestart <- base::invokeRestart
[16:05:06.576]                       is.null <- base::is.null
[16:05:06.576]                       muffled <- FALSE
[16:05:06.576]                       if (inherits(cond, "message")) {
[16:05:06.576]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.576]                         if (muffled) 
[16:05:06.576]                           invokeRestart("muffleMessage")
[16:05:06.576]                       }
[16:05:06.576]                       else if (inherits(cond, "warning")) {
[16:05:06.576]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.576]                         if (muffled) 
[16:05:06.576]                           invokeRestart("muffleWarning")
[16:05:06.576]                       }
[16:05:06.576]                       else if (inherits(cond, "condition")) {
[16:05:06.576]                         if (!is.null(pattern)) {
[16:05:06.576]                           computeRestarts <- base::computeRestarts
[16:05:06.576]                           grepl <- base::grepl
[16:05:06.576]                           restarts <- computeRestarts(cond)
[16:05:06.576]                           for (restart in restarts) {
[16:05:06.576]                             name <- restart$name
[16:05:06.576]                             if (is.null(name)) 
[16:05:06.576]                               next
[16:05:06.576]                             if (!grepl(pattern, name)) 
[16:05:06.576]                               next
[16:05:06.576]                             invokeRestart(restart)
[16:05:06.576]                             muffled <- TRUE
[16:05:06.576]                             break
[16:05:06.576]                           }
[16:05:06.576]                         }
[16:05:06.576]                       }
[16:05:06.576]                       invisible(muffled)
[16:05:06.576]                     }
[16:05:06.576]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.576]                   }
[16:05:06.576]                 }
[16:05:06.576]             }
[16:05:06.576]         }))
[16:05:06.576]     }, error = function(ex) {
[16:05:06.576]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.576]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.576]                 ...future.rng), started = ...future.startTime, 
[16:05:06.576]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.576]             version = "1.8"), class = "FutureResult")
[16:05:06.576]     }, finally = {
[16:05:06.576]         if (!identical(...future.workdir, getwd())) 
[16:05:06.576]             setwd(...future.workdir)
[16:05:06.576]         {
[16:05:06.576]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.576]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.576]             }
[16:05:06.576]             base::options(...future.oldOptions)
[16:05:06.576]             if (.Platform$OS.type == "windows") {
[16:05:06.576]                 old_names <- names(...future.oldEnvVars)
[16:05:06.576]                 envs <- base::Sys.getenv()
[16:05:06.576]                 names <- names(envs)
[16:05:06.576]                 common <- intersect(names, old_names)
[16:05:06.576]                 added <- setdiff(names, old_names)
[16:05:06.576]                 removed <- setdiff(old_names, names)
[16:05:06.576]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.576]                   envs[common]]
[16:05:06.576]                 NAMES <- toupper(changed)
[16:05:06.576]                 args <- list()
[16:05:06.576]                 for (kk in seq_along(NAMES)) {
[16:05:06.576]                   name <- changed[[kk]]
[16:05:06.576]                   NAME <- NAMES[[kk]]
[16:05:06.576]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.576]                     next
[16:05:06.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.576]                 }
[16:05:06.576]                 NAMES <- toupper(added)
[16:05:06.576]                 for (kk in seq_along(NAMES)) {
[16:05:06.576]                   name <- added[[kk]]
[16:05:06.576]                   NAME <- NAMES[[kk]]
[16:05:06.576]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.576]                     next
[16:05:06.576]                   args[[name]] <- ""
[16:05:06.576]                 }
[16:05:06.576]                 NAMES <- toupper(removed)
[16:05:06.576]                 for (kk in seq_along(NAMES)) {
[16:05:06.576]                   name <- removed[[kk]]
[16:05:06.576]                   NAME <- NAMES[[kk]]
[16:05:06.576]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.576]                     next
[16:05:06.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.576]                 }
[16:05:06.576]                 if (length(args) > 0) 
[16:05:06.576]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.576]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.576]             }
[16:05:06.576]             else {
[16:05:06.576]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.576]             }
[16:05:06.576]             {
[16:05:06.576]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.576]                   0L) {
[16:05:06.576]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.576]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.576]                   base::options(opts)
[16:05:06.576]                 }
[16:05:06.576]                 {
[16:05:06.576]                   {
[16:05:06.576]                     NULL
[16:05:06.576]                     RNGkind("Mersenne-Twister")
[16:05:06.576]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.576]                       inherits = FALSE)
[16:05:06.576]                   }
[16:05:06.576]                   options(future.plan = NULL)
[16:05:06.576]                   if (is.na(NA_character_)) 
[16:05:06.576]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.576]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.576]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.576]                   {
[16:05:06.576]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.576]                     if (!future$lazy) 
[16:05:06.576]                       future <- run(future)
[16:05:06.576]                     invisible(future)
[16:05:06.576]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.576]                 }
[16:05:06.576]             }
[16:05:06.576]         }
[16:05:06.576]     })
[16:05:06.576]     if (TRUE) {
[16:05:06.576]         base::sink(type = "output", split = FALSE)
[16:05:06.576]         if (TRUE) {
[16:05:06.576]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.576]         }
[16:05:06.576]         else {
[16:05:06.576]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.576]         }
[16:05:06.576]         base::close(...future.stdout)
[16:05:06.576]         ...future.stdout <- NULL
[16:05:06.576]     }
[16:05:06.576]     ...future.result$conditions <- ...future.conditions
[16:05:06.576]     ...future.result$finished <- base::Sys.time()
[16:05:06.576]     ...future.result
[16:05:06.576] }
[16:05:06.578] assign_globals() ...
[16:05:06.578] List of 2
[16:05:06.578]  $ a : num 1
[16:05:06.578]  $ ii: int 1
[16:05:06.578]  - attr(*, "where")=List of 2
[16:05:06.578]   ..$ a :<environment: R_EmptyEnv> 
[16:05:06.578]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:06.578]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.578]  - attr(*, "resolved")= logi TRUE
[16:05:06.578]  - attr(*, "total_size")= num 112
[16:05:06.578]  - attr(*, "already-done")= logi TRUE
[16:05:06.583] - copied ‘a’ to environment
[16:05:06.583] - copied ‘ii’ to environment
[16:05:06.583] assign_globals() ... done
[16:05:06.583] plan(): Setting new future strategy stack:
[16:05:06.584] List of future strategies:
[16:05:06.584] 1. sequential:
[16:05:06.584]    - args: function (..., envir = parent.frame())
[16:05:06.584]    - tweaked: FALSE
[16:05:06.584]    - call: NULL
[16:05:06.584] plan(): nbrOfWorkers() = 1
[16:05:06.585] plan(): Setting new future strategy stack:
[16:05:06.585] List of future strategies:
[16:05:06.585] 1. sequential:
[16:05:06.585]    - args: function (..., envir = parent.frame())
[16:05:06.585]    - tweaked: FALSE
[16:05:06.585]    - call: plan(strategy)
[16:05:06.585] plan(): nbrOfWorkers() = 1
[16:05:06.585] SequentialFuture started (and completed)
[16:05:06.585] - Launch lazy future ... done
[16:05:06.586] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.586] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.586] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:06.588] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:06.588] Searching for globals ... DONE
[16:05:06.588] Resolving globals: TRUE
[16:05:06.588] Resolving any globals that are futures ...
[16:05:06.589] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:06.589] Resolving any globals that are futures ... DONE
[16:05:06.589] Resolving futures part of globals (recursively) ...
[16:05:06.589] resolve() on list ...
[16:05:06.589]  recursive: 99
[16:05:06.589]  length: 2
[16:05:06.589]  elements: ‘a’, ‘ii’
[16:05:06.590]  length: 1 (resolved future 1)
[16:05:06.590]  length: 0 (resolved future 2)
[16:05:06.590] resolve() on list ... DONE
[16:05:06.590] - globals: [2] ‘a’, ‘ii’
[16:05:06.590] Resolving futures part of globals (recursively) ... DONE
[16:05:06.590] The total size of the 2 globals is 112 bytes (112 bytes)
[16:05:06.591] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:05:06.591] - globals: [2] ‘a’, ‘ii’
[16:05:06.591] 
[16:05:06.591] getGlobalsAndPackages() ... DONE
[16:05:06.591] run() for ‘Future’ ...
[16:05:06.591] - state: ‘created’
[16:05:06.591] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.592] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.592] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.592]   - Field: ‘label’
[16:05:06.592]   - Field: ‘local’
[16:05:06.592]   - Field: ‘owner’
[16:05:06.592]   - Field: ‘envir’
[16:05:06.592]   - Field: ‘packages’
[16:05:06.592]   - Field: ‘gc’
[16:05:06.592]   - Field: ‘conditions’
[16:05:06.593]   - Field: ‘expr’
[16:05:06.593]   - Field: ‘uuid’
[16:05:06.593]   - Field: ‘seed’
[16:05:06.593]   - Field: ‘version’
[16:05:06.593]   - Field: ‘result’
[16:05:06.593]   - Field: ‘asynchronous’
[16:05:06.593]   - Field: ‘calls’
[16:05:06.593]   - Field: ‘globals’
[16:05:06.593]   - Field: ‘stdout’
[16:05:06.593]   - Field: ‘earlySignal’
[16:05:06.593]   - Field: ‘lazy’
[16:05:06.594]   - Field: ‘state’
[16:05:06.594] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.594] - Launch lazy future ...
[16:05:06.594] Packages needed by the future expression (n = 0): <none>
[16:05:06.594] Packages needed by future strategies (n = 0): <none>
[16:05:06.594] {
[16:05:06.594]     {
[16:05:06.594]         {
[16:05:06.594]             ...future.startTime <- base::Sys.time()
[16:05:06.594]             {
[16:05:06.594]                 {
[16:05:06.594]                   {
[16:05:06.594]                     base::local({
[16:05:06.594]                       has_future <- base::requireNamespace("future", 
[16:05:06.594]                         quietly = TRUE)
[16:05:06.594]                       if (has_future) {
[16:05:06.594]                         ns <- base::getNamespace("future")
[16:05:06.594]                         version <- ns[[".package"]][["version"]]
[16:05:06.594]                         if (is.null(version)) 
[16:05:06.594]                           version <- utils::packageVersion("future")
[16:05:06.594]                       }
[16:05:06.594]                       else {
[16:05:06.594]                         version <- NULL
[16:05:06.594]                       }
[16:05:06.594]                       if (!has_future || version < "1.8.0") {
[16:05:06.594]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.594]                           "", base::R.version$version.string), 
[16:05:06.594]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.594]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.594]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.594]                             "release", "version")], collapse = " "), 
[16:05:06.594]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.594]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.594]                           info)
[16:05:06.594]                         info <- base::paste(info, collapse = "; ")
[16:05:06.594]                         if (!has_future) {
[16:05:06.594]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.594]                             info)
[16:05:06.594]                         }
[16:05:06.594]                         else {
[16:05:06.594]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.594]                             info, version)
[16:05:06.594]                         }
[16:05:06.594]                         base::stop(msg)
[16:05:06.594]                       }
[16:05:06.594]                     })
[16:05:06.594]                   }
[16:05:06.594]                   options(future.plan = NULL)
[16:05:06.594]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.594]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.594]                 }
[16:05:06.594]                 ...future.workdir <- getwd()
[16:05:06.594]             }
[16:05:06.594]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.594]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.594]         }
[16:05:06.594]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.594]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:06.594]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.594]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.594]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.594]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.594]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.594]             base::names(...future.oldOptions))
[16:05:06.594]     }
[16:05:06.594]     if (FALSE) {
[16:05:06.594]     }
[16:05:06.594]     else {
[16:05:06.594]         if (TRUE) {
[16:05:06.594]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.594]                 open = "w")
[16:05:06.594]         }
[16:05:06.594]         else {
[16:05:06.594]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.594]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.594]         }
[16:05:06.594]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.594]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.594]             base::sink(type = "output", split = FALSE)
[16:05:06.594]             base::close(...future.stdout)
[16:05:06.594]         }, add = TRUE)
[16:05:06.594]     }
[16:05:06.594]     ...future.frame <- base::sys.nframe()
[16:05:06.594]     ...future.conditions <- base::list()
[16:05:06.594]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.594]     if (FALSE) {
[16:05:06.594]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.594]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.594]     }
[16:05:06.594]     ...future.result <- base::tryCatch({
[16:05:06.594]         base::withCallingHandlers({
[16:05:06.594]             ...future.value <- base::withVisible(base::local({
[16:05:06.594]                 b <- a * ii
[16:05:06.594]                 a <- 0
[16:05:06.594]                 b
[16:05:06.594]             }))
[16:05:06.594]             future::FutureResult(value = ...future.value$value, 
[16:05:06.594]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.594]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.594]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.594]                     ...future.globalenv.names))
[16:05:06.594]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.594]         }, condition = base::local({
[16:05:06.594]             c <- base::c
[16:05:06.594]             inherits <- base::inherits
[16:05:06.594]             invokeRestart <- base::invokeRestart
[16:05:06.594]             length <- base::length
[16:05:06.594]             list <- base::list
[16:05:06.594]             seq.int <- base::seq.int
[16:05:06.594]             signalCondition <- base::signalCondition
[16:05:06.594]             sys.calls <- base::sys.calls
[16:05:06.594]             `[[` <- base::`[[`
[16:05:06.594]             `+` <- base::`+`
[16:05:06.594]             `<<-` <- base::`<<-`
[16:05:06.594]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.594]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.594]                   3L)]
[16:05:06.594]             }
[16:05:06.594]             function(cond) {
[16:05:06.594]                 is_error <- inherits(cond, "error")
[16:05:06.594]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.594]                   NULL)
[16:05:06.594]                 if (is_error) {
[16:05:06.594]                   sessionInformation <- function() {
[16:05:06.594]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.594]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.594]                       search = base::search(), system = base::Sys.info())
[16:05:06.594]                   }
[16:05:06.594]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.594]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.594]                     cond$call), session = sessionInformation(), 
[16:05:06.594]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.594]                   signalCondition(cond)
[16:05:06.594]                 }
[16:05:06.594]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.594]                 "immediateCondition"))) {
[16:05:06.594]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.594]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.594]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.594]                   if (TRUE && !signal) {
[16:05:06.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.594]                     {
[16:05:06.594]                       inherits <- base::inherits
[16:05:06.594]                       invokeRestart <- base::invokeRestart
[16:05:06.594]                       is.null <- base::is.null
[16:05:06.594]                       muffled <- FALSE
[16:05:06.594]                       if (inherits(cond, "message")) {
[16:05:06.594]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.594]                         if (muffled) 
[16:05:06.594]                           invokeRestart("muffleMessage")
[16:05:06.594]                       }
[16:05:06.594]                       else if (inherits(cond, "warning")) {
[16:05:06.594]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.594]                         if (muffled) 
[16:05:06.594]                           invokeRestart("muffleWarning")
[16:05:06.594]                       }
[16:05:06.594]                       else if (inherits(cond, "condition")) {
[16:05:06.594]                         if (!is.null(pattern)) {
[16:05:06.594]                           computeRestarts <- base::computeRestarts
[16:05:06.594]                           grepl <- base::grepl
[16:05:06.594]                           restarts <- computeRestarts(cond)
[16:05:06.594]                           for (restart in restarts) {
[16:05:06.594]                             name <- restart$name
[16:05:06.594]                             if (is.null(name)) 
[16:05:06.594]                               next
[16:05:06.594]                             if (!grepl(pattern, name)) 
[16:05:06.594]                               next
[16:05:06.594]                             invokeRestart(restart)
[16:05:06.594]                             muffled <- TRUE
[16:05:06.594]                             break
[16:05:06.594]                           }
[16:05:06.594]                         }
[16:05:06.594]                       }
[16:05:06.594]                       invisible(muffled)
[16:05:06.594]                     }
[16:05:06.594]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.594]                   }
[16:05:06.594]                 }
[16:05:06.594]                 else {
[16:05:06.594]                   if (TRUE) {
[16:05:06.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.594]                     {
[16:05:06.594]                       inherits <- base::inherits
[16:05:06.594]                       invokeRestart <- base::invokeRestart
[16:05:06.594]                       is.null <- base::is.null
[16:05:06.594]                       muffled <- FALSE
[16:05:06.594]                       if (inherits(cond, "message")) {
[16:05:06.594]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.594]                         if (muffled) 
[16:05:06.594]                           invokeRestart("muffleMessage")
[16:05:06.594]                       }
[16:05:06.594]                       else if (inherits(cond, "warning")) {
[16:05:06.594]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.594]                         if (muffled) 
[16:05:06.594]                           invokeRestart("muffleWarning")
[16:05:06.594]                       }
[16:05:06.594]                       else if (inherits(cond, "condition")) {
[16:05:06.594]                         if (!is.null(pattern)) {
[16:05:06.594]                           computeRestarts <- base::computeRestarts
[16:05:06.594]                           grepl <- base::grepl
[16:05:06.594]                           restarts <- computeRestarts(cond)
[16:05:06.594]                           for (restart in restarts) {
[16:05:06.594]                             name <- restart$name
[16:05:06.594]                             if (is.null(name)) 
[16:05:06.594]                               next
[16:05:06.594]                             if (!grepl(pattern, name)) 
[16:05:06.594]                               next
[16:05:06.594]                             invokeRestart(restart)
[16:05:06.594]                             muffled <- TRUE
[16:05:06.594]                             break
[16:05:06.594]                           }
[16:05:06.594]                         }
[16:05:06.594]                       }
[16:05:06.594]                       invisible(muffled)
[16:05:06.594]                     }
[16:05:06.594]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.594]                   }
[16:05:06.594]                 }
[16:05:06.594]             }
[16:05:06.594]         }))
[16:05:06.594]     }, error = function(ex) {
[16:05:06.594]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.594]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.594]                 ...future.rng), started = ...future.startTime, 
[16:05:06.594]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.594]             version = "1.8"), class = "FutureResult")
[16:05:06.594]     }, finally = {
[16:05:06.594]         if (!identical(...future.workdir, getwd())) 
[16:05:06.594]             setwd(...future.workdir)
[16:05:06.594]         {
[16:05:06.594]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.594]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.594]             }
[16:05:06.594]             base::options(...future.oldOptions)
[16:05:06.594]             if (.Platform$OS.type == "windows") {
[16:05:06.594]                 old_names <- names(...future.oldEnvVars)
[16:05:06.594]                 envs <- base::Sys.getenv()
[16:05:06.594]                 names <- names(envs)
[16:05:06.594]                 common <- intersect(names, old_names)
[16:05:06.594]                 added <- setdiff(names, old_names)
[16:05:06.594]                 removed <- setdiff(old_names, names)
[16:05:06.594]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.594]                   envs[common]]
[16:05:06.594]                 NAMES <- toupper(changed)
[16:05:06.594]                 args <- list()
[16:05:06.594]                 for (kk in seq_along(NAMES)) {
[16:05:06.594]                   name <- changed[[kk]]
[16:05:06.594]                   NAME <- NAMES[[kk]]
[16:05:06.594]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.594]                     next
[16:05:06.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.594]                 }
[16:05:06.594]                 NAMES <- toupper(added)
[16:05:06.594]                 for (kk in seq_along(NAMES)) {
[16:05:06.594]                   name <- added[[kk]]
[16:05:06.594]                   NAME <- NAMES[[kk]]
[16:05:06.594]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.594]                     next
[16:05:06.594]                   args[[name]] <- ""
[16:05:06.594]                 }
[16:05:06.594]                 NAMES <- toupper(removed)
[16:05:06.594]                 for (kk in seq_along(NAMES)) {
[16:05:06.594]                   name <- removed[[kk]]
[16:05:06.594]                   NAME <- NAMES[[kk]]
[16:05:06.594]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.594]                     next
[16:05:06.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.594]                 }
[16:05:06.594]                 if (length(args) > 0) 
[16:05:06.594]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.594]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.594]             }
[16:05:06.594]             else {
[16:05:06.594]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.594]             }
[16:05:06.594]             {
[16:05:06.594]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.594]                   0L) {
[16:05:06.594]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.594]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.594]                   base::options(opts)
[16:05:06.594]                 }
[16:05:06.594]                 {
[16:05:06.594]                   {
[16:05:06.594]                     NULL
[16:05:06.594]                     RNGkind("Mersenne-Twister")
[16:05:06.594]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.594]                       inherits = FALSE)
[16:05:06.594]                   }
[16:05:06.594]                   options(future.plan = NULL)
[16:05:06.594]                   if (is.na(NA_character_)) 
[16:05:06.594]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.594]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.594]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.594]                   {
[16:05:06.594]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.594]                     if (!future$lazy) 
[16:05:06.594]                       future <- run(future)
[16:05:06.594]                     invisible(future)
[16:05:06.594]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.594]                 }
[16:05:06.594]             }
[16:05:06.594]         }
[16:05:06.594]     })
[16:05:06.594]     if (TRUE) {
[16:05:06.594]         base::sink(type = "output", split = FALSE)
[16:05:06.594]         if (TRUE) {
[16:05:06.594]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.594]         }
[16:05:06.594]         else {
[16:05:06.594]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.594]         }
[16:05:06.594]         base::close(...future.stdout)
[16:05:06.594]         ...future.stdout <- NULL
[16:05:06.594]     }
[16:05:06.594]     ...future.result$conditions <- ...future.conditions
[16:05:06.594]     ...future.result$finished <- base::Sys.time()
[16:05:06.594]     ...future.result
[16:05:06.594] }
[16:05:06.596] assign_globals() ...
[16:05:06.596] List of 2
[16:05:06.596]  $ a : num 1
[16:05:06.596]  $ ii: int 2
[16:05:06.596]  - attr(*, "where")=List of 2
[16:05:06.596]   ..$ a :<environment: R_EmptyEnv> 
[16:05:06.596]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:06.596]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.596]  - attr(*, "resolved")= logi TRUE
[16:05:06.596]  - attr(*, "total_size")= num 112
[16:05:06.596]  - attr(*, "already-done")= logi TRUE
[16:05:06.599] - copied ‘a’ to environment
[16:05:06.599] - copied ‘ii’ to environment
[16:05:06.600] assign_globals() ... done
[16:05:06.600] plan(): Setting new future strategy stack:
[16:05:06.600] List of future strategies:
[16:05:06.600] 1. sequential:
[16:05:06.600]    - args: function (..., envir = parent.frame())
[16:05:06.600]    - tweaked: FALSE
[16:05:06.600]    - call: NULL
[16:05:06.600] plan(): nbrOfWorkers() = 1
[16:05:06.601] plan(): Setting new future strategy stack:
[16:05:06.601] List of future strategies:
[16:05:06.601] 1. sequential:
[16:05:06.601]    - args: function (..., envir = parent.frame())
[16:05:06.601]    - tweaked: FALSE
[16:05:06.601]    - call: plan(strategy)
[16:05:06.601] plan(): nbrOfWorkers() = 1
[16:05:06.602] SequentialFuture started (and completed)
[16:05:06.602] - Launch lazy future ... done
[16:05:06.602] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.602] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.602] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:06.606] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:06.606] Searching for globals ... DONE
[16:05:06.607] Resolving globals: TRUE
[16:05:06.607] Resolving any globals that are futures ...
[16:05:06.607] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:06.607] Resolving any globals that are futures ... DONE
[16:05:06.607] Resolving futures part of globals (recursively) ...
[16:05:06.607] resolve() on list ...
[16:05:06.608]  recursive: 99
[16:05:06.608]  length: 2
[16:05:06.608]  elements: ‘a’, ‘ii’
[16:05:06.608]  length: 1 (resolved future 1)
[16:05:06.608]  length: 0 (resolved future 2)
[16:05:06.608] resolve() on list ... DONE
[16:05:06.608] - globals: [2] ‘a’, ‘ii’
[16:05:06.608] Resolving futures part of globals (recursively) ... DONE
[16:05:06.608] The total size of the 2 globals is 112 bytes (112 bytes)
[16:05:06.609] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:05:06.609] - globals: [2] ‘a’, ‘ii’
[16:05:06.609] 
[16:05:06.609] getGlobalsAndPackages() ... DONE
[16:05:06.609] run() for ‘Future’ ...
[16:05:06.609] - state: ‘created’
[16:05:06.610] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.610] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.610] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.610]   - Field: ‘label’
[16:05:06.610]   - Field: ‘local’
[16:05:06.610]   - Field: ‘owner’
[16:05:06.610]   - Field: ‘envir’
[16:05:06.610]   - Field: ‘packages’
[16:05:06.611]   - Field: ‘gc’
[16:05:06.611]   - Field: ‘conditions’
[16:05:06.611]   - Field: ‘expr’
[16:05:06.611]   - Field: ‘uuid’
[16:05:06.611]   - Field: ‘seed’
[16:05:06.611]   - Field: ‘version’
[16:05:06.611]   - Field: ‘result’
[16:05:06.611]   - Field: ‘asynchronous’
[16:05:06.611]   - Field: ‘calls’
[16:05:06.611]   - Field: ‘globals’
[16:05:06.612]   - Field: ‘stdout’
[16:05:06.612]   - Field: ‘earlySignal’
[16:05:06.612]   - Field: ‘lazy’
[16:05:06.612]   - Field: ‘state’
[16:05:06.612] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.612] - Launch lazy future ...
[16:05:06.612] Packages needed by the future expression (n = 0): <none>
[16:05:06.612] Packages needed by future strategies (n = 0): <none>
[16:05:06.613] {
[16:05:06.613]     {
[16:05:06.613]         {
[16:05:06.613]             ...future.startTime <- base::Sys.time()
[16:05:06.613]             {
[16:05:06.613]                 {
[16:05:06.613]                   {
[16:05:06.613]                     base::local({
[16:05:06.613]                       has_future <- base::requireNamespace("future", 
[16:05:06.613]                         quietly = TRUE)
[16:05:06.613]                       if (has_future) {
[16:05:06.613]                         ns <- base::getNamespace("future")
[16:05:06.613]                         version <- ns[[".package"]][["version"]]
[16:05:06.613]                         if (is.null(version)) 
[16:05:06.613]                           version <- utils::packageVersion("future")
[16:05:06.613]                       }
[16:05:06.613]                       else {
[16:05:06.613]                         version <- NULL
[16:05:06.613]                       }
[16:05:06.613]                       if (!has_future || version < "1.8.0") {
[16:05:06.613]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.613]                           "", base::R.version$version.string), 
[16:05:06.613]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.613]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.613]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.613]                             "release", "version")], collapse = " "), 
[16:05:06.613]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.613]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.613]                           info)
[16:05:06.613]                         info <- base::paste(info, collapse = "; ")
[16:05:06.613]                         if (!has_future) {
[16:05:06.613]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.613]                             info)
[16:05:06.613]                         }
[16:05:06.613]                         else {
[16:05:06.613]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.613]                             info, version)
[16:05:06.613]                         }
[16:05:06.613]                         base::stop(msg)
[16:05:06.613]                       }
[16:05:06.613]                     })
[16:05:06.613]                   }
[16:05:06.613]                   options(future.plan = NULL)
[16:05:06.613]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.613]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.613]                 }
[16:05:06.613]                 ...future.workdir <- getwd()
[16:05:06.613]             }
[16:05:06.613]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.613]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.613]         }
[16:05:06.613]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.613]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:06.613]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.613]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.613]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.613]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.613]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.613]             base::names(...future.oldOptions))
[16:05:06.613]     }
[16:05:06.613]     if (FALSE) {
[16:05:06.613]     }
[16:05:06.613]     else {
[16:05:06.613]         if (TRUE) {
[16:05:06.613]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.613]                 open = "w")
[16:05:06.613]         }
[16:05:06.613]         else {
[16:05:06.613]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.613]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.613]         }
[16:05:06.613]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.613]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.613]             base::sink(type = "output", split = FALSE)
[16:05:06.613]             base::close(...future.stdout)
[16:05:06.613]         }, add = TRUE)
[16:05:06.613]     }
[16:05:06.613]     ...future.frame <- base::sys.nframe()
[16:05:06.613]     ...future.conditions <- base::list()
[16:05:06.613]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.613]     if (FALSE) {
[16:05:06.613]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.613]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.613]     }
[16:05:06.613]     ...future.result <- base::tryCatch({
[16:05:06.613]         base::withCallingHandlers({
[16:05:06.613]             ...future.value <- base::withVisible(base::local({
[16:05:06.613]                 b <- a * ii
[16:05:06.613]                 a <- 0
[16:05:06.613]                 b
[16:05:06.613]             }))
[16:05:06.613]             future::FutureResult(value = ...future.value$value, 
[16:05:06.613]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.613]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.613]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.613]                     ...future.globalenv.names))
[16:05:06.613]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.613]         }, condition = base::local({
[16:05:06.613]             c <- base::c
[16:05:06.613]             inherits <- base::inherits
[16:05:06.613]             invokeRestart <- base::invokeRestart
[16:05:06.613]             length <- base::length
[16:05:06.613]             list <- base::list
[16:05:06.613]             seq.int <- base::seq.int
[16:05:06.613]             signalCondition <- base::signalCondition
[16:05:06.613]             sys.calls <- base::sys.calls
[16:05:06.613]             `[[` <- base::`[[`
[16:05:06.613]             `+` <- base::`+`
[16:05:06.613]             `<<-` <- base::`<<-`
[16:05:06.613]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.613]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.613]                   3L)]
[16:05:06.613]             }
[16:05:06.613]             function(cond) {
[16:05:06.613]                 is_error <- inherits(cond, "error")
[16:05:06.613]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.613]                   NULL)
[16:05:06.613]                 if (is_error) {
[16:05:06.613]                   sessionInformation <- function() {
[16:05:06.613]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.613]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.613]                       search = base::search(), system = base::Sys.info())
[16:05:06.613]                   }
[16:05:06.613]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.613]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.613]                     cond$call), session = sessionInformation(), 
[16:05:06.613]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.613]                   signalCondition(cond)
[16:05:06.613]                 }
[16:05:06.613]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.613]                 "immediateCondition"))) {
[16:05:06.613]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.613]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.613]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.613]                   if (TRUE && !signal) {
[16:05:06.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.613]                     {
[16:05:06.613]                       inherits <- base::inherits
[16:05:06.613]                       invokeRestart <- base::invokeRestart
[16:05:06.613]                       is.null <- base::is.null
[16:05:06.613]                       muffled <- FALSE
[16:05:06.613]                       if (inherits(cond, "message")) {
[16:05:06.613]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.613]                         if (muffled) 
[16:05:06.613]                           invokeRestart("muffleMessage")
[16:05:06.613]                       }
[16:05:06.613]                       else if (inherits(cond, "warning")) {
[16:05:06.613]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.613]                         if (muffled) 
[16:05:06.613]                           invokeRestart("muffleWarning")
[16:05:06.613]                       }
[16:05:06.613]                       else if (inherits(cond, "condition")) {
[16:05:06.613]                         if (!is.null(pattern)) {
[16:05:06.613]                           computeRestarts <- base::computeRestarts
[16:05:06.613]                           grepl <- base::grepl
[16:05:06.613]                           restarts <- computeRestarts(cond)
[16:05:06.613]                           for (restart in restarts) {
[16:05:06.613]                             name <- restart$name
[16:05:06.613]                             if (is.null(name)) 
[16:05:06.613]                               next
[16:05:06.613]                             if (!grepl(pattern, name)) 
[16:05:06.613]                               next
[16:05:06.613]                             invokeRestart(restart)
[16:05:06.613]                             muffled <- TRUE
[16:05:06.613]                             break
[16:05:06.613]                           }
[16:05:06.613]                         }
[16:05:06.613]                       }
[16:05:06.613]                       invisible(muffled)
[16:05:06.613]                     }
[16:05:06.613]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.613]                   }
[16:05:06.613]                 }
[16:05:06.613]                 else {
[16:05:06.613]                   if (TRUE) {
[16:05:06.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.613]                     {
[16:05:06.613]                       inherits <- base::inherits
[16:05:06.613]                       invokeRestart <- base::invokeRestart
[16:05:06.613]                       is.null <- base::is.null
[16:05:06.613]                       muffled <- FALSE
[16:05:06.613]                       if (inherits(cond, "message")) {
[16:05:06.613]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.613]                         if (muffled) 
[16:05:06.613]                           invokeRestart("muffleMessage")
[16:05:06.613]                       }
[16:05:06.613]                       else if (inherits(cond, "warning")) {
[16:05:06.613]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.613]                         if (muffled) 
[16:05:06.613]                           invokeRestart("muffleWarning")
[16:05:06.613]                       }
[16:05:06.613]                       else if (inherits(cond, "condition")) {
[16:05:06.613]                         if (!is.null(pattern)) {
[16:05:06.613]                           computeRestarts <- base::computeRestarts
[16:05:06.613]                           grepl <- base::grepl
[16:05:06.613]                           restarts <- computeRestarts(cond)
[16:05:06.613]                           for (restart in restarts) {
[16:05:06.613]                             name <- restart$name
[16:05:06.613]                             if (is.null(name)) 
[16:05:06.613]                               next
[16:05:06.613]                             if (!grepl(pattern, name)) 
[16:05:06.613]                               next
[16:05:06.613]                             invokeRestart(restart)
[16:05:06.613]                             muffled <- TRUE
[16:05:06.613]                             break
[16:05:06.613]                           }
[16:05:06.613]                         }
[16:05:06.613]                       }
[16:05:06.613]                       invisible(muffled)
[16:05:06.613]                     }
[16:05:06.613]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.613]                   }
[16:05:06.613]                 }
[16:05:06.613]             }
[16:05:06.613]         }))
[16:05:06.613]     }, error = function(ex) {
[16:05:06.613]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.613]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.613]                 ...future.rng), started = ...future.startTime, 
[16:05:06.613]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.613]             version = "1.8"), class = "FutureResult")
[16:05:06.613]     }, finally = {
[16:05:06.613]         if (!identical(...future.workdir, getwd())) 
[16:05:06.613]             setwd(...future.workdir)
[16:05:06.613]         {
[16:05:06.613]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.613]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.613]             }
[16:05:06.613]             base::options(...future.oldOptions)
[16:05:06.613]             if (.Platform$OS.type == "windows") {
[16:05:06.613]                 old_names <- names(...future.oldEnvVars)
[16:05:06.613]                 envs <- base::Sys.getenv()
[16:05:06.613]                 names <- names(envs)
[16:05:06.613]                 common <- intersect(names, old_names)
[16:05:06.613]                 added <- setdiff(names, old_names)
[16:05:06.613]                 removed <- setdiff(old_names, names)
[16:05:06.613]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.613]                   envs[common]]
[16:05:06.613]                 NAMES <- toupper(changed)
[16:05:06.613]                 args <- list()
[16:05:06.613]                 for (kk in seq_along(NAMES)) {
[16:05:06.613]                   name <- changed[[kk]]
[16:05:06.613]                   NAME <- NAMES[[kk]]
[16:05:06.613]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.613]                     next
[16:05:06.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.613]                 }
[16:05:06.613]                 NAMES <- toupper(added)
[16:05:06.613]                 for (kk in seq_along(NAMES)) {
[16:05:06.613]                   name <- added[[kk]]
[16:05:06.613]                   NAME <- NAMES[[kk]]
[16:05:06.613]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.613]                     next
[16:05:06.613]                   args[[name]] <- ""
[16:05:06.613]                 }
[16:05:06.613]                 NAMES <- toupper(removed)
[16:05:06.613]                 for (kk in seq_along(NAMES)) {
[16:05:06.613]                   name <- removed[[kk]]
[16:05:06.613]                   NAME <- NAMES[[kk]]
[16:05:06.613]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.613]                     next
[16:05:06.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.613]                 }
[16:05:06.613]                 if (length(args) > 0) 
[16:05:06.613]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.613]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.613]             }
[16:05:06.613]             else {
[16:05:06.613]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.613]             }
[16:05:06.613]             {
[16:05:06.613]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.613]                   0L) {
[16:05:06.613]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.613]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.613]                   base::options(opts)
[16:05:06.613]                 }
[16:05:06.613]                 {
[16:05:06.613]                   {
[16:05:06.613]                     NULL
[16:05:06.613]                     RNGkind("Mersenne-Twister")
[16:05:06.613]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.613]                       inherits = FALSE)
[16:05:06.613]                   }
[16:05:06.613]                   options(future.plan = NULL)
[16:05:06.613]                   if (is.na(NA_character_)) 
[16:05:06.613]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.613]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.613]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.613]                   {
[16:05:06.613]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.613]                     if (!future$lazy) 
[16:05:06.613]                       future <- run(future)
[16:05:06.613]                     invisible(future)
[16:05:06.613]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.613]                 }
[16:05:06.613]             }
[16:05:06.613]         }
[16:05:06.613]     })
[16:05:06.613]     if (TRUE) {
[16:05:06.613]         base::sink(type = "output", split = FALSE)
[16:05:06.613]         if (TRUE) {
[16:05:06.613]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.613]         }
[16:05:06.613]         else {
[16:05:06.613]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.613]         }
[16:05:06.613]         base::close(...future.stdout)
[16:05:06.613]         ...future.stdout <- NULL
[16:05:06.613]     }
[16:05:06.613]     ...future.result$conditions <- ...future.conditions
[16:05:06.613]     ...future.result$finished <- base::Sys.time()
[16:05:06.613]     ...future.result
[16:05:06.613] }
[16:05:06.614] assign_globals() ...
[16:05:06.614] List of 2
[16:05:06.614]  $ a : num 1
[16:05:06.614]  $ ii: int 3
[16:05:06.614]  - attr(*, "where")=List of 2
[16:05:06.614]   ..$ a :<environment: R_EmptyEnv> 
[16:05:06.614]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:06.614]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.614]  - attr(*, "resolved")= logi TRUE
[16:05:06.614]  - attr(*, "total_size")= num 112
[16:05:06.614]  - attr(*, "already-done")= logi TRUE
[16:05:06.617] - copied ‘a’ to environment
[16:05:06.618] - copied ‘ii’ to environment
[16:05:06.618] assign_globals() ... done
[16:05:06.618] plan(): Setting new future strategy stack:
[16:05:06.618] List of future strategies:
[16:05:06.618] 1. sequential:
[16:05:06.618]    - args: function (..., envir = parent.frame())
[16:05:06.618]    - tweaked: FALSE
[16:05:06.618]    - call: NULL
[16:05:06.618] plan(): nbrOfWorkers() = 1
[16:05:06.619] plan(): Setting new future strategy stack:
[16:05:06.619] List of future strategies:
[16:05:06.619] 1. sequential:
[16:05:06.619]    - args: function (..., envir = parent.frame())
[16:05:06.619]    - tweaked: FALSE
[16:05:06.619]    - call: plan(strategy)
[16:05:06.620] plan(): nbrOfWorkers() = 1
[16:05:06.620] SequentialFuture started (and completed)
[16:05:06.620] - Launch lazy future ... done
[16:05:06.620] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.621] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.621] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:06.623] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:06.623] Searching for globals ... DONE
[16:05:06.623] Resolving globals: TRUE
[16:05:06.623] Resolving any globals that are futures ...
[16:05:06.623] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:06.623] Resolving any globals that are futures ... DONE
[16:05:06.624] Resolving futures part of globals (recursively) ...
[16:05:06.624] resolve() on list ...
[16:05:06.624]  recursive: 99
[16:05:06.624]  length: 2
[16:05:06.624]  elements: ‘a’, ‘ii’
[16:05:06.624]  length: 1 (resolved future 1)
[16:05:06.624]  length: 0 (resolved future 2)
[16:05:06.624] resolve() on list ... DONE
[16:05:06.625] - globals: [2] ‘a’, ‘ii’
[16:05:06.625] Resolving futures part of globals (recursively) ... DONE
[16:05:06.625] The total size of the 2 globals is 112 bytes (112 bytes)
[16:05:06.625] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:05:06.625] - globals: [2] ‘a’, ‘ii’
[16:05:06.625] 
[16:05:06.626] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.626] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.626] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:06.628] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:06.628] Searching for globals ... DONE
[16:05:06.628] Resolving globals: TRUE
[16:05:06.628] Resolving any globals that are futures ...
[16:05:06.630] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:06.630] Resolving any globals that are futures ... DONE
[16:05:06.631] Resolving futures part of globals (recursively) ...
[16:05:06.631] resolve() on list ...
[16:05:06.631]  recursive: 99
[16:05:06.631]  length: 2
[16:05:06.631]  elements: ‘a’, ‘ii’
[16:05:06.631]  length: 1 (resolved future 1)
[16:05:06.631]  length: 0 (resolved future 2)
[16:05:06.632] resolve() on list ... DONE
[16:05:06.632] - globals: [2] ‘a’, ‘ii’
[16:05:06.632] Resolving futures part of globals (recursively) ... DONE
[16:05:06.632] The total size of the 2 globals is 112 bytes (112 bytes)
[16:05:06.632] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:05:06.632] - globals: [2] ‘a’, ‘ii’
[16:05:06.633] 
[16:05:06.633] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.633] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.633] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:06.635] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:06.635] Searching for globals ... DONE
[16:05:06.635] Resolving globals: TRUE
[16:05:06.636] Resolving any globals that are futures ...
[16:05:06.636] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:06.636] Resolving any globals that are futures ... DONE
[16:05:06.636] Resolving futures part of globals (recursively) ...
[16:05:06.636] resolve() on list ...
[16:05:06.636]  recursive: 99
[16:05:06.636]  length: 2
[16:05:06.637]  elements: ‘a’, ‘ii’
[16:05:06.637]  length: 1 (resolved future 1)
[16:05:06.637]  length: 0 (resolved future 2)
[16:05:06.637] resolve() on list ... DONE
[16:05:06.637] - globals: [2] ‘a’, ‘ii’
[16:05:06.637] Resolving futures part of globals (recursively) ... DONE
[16:05:06.637] The total size of the 2 globals is 112 bytes (112 bytes)
[16:05:06.638] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:05:06.638] - globals: [2] ‘a’, ‘ii’
[16:05:06.638] 
[16:05:06.638] getGlobalsAndPackages() ... DONE
[16:05:06.638] run() for ‘Future’ ...
[16:05:06.638] - state: ‘created’
[16:05:06.638] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.639] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.639] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.639]   - Field: ‘label’
[16:05:06.639]   - Field: ‘local’
[16:05:06.639]   - Field: ‘owner’
[16:05:06.639]   - Field: ‘envir’
[16:05:06.639]   - Field: ‘packages’
[16:05:06.639]   - Field: ‘gc’
[16:05:06.640]   - Field: ‘conditions’
[16:05:06.640]   - Field: ‘expr’
[16:05:06.640]   - Field: ‘uuid’
[16:05:06.640]   - Field: ‘seed’
[16:05:06.640]   - Field: ‘version’
[16:05:06.640]   - Field: ‘result’
[16:05:06.640]   - Field: ‘asynchronous’
[16:05:06.640]   - Field: ‘calls’
[16:05:06.640]   - Field: ‘globals’
[16:05:06.640]   - Field: ‘stdout’
[16:05:06.640]   - Field: ‘earlySignal’
[16:05:06.641]   - Field: ‘lazy’
[16:05:06.641]   - Field: ‘state’
[16:05:06.641] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.641] - Launch lazy future ...
[16:05:06.641] Packages needed by the future expression (n = 0): <none>
[16:05:06.641] Packages needed by future strategies (n = 0): <none>
[16:05:06.641] {
[16:05:06.641]     {
[16:05:06.641]         {
[16:05:06.641]             ...future.startTime <- base::Sys.time()
[16:05:06.641]             {
[16:05:06.641]                 {
[16:05:06.641]                   {
[16:05:06.641]                     base::local({
[16:05:06.641]                       has_future <- base::requireNamespace("future", 
[16:05:06.641]                         quietly = TRUE)
[16:05:06.641]                       if (has_future) {
[16:05:06.641]                         ns <- base::getNamespace("future")
[16:05:06.641]                         version <- ns[[".package"]][["version"]]
[16:05:06.641]                         if (is.null(version)) 
[16:05:06.641]                           version <- utils::packageVersion("future")
[16:05:06.641]                       }
[16:05:06.641]                       else {
[16:05:06.641]                         version <- NULL
[16:05:06.641]                       }
[16:05:06.641]                       if (!has_future || version < "1.8.0") {
[16:05:06.641]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.641]                           "", base::R.version$version.string), 
[16:05:06.641]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.641]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.641]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.641]                             "release", "version")], collapse = " "), 
[16:05:06.641]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.641]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.641]                           info)
[16:05:06.641]                         info <- base::paste(info, collapse = "; ")
[16:05:06.641]                         if (!has_future) {
[16:05:06.641]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.641]                             info)
[16:05:06.641]                         }
[16:05:06.641]                         else {
[16:05:06.641]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.641]                             info, version)
[16:05:06.641]                         }
[16:05:06.641]                         base::stop(msg)
[16:05:06.641]                       }
[16:05:06.641]                     })
[16:05:06.641]                   }
[16:05:06.641]                   options(future.plan = NULL)
[16:05:06.641]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.641]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.641]                 }
[16:05:06.641]                 ...future.workdir <- getwd()
[16:05:06.641]             }
[16:05:06.641]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.641]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.641]         }
[16:05:06.641]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.641]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:06.641]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.641]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.641]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.641]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.641]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.641]             base::names(...future.oldOptions))
[16:05:06.641]     }
[16:05:06.641]     if (FALSE) {
[16:05:06.641]     }
[16:05:06.641]     else {
[16:05:06.641]         if (TRUE) {
[16:05:06.641]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.641]                 open = "w")
[16:05:06.641]         }
[16:05:06.641]         else {
[16:05:06.641]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.641]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.641]         }
[16:05:06.641]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.641]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.641]             base::sink(type = "output", split = FALSE)
[16:05:06.641]             base::close(...future.stdout)
[16:05:06.641]         }, add = TRUE)
[16:05:06.641]     }
[16:05:06.641]     ...future.frame <- base::sys.nframe()
[16:05:06.641]     ...future.conditions <- base::list()
[16:05:06.641]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.641]     if (FALSE) {
[16:05:06.641]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.641]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.641]     }
[16:05:06.641]     ...future.result <- base::tryCatch({
[16:05:06.641]         base::withCallingHandlers({
[16:05:06.641]             ...future.value <- base::withVisible(base::local({
[16:05:06.641]                 b <- a * ii
[16:05:06.641]                 a <- 0
[16:05:06.641]                 b
[16:05:06.641]             }))
[16:05:06.641]             future::FutureResult(value = ...future.value$value, 
[16:05:06.641]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.641]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.641]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.641]                     ...future.globalenv.names))
[16:05:06.641]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.641]         }, condition = base::local({
[16:05:06.641]             c <- base::c
[16:05:06.641]             inherits <- base::inherits
[16:05:06.641]             invokeRestart <- base::invokeRestart
[16:05:06.641]             length <- base::length
[16:05:06.641]             list <- base::list
[16:05:06.641]             seq.int <- base::seq.int
[16:05:06.641]             signalCondition <- base::signalCondition
[16:05:06.641]             sys.calls <- base::sys.calls
[16:05:06.641]             `[[` <- base::`[[`
[16:05:06.641]             `+` <- base::`+`
[16:05:06.641]             `<<-` <- base::`<<-`
[16:05:06.641]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.641]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.641]                   3L)]
[16:05:06.641]             }
[16:05:06.641]             function(cond) {
[16:05:06.641]                 is_error <- inherits(cond, "error")
[16:05:06.641]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.641]                   NULL)
[16:05:06.641]                 if (is_error) {
[16:05:06.641]                   sessionInformation <- function() {
[16:05:06.641]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.641]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.641]                       search = base::search(), system = base::Sys.info())
[16:05:06.641]                   }
[16:05:06.641]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.641]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.641]                     cond$call), session = sessionInformation(), 
[16:05:06.641]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.641]                   signalCondition(cond)
[16:05:06.641]                 }
[16:05:06.641]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.641]                 "immediateCondition"))) {
[16:05:06.641]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.641]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.641]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.641]                   if (TRUE && !signal) {
[16:05:06.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.641]                     {
[16:05:06.641]                       inherits <- base::inherits
[16:05:06.641]                       invokeRestart <- base::invokeRestart
[16:05:06.641]                       is.null <- base::is.null
[16:05:06.641]                       muffled <- FALSE
[16:05:06.641]                       if (inherits(cond, "message")) {
[16:05:06.641]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.641]                         if (muffled) 
[16:05:06.641]                           invokeRestart("muffleMessage")
[16:05:06.641]                       }
[16:05:06.641]                       else if (inherits(cond, "warning")) {
[16:05:06.641]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.641]                         if (muffled) 
[16:05:06.641]                           invokeRestart("muffleWarning")
[16:05:06.641]                       }
[16:05:06.641]                       else if (inherits(cond, "condition")) {
[16:05:06.641]                         if (!is.null(pattern)) {
[16:05:06.641]                           computeRestarts <- base::computeRestarts
[16:05:06.641]                           grepl <- base::grepl
[16:05:06.641]                           restarts <- computeRestarts(cond)
[16:05:06.641]                           for (restart in restarts) {
[16:05:06.641]                             name <- restart$name
[16:05:06.641]                             if (is.null(name)) 
[16:05:06.641]                               next
[16:05:06.641]                             if (!grepl(pattern, name)) 
[16:05:06.641]                               next
[16:05:06.641]                             invokeRestart(restart)
[16:05:06.641]                             muffled <- TRUE
[16:05:06.641]                             break
[16:05:06.641]                           }
[16:05:06.641]                         }
[16:05:06.641]                       }
[16:05:06.641]                       invisible(muffled)
[16:05:06.641]                     }
[16:05:06.641]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.641]                   }
[16:05:06.641]                 }
[16:05:06.641]                 else {
[16:05:06.641]                   if (TRUE) {
[16:05:06.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.641]                     {
[16:05:06.641]                       inherits <- base::inherits
[16:05:06.641]                       invokeRestart <- base::invokeRestart
[16:05:06.641]                       is.null <- base::is.null
[16:05:06.641]                       muffled <- FALSE
[16:05:06.641]                       if (inherits(cond, "message")) {
[16:05:06.641]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.641]                         if (muffled) 
[16:05:06.641]                           invokeRestart("muffleMessage")
[16:05:06.641]                       }
[16:05:06.641]                       else if (inherits(cond, "warning")) {
[16:05:06.641]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.641]                         if (muffled) 
[16:05:06.641]                           invokeRestart("muffleWarning")
[16:05:06.641]                       }
[16:05:06.641]                       else if (inherits(cond, "condition")) {
[16:05:06.641]                         if (!is.null(pattern)) {
[16:05:06.641]                           computeRestarts <- base::computeRestarts
[16:05:06.641]                           grepl <- base::grepl
[16:05:06.641]                           restarts <- computeRestarts(cond)
[16:05:06.641]                           for (restart in restarts) {
[16:05:06.641]                             name <- restart$name
[16:05:06.641]                             if (is.null(name)) 
[16:05:06.641]                               next
[16:05:06.641]                             if (!grepl(pattern, name)) 
[16:05:06.641]                               next
[16:05:06.641]                             invokeRestart(restart)
[16:05:06.641]                             muffled <- TRUE
[16:05:06.641]                             break
[16:05:06.641]                           }
[16:05:06.641]                         }
[16:05:06.641]                       }
[16:05:06.641]                       invisible(muffled)
[16:05:06.641]                     }
[16:05:06.641]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.641]                   }
[16:05:06.641]                 }
[16:05:06.641]             }
[16:05:06.641]         }))
[16:05:06.641]     }, error = function(ex) {
[16:05:06.641]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.641]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.641]                 ...future.rng), started = ...future.startTime, 
[16:05:06.641]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.641]             version = "1.8"), class = "FutureResult")
[16:05:06.641]     }, finally = {
[16:05:06.641]         if (!identical(...future.workdir, getwd())) 
[16:05:06.641]             setwd(...future.workdir)
[16:05:06.641]         {
[16:05:06.641]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.641]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.641]             }
[16:05:06.641]             base::options(...future.oldOptions)
[16:05:06.641]             if (.Platform$OS.type == "windows") {
[16:05:06.641]                 old_names <- names(...future.oldEnvVars)
[16:05:06.641]                 envs <- base::Sys.getenv()
[16:05:06.641]                 names <- names(envs)
[16:05:06.641]                 common <- intersect(names, old_names)
[16:05:06.641]                 added <- setdiff(names, old_names)
[16:05:06.641]                 removed <- setdiff(old_names, names)
[16:05:06.641]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.641]                   envs[common]]
[16:05:06.641]                 NAMES <- toupper(changed)
[16:05:06.641]                 args <- list()
[16:05:06.641]                 for (kk in seq_along(NAMES)) {
[16:05:06.641]                   name <- changed[[kk]]
[16:05:06.641]                   NAME <- NAMES[[kk]]
[16:05:06.641]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.641]                     next
[16:05:06.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.641]                 }
[16:05:06.641]                 NAMES <- toupper(added)
[16:05:06.641]                 for (kk in seq_along(NAMES)) {
[16:05:06.641]                   name <- added[[kk]]
[16:05:06.641]                   NAME <- NAMES[[kk]]
[16:05:06.641]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.641]                     next
[16:05:06.641]                   args[[name]] <- ""
[16:05:06.641]                 }
[16:05:06.641]                 NAMES <- toupper(removed)
[16:05:06.641]                 for (kk in seq_along(NAMES)) {
[16:05:06.641]                   name <- removed[[kk]]
[16:05:06.641]                   NAME <- NAMES[[kk]]
[16:05:06.641]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.641]                     next
[16:05:06.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.641]                 }
[16:05:06.641]                 if (length(args) > 0) 
[16:05:06.641]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.641]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.641]             }
[16:05:06.641]             else {
[16:05:06.641]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.641]             }
[16:05:06.641]             {
[16:05:06.641]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.641]                   0L) {
[16:05:06.641]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.641]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.641]                   base::options(opts)
[16:05:06.641]                 }
[16:05:06.641]                 {
[16:05:06.641]                   {
[16:05:06.641]                     NULL
[16:05:06.641]                     RNGkind("Mersenne-Twister")
[16:05:06.641]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.641]                       inherits = FALSE)
[16:05:06.641]                   }
[16:05:06.641]                   options(future.plan = NULL)
[16:05:06.641]                   if (is.na(NA_character_)) 
[16:05:06.641]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.641]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.641]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.641]                   {
[16:05:06.641]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.641]                     if (!future$lazy) 
[16:05:06.641]                       future <- run(future)
[16:05:06.641]                     invisible(future)
[16:05:06.641]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.641]                 }
[16:05:06.641]             }
[16:05:06.641]         }
[16:05:06.641]     })
[16:05:06.641]     if (TRUE) {
[16:05:06.641]         base::sink(type = "output", split = FALSE)
[16:05:06.641]         if (TRUE) {
[16:05:06.641]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.641]         }
[16:05:06.641]         else {
[16:05:06.641]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.641]         }
[16:05:06.641]         base::close(...future.stdout)
[16:05:06.641]         ...future.stdout <- NULL
[16:05:06.641]     }
[16:05:06.641]     ...future.result$conditions <- ...future.conditions
[16:05:06.641]     ...future.result$finished <- base::Sys.time()
[16:05:06.641]     ...future.result
[16:05:06.641] }
[16:05:06.643] assign_globals() ...
[16:05:06.643] List of 2
[16:05:06.643]  $ a : num 1
[16:05:06.643]  $ ii: int 1
[16:05:06.643]  - attr(*, "where")=List of 2
[16:05:06.643]   ..$ a :<environment: R_EmptyEnv> 
[16:05:06.643]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:06.643]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.643]  - attr(*, "resolved")= logi TRUE
[16:05:06.643]  - attr(*, "total_size")= num 112
[16:05:06.643]  - attr(*, "already-done")= logi TRUE
[16:05:06.646] - copied ‘a’ to environment
[16:05:06.646] - copied ‘ii’ to environment
[16:05:06.646] assign_globals() ... done
[16:05:06.647] plan(): Setting new future strategy stack:
[16:05:06.647] List of future strategies:
[16:05:06.647] 1. sequential:
[16:05:06.647]    - args: function (..., envir = parent.frame())
[16:05:06.647]    - tweaked: FALSE
[16:05:06.647]    - call: NULL
[16:05:06.647] plan(): nbrOfWorkers() = 1
[16:05:06.648] plan(): Setting new future strategy stack:
[16:05:06.648] List of future strategies:
[16:05:06.648] 1. sequential:
[16:05:06.648]    - args: function (..., envir = parent.frame())
[16:05:06.648]    - tweaked: FALSE
[16:05:06.648]    - call: plan(strategy)
[16:05:06.648] plan(): nbrOfWorkers() = 1
[16:05:06.648] SequentialFuture started (and completed)
[16:05:06.649] - Launch lazy future ... done
[16:05:06.649] run() for ‘SequentialFuture’ ... done
[16:05:06.649] run() for ‘Future’ ...
[16:05:06.649] - state: ‘created’
[16:05:06.649] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.649] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.649] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.650]   - Field: ‘label’
[16:05:06.650]   - Field: ‘local’
[16:05:06.650]   - Field: ‘owner’
[16:05:06.650]   - Field: ‘envir’
[16:05:06.650]   - Field: ‘packages’
[16:05:06.650]   - Field: ‘gc’
[16:05:06.650]   - Field: ‘conditions’
[16:05:06.650]   - Field: ‘expr’
[16:05:06.650]   - Field: ‘uuid’
[16:05:06.650]   - Field: ‘seed’
[16:05:06.650]   - Field: ‘version’
[16:05:06.651]   - Field: ‘result’
[16:05:06.651]   - Field: ‘asynchronous’
[16:05:06.651]   - Field: ‘calls’
[16:05:06.651]   - Field: ‘globals’
[16:05:06.651]   - Field: ‘stdout’
[16:05:06.651]   - Field: ‘earlySignal’
[16:05:06.651]   - Field: ‘lazy’
[16:05:06.651]   - Field: ‘state’
[16:05:06.651] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.651] - Launch lazy future ...
[16:05:06.652] Packages needed by the future expression (n = 0): <none>
[16:05:06.652] Packages needed by future strategies (n = 0): <none>
[16:05:06.652] {
[16:05:06.652]     {
[16:05:06.652]         {
[16:05:06.652]             ...future.startTime <- base::Sys.time()
[16:05:06.652]             {
[16:05:06.652]                 {
[16:05:06.652]                   {
[16:05:06.652]                     base::local({
[16:05:06.652]                       has_future <- base::requireNamespace("future", 
[16:05:06.652]                         quietly = TRUE)
[16:05:06.652]                       if (has_future) {
[16:05:06.652]                         ns <- base::getNamespace("future")
[16:05:06.652]                         version <- ns[[".package"]][["version"]]
[16:05:06.652]                         if (is.null(version)) 
[16:05:06.652]                           version <- utils::packageVersion("future")
[16:05:06.652]                       }
[16:05:06.652]                       else {
[16:05:06.652]                         version <- NULL
[16:05:06.652]                       }
[16:05:06.652]                       if (!has_future || version < "1.8.0") {
[16:05:06.652]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.652]                           "", base::R.version$version.string), 
[16:05:06.652]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.652]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.652]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.652]                             "release", "version")], collapse = " "), 
[16:05:06.652]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.652]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.652]                           info)
[16:05:06.652]                         info <- base::paste(info, collapse = "; ")
[16:05:06.652]                         if (!has_future) {
[16:05:06.652]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.652]                             info)
[16:05:06.652]                         }
[16:05:06.652]                         else {
[16:05:06.652]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.652]                             info, version)
[16:05:06.652]                         }
[16:05:06.652]                         base::stop(msg)
[16:05:06.652]                       }
[16:05:06.652]                     })
[16:05:06.652]                   }
[16:05:06.652]                   options(future.plan = NULL)
[16:05:06.652]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.652]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.652]                 }
[16:05:06.652]                 ...future.workdir <- getwd()
[16:05:06.652]             }
[16:05:06.652]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.652]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.652]         }
[16:05:06.652]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.652]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:06.652]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.652]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.652]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.652]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.652]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.652]             base::names(...future.oldOptions))
[16:05:06.652]     }
[16:05:06.652]     if (FALSE) {
[16:05:06.652]     }
[16:05:06.652]     else {
[16:05:06.652]         if (TRUE) {
[16:05:06.652]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.652]                 open = "w")
[16:05:06.652]         }
[16:05:06.652]         else {
[16:05:06.652]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.652]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.652]         }
[16:05:06.652]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.652]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.652]             base::sink(type = "output", split = FALSE)
[16:05:06.652]             base::close(...future.stdout)
[16:05:06.652]         }, add = TRUE)
[16:05:06.652]     }
[16:05:06.652]     ...future.frame <- base::sys.nframe()
[16:05:06.652]     ...future.conditions <- base::list()
[16:05:06.652]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.652]     if (FALSE) {
[16:05:06.652]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.652]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.652]     }
[16:05:06.652]     ...future.result <- base::tryCatch({
[16:05:06.652]         base::withCallingHandlers({
[16:05:06.652]             ...future.value <- base::withVisible(base::local({
[16:05:06.652]                 b <- a * ii
[16:05:06.652]                 a <- 0
[16:05:06.652]                 b
[16:05:06.652]             }))
[16:05:06.652]             future::FutureResult(value = ...future.value$value, 
[16:05:06.652]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.652]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.652]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.652]                     ...future.globalenv.names))
[16:05:06.652]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.652]         }, condition = base::local({
[16:05:06.652]             c <- base::c
[16:05:06.652]             inherits <- base::inherits
[16:05:06.652]             invokeRestart <- base::invokeRestart
[16:05:06.652]             length <- base::length
[16:05:06.652]             list <- base::list
[16:05:06.652]             seq.int <- base::seq.int
[16:05:06.652]             signalCondition <- base::signalCondition
[16:05:06.652]             sys.calls <- base::sys.calls
[16:05:06.652]             `[[` <- base::`[[`
[16:05:06.652]             `+` <- base::`+`
[16:05:06.652]             `<<-` <- base::`<<-`
[16:05:06.652]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.652]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.652]                   3L)]
[16:05:06.652]             }
[16:05:06.652]             function(cond) {
[16:05:06.652]                 is_error <- inherits(cond, "error")
[16:05:06.652]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.652]                   NULL)
[16:05:06.652]                 if (is_error) {
[16:05:06.652]                   sessionInformation <- function() {
[16:05:06.652]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.652]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.652]                       search = base::search(), system = base::Sys.info())
[16:05:06.652]                   }
[16:05:06.652]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.652]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.652]                     cond$call), session = sessionInformation(), 
[16:05:06.652]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.652]                   signalCondition(cond)
[16:05:06.652]                 }
[16:05:06.652]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.652]                 "immediateCondition"))) {
[16:05:06.652]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.652]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.652]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.652]                   if (TRUE && !signal) {
[16:05:06.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.652]                     {
[16:05:06.652]                       inherits <- base::inherits
[16:05:06.652]                       invokeRestart <- base::invokeRestart
[16:05:06.652]                       is.null <- base::is.null
[16:05:06.652]                       muffled <- FALSE
[16:05:06.652]                       if (inherits(cond, "message")) {
[16:05:06.652]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.652]                         if (muffled) 
[16:05:06.652]                           invokeRestart("muffleMessage")
[16:05:06.652]                       }
[16:05:06.652]                       else if (inherits(cond, "warning")) {
[16:05:06.652]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.652]                         if (muffled) 
[16:05:06.652]                           invokeRestart("muffleWarning")
[16:05:06.652]                       }
[16:05:06.652]                       else if (inherits(cond, "condition")) {
[16:05:06.652]                         if (!is.null(pattern)) {
[16:05:06.652]                           computeRestarts <- base::computeRestarts
[16:05:06.652]                           grepl <- base::grepl
[16:05:06.652]                           restarts <- computeRestarts(cond)
[16:05:06.652]                           for (restart in restarts) {
[16:05:06.652]                             name <- restart$name
[16:05:06.652]                             if (is.null(name)) 
[16:05:06.652]                               next
[16:05:06.652]                             if (!grepl(pattern, name)) 
[16:05:06.652]                               next
[16:05:06.652]                             invokeRestart(restart)
[16:05:06.652]                             muffled <- TRUE
[16:05:06.652]                             break
[16:05:06.652]                           }
[16:05:06.652]                         }
[16:05:06.652]                       }
[16:05:06.652]                       invisible(muffled)
[16:05:06.652]                     }
[16:05:06.652]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.652]                   }
[16:05:06.652]                 }
[16:05:06.652]                 else {
[16:05:06.652]                   if (TRUE) {
[16:05:06.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.652]                     {
[16:05:06.652]                       inherits <- base::inherits
[16:05:06.652]                       invokeRestart <- base::invokeRestart
[16:05:06.652]                       is.null <- base::is.null
[16:05:06.652]                       muffled <- FALSE
[16:05:06.652]                       if (inherits(cond, "message")) {
[16:05:06.652]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.652]                         if (muffled) 
[16:05:06.652]                           invokeRestart("muffleMessage")
[16:05:06.652]                       }
[16:05:06.652]                       else if (inherits(cond, "warning")) {
[16:05:06.652]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.652]                         if (muffled) 
[16:05:06.652]                           invokeRestart("muffleWarning")
[16:05:06.652]                       }
[16:05:06.652]                       else if (inherits(cond, "condition")) {
[16:05:06.652]                         if (!is.null(pattern)) {
[16:05:06.652]                           computeRestarts <- base::computeRestarts
[16:05:06.652]                           grepl <- base::grepl
[16:05:06.652]                           restarts <- computeRestarts(cond)
[16:05:06.652]                           for (restart in restarts) {
[16:05:06.652]                             name <- restart$name
[16:05:06.652]                             if (is.null(name)) 
[16:05:06.652]                               next
[16:05:06.652]                             if (!grepl(pattern, name)) 
[16:05:06.652]                               next
[16:05:06.652]                             invokeRestart(restart)
[16:05:06.652]                             muffled <- TRUE
[16:05:06.652]                             break
[16:05:06.652]                           }
[16:05:06.652]                         }
[16:05:06.652]                       }
[16:05:06.652]                       invisible(muffled)
[16:05:06.652]                     }
[16:05:06.652]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.652]                   }
[16:05:06.652]                 }
[16:05:06.652]             }
[16:05:06.652]         }))
[16:05:06.652]     }, error = function(ex) {
[16:05:06.652]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.652]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.652]                 ...future.rng), started = ...future.startTime, 
[16:05:06.652]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.652]             version = "1.8"), class = "FutureResult")
[16:05:06.652]     }, finally = {
[16:05:06.652]         if (!identical(...future.workdir, getwd())) 
[16:05:06.652]             setwd(...future.workdir)
[16:05:06.652]         {
[16:05:06.652]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.652]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.652]             }
[16:05:06.652]             base::options(...future.oldOptions)
[16:05:06.652]             if (.Platform$OS.type == "windows") {
[16:05:06.652]                 old_names <- names(...future.oldEnvVars)
[16:05:06.652]                 envs <- base::Sys.getenv()
[16:05:06.652]                 names <- names(envs)
[16:05:06.652]                 common <- intersect(names, old_names)
[16:05:06.652]                 added <- setdiff(names, old_names)
[16:05:06.652]                 removed <- setdiff(old_names, names)
[16:05:06.652]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.652]                   envs[common]]
[16:05:06.652]                 NAMES <- toupper(changed)
[16:05:06.652]                 args <- list()
[16:05:06.652]                 for (kk in seq_along(NAMES)) {
[16:05:06.652]                   name <- changed[[kk]]
[16:05:06.652]                   NAME <- NAMES[[kk]]
[16:05:06.652]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.652]                     next
[16:05:06.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.652]                 }
[16:05:06.652]                 NAMES <- toupper(added)
[16:05:06.652]                 for (kk in seq_along(NAMES)) {
[16:05:06.652]                   name <- added[[kk]]
[16:05:06.652]                   NAME <- NAMES[[kk]]
[16:05:06.652]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.652]                     next
[16:05:06.652]                   args[[name]] <- ""
[16:05:06.652]                 }
[16:05:06.652]                 NAMES <- toupper(removed)
[16:05:06.652]                 for (kk in seq_along(NAMES)) {
[16:05:06.652]                   name <- removed[[kk]]
[16:05:06.652]                   NAME <- NAMES[[kk]]
[16:05:06.652]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.652]                     next
[16:05:06.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.652]                 }
[16:05:06.652]                 if (length(args) > 0) 
[16:05:06.652]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.652]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.652]             }
[16:05:06.652]             else {
[16:05:06.652]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.652]             }
[16:05:06.652]             {
[16:05:06.652]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.652]                   0L) {
[16:05:06.652]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.652]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.652]                   base::options(opts)
[16:05:06.652]                 }
[16:05:06.652]                 {
[16:05:06.652]                   {
[16:05:06.652]                     NULL
[16:05:06.652]                     RNGkind("Mersenne-Twister")
[16:05:06.652]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.652]                       inherits = FALSE)
[16:05:06.652]                   }
[16:05:06.652]                   options(future.plan = NULL)
[16:05:06.652]                   if (is.na(NA_character_)) 
[16:05:06.652]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.652]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.652]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.652]                   {
[16:05:06.652]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.652]                     if (!future$lazy) 
[16:05:06.652]                       future <- run(future)
[16:05:06.652]                     invisible(future)
[16:05:06.652]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.652]                 }
[16:05:06.652]             }
[16:05:06.652]         }
[16:05:06.652]     })
[16:05:06.652]     if (TRUE) {
[16:05:06.652]         base::sink(type = "output", split = FALSE)
[16:05:06.652]         if (TRUE) {
[16:05:06.652]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.652]         }
[16:05:06.652]         else {
[16:05:06.652]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.652]         }
[16:05:06.652]         base::close(...future.stdout)
[16:05:06.652]         ...future.stdout <- NULL
[16:05:06.652]     }
[16:05:06.652]     ...future.result$conditions <- ...future.conditions
[16:05:06.652]     ...future.result$finished <- base::Sys.time()
[16:05:06.652]     ...future.result
[16:05:06.652] }
[16:05:06.654] assign_globals() ...
[16:05:06.654] List of 2
[16:05:06.654]  $ a : num 1
[16:05:06.654]  $ ii: int 2
[16:05:06.654]  - attr(*, "where")=List of 2
[16:05:06.654]   ..$ a :<environment: R_EmptyEnv> 
[16:05:06.654]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:06.654]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.654]  - attr(*, "resolved")= logi TRUE
[16:05:06.654]  - attr(*, "total_size")= num 112
[16:05:06.654]  - attr(*, "already-done")= logi TRUE
[16:05:06.659] - copied ‘a’ to environment
[16:05:06.659] - copied ‘ii’ to environment
[16:05:06.659] assign_globals() ... done
[16:05:06.659] plan(): Setting new future strategy stack:
[16:05:06.659] List of future strategies:
[16:05:06.659] 1. sequential:
[16:05:06.659]    - args: function (..., envir = parent.frame())
[16:05:06.659]    - tweaked: FALSE
[16:05:06.659]    - call: NULL
[16:05:06.660] plan(): nbrOfWorkers() = 1
[16:05:06.660] plan(): Setting new future strategy stack:
[16:05:06.660] List of future strategies:
[16:05:06.660] 1. sequential:
[16:05:06.660]    - args: function (..., envir = parent.frame())
[16:05:06.660]    - tweaked: FALSE
[16:05:06.660]    - call: plan(strategy)
[16:05:06.661] plan(): nbrOfWorkers() = 1
[16:05:06.661] SequentialFuture started (and completed)
[16:05:06.661] - Launch lazy future ... done
[16:05:06.661] run() for ‘SequentialFuture’ ... done
[16:05:06.661] run() for ‘Future’ ...
[16:05:06.661] - state: ‘created’
[16:05:06.661] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.662] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.662] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.662]   - Field: ‘label’
[16:05:06.662]   - Field: ‘local’
[16:05:06.662]   - Field: ‘owner’
[16:05:06.662]   - Field: ‘envir’
[16:05:06.662]   - Field: ‘packages’
[16:05:06.662]   - Field: ‘gc’
[16:05:06.663]   - Field: ‘conditions’
[16:05:06.663]   - Field: ‘expr’
[16:05:06.663]   - Field: ‘uuid’
[16:05:06.663]   - Field: ‘seed’
[16:05:06.663]   - Field: ‘version’
[16:05:06.663]   - Field: ‘result’
[16:05:06.663]   - Field: ‘asynchronous’
[16:05:06.663]   - Field: ‘calls’
[16:05:06.663]   - Field: ‘globals’
[16:05:06.663]   - Field: ‘stdout’
[16:05:06.663]   - Field: ‘earlySignal’
[16:05:06.664]   - Field: ‘lazy’
[16:05:06.664]   - Field: ‘state’
[16:05:06.664] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.664] - Launch lazy future ...
[16:05:06.664] Packages needed by the future expression (n = 0): <none>
[16:05:06.664] Packages needed by future strategies (n = 0): <none>
[16:05:06.665] {
[16:05:06.665]     {
[16:05:06.665]         {
[16:05:06.665]             ...future.startTime <- base::Sys.time()
[16:05:06.665]             {
[16:05:06.665]                 {
[16:05:06.665]                   {
[16:05:06.665]                     base::local({
[16:05:06.665]                       has_future <- base::requireNamespace("future", 
[16:05:06.665]                         quietly = TRUE)
[16:05:06.665]                       if (has_future) {
[16:05:06.665]                         ns <- base::getNamespace("future")
[16:05:06.665]                         version <- ns[[".package"]][["version"]]
[16:05:06.665]                         if (is.null(version)) 
[16:05:06.665]                           version <- utils::packageVersion("future")
[16:05:06.665]                       }
[16:05:06.665]                       else {
[16:05:06.665]                         version <- NULL
[16:05:06.665]                       }
[16:05:06.665]                       if (!has_future || version < "1.8.0") {
[16:05:06.665]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.665]                           "", base::R.version$version.string), 
[16:05:06.665]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.665]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.665]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.665]                             "release", "version")], collapse = " "), 
[16:05:06.665]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.665]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.665]                           info)
[16:05:06.665]                         info <- base::paste(info, collapse = "; ")
[16:05:06.665]                         if (!has_future) {
[16:05:06.665]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.665]                             info)
[16:05:06.665]                         }
[16:05:06.665]                         else {
[16:05:06.665]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.665]                             info, version)
[16:05:06.665]                         }
[16:05:06.665]                         base::stop(msg)
[16:05:06.665]                       }
[16:05:06.665]                     })
[16:05:06.665]                   }
[16:05:06.665]                   options(future.plan = NULL)
[16:05:06.665]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.665]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.665]                 }
[16:05:06.665]                 ...future.workdir <- getwd()
[16:05:06.665]             }
[16:05:06.665]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.665]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.665]         }
[16:05:06.665]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.665]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:06.665]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.665]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.665]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.665]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.665]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.665]             base::names(...future.oldOptions))
[16:05:06.665]     }
[16:05:06.665]     if (FALSE) {
[16:05:06.665]     }
[16:05:06.665]     else {
[16:05:06.665]         if (TRUE) {
[16:05:06.665]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.665]                 open = "w")
[16:05:06.665]         }
[16:05:06.665]         else {
[16:05:06.665]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.665]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.665]         }
[16:05:06.665]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.665]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.665]             base::sink(type = "output", split = FALSE)
[16:05:06.665]             base::close(...future.stdout)
[16:05:06.665]         }, add = TRUE)
[16:05:06.665]     }
[16:05:06.665]     ...future.frame <- base::sys.nframe()
[16:05:06.665]     ...future.conditions <- base::list()
[16:05:06.665]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.665]     if (FALSE) {
[16:05:06.665]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.665]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.665]     }
[16:05:06.665]     ...future.result <- base::tryCatch({
[16:05:06.665]         base::withCallingHandlers({
[16:05:06.665]             ...future.value <- base::withVisible(base::local({
[16:05:06.665]                 b <- a * ii
[16:05:06.665]                 a <- 0
[16:05:06.665]                 b
[16:05:06.665]             }))
[16:05:06.665]             future::FutureResult(value = ...future.value$value, 
[16:05:06.665]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.665]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.665]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.665]                     ...future.globalenv.names))
[16:05:06.665]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.665]         }, condition = base::local({
[16:05:06.665]             c <- base::c
[16:05:06.665]             inherits <- base::inherits
[16:05:06.665]             invokeRestart <- base::invokeRestart
[16:05:06.665]             length <- base::length
[16:05:06.665]             list <- base::list
[16:05:06.665]             seq.int <- base::seq.int
[16:05:06.665]             signalCondition <- base::signalCondition
[16:05:06.665]             sys.calls <- base::sys.calls
[16:05:06.665]             `[[` <- base::`[[`
[16:05:06.665]             `+` <- base::`+`
[16:05:06.665]             `<<-` <- base::`<<-`
[16:05:06.665]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.665]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.665]                   3L)]
[16:05:06.665]             }
[16:05:06.665]             function(cond) {
[16:05:06.665]                 is_error <- inherits(cond, "error")
[16:05:06.665]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.665]                   NULL)
[16:05:06.665]                 if (is_error) {
[16:05:06.665]                   sessionInformation <- function() {
[16:05:06.665]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.665]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.665]                       search = base::search(), system = base::Sys.info())
[16:05:06.665]                   }
[16:05:06.665]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.665]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.665]                     cond$call), session = sessionInformation(), 
[16:05:06.665]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.665]                   signalCondition(cond)
[16:05:06.665]                 }
[16:05:06.665]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.665]                 "immediateCondition"))) {
[16:05:06.665]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.665]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.665]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.665]                   if (TRUE && !signal) {
[16:05:06.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.665]                     {
[16:05:06.665]                       inherits <- base::inherits
[16:05:06.665]                       invokeRestart <- base::invokeRestart
[16:05:06.665]                       is.null <- base::is.null
[16:05:06.665]                       muffled <- FALSE
[16:05:06.665]                       if (inherits(cond, "message")) {
[16:05:06.665]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.665]                         if (muffled) 
[16:05:06.665]                           invokeRestart("muffleMessage")
[16:05:06.665]                       }
[16:05:06.665]                       else if (inherits(cond, "warning")) {
[16:05:06.665]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.665]                         if (muffled) 
[16:05:06.665]                           invokeRestart("muffleWarning")
[16:05:06.665]                       }
[16:05:06.665]                       else if (inherits(cond, "condition")) {
[16:05:06.665]                         if (!is.null(pattern)) {
[16:05:06.665]                           computeRestarts <- base::computeRestarts
[16:05:06.665]                           grepl <- base::grepl
[16:05:06.665]                           restarts <- computeRestarts(cond)
[16:05:06.665]                           for (restart in restarts) {
[16:05:06.665]                             name <- restart$name
[16:05:06.665]                             if (is.null(name)) 
[16:05:06.665]                               next
[16:05:06.665]                             if (!grepl(pattern, name)) 
[16:05:06.665]                               next
[16:05:06.665]                             invokeRestart(restart)
[16:05:06.665]                             muffled <- TRUE
[16:05:06.665]                             break
[16:05:06.665]                           }
[16:05:06.665]                         }
[16:05:06.665]                       }
[16:05:06.665]                       invisible(muffled)
[16:05:06.665]                     }
[16:05:06.665]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.665]                   }
[16:05:06.665]                 }
[16:05:06.665]                 else {
[16:05:06.665]                   if (TRUE) {
[16:05:06.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.665]                     {
[16:05:06.665]                       inherits <- base::inherits
[16:05:06.665]                       invokeRestart <- base::invokeRestart
[16:05:06.665]                       is.null <- base::is.null
[16:05:06.665]                       muffled <- FALSE
[16:05:06.665]                       if (inherits(cond, "message")) {
[16:05:06.665]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.665]                         if (muffled) 
[16:05:06.665]                           invokeRestart("muffleMessage")
[16:05:06.665]                       }
[16:05:06.665]                       else if (inherits(cond, "warning")) {
[16:05:06.665]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.665]                         if (muffled) 
[16:05:06.665]                           invokeRestart("muffleWarning")
[16:05:06.665]                       }
[16:05:06.665]                       else if (inherits(cond, "condition")) {
[16:05:06.665]                         if (!is.null(pattern)) {
[16:05:06.665]                           computeRestarts <- base::computeRestarts
[16:05:06.665]                           grepl <- base::grepl
[16:05:06.665]                           restarts <- computeRestarts(cond)
[16:05:06.665]                           for (restart in restarts) {
[16:05:06.665]                             name <- restart$name
[16:05:06.665]                             if (is.null(name)) 
[16:05:06.665]                               next
[16:05:06.665]                             if (!grepl(pattern, name)) 
[16:05:06.665]                               next
[16:05:06.665]                             invokeRestart(restart)
[16:05:06.665]                             muffled <- TRUE
[16:05:06.665]                             break
[16:05:06.665]                           }
[16:05:06.665]                         }
[16:05:06.665]                       }
[16:05:06.665]                       invisible(muffled)
[16:05:06.665]                     }
[16:05:06.665]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.665]                   }
[16:05:06.665]                 }
[16:05:06.665]             }
[16:05:06.665]         }))
[16:05:06.665]     }, error = function(ex) {
[16:05:06.665]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.665]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.665]                 ...future.rng), started = ...future.startTime, 
[16:05:06.665]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.665]             version = "1.8"), class = "FutureResult")
[16:05:06.665]     }, finally = {
[16:05:06.665]         if (!identical(...future.workdir, getwd())) 
[16:05:06.665]             setwd(...future.workdir)
[16:05:06.665]         {
[16:05:06.665]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.665]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.665]             }
[16:05:06.665]             base::options(...future.oldOptions)
[16:05:06.665]             if (.Platform$OS.type == "windows") {
[16:05:06.665]                 old_names <- names(...future.oldEnvVars)
[16:05:06.665]                 envs <- base::Sys.getenv()
[16:05:06.665]                 names <- names(envs)
[16:05:06.665]                 common <- intersect(names, old_names)
[16:05:06.665]                 added <- setdiff(names, old_names)
[16:05:06.665]                 removed <- setdiff(old_names, names)
[16:05:06.665]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.665]                   envs[common]]
[16:05:06.665]                 NAMES <- toupper(changed)
[16:05:06.665]                 args <- list()
[16:05:06.665]                 for (kk in seq_along(NAMES)) {
[16:05:06.665]                   name <- changed[[kk]]
[16:05:06.665]                   NAME <- NAMES[[kk]]
[16:05:06.665]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.665]                     next
[16:05:06.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.665]                 }
[16:05:06.665]                 NAMES <- toupper(added)
[16:05:06.665]                 for (kk in seq_along(NAMES)) {
[16:05:06.665]                   name <- added[[kk]]
[16:05:06.665]                   NAME <- NAMES[[kk]]
[16:05:06.665]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.665]                     next
[16:05:06.665]                   args[[name]] <- ""
[16:05:06.665]                 }
[16:05:06.665]                 NAMES <- toupper(removed)
[16:05:06.665]                 for (kk in seq_along(NAMES)) {
[16:05:06.665]                   name <- removed[[kk]]
[16:05:06.665]                   NAME <- NAMES[[kk]]
[16:05:06.665]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.665]                     next
[16:05:06.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.665]                 }
[16:05:06.665]                 if (length(args) > 0) 
[16:05:06.665]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.665]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.665]             }
[16:05:06.665]             else {
[16:05:06.665]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.665]             }
[16:05:06.665]             {
[16:05:06.665]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.665]                   0L) {
[16:05:06.665]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.665]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.665]                   base::options(opts)
[16:05:06.665]                 }
[16:05:06.665]                 {
[16:05:06.665]                   {
[16:05:06.665]                     NULL
[16:05:06.665]                     RNGkind("Mersenne-Twister")
[16:05:06.665]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.665]                       inherits = FALSE)
[16:05:06.665]                   }
[16:05:06.665]                   options(future.plan = NULL)
[16:05:06.665]                   if (is.na(NA_character_)) 
[16:05:06.665]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.665]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.665]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.665]                   {
[16:05:06.665]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.665]                     if (!future$lazy) 
[16:05:06.665]                       future <- run(future)
[16:05:06.665]                     invisible(future)
[16:05:06.665]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.665]                 }
[16:05:06.665]             }
[16:05:06.665]         }
[16:05:06.665]     })
[16:05:06.665]     if (TRUE) {
[16:05:06.665]         base::sink(type = "output", split = FALSE)
[16:05:06.665]         if (TRUE) {
[16:05:06.665]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.665]         }
[16:05:06.665]         else {
[16:05:06.665]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.665]         }
[16:05:06.665]         base::close(...future.stdout)
[16:05:06.665]         ...future.stdout <- NULL
[16:05:06.665]     }
[16:05:06.665]     ...future.result$conditions <- ...future.conditions
[16:05:06.665]     ...future.result$finished <- base::Sys.time()
[16:05:06.665]     ...future.result
[16:05:06.665] }
[16:05:06.666] assign_globals() ...
[16:05:06.666] List of 2
[16:05:06.666]  $ a : num 1
[16:05:06.666]  $ ii: int 3
[16:05:06.666]  - attr(*, "where")=List of 2
[16:05:06.666]   ..$ a :<environment: R_EmptyEnv> 
[16:05:06.666]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:06.666]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.666]  - attr(*, "resolved")= logi TRUE
[16:05:06.666]  - attr(*, "total_size")= num 112
[16:05:06.666]  - attr(*, "already-done")= logi TRUE
[16:05:06.669] - copied ‘a’ to environment
[16:05:06.669] - copied ‘ii’ to environment
[16:05:06.669] assign_globals() ... done
[16:05:06.669] plan(): Setting new future strategy stack:
[16:05:06.670] List of future strategies:
[16:05:06.670] 1. sequential:
[16:05:06.670]    - args: function (..., envir = parent.frame())
[16:05:06.670]    - tweaked: FALSE
[16:05:06.670]    - call: NULL
[16:05:06.670] plan(): nbrOfWorkers() = 1
[16:05:06.671] plan(): Setting new future strategy stack:
[16:05:06.671] List of future strategies:
[16:05:06.671] 1. sequential:
[16:05:06.671]    - args: function (..., envir = parent.frame())
[16:05:06.671]    - tweaked: FALSE
[16:05:06.671]    - call: plan(strategy)
[16:05:06.671] plan(): nbrOfWorkers() = 1
[16:05:06.671] SequentialFuture started (and completed)
[16:05:06.671] - Launch lazy future ... done
[16:05:06.671] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.672] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.672] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:06.672] 
[16:05:06.672] Searching for globals ... DONE
[16:05:06.673] - globals: [0] <none>
[16:05:06.673] getGlobalsAndPackages() ... DONE
[16:05:06.673] run() for ‘Future’ ...
[16:05:06.673] - state: ‘created’
[16:05:06.673] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.673] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.673] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.674]   - Field: ‘label’
[16:05:06.674]   - Field: ‘local’
[16:05:06.674]   - Field: ‘owner’
[16:05:06.674]   - Field: ‘envir’
[16:05:06.674]   - Field: ‘packages’
[16:05:06.674]   - Field: ‘gc’
[16:05:06.674]   - Field: ‘conditions’
[16:05:06.674]   - Field: ‘expr’
[16:05:06.674]   - Field: ‘uuid’
[16:05:06.674]   - Field: ‘seed’
[16:05:06.674]   - Field: ‘version’
[16:05:06.675]   - Field: ‘result’
[16:05:06.675]   - Field: ‘asynchronous’
[16:05:06.675]   - Field: ‘calls’
[16:05:06.675]   - Field: ‘globals’
[16:05:06.675]   - Field: ‘stdout’
[16:05:06.675]   - Field: ‘earlySignal’
[16:05:06.675]   - Field: ‘lazy’
[16:05:06.675]   - Field: ‘state’
[16:05:06.675] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.675] - Launch lazy future ...
[16:05:06.676] Packages needed by the future expression (n = 0): <none>
[16:05:06.676] Packages needed by future strategies (n = 0): <none>
[16:05:06.676] {
[16:05:06.676]     {
[16:05:06.676]         {
[16:05:06.676]             ...future.startTime <- base::Sys.time()
[16:05:06.676]             {
[16:05:06.676]                 {
[16:05:06.676]                   {
[16:05:06.676]                     base::local({
[16:05:06.676]                       has_future <- base::requireNamespace("future", 
[16:05:06.676]                         quietly = TRUE)
[16:05:06.676]                       if (has_future) {
[16:05:06.676]                         ns <- base::getNamespace("future")
[16:05:06.676]                         version <- ns[[".package"]][["version"]]
[16:05:06.676]                         if (is.null(version)) 
[16:05:06.676]                           version <- utils::packageVersion("future")
[16:05:06.676]                       }
[16:05:06.676]                       else {
[16:05:06.676]                         version <- NULL
[16:05:06.676]                       }
[16:05:06.676]                       if (!has_future || version < "1.8.0") {
[16:05:06.676]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.676]                           "", base::R.version$version.string), 
[16:05:06.676]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.676]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.676]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.676]                             "release", "version")], collapse = " "), 
[16:05:06.676]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.676]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.676]                           info)
[16:05:06.676]                         info <- base::paste(info, collapse = "; ")
[16:05:06.676]                         if (!has_future) {
[16:05:06.676]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.676]                             info)
[16:05:06.676]                         }
[16:05:06.676]                         else {
[16:05:06.676]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.676]                             info, version)
[16:05:06.676]                         }
[16:05:06.676]                         base::stop(msg)
[16:05:06.676]                       }
[16:05:06.676]                     })
[16:05:06.676]                   }
[16:05:06.676]                   options(future.plan = NULL)
[16:05:06.676]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.676]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.676]                 }
[16:05:06.676]                 ...future.workdir <- getwd()
[16:05:06.676]             }
[16:05:06.676]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.676]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.676]         }
[16:05:06.676]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.676]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:06.676]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.676]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.676]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.676]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.676]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.676]             base::names(...future.oldOptions))
[16:05:06.676]     }
[16:05:06.676]     if (FALSE) {
[16:05:06.676]     }
[16:05:06.676]     else {
[16:05:06.676]         if (TRUE) {
[16:05:06.676]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.676]                 open = "w")
[16:05:06.676]         }
[16:05:06.676]         else {
[16:05:06.676]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.676]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.676]         }
[16:05:06.676]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.676]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.676]             base::sink(type = "output", split = FALSE)
[16:05:06.676]             base::close(...future.stdout)
[16:05:06.676]         }, add = TRUE)
[16:05:06.676]     }
[16:05:06.676]     ...future.frame <- base::sys.nframe()
[16:05:06.676]     ...future.conditions <- base::list()
[16:05:06.676]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.676]     if (FALSE) {
[16:05:06.676]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.676]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.676]     }
[16:05:06.676]     ...future.result <- base::tryCatch({
[16:05:06.676]         base::withCallingHandlers({
[16:05:06.676]             ...future.value <- base::withVisible(base::local(1))
[16:05:06.676]             future::FutureResult(value = ...future.value$value, 
[16:05:06.676]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.676]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.676]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.676]                     ...future.globalenv.names))
[16:05:06.676]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.676]         }, condition = base::local({
[16:05:06.676]             c <- base::c
[16:05:06.676]             inherits <- base::inherits
[16:05:06.676]             invokeRestart <- base::invokeRestart
[16:05:06.676]             length <- base::length
[16:05:06.676]             list <- base::list
[16:05:06.676]             seq.int <- base::seq.int
[16:05:06.676]             signalCondition <- base::signalCondition
[16:05:06.676]             sys.calls <- base::sys.calls
[16:05:06.676]             `[[` <- base::`[[`
[16:05:06.676]             `+` <- base::`+`
[16:05:06.676]             `<<-` <- base::`<<-`
[16:05:06.676]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.676]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.676]                   3L)]
[16:05:06.676]             }
[16:05:06.676]             function(cond) {
[16:05:06.676]                 is_error <- inherits(cond, "error")
[16:05:06.676]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.676]                   NULL)
[16:05:06.676]                 if (is_error) {
[16:05:06.676]                   sessionInformation <- function() {
[16:05:06.676]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.676]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.676]                       search = base::search(), system = base::Sys.info())
[16:05:06.676]                   }
[16:05:06.676]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.676]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.676]                     cond$call), session = sessionInformation(), 
[16:05:06.676]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.676]                   signalCondition(cond)
[16:05:06.676]                 }
[16:05:06.676]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.676]                 "immediateCondition"))) {
[16:05:06.676]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.676]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.676]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.676]                   if (TRUE && !signal) {
[16:05:06.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.676]                     {
[16:05:06.676]                       inherits <- base::inherits
[16:05:06.676]                       invokeRestart <- base::invokeRestart
[16:05:06.676]                       is.null <- base::is.null
[16:05:06.676]                       muffled <- FALSE
[16:05:06.676]                       if (inherits(cond, "message")) {
[16:05:06.676]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.676]                         if (muffled) 
[16:05:06.676]                           invokeRestart("muffleMessage")
[16:05:06.676]                       }
[16:05:06.676]                       else if (inherits(cond, "warning")) {
[16:05:06.676]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.676]                         if (muffled) 
[16:05:06.676]                           invokeRestart("muffleWarning")
[16:05:06.676]                       }
[16:05:06.676]                       else if (inherits(cond, "condition")) {
[16:05:06.676]                         if (!is.null(pattern)) {
[16:05:06.676]                           computeRestarts <- base::computeRestarts
[16:05:06.676]                           grepl <- base::grepl
[16:05:06.676]                           restarts <- computeRestarts(cond)
[16:05:06.676]                           for (restart in restarts) {
[16:05:06.676]                             name <- restart$name
[16:05:06.676]                             if (is.null(name)) 
[16:05:06.676]                               next
[16:05:06.676]                             if (!grepl(pattern, name)) 
[16:05:06.676]                               next
[16:05:06.676]                             invokeRestart(restart)
[16:05:06.676]                             muffled <- TRUE
[16:05:06.676]                             break
[16:05:06.676]                           }
[16:05:06.676]                         }
[16:05:06.676]                       }
[16:05:06.676]                       invisible(muffled)
[16:05:06.676]                     }
[16:05:06.676]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.676]                   }
[16:05:06.676]                 }
[16:05:06.676]                 else {
[16:05:06.676]                   if (TRUE) {
[16:05:06.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.676]                     {
[16:05:06.676]                       inherits <- base::inherits
[16:05:06.676]                       invokeRestart <- base::invokeRestart
[16:05:06.676]                       is.null <- base::is.null
[16:05:06.676]                       muffled <- FALSE
[16:05:06.676]                       if (inherits(cond, "message")) {
[16:05:06.676]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.676]                         if (muffled) 
[16:05:06.676]                           invokeRestart("muffleMessage")
[16:05:06.676]                       }
[16:05:06.676]                       else if (inherits(cond, "warning")) {
[16:05:06.676]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.676]                         if (muffled) 
[16:05:06.676]                           invokeRestart("muffleWarning")
[16:05:06.676]                       }
[16:05:06.676]                       else if (inherits(cond, "condition")) {
[16:05:06.676]                         if (!is.null(pattern)) {
[16:05:06.676]                           computeRestarts <- base::computeRestarts
[16:05:06.676]                           grepl <- base::grepl
[16:05:06.676]                           restarts <- computeRestarts(cond)
[16:05:06.676]                           for (restart in restarts) {
[16:05:06.676]                             name <- restart$name
[16:05:06.676]                             if (is.null(name)) 
[16:05:06.676]                               next
[16:05:06.676]                             if (!grepl(pattern, name)) 
[16:05:06.676]                               next
[16:05:06.676]                             invokeRestart(restart)
[16:05:06.676]                             muffled <- TRUE
[16:05:06.676]                             break
[16:05:06.676]                           }
[16:05:06.676]                         }
[16:05:06.676]                       }
[16:05:06.676]                       invisible(muffled)
[16:05:06.676]                     }
[16:05:06.676]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.676]                   }
[16:05:06.676]                 }
[16:05:06.676]             }
[16:05:06.676]         }))
[16:05:06.676]     }, error = function(ex) {
[16:05:06.676]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.676]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.676]                 ...future.rng), started = ...future.startTime, 
[16:05:06.676]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.676]             version = "1.8"), class = "FutureResult")
[16:05:06.676]     }, finally = {
[16:05:06.676]         if (!identical(...future.workdir, getwd())) 
[16:05:06.676]             setwd(...future.workdir)
[16:05:06.676]         {
[16:05:06.676]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.676]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.676]             }
[16:05:06.676]             base::options(...future.oldOptions)
[16:05:06.676]             if (.Platform$OS.type == "windows") {
[16:05:06.676]                 old_names <- names(...future.oldEnvVars)
[16:05:06.676]                 envs <- base::Sys.getenv()
[16:05:06.676]                 names <- names(envs)
[16:05:06.676]                 common <- intersect(names, old_names)
[16:05:06.676]                 added <- setdiff(names, old_names)
[16:05:06.676]                 removed <- setdiff(old_names, names)
[16:05:06.676]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.676]                   envs[common]]
[16:05:06.676]                 NAMES <- toupper(changed)
[16:05:06.676]                 args <- list()
[16:05:06.676]                 for (kk in seq_along(NAMES)) {
[16:05:06.676]                   name <- changed[[kk]]
[16:05:06.676]                   NAME <- NAMES[[kk]]
[16:05:06.676]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.676]                     next
[16:05:06.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.676]                 }
[16:05:06.676]                 NAMES <- toupper(added)
[16:05:06.676]                 for (kk in seq_along(NAMES)) {
[16:05:06.676]                   name <- added[[kk]]
[16:05:06.676]                   NAME <- NAMES[[kk]]
[16:05:06.676]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.676]                     next
[16:05:06.676]                   args[[name]] <- ""
[16:05:06.676]                 }
[16:05:06.676]                 NAMES <- toupper(removed)
[16:05:06.676]                 for (kk in seq_along(NAMES)) {
[16:05:06.676]                   name <- removed[[kk]]
[16:05:06.676]                   NAME <- NAMES[[kk]]
[16:05:06.676]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.676]                     next
[16:05:06.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.676]                 }
[16:05:06.676]                 if (length(args) > 0) 
[16:05:06.676]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.676]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.676]             }
[16:05:06.676]             else {
[16:05:06.676]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.676]             }
[16:05:06.676]             {
[16:05:06.676]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.676]                   0L) {
[16:05:06.676]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.676]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.676]                   base::options(opts)
[16:05:06.676]                 }
[16:05:06.676]                 {
[16:05:06.676]                   {
[16:05:06.676]                     NULL
[16:05:06.676]                     RNGkind("Mersenne-Twister")
[16:05:06.676]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.676]                       inherits = FALSE)
[16:05:06.676]                   }
[16:05:06.676]                   options(future.plan = NULL)
[16:05:06.676]                   if (is.na(NA_character_)) 
[16:05:06.676]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.676]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.676]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.676]                   {
[16:05:06.676]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.676]                     if (!future$lazy) 
[16:05:06.676]                       future <- run(future)
[16:05:06.676]                     invisible(future)
[16:05:06.676]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.676]                 }
[16:05:06.676]             }
[16:05:06.676]         }
[16:05:06.676]     })
[16:05:06.676]     if (TRUE) {
[16:05:06.676]         base::sink(type = "output", split = FALSE)
[16:05:06.676]         if (TRUE) {
[16:05:06.676]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.676]         }
[16:05:06.676]         else {
[16:05:06.676]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.676]         }
[16:05:06.676]         base::close(...future.stdout)
[16:05:06.676]         ...future.stdout <- NULL
[16:05:06.676]     }
[16:05:06.676]     ...future.result$conditions <- ...future.conditions
[16:05:06.676]     ...future.result$finished <- base::Sys.time()
[16:05:06.676]     ...future.result
[16:05:06.676] }
[16:05:06.678] plan(): Setting new future strategy stack:
[16:05:06.678] List of future strategies:
[16:05:06.678] 1. sequential:
[16:05:06.678]    - args: function (..., envir = parent.frame())
[16:05:06.678]    - tweaked: FALSE
[16:05:06.678]    - call: NULL
[16:05:06.678] plan(): nbrOfWorkers() = 1
[16:05:06.679] plan(): Setting new future strategy stack:
[16:05:06.679] List of future strategies:
[16:05:06.679] 1. sequential:
[16:05:06.679]    - args: function (..., envir = parent.frame())
[16:05:06.679]    - tweaked: FALSE
[16:05:06.679]    - call: plan(strategy)
[16:05:06.680] plan(): nbrOfWorkers() = 1
[16:05:06.680] SequentialFuture started (and completed)
[16:05:06.680] - Launch lazy future ... done
[16:05:06.680] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.680] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.680] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:06.683] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:06.683] Searching for globals ... DONE
[16:05:06.683] Resolving globals: TRUE
[16:05:06.683] Resolving any globals that are futures ...
[16:05:06.683] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:06.683] Resolving any globals that are futures ... DONE
[16:05:06.684] Resolving futures part of globals (recursively) ...
[16:05:06.684] resolve() on list ...
[16:05:06.684]  recursive: 99
[16:05:06.684]  length: 1
[16:05:06.684]  elements: ‘a’
[16:05:06.684] resolved() for ‘SequentialFuture’ ...
[16:05:06.684] - state: ‘finished’
[16:05:06.684] - run: TRUE
[16:05:06.685] - result: ‘FutureResult’
[16:05:06.685] resolved() for ‘SequentialFuture’ ... done
[16:05:06.685] Future #1
[16:05:06.685] resolved() for ‘SequentialFuture’ ...
[16:05:06.685] - state: ‘finished’
[16:05:06.685] - run: TRUE
[16:05:06.685] - result: ‘FutureResult’
[16:05:06.685] resolved() for ‘SequentialFuture’ ... done
[16:05:06.685] A SequentialFuture was resolved
[16:05:06.686]  length: 0 (resolved future 1)
[16:05:06.686] resolve() on list ... DONE
[16:05:06.686] - globals: [1] ‘a’
[16:05:06.686] Resolving futures part of globals (recursively) ... DONE
[16:05:06.688] The total size of the 1 globals is 1.54 MiB (1615912 bytes)
[16:05:06.688] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.54 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.54 MiB of class ‘environment’)
[16:05:06.688] - globals: [1] ‘a’
[16:05:06.688] - packages: [1] ‘future’
[16:05:06.688] getGlobalsAndPackages() ... DONE
[16:05:06.689] run() for ‘Future’ ...
[16:05:06.689] - state: ‘created’
[16:05:06.689] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.689] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.689] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.689]   - Field: ‘label’
[16:05:06.689]   - Field: ‘local’
[16:05:06.690]   - Field: ‘owner’
[16:05:06.690]   - Field: ‘envir’
[16:05:06.690]   - Field: ‘packages’
[16:05:06.690]   - Field: ‘gc’
[16:05:06.690]   - Field: ‘conditions’
[16:05:06.690]   - Field: ‘expr’
[16:05:06.690]   - Field: ‘uuid’
[16:05:06.690]   - Field: ‘seed’
[16:05:06.690]   - Field: ‘version’
[16:05:06.690]   - Field: ‘result’
[16:05:06.690]   - Field: ‘asynchronous’
[16:05:06.691]   - Field: ‘calls’
[16:05:06.691]   - Field: ‘globals’
[16:05:06.691]   - Field: ‘stdout’
[16:05:06.691]   - Field: ‘earlySignal’
[16:05:06.691]   - Field: ‘lazy’
[16:05:06.691]   - Field: ‘state’
[16:05:06.691] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.691] - Launch lazy future ...
[16:05:06.691] Packages needed by the future expression (n = 1): ‘future’
[16:05:06.692] Packages needed by future strategies (n = 0): <none>
[16:05:06.692] {
[16:05:06.692]     {
[16:05:06.692]         {
[16:05:06.692]             ...future.startTime <- base::Sys.time()
[16:05:06.692]             {
[16:05:06.692]                 {
[16:05:06.692]                   {
[16:05:06.692]                     {
[16:05:06.692]                       base::local({
[16:05:06.692]                         has_future <- base::requireNamespace("future", 
[16:05:06.692]                           quietly = TRUE)
[16:05:06.692]                         if (has_future) {
[16:05:06.692]                           ns <- base::getNamespace("future")
[16:05:06.692]                           version <- ns[[".package"]][["version"]]
[16:05:06.692]                           if (is.null(version)) 
[16:05:06.692]                             version <- utils::packageVersion("future")
[16:05:06.692]                         }
[16:05:06.692]                         else {
[16:05:06.692]                           version <- NULL
[16:05:06.692]                         }
[16:05:06.692]                         if (!has_future || version < "1.8.0") {
[16:05:06.692]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.692]                             "", base::R.version$version.string), 
[16:05:06.692]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:06.692]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.692]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.692]                               "release", "version")], collapse = " "), 
[16:05:06.692]                             hostname = base::Sys.info()[["nodename"]])
[16:05:06.692]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.692]                             info)
[16:05:06.692]                           info <- base::paste(info, collapse = "; ")
[16:05:06.692]                           if (!has_future) {
[16:05:06.692]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.692]                               info)
[16:05:06.692]                           }
[16:05:06.692]                           else {
[16:05:06.692]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.692]                               info, version)
[16:05:06.692]                           }
[16:05:06.692]                           base::stop(msg)
[16:05:06.692]                         }
[16:05:06.692]                       })
[16:05:06.692]                     }
[16:05:06.692]                     base::local({
[16:05:06.692]                       for (pkg in "future") {
[16:05:06.692]                         base::loadNamespace(pkg)
[16:05:06.692]                         base::library(pkg, character.only = TRUE)
[16:05:06.692]                       }
[16:05:06.692]                     })
[16:05:06.692]                   }
[16:05:06.692]                   options(future.plan = NULL)
[16:05:06.692]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.692]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.692]                 }
[16:05:06.692]                 ...future.workdir <- getwd()
[16:05:06.692]             }
[16:05:06.692]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.692]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.692]         }
[16:05:06.692]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.692]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:06.692]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.692]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.692]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.692]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.692]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.692]             base::names(...future.oldOptions))
[16:05:06.692]     }
[16:05:06.692]     if (FALSE) {
[16:05:06.692]     }
[16:05:06.692]     else {
[16:05:06.692]         if (TRUE) {
[16:05:06.692]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.692]                 open = "w")
[16:05:06.692]         }
[16:05:06.692]         else {
[16:05:06.692]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.692]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.692]         }
[16:05:06.692]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.692]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.692]             base::sink(type = "output", split = FALSE)
[16:05:06.692]             base::close(...future.stdout)
[16:05:06.692]         }, add = TRUE)
[16:05:06.692]     }
[16:05:06.692]     ...future.frame <- base::sys.nframe()
[16:05:06.692]     ...future.conditions <- base::list()
[16:05:06.692]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.692]     if (FALSE) {
[16:05:06.692]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.692]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.692]     }
[16:05:06.692]     ...future.result <- base::tryCatch({
[16:05:06.692]         base::withCallingHandlers({
[16:05:06.692]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:05:06.692]                 1))
[16:05:06.692]             future::FutureResult(value = ...future.value$value, 
[16:05:06.692]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.692]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.692]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.692]                     ...future.globalenv.names))
[16:05:06.692]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.692]         }, condition = base::local({
[16:05:06.692]             c <- base::c
[16:05:06.692]             inherits <- base::inherits
[16:05:06.692]             invokeRestart <- base::invokeRestart
[16:05:06.692]             length <- base::length
[16:05:06.692]             list <- base::list
[16:05:06.692]             seq.int <- base::seq.int
[16:05:06.692]             signalCondition <- base::signalCondition
[16:05:06.692]             sys.calls <- base::sys.calls
[16:05:06.692]             `[[` <- base::`[[`
[16:05:06.692]             `+` <- base::`+`
[16:05:06.692]             `<<-` <- base::`<<-`
[16:05:06.692]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.692]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.692]                   3L)]
[16:05:06.692]             }
[16:05:06.692]             function(cond) {
[16:05:06.692]                 is_error <- inherits(cond, "error")
[16:05:06.692]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.692]                   NULL)
[16:05:06.692]                 if (is_error) {
[16:05:06.692]                   sessionInformation <- function() {
[16:05:06.692]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.692]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.692]                       search = base::search(), system = base::Sys.info())
[16:05:06.692]                   }
[16:05:06.692]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.692]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.692]                     cond$call), session = sessionInformation(), 
[16:05:06.692]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.692]                   signalCondition(cond)
[16:05:06.692]                 }
[16:05:06.692]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.692]                 "immediateCondition"))) {
[16:05:06.692]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.692]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.692]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.692]                   if (TRUE && !signal) {
[16:05:06.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.692]                     {
[16:05:06.692]                       inherits <- base::inherits
[16:05:06.692]                       invokeRestart <- base::invokeRestart
[16:05:06.692]                       is.null <- base::is.null
[16:05:06.692]                       muffled <- FALSE
[16:05:06.692]                       if (inherits(cond, "message")) {
[16:05:06.692]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.692]                         if (muffled) 
[16:05:06.692]                           invokeRestart("muffleMessage")
[16:05:06.692]                       }
[16:05:06.692]                       else if (inherits(cond, "warning")) {
[16:05:06.692]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.692]                         if (muffled) 
[16:05:06.692]                           invokeRestart("muffleWarning")
[16:05:06.692]                       }
[16:05:06.692]                       else if (inherits(cond, "condition")) {
[16:05:06.692]                         if (!is.null(pattern)) {
[16:05:06.692]                           computeRestarts <- base::computeRestarts
[16:05:06.692]                           grepl <- base::grepl
[16:05:06.692]                           restarts <- computeRestarts(cond)
[16:05:06.692]                           for (restart in restarts) {
[16:05:06.692]                             name <- restart$name
[16:05:06.692]                             if (is.null(name)) 
[16:05:06.692]                               next
[16:05:06.692]                             if (!grepl(pattern, name)) 
[16:05:06.692]                               next
[16:05:06.692]                             invokeRestart(restart)
[16:05:06.692]                             muffled <- TRUE
[16:05:06.692]                             break
[16:05:06.692]                           }
[16:05:06.692]                         }
[16:05:06.692]                       }
[16:05:06.692]                       invisible(muffled)
[16:05:06.692]                     }
[16:05:06.692]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.692]                   }
[16:05:06.692]                 }
[16:05:06.692]                 else {
[16:05:06.692]                   if (TRUE) {
[16:05:06.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.692]                     {
[16:05:06.692]                       inherits <- base::inherits
[16:05:06.692]                       invokeRestart <- base::invokeRestart
[16:05:06.692]                       is.null <- base::is.null
[16:05:06.692]                       muffled <- FALSE
[16:05:06.692]                       if (inherits(cond, "message")) {
[16:05:06.692]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.692]                         if (muffled) 
[16:05:06.692]                           invokeRestart("muffleMessage")
[16:05:06.692]                       }
[16:05:06.692]                       else if (inherits(cond, "warning")) {
[16:05:06.692]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.692]                         if (muffled) 
[16:05:06.692]                           invokeRestart("muffleWarning")
[16:05:06.692]                       }
[16:05:06.692]                       else if (inherits(cond, "condition")) {
[16:05:06.692]                         if (!is.null(pattern)) {
[16:05:06.692]                           computeRestarts <- base::computeRestarts
[16:05:06.692]                           grepl <- base::grepl
[16:05:06.692]                           restarts <- computeRestarts(cond)
[16:05:06.692]                           for (restart in restarts) {
[16:05:06.692]                             name <- restart$name
[16:05:06.692]                             if (is.null(name)) 
[16:05:06.692]                               next
[16:05:06.692]                             if (!grepl(pattern, name)) 
[16:05:06.692]                               next
[16:05:06.692]                             invokeRestart(restart)
[16:05:06.692]                             muffled <- TRUE
[16:05:06.692]                             break
[16:05:06.692]                           }
[16:05:06.692]                         }
[16:05:06.692]                       }
[16:05:06.692]                       invisible(muffled)
[16:05:06.692]                     }
[16:05:06.692]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.692]                   }
[16:05:06.692]                 }
[16:05:06.692]             }
[16:05:06.692]         }))
[16:05:06.692]     }, error = function(ex) {
[16:05:06.692]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.692]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.692]                 ...future.rng), started = ...future.startTime, 
[16:05:06.692]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.692]             version = "1.8"), class = "FutureResult")
[16:05:06.692]     }, finally = {
[16:05:06.692]         if (!identical(...future.workdir, getwd())) 
[16:05:06.692]             setwd(...future.workdir)
[16:05:06.692]         {
[16:05:06.692]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.692]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.692]             }
[16:05:06.692]             base::options(...future.oldOptions)
[16:05:06.692]             if (.Platform$OS.type == "windows") {
[16:05:06.692]                 old_names <- names(...future.oldEnvVars)
[16:05:06.692]                 envs <- base::Sys.getenv()
[16:05:06.692]                 names <- names(envs)
[16:05:06.692]                 common <- intersect(names, old_names)
[16:05:06.692]                 added <- setdiff(names, old_names)
[16:05:06.692]                 removed <- setdiff(old_names, names)
[16:05:06.692]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.692]                   envs[common]]
[16:05:06.692]                 NAMES <- toupper(changed)
[16:05:06.692]                 args <- list()
[16:05:06.692]                 for (kk in seq_along(NAMES)) {
[16:05:06.692]                   name <- changed[[kk]]
[16:05:06.692]                   NAME <- NAMES[[kk]]
[16:05:06.692]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.692]                     next
[16:05:06.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.692]                 }
[16:05:06.692]                 NAMES <- toupper(added)
[16:05:06.692]                 for (kk in seq_along(NAMES)) {
[16:05:06.692]                   name <- added[[kk]]
[16:05:06.692]                   NAME <- NAMES[[kk]]
[16:05:06.692]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.692]                     next
[16:05:06.692]                   args[[name]] <- ""
[16:05:06.692]                 }
[16:05:06.692]                 NAMES <- toupper(removed)
[16:05:06.692]                 for (kk in seq_along(NAMES)) {
[16:05:06.692]                   name <- removed[[kk]]
[16:05:06.692]                   NAME <- NAMES[[kk]]
[16:05:06.692]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.692]                     next
[16:05:06.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.692]                 }
[16:05:06.692]                 if (length(args) > 0) 
[16:05:06.692]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.692]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.692]             }
[16:05:06.692]             else {
[16:05:06.692]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.692]             }
[16:05:06.692]             {
[16:05:06.692]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.692]                   0L) {
[16:05:06.692]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.692]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.692]                   base::options(opts)
[16:05:06.692]                 }
[16:05:06.692]                 {
[16:05:06.692]                   {
[16:05:06.692]                     NULL
[16:05:06.692]                     RNGkind("Mersenne-Twister")
[16:05:06.692]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.692]                       inherits = FALSE)
[16:05:06.692]                   }
[16:05:06.692]                   options(future.plan = NULL)
[16:05:06.692]                   if (is.na(NA_character_)) 
[16:05:06.692]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.692]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.692]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.692]                   {
[16:05:06.692]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.692]                     if (!future$lazy) 
[16:05:06.692]                       future <- run(future)
[16:05:06.692]                     invisible(future)
[16:05:06.692]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.692]                 }
[16:05:06.692]             }
[16:05:06.692]         }
[16:05:06.692]     })
[16:05:06.692]     if (TRUE) {
[16:05:06.692]         base::sink(type = "output", split = FALSE)
[16:05:06.692]         if (TRUE) {
[16:05:06.692]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.692]         }
[16:05:06.692]         else {
[16:05:06.692]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.692]         }
[16:05:06.692]         base::close(...future.stdout)
[16:05:06.692]         ...future.stdout <- NULL
[16:05:06.692]     }
[16:05:06.692]     ...future.result$conditions <- ...future.conditions
[16:05:06.692]     ...future.result$finished <- base::Sys.time()
[16:05:06.692]     ...future.result
[16:05:06.692] }
[16:05:06.694] assign_globals() ...
[16:05:06.694] List of 1
[16:05:06.694]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a056616650> 
[16:05:06.694]  - attr(*, "where")=List of 1
[16:05:06.694]   ..$ a:<environment: R_EmptyEnv> 
[16:05:06.694]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.694]  - attr(*, "resolved")= logi TRUE
[16:05:06.694]  - attr(*, "total_size")= num 1615912
[16:05:06.694]  - attr(*, "already-done")= logi TRUE
[16:05:06.696] - copied ‘a’ to environment
[16:05:06.696] assign_globals() ... done
[16:05:06.697] plan(): Setting new future strategy stack:
[16:05:06.697] List of future strategies:
[16:05:06.697] 1. sequential:
[16:05:06.697]    - args: function (..., envir = parent.frame())
[16:05:06.697]    - tweaked: FALSE
[16:05:06.697]    - call: NULL
[16:05:06.697] plan(): nbrOfWorkers() = 1
[16:05:06.698] plan(): Setting new future strategy stack:
[16:05:06.698] List of future strategies:
[16:05:06.698] 1. sequential:
[16:05:06.698]    - args: function (..., envir = parent.frame())
[16:05:06.698]    - tweaked: FALSE
[16:05:06.698]    - call: plan(strategy)
[16:05:06.698] plan(): nbrOfWorkers() = 1
[16:05:06.698] SequentialFuture started (and completed)
[16:05:06.699] - Launch lazy future ... done
[16:05:06.699] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.699] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.699] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:06.700] 
[16:05:06.700] Searching for globals ... DONE
[16:05:06.700] - globals: [0] <none>
[16:05:06.700] getGlobalsAndPackages() ... DONE
[16:05:06.700] run() for ‘Future’ ...
[16:05:06.700] - state: ‘created’
[16:05:06.700] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.701] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.701] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.701]   - Field: ‘label’
[16:05:06.701]   - Field: ‘local’
[16:05:06.701]   - Field: ‘owner’
[16:05:06.701]   - Field: ‘envir’
[16:05:06.701]   - Field: ‘packages’
[16:05:06.701]   - Field: ‘gc’
[16:05:06.701]   - Field: ‘conditions’
[16:05:06.701]   - Field: ‘expr’
[16:05:06.702]   - Field: ‘uuid’
[16:05:06.702]   - Field: ‘seed’
[16:05:06.702]   - Field: ‘version’
[16:05:06.702]   - Field: ‘result’
[16:05:06.702]   - Field: ‘asynchronous’
[16:05:06.702]   - Field: ‘calls’
[16:05:06.702]   - Field: ‘globals’
[16:05:06.702]   - Field: ‘stdout’
[16:05:06.702]   - Field: ‘earlySignal’
[16:05:06.702]   - Field: ‘lazy’
[16:05:06.702]   - Field: ‘state’
[16:05:06.703] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.703] - Launch lazy future ...
[16:05:06.703] Packages needed by the future expression (n = 0): <none>
[16:05:06.703] Packages needed by future strategies (n = 0): <none>
[16:05:06.703] {
[16:05:06.703]     {
[16:05:06.703]         {
[16:05:06.703]             ...future.startTime <- base::Sys.time()
[16:05:06.703]             {
[16:05:06.703]                 {
[16:05:06.703]                   {
[16:05:06.703]                     base::local({
[16:05:06.703]                       has_future <- base::requireNamespace("future", 
[16:05:06.703]                         quietly = TRUE)
[16:05:06.703]                       if (has_future) {
[16:05:06.703]                         ns <- base::getNamespace("future")
[16:05:06.703]                         version <- ns[[".package"]][["version"]]
[16:05:06.703]                         if (is.null(version)) 
[16:05:06.703]                           version <- utils::packageVersion("future")
[16:05:06.703]                       }
[16:05:06.703]                       else {
[16:05:06.703]                         version <- NULL
[16:05:06.703]                       }
[16:05:06.703]                       if (!has_future || version < "1.8.0") {
[16:05:06.703]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.703]                           "", base::R.version$version.string), 
[16:05:06.703]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.703]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.703]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.703]                             "release", "version")], collapse = " "), 
[16:05:06.703]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.703]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.703]                           info)
[16:05:06.703]                         info <- base::paste(info, collapse = "; ")
[16:05:06.703]                         if (!has_future) {
[16:05:06.703]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.703]                             info)
[16:05:06.703]                         }
[16:05:06.703]                         else {
[16:05:06.703]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.703]                             info, version)
[16:05:06.703]                         }
[16:05:06.703]                         base::stop(msg)
[16:05:06.703]                       }
[16:05:06.703]                     })
[16:05:06.703]                   }
[16:05:06.703]                   options(future.plan = NULL)
[16:05:06.703]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.703]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.703]                 }
[16:05:06.703]                 ...future.workdir <- getwd()
[16:05:06.703]             }
[16:05:06.703]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.703]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.703]         }
[16:05:06.703]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.703]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:06.703]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.703]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.703]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.703]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.703]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.703]             base::names(...future.oldOptions))
[16:05:06.703]     }
[16:05:06.703]     if (FALSE) {
[16:05:06.703]     }
[16:05:06.703]     else {
[16:05:06.703]         if (TRUE) {
[16:05:06.703]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.703]                 open = "w")
[16:05:06.703]         }
[16:05:06.703]         else {
[16:05:06.703]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.703]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.703]         }
[16:05:06.703]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.703]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.703]             base::sink(type = "output", split = FALSE)
[16:05:06.703]             base::close(...future.stdout)
[16:05:06.703]         }, add = TRUE)
[16:05:06.703]     }
[16:05:06.703]     ...future.frame <- base::sys.nframe()
[16:05:06.703]     ...future.conditions <- base::list()
[16:05:06.703]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.703]     if (FALSE) {
[16:05:06.703]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.703]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.703]     }
[16:05:06.703]     ...future.result <- base::tryCatch({
[16:05:06.703]         base::withCallingHandlers({
[16:05:06.703]             ...future.value <- base::withVisible(base::local(1))
[16:05:06.703]             future::FutureResult(value = ...future.value$value, 
[16:05:06.703]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.703]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.703]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.703]                     ...future.globalenv.names))
[16:05:06.703]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.703]         }, condition = base::local({
[16:05:06.703]             c <- base::c
[16:05:06.703]             inherits <- base::inherits
[16:05:06.703]             invokeRestart <- base::invokeRestart
[16:05:06.703]             length <- base::length
[16:05:06.703]             list <- base::list
[16:05:06.703]             seq.int <- base::seq.int
[16:05:06.703]             signalCondition <- base::signalCondition
[16:05:06.703]             sys.calls <- base::sys.calls
[16:05:06.703]             `[[` <- base::`[[`
[16:05:06.703]             `+` <- base::`+`
[16:05:06.703]             `<<-` <- base::`<<-`
[16:05:06.703]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.703]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.703]                   3L)]
[16:05:06.703]             }
[16:05:06.703]             function(cond) {
[16:05:06.703]                 is_error <- inherits(cond, "error")
[16:05:06.703]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.703]                   NULL)
[16:05:06.703]                 if (is_error) {
[16:05:06.703]                   sessionInformation <- function() {
[16:05:06.703]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.703]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.703]                       search = base::search(), system = base::Sys.info())
[16:05:06.703]                   }
[16:05:06.703]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.703]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.703]                     cond$call), session = sessionInformation(), 
[16:05:06.703]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.703]                   signalCondition(cond)
[16:05:06.703]                 }
[16:05:06.703]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.703]                 "immediateCondition"))) {
[16:05:06.703]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.703]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.703]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.703]                   if (TRUE && !signal) {
[16:05:06.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.703]                     {
[16:05:06.703]                       inherits <- base::inherits
[16:05:06.703]                       invokeRestart <- base::invokeRestart
[16:05:06.703]                       is.null <- base::is.null
[16:05:06.703]                       muffled <- FALSE
[16:05:06.703]                       if (inherits(cond, "message")) {
[16:05:06.703]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.703]                         if (muffled) 
[16:05:06.703]                           invokeRestart("muffleMessage")
[16:05:06.703]                       }
[16:05:06.703]                       else if (inherits(cond, "warning")) {
[16:05:06.703]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.703]                         if (muffled) 
[16:05:06.703]                           invokeRestart("muffleWarning")
[16:05:06.703]                       }
[16:05:06.703]                       else if (inherits(cond, "condition")) {
[16:05:06.703]                         if (!is.null(pattern)) {
[16:05:06.703]                           computeRestarts <- base::computeRestarts
[16:05:06.703]                           grepl <- base::grepl
[16:05:06.703]                           restarts <- computeRestarts(cond)
[16:05:06.703]                           for (restart in restarts) {
[16:05:06.703]                             name <- restart$name
[16:05:06.703]                             if (is.null(name)) 
[16:05:06.703]                               next
[16:05:06.703]                             if (!grepl(pattern, name)) 
[16:05:06.703]                               next
[16:05:06.703]                             invokeRestart(restart)
[16:05:06.703]                             muffled <- TRUE
[16:05:06.703]                             break
[16:05:06.703]                           }
[16:05:06.703]                         }
[16:05:06.703]                       }
[16:05:06.703]                       invisible(muffled)
[16:05:06.703]                     }
[16:05:06.703]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.703]                   }
[16:05:06.703]                 }
[16:05:06.703]                 else {
[16:05:06.703]                   if (TRUE) {
[16:05:06.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.703]                     {
[16:05:06.703]                       inherits <- base::inherits
[16:05:06.703]                       invokeRestart <- base::invokeRestart
[16:05:06.703]                       is.null <- base::is.null
[16:05:06.703]                       muffled <- FALSE
[16:05:06.703]                       if (inherits(cond, "message")) {
[16:05:06.703]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.703]                         if (muffled) 
[16:05:06.703]                           invokeRestart("muffleMessage")
[16:05:06.703]                       }
[16:05:06.703]                       else if (inherits(cond, "warning")) {
[16:05:06.703]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.703]                         if (muffled) 
[16:05:06.703]                           invokeRestart("muffleWarning")
[16:05:06.703]                       }
[16:05:06.703]                       else if (inherits(cond, "condition")) {
[16:05:06.703]                         if (!is.null(pattern)) {
[16:05:06.703]                           computeRestarts <- base::computeRestarts
[16:05:06.703]                           grepl <- base::grepl
[16:05:06.703]                           restarts <- computeRestarts(cond)
[16:05:06.703]                           for (restart in restarts) {
[16:05:06.703]                             name <- restart$name
[16:05:06.703]                             if (is.null(name)) 
[16:05:06.703]                               next
[16:05:06.703]                             if (!grepl(pattern, name)) 
[16:05:06.703]                               next
[16:05:06.703]                             invokeRestart(restart)
[16:05:06.703]                             muffled <- TRUE
[16:05:06.703]                             break
[16:05:06.703]                           }
[16:05:06.703]                         }
[16:05:06.703]                       }
[16:05:06.703]                       invisible(muffled)
[16:05:06.703]                     }
[16:05:06.703]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.703]                   }
[16:05:06.703]                 }
[16:05:06.703]             }
[16:05:06.703]         }))
[16:05:06.703]     }, error = function(ex) {
[16:05:06.703]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.703]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.703]                 ...future.rng), started = ...future.startTime, 
[16:05:06.703]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.703]             version = "1.8"), class = "FutureResult")
[16:05:06.703]     }, finally = {
[16:05:06.703]         if (!identical(...future.workdir, getwd())) 
[16:05:06.703]             setwd(...future.workdir)
[16:05:06.703]         {
[16:05:06.703]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.703]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.703]             }
[16:05:06.703]             base::options(...future.oldOptions)
[16:05:06.703]             if (.Platform$OS.type == "windows") {
[16:05:06.703]                 old_names <- names(...future.oldEnvVars)
[16:05:06.703]                 envs <- base::Sys.getenv()
[16:05:06.703]                 names <- names(envs)
[16:05:06.703]                 common <- intersect(names, old_names)
[16:05:06.703]                 added <- setdiff(names, old_names)
[16:05:06.703]                 removed <- setdiff(old_names, names)
[16:05:06.703]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.703]                   envs[common]]
[16:05:06.703]                 NAMES <- toupper(changed)
[16:05:06.703]                 args <- list()
[16:05:06.703]                 for (kk in seq_along(NAMES)) {
[16:05:06.703]                   name <- changed[[kk]]
[16:05:06.703]                   NAME <- NAMES[[kk]]
[16:05:06.703]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.703]                     next
[16:05:06.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.703]                 }
[16:05:06.703]                 NAMES <- toupper(added)
[16:05:06.703]                 for (kk in seq_along(NAMES)) {
[16:05:06.703]                   name <- added[[kk]]
[16:05:06.703]                   NAME <- NAMES[[kk]]
[16:05:06.703]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.703]                     next
[16:05:06.703]                   args[[name]] <- ""
[16:05:06.703]                 }
[16:05:06.703]                 NAMES <- toupper(removed)
[16:05:06.703]                 for (kk in seq_along(NAMES)) {
[16:05:06.703]                   name <- removed[[kk]]
[16:05:06.703]                   NAME <- NAMES[[kk]]
[16:05:06.703]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.703]                     next
[16:05:06.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.703]                 }
[16:05:06.703]                 if (length(args) > 0) 
[16:05:06.703]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.703]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.703]             }
[16:05:06.703]             else {
[16:05:06.703]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.703]             }
[16:05:06.703]             {
[16:05:06.703]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.703]                   0L) {
[16:05:06.703]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.703]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.703]                   base::options(opts)
[16:05:06.703]                 }
[16:05:06.703]                 {
[16:05:06.703]                   {
[16:05:06.703]                     NULL
[16:05:06.703]                     RNGkind("Mersenne-Twister")
[16:05:06.703]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.703]                       inherits = FALSE)
[16:05:06.703]                   }
[16:05:06.703]                   options(future.plan = NULL)
[16:05:06.703]                   if (is.na(NA_character_)) 
[16:05:06.703]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.703]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.703]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.703]                   {
[16:05:06.703]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.703]                     if (!future$lazy) 
[16:05:06.703]                       future <- run(future)
[16:05:06.703]                     invisible(future)
[16:05:06.703]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.703]                 }
[16:05:06.703]             }
[16:05:06.703]         }
[16:05:06.703]     })
[16:05:06.703]     if (TRUE) {
[16:05:06.703]         base::sink(type = "output", split = FALSE)
[16:05:06.703]         if (TRUE) {
[16:05:06.703]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.703]         }
[16:05:06.703]         else {
[16:05:06.703]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.703]         }
[16:05:06.703]         base::close(...future.stdout)
[16:05:06.703]         ...future.stdout <- NULL
[16:05:06.703]     }
[16:05:06.703]     ...future.result$conditions <- ...future.conditions
[16:05:06.703]     ...future.result$finished <- base::Sys.time()
[16:05:06.703]     ...future.result
[16:05:06.703] }
[16:05:06.705] plan(): Setting new future strategy stack:
[16:05:06.705] List of future strategies:
[16:05:06.705] 1. sequential:
[16:05:06.705]    - args: function (..., envir = parent.frame())
[16:05:06.705]    - tweaked: FALSE
[16:05:06.705]    - call: NULL
[16:05:06.706] plan(): nbrOfWorkers() = 1
[16:05:06.732] plan(): Setting new future strategy stack:
[16:05:06.732] List of future strategies:
[16:05:06.732] 1. sequential:
[16:05:06.732]    - args: function (..., envir = parent.frame())
[16:05:06.732]    - tweaked: FALSE
[16:05:06.732]    - call: plan(strategy)
[16:05:06.733] plan(): nbrOfWorkers() = 1
[16:05:06.733] SequentialFuture started (and completed)
[16:05:06.733] - Launch lazy future ... done
[16:05:06.733] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.733] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.734] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:06.735] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:06.735] Searching for globals ... DONE
[16:05:06.735] Resolving globals: TRUE
[16:05:06.735] Resolving any globals that are futures ...
[16:05:06.735] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:06.735] Resolving any globals that are futures ... DONE
[16:05:06.735] Resolving futures part of globals (recursively) ...
[16:05:06.736] resolve() on list ...
[16:05:06.736]  recursive: 99
[16:05:06.736]  length: 1
[16:05:06.736]  elements: ‘a’
[16:05:06.736] resolved() for ‘SequentialFuture’ ...
[16:05:06.736] - state: ‘finished’
[16:05:06.736] - run: TRUE
[16:05:06.736] - result: ‘FutureResult’
[16:05:06.736] resolved() for ‘SequentialFuture’ ... done
[16:05:06.737] Future #1
[16:05:06.737] resolved() for ‘SequentialFuture’ ...
[16:05:06.737] - state: ‘finished’
[16:05:06.737] - run: TRUE
[16:05:06.737] - result: ‘FutureResult’
[16:05:06.737] resolved() for ‘SequentialFuture’ ... done
[16:05:06.737] A SequentialFuture was resolved
[16:05:06.737]  length: 0 (resolved future 1)
[16:05:06.737] resolve() on list ... DONE
[16:05:06.737] - globals: [1] ‘a’
[16:05:06.738] Resolving futures part of globals (recursively) ... DONE
[16:05:06.739] The total size of the 1 globals is 1.54 MiB (1615912 bytes)
[16:05:06.740] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.54 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.54 MiB of class ‘environment’)
[16:05:06.740] - globals: [1] ‘a’
[16:05:06.740] - packages: [1] ‘future’
[16:05:06.740] getGlobalsAndPackages() ... DONE
[16:05:06.740] run() for ‘Future’ ...
[16:05:06.740] - state: ‘created’
[16:05:06.741] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.741] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.741] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.741]   - Field: ‘label’
[16:05:06.741]   - Field: ‘local’
[16:05:06.741]   - Field: ‘owner’
[16:05:06.741]   - Field: ‘envir’
[16:05:06.741]   - Field: ‘packages’
[16:05:06.742]   - Field: ‘gc’
[16:05:06.742]   - Field: ‘conditions’
[16:05:06.742]   - Field: ‘expr’
[16:05:06.742]   - Field: ‘uuid’
[16:05:06.742]   - Field: ‘seed’
[16:05:06.742]   - Field: ‘version’
[16:05:06.742]   - Field: ‘result’
[16:05:06.742]   - Field: ‘asynchronous’
[16:05:06.742]   - Field: ‘calls’
[16:05:06.742]   - Field: ‘globals’
[16:05:06.742]   - Field: ‘stdout’
[16:05:06.743]   - Field: ‘earlySignal’
[16:05:06.743]   - Field: ‘lazy’
[16:05:06.743]   - Field: ‘state’
[16:05:06.743] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.743] - Launch lazy future ...
[16:05:06.743] Packages needed by the future expression (n = 1): ‘future’
[16:05:06.743] Packages needed by future strategies (n = 0): <none>
[16:05:06.744] {
[16:05:06.744]     {
[16:05:06.744]         {
[16:05:06.744]             ...future.startTime <- base::Sys.time()
[16:05:06.744]             {
[16:05:06.744]                 {
[16:05:06.744]                   {
[16:05:06.744]                     {
[16:05:06.744]                       base::local({
[16:05:06.744]                         has_future <- base::requireNamespace("future", 
[16:05:06.744]                           quietly = TRUE)
[16:05:06.744]                         if (has_future) {
[16:05:06.744]                           ns <- base::getNamespace("future")
[16:05:06.744]                           version <- ns[[".package"]][["version"]]
[16:05:06.744]                           if (is.null(version)) 
[16:05:06.744]                             version <- utils::packageVersion("future")
[16:05:06.744]                         }
[16:05:06.744]                         else {
[16:05:06.744]                           version <- NULL
[16:05:06.744]                         }
[16:05:06.744]                         if (!has_future || version < "1.8.0") {
[16:05:06.744]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.744]                             "", base::R.version$version.string), 
[16:05:06.744]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:06.744]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.744]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.744]                               "release", "version")], collapse = " "), 
[16:05:06.744]                             hostname = base::Sys.info()[["nodename"]])
[16:05:06.744]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.744]                             info)
[16:05:06.744]                           info <- base::paste(info, collapse = "; ")
[16:05:06.744]                           if (!has_future) {
[16:05:06.744]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.744]                               info)
[16:05:06.744]                           }
[16:05:06.744]                           else {
[16:05:06.744]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.744]                               info, version)
[16:05:06.744]                           }
[16:05:06.744]                           base::stop(msg)
[16:05:06.744]                         }
[16:05:06.744]                       })
[16:05:06.744]                     }
[16:05:06.744]                     base::local({
[16:05:06.744]                       for (pkg in "future") {
[16:05:06.744]                         base::loadNamespace(pkg)
[16:05:06.744]                         base::library(pkg, character.only = TRUE)
[16:05:06.744]                       }
[16:05:06.744]                     })
[16:05:06.744]                   }
[16:05:06.744]                   options(future.plan = NULL)
[16:05:06.744]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.744]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.744]                 }
[16:05:06.744]                 ...future.workdir <- getwd()
[16:05:06.744]             }
[16:05:06.744]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.744]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.744]         }
[16:05:06.744]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.744]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:06.744]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.744]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.744]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.744]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.744]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.744]             base::names(...future.oldOptions))
[16:05:06.744]     }
[16:05:06.744]     if (FALSE) {
[16:05:06.744]     }
[16:05:06.744]     else {
[16:05:06.744]         if (TRUE) {
[16:05:06.744]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.744]                 open = "w")
[16:05:06.744]         }
[16:05:06.744]         else {
[16:05:06.744]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.744]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.744]         }
[16:05:06.744]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.744]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.744]             base::sink(type = "output", split = FALSE)
[16:05:06.744]             base::close(...future.stdout)
[16:05:06.744]         }, add = TRUE)
[16:05:06.744]     }
[16:05:06.744]     ...future.frame <- base::sys.nframe()
[16:05:06.744]     ...future.conditions <- base::list()
[16:05:06.744]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.744]     if (FALSE) {
[16:05:06.744]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.744]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.744]     }
[16:05:06.744]     ...future.result <- base::tryCatch({
[16:05:06.744]         base::withCallingHandlers({
[16:05:06.744]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:05:06.744]                 1))
[16:05:06.744]             future::FutureResult(value = ...future.value$value, 
[16:05:06.744]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.744]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.744]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.744]                     ...future.globalenv.names))
[16:05:06.744]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.744]         }, condition = base::local({
[16:05:06.744]             c <- base::c
[16:05:06.744]             inherits <- base::inherits
[16:05:06.744]             invokeRestart <- base::invokeRestart
[16:05:06.744]             length <- base::length
[16:05:06.744]             list <- base::list
[16:05:06.744]             seq.int <- base::seq.int
[16:05:06.744]             signalCondition <- base::signalCondition
[16:05:06.744]             sys.calls <- base::sys.calls
[16:05:06.744]             `[[` <- base::`[[`
[16:05:06.744]             `+` <- base::`+`
[16:05:06.744]             `<<-` <- base::`<<-`
[16:05:06.744]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.744]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.744]                   3L)]
[16:05:06.744]             }
[16:05:06.744]             function(cond) {
[16:05:06.744]                 is_error <- inherits(cond, "error")
[16:05:06.744]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.744]                   NULL)
[16:05:06.744]                 if (is_error) {
[16:05:06.744]                   sessionInformation <- function() {
[16:05:06.744]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.744]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.744]                       search = base::search(), system = base::Sys.info())
[16:05:06.744]                   }
[16:05:06.744]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.744]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.744]                     cond$call), session = sessionInformation(), 
[16:05:06.744]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.744]                   signalCondition(cond)
[16:05:06.744]                 }
[16:05:06.744]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.744]                 "immediateCondition"))) {
[16:05:06.744]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.744]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.744]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.744]                   if (TRUE && !signal) {
[16:05:06.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.744]                     {
[16:05:06.744]                       inherits <- base::inherits
[16:05:06.744]                       invokeRestart <- base::invokeRestart
[16:05:06.744]                       is.null <- base::is.null
[16:05:06.744]                       muffled <- FALSE
[16:05:06.744]                       if (inherits(cond, "message")) {
[16:05:06.744]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.744]                         if (muffled) 
[16:05:06.744]                           invokeRestart("muffleMessage")
[16:05:06.744]                       }
[16:05:06.744]                       else if (inherits(cond, "warning")) {
[16:05:06.744]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.744]                         if (muffled) 
[16:05:06.744]                           invokeRestart("muffleWarning")
[16:05:06.744]                       }
[16:05:06.744]                       else if (inherits(cond, "condition")) {
[16:05:06.744]                         if (!is.null(pattern)) {
[16:05:06.744]                           computeRestarts <- base::computeRestarts
[16:05:06.744]                           grepl <- base::grepl
[16:05:06.744]                           restarts <- computeRestarts(cond)
[16:05:06.744]                           for (restart in restarts) {
[16:05:06.744]                             name <- restart$name
[16:05:06.744]                             if (is.null(name)) 
[16:05:06.744]                               next
[16:05:06.744]                             if (!grepl(pattern, name)) 
[16:05:06.744]                               next
[16:05:06.744]                             invokeRestart(restart)
[16:05:06.744]                             muffled <- TRUE
[16:05:06.744]                             break
[16:05:06.744]                           }
[16:05:06.744]                         }
[16:05:06.744]                       }
[16:05:06.744]                       invisible(muffled)
[16:05:06.744]                     }
[16:05:06.744]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.744]                   }
[16:05:06.744]                 }
[16:05:06.744]                 else {
[16:05:06.744]                   if (TRUE) {
[16:05:06.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.744]                     {
[16:05:06.744]                       inherits <- base::inherits
[16:05:06.744]                       invokeRestart <- base::invokeRestart
[16:05:06.744]                       is.null <- base::is.null
[16:05:06.744]                       muffled <- FALSE
[16:05:06.744]                       if (inherits(cond, "message")) {
[16:05:06.744]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.744]                         if (muffled) 
[16:05:06.744]                           invokeRestart("muffleMessage")
[16:05:06.744]                       }
[16:05:06.744]                       else if (inherits(cond, "warning")) {
[16:05:06.744]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.744]                         if (muffled) 
[16:05:06.744]                           invokeRestart("muffleWarning")
[16:05:06.744]                       }
[16:05:06.744]                       else if (inherits(cond, "condition")) {
[16:05:06.744]                         if (!is.null(pattern)) {
[16:05:06.744]                           computeRestarts <- base::computeRestarts
[16:05:06.744]                           grepl <- base::grepl
[16:05:06.744]                           restarts <- computeRestarts(cond)
[16:05:06.744]                           for (restart in restarts) {
[16:05:06.744]                             name <- restart$name
[16:05:06.744]                             if (is.null(name)) 
[16:05:06.744]                               next
[16:05:06.744]                             if (!grepl(pattern, name)) 
[16:05:06.744]                               next
[16:05:06.744]                             invokeRestart(restart)
[16:05:06.744]                             muffled <- TRUE
[16:05:06.744]                             break
[16:05:06.744]                           }
[16:05:06.744]                         }
[16:05:06.744]                       }
[16:05:06.744]                       invisible(muffled)
[16:05:06.744]                     }
[16:05:06.744]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.744]                   }
[16:05:06.744]                 }
[16:05:06.744]             }
[16:05:06.744]         }))
[16:05:06.744]     }, error = function(ex) {
[16:05:06.744]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.744]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.744]                 ...future.rng), started = ...future.startTime, 
[16:05:06.744]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.744]             version = "1.8"), class = "FutureResult")
[16:05:06.744]     }, finally = {
[16:05:06.744]         if (!identical(...future.workdir, getwd())) 
[16:05:06.744]             setwd(...future.workdir)
[16:05:06.744]         {
[16:05:06.744]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.744]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.744]             }
[16:05:06.744]             base::options(...future.oldOptions)
[16:05:06.744]             if (.Platform$OS.type == "windows") {
[16:05:06.744]                 old_names <- names(...future.oldEnvVars)
[16:05:06.744]                 envs <- base::Sys.getenv()
[16:05:06.744]                 names <- names(envs)
[16:05:06.744]                 common <- intersect(names, old_names)
[16:05:06.744]                 added <- setdiff(names, old_names)
[16:05:06.744]                 removed <- setdiff(old_names, names)
[16:05:06.744]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.744]                   envs[common]]
[16:05:06.744]                 NAMES <- toupper(changed)
[16:05:06.744]                 args <- list()
[16:05:06.744]                 for (kk in seq_along(NAMES)) {
[16:05:06.744]                   name <- changed[[kk]]
[16:05:06.744]                   NAME <- NAMES[[kk]]
[16:05:06.744]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.744]                     next
[16:05:06.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.744]                 }
[16:05:06.744]                 NAMES <- toupper(added)
[16:05:06.744]                 for (kk in seq_along(NAMES)) {
[16:05:06.744]                   name <- added[[kk]]
[16:05:06.744]                   NAME <- NAMES[[kk]]
[16:05:06.744]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.744]                     next
[16:05:06.744]                   args[[name]] <- ""
[16:05:06.744]                 }
[16:05:06.744]                 NAMES <- toupper(removed)
[16:05:06.744]                 for (kk in seq_along(NAMES)) {
[16:05:06.744]                   name <- removed[[kk]]
[16:05:06.744]                   NAME <- NAMES[[kk]]
[16:05:06.744]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.744]                     next
[16:05:06.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.744]                 }
[16:05:06.744]                 if (length(args) > 0) 
[16:05:06.744]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.744]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.744]             }
[16:05:06.744]             else {
[16:05:06.744]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.744]             }
[16:05:06.744]             {
[16:05:06.744]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.744]                   0L) {
[16:05:06.744]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.744]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.744]                   base::options(opts)
[16:05:06.744]                 }
[16:05:06.744]                 {
[16:05:06.744]                   {
[16:05:06.744]                     NULL
[16:05:06.744]                     RNGkind("Mersenne-Twister")
[16:05:06.744]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.744]                       inherits = FALSE)
[16:05:06.744]                   }
[16:05:06.744]                   options(future.plan = NULL)
[16:05:06.744]                   if (is.na(NA_character_)) 
[16:05:06.744]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.744]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.744]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.744]                   {
[16:05:06.744]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.744]                     if (!future$lazy) 
[16:05:06.744]                       future <- run(future)
[16:05:06.744]                     invisible(future)
[16:05:06.744]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.744]                 }
[16:05:06.744]             }
[16:05:06.744]         }
[16:05:06.744]     })
[16:05:06.744]     if (TRUE) {
[16:05:06.744]         base::sink(type = "output", split = FALSE)
[16:05:06.744]         if (TRUE) {
[16:05:06.744]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.744]         }
[16:05:06.744]         else {
[16:05:06.744]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.744]         }
[16:05:06.744]         base::close(...future.stdout)
[16:05:06.744]         ...future.stdout <- NULL
[16:05:06.744]     }
[16:05:06.744]     ...future.result$conditions <- ...future.conditions
[16:05:06.744]     ...future.result$finished <- base::Sys.time()
[16:05:06.744]     ...future.result
[16:05:06.744] }
[16:05:06.745] assign_globals() ...
[16:05:06.746] List of 1
[16:05:06.746]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a056680b28> 
[16:05:06.746]  - attr(*, "where")=List of 1
[16:05:06.746]   ..$ a:<environment: R_EmptyEnv> 
[16:05:06.746]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.746]  - attr(*, "resolved")= logi TRUE
[16:05:06.746]  - attr(*, "total_size")= num 1615912
[16:05:06.746]  - attr(*, "already-done")= logi TRUE
[16:05:06.748] - copied ‘a’ to environment
[16:05:06.748] assign_globals() ... done
[16:05:06.749] plan(): Setting new future strategy stack:
[16:05:06.749] List of future strategies:
[16:05:06.749] 1. sequential:
[16:05:06.749]    - args: function (..., envir = parent.frame())
[16:05:06.749]    - tweaked: FALSE
[16:05:06.749]    - call: NULL
[16:05:06.749] plan(): nbrOfWorkers() = 1
[16:05:06.750] plan(): Setting new future strategy stack:
[16:05:06.750] List of future strategies:
[16:05:06.750] 1. sequential:
[16:05:06.750]    - args: function (..., envir = parent.frame())
[16:05:06.750]    - tweaked: FALSE
[16:05:06.750]    - call: plan(strategy)
[16:05:06.750] plan(): nbrOfWorkers() = 1
[16:05:06.750] SequentialFuture started (and completed)
[16:05:06.751] - Launch lazy future ... done
[16:05:06.751] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.751] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.751] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:06.752] 
[16:05:06.752] Searching for globals ... DONE
[16:05:06.752] - globals: [0] <none>
[16:05:06.752] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.752] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.752] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:06.753] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:06.753] Searching for globals ... DONE
[16:05:06.753] Resolving globals: TRUE
[16:05:06.753] Resolving any globals that are futures ...
[16:05:06.754] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:06.754] Resolving any globals that are futures ... DONE
[16:05:06.754] Resolving futures part of globals (recursively) ...
[16:05:06.754] resolve() on list ...
[16:05:06.754]  recursive: 99
[16:05:06.754]  length: 1
[16:05:06.754]  elements: ‘a’
[16:05:06.755] run() for ‘Future’ ...
[16:05:06.755] - state: ‘created’
[16:05:06.755] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.755] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.755] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.755]   - Field: ‘label’
[16:05:06.755]   - Field: ‘local’
[16:05:06.756]   - Field: ‘owner’
[16:05:06.756]   - Field: ‘envir’
[16:05:06.756]   - Field: ‘packages’
[16:05:06.756]   - Field: ‘gc’
[16:05:06.756]   - Field: ‘conditions’
[16:05:06.756]   - Field: ‘expr’
[16:05:06.756]   - Field: ‘uuid’
[16:05:06.756]   - Field: ‘seed’
[16:05:06.756]   - Field: ‘version’
[16:05:06.756]   - Field: ‘result’
[16:05:06.756]   - Field: ‘asynchronous’
[16:05:06.757]   - Field: ‘calls’
[16:05:06.757]   - Field: ‘globals’
[16:05:06.757]   - Field: ‘stdout’
[16:05:06.757]   - Field: ‘earlySignal’
[16:05:06.757]   - Field: ‘lazy’
[16:05:06.757]   - Field: ‘state’
[16:05:06.757] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.757] - Launch lazy future ...
[16:05:06.757] Packages needed by the future expression (n = 0): <none>
[16:05:06.757] Packages needed by future strategies (n = 0): <none>
[16:05:06.758] {
[16:05:06.758]     {
[16:05:06.758]         {
[16:05:06.758]             ...future.startTime <- base::Sys.time()
[16:05:06.758]             {
[16:05:06.758]                 {
[16:05:06.758]                   {
[16:05:06.758]                     base::local({
[16:05:06.758]                       has_future <- base::requireNamespace("future", 
[16:05:06.758]                         quietly = TRUE)
[16:05:06.758]                       if (has_future) {
[16:05:06.758]                         ns <- base::getNamespace("future")
[16:05:06.758]                         version <- ns[[".package"]][["version"]]
[16:05:06.758]                         if (is.null(version)) 
[16:05:06.758]                           version <- utils::packageVersion("future")
[16:05:06.758]                       }
[16:05:06.758]                       else {
[16:05:06.758]                         version <- NULL
[16:05:06.758]                       }
[16:05:06.758]                       if (!has_future || version < "1.8.0") {
[16:05:06.758]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.758]                           "", base::R.version$version.string), 
[16:05:06.758]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.758]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.758]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.758]                             "release", "version")], collapse = " "), 
[16:05:06.758]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.758]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.758]                           info)
[16:05:06.758]                         info <- base::paste(info, collapse = "; ")
[16:05:06.758]                         if (!has_future) {
[16:05:06.758]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.758]                             info)
[16:05:06.758]                         }
[16:05:06.758]                         else {
[16:05:06.758]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.758]                             info, version)
[16:05:06.758]                         }
[16:05:06.758]                         base::stop(msg)
[16:05:06.758]                       }
[16:05:06.758]                     })
[16:05:06.758]                   }
[16:05:06.758]                   options(future.plan = NULL)
[16:05:06.758]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.758]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.758]                 }
[16:05:06.758]                 ...future.workdir <- getwd()
[16:05:06.758]             }
[16:05:06.758]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.758]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.758]         }
[16:05:06.758]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.758]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:06.758]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.758]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.758]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.758]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.758]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.758]             base::names(...future.oldOptions))
[16:05:06.758]     }
[16:05:06.758]     if (FALSE) {
[16:05:06.758]     }
[16:05:06.758]     else {
[16:05:06.758]         if (TRUE) {
[16:05:06.758]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.758]                 open = "w")
[16:05:06.758]         }
[16:05:06.758]         else {
[16:05:06.758]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.758]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.758]         }
[16:05:06.758]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.758]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.758]             base::sink(type = "output", split = FALSE)
[16:05:06.758]             base::close(...future.stdout)
[16:05:06.758]         }, add = TRUE)
[16:05:06.758]     }
[16:05:06.758]     ...future.frame <- base::sys.nframe()
[16:05:06.758]     ...future.conditions <- base::list()
[16:05:06.758]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.758]     if (FALSE) {
[16:05:06.758]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.758]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.758]     }
[16:05:06.758]     ...future.result <- base::tryCatch({
[16:05:06.758]         base::withCallingHandlers({
[16:05:06.758]             ...future.value <- base::withVisible(base::local(1))
[16:05:06.758]             future::FutureResult(value = ...future.value$value, 
[16:05:06.758]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.758]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.758]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.758]                     ...future.globalenv.names))
[16:05:06.758]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.758]         }, condition = base::local({
[16:05:06.758]             c <- base::c
[16:05:06.758]             inherits <- base::inherits
[16:05:06.758]             invokeRestart <- base::invokeRestart
[16:05:06.758]             length <- base::length
[16:05:06.758]             list <- base::list
[16:05:06.758]             seq.int <- base::seq.int
[16:05:06.758]             signalCondition <- base::signalCondition
[16:05:06.758]             sys.calls <- base::sys.calls
[16:05:06.758]             `[[` <- base::`[[`
[16:05:06.758]             `+` <- base::`+`
[16:05:06.758]             `<<-` <- base::`<<-`
[16:05:06.758]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.758]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.758]                   3L)]
[16:05:06.758]             }
[16:05:06.758]             function(cond) {
[16:05:06.758]                 is_error <- inherits(cond, "error")
[16:05:06.758]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.758]                   NULL)
[16:05:06.758]                 if (is_error) {
[16:05:06.758]                   sessionInformation <- function() {
[16:05:06.758]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.758]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.758]                       search = base::search(), system = base::Sys.info())
[16:05:06.758]                   }
[16:05:06.758]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.758]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.758]                     cond$call), session = sessionInformation(), 
[16:05:06.758]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.758]                   signalCondition(cond)
[16:05:06.758]                 }
[16:05:06.758]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.758]                 "immediateCondition"))) {
[16:05:06.758]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.758]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.758]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.758]                   if (TRUE && !signal) {
[16:05:06.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.758]                     {
[16:05:06.758]                       inherits <- base::inherits
[16:05:06.758]                       invokeRestart <- base::invokeRestart
[16:05:06.758]                       is.null <- base::is.null
[16:05:06.758]                       muffled <- FALSE
[16:05:06.758]                       if (inherits(cond, "message")) {
[16:05:06.758]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.758]                         if (muffled) 
[16:05:06.758]                           invokeRestart("muffleMessage")
[16:05:06.758]                       }
[16:05:06.758]                       else if (inherits(cond, "warning")) {
[16:05:06.758]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.758]                         if (muffled) 
[16:05:06.758]                           invokeRestart("muffleWarning")
[16:05:06.758]                       }
[16:05:06.758]                       else if (inherits(cond, "condition")) {
[16:05:06.758]                         if (!is.null(pattern)) {
[16:05:06.758]                           computeRestarts <- base::computeRestarts
[16:05:06.758]                           grepl <- base::grepl
[16:05:06.758]                           restarts <- computeRestarts(cond)
[16:05:06.758]                           for (restart in restarts) {
[16:05:06.758]                             name <- restart$name
[16:05:06.758]                             if (is.null(name)) 
[16:05:06.758]                               next
[16:05:06.758]                             if (!grepl(pattern, name)) 
[16:05:06.758]                               next
[16:05:06.758]                             invokeRestart(restart)
[16:05:06.758]                             muffled <- TRUE
[16:05:06.758]                             break
[16:05:06.758]                           }
[16:05:06.758]                         }
[16:05:06.758]                       }
[16:05:06.758]                       invisible(muffled)
[16:05:06.758]                     }
[16:05:06.758]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.758]                   }
[16:05:06.758]                 }
[16:05:06.758]                 else {
[16:05:06.758]                   if (TRUE) {
[16:05:06.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.758]                     {
[16:05:06.758]                       inherits <- base::inherits
[16:05:06.758]                       invokeRestart <- base::invokeRestart
[16:05:06.758]                       is.null <- base::is.null
[16:05:06.758]                       muffled <- FALSE
[16:05:06.758]                       if (inherits(cond, "message")) {
[16:05:06.758]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.758]                         if (muffled) 
[16:05:06.758]                           invokeRestart("muffleMessage")
[16:05:06.758]                       }
[16:05:06.758]                       else if (inherits(cond, "warning")) {
[16:05:06.758]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.758]                         if (muffled) 
[16:05:06.758]                           invokeRestart("muffleWarning")
[16:05:06.758]                       }
[16:05:06.758]                       else if (inherits(cond, "condition")) {
[16:05:06.758]                         if (!is.null(pattern)) {
[16:05:06.758]                           computeRestarts <- base::computeRestarts
[16:05:06.758]                           grepl <- base::grepl
[16:05:06.758]                           restarts <- computeRestarts(cond)
[16:05:06.758]                           for (restart in restarts) {
[16:05:06.758]                             name <- restart$name
[16:05:06.758]                             if (is.null(name)) 
[16:05:06.758]                               next
[16:05:06.758]                             if (!grepl(pattern, name)) 
[16:05:06.758]                               next
[16:05:06.758]                             invokeRestart(restart)
[16:05:06.758]                             muffled <- TRUE
[16:05:06.758]                             break
[16:05:06.758]                           }
[16:05:06.758]                         }
[16:05:06.758]                       }
[16:05:06.758]                       invisible(muffled)
[16:05:06.758]                     }
[16:05:06.758]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.758]                   }
[16:05:06.758]                 }
[16:05:06.758]             }
[16:05:06.758]         }))
[16:05:06.758]     }, error = function(ex) {
[16:05:06.758]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.758]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.758]                 ...future.rng), started = ...future.startTime, 
[16:05:06.758]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.758]             version = "1.8"), class = "FutureResult")
[16:05:06.758]     }, finally = {
[16:05:06.758]         if (!identical(...future.workdir, getwd())) 
[16:05:06.758]             setwd(...future.workdir)
[16:05:06.758]         {
[16:05:06.758]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.758]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.758]             }
[16:05:06.758]             base::options(...future.oldOptions)
[16:05:06.758]             if (.Platform$OS.type == "windows") {
[16:05:06.758]                 old_names <- names(...future.oldEnvVars)
[16:05:06.758]                 envs <- base::Sys.getenv()
[16:05:06.758]                 names <- names(envs)
[16:05:06.758]                 common <- intersect(names, old_names)
[16:05:06.758]                 added <- setdiff(names, old_names)
[16:05:06.758]                 removed <- setdiff(old_names, names)
[16:05:06.758]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.758]                   envs[common]]
[16:05:06.758]                 NAMES <- toupper(changed)
[16:05:06.758]                 args <- list()
[16:05:06.758]                 for (kk in seq_along(NAMES)) {
[16:05:06.758]                   name <- changed[[kk]]
[16:05:06.758]                   NAME <- NAMES[[kk]]
[16:05:06.758]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.758]                     next
[16:05:06.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.758]                 }
[16:05:06.758]                 NAMES <- toupper(added)
[16:05:06.758]                 for (kk in seq_along(NAMES)) {
[16:05:06.758]                   name <- added[[kk]]
[16:05:06.758]                   NAME <- NAMES[[kk]]
[16:05:06.758]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.758]                     next
[16:05:06.758]                   args[[name]] <- ""
[16:05:06.758]                 }
[16:05:06.758]                 NAMES <- toupper(removed)
[16:05:06.758]                 for (kk in seq_along(NAMES)) {
[16:05:06.758]                   name <- removed[[kk]]
[16:05:06.758]                   NAME <- NAMES[[kk]]
[16:05:06.758]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.758]                     next
[16:05:06.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.758]                 }
[16:05:06.758]                 if (length(args) > 0) 
[16:05:06.758]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.758]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.758]             }
[16:05:06.758]             else {
[16:05:06.758]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.758]             }
[16:05:06.758]             {
[16:05:06.758]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.758]                   0L) {
[16:05:06.758]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.758]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.758]                   base::options(opts)
[16:05:06.758]                 }
[16:05:06.758]                 {
[16:05:06.758]                   {
[16:05:06.758]                     NULL
[16:05:06.758]                     RNGkind("Mersenne-Twister")
[16:05:06.758]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.758]                       inherits = FALSE)
[16:05:06.758]                   }
[16:05:06.758]                   options(future.plan = NULL)
[16:05:06.758]                   if (is.na(NA_character_)) 
[16:05:06.758]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.758]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.758]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.758]                   {
[16:05:06.758]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.758]                     if (!future$lazy) 
[16:05:06.758]                       future <- run(future)
[16:05:06.758]                     invisible(future)
[16:05:06.758]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.758]                 }
[16:05:06.758]             }
[16:05:06.758]         }
[16:05:06.758]     })
[16:05:06.758]     if (TRUE) {
[16:05:06.758]         base::sink(type = "output", split = FALSE)
[16:05:06.758]         if (TRUE) {
[16:05:06.758]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.758]         }
[16:05:06.758]         else {
[16:05:06.758]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.758]         }
[16:05:06.758]         base::close(...future.stdout)
[16:05:06.758]         ...future.stdout <- NULL
[16:05:06.758]     }
[16:05:06.758]     ...future.result$conditions <- ...future.conditions
[16:05:06.758]     ...future.result$finished <- base::Sys.time()
[16:05:06.758]     ...future.result
[16:05:06.758] }
[16:05:06.760] plan(): Setting new future strategy stack:
[16:05:06.760] List of future strategies:
[16:05:06.760] 1. sequential:
[16:05:06.760]    - args: function (..., envir = parent.frame())
[16:05:06.760]    - tweaked: FALSE
[16:05:06.760]    - call: NULL
[16:05:06.760] plan(): nbrOfWorkers() = 1
[16:05:06.762] plan(): Setting new future strategy stack:
[16:05:06.762] List of future strategies:
[16:05:06.762] 1. sequential:
[16:05:06.762]    - args: function (..., envir = parent.frame())
[16:05:06.762]    - tweaked: FALSE
[16:05:06.762]    - call: plan(strategy)
[16:05:06.763] plan(): nbrOfWorkers() = 1
[16:05:06.763] SequentialFuture started (and completed)
[16:05:06.763] - Launch lazy future ... done
[16:05:06.763] run() for ‘SequentialFuture’ ... done
[16:05:06.763] resolved() for ‘SequentialFuture’ ...
[16:05:06.763] - state: ‘finished’
[16:05:06.764] - run: TRUE
[16:05:06.764] - result: ‘FutureResult’
[16:05:06.764] resolved() for ‘SequentialFuture’ ... done
[16:05:06.764] Future #1
[16:05:06.764] resolved() for ‘SequentialFuture’ ...
[16:05:06.764] - state: ‘finished’
[16:05:06.764] - run: TRUE
[16:05:06.764] - result: ‘FutureResult’
[16:05:06.764] resolved() for ‘SequentialFuture’ ... done
[16:05:06.765] A SequentialFuture was resolved
[16:05:06.765]  length: 0 (resolved future 1)
[16:05:06.765] resolve() on list ... DONE
[16:05:06.765] - globals: [1] ‘a’
[16:05:06.765] Resolving futures part of globals (recursively) ... DONE
[16:05:06.767] The total size of the 1 globals is 1.54 MiB (1616080 bytes)
[16:05:06.767] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.54 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.54 MiB of class ‘environment’)
[16:05:06.767] - globals: [1] ‘a’
[16:05:06.767] - packages: [1] ‘future’
[16:05:06.767] getGlobalsAndPackages() ... DONE
[16:05:06.768] run() for ‘Future’ ...
[16:05:06.768] - state: ‘created’
[16:05:06.768] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.768] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.768] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.768]   - Field: ‘label’
[16:05:06.769]   - Field: ‘local’
[16:05:06.769]   - Field: ‘owner’
[16:05:06.769]   - Field: ‘envir’
[16:05:06.769]   - Field: ‘packages’
[16:05:06.769]   - Field: ‘gc’
[16:05:06.769]   - Field: ‘conditions’
[16:05:06.769]   - Field: ‘expr’
[16:05:06.769]   - Field: ‘uuid’
[16:05:06.769]   - Field: ‘seed’
[16:05:06.769]   - Field: ‘version’
[16:05:06.769]   - Field: ‘result’
[16:05:06.770]   - Field: ‘asynchronous’
[16:05:06.770]   - Field: ‘calls’
[16:05:06.770]   - Field: ‘globals’
[16:05:06.770]   - Field: ‘stdout’
[16:05:06.770]   - Field: ‘earlySignal’
[16:05:06.770]   - Field: ‘lazy’
[16:05:06.770]   - Field: ‘state’
[16:05:06.770] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.770] - Launch lazy future ...
[16:05:06.770] Packages needed by the future expression (n = 1): ‘future’
[16:05:06.771] Packages needed by future strategies (n = 0): <none>
[16:05:06.771] {
[16:05:06.771]     {
[16:05:06.771]         {
[16:05:06.771]             ...future.startTime <- base::Sys.time()
[16:05:06.771]             {
[16:05:06.771]                 {
[16:05:06.771]                   {
[16:05:06.771]                     {
[16:05:06.771]                       base::local({
[16:05:06.771]                         has_future <- base::requireNamespace("future", 
[16:05:06.771]                           quietly = TRUE)
[16:05:06.771]                         if (has_future) {
[16:05:06.771]                           ns <- base::getNamespace("future")
[16:05:06.771]                           version <- ns[[".package"]][["version"]]
[16:05:06.771]                           if (is.null(version)) 
[16:05:06.771]                             version <- utils::packageVersion("future")
[16:05:06.771]                         }
[16:05:06.771]                         else {
[16:05:06.771]                           version <- NULL
[16:05:06.771]                         }
[16:05:06.771]                         if (!has_future || version < "1.8.0") {
[16:05:06.771]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.771]                             "", base::R.version$version.string), 
[16:05:06.771]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:06.771]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.771]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.771]                               "release", "version")], collapse = " "), 
[16:05:06.771]                             hostname = base::Sys.info()[["nodename"]])
[16:05:06.771]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.771]                             info)
[16:05:06.771]                           info <- base::paste(info, collapse = "; ")
[16:05:06.771]                           if (!has_future) {
[16:05:06.771]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.771]                               info)
[16:05:06.771]                           }
[16:05:06.771]                           else {
[16:05:06.771]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.771]                               info, version)
[16:05:06.771]                           }
[16:05:06.771]                           base::stop(msg)
[16:05:06.771]                         }
[16:05:06.771]                       })
[16:05:06.771]                     }
[16:05:06.771]                     base::local({
[16:05:06.771]                       for (pkg in "future") {
[16:05:06.771]                         base::loadNamespace(pkg)
[16:05:06.771]                         base::library(pkg, character.only = TRUE)
[16:05:06.771]                       }
[16:05:06.771]                     })
[16:05:06.771]                   }
[16:05:06.771]                   options(future.plan = NULL)
[16:05:06.771]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.771]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.771]                 }
[16:05:06.771]                 ...future.workdir <- getwd()
[16:05:06.771]             }
[16:05:06.771]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.771]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.771]         }
[16:05:06.771]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.771]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:06.771]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.771]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.771]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.771]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.771]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.771]             base::names(...future.oldOptions))
[16:05:06.771]     }
[16:05:06.771]     if (FALSE) {
[16:05:06.771]     }
[16:05:06.771]     else {
[16:05:06.771]         if (TRUE) {
[16:05:06.771]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.771]                 open = "w")
[16:05:06.771]         }
[16:05:06.771]         else {
[16:05:06.771]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.771]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.771]         }
[16:05:06.771]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.771]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.771]             base::sink(type = "output", split = FALSE)
[16:05:06.771]             base::close(...future.stdout)
[16:05:06.771]         }, add = TRUE)
[16:05:06.771]     }
[16:05:06.771]     ...future.frame <- base::sys.nframe()
[16:05:06.771]     ...future.conditions <- base::list()
[16:05:06.771]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.771]     if (FALSE) {
[16:05:06.771]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.771]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.771]     }
[16:05:06.771]     ...future.result <- base::tryCatch({
[16:05:06.771]         base::withCallingHandlers({
[16:05:06.771]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:05:06.771]                 1))
[16:05:06.771]             future::FutureResult(value = ...future.value$value, 
[16:05:06.771]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.771]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.771]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.771]                     ...future.globalenv.names))
[16:05:06.771]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.771]         }, condition = base::local({
[16:05:06.771]             c <- base::c
[16:05:06.771]             inherits <- base::inherits
[16:05:06.771]             invokeRestart <- base::invokeRestart
[16:05:06.771]             length <- base::length
[16:05:06.771]             list <- base::list
[16:05:06.771]             seq.int <- base::seq.int
[16:05:06.771]             signalCondition <- base::signalCondition
[16:05:06.771]             sys.calls <- base::sys.calls
[16:05:06.771]             `[[` <- base::`[[`
[16:05:06.771]             `+` <- base::`+`
[16:05:06.771]             `<<-` <- base::`<<-`
[16:05:06.771]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.771]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.771]                   3L)]
[16:05:06.771]             }
[16:05:06.771]             function(cond) {
[16:05:06.771]                 is_error <- inherits(cond, "error")
[16:05:06.771]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.771]                   NULL)
[16:05:06.771]                 if (is_error) {
[16:05:06.771]                   sessionInformation <- function() {
[16:05:06.771]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.771]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.771]                       search = base::search(), system = base::Sys.info())
[16:05:06.771]                   }
[16:05:06.771]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.771]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.771]                     cond$call), session = sessionInformation(), 
[16:05:06.771]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.771]                   signalCondition(cond)
[16:05:06.771]                 }
[16:05:06.771]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.771]                 "immediateCondition"))) {
[16:05:06.771]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.771]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.771]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.771]                   if (TRUE && !signal) {
[16:05:06.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.771]                     {
[16:05:06.771]                       inherits <- base::inherits
[16:05:06.771]                       invokeRestart <- base::invokeRestart
[16:05:06.771]                       is.null <- base::is.null
[16:05:06.771]                       muffled <- FALSE
[16:05:06.771]                       if (inherits(cond, "message")) {
[16:05:06.771]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.771]                         if (muffled) 
[16:05:06.771]                           invokeRestart("muffleMessage")
[16:05:06.771]                       }
[16:05:06.771]                       else if (inherits(cond, "warning")) {
[16:05:06.771]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.771]                         if (muffled) 
[16:05:06.771]                           invokeRestart("muffleWarning")
[16:05:06.771]                       }
[16:05:06.771]                       else if (inherits(cond, "condition")) {
[16:05:06.771]                         if (!is.null(pattern)) {
[16:05:06.771]                           computeRestarts <- base::computeRestarts
[16:05:06.771]                           grepl <- base::grepl
[16:05:06.771]                           restarts <- computeRestarts(cond)
[16:05:06.771]                           for (restart in restarts) {
[16:05:06.771]                             name <- restart$name
[16:05:06.771]                             if (is.null(name)) 
[16:05:06.771]                               next
[16:05:06.771]                             if (!grepl(pattern, name)) 
[16:05:06.771]                               next
[16:05:06.771]                             invokeRestart(restart)
[16:05:06.771]                             muffled <- TRUE
[16:05:06.771]                             break
[16:05:06.771]                           }
[16:05:06.771]                         }
[16:05:06.771]                       }
[16:05:06.771]                       invisible(muffled)
[16:05:06.771]                     }
[16:05:06.771]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.771]                   }
[16:05:06.771]                 }
[16:05:06.771]                 else {
[16:05:06.771]                   if (TRUE) {
[16:05:06.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.771]                     {
[16:05:06.771]                       inherits <- base::inherits
[16:05:06.771]                       invokeRestart <- base::invokeRestart
[16:05:06.771]                       is.null <- base::is.null
[16:05:06.771]                       muffled <- FALSE
[16:05:06.771]                       if (inherits(cond, "message")) {
[16:05:06.771]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.771]                         if (muffled) 
[16:05:06.771]                           invokeRestart("muffleMessage")
[16:05:06.771]                       }
[16:05:06.771]                       else if (inherits(cond, "warning")) {
[16:05:06.771]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.771]                         if (muffled) 
[16:05:06.771]                           invokeRestart("muffleWarning")
[16:05:06.771]                       }
[16:05:06.771]                       else if (inherits(cond, "condition")) {
[16:05:06.771]                         if (!is.null(pattern)) {
[16:05:06.771]                           computeRestarts <- base::computeRestarts
[16:05:06.771]                           grepl <- base::grepl
[16:05:06.771]                           restarts <- computeRestarts(cond)
[16:05:06.771]                           for (restart in restarts) {
[16:05:06.771]                             name <- restart$name
[16:05:06.771]                             if (is.null(name)) 
[16:05:06.771]                               next
[16:05:06.771]                             if (!grepl(pattern, name)) 
[16:05:06.771]                               next
[16:05:06.771]                             invokeRestart(restart)
[16:05:06.771]                             muffled <- TRUE
[16:05:06.771]                             break
[16:05:06.771]                           }
[16:05:06.771]                         }
[16:05:06.771]                       }
[16:05:06.771]                       invisible(muffled)
[16:05:06.771]                     }
[16:05:06.771]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.771]                   }
[16:05:06.771]                 }
[16:05:06.771]             }
[16:05:06.771]         }))
[16:05:06.771]     }, error = function(ex) {
[16:05:06.771]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.771]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.771]                 ...future.rng), started = ...future.startTime, 
[16:05:06.771]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.771]             version = "1.8"), class = "FutureResult")
[16:05:06.771]     }, finally = {
[16:05:06.771]         if (!identical(...future.workdir, getwd())) 
[16:05:06.771]             setwd(...future.workdir)
[16:05:06.771]         {
[16:05:06.771]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.771]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.771]             }
[16:05:06.771]             base::options(...future.oldOptions)
[16:05:06.771]             if (.Platform$OS.type == "windows") {
[16:05:06.771]                 old_names <- names(...future.oldEnvVars)
[16:05:06.771]                 envs <- base::Sys.getenv()
[16:05:06.771]                 names <- names(envs)
[16:05:06.771]                 common <- intersect(names, old_names)
[16:05:06.771]                 added <- setdiff(names, old_names)
[16:05:06.771]                 removed <- setdiff(old_names, names)
[16:05:06.771]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.771]                   envs[common]]
[16:05:06.771]                 NAMES <- toupper(changed)
[16:05:06.771]                 args <- list()
[16:05:06.771]                 for (kk in seq_along(NAMES)) {
[16:05:06.771]                   name <- changed[[kk]]
[16:05:06.771]                   NAME <- NAMES[[kk]]
[16:05:06.771]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.771]                     next
[16:05:06.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.771]                 }
[16:05:06.771]                 NAMES <- toupper(added)
[16:05:06.771]                 for (kk in seq_along(NAMES)) {
[16:05:06.771]                   name <- added[[kk]]
[16:05:06.771]                   NAME <- NAMES[[kk]]
[16:05:06.771]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.771]                     next
[16:05:06.771]                   args[[name]] <- ""
[16:05:06.771]                 }
[16:05:06.771]                 NAMES <- toupper(removed)
[16:05:06.771]                 for (kk in seq_along(NAMES)) {
[16:05:06.771]                   name <- removed[[kk]]
[16:05:06.771]                   NAME <- NAMES[[kk]]
[16:05:06.771]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.771]                     next
[16:05:06.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.771]                 }
[16:05:06.771]                 if (length(args) > 0) 
[16:05:06.771]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.771]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.771]             }
[16:05:06.771]             else {
[16:05:06.771]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.771]             }
[16:05:06.771]             {
[16:05:06.771]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.771]                   0L) {
[16:05:06.771]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.771]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.771]                   base::options(opts)
[16:05:06.771]                 }
[16:05:06.771]                 {
[16:05:06.771]                   {
[16:05:06.771]                     NULL
[16:05:06.771]                     RNGkind("Mersenne-Twister")
[16:05:06.771]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.771]                       inherits = FALSE)
[16:05:06.771]                   }
[16:05:06.771]                   options(future.plan = NULL)
[16:05:06.771]                   if (is.na(NA_character_)) 
[16:05:06.771]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.771]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.771]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.771]                   {
[16:05:06.771]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.771]                     if (!future$lazy) 
[16:05:06.771]                       future <- run(future)
[16:05:06.771]                     invisible(future)
[16:05:06.771]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.771]                 }
[16:05:06.771]             }
[16:05:06.771]         }
[16:05:06.771]     })
[16:05:06.771]     if (TRUE) {
[16:05:06.771]         base::sink(type = "output", split = FALSE)
[16:05:06.771]         if (TRUE) {
[16:05:06.771]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.771]         }
[16:05:06.771]         else {
[16:05:06.771]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.771]         }
[16:05:06.771]         base::close(...future.stdout)
[16:05:06.771]         ...future.stdout <- NULL
[16:05:06.771]     }
[16:05:06.771]     ...future.result$conditions <- ...future.conditions
[16:05:06.771]     ...future.result$finished <- base::Sys.time()
[16:05:06.771]     ...future.result
[16:05:06.771] }
[16:05:06.773] assign_globals() ...
[16:05:06.773] List of 1
[16:05:06.773]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a056630768> 
[16:05:06.773]  - attr(*, "where")=List of 1
[16:05:06.773]   ..$ a:<environment: R_EmptyEnv> 
[16:05:06.773]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.773]  - attr(*, "resolved")= logi TRUE
[16:05:06.773]  - attr(*, "total_size")= num 1616080
[16:05:06.773]  - attr(*, "already-done")= logi TRUE
[16:05:06.775] - copied ‘a’ to environment
[16:05:06.775] assign_globals() ... done
[16:05:06.776] plan(): Setting new future strategy stack:
[16:05:06.776] List of future strategies:
[16:05:06.776] 1. sequential:
[16:05:06.776]    - args: function (..., envir = parent.frame())
[16:05:06.776]    - tweaked: FALSE
[16:05:06.776]    - call: NULL
[16:05:06.776] plan(): nbrOfWorkers() = 1
[16:05:06.777] plan(): Setting new future strategy stack:
[16:05:06.777] List of future strategies:
[16:05:06.777] 1. sequential:
[16:05:06.777]    - args: function (..., envir = parent.frame())
[16:05:06.777]    - tweaked: FALSE
[16:05:06.777]    - call: plan(strategy)
[16:05:06.777] plan(): nbrOfWorkers() = 1
[16:05:06.777] SequentialFuture started (and completed)
[16:05:06.778] - Launch lazy future ... done
[16:05:06.778] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.778] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.778] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:06.779] 
[16:05:06.779] Searching for globals ... DONE
[16:05:06.779] - globals: [0] <none>
[16:05:06.779] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.779] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.780] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:06.780] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:06.780] Searching for globals ... DONE
[16:05:06.780] Resolving globals: TRUE
[16:05:06.781] Resolving any globals that are futures ...
[16:05:06.781] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:06.781] Resolving any globals that are futures ... DONE
[16:05:06.781] Resolving futures part of globals (recursively) ...
[16:05:06.781] resolve() on list ...
[16:05:06.781]  recursive: 99
[16:05:06.781]  length: 1
[16:05:06.781]  elements: ‘a’
[16:05:06.782] run() for ‘Future’ ...
[16:05:06.782] - state: ‘created’
[16:05:06.782] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.782] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.782] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.782]   - Field: ‘label’
[16:05:06.782]   - Field: ‘local’
[16:05:06.783]   - Field: ‘owner’
[16:05:06.783]   - Field: ‘envir’
[16:05:06.783]   - Field: ‘packages’
[16:05:06.783]   - Field: ‘gc’
[16:05:06.783]   - Field: ‘conditions’
[16:05:06.783]   - Field: ‘expr’
[16:05:06.783]   - Field: ‘uuid’
[16:05:06.783]   - Field: ‘seed’
[16:05:06.783]   - Field: ‘version’
[16:05:06.783]   - Field: ‘result’
[16:05:06.783]   - Field: ‘asynchronous’
[16:05:06.784]   - Field: ‘calls’
[16:05:06.784]   - Field: ‘globals’
[16:05:06.784]   - Field: ‘stdout’
[16:05:06.784]   - Field: ‘earlySignal’
[16:05:06.784]   - Field: ‘lazy’
[16:05:06.784]   - Field: ‘state’
[16:05:06.784] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.784] - Launch lazy future ...
[16:05:06.784] Packages needed by the future expression (n = 0): <none>
[16:05:06.784] Packages needed by future strategies (n = 0): <none>
[16:05:06.785] {
[16:05:06.785]     {
[16:05:06.785]         {
[16:05:06.785]             ...future.startTime <- base::Sys.time()
[16:05:06.785]             {
[16:05:06.785]                 {
[16:05:06.785]                   {
[16:05:06.785]                     base::local({
[16:05:06.785]                       has_future <- base::requireNamespace("future", 
[16:05:06.785]                         quietly = TRUE)
[16:05:06.785]                       if (has_future) {
[16:05:06.785]                         ns <- base::getNamespace("future")
[16:05:06.785]                         version <- ns[[".package"]][["version"]]
[16:05:06.785]                         if (is.null(version)) 
[16:05:06.785]                           version <- utils::packageVersion("future")
[16:05:06.785]                       }
[16:05:06.785]                       else {
[16:05:06.785]                         version <- NULL
[16:05:06.785]                       }
[16:05:06.785]                       if (!has_future || version < "1.8.0") {
[16:05:06.785]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.785]                           "", base::R.version$version.string), 
[16:05:06.785]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.785]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.785]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.785]                             "release", "version")], collapse = " "), 
[16:05:06.785]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.785]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.785]                           info)
[16:05:06.785]                         info <- base::paste(info, collapse = "; ")
[16:05:06.785]                         if (!has_future) {
[16:05:06.785]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.785]                             info)
[16:05:06.785]                         }
[16:05:06.785]                         else {
[16:05:06.785]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.785]                             info, version)
[16:05:06.785]                         }
[16:05:06.785]                         base::stop(msg)
[16:05:06.785]                       }
[16:05:06.785]                     })
[16:05:06.785]                   }
[16:05:06.785]                   options(future.plan = NULL)
[16:05:06.785]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.785]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.785]                 }
[16:05:06.785]                 ...future.workdir <- getwd()
[16:05:06.785]             }
[16:05:06.785]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.785]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.785]         }
[16:05:06.785]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.785]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:06.785]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.785]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.785]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.785]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.785]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.785]             base::names(...future.oldOptions))
[16:05:06.785]     }
[16:05:06.785]     if (FALSE) {
[16:05:06.785]     }
[16:05:06.785]     else {
[16:05:06.785]         if (TRUE) {
[16:05:06.785]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.785]                 open = "w")
[16:05:06.785]         }
[16:05:06.785]         else {
[16:05:06.785]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.785]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.785]         }
[16:05:06.785]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.785]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.785]             base::sink(type = "output", split = FALSE)
[16:05:06.785]             base::close(...future.stdout)
[16:05:06.785]         }, add = TRUE)
[16:05:06.785]     }
[16:05:06.785]     ...future.frame <- base::sys.nframe()
[16:05:06.785]     ...future.conditions <- base::list()
[16:05:06.785]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.785]     if (FALSE) {
[16:05:06.785]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.785]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.785]     }
[16:05:06.785]     ...future.result <- base::tryCatch({
[16:05:06.785]         base::withCallingHandlers({
[16:05:06.785]             ...future.value <- base::withVisible(base::local(1))
[16:05:06.785]             future::FutureResult(value = ...future.value$value, 
[16:05:06.785]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.785]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.785]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.785]                     ...future.globalenv.names))
[16:05:06.785]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.785]         }, condition = base::local({
[16:05:06.785]             c <- base::c
[16:05:06.785]             inherits <- base::inherits
[16:05:06.785]             invokeRestart <- base::invokeRestart
[16:05:06.785]             length <- base::length
[16:05:06.785]             list <- base::list
[16:05:06.785]             seq.int <- base::seq.int
[16:05:06.785]             signalCondition <- base::signalCondition
[16:05:06.785]             sys.calls <- base::sys.calls
[16:05:06.785]             `[[` <- base::`[[`
[16:05:06.785]             `+` <- base::`+`
[16:05:06.785]             `<<-` <- base::`<<-`
[16:05:06.785]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.785]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.785]                   3L)]
[16:05:06.785]             }
[16:05:06.785]             function(cond) {
[16:05:06.785]                 is_error <- inherits(cond, "error")
[16:05:06.785]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.785]                   NULL)
[16:05:06.785]                 if (is_error) {
[16:05:06.785]                   sessionInformation <- function() {
[16:05:06.785]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.785]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.785]                       search = base::search(), system = base::Sys.info())
[16:05:06.785]                   }
[16:05:06.785]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.785]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.785]                     cond$call), session = sessionInformation(), 
[16:05:06.785]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.785]                   signalCondition(cond)
[16:05:06.785]                 }
[16:05:06.785]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.785]                 "immediateCondition"))) {
[16:05:06.785]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.785]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.785]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.785]                   if (TRUE && !signal) {
[16:05:06.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.785]                     {
[16:05:06.785]                       inherits <- base::inherits
[16:05:06.785]                       invokeRestart <- base::invokeRestart
[16:05:06.785]                       is.null <- base::is.null
[16:05:06.785]                       muffled <- FALSE
[16:05:06.785]                       if (inherits(cond, "message")) {
[16:05:06.785]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.785]                         if (muffled) 
[16:05:06.785]                           invokeRestart("muffleMessage")
[16:05:06.785]                       }
[16:05:06.785]                       else if (inherits(cond, "warning")) {
[16:05:06.785]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.785]                         if (muffled) 
[16:05:06.785]                           invokeRestart("muffleWarning")
[16:05:06.785]                       }
[16:05:06.785]                       else if (inherits(cond, "condition")) {
[16:05:06.785]                         if (!is.null(pattern)) {
[16:05:06.785]                           computeRestarts <- base::computeRestarts
[16:05:06.785]                           grepl <- base::grepl
[16:05:06.785]                           restarts <- computeRestarts(cond)
[16:05:06.785]                           for (restart in restarts) {
[16:05:06.785]                             name <- restart$name
[16:05:06.785]                             if (is.null(name)) 
[16:05:06.785]                               next
[16:05:06.785]                             if (!grepl(pattern, name)) 
[16:05:06.785]                               next
[16:05:06.785]                             invokeRestart(restart)
[16:05:06.785]                             muffled <- TRUE
[16:05:06.785]                             break
[16:05:06.785]                           }
[16:05:06.785]                         }
[16:05:06.785]                       }
[16:05:06.785]                       invisible(muffled)
[16:05:06.785]                     }
[16:05:06.785]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.785]                   }
[16:05:06.785]                 }
[16:05:06.785]                 else {
[16:05:06.785]                   if (TRUE) {
[16:05:06.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.785]                     {
[16:05:06.785]                       inherits <- base::inherits
[16:05:06.785]                       invokeRestart <- base::invokeRestart
[16:05:06.785]                       is.null <- base::is.null
[16:05:06.785]                       muffled <- FALSE
[16:05:06.785]                       if (inherits(cond, "message")) {
[16:05:06.785]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.785]                         if (muffled) 
[16:05:06.785]                           invokeRestart("muffleMessage")
[16:05:06.785]                       }
[16:05:06.785]                       else if (inherits(cond, "warning")) {
[16:05:06.785]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.785]                         if (muffled) 
[16:05:06.785]                           invokeRestart("muffleWarning")
[16:05:06.785]                       }
[16:05:06.785]                       else if (inherits(cond, "condition")) {
[16:05:06.785]                         if (!is.null(pattern)) {
[16:05:06.785]                           computeRestarts <- base::computeRestarts
[16:05:06.785]                           grepl <- base::grepl
[16:05:06.785]                           restarts <- computeRestarts(cond)
[16:05:06.785]                           for (restart in restarts) {
[16:05:06.785]                             name <- restart$name
[16:05:06.785]                             if (is.null(name)) 
[16:05:06.785]                               next
[16:05:06.785]                             if (!grepl(pattern, name)) 
[16:05:06.785]                               next
[16:05:06.785]                             invokeRestart(restart)
[16:05:06.785]                             muffled <- TRUE
[16:05:06.785]                             break
[16:05:06.785]                           }
[16:05:06.785]                         }
[16:05:06.785]                       }
[16:05:06.785]                       invisible(muffled)
[16:05:06.785]                     }
[16:05:06.785]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.785]                   }
[16:05:06.785]                 }
[16:05:06.785]             }
[16:05:06.785]         }))
[16:05:06.785]     }, error = function(ex) {
[16:05:06.785]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.785]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.785]                 ...future.rng), started = ...future.startTime, 
[16:05:06.785]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.785]             version = "1.8"), class = "FutureResult")
[16:05:06.785]     }, finally = {
[16:05:06.785]         if (!identical(...future.workdir, getwd())) 
[16:05:06.785]             setwd(...future.workdir)
[16:05:06.785]         {
[16:05:06.785]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.785]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.785]             }
[16:05:06.785]             base::options(...future.oldOptions)
[16:05:06.785]             if (.Platform$OS.type == "windows") {
[16:05:06.785]                 old_names <- names(...future.oldEnvVars)
[16:05:06.785]                 envs <- base::Sys.getenv()
[16:05:06.785]                 names <- names(envs)
[16:05:06.785]                 common <- intersect(names, old_names)
[16:05:06.785]                 added <- setdiff(names, old_names)
[16:05:06.785]                 removed <- setdiff(old_names, names)
[16:05:06.785]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.785]                   envs[common]]
[16:05:06.785]                 NAMES <- toupper(changed)
[16:05:06.785]                 args <- list()
[16:05:06.785]                 for (kk in seq_along(NAMES)) {
[16:05:06.785]                   name <- changed[[kk]]
[16:05:06.785]                   NAME <- NAMES[[kk]]
[16:05:06.785]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.785]                     next
[16:05:06.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.785]                 }
[16:05:06.785]                 NAMES <- toupper(added)
[16:05:06.785]                 for (kk in seq_along(NAMES)) {
[16:05:06.785]                   name <- added[[kk]]
[16:05:06.785]                   NAME <- NAMES[[kk]]
[16:05:06.785]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.785]                     next
[16:05:06.785]                   args[[name]] <- ""
[16:05:06.785]                 }
[16:05:06.785]                 NAMES <- toupper(removed)
[16:05:06.785]                 for (kk in seq_along(NAMES)) {
[16:05:06.785]                   name <- removed[[kk]]
[16:05:06.785]                   NAME <- NAMES[[kk]]
[16:05:06.785]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.785]                     next
[16:05:06.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.785]                 }
[16:05:06.785]                 if (length(args) > 0) 
[16:05:06.785]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.785]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.785]             }
[16:05:06.785]             else {
[16:05:06.785]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.785]             }
[16:05:06.785]             {
[16:05:06.785]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.785]                   0L) {
[16:05:06.785]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.785]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.785]                   base::options(opts)
[16:05:06.785]                 }
[16:05:06.785]                 {
[16:05:06.785]                   {
[16:05:06.785]                     NULL
[16:05:06.785]                     RNGkind("Mersenne-Twister")
[16:05:06.785]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.785]                       inherits = FALSE)
[16:05:06.785]                   }
[16:05:06.785]                   options(future.plan = NULL)
[16:05:06.785]                   if (is.na(NA_character_)) 
[16:05:06.785]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.785]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.785]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.785]                   {
[16:05:06.785]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.785]                     if (!future$lazy) 
[16:05:06.785]                       future <- run(future)
[16:05:06.785]                     invisible(future)
[16:05:06.785]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.785]                 }
[16:05:06.785]             }
[16:05:06.785]         }
[16:05:06.785]     })
[16:05:06.785]     if (TRUE) {
[16:05:06.785]         base::sink(type = "output", split = FALSE)
[16:05:06.785]         if (TRUE) {
[16:05:06.785]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.785]         }
[16:05:06.785]         else {
[16:05:06.785]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.785]         }
[16:05:06.785]         base::close(...future.stdout)
[16:05:06.785]         ...future.stdout <- NULL
[16:05:06.785]     }
[16:05:06.785]     ...future.result$conditions <- ...future.conditions
[16:05:06.785]     ...future.result$finished <- base::Sys.time()
[16:05:06.785]     ...future.result
[16:05:06.785] }
[16:05:06.787] plan(): Setting new future strategy stack:
[16:05:06.787] List of future strategies:
[16:05:06.787] 1. sequential:
[16:05:06.787]    - args: function (..., envir = parent.frame())
[16:05:06.787]    - tweaked: FALSE
[16:05:06.787]    - call: NULL
[16:05:06.787] plan(): nbrOfWorkers() = 1
[16:05:06.788] plan(): Setting new future strategy stack:
[16:05:06.788] List of future strategies:
[16:05:06.788] 1. sequential:
[16:05:06.788]    - args: function (..., envir = parent.frame())
[16:05:06.788]    - tweaked: FALSE
[16:05:06.788]    - call: plan(strategy)
[16:05:06.788] plan(): nbrOfWorkers() = 1
[16:05:06.788] SequentialFuture started (and completed)
[16:05:06.789] - Launch lazy future ... done
[16:05:06.789] run() for ‘SequentialFuture’ ... done
[16:05:06.789] resolved() for ‘SequentialFuture’ ...
[16:05:06.789] - state: ‘finished’
[16:05:06.789] - run: TRUE
[16:05:06.789] - result: ‘FutureResult’
[16:05:06.789] resolved() for ‘SequentialFuture’ ... done
[16:05:06.789] Future #1
[16:05:06.791] resolved() for ‘SequentialFuture’ ...
[16:05:06.791] - state: ‘finished’
[16:05:06.791] - run: TRUE
[16:05:06.791] - result: ‘FutureResult’
[16:05:06.791] resolved() for ‘SequentialFuture’ ... done
[16:05:06.792] A SequentialFuture was resolved
[16:05:06.792]  length: 0 (resolved future 1)
[16:05:06.792] resolve() on list ... DONE
[16:05:06.792] - globals: [1] ‘a’
[16:05:06.792] Resolving futures part of globals (recursively) ... DONE
[16:05:06.794] The total size of the 1 globals is 1.54 MiB (1616080 bytes)
[16:05:06.794] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.54 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.54 MiB of class ‘environment’)
[16:05:06.795] - globals: [1] ‘a’
[16:05:06.795] - packages: [1] ‘future’
[16:05:06.795] getGlobalsAndPackages() ... DONE
[16:05:06.795] run() for ‘Future’ ...
[16:05:06.795] - state: ‘created’
[16:05:06.795] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.796] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.796] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.796]   - Field: ‘label’
[16:05:06.796]   - Field: ‘local’
[16:05:06.796]   - Field: ‘owner’
[16:05:06.796]   - Field: ‘envir’
[16:05:06.796]   - Field: ‘packages’
[16:05:06.796]   - Field: ‘gc’
[16:05:06.796]   - Field: ‘conditions’
[16:05:06.797]   - Field: ‘expr’
[16:05:06.797]   - Field: ‘uuid’
[16:05:06.797]   - Field: ‘seed’
[16:05:06.797]   - Field: ‘version’
[16:05:06.797]   - Field: ‘result’
[16:05:06.797]   - Field: ‘asynchronous’
[16:05:06.797]   - Field: ‘calls’
[16:05:06.797]   - Field: ‘globals’
[16:05:06.797]   - Field: ‘stdout’
[16:05:06.797]   - Field: ‘earlySignal’
[16:05:06.798]   - Field: ‘lazy’
[16:05:06.798]   - Field: ‘state’
[16:05:06.798] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.798] - Launch lazy future ...
[16:05:06.798] Packages needed by the future expression (n = 1): ‘future’
[16:05:06.798] Packages needed by future strategies (n = 0): <none>
[16:05:06.799] {
[16:05:06.799]     {
[16:05:06.799]         {
[16:05:06.799]             ...future.startTime <- base::Sys.time()
[16:05:06.799]             {
[16:05:06.799]                 {
[16:05:06.799]                   {
[16:05:06.799]                     {
[16:05:06.799]                       base::local({
[16:05:06.799]                         has_future <- base::requireNamespace("future", 
[16:05:06.799]                           quietly = TRUE)
[16:05:06.799]                         if (has_future) {
[16:05:06.799]                           ns <- base::getNamespace("future")
[16:05:06.799]                           version <- ns[[".package"]][["version"]]
[16:05:06.799]                           if (is.null(version)) 
[16:05:06.799]                             version <- utils::packageVersion("future")
[16:05:06.799]                         }
[16:05:06.799]                         else {
[16:05:06.799]                           version <- NULL
[16:05:06.799]                         }
[16:05:06.799]                         if (!has_future || version < "1.8.0") {
[16:05:06.799]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.799]                             "", base::R.version$version.string), 
[16:05:06.799]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:06.799]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.799]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.799]                               "release", "version")], collapse = " "), 
[16:05:06.799]                             hostname = base::Sys.info()[["nodename"]])
[16:05:06.799]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.799]                             info)
[16:05:06.799]                           info <- base::paste(info, collapse = "; ")
[16:05:06.799]                           if (!has_future) {
[16:05:06.799]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.799]                               info)
[16:05:06.799]                           }
[16:05:06.799]                           else {
[16:05:06.799]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.799]                               info, version)
[16:05:06.799]                           }
[16:05:06.799]                           base::stop(msg)
[16:05:06.799]                         }
[16:05:06.799]                       })
[16:05:06.799]                     }
[16:05:06.799]                     base::local({
[16:05:06.799]                       for (pkg in "future") {
[16:05:06.799]                         base::loadNamespace(pkg)
[16:05:06.799]                         base::library(pkg, character.only = TRUE)
[16:05:06.799]                       }
[16:05:06.799]                     })
[16:05:06.799]                   }
[16:05:06.799]                   options(future.plan = NULL)
[16:05:06.799]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.799]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.799]                 }
[16:05:06.799]                 ...future.workdir <- getwd()
[16:05:06.799]             }
[16:05:06.799]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.799]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.799]         }
[16:05:06.799]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.799]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:06.799]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.799]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.799]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.799]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.799]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.799]             base::names(...future.oldOptions))
[16:05:06.799]     }
[16:05:06.799]     if (FALSE) {
[16:05:06.799]     }
[16:05:06.799]     else {
[16:05:06.799]         if (TRUE) {
[16:05:06.799]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.799]                 open = "w")
[16:05:06.799]         }
[16:05:06.799]         else {
[16:05:06.799]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.799]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.799]         }
[16:05:06.799]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.799]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.799]             base::sink(type = "output", split = FALSE)
[16:05:06.799]             base::close(...future.stdout)
[16:05:06.799]         }, add = TRUE)
[16:05:06.799]     }
[16:05:06.799]     ...future.frame <- base::sys.nframe()
[16:05:06.799]     ...future.conditions <- base::list()
[16:05:06.799]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.799]     if (FALSE) {
[16:05:06.799]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.799]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.799]     }
[16:05:06.799]     ...future.result <- base::tryCatch({
[16:05:06.799]         base::withCallingHandlers({
[16:05:06.799]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:05:06.799]                 1))
[16:05:06.799]             future::FutureResult(value = ...future.value$value, 
[16:05:06.799]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.799]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.799]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.799]                     ...future.globalenv.names))
[16:05:06.799]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.799]         }, condition = base::local({
[16:05:06.799]             c <- base::c
[16:05:06.799]             inherits <- base::inherits
[16:05:06.799]             invokeRestart <- base::invokeRestart
[16:05:06.799]             length <- base::length
[16:05:06.799]             list <- base::list
[16:05:06.799]             seq.int <- base::seq.int
[16:05:06.799]             signalCondition <- base::signalCondition
[16:05:06.799]             sys.calls <- base::sys.calls
[16:05:06.799]             `[[` <- base::`[[`
[16:05:06.799]             `+` <- base::`+`
[16:05:06.799]             `<<-` <- base::`<<-`
[16:05:06.799]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.799]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.799]                   3L)]
[16:05:06.799]             }
[16:05:06.799]             function(cond) {
[16:05:06.799]                 is_error <- inherits(cond, "error")
[16:05:06.799]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.799]                   NULL)
[16:05:06.799]                 if (is_error) {
[16:05:06.799]                   sessionInformation <- function() {
[16:05:06.799]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.799]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.799]                       search = base::search(), system = base::Sys.info())
[16:05:06.799]                   }
[16:05:06.799]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.799]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.799]                     cond$call), session = sessionInformation(), 
[16:05:06.799]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.799]                   signalCondition(cond)
[16:05:06.799]                 }
[16:05:06.799]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.799]                 "immediateCondition"))) {
[16:05:06.799]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.799]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.799]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.799]                   if (TRUE && !signal) {
[16:05:06.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.799]                     {
[16:05:06.799]                       inherits <- base::inherits
[16:05:06.799]                       invokeRestart <- base::invokeRestart
[16:05:06.799]                       is.null <- base::is.null
[16:05:06.799]                       muffled <- FALSE
[16:05:06.799]                       if (inherits(cond, "message")) {
[16:05:06.799]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.799]                         if (muffled) 
[16:05:06.799]                           invokeRestart("muffleMessage")
[16:05:06.799]                       }
[16:05:06.799]                       else if (inherits(cond, "warning")) {
[16:05:06.799]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.799]                         if (muffled) 
[16:05:06.799]                           invokeRestart("muffleWarning")
[16:05:06.799]                       }
[16:05:06.799]                       else if (inherits(cond, "condition")) {
[16:05:06.799]                         if (!is.null(pattern)) {
[16:05:06.799]                           computeRestarts <- base::computeRestarts
[16:05:06.799]                           grepl <- base::grepl
[16:05:06.799]                           restarts <- computeRestarts(cond)
[16:05:06.799]                           for (restart in restarts) {
[16:05:06.799]                             name <- restart$name
[16:05:06.799]                             if (is.null(name)) 
[16:05:06.799]                               next
[16:05:06.799]                             if (!grepl(pattern, name)) 
[16:05:06.799]                               next
[16:05:06.799]                             invokeRestart(restart)
[16:05:06.799]                             muffled <- TRUE
[16:05:06.799]                             break
[16:05:06.799]                           }
[16:05:06.799]                         }
[16:05:06.799]                       }
[16:05:06.799]                       invisible(muffled)
[16:05:06.799]                     }
[16:05:06.799]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.799]                   }
[16:05:06.799]                 }
[16:05:06.799]                 else {
[16:05:06.799]                   if (TRUE) {
[16:05:06.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.799]                     {
[16:05:06.799]                       inherits <- base::inherits
[16:05:06.799]                       invokeRestart <- base::invokeRestart
[16:05:06.799]                       is.null <- base::is.null
[16:05:06.799]                       muffled <- FALSE
[16:05:06.799]                       if (inherits(cond, "message")) {
[16:05:06.799]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.799]                         if (muffled) 
[16:05:06.799]                           invokeRestart("muffleMessage")
[16:05:06.799]                       }
[16:05:06.799]                       else if (inherits(cond, "warning")) {
[16:05:06.799]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.799]                         if (muffled) 
[16:05:06.799]                           invokeRestart("muffleWarning")
[16:05:06.799]                       }
[16:05:06.799]                       else if (inherits(cond, "condition")) {
[16:05:06.799]                         if (!is.null(pattern)) {
[16:05:06.799]                           computeRestarts <- base::computeRestarts
[16:05:06.799]                           grepl <- base::grepl
[16:05:06.799]                           restarts <- computeRestarts(cond)
[16:05:06.799]                           for (restart in restarts) {
[16:05:06.799]                             name <- restart$name
[16:05:06.799]                             if (is.null(name)) 
[16:05:06.799]                               next
[16:05:06.799]                             if (!grepl(pattern, name)) 
[16:05:06.799]                               next
[16:05:06.799]                             invokeRestart(restart)
[16:05:06.799]                             muffled <- TRUE
[16:05:06.799]                             break
[16:05:06.799]                           }
[16:05:06.799]                         }
[16:05:06.799]                       }
[16:05:06.799]                       invisible(muffled)
[16:05:06.799]                     }
[16:05:06.799]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.799]                   }
[16:05:06.799]                 }
[16:05:06.799]             }
[16:05:06.799]         }))
[16:05:06.799]     }, error = function(ex) {
[16:05:06.799]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.799]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.799]                 ...future.rng), started = ...future.startTime, 
[16:05:06.799]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.799]             version = "1.8"), class = "FutureResult")
[16:05:06.799]     }, finally = {
[16:05:06.799]         if (!identical(...future.workdir, getwd())) 
[16:05:06.799]             setwd(...future.workdir)
[16:05:06.799]         {
[16:05:06.799]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.799]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.799]             }
[16:05:06.799]             base::options(...future.oldOptions)
[16:05:06.799]             if (.Platform$OS.type == "windows") {
[16:05:06.799]                 old_names <- names(...future.oldEnvVars)
[16:05:06.799]                 envs <- base::Sys.getenv()
[16:05:06.799]                 names <- names(envs)
[16:05:06.799]                 common <- intersect(names, old_names)
[16:05:06.799]                 added <- setdiff(names, old_names)
[16:05:06.799]                 removed <- setdiff(old_names, names)
[16:05:06.799]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.799]                   envs[common]]
[16:05:06.799]                 NAMES <- toupper(changed)
[16:05:06.799]                 args <- list()
[16:05:06.799]                 for (kk in seq_along(NAMES)) {
[16:05:06.799]                   name <- changed[[kk]]
[16:05:06.799]                   NAME <- NAMES[[kk]]
[16:05:06.799]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.799]                     next
[16:05:06.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.799]                 }
[16:05:06.799]                 NAMES <- toupper(added)
[16:05:06.799]                 for (kk in seq_along(NAMES)) {
[16:05:06.799]                   name <- added[[kk]]
[16:05:06.799]                   NAME <- NAMES[[kk]]
[16:05:06.799]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.799]                     next
[16:05:06.799]                   args[[name]] <- ""
[16:05:06.799]                 }
[16:05:06.799]                 NAMES <- toupper(removed)
[16:05:06.799]                 for (kk in seq_along(NAMES)) {
[16:05:06.799]                   name <- removed[[kk]]
[16:05:06.799]                   NAME <- NAMES[[kk]]
[16:05:06.799]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.799]                     next
[16:05:06.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.799]                 }
[16:05:06.799]                 if (length(args) > 0) 
[16:05:06.799]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.799]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.799]             }
[16:05:06.799]             else {
[16:05:06.799]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.799]             }
[16:05:06.799]             {
[16:05:06.799]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.799]                   0L) {
[16:05:06.799]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.799]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.799]                   base::options(opts)
[16:05:06.799]                 }
[16:05:06.799]                 {
[16:05:06.799]                   {
[16:05:06.799]                     NULL
[16:05:06.799]                     RNGkind("Mersenne-Twister")
[16:05:06.799]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.799]                       inherits = FALSE)
[16:05:06.799]                   }
[16:05:06.799]                   options(future.plan = NULL)
[16:05:06.799]                   if (is.na(NA_character_)) 
[16:05:06.799]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.799]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.799]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.799]                   {
[16:05:06.799]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.799]                     if (!future$lazy) 
[16:05:06.799]                       future <- run(future)
[16:05:06.799]                     invisible(future)
[16:05:06.799]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.799]                 }
[16:05:06.799]             }
[16:05:06.799]         }
[16:05:06.799]     })
[16:05:06.799]     if (TRUE) {
[16:05:06.799]         base::sink(type = "output", split = FALSE)
[16:05:06.799]         if (TRUE) {
[16:05:06.799]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.799]         }
[16:05:06.799]         else {
[16:05:06.799]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.799]         }
[16:05:06.799]         base::close(...future.stdout)
[16:05:06.799]         ...future.stdout <- NULL
[16:05:06.799]     }
[16:05:06.799]     ...future.result$conditions <- ...future.conditions
[16:05:06.799]     ...future.result$finished <- base::Sys.time()
[16:05:06.799]     ...future.result
[16:05:06.799] }
[16:05:06.800] assign_globals() ...
[16:05:06.800] List of 1
[16:05:06.800]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a056444b58> 
[16:05:06.800]  - attr(*, "where")=List of 1
[16:05:06.800]   ..$ a:<environment: R_EmptyEnv> 
[16:05:06.800]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.800]  - attr(*, "resolved")= logi TRUE
[16:05:06.800]  - attr(*, "total_size")= num 1616080
[16:05:06.800]  - attr(*, "already-done")= logi TRUE
[16:05:06.803] - copied ‘a’ to environment
[16:05:06.803] assign_globals() ... done
[16:05:06.803] plan(): Setting new future strategy stack:
[16:05:06.804] List of future strategies:
[16:05:06.804] 1. sequential:
[16:05:06.804]    - args: function (..., envir = parent.frame())
[16:05:06.804]    - tweaked: FALSE
[16:05:06.804]    - call: NULL
[16:05:06.804] plan(): nbrOfWorkers() = 1
[16:05:06.805] plan(): Setting new future strategy stack:
[16:05:06.805] List of future strategies:
[16:05:06.805] 1. sequential:
[16:05:06.805]    - args: function (..., envir = parent.frame())
[16:05:06.805]    - tweaked: FALSE
[16:05:06.805]    - call: plan(strategy)
[16:05:06.805] plan(): nbrOfWorkers() = 1
[16:05:06.805] SequentialFuture started (and completed)
[16:05:06.806] - Launch lazy future ... done
[16:05:06.806] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.806] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.806] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:06.807] - globals found: [2] ‘{’, ‘pkg’
[16:05:06.807] Searching for globals ... DONE
[16:05:06.807] Resolving globals: TRUE
[16:05:06.807] Resolving any globals that are futures ...
[16:05:06.807] - globals: [2] ‘{’, ‘pkg’
[16:05:06.808] Resolving any globals that are futures ... DONE
[16:05:06.808] Resolving futures part of globals (recursively) ...
[16:05:06.808] resolve() on list ...
[16:05:06.808]  recursive: 99
[16:05:06.808]  length: 1
[16:05:06.808]  elements: ‘pkg’
[16:05:06.808]  length: 0 (resolved future 1)
[16:05:06.809] resolve() on list ... DONE
[16:05:06.809] - globals: [1] ‘pkg’
[16:05:06.809] Resolving futures part of globals (recursively) ... DONE
[16:05:06.809] The total size of the 1 globals is 112 bytes (112 bytes)
[16:05:06.809] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[16:05:06.809] - globals: [1] ‘pkg’
[16:05:06.810] 
[16:05:06.810] getGlobalsAndPackages() ... DONE
[16:05:06.810] Packages needed by the future expression (n = 0): <none>
[16:05:06.810] Packages needed by future strategies (n = 0): <none>
[16:05:06.810] {
[16:05:06.810]     {
[16:05:06.810]         {
[16:05:06.810]             ...future.startTime <- base::Sys.time()
[16:05:06.810]             {
[16:05:06.810]                 {
[16:05:06.810]                   {
[16:05:06.810]                     base::local({
[16:05:06.810]                       has_future <- base::requireNamespace("future", 
[16:05:06.810]                         quietly = TRUE)
[16:05:06.810]                       if (has_future) {
[16:05:06.810]                         ns <- base::getNamespace("future")
[16:05:06.810]                         version <- ns[[".package"]][["version"]]
[16:05:06.810]                         if (is.null(version)) 
[16:05:06.810]                           version <- utils::packageVersion("future")
[16:05:06.810]                       }
[16:05:06.810]                       else {
[16:05:06.810]                         version <- NULL
[16:05:06.810]                       }
[16:05:06.810]                       if (!has_future || version < "1.8.0") {
[16:05:06.810]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.810]                           "", base::R.version$version.string), 
[16:05:06.810]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.810]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.810]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.810]                             "release", "version")], collapse = " "), 
[16:05:06.810]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.810]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.810]                           info)
[16:05:06.810]                         info <- base::paste(info, collapse = "; ")
[16:05:06.810]                         if (!has_future) {
[16:05:06.810]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.810]                             info)
[16:05:06.810]                         }
[16:05:06.810]                         else {
[16:05:06.810]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.810]                             info, version)
[16:05:06.810]                         }
[16:05:06.810]                         base::stop(msg)
[16:05:06.810]                       }
[16:05:06.810]                     })
[16:05:06.810]                   }
[16:05:06.810]                   options(future.plan = NULL)
[16:05:06.810]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.810]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.810]                 }
[16:05:06.810]                 ...future.workdir <- getwd()
[16:05:06.810]             }
[16:05:06.810]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.810]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.810]         }
[16:05:06.810]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.810]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:06.810]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.810]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.810]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.810]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.810]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.810]             base::names(...future.oldOptions))
[16:05:06.810]     }
[16:05:06.810]     if (FALSE) {
[16:05:06.810]     }
[16:05:06.810]     else {
[16:05:06.810]         if (TRUE) {
[16:05:06.810]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.810]                 open = "w")
[16:05:06.810]         }
[16:05:06.810]         else {
[16:05:06.810]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.810]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.810]         }
[16:05:06.810]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.810]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.810]             base::sink(type = "output", split = FALSE)
[16:05:06.810]             base::close(...future.stdout)
[16:05:06.810]         }, add = TRUE)
[16:05:06.810]     }
[16:05:06.810]     ...future.frame <- base::sys.nframe()
[16:05:06.810]     ...future.conditions <- base::list()
[16:05:06.810]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.810]     if (FALSE) {
[16:05:06.810]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.810]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.810]     }
[16:05:06.810]     ...future.result <- base::tryCatch({
[16:05:06.810]         base::withCallingHandlers({
[16:05:06.810]             ...future.value <- base::withVisible(base::local({
[16:05:06.810]                 pkg
[16:05:06.810]             }))
[16:05:06.810]             future::FutureResult(value = ...future.value$value, 
[16:05:06.810]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.810]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.810]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.810]                     ...future.globalenv.names))
[16:05:06.810]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.810]         }, condition = base::local({
[16:05:06.810]             c <- base::c
[16:05:06.810]             inherits <- base::inherits
[16:05:06.810]             invokeRestart <- base::invokeRestart
[16:05:06.810]             length <- base::length
[16:05:06.810]             list <- base::list
[16:05:06.810]             seq.int <- base::seq.int
[16:05:06.810]             signalCondition <- base::signalCondition
[16:05:06.810]             sys.calls <- base::sys.calls
[16:05:06.810]             `[[` <- base::`[[`
[16:05:06.810]             `+` <- base::`+`
[16:05:06.810]             `<<-` <- base::`<<-`
[16:05:06.810]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.810]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.810]                   3L)]
[16:05:06.810]             }
[16:05:06.810]             function(cond) {
[16:05:06.810]                 is_error <- inherits(cond, "error")
[16:05:06.810]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.810]                   NULL)
[16:05:06.810]                 if (is_error) {
[16:05:06.810]                   sessionInformation <- function() {
[16:05:06.810]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.810]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.810]                       search = base::search(), system = base::Sys.info())
[16:05:06.810]                   }
[16:05:06.810]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.810]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.810]                     cond$call), session = sessionInformation(), 
[16:05:06.810]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.810]                   signalCondition(cond)
[16:05:06.810]                 }
[16:05:06.810]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.810]                 "immediateCondition"))) {
[16:05:06.810]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.810]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.810]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.810]                   if (TRUE && !signal) {
[16:05:06.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.810]                     {
[16:05:06.810]                       inherits <- base::inherits
[16:05:06.810]                       invokeRestart <- base::invokeRestart
[16:05:06.810]                       is.null <- base::is.null
[16:05:06.810]                       muffled <- FALSE
[16:05:06.810]                       if (inherits(cond, "message")) {
[16:05:06.810]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.810]                         if (muffled) 
[16:05:06.810]                           invokeRestart("muffleMessage")
[16:05:06.810]                       }
[16:05:06.810]                       else if (inherits(cond, "warning")) {
[16:05:06.810]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.810]                         if (muffled) 
[16:05:06.810]                           invokeRestart("muffleWarning")
[16:05:06.810]                       }
[16:05:06.810]                       else if (inherits(cond, "condition")) {
[16:05:06.810]                         if (!is.null(pattern)) {
[16:05:06.810]                           computeRestarts <- base::computeRestarts
[16:05:06.810]                           grepl <- base::grepl
[16:05:06.810]                           restarts <- computeRestarts(cond)
[16:05:06.810]                           for (restart in restarts) {
[16:05:06.810]                             name <- restart$name
[16:05:06.810]                             if (is.null(name)) 
[16:05:06.810]                               next
[16:05:06.810]                             if (!grepl(pattern, name)) 
[16:05:06.810]                               next
[16:05:06.810]                             invokeRestart(restart)
[16:05:06.810]                             muffled <- TRUE
[16:05:06.810]                             break
[16:05:06.810]                           }
[16:05:06.810]                         }
[16:05:06.810]                       }
[16:05:06.810]                       invisible(muffled)
[16:05:06.810]                     }
[16:05:06.810]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.810]                   }
[16:05:06.810]                 }
[16:05:06.810]                 else {
[16:05:06.810]                   if (TRUE) {
[16:05:06.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.810]                     {
[16:05:06.810]                       inherits <- base::inherits
[16:05:06.810]                       invokeRestart <- base::invokeRestart
[16:05:06.810]                       is.null <- base::is.null
[16:05:06.810]                       muffled <- FALSE
[16:05:06.810]                       if (inherits(cond, "message")) {
[16:05:06.810]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.810]                         if (muffled) 
[16:05:06.810]                           invokeRestart("muffleMessage")
[16:05:06.810]                       }
[16:05:06.810]                       else if (inherits(cond, "warning")) {
[16:05:06.810]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.810]                         if (muffled) 
[16:05:06.810]                           invokeRestart("muffleWarning")
[16:05:06.810]                       }
[16:05:06.810]                       else if (inherits(cond, "condition")) {
[16:05:06.810]                         if (!is.null(pattern)) {
[16:05:06.810]                           computeRestarts <- base::computeRestarts
[16:05:06.810]                           grepl <- base::grepl
[16:05:06.810]                           restarts <- computeRestarts(cond)
[16:05:06.810]                           for (restart in restarts) {
[16:05:06.810]                             name <- restart$name
[16:05:06.810]                             if (is.null(name)) 
[16:05:06.810]                               next
[16:05:06.810]                             if (!grepl(pattern, name)) 
[16:05:06.810]                               next
[16:05:06.810]                             invokeRestart(restart)
[16:05:06.810]                             muffled <- TRUE
[16:05:06.810]                             break
[16:05:06.810]                           }
[16:05:06.810]                         }
[16:05:06.810]                       }
[16:05:06.810]                       invisible(muffled)
[16:05:06.810]                     }
[16:05:06.810]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.810]                   }
[16:05:06.810]                 }
[16:05:06.810]             }
[16:05:06.810]         }))
[16:05:06.810]     }, error = function(ex) {
[16:05:06.810]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.810]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.810]                 ...future.rng), started = ...future.startTime, 
[16:05:06.810]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.810]             version = "1.8"), class = "FutureResult")
[16:05:06.810]     }, finally = {
[16:05:06.810]         if (!identical(...future.workdir, getwd())) 
[16:05:06.810]             setwd(...future.workdir)
[16:05:06.810]         {
[16:05:06.810]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.810]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.810]             }
[16:05:06.810]             base::options(...future.oldOptions)
[16:05:06.810]             if (.Platform$OS.type == "windows") {
[16:05:06.810]                 old_names <- names(...future.oldEnvVars)
[16:05:06.810]                 envs <- base::Sys.getenv()
[16:05:06.810]                 names <- names(envs)
[16:05:06.810]                 common <- intersect(names, old_names)
[16:05:06.810]                 added <- setdiff(names, old_names)
[16:05:06.810]                 removed <- setdiff(old_names, names)
[16:05:06.810]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.810]                   envs[common]]
[16:05:06.810]                 NAMES <- toupper(changed)
[16:05:06.810]                 args <- list()
[16:05:06.810]                 for (kk in seq_along(NAMES)) {
[16:05:06.810]                   name <- changed[[kk]]
[16:05:06.810]                   NAME <- NAMES[[kk]]
[16:05:06.810]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.810]                     next
[16:05:06.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.810]                 }
[16:05:06.810]                 NAMES <- toupper(added)
[16:05:06.810]                 for (kk in seq_along(NAMES)) {
[16:05:06.810]                   name <- added[[kk]]
[16:05:06.810]                   NAME <- NAMES[[kk]]
[16:05:06.810]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.810]                     next
[16:05:06.810]                   args[[name]] <- ""
[16:05:06.810]                 }
[16:05:06.810]                 NAMES <- toupper(removed)
[16:05:06.810]                 for (kk in seq_along(NAMES)) {
[16:05:06.810]                   name <- removed[[kk]]
[16:05:06.810]                   NAME <- NAMES[[kk]]
[16:05:06.810]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.810]                     next
[16:05:06.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.810]                 }
[16:05:06.810]                 if (length(args) > 0) 
[16:05:06.810]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.810]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.810]             }
[16:05:06.810]             else {
[16:05:06.810]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.810]             }
[16:05:06.810]             {
[16:05:06.810]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.810]                   0L) {
[16:05:06.810]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.810]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.810]                   base::options(opts)
[16:05:06.810]                 }
[16:05:06.810]                 {
[16:05:06.810]                   {
[16:05:06.810]                     NULL
[16:05:06.810]                     RNGkind("Mersenne-Twister")
[16:05:06.810]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.810]                       inherits = FALSE)
[16:05:06.810]                   }
[16:05:06.810]                   options(future.plan = NULL)
[16:05:06.810]                   if (is.na(NA_character_)) 
[16:05:06.810]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.810]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.810]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.810]                   {
[16:05:06.810]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.810]                     if (!future$lazy) 
[16:05:06.810]                       future <- run(future)
[16:05:06.810]                     invisible(future)
[16:05:06.810]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.810]                 }
[16:05:06.810]             }
[16:05:06.810]         }
[16:05:06.810]     })
[16:05:06.810]     if (TRUE) {
[16:05:06.810]         base::sink(type = "output", split = FALSE)
[16:05:06.810]         if (TRUE) {
[16:05:06.810]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.810]         }
[16:05:06.810]         else {
[16:05:06.810]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.810]         }
[16:05:06.810]         base::close(...future.stdout)
[16:05:06.810]         ...future.stdout <- NULL
[16:05:06.810]     }
[16:05:06.810]     ...future.result$conditions <- ...future.conditions
[16:05:06.810]     ...future.result$finished <- base::Sys.time()
[16:05:06.810]     ...future.result
[16:05:06.810] }
[16:05:06.812] assign_globals() ...
[16:05:06.812] List of 1
[16:05:06.812]  $ pkg: chr "foo"
[16:05:06.812]  - attr(*, "where")=List of 1
[16:05:06.812]   ..$ pkg:<environment: R_EmptyEnv> 
[16:05:06.812]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.812]  - attr(*, "resolved")= logi TRUE
[16:05:06.812]  - attr(*, "total_size")= num 112
[16:05:06.814] - copied ‘pkg’ to environment
[16:05:06.814] assign_globals() ... done
[16:05:06.815] plan(): Setting new future strategy stack:
[16:05:06.815] List of future strategies:
[16:05:06.815] 1. sequential:
[16:05:06.815]    - args: function (..., envir = parent.frame())
[16:05:06.815]    - tweaked: FALSE
[16:05:06.815]    - call: NULL
[16:05:06.815] plan(): nbrOfWorkers() = 1
[16:05:06.816] plan(): Setting new future strategy stack:
[16:05:06.816] List of future strategies:
[16:05:06.816] 1. sequential:
[16:05:06.816]    - args: function (..., envir = parent.frame())
[16:05:06.816]    - tweaked: FALSE
[16:05:06.816]    - call: plan(strategy)
[16:05:06.816] plan(): nbrOfWorkers() = 1
[16:05:06.817] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.817] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.817] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:06.819] - globals found: [3] ‘{’, ‘<-’, ‘+’
[16:05:06.819] Searching for globals ... DONE
[16:05:06.821] Resolving globals: TRUE
[16:05:06.821] Resolving any globals that are futures ...
[16:05:06.821] - globals: [3] ‘{’, ‘<-’, ‘+’
[16:05:06.821] Resolving any globals that are futures ... DONE
[16:05:06.822] 
[16:05:06.822] 
[16:05:06.822] getGlobalsAndPackages() ... DONE
[16:05:06.822] run() for ‘Future’ ...
[16:05:06.822] - state: ‘created’
[16:05:06.823] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.823] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.823] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.823]   - Field: ‘label’
[16:05:06.823]   - Field: ‘local’
[16:05:06.824]   - Field: ‘owner’
[16:05:06.824]   - Field: ‘envir’
[16:05:06.824]   - Field: ‘packages’
[16:05:06.824]   - Field: ‘gc’
[16:05:06.824]   - Field: ‘conditions’
[16:05:06.824]   - Field: ‘expr’
[16:05:06.824]   - Field: ‘uuid’
[16:05:06.824]   - Field: ‘seed’
[16:05:06.824]   - Field: ‘version’
[16:05:06.824]   - Field: ‘result’
[16:05:06.825]   - Field: ‘asynchronous’
[16:05:06.825]   - Field: ‘calls’
[16:05:06.825]   - Field: ‘globals’
[16:05:06.825]   - Field: ‘stdout’
[16:05:06.825]   - Field: ‘earlySignal’
[16:05:06.825]   - Field: ‘lazy’
[16:05:06.825]   - Field: ‘state’
[16:05:06.825] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.825] - Launch lazy future ...
[16:05:06.826] Packages needed by the future expression (n = 0): <none>
[16:05:06.826] Packages needed by future strategies (n = 0): <none>
[16:05:06.826] {
[16:05:06.826]     {
[16:05:06.826]         {
[16:05:06.826]             ...future.startTime <- base::Sys.time()
[16:05:06.826]             {
[16:05:06.826]                 {
[16:05:06.826]                   {
[16:05:06.826]                     base::local({
[16:05:06.826]                       has_future <- base::requireNamespace("future", 
[16:05:06.826]                         quietly = TRUE)
[16:05:06.826]                       if (has_future) {
[16:05:06.826]                         ns <- base::getNamespace("future")
[16:05:06.826]                         version <- ns[[".package"]][["version"]]
[16:05:06.826]                         if (is.null(version)) 
[16:05:06.826]                           version <- utils::packageVersion("future")
[16:05:06.826]                       }
[16:05:06.826]                       else {
[16:05:06.826]                         version <- NULL
[16:05:06.826]                       }
[16:05:06.826]                       if (!has_future || version < "1.8.0") {
[16:05:06.826]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.826]                           "", base::R.version$version.string), 
[16:05:06.826]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.826]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.826]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.826]                             "release", "version")], collapse = " "), 
[16:05:06.826]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.826]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.826]                           info)
[16:05:06.826]                         info <- base::paste(info, collapse = "; ")
[16:05:06.826]                         if (!has_future) {
[16:05:06.826]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.826]                             info)
[16:05:06.826]                         }
[16:05:06.826]                         else {
[16:05:06.826]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.826]                             info, version)
[16:05:06.826]                         }
[16:05:06.826]                         base::stop(msg)
[16:05:06.826]                       }
[16:05:06.826]                     })
[16:05:06.826]                   }
[16:05:06.826]                   options(future.plan = NULL)
[16:05:06.826]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.826]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.826]                 }
[16:05:06.826]                 ...future.workdir <- getwd()
[16:05:06.826]             }
[16:05:06.826]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.826]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.826]         }
[16:05:06.826]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.826]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:06.826]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.826]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.826]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.826]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.826]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.826]             base::names(...future.oldOptions))
[16:05:06.826]     }
[16:05:06.826]     if (FALSE) {
[16:05:06.826]     }
[16:05:06.826]     else {
[16:05:06.826]         if (TRUE) {
[16:05:06.826]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.826]                 open = "w")
[16:05:06.826]         }
[16:05:06.826]         else {
[16:05:06.826]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.826]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.826]         }
[16:05:06.826]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.826]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.826]             base::sink(type = "output", split = FALSE)
[16:05:06.826]             base::close(...future.stdout)
[16:05:06.826]         }, add = TRUE)
[16:05:06.826]     }
[16:05:06.826]     ...future.frame <- base::sys.nframe()
[16:05:06.826]     ...future.conditions <- base::list()
[16:05:06.826]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.826]     if (FALSE) {
[16:05:06.826]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.826]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.826]     }
[16:05:06.826]     ...future.result <- base::tryCatch({
[16:05:06.826]         base::withCallingHandlers({
[16:05:06.826]             ...future.value <- base::withVisible(base::local({
[16:05:06.826]                 x <- 0
[16:05:06.826]                 x <- x + 1
[16:05:06.826]                 x
[16:05:06.826]             }))
[16:05:06.826]             future::FutureResult(value = ...future.value$value, 
[16:05:06.826]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.826]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.826]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.826]                     ...future.globalenv.names))
[16:05:06.826]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.826]         }, condition = base::local({
[16:05:06.826]             c <- base::c
[16:05:06.826]             inherits <- base::inherits
[16:05:06.826]             invokeRestart <- base::invokeRestart
[16:05:06.826]             length <- base::length
[16:05:06.826]             list <- base::list
[16:05:06.826]             seq.int <- base::seq.int
[16:05:06.826]             signalCondition <- base::signalCondition
[16:05:06.826]             sys.calls <- base::sys.calls
[16:05:06.826]             `[[` <- base::`[[`
[16:05:06.826]             `+` <- base::`+`
[16:05:06.826]             `<<-` <- base::`<<-`
[16:05:06.826]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.826]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.826]                   3L)]
[16:05:06.826]             }
[16:05:06.826]             function(cond) {
[16:05:06.826]                 is_error <- inherits(cond, "error")
[16:05:06.826]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.826]                   NULL)
[16:05:06.826]                 if (is_error) {
[16:05:06.826]                   sessionInformation <- function() {
[16:05:06.826]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.826]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.826]                       search = base::search(), system = base::Sys.info())
[16:05:06.826]                   }
[16:05:06.826]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.826]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.826]                     cond$call), session = sessionInformation(), 
[16:05:06.826]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.826]                   signalCondition(cond)
[16:05:06.826]                 }
[16:05:06.826]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.826]                 "immediateCondition"))) {
[16:05:06.826]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.826]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.826]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.826]                   if (TRUE && !signal) {
[16:05:06.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.826]                     {
[16:05:06.826]                       inherits <- base::inherits
[16:05:06.826]                       invokeRestart <- base::invokeRestart
[16:05:06.826]                       is.null <- base::is.null
[16:05:06.826]                       muffled <- FALSE
[16:05:06.826]                       if (inherits(cond, "message")) {
[16:05:06.826]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.826]                         if (muffled) 
[16:05:06.826]                           invokeRestart("muffleMessage")
[16:05:06.826]                       }
[16:05:06.826]                       else if (inherits(cond, "warning")) {
[16:05:06.826]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.826]                         if (muffled) 
[16:05:06.826]                           invokeRestart("muffleWarning")
[16:05:06.826]                       }
[16:05:06.826]                       else if (inherits(cond, "condition")) {
[16:05:06.826]                         if (!is.null(pattern)) {
[16:05:06.826]                           computeRestarts <- base::computeRestarts
[16:05:06.826]                           grepl <- base::grepl
[16:05:06.826]                           restarts <- computeRestarts(cond)
[16:05:06.826]                           for (restart in restarts) {
[16:05:06.826]                             name <- restart$name
[16:05:06.826]                             if (is.null(name)) 
[16:05:06.826]                               next
[16:05:06.826]                             if (!grepl(pattern, name)) 
[16:05:06.826]                               next
[16:05:06.826]                             invokeRestart(restart)
[16:05:06.826]                             muffled <- TRUE
[16:05:06.826]                             break
[16:05:06.826]                           }
[16:05:06.826]                         }
[16:05:06.826]                       }
[16:05:06.826]                       invisible(muffled)
[16:05:06.826]                     }
[16:05:06.826]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.826]                   }
[16:05:06.826]                 }
[16:05:06.826]                 else {
[16:05:06.826]                   if (TRUE) {
[16:05:06.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.826]                     {
[16:05:06.826]                       inherits <- base::inherits
[16:05:06.826]                       invokeRestart <- base::invokeRestart
[16:05:06.826]                       is.null <- base::is.null
[16:05:06.826]                       muffled <- FALSE
[16:05:06.826]                       if (inherits(cond, "message")) {
[16:05:06.826]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.826]                         if (muffled) 
[16:05:06.826]                           invokeRestart("muffleMessage")
[16:05:06.826]                       }
[16:05:06.826]                       else if (inherits(cond, "warning")) {
[16:05:06.826]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.826]                         if (muffled) 
[16:05:06.826]                           invokeRestart("muffleWarning")
[16:05:06.826]                       }
[16:05:06.826]                       else if (inherits(cond, "condition")) {
[16:05:06.826]                         if (!is.null(pattern)) {
[16:05:06.826]                           computeRestarts <- base::computeRestarts
[16:05:06.826]                           grepl <- base::grepl
[16:05:06.826]                           restarts <- computeRestarts(cond)
[16:05:06.826]                           for (restart in restarts) {
[16:05:06.826]                             name <- restart$name
[16:05:06.826]                             if (is.null(name)) 
[16:05:06.826]                               next
[16:05:06.826]                             if (!grepl(pattern, name)) 
[16:05:06.826]                               next
[16:05:06.826]                             invokeRestart(restart)
[16:05:06.826]                             muffled <- TRUE
[16:05:06.826]                             break
[16:05:06.826]                           }
[16:05:06.826]                         }
[16:05:06.826]                       }
[16:05:06.826]                       invisible(muffled)
[16:05:06.826]                     }
[16:05:06.826]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.826]                   }
[16:05:06.826]                 }
[16:05:06.826]             }
[16:05:06.826]         }))
[16:05:06.826]     }, error = function(ex) {
[16:05:06.826]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.826]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.826]                 ...future.rng), started = ...future.startTime, 
[16:05:06.826]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.826]             version = "1.8"), class = "FutureResult")
[16:05:06.826]     }, finally = {
[16:05:06.826]         if (!identical(...future.workdir, getwd())) 
[16:05:06.826]             setwd(...future.workdir)
[16:05:06.826]         {
[16:05:06.826]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.826]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.826]             }
[16:05:06.826]             base::options(...future.oldOptions)
[16:05:06.826]             if (.Platform$OS.type == "windows") {
[16:05:06.826]                 old_names <- names(...future.oldEnvVars)
[16:05:06.826]                 envs <- base::Sys.getenv()
[16:05:06.826]                 names <- names(envs)
[16:05:06.826]                 common <- intersect(names, old_names)
[16:05:06.826]                 added <- setdiff(names, old_names)
[16:05:06.826]                 removed <- setdiff(old_names, names)
[16:05:06.826]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.826]                   envs[common]]
[16:05:06.826]                 NAMES <- toupper(changed)
[16:05:06.826]                 args <- list()
[16:05:06.826]                 for (kk in seq_along(NAMES)) {
[16:05:06.826]                   name <- changed[[kk]]
[16:05:06.826]                   NAME <- NAMES[[kk]]
[16:05:06.826]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.826]                     next
[16:05:06.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.826]                 }
[16:05:06.826]                 NAMES <- toupper(added)
[16:05:06.826]                 for (kk in seq_along(NAMES)) {
[16:05:06.826]                   name <- added[[kk]]
[16:05:06.826]                   NAME <- NAMES[[kk]]
[16:05:06.826]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.826]                     next
[16:05:06.826]                   args[[name]] <- ""
[16:05:06.826]                 }
[16:05:06.826]                 NAMES <- toupper(removed)
[16:05:06.826]                 for (kk in seq_along(NAMES)) {
[16:05:06.826]                   name <- removed[[kk]]
[16:05:06.826]                   NAME <- NAMES[[kk]]
[16:05:06.826]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.826]                     next
[16:05:06.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.826]                 }
[16:05:06.826]                 if (length(args) > 0) 
[16:05:06.826]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.826]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.826]             }
[16:05:06.826]             else {
[16:05:06.826]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.826]             }
[16:05:06.826]             {
[16:05:06.826]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.826]                   0L) {
[16:05:06.826]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.826]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.826]                   base::options(opts)
[16:05:06.826]                 }
[16:05:06.826]                 {
[16:05:06.826]                   {
[16:05:06.826]                     NULL
[16:05:06.826]                     RNGkind("Mersenne-Twister")
[16:05:06.826]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.826]                       inherits = FALSE)
[16:05:06.826]                   }
[16:05:06.826]                   options(future.plan = NULL)
[16:05:06.826]                   if (is.na(NA_character_)) 
[16:05:06.826]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.826]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.826]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.826]                   {
[16:05:06.826]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.826]                     if (!future$lazy) 
[16:05:06.826]                       future <- run(future)
[16:05:06.826]                     invisible(future)
[16:05:06.826]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.826]                 }
[16:05:06.826]             }
[16:05:06.826]         }
[16:05:06.826]     })
[16:05:06.826]     if (TRUE) {
[16:05:06.826]         base::sink(type = "output", split = FALSE)
[16:05:06.826]         if (TRUE) {
[16:05:06.826]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.826]         }
[16:05:06.826]         else {
[16:05:06.826]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.826]         }
[16:05:06.826]         base::close(...future.stdout)
[16:05:06.826]         ...future.stdout <- NULL
[16:05:06.826]     }
[16:05:06.826]     ...future.result$conditions <- ...future.conditions
[16:05:06.826]     ...future.result$finished <- base::Sys.time()
[16:05:06.826]     ...future.result
[16:05:06.826] }
[16:05:06.828] plan(): Setting new future strategy stack:
[16:05:06.828] List of future strategies:
[16:05:06.828] 1. sequential:
[16:05:06.828]    - args: function (..., envir = parent.frame())
[16:05:06.828]    - tweaked: FALSE
[16:05:06.828]    - call: NULL
[16:05:06.828] plan(): nbrOfWorkers() = 1
[16:05:06.829] plan(): Setting new future strategy stack:
[16:05:06.829] List of future strategies:
[16:05:06.829] 1. sequential:
[16:05:06.829]    - args: function (..., envir = parent.frame())
[16:05:06.829]    - tweaked: FALSE
[16:05:06.829]    - call: plan(strategy)
[16:05:06.830] plan(): nbrOfWorkers() = 1
[16:05:06.830] SequentialFuture started (and completed)
[16:05:06.830] - Launch lazy future ... done
[16:05:06.830] run() for ‘SequentialFuture’ ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.831] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.831] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:06.832] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[16:05:06.832] Searching for globals ... DONE
[16:05:06.832] Resolving globals: TRUE
[16:05:06.833] Resolving any globals that are futures ...
[16:05:06.833] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[16:05:06.833] Resolving any globals that are futures ... DONE
[16:05:06.833] Resolving futures part of globals (recursively) ...
[16:05:06.833] resolve() on list ...
[16:05:06.833]  recursive: 99
[16:05:06.834]  length: 1
[16:05:06.834]  elements: ‘x’
[16:05:06.834]  length: 0 (resolved future 1)
[16:05:06.834] resolve() on list ... DONE
[16:05:06.834] - globals: [1] ‘x’
[16:05:06.834] Resolving futures part of globals (recursively) ... DONE
[16:05:06.834] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:06.835] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[16:05:06.835] - globals: [1] ‘x’
[16:05:06.835] 
[16:05:06.835] getGlobalsAndPackages() ... DONE
[16:05:06.835] run() for ‘Future’ ...
[16:05:06.835] - state: ‘created’
[16:05:06.835] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.836] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.836] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.836]   - Field: ‘label’
[16:05:06.836]   - Field: ‘local’
[16:05:06.836]   - Field: ‘owner’
[16:05:06.836]   - Field: ‘envir’
[16:05:06.836]   - Field: ‘packages’
[16:05:06.836]   - Field: ‘gc’
[16:05:06.836]   - Field: ‘conditions’
[16:05:06.837]   - Field: ‘expr’
[16:05:06.837]   - Field: ‘uuid’
[16:05:06.837]   - Field: ‘seed’
[16:05:06.837]   - Field: ‘version’
[16:05:06.837]   - Field: ‘result’
[16:05:06.837]   - Field: ‘asynchronous’
[16:05:06.837]   - Field: ‘calls’
[16:05:06.837]   - Field: ‘globals’
[16:05:06.837]   - Field: ‘stdout’
[16:05:06.837]   - Field: ‘earlySignal’
[16:05:06.838]   - Field: ‘lazy’
[16:05:06.838]   - Field: ‘state’
[16:05:06.838] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.838] - Launch lazy future ...
[16:05:06.838] Packages needed by the future expression (n = 0): <none>
[16:05:06.838] Packages needed by future strategies (n = 0): <none>
[16:05:06.839] {
[16:05:06.839]     {
[16:05:06.839]         {
[16:05:06.839]             ...future.startTime <- base::Sys.time()
[16:05:06.839]             {
[16:05:06.839]                 {
[16:05:06.839]                   {
[16:05:06.839]                     base::local({
[16:05:06.839]                       has_future <- base::requireNamespace("future", 
[16:05:06.839]                         quietly = TRUE)
[16:05:06.839]                       if (has_future) {
[16:05:06.839]                         ns <- base::getNamespace("future")
[16:05:06.839]                         version <- ns[[".package"]][["version"]]
[16:05:06.839]                         if (is.null(version)) 
[16:05:06.839]                           version <- utils::packageVersion("future")
[16:05:06.839]                       }
[16:05:06.839]                       else {
[16:05:06.839]                         version <- NULL
[16:05:06.839]                       }
[16:05:06.839]                       if (!has_future || version < "1.8.0") {
[16:05:06.839]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.839]                           "", base::R.version$version.string), 
[16:05:06.839]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.839]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.839]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.839]                             "release", "version")], collapse = " "), 
[16:05:06.839]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.839]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.839]                           info)
[16:05:06.839]                         info <- base::paste(info, collapse = "; ")
[16:05:06.839]                         if (!has_future) {
[16:05:06.839]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.839]                             info)
[16:05:06.839]                         }
[16:05:06.839]                         else {
[16:05:06.839]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.839]                             info, version)
[16:05:06.839]                         }
[16:05:06.839]                         base::stop(msg)
[16:05:06.839]                       }
[16:05:06.839]                     })
[16:05:06.839]                   }
[16:05:06.839]                   options(future.plan = NULL)
[16:05:06.839]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.839]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.839]                 }
[16:05:06.839]                 ...future.workdir <- getwd()
[16:05:06.839]             }
[16:05:06.839]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.839]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.839]         }
[16:05:06.839]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.839]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:06.839]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.839]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.839]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.839]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.839]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.839]             base::names(...future.oldOptions))
[16:05:06.839]     }
[16:05:06.839]     if (FALSE) {
[16:05:06.839]     }
[16:05:06.839]     else {
[16:05:06.839]         if (TRUE) {
[16:05:06.839]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.839]                 open = "w")
[16:05:06.839]         }
[16:05:06.839]         else {
[16:05:06.839]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.839]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.839]         }
[16:05:06.839]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.839]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.839]             base::sink(type = "output", split = FALSE)
[16:05:06.839]             base::close(...future.stdout)
[16:05:06.839]         }, add = TRUE)
[16:05:06.839]     }
[16:05:06.839]     ...future.frame <- base::sys.nframe()
[16:05:06.839]     ...future.conditions <- base::list()
[16:05:06.839]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.839]     if (FALSE) {
[16:05:06.839]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.839]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.839]     }
[16:05:06.839]     ...future.result <- base::tryCatch({
[16:05:06.839]         base::withCallingHandlers({
[16:05:06.839]             ...future.value <- base::withVisible(base::local({
[16:05:06.839]                 x <- x + 1
[16:05:06.839]                 x
[16:05:06.839]             }))
[16:05:06.839]             future::FutureResult(value = ...future.value$value, 
[16:05:06.839]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.839]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.839]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.839]                     ...future.globalenv.names))
[16:05:06.839]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.839]         }, condition = base::local({
[16:05:06.839]             c <- base::c
[16:05:06.839]             inherits <- base::inherits
[16:05:06.839]             invokeRestart <- base::invokeRestart
[16:05:06.839]             length <- base::length
[16:05:06.839]             list <- base::list
[16:05:06.839]             seq.int <- base::seq.int
[16:05:06.839]             signalCondition <- base::signalCondition
[16:05:06.839]             sys.calls <- base::sys.calls
[16:05:06.839]             `[[` <- base::`[[`
[16:05:06.839]             `+` <- base::`+`
[16:05:06.839]             `<<-` <- base::`<<-`
[16:05:06.839]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.839]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.839]                   3L)]
[16:05:06.839]             }
[16:05:06.839]             function(cond) {
[16:05:06.839]                 is_error <- inherits(cond, "error")
[16:05:06.839]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.839]                   NULL)
[16:05:06.839]                 if (is_error) {
[16:05:06.839]                   sessionInformation <- function() {
[16:05:06.839]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.839]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.839]                       search = base::search(), system = base::Sys.info())
[16:05:06.839]                   }
[16:05:06.839]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.839]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.839]                     cond$call), session = sessionInformation(), 
[16:05:06.839]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.839]                   signalCondition(cond)
[16:05:06.839]                 }
[16:05:06.839]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.839]                 "immediateCondition"))) {
[16:05:06.839]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.839]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.839]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.839]                   if (TRUE && !signal) {
[16:05:06.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.839]                     {
[16:05:06.839]                       inherits <- base::inherits
[16:05:06.839]                       invokeRestart <- base::invokeRestart
[16:05:06.839]                       is.null <- base::is.null
[16:05:06.839]                       muffled <- FALSE
[16:05:06.839]                       if (inherits(cond, "message")) {
[16:05:06.839]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.839]                         if (muffled) 
[16:05:06.839]                           invokeRestart("muffleMessage")
[16:05:06.839]                       }
[16:05:06.839]                       else if (inherits(cond, "warning")) {
[16:05:06.839]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.839]                         if (muffled) 
[16:05:06.839]                           invokeRestart("muffleWarning")
[16:05:06.839]                       }
[16:05:06.839]                       else if (inherits(cond, "condition")) {
[16:05:06.839]                         if (!is.null(pattern)) {
[16:05:06.839]                           computeRestarts <- base::computeRestarts
[16:05:06.839]                           grepl <- base::grepl
[16:05:06.839]                           restarts <- computeRestarts(cond)
[16:05:06.839]                           for (restart in restarts) {
[16:05:06.839]                             name <- restart$name
[16:05:06.839]                             if (is.null(name)) 
[16:05:06.839]                               next
[16:05:06.839]                             if (!grepl(pattern, name)) 
[16:05:06.839]                               next
[16:05:06.839]                             invokeRestart(restart)
[16:05:06.839]                             muffled <- TRUE
[16:05:06.839]                             break
[16:05:06.839]                           }
[16:05:06.839]                         }
[16:05:06.839]                       }
[16:05:06.839]                       invisible(muffled)
[16:05:06.839]                     }
[16:05:06.839]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.839]                   }
[16:05:06.839]                 }
[16:05:06.839]                 else {
[16:05:06.839]                   if (TRUE) {
[16:05:06.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.839]                     {
[16:05:06.839]                       inherits <- base::inherits
[16:05:06.839]                       invokeRestart <- base::invokeRestart
[16:05:06.839]                       is.null <- base::is.null
[16:05:06.839]                       muffled <- FALSE
[16:05:06.839]                       if (inherits(cond, "message")) {
[16:05:06.839]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.839]                         if (muffled) 
[16:05:06.839]                           invokeRestart("muffleMessage")
[16:05:06.839]                       }
[16:05:06.839]                       else if (inherits(cond, "warning")) {
[16:05:06.839]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.839]                         if (muffled) 
[16:05:06.839]                           invokeRestart("muffleWarning")
[16:05:06.839]                       }
[16:05:06.839]                       else if (inherits(cond, "condition")) {
[16:05:06.839]                         if (!is.null(pattern)) {
[16:05:06.839]                           computeRestarts <- base::computeRestarts
[16:05:06.839]                           grepl <- base::grepl
[16:05:06.839]                           restarts <- computeRestarts(cond)
[16:05:06.839]                           for (restart in restarts) {
[16:05:06.839]                             name <- restart$name
[16:05:06.839]                             if (is.null(name)) 
[16:05:06.839]                               next
[16:05:06.839]                             if (!grepl(pattern, name)) 
[16:05:06.839]                               next
[16:05:06.839]                             invokeRestart(restart)
[16:05:06.839]                             muffled <- TRUE
[16:05:06.839]                             break
[16:05:06.839]                           }
[16:05:06.839]                         }
[16:05:06.839]                       }
[16:05:06.839]                       invisible(muffled)
[16:05:06.839]                     }
[16:05:06.839]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.839]                   }
[16:05:06.839]                 }
[16:05:06.839]             }
[16:05:06.839]         }))
[16:05:06.839]     }, error = function(ex) {
[16:05:06.839]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.839]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.839]                 ...future.rng), started = ...future.startTime, 
[16:05:06.839]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.839]             version = "1.8"), class = "FutureResult")
[16:05:06.839]     }, finally = {
[16:05:06.839]         if (!identical(...future.workdir, getwd())) 
[16:05:06.839]             setwd(...future.workdir)
[16:05:06.839]         {
[16:05:06.839]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.839]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.839]             }
[16:05:06.839]             base::options(...future.oldOptions)
[16:05:06.839]             if (.Platform$OS.type == "windows") {
[16:05:06.839]                 old_names <- names(...future.oldEnvVars)
[16:05:06.839]                 envs <- base::Sys.getenv()
[16:05:06.839]                 names <- names(envs)
[16:05:06.839]                 common <- intersect(names, old_names)
[16:05:06.839]                 added <- setdiff(names, old_names)
[16:05:06.839]                 removed <- setdiff(old_names, names)
[16:05:06.839]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.839]                   envs[common]]
[16:05:06.839]                 NAMES <- toupper(changed)
[16:05:06.839]                 args <- list()
[16:05:06.839]                 for (kk in seq_along(NAMES)) {
[16:05:06.839]                   name <- changed[[kk]]
[16:05:06.839]                   NAME <- NAMES[[kk]]
[16:05:06.839]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.839]                     next
[16:05:06.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.839]                 }
[16:05:06.839]                 NAMES <- toupper(added)
[16:05:06.839]                 for (kk in seq_along(NAMES)) {
[16:05:06.839]                   name <- added[[kk]]
[16:05:06.839]                   NAME <- NAMES[[kk]]
[16:05:06.839]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.839]                     next
[16:05:06.839]                   args[[name]] <- ""
[16:05:06.839]                 }
[16:05:06.839]                 NAMES <- toupper(removed)
[16:05:06.839]                 for (kk in seq_along(NAMES)) {
[16:05:06.839]                   name <- removed[[kk]]
[16:05:06.839]                   NAME <- NAMES[[kk]]
[16:05:06.839]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.839]                     next
[16:05:06.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.839]                 }
[16:05:06.839]                 if (length(args) > 0) 
[16:05:06.839]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.839]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.839]             }
[16:05:06.839]             else {
[16:05:06.839]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.839]             }
[16:05:06.839]             {
[16:05:06.839]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.839]                   0L) {
[16:05:06.839]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.839]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.839]                   base::options(opts)
[16:05:06.839]                 }
[16:05:06.839]                 {
[16:05:06.839]                   {
[16:05:06.839]                     NULL
[16:05:06.839]                     RNGkind("Mersenne-Twister")
[16:05:06.839]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.839]                       inherits = FALSE)
[16:05:06.839]                   }
[16:05:06.839]                   options(future.plan = NULL)
[16:05:06.839]                   if (is.na(NA_character_)) 
[16:05:06.839]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.839]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.839]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.839]                   {
[16:05:06.839]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.839]                     if (!future$lazy) 
[16:05:06.839]                       future <- run(future)
[16:05:06.839]                     invisible(future)
[16:05:06.839]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.839]                 }
[16:05:06.839]             }
[16:05:06.839]         }
[16:05:06.839]     })
[16:05:06.839]     if (TRUE) {
[16:05:06.839]         base::sink(type = "output", split = FALSE)
[16:05:06.839]         if (TRUE) {
[16:05:06.839]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.839]         }
[16:05:06.839]         else {
[16:05:06.839]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.839]         }
[16:05:06.839]         base::close(...future.stdout)
[16:05:06.839]         ...future.stdout <- NULL
[16:05:06.839]     }
[16:05:06.839]     ...future.result$conditions <- ...future.conditions
[16:05:06.839]     ...future.result$finished <- base::Sys.time()
[16:05:06.839]     ...future.result
[16:05:06.839] }
[16:05:06.840] assign_globals() ...
[16:05:06.840] List of 1
[16:05:06.840]  $ x: num 1
[16:05:06.840]  - attr(*, "where")=List of 1
[16:05:06.840]   ..$ x:<environment: R_EmptyEnv> 
[16:05:06.840]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.840]  - attr(*, "resolved")= logi TRUE
[16:05:06.840]  - attr(*, "total_size")= num 56
[16:05:06.840]  - attr(*, "already-done")= logi TRUE
[16:05:06.843] - copied ‘x’ to environment
[16:05:06.843] assign_globals() ... done
[16:05:06.843] plan(): Setting new future strategy stack:
[16:05:06.843] List of future strategies:
[16:05:06.843] 1. sequential:
[16:05:06.843]    - args: function (..., envir = parent.frame())
[16:05:06.843]    - tweaked: FALSE
[16:05:06.843]    - call: NULL
[16:05:06.844] plan(): nbrOfWorkers() = 1
[16:05:06.845] plan(): Setting new future strategy stack:
[16:05:06.845] List of future strategies:
[16:05:06.845] 1. sequential:
[16:05:06.845]    - args: function (..., envir = parent.frame())
[16:05:06.845]    - tweaked: FALSE
[16:05:06.845]    - call: plan(strategy)
[16:05:06.845] plan(): nbrOfWorkers() = 1
[16:05:06.845] SequentialFuture started (and completed)
[16:05:06.845] - Launch lazy future ... done
[16:05:06.845] run() for ‘SequentialFuture’ ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.846] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.846] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:06.848] - globals found: [3] ‘{’, ‘<-’, ‘x’
[16:05:06.848] Searching for globals ... DONE
[16:05:06.848] Resolving globals: TRUE
[16:05:06.848] Resolving any globals that are futures ...
[16:05:06.848] - globals: [3] ‘{’, ‘<-’, ‘x’
[16:05:06.849] Resolving any globals that are futures ... DONE
[16:05:06.849] Resolving futures part of globals (recursively) ...
[16:05:06.849] resolve() on list ...
[16:05:06.849]  recursive: 99
[16:05:06.849]  length: 1
[16:05:06.849]  elements: ‘x’
[16:05:06.850]  length: 0 (resolved future 1)
[16:05:06.850] resolve() on list ... DONE
[16:05:06.850] - globals: [1] ‘x’
[16:05:06.850] Resolving futures part of globals (recursively) ... DONE
[16:05:06.850] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[16:05:06.852] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[16:05:06.853] - globals: [1] ‘x’
[16:05:06.853] 
[16:05:06.853] getGlobalsAndPackages() ... DONE
[16:05:06.853] run() for ‘Future’ ...
[16:05:06.853] - state: ‘created’
[16:05:06.853] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:06.854] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:06.854] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:06.854]   - Field: ‘label’
[16:05:06.854]   - Field: ‘local’
[16:05:06.854]   - Field: ‘owner’
[16:05:06.854]   - Field: ‘envir’
[16:05:06.854]   - Field: ‘packages’
[16:05:06.855]   - Field: ‘gc’
[16:05:06.855]   - Field: ‘conditions’
[16:05:06.855]   - Field: ‘expr’
[16:05:06.855]   - Field: ‘uuid’
[16:05:06.855]   - Field: ‘seed’
[16:05:06.855]   - Field: ‘version’
[16:05:06.855]   - Field: ‘result’
[16:05:06.855]   - Field: ‘asynchronous’
[16:05:06.855]   - Field: ‘calls’
[16:05:06.856]   - Field: ‘globals’
[16:05:06.856]   - Field: ‘stdout’
[16:05:06.856]   - Field: ‘earlySignal’
[16:05:06.856]   - Field: ‘lazy’
[16:05:06.856]   - Field: ‘state’
[16:05:06.856] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:06.856] - Launch lazy future ...
[16:05:06.856] Packages needed by the future expression (n = 0): <none>
[16:05:06.856] Packages needed by future strategies (n = 0): <none>
[16:05:06.857] {
[16:05:06.857]     {
[16:05:06.857]         {
[16:05:06.857]             ...future.startTime <- base::Sys.time()
[16:05:06.857]             {
[16:05:06.857]                 {
[16:05:06.857]                   {
[16:05:06.857]                     base::local({
[16:05:06.857]                       has_future <- base::requireNamespace("future", 
[16:05:06.857]                         quietly = TRUE)
[16:05:06.857]                       if (has_future) {
[16:05:06.857]                         ns <- base::getNamespace("future")
[16:05:06.857]                         version <- ns[[".package"]][["version"]]
[16:05:06.857]                         if (is.null(version)) 
[16:05:06.857]                           version <- utils::packageVersion("future")
[16:05:06.857]                       }
[16:05:06.857]                       else {
[16:05:06.857]                         version <- NULL
[16:05:06.857]                       }
[16:05:06.857]                       if (!has_future || version < "1.8.0") {
[16:05:06.857]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.857]                           "", base::R.version$version.string), 
[16:05:06.857]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:06.857]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.857]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.857]                             "release", "version")], collapse = " "), 
[16:05:06.857]                           hostname = base::Sys.info()[["nodename"]])
[16:05:06.857]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.857]                           info)
[16:05:06.857]                         info <- base::paste(info, collapse = "; ")
[16:05:06.857]                         if (!has_future) {
[16:05:06.857]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.857]                             info)
[16:05:06.857]                         }
[16:05:06.857]                         else {
[16:05:06.857]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.857]                             info, version)
[16:05:06.857]                         }
[16:05:06.857]                         base::stop(msg)
[16:05:06.857]                       }
[16:05:06.857]                     })
[16:05:06.857]                   }
[16:05:06.857]                   options(future.plan = NULL)
[16:05:06.857]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.857]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.857]                 }
[16:05:06.857]                 ...future.workdir <- getwd()
[16:05:06.857]             }
[16:05:06.857]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.857]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.857]         }
[16:05:06.857]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.857]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:06.857]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.857]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.857]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.857]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.857]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.857]             base::names(...future.oldOptions))
[16:05:06.857]     }
[16:05:06.857]     if (FALSE) {
[16:05:06.857]     }
[16:05:06.857]     else {
[16:05:06.857]         if (TRUE) {
[16:05:06.857]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.857]                 open = "w")
[16:05:06.857]         }
[16:05:06.857]         else {
[16:05:06.857]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.857]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.857]         }
[16:05:06.857]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.857]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.857]             base::sink(type = "output", split = FALSE)
[16:05:06.857]             base::close(...future.stdout)
[16:05:06.857]         }, add = TRUE)
[16:05:06.857]     }
[16:05:06.857]     ...future.frame <- base::sys.nframe()
[16:05:06.857]     ...future.conditions <- base::list()
[16:05:06.857]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.857]     if (FALSE) {
[16:05:06.857]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.857]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.857]     }
[16:05:06.857]     ...future.result <- base::tryCatch({
[16:05:06.857]         base::withCallingHandlers({
[16:05:06.857]             ...future.value <- base::withVisible(base::local({
[16:05:06.857]                 x <- x()
[16:05:06.857]                 x
[16:05:06.857]             }))
[16:05:06.857]             future::FutureResult(value = ...future.value$value, 
[16:05:06.857]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.857]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.857]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.857]                     ...future.globalenv.names))
[16:05:06.857]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.857]         }, condition = base::local({
[16:05:06.857]             c <- base::c
[16:05:06.857]             inherits <- base::inherits
[16:05:06.857]             invokeRestart <- base::invokeRestart
[16:05:06.857]             length <- base::length
[16:05:06.857]             list <- base::list
[16:05:06.857]             seq.int <- base::seq.int
[16:05:06.857]             signalCondition <- base::signalCondition
[16:05:06.857]             sys.calls <- base::sys.calls
[16:05:06.857]             `[[` <- base::`[[`
[16:05:06.857]             `+` <- base::`+`
[16:05:06.857]             `<<-` <- base::`<<-`
[16:05:06.857]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.857]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.857]                   3L)]
[16:05:06.857]             }
[16:05:06.857]             function(cond) {
[16:05:06.857]                 is_error <- inherits(cond, "error")
[16:05:06.857]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.857]                   NULL)
[16:05:06.857]                 if (is_error) {
[16:05:06.857]                   sessionInformation <- function() {
[16:05:06.857]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.857]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.857]                       search = base::search(), system = base::Sys.info())
[16:05:06.857]                   }
[16:05:06.857]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.857]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.857]                     cond$call), session = sessionInformation(), 
[16:05:06.857]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.857]                   signalCondition(cond)
[16:05:06.857]                 }
[16:05:06.857]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.857]                 "immediateCondition"))) {
[16:05:06.857]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.857]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.857]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.857]                   if (TRUE && !signal) {
[16:05:06.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.857]                     {
[16:05:06.857]                       inherits <- base::inherits
[16:05:06.857]                       invokeRestart <- base::invokeRestart
[16:05:06.857]                       is.null <- base::is.null
[16:05:06.857]                       muffled <- FALSE
[16:05:06.857]                       if (inherits(cond, "message")) {
[16:05:06.857]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.857]                         if (muffled) 
[16:05:06.857]                           invokeRestart("muffleMessage")
[16:05:06.857]                       }
[16:05:06.857]                       else if (inherits(cond, "warning")) {
[16:05:06.857]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.857]                         if (muffled) 
[16:05:06.857]                           invokeRestart("muffleWarning")
[16:05:06.857]                       }
[16:05:06.857]                       else if (inherits(cond, "condition")) {
[16:05:06.857]                         if (!is.null(pattern)) {
[16:05:06.857]                           computeRestarts <- base::computeRestarts
[16:05:06.857]                           grepl <- base::grepl
[16:05:06.857]                           restarts <- computeRestarts(cond)
[16:05:06.857]                           for (restart in restarts) {
[16:05:06.857]                             name <- restart$name
[16:05:06.857]                             if (is.null(name)) 
[16:05:06.857]                               next
[16:05:06.857]                             if (!grepl(pattern, name)) 
[16:05:06.857]                               next
[16:05:06.857]                             invokeRestart(restart)
[16:05:06.857]                             muffled <- TRUE
[16:05:06.857]                             break
[16:05:06.857]                           }
[16:05:06.857]                         }
[16:05:06.857]                       }
[16:05:06.857]                       invisible(muffled)
[16:05:06.857]                     }
[16:05:06.857]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.857]                   }
[16:05:06.857]                 }
[16:05:06.857]                 else {
[16:05:06.857]                   if (TRUE) {
[16:05:06.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.857]                     {
[16:05:06.857]                       inherits <- base::inherits
[16:05:06.857]                       invokeRestart <- base::invokeRestart
[16:05:06.857]                       is.null <- base::is.null
[16:05:06.857]                       muffled <- FALSE
[16:05:06.857]                       if (inherits(cond, "message")) {
[16:05:06.857]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.857]                         if (muffled) 
[16:05:06.857]                           invokeRestart("muffleMessage")
[16:05:06.857]                       }
[16:05:06.857]                       else if (inherits(cond, "warning")) {
[16:05:06.857]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.857]                         if (muffled) 
[16:05:06.857]                           invokeRestart("muffleWarning")
[16:05:06.857]                       }
[16:05:06.857]                       else if (inherits(cond, "condition")) {
[16:05:06.857]                         if (!is.null(pattern)) {
[16:05:06.857]                           computeRestarts <- base::computeRestarts
[16:05:06.857]                           grepl <- base::grepl
[16:05:06.857]                           restarts <- computeRestarts(cond)
[16:05:06.857]                           for (restart in restarts) {
[16:05:06.857]                             name <- restart$name
[16:05:06.857]                             if (is.null(name)) 
[16:05:06.857]                               next
[16:05:06.857]                             if (!grepl(pattern, name)) 
[16:05:06.857]                               next
[16:05:06.857]                             invokeRestart(restart)
[16:05:06.857]                             muffled <- TRUE
[16:05:06.857]                             break
[16:05:06.857]                           }
[16:05:06.857]                         }
[16:05:06.857]                       }
[16:05:06.857]                       invisible(muffled)
[16:05:06.857]                     }
[16:05:06.857]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.857]                   }
[16:05:06.857]                 }
[16:05:06.857]             }
[16:05:06.857]         }))
[16:05:06.857]     }, error = function(ex) {
[16:05:06.857]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.857]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.857]                 ...future.rng), started = ...future.startTime, 
[16:05:06.857]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.857]             version = "1.8"), class = "FutureResult")
[16:05:06.857]     }, finally = {
[16:05:06.857]         if (!identical(...future.workdir, getwd())) 
[16:05:06.857]             setwd(...future.workdir)
[16:05:06.857]         {
[16:05:06.857]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.857]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.857]             }
[16:05:06.857]             base::options(...future.oldOptions)
[16:05:06.857]             if (.Platform$OS.type == "windows") {
[16:05:06.857]                 old_names <- names(...future.oldEnvVars)
[16:05:06.857]                 envs <- base::Sys.getenv()
[16:05:06.857]                 names <- names(envs)
[16:05:06.857]                 common <- intersect(names, old_names)
[16:05:06.857]                 added <- setdiff(names, old_names)
[16:05:06.857]                 removed <- setdiff(old_names, names)
[16:05:06.857]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.857]                   envs[common]]
[16:05:06.857]                 NAMES <- toupper(changed)
[16:05:06.857]                 args <- list()
[16:05:06.857]                 for (kk in seq_along(NAMES)) {
[16:05:06.857]                   name <- changed[[kk]]
[16:05:06.857]                   NAME <- NAMES[[kk]]
[16:05:06.857]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.857]                     next
[16:05:06.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.857]                 }
[16:05:06.857]                 NAMES <- toupper(added)
[16:05:06.857]                 for (kk in seq_along(NAMES)) {
[16:05:06.857]                   name <- added[[kk]]
[16:05:06.857]                   NAME <- NAMES[[kk]]
[16:05:06.857]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.857]                     next
[16:05:06.857]                   args[[name]] <- ""
[16:05:06.857]                 }
[16:05:06.857]                 NAMES <- toupper(removed)
[16:05:06.857]                 for (kk in seq_along(NAMES)) {
[16:05:06.857]                   name <- removed[[kk]]
[16:05:06.857]                   NAME <- NAMES[[kk]]
[16:05:06.857]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.857]                     next
[16:05:06.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.857]                 }
[16:05:06.857]                 if (length(args) > 0) 
[16:05:06.857]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.857]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.857]             }
[16:05:06.857]             else {
[16:05:06.857]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.857]             }
[16:05:06.857]             {
[16:05:06.857]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.857]                   0L) {
[16:05:06.857]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.857]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.857]                   base::options(opts)
[16:05:06.857]                 }
[16:05:06.857]                 {
[16:05:06.857]                   {
[16:05:06.857]                     NULL
[16:05:06.857]                     RNGkind("Mersenne-Twister")
[16:05:06.857]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:06.857]                       inherits = FALSE)
[16:05:06.857]                   }
[16:05:06.857]                   options(future.plan = NULL)
[16:05:06.857]                   if (is.na(NA_character_)) 
[16:05:06.857]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.857]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.857]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:06.857]                   {
[16:05:06.857]                     future <- SequentialFuture(..., envir = envir)
[16:05:06.857]                     if (!future$lazy) 
[16:05:06.857]                       future <- run(future)
[16:05:06.857]                     invisible(future)
[16:05:06.857]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.857]                 }
[16:05:06.857]             }
[16:05:06.857]         }
[16:05:06.857]     })
[16:05:06.857]     if (TRUE) {
[16:05:06.857]         base::sink(type = "output", split = FALSE)
[16:05:06.857]         if (TRUE) {
[16:05:06.857]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.857]         }
[16:05:06.857]         else {
[16:05:06.857]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.857]         }
[16:05:06.857]         base::close(...future.stdout)
[16:05:06.857]         ...future.stdout <- NULL
[16:05:06.857]     }
[16:05:06.857]     ...future.result$conditions <- ...future.conditions
[16:05:06.857]     ...future.result$finished <- base::Sys.time()
[16:05:06.857]     ...future.result
[16:05:06.857] }
[16:05:06.859] assign_globals() ...
[16:05:06.859] List of 1
[16:05:06.859]  $ x:function ()  
[16:05:06.859]  - attr(*, "where")=List of 1
[16:05:06.859]   ..$ x:<environment: R_EmptyEnv> 
[16:05:06.859]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.859]  - attr(*, "resolved")= logi TRUE
[16:05:06.859]  - attr(*, "total_size")= num 1032
[16:05:06.859]  - attr(*, "already-done")= logi TRUE
[16:05:06.861] - reassign environment for ‘x’
[16:05:06.862] - copied ‘x’ to environment
[16:05:06.862] assign_globals() ... done
[16:05:06.862] plan(): Setting new future strategy stack:
[16:05:06.862] List of future strategies:
[16:05:06.862] 1. sequential:
[16:05:06.862]    - args: function (..., envir = parent.frame())
[16:05:06.862]    - tweaked: FALSE
[16:05:06.862]    - call: NULL
[16:05:06.862] plan(): nbrOfWorkers() = 1
[16:05:06.863] plan(): Setting new future strategy stack:
[16:05:06.863] List of future strategies:
[16:05:06.863] 1. sequential:
[16:05:06.863]    - args: function (..., envir = parent.frame())
[16:05:06.863]    - tweaked: FALSE
[16:05:06.863]    - call: plan(strategy)
[16:05:06.864] plan(): nbrOfWorkers() = 1
[16:05:06.864] SequentialFuture started (and completed)
[16:05:06.864] - Launch lazy future ... done
[16:05:06.864] run() for ‘SequentialFuture’ ... done
value(f) = ‘TRUE’
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- Local variables with the same name as globals ...
- plan('multicore') ...
[16:05:06.873] plan(): Setting new future strategy stack:
[16:05:06.873] List of future strategies:
[16:05:06.873] 1. multicore:
[16:05:06.873]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:06.873]    - tweaked: FALSE
[16:05:06.873]    - call: plan(strategy)
[16:05:06.877] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.878] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.878] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:06.879] - globals found: [3] ‘{’, ‘<-’, ‘*’
[16:05:06.879] Searching for globals ... DONE
[16:05:06.880] Resolving globals: TRUE
[16:05:06.880] Resolving any globals that are futures ...
[16:05:06.880] - globals: [3] ‘{’, ‘<-’, ‘*’
[16:05:06.880] Resolving any globals that are futures ... DONE
[16:05:06.880] 
[16:05:06.880] 
[16:05:06.880] getGlobalsAndPackages() ... DONE
[16:05:06.881] run() for ‘Future’ ...
[16:05:06.881] - state: ‘created’
[16:05:06.881] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:06.884] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:06.885] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:06.885]   - Field: ‘label’
[16:05:06.885]   - Field: ‘local’
[16:05:06.885]   - Field: ‘owner’
[16:05:06.885]   - Field: ‘envir’
[16:05:06.885]   - Field: ‘workers’
[16:05:06.885]   - Field: ‘packages’
[16:05:06.887]   - Field: ‘gc’
[16:05:06.887]   - Field: ‘job’
[16:05:06.887]   - Field: ‘conditions’
[16:05:06.888]   - Field: ‘expr’
[16:05:06.888]   - Field: ‘uuid’
[16:05:06.888]   - Field: ‘seed’
[16:05:06.888]   - Field: ‘version’
[16:05:06.888]   - Field: ‘result’
[16:05:06.888]   - Field: ‘asynchronous’
[16:05:06.888]   - Field: ‘calls’
[16:05:06.888]   - Field: ‘globals’
[16:05:06.888]   - Field: ‘stdout’
[16:05:06.889]   - Field: ‘earlySignal’
[16:05:06.889]   - Field: ‘lazy’
[16:05:06.889]   - Field: ‘state’
[16:05:06.889] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:06.889] - Launch lazy future ...
[16:05:06.890] Packages needed by the future expression (n = 0): <none>
[16:05:06.890] Packages needed by future strategies (n = 0): <none>
[16:05:06.891] {
[16:05:06.891]     {
[16:05:06.891]         {
[16:05:06.891]             ...future.startTime <- base::Sys.time()
[16:05:06.891]             {
[16:05:06.891]                 {
[16:05:06.891]                   {
[16:05:06.891]                     {
[16:05:06.891]                       base::local({
[16:05:06.891]                         has_future <- base::requireNamespace("future", 
[16:05:06.891]                           quietly = TRUE)
[16:05:06.891]                         if (has_future) {
[16:05:06.891]                           ns <- base::getNamespace("future")
[16:05:06.891]                           version <- ns[[".package"]][["version"]]
[16:05:06.891]                           if (is.null(version)) 
[16:05:06.891]                             version <- utils::packageVersion("future")
[16:05:06.891]                         }
[16:05:06.891]                         else {
[16:05:06.891]                           version <- NULL
[16:05:06.891]                         }
[16:05:06.891]                         if (!has_future || version < "1.8.0") {
[16:05:06.891]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.891]                             "", base::R.version$version.string), 
[16:05:06.891]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:06.891]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.891]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.891]                               "release", "version")], collapse = " "), 
[16:05:06.891]                             hostname = base::Sys.info()[["nodename"]])
[16:05:06.891]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.891]                             info)
[16:05:06.891]                           info <- base::paste(info, collapse = "; ")
[16:05:06.891]                           if (!has_future) {
[16:05:06.891]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.891]                               info)
[16:05:06.891]                           }
[16:05:06.891]                           else {
[16:05:06.891]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.891]                               info, version)
[16:05:06.891]                           }
[16:05:06.891]                           base::stop(msg)
[16:05:06.891]                         }
[16:05:06.891]                       })
[16:05:06.891]                     }
[16:05:06.891]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:06.891]                     base::options(mc.cores = 1L)
[16:05:06.891]                   }
[16:05:06.891]                   options(future.plan = NULL)
[16:05:06.891]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.891]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.891]                 }
[16:05:06.891]                 ...future.workdir <- getwd()
[16:05:06.891]             }
[16:05:06.891]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.891]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.891]         }
[16:05:06.891]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.891]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:06.891]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.891]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.891]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.891]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.891]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.891]             base::names(...future.oldOptions))
[16:05:06.891]     }
[16:05:06.891]     if (FALSE) {
[16:05:06.891]     }
[16:05:06.891]     else {
[16:05:06.891]         if (TRUE) {
[16:05:06.891]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.891]                 open = "w")
[16:05:06.891]         }
[16:05:06.891]         else {
[16:05:06.891]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.891]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.891]         }
[16:05:06.891]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.891]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.891]             base::sink(type = "output", split = FALSE)
[16:05:06.891]             base::close(...future.stdout)
[16:05:06.891]         }, add = TRUE)
[16:05:06.891]     }
[16:05:06.891]     ...future.frame <- base::sys.nframe()
[16:05:06.891]     ...future.conditions <- base::list()
[16:05:06.891]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.891]     if (FALSE) {
[16:05:06.891]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.891]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.891]     }
[16:05:06.891]     ...future.result <- base::tryCatch({
[16:05:06.891]         base::withCallingHandlers({
[16:05:06.891]             ...future.value <- base::withVisible(base::local({
[16:05:06.891]                 withCallingHandlers({
[16:05:06.891]                   {
[16:05:06.891]                     b <- a
[16:05:06.891]                     a <- 2
[16:05:06.891]                     a * b
[16:05:06.891]                   }
[16:05:06.891]                 }, immediateCondition = function(cond) {
[16:05:06.891]                   save_rds <- function (object, pathname, ...) 
[16:05:06.891]                   {
[16:05:06.891]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:06.891]                     if (file_test("-f", pathname_tmp)) {
[16:05:06.891]                       fi_tmp <- file.info(pathname_tmp)
[16:05:06.891]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:06.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:06.891]                         fi_tmp[["mtime"]])
[16:05:06.891]                     }
[16:05:06.891]                     tryCatch({
[16:05:06.891]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:06.891]                     }, error = function(ex) {
[16:05:06.891]                       msg <- conditionMessage(ex)
[16:05:06.891]                       fi_tmp <- file.info(pathname_tmp)
[16:05:06.891]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:06.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:06.891]                         fi_tmp[["mtime"]], msg)
[16:05:06.891]                       ex$message <- msg
[16:05:06.891]                       stop(ex)
[16:05:06.891]                     })
[16:05:06.891]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:06.891]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:06.891]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:06.891]                       fi_tmp <- file.info(pathname_tmp)
[16:05:06.891]                       fi <- file.info(pathname)
[16:05:06.891]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:06.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:06.891]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:06.891]                         fi[["size"]], fi[["mtime"]])
[16:05:06.891]                       stop(msg)
[16:05:06.891]                     }
[16:05:06.891]                     invisible(pathname)
[16:05:06.891]                   }
[16:05:06.891]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:06.891]                     rootPath = tempdir()) 
[16:05:06.891]                   {
[16:05:06.891]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:06.891]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:06.891]                       tmpdir = path, fileext = ".rds")
[16:05:06.891]                     save_rds(obj, file)
[16:05:06.891]                   }
[16:05:06.891]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:06.891]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.891]                   {
[16:05:06.891]                     inherits <- base::inherits
[16:05:06.891]                     invokeRestart <- base::invokeRestart
[16:05:06.891]                     is.null <- base::is.null
[16:05:06.891]                     muffled <- FALSE
[16:05:06.891]                     if (inherits(cond, "message")) {
[16:05:06.891]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:06.891]                       if (muffled) 
[16:05:06.891]                         invokeRestart("muffleMessage")
[16:05:06.891]                     }
[16:05:06.891]                     else if (inherits(cond, "warning")) {
[16:05:06.891]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:06.891]                       if (muffled) 
[16:05:06.891]                         invokeRestart("muffleWarning")
[16:05:06.891]                     }
[16:05:06.891]                     else if (inherits(cond, "condition")) {
[16:05:06.891]                       if (!is.null(pattern)) {
[16:05:06.891]                         computeRestarts <- base::computeRestarts
[16:05:06.891]                         grepl <- base::grepl
[16:05:06.891]                         restarts <- computeRestarts(cond)
[16:05:06.891]                         for (restart in restarts) {
[16:05:06.891]                           name <- restart$name
[16:05:06.891]                           if (is.null(name)) 
[16:05:06.891]                             next
[16:05:06.891]                           if (!grepl(pattern, name)) 
[16:05:06.891]                             next
[16:05:06.891]                           invokeRestart(restart)
[16:05:06.891]                           muffled <- TRUE
[16:05:06.891]                           break
[16:05:06.891]                         }
[16:05:06.891]                       }
[16:05:06.891]                     }
[16:05:06.891]                     invisible(muffled)
[16:05:06.891]                   }
[16:05:06.891]                   muffleCondition(cond)
[16:05:06.891]                 })
[16:05:06.891]             }))
[16:05:06.891]             future::FutureResult(value = ...future.value$value, 
[16:05:06.891]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.891]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.891]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.891]                     ...future.globalenv.names))
[16:05:06.891]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.891]         }, condition = base::local({
[16:05:06.891]             c <- base::c
[16:05:06.891]             inherits <- base::inherits
[16:05:06.891]             invokeRestart <- base::invokeRestart
[16:05:06.891]             length <- base::length
[16:05:06.891]             list <- base::list
[16:05:06.891]             seq.int <- base::seq.int
[16:05:06.891]             signalCondition <- base::signalCondition
[16:05:06.891]             sys.calls <- base::sys.calls
[16:05:06.891]             `[[` <- base::`[[`
[16:05:06.891]             `+` <- base::`+`
[16:05:06.891]             `<<-` <- base::`<<-`
[16:05:06.891]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.891]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.891]                   3L)]
[16:05:06.891]             }
[16:05:06.891]             function(cond) {
[16:05:06.891]                 is_error <- inherits(cond, "error")
[16:05:06.891]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.891]                   NULL)
[16:05:06.891]                 if (is_error) {
[16:05:06.891]                   sessionInformation <- function() {
[16:05:06.891]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.891]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.891]                       search = base::search(), system = base::Sys.info())
[16:05:06.891]                   }
[16:05:06.891]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.891]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.891]                     cond$call), session = sessionInformation(), 
[16:05:06.891]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.891]                   signalCondition(cond)
[16:05:06.891]                 }
[16:05:06.891]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.891]                 "immediateCondition"))) {
[16:05:06.891]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.891]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.891]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.891]                   if (TRUE && !signal) {
[16:05:06.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.891]                     {
[16:05:06.891]                       inherits <- base::inherits
[16:05:06.891]                       invokeRestart <- base::invokeRestart
[16:05:06.891]                       is.null <- base::is.null
[16:05:06.891]                       muffled <- FALSE
[16:05:06.891]                       if (inherits(cond, "message")) {
[16:05:06.891]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.891]                         if (muffled) 
[16:05:06.891]                           invokeRestart("muffleMessage")
[16:05:06.891]                       }
[16:05:06.891]                       else if (inherits(cond, "warning")) {
[16:05:06.891]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.891]                         if (muffled) 
[16:05:06.891]                           invokeRestart("muffleWarning")
[16:05:06.891]                       }
[16:05:06.891]                       else if (inherits(cond, "condition")) {
[16:05:06.891]                         if (!is.null(pattern)) {
[16:05:06.891]                           computeRestarts <- base::computeRestarts
[16:05:06.891]                           grepl <- base::grepl
[16:05:06.891]                           restarts <- computeRestarts(cond)
[16:05:06.891]                           for (restart in restarts) {
[16:05:06.891]                             name <- restart$name
[16:05:06.891]                             if (is.null(name)) 
[16:05:06.891]                               next
[16:05:06.891]                             if (!grepl(pattern, name)) 
[16:05:06.891]                               next
[16:05:06.891]                             invokeRestart(restart)
[16:05:06.891]                             muffled <- TRUE
[16:05:06.891]                             break
[16:05:06.891]                           }
[16:05:06.891]                         }
[16:05:06.891]                       }
[16:05:06.891]                       invisible(muffled)
[16:05:06.891]                     }
[16:05:06.891]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.891]                   }
[16:05:06.891]                 }
[16:05:06.891]                 else {
[16:05:06.891]                   if (TRUE) {
[16:05:06.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.891]                     {
[16:05:06.891]                       inherits <- base::inherits
[16:05:06.891]                       invokeRestart <- base::invokeRestart
[16:05:06.891]                       is.null <- base::is.null
[16:05:06.891]                       muffled <- FALSE
[16:05:06.891]                       if (inherits(cond, "message")) {
[16:05:06.891]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.891]                         if (muffled) 
[16:05:06.891]                           invokeRestart("muffleMessage")
[16:05:06.891]                       }
[16:05:06.891]                       else if (inherits(cond, "warning")) {
[16:05:06.891]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.891]                         if (muffled) 
[16:05:06.891]                           invokeRestart("muffleWarning")
[16:05:06.891]                       }
[16:05:06.891]                       else if (inherits(cond, "condition")) {
[16:05:06.891]                         if (!is.null(pattern)) {
[16:05:06.891]                           computeRestarts <- base::computeRestarts
[16:05:06.891]                           grepl <- base::grepl
[16:05:06.891]                           restarts <- computeRestarts(cond)
[16:05:06.891]                           for (restart in restarts) {
[16:05:06.891]                             name <- restart$name
[16:05:06.891]                             if (is.null(name)) 
[16:05:06.891]                               next
[16:05:06.891]                             if (!grepl(pattern, name)) 
[16:05:06.891]                               next
[16:05:06.891]                             invokeRestart(restart)
[16:05:06.891]                             muffled <- TRUE
[16:05:06.891]                             break
[16:05:06.891]                           }
[16:05:06.891]                         }
[16:05:06.891]                       }
[16:05:06.891]                       invisible(muffled)
[16:05:06.891]                     }
[16:05:06.891]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.891]                   }
[16:05:06.891]                 }
[16:05:06.891]             }
[16:05:06.891]         }))
[16:05:06.891]     }, error = function(ex) {
[16:05:06.891]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.891]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.891]                 ...future.rng), started = ...future.startTime, 
[16:05:06.891]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.891]             version = "1.8"), class = "FutureResult")
[16:05:06.891]     }, finally = {
[16:05:06.891]         if (!identical(...future.workdir, getwd())) 
[16:05:06.891]             setwd(...future.workdir)
[16:05:06.891]         {
[16:05:06.891]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.891]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.891]             }
[16:05:06.891]             base::options(...future.oldOptions)
[16:05:06.891]             if (.Platform$OS.type == "windows") {
[16:05:06.891]                 old_names <- names(...future.oldEnvVars)
[16:05:06.891]                 envs <- base::Sys.getenv()
[16:05:06.891]                 names <- names(envs)
[16:05:06.891]                 common <- intersect(names, old_names)
[16:05:06.891]                 added <- setdiff(names, old_names)
[16:05:06.891]                 removed <- setdiff(old_names, names)
[16:05:06.891]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.891]                   envs[common]]
[16:05:06.891]                 NAMES <- toupper(changed)
[16:05:06.891]                 args <- list()
[16:05:06.891]                 for (kk in seq_along(NAMES)) {
[16:05:06.891]                   name <- changed[[kk]]
[16:05:06.891]                   NAME <- NAMES[[kk]]
[16:05:06.891]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.891]                     next
[16:05:06.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.891]                 }
[16:05:06.891]                 NAMES <- toupper(added)
[16:05:06.891]                 for (kk in seq_along(NAMES)) {
[16:05:06.891]                   name <- added[[kk]]
[16:05:06.891]                   NAME <- NAMES[[kk]]
[16:05:06.891]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.891]                     next
[16:05:06.891]                   args[[name]] <- ""
[16:05:06.891]                 }
[16:05:06.891]                 NAMES <- toupper(removed)
[16:05:06.891]                 for (kk in seq_along(NAMES)) {
[16:05:06.891]                   name <- removed[[kk]]
[16:05:06.891]                   NAME <- NAMES[[kk]]
[16:05:06.891]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.891]                     next
[16:05:06.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.891]                 }
[16:05:06.891]                 if (length(args) > 0) 
[16:05:06.891]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.891]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.891]             }
[16:05:06.891]             else {
[16:05:06.891]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.891]             }
[16:05:06.891]             {
[16:05:06.891]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.891]                   0L) {
[16:05:06.891]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.891]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.891]                   base::options(opts)
[16:05:06.891]                 }
[16:05:06.891]                 {
[16:05:06.891]                   {
[16:05:06.891]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:06.891]                     NULL
[16:05:06.891]                   }
[16:05:06.891]                   options(future.plan = NULL)
[16:05:06.891]                   if (is.na(NA_character_)) 
[16:05:06.891]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.891]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.891]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:06.891]                     envir = parent.frame()) 
[16:05:06.891]                   {
[16:05:06.891]                     default_workers <- missing(workers)
[16:05:06.891]                     if (is.function(workers)) 
[16:05:06.891]                       workers <- workers()
[16:05:06.891]                     workers <- structure(as.integer(workers), 
[16:05:06.891]                       class = class(workers))
[16:05:06.891]                     stop_if_not(is.finite(workers), workers >= 
[16:05:06.891]                       1L)
[16:05:06.891]                     if ((workers == 1L && !inherits(workers, 
[16:05:06.891]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:06.891]                       if (default_workers) 
[16:05:06.891]                         supportsMulticore(warn = TRUE)
[16:05:06.891]                       return(sequential(..., envir = envir))
[16:05:06.891]                     }
[16:05:06.891]                     oopts <- options(mc.cores = workers)
[16:05:06.891]                     on.exit(options(oopts))
[16:05:06.891]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:06.891]                       envir = envir)
[16:05:06.891]                     if (!future$lazy) 
[16:05:06.891]                       future <- run(future)
[16:05:06.891]                     invisible(future)
[16:05:06.891]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.891]                 }
[16:05:06.891]             }
[16:05:06.891]         }
[16:05:06.891]     })
[16:05:06.891]     if (TRUE) {
[16:05:06.891]         base::sink(type = "output", split = FALSE)
[16:05:06.891]         if (TRUE) {
[16:05:06.891]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.891]         }
[16:05:06.891]         else {
[16:05:06.891]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.891]         }
[16:05:06.891]         base::close(...future.stdout)
[16:05:06.891]         ...future.stdout <- NULL
[16:05:06.891]     }
[16:05:06.891]     ...future.result$conditions <- ...future.conditions
[16:05:06.891]     ...future.result$finished <- base::Sys.time()
[16:05:06.891]     ...future.result
[16:05:06.891] }
[16:05:06.893] requestCore(): workers = 2
[16:05:06.896] MulticoreFuture started
[16:05:06.897] - Launch lazy future ... done
[16:05:06.897] plan(): Setting new future strategy stack:
[16:05:06.897] run() for ‘MulticoreFuture’ ... done
[16:05:06.898] List of future strategies:
[16:05:06.898] 1. sequential:
[16:05:06.898]    - args: function (..., envir = parent.frame())
[16:05:06.898]    - tweaked: FALSE
[16:05:06.898]    - call: NULL
[16:05:06.899] plan(): nbrOfWorkers() = 1
[16:05:06.899] result() for MulticoreFuture ...
[16:05:06.901] plan(): Setting new future strategy stack:
[16:05:06.901] List of future strategies:
[16:05:06.901] 1. multicore:
[16:05:06.901]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:06.901]    - tweaked: FALSE
[16:05:06.901]    - call: plan(strategy)
[16:05:06.907] plan(): nbrOfWorkers() = 2
[16:05:06.913] result() for MulticoreFuture ...
[16:05:06.913] result() for MulticoreFuture ... done
[16:05:06.913] result() for MulticoreFuture ... done
[16:05:06.913] result() for MulticoreFuture ...
[16:05:06.913] result() for MulticoreFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.914] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.914] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:06.916] - globals found: [3] ‘{’, ‘<-’, ‘*’
[16:05:06.916] Searching for globals ... DONE
[16:05:06.916] Resolving globals: TRUE
[16:05:06.916] Resolving any globals that are futures ...
[16:05:06.916] - globals: [3] ‘{’, ‘<-’, ‘*’
[16:05:06.917] Resolving any globals that are futures ... DONE
[16:05:06.917] 
[16:05:06.917] 
[16:05:06.917] getGlobalsAndPackages() ... DONE
[16:05:06.918] run() for ‘Future’ ...
[16:05:06.918] - state: ‘created’
[16:05:06.918] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:06.922] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:06.922] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:06.922]   - Field: ‘label’
[16:05:06.922]   - Field: ‘local’
[16:05:06.923]   - Field: ‘owner’
[16:05:06.923]   - Field: ‘envir’
[16:05:06.923]   - Field: ‘workers’
[16:05:06.923]   - Field: ‘packages’
[16:05:06.923]   - Field: ‘gc’
[16:05:06.923]   - Field: ‘job’
[16:05:06.923]   - Field: ‘conditions’
[16:05:06.923]   - Field: ‘expr’
[16:05:06.924]   - Field: ‘uuid’
[16:05:06.924]   - Field: ‘seed’
[16:05:06.924]   - Field: ‘version’
[16:05:06.924]   - Field: ‘result’
[16:05:06.924]   - Field: ‘asynchronous’
[16:05:06.924]   - Field: ‘calls’
[16:05:06.924]   - Field: ‘globals’
[16:05:06.924]   - Field: ‘stdout’
[16:05:06.924]   - Field: ‘earlySignal’
[16:05:06.925]   - Field: ‘lazy’
[16:05:06.925]   - Field: ‘state’
[16:05:06.925] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:06.925] - Launch lazy future ...
[16:05:06.925] Packages needed by the future expression (n = 0): <none>
[16:05:06.925] Packages needed by future strategies (n = 0): <none>
[16:05:06.926] {
[16:05:06.926]     {
[16:05:06.926]         {
[16:05:06.926]             ...future.startTime <- base::Sys.time()
[16:05:06.926]             {
[16:05:06.926]                 {
[16:05:06.926]                   {
[16:05:06.926]                     {
[16:05:06.926]                       base::local({
[16:05:06.926]                         has_future <- base::requireNamespace("future", 
[16:05:06.926]                           quietly = TRUE)
[16:05:06.926]                         if (has_future) {
[16:05:06.926]                           ns <- base::getNamespace("future")
[16:05:06.926]                           version <- ns[[".package"]][["version"]]
[16:05:06.926]                           if (is.null(version)) 
[16:05:06.926]                             version <- utils::packageVersion("future")
[16:05:06.926]                         }
[16:05:06.926]                         else {
[16:05:06.926]                           version <- NULL
[16:05:06.926]                         }
[16:05:06.926]                         if (!has_future || version < "1.8.0") {
[16:05:06.926]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.926]                             "", base::R.version$version.string), 
[16:05:06.926]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:06.926]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.926]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.926]                               "release", "version")], collapse = " "), 
[16:05:06.926]                             hostname = base::Sys.info()[["nodename"]])
[16:05:06.926]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.926]                             info)
[16:05:06.926]                           info <- base::paste(info, collapse = "; ")
[16:05:06.926]                           if (!has_future) {
[16:05:06.926]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.926]                               info)
[16:05:06.926]                           }
[16:05:06.926]                           else {
[16:05:06.926]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.926]                               info, version)
[16:05:06.926]                           }
[16:05:06.926]                           base::stop(msg)
[16:05:06.926]                         }
[16:05:06.926]                       })
[16:05:06.926]                     }
[16:05:06.926]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:06.926]                     base::options(mc.cores = 1L)
[16:05:06.926]                   }
[16:05:06.926]                   options(future.plan = NULL)
[16:05:06.926]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.926]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.926]                 }
[16:05:06.926]                 ...future.workdir <- getwd()
[16:05:06.926]             }
[16:05:06.926]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.926]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.926]         }
[16:05:06.926]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.926]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:06.926]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.926]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.926]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.926]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.926]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.926]             base::names(...future.oldOptions))
[16:05:06.926]     }
[16:05:06.926]     if (FALSE) {
[16:05:06.926]     }
[16:05:06.926]     else {
[16:05:06.926]         if (TRUE) {
[16:05:06.926]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.926]                 open = "w")
[16:05:06.926]         }
[16:05:06.926]         else {
[16:05:06.926]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.926]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.926]         }
[16:05:06.926]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.926]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.926]             base::sink(type = "output", split = FALSE)
[16:05:06.926]             base::close(...future.stdout)
[16:05:06.926]         }, add = TRUE)
[16:05:06.926]     }
[16:05:06.926]     ...future.frame <- base::sys.nframe()
[16:05:06.926]     ...future.conditions <- base::list()
[16:05:06.926]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.926]     if (FALSE) {
[16:05:06.926]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.926]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.926]     }
[16:05:06.926]     ...future.result <- base::tryCatch({
[16:05:06.926]         base::withCallingHandlers({
[16:05:06.926]             ...future.value <- base::withVisible(base::local({
[16:05:06.926]                 withCallingHandlers({
[16:05:06.926]                   {
[16:05:06.926]                     b <- a
[16:05:06.926]                     a <- 2
[16:05:06.926]                     a * b
[16:05:06.926]                   }
[16:05:06.926]                 }, immediateCondition = function(cond) {
[16:05:06.926]                   save_rds <- function (object, pathname, ...) 
[16:05:06.926]                   {
[16:05:06.926]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:06.926]                     if (file_test("-f", pathname_tmp)) {
[16:05:06.926]                       fi_tmp <- file.info(pathname_tmp)
[16:05:06.926]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:06.926]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:06.926]                         fi_tmp[["mtime"]])
[16:05:06.926]                     }
[16:05:06.926]                     tryCatch({
[16:05:06.926]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:06.926]                     }, error = function(ex) {
[16:05:06.926]                       msg <- conditionMessage(ex)
[16:05:06.926]                       fi_tmp <- file.info(pathname_tmp)
[16:05:06.926]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:06.926]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:06.926]                         fi_tmp[["mtime"]], msg)
[16:05:06.926]                       ex$message <- msg
[16:05:06.926]                       stop(ex)
[16:05:06.926]                     })
[16:05:06.926]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:06.926]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:06.926]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:06.926]                       fi_tmp <- file.info(pathname_tmp)
[16:05:06.926]                       fi <- file.info(pathname)
[16:05:06.926]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:06.926]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:06.926]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:06.926]                         fi[["size"]], fi[["mtime"]])
[16:05:06.926]                       stop(msg)
[16:05:06.926]                     }
[16:05:06.926]                     invisible(pathname)
[16:05:06.926]                   }
[16:05:06.926]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:06.926]                     rootPath = tempdir()) 
[16:05:06.926]                   {
[16:05:06.926]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:06.926]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:06.926]                       tmpdir = path, fileext = ".rds")
[16:05:06.926]                     save_rds(obj, file)
[16:05:06.926]                   }
[16:05:06.926]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:06.926]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.926]                   {
[16:05:06.926]                     inherits <- base::inherits
[16:05:06.926]                     invokeRestart <- base::invokeRestart
[16:05:06.926]                     is.null <- base::is.null
[16:05:06.926]                     muffled <- FALSE
[16:05:06.926]                     if (inherits(cond, "message")) {
[16:05:06.926]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:06.926]                       if (muffled) 
[16:05:06.926]                         invokeRestart("muffleMessage")
[16:05:06.926]                     }
[16:05:06.926]                     else if (inherits(cond, "warning")) {
[16:05:06.926]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:06.926]                       if (muffled) 
[16:05:06.926]                         invokeRestart("muffleWarning")
[16:05:06.926]                     }
[16:05:06.926]                     else if (inherits(cond, "condition")) {
[16:05:06.926]                       if (!is.null(pattern)) {
[16:05:06.926]                         computeRestarts <- base::computeRestarts
[16:05:06.926]                         grepl <- base::grepl
[16:05:06.926]                         restarts <- computeRestarts(cond)
[16:05:06.926]                         for (restart in restarts) {
[16:05:06.926]                           name <- restart$name
[16:05:06.926]                           if (is.null(name)) 
[16:05:06.926]                             next
[16:05:06.926]                           if (!grepl(pattern, name)) 
[16:05:06.926]                             next
[16:05:06.926]                           invokeRestart(restart)
[16:05:06.926]                           muffled <- TRUE
[16:05:06.926]                           break
[16:05:06.926]                         }
[16:05:06.926]                       }
[16:05:06.926]                     }
[16:05:06.926]                     invisible(muffled)
[16:05:06.926]                   }
[16:05:06.926]                   muffleCondition(cond)
[16:05:06.926]                 })
[16:05:06.926]             }))
[16:05:06.926]             future::FutureResult(value = ...future.value$value, 
[16:05:06.926]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.926]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.926]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.926]                     ...future.globalenv.names))
[16:05:06.926]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.926]         }, condition = base::local({
[16:05:06.926]             c <- base::c
[16:05:06.926]             inherits <- base::inherits
[16:05:06.926]             invokeRestart <- base::invokeRestart
[16:05:06.926]             length <- base::length
[16:05:06.926]             list <- base::list
[16:05:06.926]             seq.int <- base::seq.int
[16:05:06.926]             signalCondition <- base::signalCondition
[16:05:06.926]             sys.calls <- base::sys.calls
[16:05:06.926]             `[[` <- base::`[[`
[16:05:06.926]             `+` <- base::`+`
[16:05:06.926]             `<<-` <- base::`<<-`
[16:05:06.926]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.926]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.926]                   3L)]
[16:05:06.926]             }
[16:05:06.926]             function(cond) {
[16:05:06.926]                 is_error <- inherits(cond, "error")
[16:05:06.926]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.926]                   NULL)
[16:05:06.926]                 if (is_error) {
[16:05:06.926]                   sessionInformation <- function() {
[16:05:06.926]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.926]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.926]                       search = base::search(), system = base::Sys.info())
[16:05:06.926]                   }
[16:05:06.926]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.926]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.926]                     cond$call), session = sessionInformation(), 
[16:05:06.926]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.926]                   signalCondition(cond)
[16:05:06.926]                 }
[16:05:06.926]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.926]                 "immediateCondition"))) {
[16:05:06.926]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.926]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.926]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.926]                   if (TRUE && !signal) {
[16:05:06.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.926]                     {
[16:05:06.926]                       inherits <- base::inherits
[16:05:06.926]                       invokeRestart <- base::invokeRestart
[16:05:06.926]                       is.null <- base::is.null
[16:05:06.926]                       muffled <- FALSE
[16:05:06.926]                       if (inherits(cond, "message")) {
[16:05:06.926]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.926]                         if (muffled) 
[16:05:06.926]                           invokeRestart("muffleMessage")
[16:05:06.926]                       }
[16:05:06.926]                       else if (inherits(cond, "warning")) {
[16:05:06.926]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.926]                         if (muffled) 
[16:05:06.926]                           invokeRestart("muffleWarning")
[16:05:06.926]                       }
[16:05:06.926]                       else if (inherits(cond, "condition")) {
[16:05:06.926]                         if (!is.null(pattern)) {
[16:05:06.926]                           computeRestarts <- base::computeRestarts
[16:05:06.926]                           grepl <- base::grepl
[16:05:06.926]                           restarts <- computeRestarts(cond)
[16:05:06.926]                           for (restart in restarts) {
[16:05:06.926]                             name <- restart$name
[16:05:06.926]                             if (is.null(name)) 
[16:05:06.926]                               next
[16:05:06.926]                             if (!grepl(pattern, name)) 
[16:05:06.926]                               next
[16:05:06.926]                             invokeRestart(restart)
[16:05:06.926]                             muffled <- TRUE
[16:05:06.926]                             break
[16:05:06.926]                           }
[16:05:06.926]                         }
[16:05:06.926]                       }
[16:05:06.926]                       invisible(muffled)
[16:05:06.926]                     }
[16:05:06.926]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.926]                   }
[16:05:06.926]                 }
[16:05:06.926]                 else {
[16:05:06.926]                   if (TRUE) {
[16:05:06.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.926]                     {
[16:05:06.926]                       inherits <- base::inherits
[16:05:06.926]                       invokeRestart <- base::invokeRestart
[16:05:06.926]                       is.null <- base::is.null
[16:05:06.926]                       muffled <- FALSE
[16:05:06.926]                       if (inherits(cond, "message")) {
[16:05:06.926]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.926]                         if (muffled) 
[16:05:06.926]                           invokeRestart("muffleMessage")
[16:05:06.926]                       }
[16:05:06.926]                       else if (inherits(cond, "warning")) {
[16:05:06.926]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.926]                         if (muffled) 
[16:05:06.926]                           invokeRestart("muffleWarning")
[16:05:06.926]                       }
[16:05:06.926]                       else if (inherits(cond, "condition")) {
[16:05:06.926]                         if (!is.null(pattern)) {
[16:05:06.926]                           computeRestarts <- base::computeRestarts
[16:05:06.926]                           grepl <- base::grepl
[16:05:06.926]                           restarts <- computeRestarts(cond)
[16:05:06.926]                           for (restart in restarts) {
[16:05:06.926]                             name <- restart$name
[16:05:06.926]                             if (is.null(name)) 
[16:05:06.926]                               next
[16:05:06.926]                             if (!grepl(pattern, name)) 
[16:05:06.926]                               next
[16:05:06.926]                             invokeRestart(restart)
[16:05:06.926]                             muffled <- TRUE
[16:05:06.926]                             break
[16:05:06.926]                           }
[16:05:06.926]                         }
[16:05:06.926]                       }
[16:05:06.926]                       invisible(muffled)
[16:05:06.926]                     }
[16:05:06.926]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.926]                   }
[16:05:06.926]                 }
[16:05:06.926]             }
[16:05:06.926]         }))
[16:05:06.926]     }, error = function(ex) {
[16:05:06.926]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.926]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.926]                 ...future.rng), started = ...future.startTime, 
[16:05:06.926]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.926]             version = "1.8"), class = "FutureResult")
[16:05:06.926]     }, finally = {
[16:05:06.926]         if (!identical(...future.workdir, getwd())) 
[16:05:06.926]             setwd(...future.workdir)
[16:05:06.926]         {
[16:05:06.926]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.926]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.926]             }
[16:05:06.926]             base::options(...future.oldOptions)
[16:05:06.926]             if (.Platform$OS.type == "windows") {
[16:05:06.926]                 old_names <- names(...future.oldEnvVars)
[16:05:06.926]                 envs <- base::Sys.getenv()
[16:05:06.926]                 names <- names(envs)
[16:05:06.926]                 common <- intersect(names, old_names)
[16:05:06.926]                 added <- setdiff(names, old_names)
[16:05:06.926]                 removed <- setdiff(old_names, names)
[16:05:06.926]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.926]                   envs[common]]
[16:05:06.926]                 NAMES <- toupper(changed)
[16:05:06.926]                 args <- list()
[16:05:06.926]                 for (kk in seq_along(NAMES)) {
[16:05:06.926]                   name <- changed[[kk]]
[16:05:06.926]                   NAME <- NAMES[[kk]]
[16:05:06.926]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.926]                     next
[16:05:06.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.926]                 }
[16:05:06.926]                 NAMES <- toupper(added)
[16:05:06.926]                 for (kk in seq_along(NAMES)) {
[16:05:06.926]                   name <- added[[kk]]
[16:05:06.926]                   NAME <- NAMES[[kk]]
[16:05:06.926]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.926]                     next
[16:05:06.926]                   args[[name]] <- ""
[16:05:06.926]                 }
[16:05:06.926]                 NAMES <- toupper(removed)
[16:05:06.926]                 for (kk in seq_along(NAMES)) {
[16:05:06.926]                   name <- removed[[kk]]
[16:05:06.926]                   NAME <- NAMES[[kk]]
[16:05:06.926]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.926]                     next
[16:05:06.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.926]                 }
[16:05:06.926]                 if (length(args) > 0) 
[16:05:06.926]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.926]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.926]             }
[16:05:06.926]             else {
[16:05:06.926]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.926]             }
[16:05:06.926]             {
[16:05:06.926]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.926]                   0L) {
[16:05:06.926]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.926]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.926]                   base::options(opts)
[16:05:06.926]                 }
[16:05:06.926]                 {
[16:05:06.926]                   {
[16:05:06.926]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:06.926]                     NULL
[16:05:06.926]                   }
[16:05:06.926]                   options(future.plan = NULL)
[16:05:06.926]                   if (is.na(NA_character_)) 
[16:05:06.926]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.926]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.926]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:06.926]                     envir = parent.frame()) 
[16:05:06.926]                   {
[16:05:06.926]                     default_workers <- missing(workers)
[16:05:06.926]                     if (is.function(workers)) 
[16:05:06.926]                       workers <- workers()
[16:05:06.926]                     workers <- structure(as.integer(workers), 
[16:05:06.926]                       class = class(workers))
[16:05:06.926]                     stop_if_not(is.finite(workers), workers >= 
[16:05:06.926]                       1L)
[16:05:06.926]                     if ((workers == 1L && !inherits(workers, 
[16:05:06.926]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:06.926]                       if (default_workers) 
[16:05:06.926]                         supportsMulticore(warn = TRUE)
[16:05:06.926]                       return(sequential(..., envir = envir))
[16:05:06.926]                     }
[16:05:06.926]                     oopts <- options(mc.cores = workers)
[16:05:06.926]                     on.exit(options(oopts))
[16:05:06.926]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:06.926]                       envir = envir)
[16:05:06.926]                     if (!future$lazy) 
[16:05:06.926]                       future <- run(future)
[16:05:06.926]                     invisible(future)
[16:05:06.926]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.926]                 }
[16:05:06.926]             }
[16:05:06.926]         }
[16:05:06.926]     })
[16:05:06.926]     if (TRUE) {
[16:05:06.926]         base::sink(type = "output", split = FALSE)
[16:05:06.926]         if (TRUE) {
[16:05:06.926]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.926]         }
[16:05:06.926]         else {
[16:05:06.926]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.926]         }
[16:05:06.926]         base::close(...future.stdout)
[16:05:06.926]         ...future.stdout <- NULL
[16:05:06.926]     }
[16:05:06.926]     ...future.result$conditions <- ...future.conditions
[16:05:06.926]     ...future.result$finished <- base::Sys.time()
[16:05:06.926]     ...future.result
[16:05:06.926] }
[16:05:06.929] requestCore(): workers = 2
[16:05:06.931] MulticoreFuture started
[16:05:06.931] - Launch lazy future ... done
[16:05:06.932] run() for ‘MulticoreFuture’ ... done
[16:05:06.932] result() for MulticoreFuture ...
[16:05:06.932] plan(): Setting new future strategy stack:
[16:05:06.932] List of future strategies:
[16:05:06.932] 1. sequential:
[16:05:06.932]    - args: function (..., envir = parent.frame())
[16:05:06.932]    - tweaked: FALSE
[16:05:06.932]    - call: NULL
[16:05:06.933] plan(): nbrOfWorkers() = 1
[16:05:06.935] plan(): Setting new future strategy stack:
[16:05:06.936] List of future strategies:
[16:05:06.936] 1. multicore:
[16:05:06.936]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:06.936]    - tweaked: FALSE
[16:05:06.936]    - call: plan(strategy)
[16:05:06.941] plan(): nbrOfWorkers() = 2
[16:05:06.947] result() for MulticoreFuture ...
[16:05:06.947] result() for MulticoreFuture ... done
[16:05:06.948] signalConditions() ...
[16:05:06.948]  - include = ‘immediateCondition’
[16:05:06.948]  - exclude = 
[16:05:06.948]  - resignal = FALSE
[16:05:06.948]  - Number of conditions: 1
[16:05:06.948] signalConditions() ... done
[16:05:06.949] result() for MulticoreFuture ... done
[16:05:06.949] result() for MulticoreFuture ...
[16:05:06.949] result() for MulticoreFuture ... done
[16:05:06.949] signalConditions() ...
[16:05:06.949]  - include = ‘immediateCondition’
[16:05:06.949]  - exclude = 
[16:05:06.950]  - resignal = FALSE
[16:05:06.950]  - Number of conditions: 1
[16:05:06.950] signalConditions() ... done
[16:05:06.950] Future state: ‘finished’
[16:05:06.950] result() for MulticoreFuture ...
[16:05:06.950] result() for MulticoreFuture ... done
[16:05:06.950] signalConditions() ...
[16:05:06.951]  - include = ‘condition’
[16:05:06.951]  - exclude = ‘immediateCondition’
[16:05:06.951]  - resignal = TRUE
[16:05:06.951]  - Number of conditions: 1
[16:05:06.951]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:05:06.951] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 39
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "11666ca4073c" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:05:06"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:06.984] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:06.984] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:06.986] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:06.986] Searching for globals ... DONE
[16:05:06.986] Resolving globals: TRUE
[16:05:06.986] Resolving any globals that are futures ...
[16:05:06.986] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:06.987] Resolving any globals that are futures ... DONE
[16:05:06.987] Resolving futures part of globals (recursively) ...
[16:05:06.987] resolve() on list ...
[16:05:06.987]  recursive: 99
[16:05:06.987]  length: 1
[16:05:06.988]  elements: ‘ii’
[16:05:06.988]  length: 0 (resolved future 1)
[16:05:06.988] resolve() on list ... DONE
[16:05:06.988] - globals: [1] ‘ii’
[16:05:06.988] Resolving futures part of globals (recursively) ... DONE
[16:05:06.988] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:06.989] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:06.989] - globals: [1] ‘ii’
[16:05:06.989] 
[16:05:06.989] getGlobalsAndPackages() ... DONE
[16:05:06.989] run() for ‘Future’ ...
[16:05:06.989] - state: ‘created’
[16:05:06.990] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:06.994] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:06.994] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:06.994]   - Field: ‘label’
[16:05:06.994]   - Field: ‘local’
[16:05:06.994]   - Field: ‘owner’
[16:05:06.994]   - Field: ‘envir’
[16:05:06.994]   - Field: ‘workers’
[16:05:06.994]   - Field: ‘packages’
[16:05:06.994]   - Field: ‘gc’
[16:05:06.995]   - Field: ‘job’
[16:05:06.995]   - Field: ‘conditions’
[16:05:06.995]   - Field: ‘expr’
[16:05:06.995]   - Field: ‘uuid’
[16:05:06.995]   - Field: ‘seed’
[16:05:06.995]   - Field: ‘version’
[16:05:06.995]   - Field: ‘result’
[16:05:06.995]   - Field: ‘asynchronous’
[16:05:06.995]   - Field: ‘calls’
[16:05:06.995]   - Field: ‘globals’
[16:05:06.996]   - Field: ‘stdout’
[16:05:06.996]   - Field: ‘earlySignal’
[16:05:06.996]   - Field: ‘lazy’
[16:05:06.996]   - Field: ‘state’
[16:05:06.996] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:06.996] - Launch lazy future ...
[16:05:06.996] Packages needed by the future expression (n = 0): <none>
[16:05:06.996] Packages needed by future strategies (n = 0): <none>
[16:05:06.997] {
[16:05:06.997]     {
[16:05:06.997]         {
[16:05:06.997]             ...future.startTime <- base::Sys.time()
[16:05:06.997]             {
[16:05:06.997]                 {
[16:05:06.997]                   {
[16:05:06.997]                     {
[16:05:06.997]                       base::local({
[16:05:06.997]                         has_future <- base::requireNamespace("future", 
[16:05:06.997]                           quietly = TRUE)
[16:05:06.997]                         if (has_future) {
[16:05:06.997]                           ns <- base::getNamespace("future")
[16:05:06.997]                           version <- ns[[".package"]][["version"]]
[16:05:06.997]                           if (is.null(version)) 
[16:05:06.997]                             version <- utils::packageVersion("future")
[16:05:06.997]                         }
[16:05:06.997]                         else {
[16:05:06.997]                           version <- NULL
[16:05:06.997]                         }
[16:05:06.997]                         if (!has_future || version < "1.8.0") {
[16:05:06.997]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:06.997]                             "", base::R.version$version.string), 
[16:05:06.997]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:06.997]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:06.997]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:06.997]                               "release", "version")], collapse = " "), 
[16:05:06.997]                             hostname = base::Sys.info()[["nodename"]])
[16:05:06.997]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:06.997]                             info)
[16:05:06.997]                           info <- base::paste(info, collapse = "; ")
[16:05:06.997]                           if (!has_future) {
[16:05:06.997]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:06.997]                               info)
[16:05:06.997]                           }
[16:05:06.997]                           else {
[16:05:06.997]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:06.997]                               info, version)
[16:05:06.997]                           }
[16:05:06.997]                           base::stop(msg)
[16:05:06.997]                         }
[16:05:06.997]                       })
[16:05:06.997]                     }
[16:05:06.997]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:06.997]                     base::options(mc.cores = 1L)
[16:05:06.997]                   }
[16:05:06.997]                   options(future.plan = NULL)
[16:05:06.997]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.997]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:06.997]                 }
[16:05:06.997]                 ...future.workdir <- getwd()
[16:05:06.997]             }
[16:05:06.997]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:06.997]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:06.997]         }
[16:05:06.997]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:06.997]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:06.997]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:06.997]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:06.997]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:06.997]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:06.997]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:06.997]             base::names(...future.oldOptions))
[16:05:06.997]     }
[16:05:06.997]     if (FALSE) {
[16:05:06.997]     }
[16:05:06.997]     else {
[16:05:06.997]         if (TRUE) {
[16:05:06.997]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:06.997]                 open = "w")
[16:05:06.997]         }
[16:05:06.997]         else {
[16:05:06.997]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:06.997]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:06.997]         }
[16:05:06.997]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:06.997]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:06.997]             base::sink(type = "output", split = FALSE)
[16:05:06.997]             base::close(...future.stdout)
[16:05:06.997]         }, add = TRUE)
[16:05:06.997]     }
[16:05:06.997]     ...future.frame <- base::sys.nframe()
[16:05:06.997]     ...future.conditions <- base::list()
[16:05:06.997]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:06.997]     if (FALSE) {
[16:05:06.997]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:06.997]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:06.997]     }
[16:05:06.997]     ...future.result <- base::tryCatch({
[16:05:06.997]         base::withCallingHandlers({
[16:05:06.997]             ...future.value <- base::withVisible(base::local({
[16:05:06.997]                 withCallingHandlers({
[16:05:06.997]                   {
[16:05:06.997]                     b <- a * ii
[16:05:06.997]                     a <- 0
[16:05:06.997]                     b
[16:05:06.997]                   }
[16:05:06.997]                 }, immediateCondition = function(cond) {
[16:05:06.997]                   save_rds <- function (object, pathname, ...) 
[16:05:06.997]                   {
[16:05:06.997]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:06.997]                     if (file_test("-f", pathname_tmp)) {
[16:05:06.997]                       fi_tmp <- file.info(pathname_tmp)
[16:05:06.997]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:06.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:06.997]                         fi_tmp[["mtime"]])
[16:05:06.997]                     }
[16:05:06.997]                     tryCatch({
[16:05:06.997]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:06.997]                     }, error = function(ex) {
[16:05:06.997]                       msg <- conditionMessage(ex)
[16:05:06.997]                       fi_tmp <- file.info(pathname_tmp)
[16:05:06.997]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:06.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:06.997]                         fi_tmp[["mtime"]], msg)
[16:05:06.997]                       ex$message <- msg
[16:05:06.997]                       stop(ex)
[16:05:06.997]                     })
[16:05:06.997]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:06.997]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:06.997]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:06.997]                       fi_tmp <- file.info(pathname_tmp)
[16:05:06.997]                       fi <- file.info(pathname)
[16:05:06.997]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:06.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:06.997]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:06.997]                         fi[["size"]], fi[["mtime"]])
[16:05:06.997]                       stop(msg)
[16:05:06.997]                     }
[16:05:06.997]                     invisible(pathname)
[16:05:06.997]                   }
[16:05:06.997]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:06.997]                     rootPath = tempdir()) 
[16:05:06.997]                   {
[16:05:06.997]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:06.997]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:06.997]                       tmpdir = path, fileext = ".rds")
[16:05:06.997]                     save_rds(obj, file)
[16:05:06.997]                   }
[16:05:06.997]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:06.997]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.997]                   {
[16:05:06.997]                     inherits <- base::inherits
[16:05:06.997]                     invokeRestart <- base::invokeRestart
[16:05:06.997]                     is.null <- base::is.null
[16:05:06.997]                     muffled <- FALSE
[16:05:06.997]                     if (inherits(cond, "message")) {
[16:05:06.997]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:06.997]                       if (muffled) 
[16:05:06.997]                         invokeRestart("muffleMessage")
[16:05:06.997]                     }
[16:05:06.997]                     else if (inherits(cond, "warning")) {
[16:05:06.997]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:06.997]                       if (muffled) 
[16:05:06.997]                         invokeRestart("muffleWarning")
[16:05:06.997]                     }
[16:05:06.997]                     else if (inherits(cond, "condition")) {
[16:05:06.997]                       if (!is.null(pattern)) {
[16:05:06.997]                         computeRestarts <- base::computeRestarts
[16:05:06.997]                         grepl <- base::grepl
[16:05:06.997]                         restarts <- computeRestarts(cond)
[16:05:06.997]                         for (restart in restarts) {
[16:05:06.997]                           name <- restart$name
[16:05:06.997]                           if (is.null(name)) 
[16:05:06.997]                             next
[16:05:06.997]                           if (!grepl(pattern, name)) 
[16:05:06.997]                             next
[16:05:06.997]                           invokeRestart(restart)
[16:05:06.997]                           muffled <- TRUE
[16:05:06.997]                           break
[16:05:06.997]                         }
[16:05:06.997]                       }
[16:05:06.997]                     }
[16:05:06.997]                     invisible(muffled)
[16:05:06.997]                   }
[16:05:06.997]                   muffleCondition(cond)
[16:05:06.997]                 })
[16:05:06.997]             }))
[16:05:06.997]             future::FutureResult(value = ...future.value$value, 
[16:05:06.997]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.997]                   ...future.rng), globalenv = if (FALSE) 
[16:05:06.997]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:06.997]                     ...future.globalenv.names))
[16:05:06.997]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:06.997]         }, condition = base::local({
[16:05:06.997]             c <- base::c
[16:05:06.997]             inherits <- base::inherits
[16:05:06.997]             invokeRestart <- base::invokeRestart
[16:05:06.997]             length <- base::length
[16:05:06.997]             list <- base::list
[16:05:06.997]             seq.int <- base::seq.int
[16:05:06.997]             signalCondition <- base::signalCondition
[16:05:06.997]             sys.calls <- base::sys.calls
[16:05:06.997]             `[[` <- base::`[[`
[16:05:06.997]             `+` <- base::`+`
[16:05:06.997]             `<<-` <- base::`<<-`
[16:05:06.997]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:06.997]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:06.997]                   3L)]
[16:05:06.997]             }
[16:05:06.997]             function(cond) {
[16:05:06.997]                 is_error <- inherits(cond, "error")
[16:05:06.997]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:06.997]                   NULL)
[16:05:06.997]                 if (is_error) {
[16:05:06.997]                   sessionInformation <- function() {
[16:05:06.997]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:06.997]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:06.997]                       search = base::search(), system = base::Sys.info())
[16:05:06.997]                   }
[16:05:06.997]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.997]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:06.997]                     cond$call), session = sessionInformation(), 
[16:05:06.997]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:06.997]                   signalCondition(cond)
[16:05:06.997]                 }
[16:05:06.997]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:06.997]                 "immediateCondition"))) {
[16:05:06.997]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:06.997]                   ...future.conditions[[length(...future.conditions) + 
[16:05:06.997]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:06.997]                   if (TRUE && !signal) {
[16:05:06.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.997]                     {
[16:05:06.997]                       inherits <- base::inherits
[16:05:06.997]                       invokeRestart <- base::invokeRestart
[16:05:06.997]                       is.null <- base::is.null
[16:05:06.997]                       muffled <- FALSE
[16:05:06.997]                       if (inherits(cond, "message")) {
[16:05:06.997]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.997]                         if (muffled) 
[16:05:06.997]                           invokeRestart("muffleMessage")
[16:05:06.997]                       }
[16:05:06.997]                       else if (inherits(cond, "warning")) {
[16:05:06.997]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.997]                         if (muffled) 
[16:05:06.997]                           invokeRestart("muffleWarning")
[16:05:06.997]                       }
[16:05:06.997]                       else if (inherits(cond, "condition")) {
[16:05:06.997]                         if (!is.null(pattern)) {
[16:05:06.997]                           computeRestarts <- base::computeRestarts
[16:05:06.997]                           grepl <- base::grepl
[16:05:06.997]                           restarts <- computeRestarts(cond)
[16:05:06.997]                           for (restart in restarts) {
[16:05:06.997]                             name <- restart$name
[16:05:06.997]                             if (is.null(name)) 
[16:05:06.997]                               next
[16:05:06.997]                             if (!grepl(pattern, name)) 
[16:05:06.997]                               next
[16:05:06.997]                             invokeRestart(restart)
[16:05:06.997]                             muffled <- TRUE
[16:05:06.997]                             break
[16:05:06.997]                           }
[16:05:06.997]                         }
[16:05:06.997]                       }
[16:05:06.997]                       invisible(muffled)
[16:05:06.997]                     }
[16:05:06.997]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.997]                   }
[16:05:06.997]                 }
[16:05:06.997]                 else {
[16:05:06.997]                   if (TRUE) {
[16:05:06.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:06.997]                     {
[16:05:06.997]                       inherits <- base::inherits
[16:05:06.997]                       invokeRestart <- base::invokeRestart
[16:05:06.997]                       is.null <- base::is.null
[16:05:06.997]                       muffled <- FALSE
[16:05:06.997]                       if (inherits(cond, "message")) {
[16:05:06.997]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:06.997]                         if (muffled) 
[16:05:06.997]                           invokeRestart("muffleMessage")
[16:05:06.997]                       }
[16:05:06.997]                       else if (inherits(cond, "warning")) {
[16:05:06.997]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:06.997]                         if (muffled) 
[16:05:06.997]                           invokeRestart("muffleWarning")
[16:05:06.997]                       }
[16:05:06.997]                       else if (inherits(cond, "condition")) {
[16:05:06.997]                         if (!is.null(pattern)) {
[16:05:06.997]                           computeRestarts <- base::computeRestarts
[16:05:06.997]                           grepl <- base::grepl
[16:05:06.997]                           restarts <- computeRestarts(cond)
[16:05:06.997]                           for (restart in restarts) {
[16:05:06.997]                             name <- restart$name
[16:05:06.997]                             if (is.null(name)) 
[16:05:06.997]                               next
[16:05:06.997]                             if (!grepl(pattern, name)) 
[16:05:06.997]                               next
[16:05:06.997]                             invokeRestart(restart)
[16:05:06.997]                             muffled <- TRUE
[16:05:06.997]                             break
[16:05:06.997]                           }
[16:05:06.997]                         }
[16:05:06.997]                       }
[16:05:06.997]                       invisible(muffled)
[16:05:06.997]                     }
[16:05:06.997]                     muffleCondition(cond, pattern = "^muffle")
[16:05:06.997]                   }
[16:05:06.997]                 }
[16:05:06.997]             }
[16:05:06.997]         }))
[16:05:06.997]     }, error = function(ex) {
[16:05:06.997]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:06.997]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:06.997]                 ...future.rng), started = ...future.startTime, 
[16:05:06.997]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:06.997]             version = "1.8"), class = "FutureResult")
[16:05:06.997]     }, finally = {
[16:05:06.997]         if (!identical(...future.workdir, getwd())) 
[16:05:06.997]             setwd(...future.workdir)
[16:05:06.997]         {
[16:05:06.997]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:06.997]                 ...future.oldOptions$nwarnings <- NULL
[16:05:06.997]             }
[16:05:06.997]             base::options(...future.oldOptions)
[16:05:06.997]             if (.Platform$OS.type == "windows") {
[16:05:06.997]                 old_names <- names(...future.oldEnvVars)
[16:05:06.997]                 envs <- base::Sys.getenv()
[16:05:06.997]                 names <- names(envs)
[16:05:06.997]                 common <- intersect(names, old_names)
[16:05:06.997]                 added <- setdiff(names, old_names)
[16:05:06.997]                 removed <- setdiff(old_names, names)
[16:05:06.997]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:06.997]                   envs[common]]
[16:05:06.997]                 NAMES <- toupper(changed)
[16:05:06.997]                 args <- list()
[16:05:06.997]                 for (kk in seq_along(NAMES)) {
[16:05:06.997]                   name <- changed[[kk]]
[16:05:06.997]                   NAME <- NAMES[[kk]]
[16:05:06.997]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.997]                     next
[16:05:06.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.997]                 }
[16:05:06.997]                 NAMES <- toupper(added)
[16:05:06.997]                 for (kk in seq_along(NAMES)) {
[16:05:06.997]                   name <- added[[kk]]
[16:05:06.997]                   NAME <- NAMES[[kk]]
[16:05:06.997]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.997]                     next
[16:05:06.997]                   args[[name]] <- ""
[16:05:06.997]                 }
[16:05:06.997]                 NAMES <- toupper(removed)
[16:05:06.997]                 for (kk in seq_along(NAMES)) {
[16:05:06.997]                   name <- removed[[kk]]
[16:05:06.997]                   NAME <- NAMES[[kk]]
[16:05:06.997]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:06.997]                     next
[16:05:06.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:06.997]                 }
[16:05:06.997]                 if (length(args) > 0) 
[16:05:06.997]                   base::do.call(base::Sys.setenv, args = args)
[16:05:06.997]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:06.997]             }
[16:05:06.997]             else {
[16:05:06.997]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:06.997]             }
[16:05:06.997]             {
[16:05:06.997]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:06.997]                   0L) {
[16:05:06.997]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:06.997]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:06.997]                   base::options(opts)
[16:05:06.997]                 }
[16:05:06.997]                 {
[16:05:06.997]                   {
[16:05:06.997]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:06.997]                     NULL
[16:05:06.997]                   }
[16:05:06.997]                   options(future.plan = NULL)
[16:05:06.997]                   if (is.na(NA_character_)) 
[16:05:06.997]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:06.997]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:06.997]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:06.997]                     envir = parent.frame()) 
[16:05:06.997]                   {
[16:05:06.997]                     default_workers <- missing(workers)
[16:05:06.997]                     if (is.function(workers)) 
[16:05:06.997]                       workers <- workers()
[16:05:06.997]                     workers <- structure(as.integer(workers), 
[16:05:06.997]                       class = class(workers))
[16:05:06.997]                     stop_if_not(is.finite(workers), workers >= 
[16:05:06.997]                       1L)
[16:05:06.997]                     if ((workers == 1L && !inherits(workers, 
[16:05:06.997]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:06.997]                       if (default_workers) 
[16:05:06.997]                         supportsMulticore(warn = TRUE)
[16:05:06.997]                       return(sequential(..., envir = envir))
[16:05:06.997]                     }
[16:05:06.997]                     oopts <- options(mc.cores = workers)
[16:05:06.997]                     on.exit(options(oopts))
[16:05:06.997]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:06.997]                       envir = envir)
[16:05:06.997]                     if (!future$lazy) 
[16:05:06.997]                       future <- run(future)
[16:05:06.997]                     invisible(future)
[16:05:06.997]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:06.997]                 }
[16:05:06.997]             }
[16:05:06.997]         }
[16:05:06.997]     })
[16:05:06.997]     if (TRUE) {
[16:05:06.997]         base::sink(type = "output", split = FALSE)
[16:05:06.997]         if (TRUE) {
[16:05:06.997]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:06.997]         }
[16:05:06.997]         else {
[16:05:06.997]             ...future.result["stdout"] <- base::list(NULL)
[16:05:06.997]         }
[16:05:06.997]         base::close(...future.stdout)
[16:05:06.997]         ...future.stdout <- NULL
[16:05:06.997]     }
[16:05:06.997]     ...future.result$conditions <- ...future.conditions
[16:05:06.997]     ...future.result$finished <- base::Sys.time()
[16:05:06.997]     ...future.result
[16:05:06.997] }
[16:05:06.999] assign_globals() ...
[16:05:06.999] List of 1
[16:05:06.999]  $ ii: int 1
[16:05:06.999]  - attr(*, "where")=List of 1
[16:05:06.999]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:06.999]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:06.999]  - attr(*, "resolved")= logi TRUE
[16:05:06.999]  - attr(*, "total_size")= num 56
[16:05:06.999]  - attr(*, "already-done")= logi TRUE
[16:05:07.002] - copied ‘ii’ to environment
[16:05:07.002] assign_globals() ... done
[16:05:07.002] requestCore(): workers = 2
[16:05:07.004] MulticoreFuture started
[16:05:07.005] - Launch lazy future ... done
[16:05:07.005] run() for ‘MulticoreFuture’ ... done
[16:05:07.006] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.006] List of future strategies:
[16:05:07.006] 1. sequential:
[16:05:07.006]    - args: function (..., envir = parent.frame())
[16:05:07.006]    - tweaked: FALSE
[16:05:07.006]    - call: NULL
[16:05:07.006] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.007] plan(): nbrOfWorkers() = 1
[16:05:07.007] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:07.009] plan(): Setting new future strategy stack:
[16:05:07.009] List of future strategies:
[16:05:07.009] 1. multicore:
[16:05:07.009]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.009]    - tweaked: FALSE
[16:05:07.009]    - call: plan(strategy)
[16:05:07.010] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:07.010] Searching for globals ... DONE
[16:05:07.010] Resolving globals: TRUE
[16:05:07.010] Resolving any globals that are futures ...
[16:05:07.010] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:07.010] Resolving any globals that are futures ... DONE
[16:05:07.011] Resolving futures part of globals (recursively) ...
[16:05:07.012] resolve() on list ...
[16:05:07.012]  recursive: 99
[16:05:07.012]  length: 1
[16:05:07.012]  elements: ‘ii’
[16:05:07.012]  length: 0 (resolved future 1)
[16:05:07.013] resolve() on list ... DONE
[16:05:07.013] - globals: [1] ‘ii’
[16:05:07.013] Resolving futures part of globals (recursively) ... DONE
[16:05:07.013] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:07.014] plan(): nbrOfWorkers() = 2
[16:05:07.014] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:07.014] - globals: [1] ‘ii’
[16:05:07.014] 
[16:05:07.014] getGlobalsAndPackages() ... DONE
[16:05:07.015] run() for ‘Future’ ...
[16:05:07.015] - state: ‘created’
[16:05:07.015] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:07.020] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:07.020] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:07.020]   - Field: ‘label’
[16:05:07.020]   - Field: ‘local’
[16:05:07.021]   - Field: ‘owner’
[16:05:07.021]   - Field: ‘envir’
[16:05:07.021]   - Field: ‘workers’
[16:05:07.021]   - Field: ‘packages’
[16:05:07.021]   - Field: ‘gc’
[16:05:07.024]   - Field: ‘job’
[16:05:07.025]   - Field: ‘conditions’
[16:05:07.025]   - Field: ‘expr’
[16:05:07.025]   - Field: ‘uuid’
[16:05:07.026]   - Field: ‘seed’
[16:05:07.026]   - Field: ‘version’
[16:05:07.026]   - Field: ‘result’
[16:05:07.026]   - Field: ‘asynchronous’
[16:05:07.027]   - Field: ‘calls’
[16:05:07.027]   - Field: ‘globals’
[16:05:07.027]   - Field: ‘stdout’
[16:05:07.027]   - Field: ‘earlySignal’
[16:05:07.028]   - Field: ‘lazy’
[16:05:07.028]   - Field: ‘state’
[16:05:07.028] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:07.028] - Launch lazy future ...
[16:05:07.029] Packages needed by the future expression (n = 0): <none>
[16:05:07.029] Packages needed by future strategies (n = 0): <none>
[16:05:07.030] {
[16:05:07.030]     {
[16:05:07.030]         {
[16:05:07.030]             ...future.startTime <- base::Sys.time()
[16:05:07.030]             {
[16:05:07.030]                 {
[16:05:07.030]                   {
[16:05:07.030]                     {
[16:05:07.030]                       base::local({
[16:05:07.030]                         has_future <- base::requireNamespace("future", 
[16:05:07.030]                           quietly = TRUE)
[16:05:07.030]                         if (has_future) {
[16:05:07.030]                           ns <- base::getNamespace("future")
[16:05:07.030]                           version <- ns[[".package"]][["version"]]
[16:05:07.030]                           if (is.null(version)) 
[16:05:07.030]                             version <- utils::packageVersion("future")
[16:05:07.030]                         }
[16:05:07.030]                         else {
[16:05:07.030]                           version <- NULL
[16:05:07.030]                         }
[16:05:07.030]                         if (!has_future || version < "1.8.0") {
[16:05:07.030]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:07.030]                             "", base::R.version$version.string), 
[16:05:07.030]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:07.030]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:07.030]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:07.030]                               "release", "version")], collapse = " "), 
[16:05:07.030]                             hostname = base::Sys.info()[["nodename"]])
[16:05:07.030]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:07.030]                             info)
[16:05:07.030]                           info <- base::paste(info, collapse = "; ")
[16:05:07.030]                           if (!has_future) {
[16:05:07.030]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:07.030]                               info)
[16:05:07.030]                           }
[16:05:07.030]                           else {
[16:05:07.030]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:07.030]                               info, version)
[16:05:07.030]                           }
[16:05:07.030]                           base::stop(msg)
[16:05:07.030]                         }
[16:05:07.030]                       })
[16:05:07.030]                     }
[16:05:07.030]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:07.030]                     base::options(mc.cores = 1L)
[16:05:07.030]                   }
[16:05:07.030]                   options(future.plan = NULL)
[16:05:07.030]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.030]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:07.030]                 }
[16:05:07.030]                 ...future.workdir <- getwd()
[16:05:07.030]             }
[16:05:07.030]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:07.030]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:07.030]         }
[16:05:07.030]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:07.030]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:07.030]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:07.030]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:07.030]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:07.030]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:07.030]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:07.030]             base::names(...future.oldOptions))
[16:05:07.030]     }
[16:05:07.030]     if (FALSE) {
[16:05:07.030]     }
[16:05:07.030]     else {
[16:05:07.030]         if (TRUE) {
[16:05:07.030]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:07.030]                 open = "w")
[16:05:07.030]         }
[16:05:07.030]         else {
[16:05:07.030]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:07.030]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:07.030]         }
[16:05:07.030]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:07.030]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:07.030]             base::sink(type = "output", split = FALSE)
[16:05:07.030]             base::close(...future.stdout)
[16:05:07.030]         }, add = TRUE)
[16:05:07.030]     }
[16:05:07.030]     ...future.frame <- base::sys.nframe()
[16:05:07.030]     ...future.conditions <- base::list()
[16:05:07.030]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:07.030]     if (FALSE) {
[16:05:07.030]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:07.030]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:07.030]     }
[16:05:07.030]     ...future.result <- base::tryCatch({
[16:05:07.030]         base::withCallingHandlers({
[16:05:07.030]             ...future.value <- base::withVisible(base::local({
[16:05:07.030]                 withCallingHandlers({
[16:05:07.030]                   {
[16:05:07.030]                     b <- a * ii
[16:05:07.030]                     a <- 0
[16:05:07.030]                     b
[16:05:07.030]                   }
[16:05:07.030]                 }, immediateCondition = function(cond) {
[16:05:07.030]                   save_rds <- function (object, pathname, ...) 
[16:05:07.030]                   {
[16:05:07.030]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:07.030]                     if (file_test("-f", pathname_tmp)) {
[16:05:07.030]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.030]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:07.030]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.030]                         fi_tmp[["mtime"]])
[16:05:07.030]                     }
[16:05:07.030]                     tryCatch({
[16:05:07.030]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:07.030]                     }, error = function(ex) {
[16:05:07.030]                       msg <- conditionMessage(ex)
[16:05:07.030]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.030]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:07.030]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.030]                         fi_tmp[["mtime"]], msg)
[16:05:07.030]                       ex$message <- msg
[16:05:07.030]                       stop(ex)
[16:05:07.030]                     })
[16:05:07.030]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:07.030]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:07.030]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:07.030]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.030]                       fi <- file.info(pathname)
[16:05:07.030]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:07.030]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.030]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:07.030]                         fi[["size"]], fi[["mtime"]])
[16:05:07.030]                       stop(msg)
[16:05:07.030]                     }
[16:05:07.030]                     invisible(pathname)
[16:05:07.030]                   }
[16:05:07.030]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:07.030]                     rootPath = tempdir()) 
[16:05:07.030]                   {
[16:05:07.030]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:07.030]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:07.030]                       tmpdir = path, fileext = ".rds")
[16:05:07.030]                     save_rds(obj, file)
[16:05:07.030]                   }
[16:05:07.030]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:07.030]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.030]                   {
[16:05:07.030]                     inherits <- base::inherits
[16:05:07.030]                     invokeRestart <- base::invokeRestart
[16:05:07.030]                     is.null <- base::is.null
[16:05:07.030]                     muffled <- FALSE
[16:05:07.030]                     if (inherits(cond, "message")) {
[16:05:07.030]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:07.030]                       if (muffled) 
[16:05:07.030]                         invokeRestart("muffleMessage")
[16:05:07.030]                     }
[16:05:07.030]                     else if (inherits(cond, "warning")) {
[16:05:07.030]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:07.030]                       if (muffled) 
[16:05:07.030]                         invokeRestart("muffleWarning")
[16:05:07.030]                     }
[16:05:07.030]                     else if (inherits(cond, "condition")) {
[16:05:07.030]                       if (!is.null(pattern)) {
[16:05:07.030]                         computeRestarts <- base::computeRestarts
[16:05:07.030]                         grepl <- base::grepl
[16:05:07.030]                         restarts <- computeRestarts(cond)
[16:05:07.030]                         for (restart in restarts) {
[16:05:07.030]                           name <- restart$name
[16:05:07.030]                           if (is.null(name)) 
[16:05:07.030]                             next
[16:05:07.030]                           if (!grepl(pattern, name)) 
[16:05:07.030]                             next
[16:05:07.030]                           invokeRestart(restart)
[16:05:07.030]                           muffled <- TRUE
[16:05:07.030]                           break
[16:05:07.030]                         }
[16:05:07.030]                       }
[16:05:07.030]                     }
[16:05:07.030]                     invisible(muffled)
[16:05:07.030]                   }
[16:05:07.030]                   muffleCondition(cond)
[16:05:07.030]                 })
[16:05:07.030]             }))
[16:05:07.030]             future::FutureResult(value = ...future.value$value, 
[16:05:07.030]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.030]                   ...future.rng), globalenv = if (FALSE) 
[16:05:07.030]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:07.030]                     ...future.globalenv.names))
[16:05:07.030]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:07.030]         }, condition = base::local({
[16:05:07.030]             c <- base::c
[16:05:07.030]             inherits <- base::inherits
[16:05:07.030]             invokeRestart <- base::invokeRestart
[16:05:07.030]             length <- base::length
[16:05:07.030]             list <- base::list
[16:05:07.030]             seq.int <- base::seq.int
[16:05:07.030]             signalCondition <- base::signalCondition
[16:05:07.030]             sys.calls <- base::sys.calls
[16:05:07.030]             `[[` <- base::`[[`
[16:05:07.030]             `+` <- base::`+`
[16:05:07.030]             `<<-` <- base::`<<-`
[16:05:07.030]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:07.030]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:07.030]                   3L)]
[16:05:07.030]             }
[16:05:07.030]             function(cond) {
[16:05:07.030]                 is_error <- inherits(cond, "error")
[16:05:07.030]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:07.030]                   NULL)
[16:05:07.030]                 if (is_error) {
[16:05:07.030]                   sessionInformation <- function() {
[16:05:07.030]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:07.030]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:07.030]                       search = base::search(), system = base::Sys.info())
[16:05:07.030]                   }
[16:05:07.030]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.030]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:07.030]                     cond$call), session = sessionInformation(), 
[16:05:07.030]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:07.030]                   signalCondition(cond)
[16:05:07.030]                 }
[16:05:07.030]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:07.030]                 "immediateCondition"))) {
[16:05:07.030]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:07.030]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.030]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:07.030]                   if (TRUE && !signal) {
[16:05:07.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.030]                     {
[16:05:07.030]                       inherits <- base::inherits
[16:05:07.030]                       invokeRestart <- base::invokeRestart
[16:05:07.030]                       is.null <- base::is.null
[16:05:07.030]                       muffled <- FALSE
[16:05:07.030]                       if (inherits(cond, "message")) {
[16:05:07.030]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.030]                         if (muffled) 
[16:05:07.030]                           invokeRestart("muffleMessage")
[16:05:07.030]                       }
[16:05:07.030]                       else if (inherits(cond, "warning")) {
[16:05:07.030]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.030]                         if (muffled) 
[16:05:07.030]                           invokeRestart("muffleWarning")
[16:05:07.030]                       }
[16:05:07.030]                       else if (inherits(cond, "condition")) {
[16:05:07.030]                         if (!is.null(pattern)) {
[16:05:07.030]                           computeRestarts <- base::computeRestarts
[16:05:07.030]                           grepl <- base::grepl
[16:05:07.030]                           restarts <- computeRestarts(cond)
[16:05:07.030]                           for (restart in restarts) {
[16:05:07.030]                             name <- restart$name
[16:05:07.030]                             if (is.null(name)) 
[16:05:07.030]                               next
[16:05:07.030]                             if (!grepl(pattern, name)) 
[16:05:07.030]                               next
[16:05:07.030]                             invokeRestart(restart)
[16:05:07.030]                             muffled <- TRUE
[16:05:07.030]                             break
[16:05:07.030]                           }
[16:05:07.030]                         }
[16:05:07.030]                       }
[16:05:07.030]                       invisible(muffled)
[16:05:07.030]                     }
[16:05:07.030]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.030]                   }
[16:05:07.030]                 }
[16:05:07.030]                 else {
[16:05:07.030]                   if (TRUE) {
[16:05:07.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.030]                     {
[16:05:07.030]                       inherits <- base::inherits
[16:05:07.030]                       invokeRestart <- base::invokeRestart
[16:05:07.030]                       is.null <- base::is.null
[16:05:07.030]                       muffled <- FALSE
[16:05:07.030]                       if (inherits(cond, "message")) {
[16:05:07.030]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.030]                         if (muffled) 
[16:05:07.030]                           invokeRestart("muffleMessage")
[16:05:07.030]                       }
[16:05:07.030]                       else if (inherits(cond, "warning")) {
[16:05:07.030]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.030]                         if (muffled) 
[16:05:07.030]                           invokeRestart("muffleWarning")
[16:05:07.030]                       }
[16:05:07.030]                       else if (inherits(cond, "condition")) {
[16:05:07.030]                         if (!is.null(pattern)) {
[16:05:07.030]                           computeRestarts <- base::computeRestarts
[16:05:07.030]                           grepl <- base::grepl
[16:05:07.030]                           restarts <- computeRestarts(cond)
[16:05:07.030]                           for (restart in restarts) {
[16:05:07.030]                             name <- restart$name
[16:05:07.030]                             if (is.null(name)) 
[16:05:07.030]                               next
[16:05:07.030]                             if (!grepl(pattern, name)) 
[16:05:07.030]                               next
[16:05:07.030]                             invokeRestart(restart)
[16:05:07.030]                             muffled <- TRUE
[16:05:07.030]                             break
[16:05:07.030]                           }
[16:05:07.030]                         }
[16:05:07.030]                       }
[16:05:07.030]                       invisible(muffled)
[16:05:07.030]                     }
[16:05:07.030]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.030]                   }
[16:05:07.030]                 }
[16:05:07.030]             }
[16:05:07.030]         }))
[16:05:07.030]     }, error = function(ex) {
[16:05:07.030]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:07.030]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.030]                 ...future.rng), started = ...future.startTime, 
[16:05:07.030]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:07.030]             version = "1.8"), class = "FutureResult")
[16:05:07.030]     }, finally = {
[16:05:07.030]         if (!identical(...future.workdir, getwd())) 
[16:05:07.030]             setwd(...future.workdir)
[16:05:07.030]         {
[16:05:07.030]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:07.030]                 ...future.oldOptions$nwarnings <- NULL
[16:05:07.030]             }
[16:05:07.030]             base::options(...future.oldOptions)
[16:05:07.030]             if (.Platform$OS.type == "windows") {
[16:05:07.030]                 old_names <- names(...future.oldEnvVars)
[16:05:07.030]                 envs <- base::Sys.getenv()
[16:05:07.030]                 names <- names(envs)
[16:05:07.030]                 common <- intersect(names, old_names)
[16:05:07.030]                 added <- setdiff(names, old_names)
[16:05:07.030]                 removed <- setdiff(old_names, names)
[16:05:07.030]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:07.030]                   envs[common]]
[16:05:07.030]                 NAMES <- toupper(changed)
[16:05:07.030]                 args <- list()
[16:05:07.030]                 for (kk in seq_along(NAMES)) {
[16:05:07.030]                   name <- changed[[kk]]
[16:05:07.030]                   NAME <- NAMES[[kk]]
[16:05:07.030]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.030]                     next
[16:05:07.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.030]                 }
[16:05:07.030]                 NAMES <- toupper(added)
[16:05:07.030]                 for (kk in seq_along(NAMES)) {
[16:05:07.030]                   name <- added[[kk]]
[16:05:07.030]                   NAME <- NAMES[[kk]]
[16:05:07.030]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.030]                     next
[16:05:07.030]                   args[[name]] <- ""
[16:05:07.030]                 }
[16:05:07.030]                 NAMES <- toupper(removed)
[16:05:07.030]                 for (kk in seq_along(NAMES)) {
[16:05:07.030]                   name <- removed[[kk]]
[16:05:07.030]                   NAME <- NAMES[[kk]]
[16:05:07.030]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.030]                     next
[16:05:07.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.030]                 }
[16:05:07.030]                 if (length(args) > 0) 
[16:05:07.030]                   base::do.call(base::Sys.setenv, args = args)
[16:05:07.030]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:07.030]             }
[16:05:07.030]             else {
[16:05:07.030]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:07.030]             }
[16:05:07.030]             {
[16:05:07.030]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:07.030]                   0L) {
[16:05:07.030]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:07.030]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:07.030]                   base::options(opts)
[16:05:07.030]                 }
[16:05:07.030]                 {
[16:05:07.030]                   {
[16:05:07.030]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:07.030]                     NULL
[16:05:07.030]                   }
[16:05:07.030]                   options(future.plan = NULL)
[16:05:07.030]                   if (is.na(NA_character_)) 
[16:05:07.030]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.030]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:07.030]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:07.030]                     envir = parent.frame()) 
[16:05:07.030]                   {
[16:05:07.030]                     default_workers <- missing(workers)
[16:05:07.030]                     if (is.function(workers)) 
[16:05:07.030]                       workers <- workers()
[16:05:07.030]                     workers <- structure(as.integer(workers), 
[16:05:07.030]                       class = class(workers))
[16:05:07.030]                     stop_if_not(is.finite(workers), workers >= 
[16:05:07.030]                       1L)
[16:05:07.030]                     if ((workers == 1L && !inherits(workers, 
[16:05:07.030]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:07.030]                       if (default_workers) 
[16:05:07.030]                         supportsMulticore(warn = TRUE)
[16:05:07.030]                       return(sequential(..., envir = envir))
[16:05:07.030]                     }
[16:05:07.030]                     oopts <- options(mc.cores = workers)
[16:05:07.030]                     on.exit(options(oopts))
[16:05:07.030]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:07.030]                       envir = envir)
[16:05:07.030]                     if (!future$lazy) 
[16:05:07.030]                       future <- run(future)
[16:05:07.030]                     invisible(future)
[16:05:07.030]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:07.030]                 }
[16:05:07.030]             }
[16:05:07.030]         }
[16:05:07.030]     })
[16:05:07.030]     if (TRUE) {
[16:05:07.030]         base::sink(type = "output", split = FALSE)
[16:05:07.030]         if (TRUE) {
[16:05:07.030]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:07.030]         }
[16:05:07.030]         else {
[16:05:07.030]             ...future.result["stdout"] <- base::list(NULL)
[16:05:07.030]         }
[16:05:07.030]         base::close(...future.stdout)
[16:05:07.030]         ...future.stdout <- NULL
[16:05:07.030]     }
[16:05:07.030]     ...future.result$conditions <- ...future.conditions
[16:05:07.030]     ...future.result$finished <- base::Sys.time()
[16:05:07.030]     ...future.result
[16:05:07.030] }
[16:05:07.033] assign_globals() ...
[16:05:07.033] List of 1
[16:05:07.033]  $ ii: int 2
[16:05:07.033]  - attr(*, "where")=List of 1
[16:05:07.033]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:07.033]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:07.033]  - attr(*, "resolved")= logi TRUE
[16:05:07.033]  - attr(*, "total_size")= num 56
[16:05:07.033]  - attr(*, "already-done")= logi TRUE
[16:05:07.037] - copied ‘ii’ to environment
[16:05:07.037] assign_globals() ... done
[16:05:07.038] requestCore(): workers = 2
[16:05:07.040] MulticoreFuture started
[16:05:07.040] - Launch lazy future ... done
[16:05:07.041] run() for ‘MulticoreFuture’ ... done
[16:05:07.041] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.042] getGlobalsAndPackages() ...
[16:05:07.041] List of future strategies:
[16:05:07.041] 1. sequential:
[16:05:07.041]    - args: function (..., envir = parent.frame())
[16:05:07.041]    - tweaked: FALSE
[16:05:07.041]    - call: NULL
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.042] plan(): nbrOfWorkers() = 1
[16:05:07.042] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:07.044] plan(): Setting new future strategy stack:
[16:05:07.045] List of future strategies:
[16:05:07.045] 1. multicore:
[16:05:07.045]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.045]    - tweaked: FALSE
[16:05:07.045]    - call: plan(strategy)
[16:05:07.045] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:07.046] Searching for globals ... DONE
[16:05:07.046] Resolving globals: TRUE
[16:05:07.046] Resolving any globals that are futures ...
[16:05:07.046] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:07.046] Resolving any globals that are futures ... DONE
[16:05:07.047] Resolving futures part of globals (recursively) ...
[16:05:07.047] resolve() on list ...
[16:05:07.048]  recursive: 99
[16:05:07.048]  length: 1
[16:05:07.048]  elements: ‘ii’
[16:05:07.048]  length: 0 (resolved future 1)
[16:05:07.048] resolve() on list ... DONE
[16:05:07.048] - globals: [1] ‘ii’
[16:05:07.049] Resolving futures part of globals (recursively) ... DONE
[16:05:07.049] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:07.050] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:07.050] plan(): nbrOfWorkers() = 2
[16:05:07.050] - globals: [1] ‘ii’
[16:05:07.050] 
[16:05:07.050] getGlobalsAndPackages() ... DONE
[16:05:07.050] run() for ‘Future’ ...
[16:05:07.051] - state: ‘created’
[16:05:07.051] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:07.056] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:07.056] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:07.056]   - Field: ‘label’
[16:05:07.056]   - Field: ‘local’
[16:05:07.056]   - Field: ‘owner’
[16:05:07.056]   - Field: ‘envir’
[16:05:07.057]   - Field: ‘workers’
[16:05:07.057]   - Field: ‘packages’
[16:05:07.057]   - Field: ‘gc’
[16:05:07.057]   - Field: ‘job’
[16:05:07.057]   - Field: ‘conditions’
[16:05:07.057]   - Field: ‘expr’
[16:05:07.057]   - Field: ‘uuid’
[16:05:07.058]   - Field: ‘seed’
[16:05:07.058]   - Field: ‘version’
[16:05:07.058]   - Field: ‘result’
[16:05:07.058]   - Field: ‘asynchronous’
[16:05:07.058]   - Field: ‘calls’
[16:05:07.058]   - Field: ‘globals’
[16:05:07.058]   - Field: ‘stdout’
[16:05:07.059]   - Field: ‘earlySignal’
[16:05:07.059]   - Field: ‘lazy’
[16:05:07.059]   - Field: ‘state’
[16:05:07.059] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:07.059] - Launch lazy future ...
[16:05:07.060] Packages needed by the future expression (n = 0): <none>
[16:05:07.060] Packages needed by future strategies (n = 0): <none>
[16:05:07.061] {
[16:05:07.061]     {
[16:05:07.061]         {
[16:05:07.061]             ...future.startTime <- base::Sys.time()
[16:05:07.061]             {
[16:05:07.061]                 {
[16:05:07.061]                   {
[16:05:07.061]                     {
[16:05:07.061]                       base::local({
[16:05:07.061]                         has_future <- base::requireNamespace("future", 
[16:05:07.061]                           quietly = TRUE)
[16:05:07.061]                         if (has_future) {
[16:05:07.061]                           ns <- base::getNamespace("future")
[16:05:07.061]                           version <- ns[[".package"]][["version"]]
[16:05:07.061]                           if (is.null(version)) 
[16:05:07.061]                             version <- utils::packageVersion("future")
[16:05:07.061]                         }
[16:05:07.061]                         else {
[16:05:07.061]                           version <- NULL
[16:05:07.061]                         }
[16:05:07.061]                         if (!has_future || version < "1.8.0") {
[16:05:07.061]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:07.061]                             "", base::R.version$version.string), 
[16:05:07.061]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:07.061]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:07.061]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:07.061]                               "release", "version")], collapse = " "), 
[16:05:07.061]                             hostname = base::Sys.info()[["nodename"]])
[16:05:07.061]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:07.061]                             info)
[16:05:07.061]                           info <- base::paste(info, collapse = "; ")
[16:05:07.061]                           if (!has_future) {
[16:05:07.061]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:07.061]                               info)
[16:05:07.061]                           }
[16:05:07.061]                           else {
[16:05:07.061]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:07.061]                               info, version)
[16:05:07.061]                           }
[16:05:07.061]                           base::stop(msg)
[16:05:07.061]                         }
[16:05:07.061]                       })
[16:05:07.061]                     }
[16:05:07.061]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:07.061]                     base::options(mc.cores = 1L)
[16:05:07.061]                   }
[16:05:07.061]                   options(future.plan = NULL)
[16:05:07.061]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.061]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:07.061]                 }
[16:05:07.061]                 ...future.workdir <- getwd()
[16:05:07.061]             }
[16:05:07.061]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:07.061]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:07.061]         }
[16:05:07.061]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:07.061]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:07.061]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:07.061]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:07.061]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:07.061]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:07.061]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:07.061]             base::names(...future.oldOptions))
[16:05:07.061]     }
[16:05:07.061]     if (FALSE) {
[16:05:07.061]     }
[16:05:07.061]     else {
[16:05:07.061]         if (TRUE) {
[16:05:07.061]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:07.061]                 open = "w")
[16:05:07.061]         }
[16:05:07.061]         else {
[16:05:07.061]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:07.061]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:07.061]         }
[16:05:07.061]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:07.061]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:07.061]             base::sink(type = "output", split = FALSE)
[16:05:07.061]             base::close(...future.stdout)
[16:05:07.061]         }, add = TRUE)
[16:05:07.061]     }
[16:05:07.061]     ...future.frame <- base::sys.nframe()
[16:05:07.061]     ...future.conditions <- base::list()
[16:05:07.061]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:07.061]     if (FALSE) {
[16:05:07.061]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:07.061]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:07.061]     }
[16:05:07.061]     ...future.result <- base::tryCatch({
[16:05:07.061]         base::withCallingHandlers({
[16:05:07.061]             ...future.value <- base::withVisible(base::local({
[16:05:07.061]                 withCallingHandlers({
[16:05:07.061]                   {
[16:05:07.061]                     b <- a * ii
[16:05:07.061]                     a <- 0
[16:05:07.061]                     b
[16:05:07.061]                   }
[16:05:07.061]                 }, immediateCondition = function(cond) {
[16:05:07.061]                   save_rds <- function (object, pathname, ...) 
[16:05:07.061]                   {
[16:05:07.061]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:07.061]                     if (file_test("-f", pathname_tmp)) {
[16:05:07.061]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.061]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:07.061]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.061]                         fi_tmp[["mtime"]])
[16:05:07.061]                     }
[16:05:07.061]                     tryCatch({
[16:05:07.061]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:07.061]                     }, error = function(ex) {
[16:05:07.061]                       msg <- conditionMessage(ex)
[16:05:07.061]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.061]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:07.061]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.061]                         fi_tmp[["mtime"]], msg)
[16:05:07.061]                       ex$message <- msg
[16:05:07.061]                       stop(ex)
[16:05:07.061]                     })
[16:05:07.061]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:07.061]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:07.061]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:07.061]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.061]                       fi <- file.info(pathname)
[16:05:07.061]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:07.061]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.061]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:07.061]                         fi[["size"]], fi[["mtime"]])
[16:05:07.061]                       stop(msg)
[16:05:07.061]                     }
[16:05:07.061]                     invisible(pathname)
[16:05:07.061]                   }
[16:05:07.061]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:07.061]                     rootPath = tempdir()) 
[16:05:07.061]                   {
[16:05:07.061]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:07.061]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:07.061]                       tmpdir = path, fileext = ".rds")
[16:05:07.061]                     save_rds(obj, file)
[16:05:07.061]                   }
[16:05:07.061]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:07.061]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.061]                   {
[16:05:07.061]                     inherits <- base::inherits
[16:05:07.061]                     invokeRestart <- base::invokeRestart
[16:05:07.061]                     is.null <- base::is.null
[16:05:07.061]                     muffled <- FALSE
[16:05:07.061]                     if (inherits(cond, "message")) {
[16:05:07.061]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:07.061]                       if (muffled) 
[16:05:07.061]                         invokeRestart("muffleMessage")
[16:05:07.061]                     }
[16:05:07.061]                     else if (inherits(cond, "warning")) {
[16:05:07.061]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:07.061]                       if (muffled) 
[16:05:07.061]                         invokeRestart("muffleWarning")
[16:05:07.061]                     }
[16:05:07.061]                     else if (inherits(cond, "condition")) {
[16:05:07.061]                       if (!is.null(pattern)) {
[16:05:07.061]                         computeRestarts <- base::computeRestarts
[16:05:07.061]                         grepl <- base::grepl
[16:05:07.061]                         restarts <- computeRestarts(cond)
[16:05:07.061]                         for (restart in restarts) {
[16:05:07.061]                           name <- restart$name
[16:05:07.061]                           if (is.null(name)) 
[16:05:07.061]                             next
[16:05:07.061]                           if (!grepl(pattern, name)) 
[16:05:07.061]                             next
[16:05:07.061]                           invokeRestart(restart)
[16:05:07.061]                           muffled <- TRUE
[16:05:07.061]                           break
[16:05:07.061]                         }
[16:05:07.061]                       }
[16:05:07.061]                     }
[16:05:07.061]                     invisible(muffled)
[16:05:07.061]                   }
[16:05:07.061]                   muffleCondition(cond)
[16:05:07.061]                 })
[16:05:07.061]             }))
[16:05:07.061]             future::FutureResult(value = ...future.value$value, 
[16:05:07.061]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.061]                   ...future.rng), globalenv = if (FALSE) 
[16:05:07.061]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:07.061]                     ...future.globalenv.names))
[16:05:07.061]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:07.061]         }, condition = base::local({
[16:05:07.061]             c <- base::c
[16:05:07.061]             inherits <- base::inherits
[16:05:07.061]             invokeRestart <- base::invokeRestart
[16:05:07.061]             length <- base::length
[16:05:07.061]             list <- base::list
[16:05:07.061]             seq.int <- base::seq.int
[16:05:07.061]             signalCondition <- base::signalCondition
[16:05:07.061]             sys.calls <- base::sys.calls
[16:05:07.061]             `[[` <- base::`[[`
[16:05:07.061]             `+` <- base::`+`
[16:05:07.061]             `<<-` <- base::`<<-`
[16:05:07.061]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:07.061]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:07.061]                   3L)]
[16:05:07.061]             }
[16:05:07.061]             function(cond) {
[16:05:07.061]                 is_error <- inherits(cond, "error")
[16:05:07.061]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:07.061]                   NULL)
[16:05:07.061]                 if (is_error) {
[16:05:07.061]                   sessionInformation <- function() {
[16:05:07.061]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:07.061]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:07.061]                       search = base::search(), system = base::Sys.info())
[16:05:07.061]                   }
[16:05:07.061]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.061]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:07.061]                     cond$call), session = sessionInformation(), 
[16:05:07.061]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:07.061]                   signalCondition(cond)
[16:05:07.061]                 }
[16:05:07.061]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:07.061]                 "immediateCondition"))) {
[16:05:07.061]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:07.061]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.061]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:07.061]                   if (TRUE && !signal) {
[16:05:07.061]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.061]                     {
[16:05:07.061]                       inherits <- base::inherits
[16:05:07.061]                       invokeRestart <- base::invokeRestart
[16:05:07.061]                       is.null <- base::is.null
[16:05:07.061]                       muffled <- FALSE
[16:05:07.061]                       if (inherits(cond, "message")) {
[16:05:07.061]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.061]                         if (muffled) 
[16:05:07.061]                           invokeRestart("muffleMessage")
[16:05:07.061]                       }
[16:05:07.061]                       else if (inherits(cond, "warning")) {
[16:05:07.061]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.061]                         if (muffled) 
[16:05:07.061]                           invokeRestart("muffleWarning")
[16:05:07.061]                       }
[16:05:07.061]                       else if (inherits(cond, "condition")) {
[16:05:07.061]                         if (!is.null(pattern)) {
[16:05:07.061]                           computeRestarts <- base::computeRestarts
[16:05:07.061]                           grepl <- base::grepl
[16:05:07.061]                           restarts <- computeRestarts(cond)
[16:05:07.061]                           for (restart in restarts) {
[16:05:07.061]                             name <- restart$name
[16:05:07.061]                             if (is.null(name)) 
[16:05:07.061]                               next
[16:05:07.061]                             if (!grepl(pattern, name)) 
[16:05:07.061]                               next
[16:05:07.061]                             invokeRestart(restart)
[16:05:07.061]                             muffled <- TRUE
[16:05:07.061]                             break
[16:05:07.061]                           }
[16:05:07.061]                         }
[16:05:07.061]                       }
[16:05:07.061]                       invisible(muffled)
[16:05:07.061]                     }
[16:05:07.061]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.061]                   }
[16:05:07.061]                 }
[16:05:07.061]                 else {
[16:05:07.061]                   if (TRUE) {
[16:05:07.061]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.061]                     {
[16:05:07.061]                       inherits <- base::inherits
[16:05:07.061]                       invokeRestart <- base::invokeRestart
[16:05:07.061]                       is.null <- base::is.null
[16:05:07.061]                       muffled <- FALSE
[16:05:07.061]                       if (inherits(cond, "message")) {
[16:05:07.061]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.061]                         if (muffled) 
[16:05:07.061]                           invokeRestart("muffleMessage")
[16:05:07.061]                       }
[16:05:07.061]                       else if (inherits(cond, "warning")) {
[16:05:07.061]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.061]                         if (muffled) 
[16:05:07.061]                           invokeRestart("muffleWarning")
[16:05:07.061]                       }
[16:05:07.061]                       else if (inherits(cond, "condition")) {
[16:05:07.061]                         if (!is.null(pattern)) {
[16:05:07.061]                           computeRestarts <- base::computeRestarts
[16:05:07.061]                           grepl <- base::grepl
[16:05:07.061]                           restarts <- computeRestarts(cond)
[16:05:07.061]                           for (restart in restarts) {
[16:05:07.061]                             name <- restart$name
[16:05:07.061]                             if (is.null(name)) 
[16:05:07.061]                               next
[16:05:07.061]                             if (!grepl(pattern, name)) 
[16:05:07.061]                               next
[16:05:07.061]                             invokeRestart(restart)
[16:05:07.061]                             muffled <- TRUE
[16:05:07.061]                             break
[16:05:07.061]                           }
[16:05:07.061]                         }
[16:05:07.061]                       }
[16:05:07.061]                       invisible(muffled)
[16:05:07.061]                     }
[16:05:07.061]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.061]                   }
[16:05:07.061]                 }
[16:05:07.061]             }
[16:05:07.061]         }))
[16:05:07.061]     }, error = function(ex) {
[16:05:07.061]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:07.061]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.061]                 ...future.rng), started = ...future.startTime, 
[16:05:07.061]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:07.061]             version = "1.8"), class = "FutureResult")
[16:05:07.061]     }, finally = {
[16:05:07.061]         if (!identical(...future.workdir, getwd())) 
[16:05:07.061]             setwd(...future.workdir)
[16:05:07.061]         {
[16:05:07.061]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:07.061]                 ...future.oldOptions$nwarnings <- NULL
[16:05:07.061]             }
[16:05:07.061]             base::options(...future.oldOptions)
[16:05:07.061]             if (.Platform$OS.type == "windows") {
[16:05:07.061]                 old_names <- names(...future.oldEnvVars)
[16:05:07.061]                 envs <- base::Sys.getenv()
[16:05:07.061]                 names <- names(envs)
[16:05:07.061]                 common <- intersect(names, old_names)
[16:05:07.061]                 added <- setdiff(names, old_names)
[16:05:07.061]                 removed <- setdiff(old_names, names)
[16:05:07.061]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:07.061]                   envs[common]]
[16:05:07.061]                 NAMES <- toupper(changed)
[16:05:07.061]                 args <- list()
[16:05:07.061]                 for (kk in seq_along(NAMES)) {
[16:05:07.061]                   name <- changed[[kk]]
[16:05:07.061]                   NAME <- NAMES[[kk]]
[16:05:07.061]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.061]                     next
[16:05:07.061]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.061]                 }
[16:05:07.061]                 NAMES <- toupper(added)
[16:05:07.061]                 for (kk in seq_along(NAMES)) {
[16:05:07.061]                   name <- added[[kk]]
[16:05:07.061]                   NAME <- NAMES[[kk]]
[16:05:07.061]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.061]                     next
[16:05:07.061]                   args[[name]] <- ""
[16:05:07.061]                 }
[16:05:07.061]                 NAMES <- toupper(removed)
[16:05:07.061]                 for (kk in seq_along(NAMES)) {
[16:05:07.061]                   name <- removed[[kk]]
[16:05:07.061]                   NAME <- NAMES[[kk]]
[16:05:07.061]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.061]                     next
[16:05:07.061]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.061]                 }
[16:05:07.061]                 if (length(args) > 0) 
[16:05:07.061]                   base::do.call(base::Sys.setenv, args = args)
[16:05:07.061]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:07.061]             }
[16:05:07.061]             else {
[16:05:07.061]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:07.061]             }
[16:05:07.061]             {
[16:05:07.061]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:07.061]                   0L) {
[16:05:07.061]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:07.061]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:07.061]                   base::options(opts)
[16:05:07.061]                 }
[16:05:07.061]                 {
[16:05:07.061]                   {
[16:05:07.061]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:07.061]                     NULL
[16:05:07.061]                   }
[16:05:07.061]                   options(future.plan = NULL)
[16:05:07.061]                   if (is.na(NA_character_)) 
[16:05:07.061]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.061]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:07.061]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:07.061]                     envir = parent.frame()) 
[16:05:07.061]                   {
[16:05:07.061]                     default_workers <- missing(workers)
[16:05:07.061]                     if (is.function(workers)) 
[16:05:07.061]                       workers <- workers()
[16:05:07.061]                     workers <- structure(as.integer(workers), 
[16:05:07.061]                       class = class(workers))
[16:05:07.061]                     stop_if_not(is.finite(workers), workers >= 
[16:05:07.061]                       1L)
[16:05:07.061]                     if ((workers == 1L && !inherits(workers, 
[16:05:07.061]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:07.061]                       if (default_workers) 
[16:05:07.061]                         supportsMulticore(warn = TRUE)
[16:05:07.061]                       return(sequential(..., envir = envir))
[16:05:07.061]                     }
[16:05:07.061]                     oopts <- options(mc.cores = workers)
[16:05:07.061]                     on.exit(options(oopts))
[16:05:07.061]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:07.061]                       envir = envir)
[16:05:07.061]                     if (!future$lazy) 
[16:05:07.061]                       future <- run(future)
[16:05:07.061]                     invisible(future)
[16:05:07.061]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:07.061]                 }
[16:05:07.061]             }
[16:05:07.061]         }
[16:05:07.061]     })
[16:05:07.061]     if (TRUE) {
[16:05:07.061]         base::sink(type = "output", split = FALSE)
[16:05:07.061]         if (TRUE) {
[16:05:07.061]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:07.061]         }
[16:05:07.061]         else {
[16:05:07.061]             ...future.result["stdout"] <- base::list(NULL)
[16:05:07.061]         }
[16:05:07.061]         base::close(...future.stdout)
[16:05:07.061]         ...future.stdout <- NULL
[16:05:07.061]     }
[16:05:07.061]     ...future.result$conditions <- ...future.conditions
[16:05:07.061]     ...future.result$finished <- base::Sys.time()
[16:05:07.061]     ...future.result
[16:05:07.061] }
[16:05:07.064] assign_globals() ...
[16:05:07.064] List of 1
[16:05:07.064]  $ ii: int 3
[16:05:07.064]  - attr(*, "where")=List of 1
[16:05:07.064]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:07.064]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:07.064]  - attr(*, "resolved")= logi TRUE
[16:05:07.064]  - attr(*, "total_size")= num 56
[16:05:07.064]  - attr(*, "already-done")= logi TRUE
[16:05:07.068] - copied ‘ii’ to environment
[16:05:07.068] assign_globals() ... done
[16:05:07.069] requestCore(): workers = 2
[16:05:07.069] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:07.080] result() for MulticoreFuture ...
[16:05:07.081] result() for MulticoreFuture ...
[16:05:07.081] result() for MulticoreFuture ... done
[16:05:07.081] result() for MulticoreFuture ... done
[16:05:07.082] result() for MulticoreFuture ...
[16:05:07.082] result() for MulticoreFuture ... done
[16:05:07.088] MulticoreFuture started
[16:05:07.088] - Launch lazy future ... done
[16:05:07.089] run() for ‘MulticoreFuture’ ... done
[16:05:07.090] result() for MulticoreFuture ...
[16:05:07.090] plan(): Setting new future strategy stack:
[16:05:07.091] result() for MulticoreFuture ... done
[16:05:07.091] result() for MulticoreFuture ...
[16:05:07.092] result() for MulticoreFuture ... done
[16:05:07.091] List of future strategies:
[16:05:07.091] 1. sequential:
[16:05:07.091]    - args: function (..., envir = parent.frame())
[16:05:07.091]    - tweaked: FALSE
[16:05:07.091]    - call: NULL
[16:05:07.092] plan(): nbrOfWorkers() = 1
[16:05:07.092] result() for MulticoreFuture ...
[16:05:07.095] result() for MulticoreFuture ...
[16:05:07.095] result() for MulticoreFuture ... done
[16:05:07.096] plan(): Setting new future strategy stack:
[16:05:07.096] result() for MulticoreFuture ... done
[16:05:07.096] result() for MulticoreFuture ...
[16:05:07.096] List of future strategies:
[16:05:07.096] 1. multicore:
[16:05:07.096]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.096]    - tweaked: FALSE
[16:05:07.096]    - call: plan(strategy)
[16:05:07.097] result() for MulticoreFuture ... done
[16:05:07.097] result() for MulticoreFuture ...
[16:05:07.102] plan(): nbrOfWorkers() = 2
[16:05:07.103] result() for MulticoreFuture ...
[16:05:07.103] result() for MulticoreFuture ... done
[16:05:07.103] result() for MulticoreFuture ... done
[16:05:07.103] result() for MulticoreFuture ...
[16:05:07.103] result() for MulticoreFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.105] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.105] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:07.107] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:07.107] Searching for globals ... DONE
[16:05:07.107] Resolving globals: TRUE
[16:05:07.108] Resolving any globals that are futures ...
[16:05:07.108] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:07.108] Resolving any globals that are futures ... DONE
[16:05:07.108] Resolving futures part of globals (recursively) ...
[16:05:07.109] resolve() on list ...
[16:05:07.109]  recursive: 99
[16:05:07.109]  length: 1
[16:05:07.109]  elements: ‘ii’
[16:05:07.109]  length: 0 (resolved future 1)
[16:05:07.109] resolve() on list ... DONE
[16:05:07.109] - globals: [1] ‘ii’
[16:05:07.109] Resolving futures part of globals (recursively) ... DONE
[16:05:07.110] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:07.110] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:07.110] - globals: [1] ‘ii’
[16:05:07.110] 
[16:05:07.110] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.111] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.111] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:07.113] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:07.113] Searching for globals ... DONE
[16:05:07.113] Resolving globals: TRUE
[16:05:07.113] Resolving any globals that are futures ...
[16:05:07.114] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:07.114] Resolving any globals that are futures ... DONE
[16:05:07.114] Resolving futures part of globals (recursively) ...
[16:05:07.114] resolve() on list ...
[16:05:07.114]  recursive: 99
[16:05:07.115]  length: 1
[16:05:07.115]  elements: ‘ii’
[16:05:07.115]  length: 0 (resolved future 1)
[16:05:07.115] resolve() on list ... DONE
[16:05:07.115] - globals: [1] ‘ii’
[16:05:07.115] Resolving futures part of globals (recursively) ... DONE
[16:05:07.115] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:07.116] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:07.116] - globals: [1] ‘ii’
[16:05:07.116] 
[16:05:07.116] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.117] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.117] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:07.119] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:07.119] Searching for globals ... DONE
[16:05:07.119] Resolving globals: TRUE
[16:05:07.119] Resolving any globals that are futures ...
[16:05:07.119] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:07.119] Resolving any globals that are futures ... DONE
[16:05:07.120] Resolving futures part of globals (recursively) ...
[16:05:07.120] resolve() on list ...
[16:05:07.120]  recursive: 99
[16:05:07.120]  length: 1
[16:05:07.120]  elements: ‘ii’
[16:05:07.120]  length: 0 (resolved future 1)
[16:05:07.120] resolve() on list ... DONE
[16:05:07.121] - globals: [1] ‘ii’
[16:05:07.121] Resolving futures part of globals (recursively) ... DONE
[16:05:07.121] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:07.121] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:07.121] - globals: [1] ‘ii’
[16:05:07.121] 
[16:05:07.122] getGlobalsAndPackages() ... DONE
[16:05:07.122] run() for ‘Future’ ...
[16:05:07.122] - state: ‘created’
[16:05:07.122] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:07.126] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:07.127] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:07.127]   - Field: ‘label’
[16:05:07.127]   - Field: ‘local’
[16:05:07.127]   - Field: ‘owner’
[16:05:07.127]   - Field: ‘envir’
[16:05:07.127]   - Field: ‘workers’
[16:05:07.127]   - Field: ‘packages’
[16:05:07.127]   - Field: ‘gc’
[16:05:07.128]   - Field: ‘job’
[16:05:07.128]   - Field: ‘conditions’
[16:05:07.128]   - Field: ‘expr’
[16:05:07.128]   - Field: ‘uuid’
[16:05:07.130]   - Field: ‘seed’
[16:05:07.130]   - Field: ‘version’
[16:05:07.130]   - Field: ‘result’
[16:05:07.130]   - Field: ‘asynchronous’
[16:05:07.130]   - Field: ‘calls’
[16:05:07.130]   - Field: ‘globals’
[16:05:07.131]   - Field: ‘stdout’
[16:05:07.131]   - Field: ‘earlySignal’
[16:05:07.131]   - Field: ‘lazy’
[16:05:07.131]   - Field: ‘state’
[16:05:07.131] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:07.131] - Launch lazy future ...
[16:05:07.132] Packages needed by the future expression (n = 0): <none>
[16:05:07.132] Packages needed by future strategies (n = 0): <none>
[16:05:07.132] {
[16:05:07.132]     {
[16:05:07.132]         {
[16:05:07.132]             ...future.startTime <- base::Sys.time()
[16:05:07.132]             {
[16:05:07.132]                 {
[16:05:07.132]                   {
[16:05:07.132]                     {
[16:05:07.132]                       base::local({
[16:05:07.132]                         has_future <- base::requireNamespace("future", 
[16:05:07.132]                           quietly = TRUE)
[16:05:07.132]                         if (has_future) {
[16:05:07.132]                           ns <- base::getNamespace("future")
[16:05:07.132]                           version <- ns[[".package"]][["version"]]
[16:05:07.132]                           if (is.null(version)) 
[16:05:07.132]                             version <- utils::packageVersion("future")
[16:05:07.132]                         }
[16:05:07.132]                         else {
[16:05:07.132]                           version <- NULL
[16:05:07.132]                         }
[16:05:07.132]                         if (!has_future || version < "1.8.0") {
[16:05:07.132]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:07.132]                             "", base::R.version$version.string), 
[16:05:07.132]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:07.132]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:07.132]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:07.132]                               "release", "version")], collapse = " "), 
[16:05:07.132]                             hostname = base::Sys.info()[["nodename"]])
[16:05:07.132]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:07.132]                             info)
[16:05:07.132]                           info <- base::paste(info, collapse = "; ")
[16:05:07.132]                           if (!has_future) {
[16:05:07.132]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:07.132]                               info)
[16:05:07.132]                           }
[16:05:07.132]                           else {
[16:05:07.132]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:07.132]                               info, version)
[16:05:07.132]                           }
[16:05:07.132]                           base::stop(msg)
[16:05:07.132]                         }
[16:05:07.132]                       })
[16:05:07.132]                     }
[16:05:07.132]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:07.132]                     base::options(mc.cores = 1L)
[16:05:07.132]                   }
[16:05:07.132]                   options(future.plan = NULL)
[16:05:07.132]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.132]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:07.132]                 }
[16:05:07.132]                 ...future.workdir <- getwd()
[16:05:07.132]             }
[16:05:07.132]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:07.132]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:07.132]         }
[16:05:07.132]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:07.132]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:07.132]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:07.132]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:07.132]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:07.132]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:07.132]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:07.132]             base::names(...future.oldOptions))
[16:05:07.132]     }
[16:05:07.132]     if (FALSE) {
[16:05:07.132]     }
[16:05:07.132]     else {
[16:05:07.132]         if (TRUE) {
[16:05:07.132]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:07.132]                 open = "w")
[16:05:07.132]         }
[16:05:07.132]         else {
[16:05:07.132]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:07.132]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:07.132]         }
[16:05:07.132]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:07.132]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:07.132]             base::sink(type = "output", split = FALSE)
[16:05:07.132]             base::close(...future.stdout)
[16:05:07.132]         }, add = TRUE)
[16:05:07.132]     }
[16:05:07.132]     ...future.frame <- base::sys.nframe()
[16:05:07.132]     ...future.conditions <- base::list()
[16:05:07.132]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:07.132]     if (FALSE) {
[16:05:07.132]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:07.132]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:07.132]     }
[16:05:07.132]     ...future.result <- base::tryCatch({
[16:05:07.132]         base::withCallingHandlers({
[16:05:07.132]             ...future.value <- base::withVisible(base::local({
[16:05:07.132]                 withCallingHandlers({
[16:05:07.132]                   {
[16:05:07.132]                     b <- a * ii
[16:05:07.132]                     a <- 0
[16:05:07.132]                     b
[16:05:07.132]                   }
[16:05:07.132]                 }, immediateCondition = function(cond) {
[16:05:07.132]                   save_rds <- function (object, pathname, ...) 
[16:05:07.132]                   {
[16:05:07.132]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:07.132]                     if (file_test("-f", pathname_tmp)) {
[16:05:07.132]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.132]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:07.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.132]                         fi_tmp[["mtime"]])
[16:05:07.132]                     }
[16:05:07.132]                     tryCatch({
[16:05:07.132]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:07.132]                     }, error = function(ex) {
[16:05:07.132]                       msg <- conditionMessage(ex)
[16:05:07.132]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.132]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:07.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.132]                         fi_tmp[["mtime"]], msg)
[16:05:07.132]                       ex$message <- msg
[16:05:07.132]                       stop(ex)
[16:05:07.132]                     })
[16:05:07.132]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:07.132]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:07.132]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:07.132]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.132]                       fi <- file.info(pathname)
[16:05:07.132]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:07.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.132]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:07.132]                         fi[["size"]], fi[["mtime"]])
[16:05:07.132]                       stop(msg)
[16:05:07.132]                     }
[16:05:07.132]                     invisible(pathname)
[16:05:07.132]                   }
[16:05:07.132]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:07.132]                     rootPath = tempdir()) 
[16:05:07.132]                   {
[16:05:07.132]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:07.132]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:07.132]                       tmpdir = path, fileext = ".rds")
[16:05:07.132]                     save_rds(obj, file)
[16:05:07.132]                   }
[16:05:07.132]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:07.132]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.132]                   {
[16:05:07.132]                     inherits <- base::inherits
[16:05:07.132]                     invokeRestart <- base::invokeRestart
[16:05:07.132]                     is.null <- base::is.null
[16:05:07.132]                     muffled <- FALSE
[16:05:07.132]                     if (inherits(cond, "message")) {
[16:05:07.132]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:07.132]                       if (muffled) 
[16:05:07.132]                         invokeRestart("muffleMessage")
[16:05:07.132]                     }
[16:05:07.132]                     else if (inherits(cond, "warning")) {
[16:05:07.132]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:07.132]                       if (muffled) 
[16:05:07.132]                         invokeRestart("muffleWarning")
[16:05:07.132]                     }
[16:05:07.132]                     else if (inherits(cond, "condition")) {
[16:05:07.132]                       if (!is.null(pattern)) {
[16:05:07.132]                         computeRestarts <- base::computeRestarts
[16:05:07.132]                         grepl <- base::grepl
[16:05:07.132]                         restarts <- computeRestarts(cond)
[16:05:07.132]                         for (restart in restarts) {
[16:05:07.132]                           name <- restart$name
[16:05:07.132]                           if (is.null(name)) 
[16:05:07.132]                             next
[16:05:07.132]                           if (!grepl(pattern, name)) 
[16:05:07.132]                             next
[16:05:07.132]                           invokeRestart(restart)
[16:05:07.132]                           muffled <- TRUE
[16:05:07.132]                           break
[16:05:07.132]                         }
[16:05:07.132]                       }
[16:05:07.132]                     }
[16:05:07.132]                     invisible(muffled)
[16:05:07.132]                   }
[16:05:07.132]                   muffleCondition(cond)
[16:05:07.132]                 })
[16:05:07.132]             }))
[16:05:07.132]             future::FutureResult(value = ...future.value$value, 
[16:05:07.132]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.132]                   ...future.rng), globalenv = if (FALSE) 
[16:05:07.132]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:07.132]                     ...future.globalenv.names))
[16:05:07.132]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:07.132]         }, condition = base::local({
[16:05:07.132]             c <- base::c
[16:05:07.132]             inherits <- base::inherits
[16:05:07.132]             invokeRestart <- base::invokeRestart
[16:05:07.132]             length <- base::length
[16:05:07.132]             list <- base::list
[16:05:07.132]             seq.int <- base::seq.int
[16:05:07.132]             signalCondition <- base::signalCondition
[16:05:07.132]             sys.calls <- base::sys.calls
[16:05:07.132]             `[[` <- base::`[[`
[16:05:07.132]             `+` <- base::`+`
[16:05:07.132]             `<<-` <- base::`<<-`
[16:05:07.132]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:07.132]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:07.132]                   3L)]
[16:05:07.132]             }
[16:05:07.132]             function(cond) {
[16:05:07.132]                 is_error <- inherits(cond, "error")
[16:05:07.132]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:07.132]                   NULL)
[16:05:07.132]                 if (is_error) {
[16:05:07.132]                   sessionInformation <- function() {
[16:05:07.132]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:07.132]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:07.132]                       search = base::search(), system = base::Sys.info())
[16:05:07.132]                   }
[16:05:07.132]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.132]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:07.132]                     cond$call), session = sessionInformation(), 
[16:05:07.132]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:07.132]                   signalCondition(cond)
[16:05:07.132]                 }
[16:05:07.132]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:07.132]                 "immediateCondition"))) {
[16:05:07.132]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:07.132]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.132]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:07.132]                   if (TRUE && !signal) {
[16:05:07.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.132]                     {
[16:05:07.132]                       inherits <- base::inherits
[16:05:07.132]                       invokeRestart <- base::invokeRestart
[16:05:07.132]                       is.null <- base::is.null
[16:05:07.132]                       muffled <- FALSE
[16:05:07.132]                       if (inherits(cond, "message")) {
[16:05:07.132]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.132]                         if (muffled) 
[16:05:07.132]                           invokeRestart("muffleMessage")
[16:05:07.132]                       }
[16:05:07.132]                       else if (inherits(cond, "warning")) {
[16:05:07.132]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.132]                         if (muffled) 
[16:05:07.132]                           invokeRestart("muffleWarning")
[16:05:07.132]                       }
[16:05:07.132]                       else if (inherits(cond, "condition")) {
[16:05:07.132]                         if (!is.null(pattern)) {
[16:05:07.132]                           computeRestarts <- base::computeRestarts
[16:05:07.132]                           grepl <- base::grepl
[16:05:07.132]                           restarts <- computeRestarts(cond)
[16:05:07.132]                           for (restart in restarts) {
[16:05:07.132]                             name <- restart$name
[16:05:07.132]                             if (is.null(name)) 
[16:05:07.132]                               next
[16:05:07.132]                             if (!grepl(pattern, name)) 
[16:05:07.132]                               next
[16:05:07.132]                             invokeRestart(restart)
[16:05:07.132]                             muffled <- TRUE
[16:05:07.132]                             break
[16:05:07.132]                           }
[16:05:07.132]                         }
[16:05:07.132]                       }
[16:05:07.132]                       invisible(muffled)
[16:05:07.132]                     }
[16:05:07.132]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.132]                   }
[16:05:07.132]                 }
[16:05:07.132]                 else {
[16:05:07.132]                   if (TRUE) {
[16:05:07.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.132]                     {
[16:05:07.132]                       inherits <- base::inherits
[16:05:07.132]                       invokeRestart <- base::invokeRestart
[16:05:07.132]                       is.null <- base::is.null
[16:05:07.132]                       muffled <- FALSE
[16:05:07.132]                       if (inherits(cond, "message")) {
[16:05:07.132]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.132]                         if (muffled) 
[16:05:07.132]                           invokeRestart("muffleMessage")
[16:05:07.132]                       }
[16:05:07.132]                       else if (inherits(cond, "warning")) {
[16:05:07.132]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.132]                         if (muffled) 
[16:05:07.132]                           invokeRestart("muffleWarning")
[16:05:07.132]                       }
[16:05:07.132]                       else if (inherits(cond, "condition")) {
[16:05:07.132]                         if (!is.null(pattern)) {
[16:05:07.132]                           computeRestarts <- base::computeRestarts
[16:05:07.132]                           grepl <- base::grepl
[16:05:07.132]                           restarts <- computeRestarts(cond)
[16:05:07.132]                           for (restart in restarts) {
[16:05:07.132]                             name <- restart$name
[16:05:07.132]                             if (is.null(name)) 
[16:05:07.132]                               next
[16:05:07.132]                             if (!grepl(pattern, name)) 
[16:05:07.132]                               next
[16:05:07.132]                             invokeRestart(restart)
[16:05:07.132]                             muffled <- TRUE
[16:05:07.132]                             break
[16:05:07.132]                           }
[16:05:07.132]                         }
[16:05:07.132]                       }
[16:05:07.132]                       invisible(muffled)
[16:05:07.132]                     }
[16:05:07.132]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.132]                   }
[16:05:07.132]                 }
[16:05:07.132]             }
[16:05:07.132]         }))
[16:05:07.132]     }, error = function(ex) {
[16:05:07.132]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:07.132]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.132]                 ...future.rng), started = ...future.startTime, 
[16:05:07.132]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:07.132]             version = "1.8"), class = "FutureResult")
[16:05:07.132]     }, finally = {
[16:05:07.132]         if (!identical(...future.workdir, getwd())) 
[16:05:07.132]             setwd(...future.workdir)
[16:05:07.132]         {
[16:05:07.132]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:07.132]                 ...future.oldOptions$nwarnings <- NULL
[16:05:07.132]             }
[16:05:07.132]             base::options(...future.oldOptions)
[16:05:07.132]             if (.Platform$OS.type == "windows") {
[16:05:07.132]                 old_names <- names(...future.oldEnvVars)
[16:05:07.132]                 envs <- base::Sys.getenv()
[16:05:07.132]                 names <- names(envs)
[16:05:07.132]                 common <- intersect(names, old_names)
[16:05:07.132]                 added <- setdiff(names, old_names)
[16:05:07.132]                 removed <- setdiff(old_names, names)
[16:05:07.132]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:07.132]                   envs[common]]
[16:05:07.132]                 NAMES <- toupper(changed)
[16:05:07.132]                 args <- list()
[16:05:07.132]                 for (kk in seq_along(NAMES)) {
[16:05:07.132]                   name <- changed[[kk]]
[16:05:07.132]                   NAME <- NAMES[[kk]]
[16:05:07.132]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.132]                     next
[16:05:07.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.132]                 }
[16:05:07.132]                 NAMES <- toupper(added)
[16:05:07.132]                 for (kk in seq_along(NAMES)) {
[16:05:07.132]                   name <- added[[kk]]
[16:05:07.132]                   NAME <- NAMES[[kk]]
[16:05:07.132]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.132]                     next
[16:05:07.132]                   args[[name]] <- ""
[16:05:07.132]                 }
[16:05:07.132]                 NAMES <- toupper(removed)
[16:05:07.132]                 for (kk in seq_along(NAMES)) {
[16:05:07.132]                   name <- removed[[kk]]
[16:05:07.132]                   NAME <- NAMES[[kk]]
[16:05:07.132]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.132]                     next
[16:05:07.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.132]                 }
[16:05:07.132]                 if (length(args) > 0) 
[16:05:07.132]                   base::do.call(base::Sys.setenv, args = args)
[16:05:07.132]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:07.132]             }
[16:05:07.132]             else {
[16:05:07.132]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:07.132]             }
[16:05:07.132]             {
[16:05:07.132]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:07.132]                   0L) {
[16:05:07.132]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:07.132]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:07.132]                   base::options(opts)
[16:05:07.132]                 }
[16:05:07.132]                 {
[16:05:07.132]                   {
[16:05:07.132]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:07.132]                     NULL
[16:05:07.132]                   }
[16:05:07.132]                   options(future.plan = NULL)
[16:05:07.132]                   if (is.na(NA_character_)) 
[16:05:07.132]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.132]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:07.132]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:07.132]                     envir = parent.frame()) 
[16:05:07.132]                   {
[16:05:07.132]                     default_workers <- missing(workers)
[16:05:07.132]                     if (is.function(workers)) 
[16:05:07.132]                       workers <- workers()
[16:05:07.132]                     workers <- structure(as.integer(workers), 
[16:05:07.132]                       class = class(workers))
[16:05:07.132]                     stop_if_not(is.finite(workers), workers >= 
[16:05:07.132]                       1L)
[16:05:07.132]                     if ((workers == 1L && !inherits(workers, 
[16:05:07.132]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:07.132]                       if (default_workers) 
[16:05:07.132]                         supportsMulticore(warn = TRUE)
[16:05:07.132]                       return(sequential(..., envir = envir))
[16:05:07.132]                     }
[16:05:07.132]                     oopts <- options(mc.cores = workers)
[16:05:07.132]                     on.exit(options(oopts))
[16:05:07.132]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:07.132]                       envir = envir)
[16:05:07.132]                     if (!future$lazy) 
[16:05:07.132]                       future <- run(future)
[16:05:07.132]                     invisible(future)
[16:05:07.132]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:07.132]                 }
[16:05:07.132]             }
[16:05:07.132]         }
[16:05:07.132]     })
[16:05:07.132]     if (TRUE) {
[16:05:07.132]         base::sink(type = "output", split = FALSE)
[16:05:07.132]         if (TRUE) {
[16:05:07.132]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:07.132]         }
[16:05:07.132]         else {
[16:05:07.132]             ...future.result["stdout"] <- base::list(NULL)
[16:05:07.132]         }
[16:05:07.132]         base::close(...future.stdout)
[16:05:07.132]         ...future.stdout <- NULL
[16:05:07.132]     }
[16:05:07.132]     ...future.result$conditions <- ...future.conditions
[16:05:07.132]     ...future.result$finished <- base::Sys.time()
[16:05:07.132]     ...future.result
[16:05:07.132] }
[16:05:07.135] assign_globals() ...
[16:05:07.135] List of 1
[16:05:07.135]  $ ii: int 1
[16:05:07.135]  - attr(*, "where")=List of 1
[16:05:07.135]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:07.135]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:07.135]  - attr(*, "resolved")= logi TRUE
[16:05:07.135]  - attr(*, "total_size")= num 56
[16:05:07.135]  - attr(*, "already-done")= logi TRUE
[16:05:07.138] - copied ‘ii’ to environment
[16:05:07.138] assign_globals() ... done
[16:05:07.138] requestCore(): workers = 2
[16:05:07.140] MulticoreFuture started
[16:05:07.141] - Launch lazy future ... done
[16:05:07.141] run() for ‘MulticoreFuture’ ... done
[16:05:07.141] result() for MulticoreFuture ...
[16:05:07.142] plan(): Setting new future strategy stack:
[16:05:07.142] List of future strategies:
[16:05:07.142] 1. sequential:
[16:05:07.142]    - args: function (..., envir = parent.frame())
[16:05:07.142]    - tweaked: FALSE
[16:05:07.142]    - call: NULL
[16:05:07.143] plan(): nbrOfWorkers() = 1
[16:05:07.145] plan(): Setting new future strategy stack:
[16:05:07.145] List of future strategies:
[16:05:07.145] 1. multicore:
[16:05:07.145]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.145]    - tweaked: FALSE
[16:05:07.145]    - call: plan(strategy)
[16:05:07.151] plan(): nbrOfWorkers() = 2
[16:05:07.158] result() for MulticoreFuture ...
[16:05:07.158] result() for MulticoreFuture ... done
[16:05:07.158] signalConditions() ...
[16:05:07.158]  - include = ‘immediateCondition’
[16:05:07.158]  - exclude = 
[16:05:07.159]  - resignal = FALSE
[16:05:07.159]  - Number of conditions: 1
[16:05:07.159] signalConditions() ... done
[16:05:07.159] result() for MulticoreFuture ... done
[16:05:07.159] result() for MulticoreFuture ...
[16:05:07.160] result() for MulticoreFuture ... done
[16:05:07.160] signalConditions() ...
[16:05:07.160]  - include = ‘immediateCondition’
[16:05:07.160]  - exclude = 
[16:05:07.160]  - resignal = FALSE
[16:05:07.160]  - Number of conditions: 1
[16:05:07.160] signalConditions() ... done
[16:05:07.161] Future state: ‘finished’
[16:05:07.161] result() for MulticoreFuture ...
[16:05:07.161] result() for MulticoreFuture ... done
[16:05:07.161] signalConditions() ...
[16:05:07.161]  - include = ‘condition’
[16:05:07.161]  - exclude = ‘immediateCondition’
[16:05:07.161]  - resignal = TRUE
[16:05:07.162]  - Number of conditions: 1
[16:05:07.162]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:05:07.162] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 45
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language local({     value <- value(future) ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "11666ca4073c" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:05:07"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.192] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.192] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:07.193] 
[16:05:07.193] Searching for globals ... DONE
[16:05:07.193] - globals: [0] <none>
[16:05:07.193] getGlobalsAndPackages() ... DONE
[16:05:07.194] run() for ‘Future’ ...
[16:05:07.194] - state: ‘created’
[16:05:07.194] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:07.200] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:07.200] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:07.200]   - Field: ‘label’
[16:05:07.200]   - Field: ‘local’
[16:05:07.200]   - Field: ‘owner’
[16:05:07.200]   - Field: ‘envir’
[16:05:07.201]   - Field: ‘workers’
[16:05:07.201]   - Field: ‘packages’
[16:05:07.201]   - Field: ‘gc’
[16:05:07.201]   - Field: ‘job’
[16:05:07.201]   - Field: ‘conditions’
[16:05:07.201]   - Field: ‘expr’
[16:05:07.201]   - Field: ‘uuid’
[16:05:07.201]   - Field: ‘seed’
[16:05:07.201]   - Field: ‘version’
[16:05:07.202]   - Field: ‘result’
[16:05:07.202]   - Field: ‘asynchronous’
[16:05:07.202]   - Field: ‘calls’
[16:05:07.202]   - Field: ‘globals’
[16:05:07.202]   - Field: ‘stdout’
[16:05:07.202]   - Field: ‘earlySignal’
[16:05:07.202]   - Field: ‘lazy’
[16:05:07.202]   - Field: ‘state’
[16:05:07.202] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:07.202] - Launch lazy future ...
[16:05:07.203] Packages needed by the future expression (n = 0): <none>
[16:05:07.203] Packages needed by future strategies (n = 0): <none>
[16:05:07.203] {
[16:05:07.203]     {
[16:05:07.203]         {
[16:05:07.203]             ...future.startTime <- base::Sys.time()
[16:05:07.203]             {
[16:05:07.203]                 {
[16:05:07.203]                   {
[16:05:07.203]                     {
[16:05:07.203]                       base::local({
[16:05:07.203]                         has_future <- base::requireNamespace("future", 
[16:05:07.203]                           quietly = TRUE)
[16:05:07.203]                         if (has_future) {
[16:05:07.203]                           ns <- base::getNamespace("future")
[16:05:07.203]                           version <- ns[[".package"]][["version"]]
[16:05:07.203]                           if (is.null(version)) 
[16:05:07.203]                             version <- utils::packageVersion("future")
[16:05:07.203]                         }
[16:05:07.203]                         else {
[16:05:07.203]                           version <- NULL
[16:05:07.203]                         }
[16:05:07.203]                         if (!has_future || version < "1.8.0") {
[16:05:07.203]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:07.203]                             "", base::R.version$version.string), 
[16:05:07.203]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:07.203]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:07.203]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:07.203]                               "release", "version")], collapse = " "), 
[16:05:07.203]                             hostname = base::Sys.info()[["nodename"]])
[16:05:07.203]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:07.203]                             info)
[16:05:07.203]                           info <- base::paste(info, collapse = "; ")
[16:05:07.203]                           if (!has_future) {
[16:05:07.203]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:07.203]                               info)
[16:05:07.203]                           }
[16:05:07.203]                           else {
[16:05:07.203]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:07.203]                               info, version)
[16:05:07.203]                           }
[16:05:07.203]                           base::stop(msg)
[16:05:07.203]                         }
[16:05:07.203]                       })
[16:05:07.203]                     }
[16:05:07.203]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:07.203]                     base::options(mc.cores = 1L)
[16:05:07.203]                   }
[16:05:07.203]                   options(future.plan = NULL)
[16:05:07.203]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.203]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:07.203]                 }
[16:05:07.203]                 ...future.workdir <- getwd()
[16:05:07.203]             }
[16:05:07.203]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:07.203]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:07.203]         }
[16:05:07.203]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:07.203]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:07.203]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:07.203]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:07.203]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:07.203]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:07.203]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:07.203]             base::names(...future.oldOptions))
[16:05:07.203]     }
[16:05:07.203]     if (FALSE) {
[16:05:07.203]     }
[16:05:07.203]     else {
[16:05:07.203]         if (TRUE) {
[16:05:07.203]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:07.203]                 open = "w")
[16:05:07.203]         }
[16:05:07.203]         else {
[16:05:07.203]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:07.203]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:07.203]         }
[16:05:07.203]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:07.203]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:07.203]             base::sink(type = "output", split = FALSE)
[16:05:07.203]             base::close(...future.stdout)
[16:05:07.203]         }, add = TRUE)
[16:05:07.203]     }
[16:05:07.203]     ...future.frame <- base::sys.nframe()
[16:05:07.203]     ...future.conditions <- base::list()
[16:05:07.203]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:07.203]     if (FALSE) {
[16:05:07.203]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:07.203]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:07.203]     }
[16:05:07.203]     ...future.result <- base::tryCatch({
[16:05:07.203]         base::withCallingHandlers({
[16:05:07.203]             ...future.value <- base::withVisible(base::local({
[16:05:07.203]                 withCallingHandlers({
[16:05:07.203]                   1
[16:05:07.203]                 }, immediateCondition = function(cond) {
[16:05:07.203]                   save_rds <- function (object, pathname, ...) 
[16:05:07.203]                   {
[16:05:07.203]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:07.203]                     if (file_test("-f", pathname_tmp)) {
[16:05:07.203]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.203]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:07.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.203]                         fi_tmp[["mtime"]])
[16:05:07.203]                     }
[16:05:07.203]                     tryCatch({
[16:05:07.203]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:07.203]                     }, error = function(ex) {
[16:05:07.203]                       msg <- conditionMessage(ex)
[16:05:07.203]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.203]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:07.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.203]                         fi_tmp[["mtime"]], msg)
[16:05:07.203]                       ex$message <- msg
[16:05:07.203]                       stop(ex)
[16:05:07.203]                     })
[16:05:07.203]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:07.203]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:07.203]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:07.203]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.203]                       fi <- file.info(pathname)
[16:05:07.203]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:07.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.203]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:07.203]                         fi[["size"]], fi[["mtime"]])
[16:05:07.203]                       stop(msg)
[16:05:07.203]                     }
[16:05:07.203]                     invisible(pathname)
[16:05:07.203]                   }
[16:05:07.203]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:07.203]                     rootPath = tempdir()) 
[16:05:07.203]                   {
[16:05:07.203]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:07.203]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:07.203]                       tmpdir = path, fileext = ".rds")
[16:05:07.203]                     save_rds(obj, file)
[16:05:07.203]                   }
[16:05:07.203]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:07.203]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.203]                   {
[16:05:07.203]                     inherits <- base::inherits
[16:05:07.203]                     invokeRestart <- base::invokeRestart
[16:05:07.203]                     is.null <- base::is.null
[16:05:07.203]                     muffled <- FALSE
[16:05:07.203]                     if (inherits(cond, "message")) {
[16:05:07.203]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:07.203]                       if (muffled) 
[16:05:07.203]                         invokeRestart("muffleMessage")
[16:05:07.203]                     }
[16:05:07.203]                     else if (inherits(cond, "warning")) {
[16:05:07.203]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:07.203]                       if (muffled) 
[16:05:07.203]                         invokeRestart("muffleWarning")
[16:05:07.203]                     }
[16:05:07.203]                     else if (inherits(cond, "condition")) {
[16:05:07.203]                       if (!is.null(pattern)) {
[16:05:07.203]                         computeRestarts <- base::computeRestarts
[16:05:07.203]                         grepl <- base::grepl
[16:05:07.203]                         restarts <- computeRestarts(cond)
[16:05:07.203]                         for (restart in restarts) {
[16:05:07.203]                           name <- restart$name
[16:05:07.203]                           if (is.null(name)) 
[16:05:07.203]                             next
[16:05:07.203]                           if (!grepl(pattern, name)) 
[16:05:07.203]                             next
[16:05:07.203]                           invokeRestart(restart)
[16:05:07.203]                           muffled <- TRUE
[16:05:07.203]                           break
[16:05:07.203]                         }
[16:05:07.203]                       }
[16:05:07.203]                     }
[16:05:07.203]                     invisible(muffled)
[16:05:07.203]                   }
[16:05:07.203]                   muffleCondition(cond)
[16:05:07.203]                 })
[16:05:07.203]             }))
[16:05:07.203]             future::FutureResult(value = ...future.value$value, 
[16:05:07.203]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.203]                   ...future.rng), globalenv = if (FALSE) 
[16:05:07.203]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:07.203]                     ...future.globalenv.names))
[16:05:07.203]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:07.203]         }, condition = base::local({
[16:05:07.203]             c <- base::c
[16:05:07.203]             inherits <- base::inherits
[16:05:07.203]             invokeRestart <- base::invokeRestart
[16:05:07.203]             length <- base::length
[16:05:07.203]             list <- base::list
[16:05:07.203]             seq.int <- base::seq.int
[16:05:07.203]             signalCondition <- base::signalCondition
[16:05:07.203]             sys.calls <- base::sys.calls
[16:05:07.203]             `[[` <- base::`[[`
[16:05:07.203]             `+` <- base::`+`
[16:05:07.203]             `<<-` <- base::`<<-`
[16:05:07.203]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:07.203]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:07.203]                   3L)]
[16:05:07.203]             }
[16:05:07.203]             function(cond) {
[16:05:07.203]                 is_error <- inherits(cond, "error")
[16:05:07.203]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:07.203]                   NULL)
[16:05:07.203]                 if (is_error) {
[16:05:07.203]                   sessionInformation <- function() {
[16:05:07.203]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:07.203]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:07.203]                       search = base::search(), system = base::Sys.info())
[16:05:07.203]                   }
[16:05:07.203]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.203]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:07.203]                     cond$call), session = sessionInformation(), 
[16:05:07.203]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:07.203]                   signalCondition(cond)
[16:05:07.203]                 }
[16:05:07.203]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:07.203]                 "immediateCondition"))) {
[16:05:07.203]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:07.203]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.203]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:07.203]                   if (TRUE && !signal) {
[16:05:07.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.203]                     {
[16:05:07.203]                       inherits <- base::inherits
[16:05:07.203]                       invokeRestart <- base::invokeRestart
[16:05:07.203]                       is.null <- base::is.null
[16:05:07.203]                       muffled <- FALSE
[16:05:07.203]                       if (inherits(cond, "message")) {
[16:05:07.203]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.203]                         if (muffled) 
[16:05:07.203]                           invokeRestart("muffleMessage")
[16:05:07.203]                       }
[16:05:07.203]                       else if (inherits(cond, "warning")) {
[16:05:07.203]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.203]                         if (muffled) 
[16:05:07.203]                           invokeRestart("muffleWarning")
[16:05:07.203]                       }
[16:05:07.203]                       else if (inherits(cond, "condition")) {
[16:05:07.203]                         if (!is.null(pattern)) {
[16:05:07.203]                           computeRestarts <- base::computeRestarts
[16:05:07.203]                           grepl <- base::grepl
[16:05:07.203]                           restarts <- computeRestarts(cond)
[16:05:07.203]                           for (restart in restarts) {
[16:05:07.203]                             name <- restart$name
[16:05:07.203]                             if (is.null(name)) 
[16:05:07.203]                               next
[16:05:07.203]                             if (!grepl(pattern, name)) 
[16:05:07.203]                               next
[16:05:07.203]                             invokeRestart(restart)
[16:05:07.203]                             muffled <- TRUE
[16:05:07.203]                             break
[16:05:07.203]                           }
[16:05:07.203]                         }
[16:05:07.203]                       }
[16:05:07.203]                       invisible(muffled)
[16:05:07.203]                     }
[16:05:07.203]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.203]                   }
[16:05:07.203]                 }
[16:05:07.203]                 else {
[16:05:07.203]                   if (TRUE) {
[16:05:07.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.203]                     {
[16:05:07.203]                       inherits <- base::inherits
[16:05:07.203]                       invokeRestart <- base::invokeRestart
[16:05:07.203]                       is.null <- base::is.null
[16:05:07.203]                       muffled <- FALSE
[16:05:07.203]                       if (inherits(cond, "message")) {
[16:05:07.203]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.203]                         if (muffled) 
[16:05:07.203]                           invokeRestart("muffleMessage")
[16:05:07.203]                       }
[16:05:07.203]                       else if (inherits(cond, "warning")) {
[16:05:07.203]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.203]                         if (muffled) 
[16:05:07.203]                           invokeRestart("muffleWarning")
[16:05:07.203]                       }
[16:05:07.203]                       else if (inherits(cond, "condition")) {
[16:05:07.203]                         if (!is.null(pattern)) {
[16:05:07.203]                           computeRestarts <- base::computeRestarts
[16:05:07.203]                           grepl <- base::grepl
[16:05:07.203]                           restarts <- computeRestarts(cond)
[16:05:07.203]                           for (restart in restarts) {
[16:05:07.203]                             name <- restart$name
[16:05:07.203]                             if (is.null(name)) 
[16:05:07.203]                               next
[16:05:07.203]                             if (!grepl(pattern, name)) 
[16:05:07.203]                               next
[16:05:07.203]                             invokeRestart(restart)
[16:05:07.203]                             muffled <- TRUE
[16:05:07.203]                             break
[16:05:07.203]                           }
[16:05:07.203]                         }
[16:05:07.203]                       }
[16:05:07.203]                       invisible(muffled)
[16:05:07.203]                     }
[16:05:07.203]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.203]                   }
[16:05:07.203]                 }
[16:05:07.203]             }
[16:05:07.203]         }))
[16:05:07.203]     }, error = function(ex) {
[16:05:07.203]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:07.203]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.203]                 ...future.rng), started = ...future.startTime, 
[16:05:07.203]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:07.203]             version = "1.8"), class = "FutureResult")
[16:05:07.203]     }, finally = {
[16:05:07.203]         if (!identical(...future.workdir, getwd())) 
[16:05:07.203]             setwd(...future.workdir)
[16:05:07.203]         {
[16:05:07.203]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:07.203]                 ...future.oldOptions$nwarnings <- NULL
[16:05:07.203]             }
[16:05:07.203]             base::options(...future.oldOptions)
[16:05:07.203]             if (.Platform$OS.type == "windows") {
[16:05:07.203]                 old_names <- names(...future.oldEnvVars)
[16:05:07.203]                 envs <- base::Sys.getenv()
[16:05:07.203]                 names <- names(envs)
[16:05:07.203]                 common <- intersect(names, old_names)
[16:05:07.203]                 added <- setdiff(names, old_names)
[16:05:07.203]                 removed <- setdiff(old_names, names)
[16:05:07.203]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:07.203]                   envs[common]]
[16:05:07.203]                 NAMES <- toupper(changed)
[16:05:07.203]                 args <- list()
[16:05:07.203]                 for (kk in seq_along(NAMES)) {
[16:05:07.203]                   name <- changed[[kk]]
[16:05:07.203]                   NAME <- NAMES[[kk]]
[16:05:07.203]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.203]                     next
[16:05:07.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.203]                 }
[16:05:07.203]                 NAMES <- toupper(added)
[16:05:07.203]                 for (kk in seq_along(NAMES)) {
[16:05:07.203]                   name <- added[[kk]]
[16:05:07.203]                   NAME <- NAMES[[kk]]
[16:05:07.203]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.203]                     next
[16:05:07.203]                   args[[name]] <- ""
[16:05:07.203]                 }
[16:05:07.203]                 NAMES <- toupper(removed)
[16:05:07.203]                 for (kk in seq_along(NAMES)) {
[16:05:07.203]                   name <- removed[[kk]]
[16:05:07.203]                   NAME <- NAMES[[kk]]
[16:05:07.203]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.203]                     next
[16:05:07.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.203]                 }
[16:05:07.203]                 if (length(args) > 0) 
[16:05:07.203]                   base::do.call(base::Sys.setenv, args = args)
[16:05:07.203]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:07.203]             }
[16:05:07.203]             else {
[16:05:07.203]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:07.203]             }
[16:05:07.203]             {
[16:05:07.203]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:07.203]                   0L) {
[16:05:07.203]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:07.203]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:07.203]                   base::options(opts)
[16:05:07.203]                 }
[16:05:07.203]                 {
[16:05:07.203]                   {
[16:05:07.203]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:07.203]                     NULL
[16:05:07.203]                   }
[16:05:07.203]                   options(future.plan = NULL)
[16:05:07.203]                   if (is.na(NA_character_)) 
[16:05:07.203]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.203]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:07.203]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:07.203]                     envir = parent.frame()) 
[16:05:07.203]                   {
[16:05:07.203]                     default_workers <- missing(workers)
[16:05:07.203]                     if (is.function(workers)) 
[16:05:07.203]                       workers <- workers()
[16:05:07.203]                     workers <- structure(as.integer(workers), 
[16:05:07.203]                       class = class(workers))
[16:05:07.203]                     stop_if_not(is.finite(workers), workers >= 
[16:05:07.203]                       1L)
[16:05:07.203]                     if ((workers == 1L && !inherits(workers, 
[16:05:07.203]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:07.203]                       if (default_workers) 
[16:05:07.203]                         supportsMulticore(warn = TRUE)
[16:05:07.203]                       return(sequential(..., envir = envir))
[16:05:07.203]                     }
[16:05:07.203]                     oopts <- options(mc.cores = workers)
[16:05:07.203]                     on.exit(options(oopts))
[16:05:07.203]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:07.203]                       envir = envir)
[16:05:07.203]                     if (!future$lazy) 
[16:05:07.203]                       future <- run(future)
[16:05:07.203]                     invisible(future)
[16:05:07.203]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:07.203]                 }
[16:05:07.203]             }
[16:05:07.203]         }
[16:05:07.203]     })
[16:05:07.203]     if (TRUE) {
[16:05:07.203]         base::sink(type = "output", split = FALSE)
[16:05:07.203]         if (TRUE) {
[16:05:07.203]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:07.203]         }
[16:05:07.203]         else {
[16:05:07.203]             ...future.result["stdout"] <- base::list(NULL)
[16:05:07.203]         }
[16:05:07.203]         base::close(...future.stdout)
[16:05:07.203]         ...future.stdout <- NULL
[16:05:07.203]     }
[16:05:07.203]     ...future.result$conditions <- ...future.conditions
[16:05:07.203]     ...future.result$finished <- base::Sys.time()
[16:05:07.203]     ...future.result
[16:05:07.203] }
[16:05:07.206] requestCore(): workers = 2
[16:05:07.208] MulticoreFuture started
[16:05:07.208] - Launch lazy future ... done
[16:05:07.209] run() for ‘MulticoreFuture’ ... done
[16:05:07.209] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.209] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.210] Searching for globals...
[16:05:07.209] List of future strategies:
[16:05:07.209] 1. sequential:
[16:05:07.209]    - args: function (..., envir = parent.frame())
[16:05:07.209]    - tweaked: FALSE
[16:05:07.209]    - call: NULL
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:07.210] plan(): nbrOfWorkers() = 1
[16:05:07.212] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:07.212] Searching for globals ... DONE
[16:05:07.212] plan(): Setting new future strategy stack:
[16:05:07.212] Resolving globals: TRUE
[16:05:07.213] Resolving any globals that are futures ...
[16:05:07.213] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:07.212] List of future strategies:
[16:05:07.212] 1. multicore:
[16:05:07.212]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.212]    - tweaked: FALSE
[16:05:07.212]    - call: plan(strategy)
[16:05:07.213] Resolving any globals that are futures ... DONE
[16:05:07.214] Resolving futures part of globals (recursively) ...
[16:05:07.214] resolve() on list ...
[16:05:07.214]  recursive: 99
[16:05:07.214]  length: 1
[16:05:07.215]  elements: ‘a’
[16:05:07.217] plan(): nbrOfWorkers() = 2
[16:05:07.218] Future #1
[16:05:07.218] result() for MulticoreFuture ...
[16:05:07.219] result() for MulticoreFuture ...
[16:05:07.219] result() for MulticoreFuture ... done
[16:05:07.220] result() for MulticoreFuture ... done
[16:05:07.220] result() for MulticoreFuture ...
[16:05:07.220] result() for MulticoreFuture ... done
[16:05:07.220] A MulticoreFuture was resolved
[16:05:07.220]  length: 0 (resolved future 1)
[16:05:07.221] resolve() on list ... DONE
[16:05:07.221] - globals: [1] ‘a’
[16:05:07.221] Resolving futures part of globals (recursively) ... DONE
[16:05:07.222] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[16:05:07.223] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[16:05:07.223] - globals: [1] ‘a’
[16:05:07.223] - packages: [1] ‘future’
[16:05:07.224] getGlobalsAndPackages() ... DONE
[16:05:07.224] run() for ‘Future’ ...
[16:05:07.224] - state: ‘created’
[16:05:07.224] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:07.228] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:07.228] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:07.228]   - Field: ‘label’
[16:05:07.228]   - Field: ‘local’
[16:05:07.229]   - Field: ‘owner’
[16:05:07.229]   - Field: ‘envir’
[16:05:07.229]   - Field: ‘workers’
[16:05:07.229]   - Field: ‘packages’
[16:05:07.229]   - Field: ‘gc’
[16:05:07.229]   - Field: ‘job’
[16:05:07.229]   - Field: ‘conditions’
[16:05:07.229]   - Field: ‘expr’
[16:05:07.230]   - Field: ‘uuid’
[16:05:07.230]   - Field: ‘seed’
[16:05:07.230]   - Field: ‘version’
[16:05:07.230]   - Field: ‘result’
[16:05:07.230]   - Field: ‘asynchronous’
[16:05:07.230]   - Field: ‘calls’
[16:05:07.230]   - Field: ‘globals’
[16:05:07.230]   - Field: ‘stdout’
[16:05:07.230]   - Field: ‘earlySignal’
[16:05:07.231]   - Field: ‘lazy’
[16:05:07.231]   - Field: ‘state’
[16:05:07.231] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:07.231] - Launch lazy future ...
[16:05:07.231] Packages needed by the future expression (n = 1): ‘future’
[16:05:07.231] Packages needed by future strategies (n = 0): <none>
[16:05:07.232] {
[16:05:07.232]     {
[16:05:07.232]         {
[16:05:07.232]             ...future.startTime <- base::Sys.time()
[16:05:07.232]             {
[16:05:07.232]                 {
[16:05:07.232]                   {
[16:05:07.232]                     {
[16:05:07.232]                       {
[16:05:07.232]                         base::local({
[16:05:07.232]                           has_future <- base::requireNamespace("future", 
[16:05:07.232]                             quietly = TRUE)
[16:05:07.232]                           if (has_future) {
[16:05:07.232]                             ns <- base::getNamespace("future")
[16:05:07.232]                             version <- ns[[".package"]][["version"]]
[16:05:07.232]                             if (is.null(version)) 
[16:05:07.232]                               version <- utils::packageVersion("future")
[16:05:07.232]                           }
[16:05:07.232]                           else {
[16:05:07.232]                             version <- NULL
[16:05:07.232]                           }
[16:05:07.232]                           if (!has_future || version < "1.8.0") {
[16:05:07.232]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:07.232]                               "", base::R.version$version.string), 
[16:05:07.232]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:07.232]                                 base::R.version$platform, 8 * 
[16:05:07.232]                                   base::.Machine$sizeof.pointer), 
[16:05:07.232]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:07.232]                                 "release", "version")], collapse = " "), 
[16:05:07.232]                               hostname = base::Sys.info()[["nodename"]])
[16:05:07.232]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:07.232]                               info)
[16:05:07.232]                             info <- base::paste(info, collapse = "; ")
[16:05:07.232]                             if (!has_future) {
[16:05:07.232]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:07.232]                                 info)
[16:05:07.232]                             }
[16:05:07.232]                             else {
[16:05:07.232]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:07.232]                                 info, version)
[16:05:07.232]                             }
[16:05:07.232]                             base::stop(msg)
[16:05:07.232]                           }
[16:05:07.232]                         })
[16:05:07.232]                       }
[16:05:07.232]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:07.232]                       base::options(mc.cores = 1L)
[16:05:07.232]                     }
[16:05:07.232]                     base::local({
[16:05:07.232]                       for (pkg in "future") {
[16:05:07.232]                         base::loadNamespace(pkg)
[16:05:07.232]                         base::library(pkg, character.only = TRUE)
[16:05:07.232]                       }
[16:05:07.232]                     })
[16:05:07.232]                   }
[16:05:07.232]                   options(future.plan = NULL)
[16:05:07.232]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.232]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:07.232]                 }
[16:05:07.232]                 ...future.workdir <- getwd()
[16:05:07.232]             }
[16:05:07.232]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:07.232]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:07.232]         }
[16:05:07.232]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:07.232]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:07.232]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:07.232]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:07.232]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:07.232]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:07.232]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:07.232]             base::names(...future.oldOptions))
[16:05:07.232]     }
[16:05:07.232]     if (FALSE) {
[16:05:07.232]     }
[16:05:07.232]     else {
[16:05:07.232]         if (TRUE) {
[16:05:07.232]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:07.232]                 open = "w")
[16:05:07.232]         }
[16:05:07.232]         else {
[16:05:07.232]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:07.232]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:07.232]         }
[16:05:07.232]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:07.232]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:07.232]             base::sink(type = "output", split = FALSE)
[16:05:07.232]             base::close(...future.stdout)
[16:05:07.232]         }, add = TRUE)
[16:05:07.232]     }
[16:05:07.232]     ...future.frame <- base::sys.nframe()
[16:05:07.232]     ...future.conditions <- base::list()
[16:05:07.232]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:07.232]     if (FALSE) {
[16:05:07.232]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:07.232]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:07.232]     }
[16:05:07.232]     ...future.result <- base::tryCatch({
[16:05:07.232]         base::withCallingHandlers({
[16:05:07.232]             ...future.value <- base::withVisible(base::local({
[16:05:07.232]                 withCallingHandlers({
[16:05:07.232]                   value(a) + 1
[16:05:07.232]                 }, immediateCondition = function(cond) {
[16:05:07.232]                   save_rds <- function (object, pathname, ...) 
[16:05:07.232]                   {
[16:05:07.232]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:07.232]                     if (file_test("-f", pathname_tmp)) {
[16:05:07.232]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.232]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:07.232]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.232]                         fi_tmp[["mtime"]])
[16:05:07.232]                     }
[16:05:07.232]                     tryCatch({
[16:05:07.232]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:07.232]                     }, error = function(ex) {
[16:05:07.232]                       msg <- conditionMessage(ex)
[16:05:07.232]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.232]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:07.232]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.232]                         fi_tmp[["mtime"]], msg)
[16:05:07.232]                       ex$message <- msg
[16:05:07.232]                       stop(ex)
[16:05:07.232]                     })
[16:05:07.232]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:07.232]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:07.232]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:07.232]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.232]                       fi <- file.info(pathname)
[16:05:07.232]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:07.232]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.232]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:07.232]                         fi[["size"]], fi[["mtime"]])
[16:05:07.232]                       stop(msg)
[16:05:07.232]                     }
[16:05:07.232]                     invisible(pathname)
[16:05:07.232]                   }
[16:05:07.232]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:07.232]                     rootPath = tempdir()) 
[16:05:07.232]                   {
[16:05:07.232]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:07.232]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:07.232]                       tmpdir = path, fileext = ".rds")
[16:05:07.232]                     save_rds(obj, file)
[16:05:07.232]                   }
[16:05:07.232]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:07.232]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.232]                   {
[16:05:07.232]                     inherits <- base::inherits
[16:05:07.232]                     invokeRestart <- base::invokeRestart
[16:05:07.232]                     is.null <- base::is.null
[16:05:07.232]                     muffled <- FALSE
[16:05:07.232]                     if (inherits(cond, "message")) {
[16:05:07.232]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:07.232]                       if (muffled) 
[16:05:07.232]                         invokeRestart("muffleMessage")
[16:05:07.232]                     }
[16:05:07.232]                     else if (inherits(cond, "warning")) {
[16:05:07.232]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:07.232]                       if (muffled) 
[16:05:07.232]                         invokeRestart("muffleWarning")
[16:05:07.232]                     }
[16:05:07.232]                     else if (inherits(cond, "condition")) {
[16:05:07.232]                       if (!is.null(pattern)) {
[16:05:07.232]                         computeRestarts <- base::computeRestarts
[16:05:07.232]                         grepl <- base::grepl
[16:05:07.232]                         restarts <- computeRestarts(cond)
[16:05:07.232]                         for (restart in restarts) {
[16:05:07.232]                           name <- restart$name
[16:05:07.232]                           if (is.null(name)) 
[16:05:07.232]                             next
[16:05:07.232]                           if (!grepl(pattern, name)) 
[16:05:07.232]                             next
[16:05:07.232]                           invokeRestart(restart)
[16:05:07.232]                           muffled <- TRUE
[16:05:07.232]                           break
[16:05:07.232]                         }
[16:05:07.232]                       }
[16:05:07.232]                     }
[16:05:07.232]                     invisible(muffled)
[16:05:07.232]                   }
[16:05:07.232]                   muffleCondition(cond)
[16:05:07.232]                 })
[16:05:07.232]             }))
[16:05:07.232]             future::FutureResult(value = ...future.value$value, 
[16:05:07.232]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.232]                   ...future.rng), globalenv = if (FALSE) 
[16:05:07.232]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:07.232]                     ...future.globalenv.names))
[16:05:07.232]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:07.232]         }, condition = base::local({
[16:05:07.232]             c <- base::c
[16:05:07.232]             inherits <- base::inherits
[16:05:07.232]             invokeRestart <- base::invokeRestart
[16:05:07.232]             length <- base::length
[16:05:07.232]             list <- base::list
[16:05:07.232]             seq.int <- base::seq.int
[16:05:07.232]             signalCondition <- base::signalCondition
[16:05:07.232]             sys.calls <- base::sys.calls
[16:05:07.232]             `[[` <- base::`[[`
[16:05:07.232]             `+` <- base::`+`
[16:05:07.232]             `<<-` <- base::`<<-`
[16:05:07.232]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:07.232]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:07.232]                   3L)]
[16:05:07.232]             }
[16:05:07.232]             function(cond) {
[16:05:07.232]                 is_error <- inherits(cond, "error")
[16:05:07.232]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:07.232]                   NULL)
[16:05:07.232]                 if (is_error) {
[16:05:07.232]                   sessionInformation <- function() {
[16:05:07.232]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:07.232]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:07.232]                       search = base::search(), system = base::Sys.info())
[16:05:07.232]                   }
[16:05:07.232]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.232]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:07.232]                     cond$call), session = sessionInformation(), 
[16:05:07.232]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:07.232]                   signalCondition(cond)
[16:05:07.232]                 }
[16:05:07.232]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:07.232]                 "immediateCondition"))) {
[16:05:07.232]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:07.232]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.232]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:07.232]                   if (TRUE && !signal) {
[16:05:07.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.232]                     {
[16:05:07.232]                       inherits <- base::inherits
[16:05:07.232]                       invokeRestart <- base::invokeRestart
[16:05:07.232]                       is.null <- base::is.null
[16:05:07.232]                       muffled <- FALSE
[16:05:07.232]                       if (inherits(cond, "message")) {
[16:05:07.232]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.232]                         if (muffled) 
[16:05:07.232]                           invokeRestart("muffleMessage")
[16:05:07.232]                       }
[16:05:07.232]                       else if (inherits(cond, "warning")) {
[16:05:07.232]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.232]                         if (muffled) 
[16:05:07.232]                           invokeRestart("muffleWarning")
[16:05:07.232]                       }
[16:05:07.232]                       else if (inherits(cond, "condition")) {
[16:05:07.232]                         if (!is.null(pattern)) {
[16:05:07.232]                           computeRestarts <- base::computeRestarts
[16:05:07.232]                           grepl <- base::grepl
[16:05:07.232]                           restarts <- computeRestarts(cond)
[16:05:07.232]                           for (restart in restarts) {
[16:05:07.232]                             name <- restart$name
[16:05:07.232]                             if (is.null(name)) 
[16:05:07.232]                               next
[16:05:07.232]                             if (!grepl(pattern, name)) 
[16:05:07.232]                               next
[16:05:07.232]                             invokeRestart(restart)
[16:05:07.232]                             muffled <- TRUE
[16:05:07.232]                             break
[16:05:07.232]                           }
[16:05:07.232]                         }
[16:05:07.232]                       }
[16:05:07.232]                       invisible(muffled)
[16:05:07.232]                     }
[16:05:07.232]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.232]                   }
[16:05:07.232]                 }
[16:05:07.232]                 else {
[16:05:07.232]                   if (TRUE) {
[16:05:07.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.232]                     {
[16:05:07.232]                       inherits <- base::inherits
[16:05:07.232]                       invokeRestart <- base::invokeRestart
[16:05:07.232]                       is.null <- base::is.null
[16:05:07.232]                       muffled <- FALSE
[16:05:07.232]                       if (inherits(cond, "message")) {
[16:05:07.232]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.232]                         if (muffled) 
[16:05:07.232]                           invokeRestart("muffleMessage")
[16:05:07.232]                       }
[16:05:07.232]                       else if (inherits(cond, "warning")) {
[16:05:07.232]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.232]                         if (muffled) 
[16:05:07.232]                           invokeRestart("muffleWarning")
[16:05:07.232]                       }
[16:05:07.232]                       else if (inherits(cond, "condition")) {
[16:05:07.232]                         if (!is.null(pattern)) {
[16:05:07.232]                           computeRestarts <- base::computeRestarts
[16:05:07.232]                           grepl <- base::grepl
[16:05:07.232]                           restarts <- computeRestarts(cond)
[16:05:07.232]                           for (restart in restarts) {
[16:05:07.232]                             name <- restart$name
[16:05:07.232]                             if (is.null(name)) 
[16:05:07.232]                               next
[16:05:07.232]                             if (!grepl(pattern, name)) 
[16:05:07.232]                               next
[16:05:07.232]                             invokeRestart(restart)
[16:05:07.232]                             muffled <- TRUE
[16:05:07.232]                             break
[16:05:07.232]                           }
[16:05:07.232]                         }
[16:05:07.232]                       }
[16:05:07.232]                       invisible(muffled)
[16:05:07.232]                     }
[16:05:07.232]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.232]                   }
[16:05:07.232]                 }
[16:05:07.232]             }
[16:05:07.232]         }))
[16:05:07.232]     }, error = function(ex) {
[16:05:07.232]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:07.232]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.232]                 ...future.rng), started = ...future.startTime, 
[16:05:07.232]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:07.232]             version = "1.8"), class = "FutureResult")
[16:05:07.232]     }, finally = {
[16:05:07.232]         if (!identical(...future.workdir, getwd())) 
[16:05:07.232]             setwd(...future.workdir)
[16:05:07.232]         {
[16:05:07.232]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:07.232]                 ...future.oldOptions$nwarnings <- NULL
[16:05:07.232]             }
[16:05:07.232]             base::options(...future.oldOptions)
[16:05:07.232]             if (.Platform$OS.type == "windows") {
[16:05:07.232]                 old_names <- names(...future.oldEnvVars)
[16:05:07.232]                 envs <- base::Sys.getenv()
[16:05:07.232]                 names <- names(envs)
[16:05:07.232]                 common <- intersect(names, old_names)
[16:05:07.232]                 added <- setdiff(names, old_names)
[16:05:07.232]                 removed <- setdiff(old_names, names)
[16:05:07.232]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:07.232]                   envs[common]]
[16:05:07.232]                 NAMES <- toupper(changed)
[16:05:07.232]                 args <- list()
[16:05:07.232]                 for (kk in seq_along(NAMES)) {
[16:05:07.232]                   name <- changed[[kk]]
[16:05:07.232]                   NAME <- NAMES[[kk]]
[16:05:07.232]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.232]                     next
[16:05:07.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.232]                 }
[16:05:07.232]                 NAMES <- toupper(added)
[16:05:07.232]                 for (kk in seq_along(NAMES)) {
[16:05:07.232]                   name <- added[[kk]]
[16:05:07.232]                   NAME <- NAMES[[kk]]
[16:05:07.232]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.232]                     next
[16:05:07.232]                   args[[name]] <- ""
[16:05:07.232]                 }
[16:05:07.232]                 NAMES <- toupper(removed)
[16:05:07.232]                 for (kk in seq_along(NAMES)) {
[16:05:07.232]                   name <- removed[[kk]]
[16:05:07.232]                   NAME <- NAMES[[kk]]
[16:05:07.232]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.232]                     next
[16:05:07.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.232]                 }
[16:05:07.232]                 if (length(args) > 0) 
[16:05:07.232]                   base::do.call(base::Sys.setenv, args = args)
[16:05:07.232]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:07.232]             }
[16:05:07.232]             else {
[16:05:07.232]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:07.232]             }
[16:05:07.232]             {
[16:05:07.232]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:07.232]                   0L) {
[16:05:07.232]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:07.232]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:07.232]                   base::options(opts)
[16:05:07.232]                 }
[16:05:07.232]                 {
[16:05:07.232]                   {
[16:05:07.232]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:07.232]                     NULL
[16:05:07.232]                   }
[16:05:07.232]                   options(future.plan = NULL)
[16:05:07.232]                   if (is.na(NA_character_)) 
[16:05:07.232]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.232]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:07.232]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:07.232]                     envir = parent.frame()) 
[16:05:07.232]                   {
[16:05:07.232]                     default_workers <- missing(workers)
[16:05:07.232]                     if (is.function(workers)) 
[16:05:07.232]                       workers <- workers()
[16:05:07.232]                     workers <- structure(as.integer(workers), 
[16:05:07.232]                       class = class(workers))
[16:05:07.232]                     stop_if_not(is.finite(workers), workers >= 
[16:05:07.232]                       1L)
[16:05:07.232]                     if ((workers == 1L && !inherits(workers, 
[16:05:07.232]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:07.232]                       if (default_workers) 
[16:05:07.232]                         supportsMulticore(warn = TRUE)
[16:05:07.232]                       return(sequential(..., envir = envir))
[16:05:07.232]                     }
[16:05:07.232]                     oopts <- options(mc.cores = workers)
[16:05:07.232]                     on.exit(options(oopts))
[16:05:07.232]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:07.232]                       envir = envir)
[16:05:07.232]                     if (!future$lazy) 
[16:05:07.232]                       future <- run(future)
[16:05:07.232]                     invisible(future)
[16:05:07.232]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:07.232]                 }
[16:05:07.232]             }
[16:05:07.232]         }
[16:05:07.232]     })
[16:05:07.232]     if (TRUE) {
[16:05:07.232]         base::sink(type = "output", split = FALSE)
[16:05:07.232]         if (TRUE) {
[16:05:07.232]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:07.232]         }
[16:05:07.232]         else {
[16:05:07.232]             ...future.result["stdout"] <- base::list(NULL)
[16:05:07.232]         }
[16:05:07.232]         base::close(...future.stdout)
[16:05:07.232]         ...future.stdout <- NULL
[16:05:07.232]     }
[16:05:07.232]     ...future.result$conditions <- ...future.conditions
[16:05:07.232]     ...future.result$finished <- base::Sys.time()
[16:05:07.232]     ...future.result
[16:05:07.232] }
[16:05:07.235] assign_globals() ...
[16:05:07.235] List of 1
[16:05:07.235]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a0569371e8> 
[16:05:07.235]  - attr(*, "where")=List of 1
[16:05:07.235]   ..$ a:<environment: R_EmptyEnv> 
[16:05:07.235]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:07.235]  - attr(*, "resolved")= logi TRUE
[16:05:07.235]  - attr(*, "total_size")= num 10816
[16:05:07.235]  - attr(*, "already-done")= logi TRUE
[16:05:07.241] - copied ‘a’ to environment
[16:05:07.241] assign_globals() ... done
[16:05:07.241] requestCore(): workers = 2
[16:05:07.244] MulticoreFuture started
[16:05:07.244] - Launch lazy future ... done
[16:05:07.245] run() for ‘MulticoreFuture’ ... done
[16:05:07.245] plan(): Setting new future strategy stack:
[16:05:07.245] result() for MulticoreFuture ...
[16:05:07.246] List of future strategies:
[16:05:07.246] 1. sequential:
[16:05:07.246]    - args: function (..., envir = parent.frame())
[16:05:07.246]    - tweaked: FALSE
[16:05:07.246]    - call: NULL
[16:05:07.247] plan(): nbrOfWorkers() = 1
[16:05:07.251] plan(): Setting new future strategy stack:
[16:05:07.251] List of future strategies:
[16:05:07.251] 1. multicore:
[16:05:07.251]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.251]    - tweaked: FALSE
[16:05:07.251]    - call: plan(strategy)
[16:05:07.257] plan(): nbrOfWorkers() = 2
[16:05:07.258] result() for MulticoreFuture ...
[16:05:07.259] result() for MulticoreFuture ... done
[16:05:07.259] signalConditions() ...
[16:05:07.259]  - include = ‘immediateCondition’
[16:05:07.259]  - exclude = 
[16:05:07.259]  - resignal = FALSE
[16:05:07.259]  - Number of conditions: 4
[16:05:07.260] signalConditions() ... done
[16:05:07.260] result() for MulticoreFuture ... done
[16:05:07.260] result() for MulticoreFuture ...
[16:05:07.260] result() for MulticoreFuture ... done
[16:05:07.260] signalConditions() ...
[16:05:07.260]  - include = ‘immediateCondition’
[16:05:07.260]  - exclude = 
[16:05:07.261]  - resignal = FALSE
[16:05:07.261]  - Number of conditions: 4
[16:05:07.261] signalConditions() ... done
[16:05:07.261] Future state: ‘finished’
[16:05:07.261] result() for MulticoreFuture ...
[16:05:07.261] result() for MulticoreFuture ... done
[16:05:07.261] signalConditions() ...
[16:05:07.262]  - include = ‘condition’
[16:05:07.262]  - exclude = ‘immediateCondition’
[16:05:07.262]  - resignal = TRUE
[16:05:07.262]  - Number of conditions: 4
[16:05:07.262]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.249] result() for MulticoreFuture ...
[16:05:07.262]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.249] result() for MulticoreFuture ... done
[16:05:07.263]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.250] result() for MulticoreFuture ...
[16:05:07.263]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.250] result() for MulticoreFuture ... done
[16:05:07.263] signalConditions() ... done
value(b) = 2
[16:05:07.263] result() for MulticoreFuture ...
[16:05:07.263] result() for MulticoreFuture ... done
[16:05:07.263] result() for MulticoreFuture ...
[16:05:07.264] result() for MulticoreFuture ... done
[16:05:07.264] signalConditions() ...
[16:05:07.264]  - include = ‘immediateCondition’
[16:05:07.264]  - exclude = 
[16:05:07.264]  - resignal = FALSE
[16:05:07.264]  - Number of conditions: 4
[16:05:07.264] signalConditions() ... done
[16:05:07.264] Future state: ‘finished’
[16:05:07.265] result() for MulticoreFuture ...
[16:05:07.265] result() for MulticoreFuture ... done
[16:05:07.265] signalConditions() ...
[16:05:07.265]  - include = ‘condition’
[16:05:07.265]  - exclude = ‘immediateCondition’
[16:05:07.265]  - resignal = TRUE
[16:05:07.265]  - Number of conditions: 4
[16:05:07.265]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.249] result() for MulticoreFuture ...
[16:05:07.265]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.249] result() for MulticoreFuture ... done
[16:05:07.266]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.250] result() for MulticoreFuture ...
[16:05:07.266]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.250] result() for MulticoreFuture ... done
[16:05:07.266] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.266] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.266] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:07.267] 
[16:05:07.267] Searching for globals ... DONE
[16:05:07.267] - globals: [0] <none>
[16:05:07.268] getGlobalsAndPackages() ... DONE
[16:05:07.268] run() for ‘Future’ ...
[16:05:07.268] - state: ‘created’
[16:05:07.268] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:07.272] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:07.272] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:07.273]   - Field: ‘label’
[16:05:07.273]   - Field: ‘local’
[16:05:07.273]   - Field: ‘owner’
[16:05:07.273]   - Field: ‘envir’
[16:05:07.273]   - Field: ‘workers’
[16:05:07.273]   - Field: ‘packages’
[16:05:07.273]   - Field: ‘gc’
[16:05:07.273]   - Field: ‘job’
[16:05:07.274]   - Field: ‘conditions’
[16:05:07.274]   - Field: ‘expr’
[16:05:07.274]   - Field: ‘uuid’
[16:05:07.274]   - Field: ‘seed’
[16:05:07.274]   - Field: ‘version’
[16:05:07.274]   - Field: ‘result’
[16:05:07.274]   - Field: ‘asynchronous’
[16:05:07.274]   - Field: ‘calls’
[16:05:07.274]   - Field: ‘globals’
[16:05:07.275]   - Field: ‘stdout’
[16:05:07.275]   - Field: ‘earlySignal’
[16:05:07.275]   - Field: ‘lazy’
[16:05:07.275]   - Field: ‘state’
[16:05:07.275] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:07.275] - Launch lazy future ...
[16:05:07.275] Packages needed by the future expression (n = 0): <none>
[16:05:07.276] Packages needed by future strategies (n = 0): <none>
[16:05:07.276] {
[16:05:07.276]     {
[16:05:07.276]         {
[16:05:07.276]             ...future.startTime <- base::Sys.time()
[16:05:07.276]             {
[16:05:07.276]                 {
[16:05:07.276]                   {
[16:05:07.276]                     {
[16:05:07.276]                       base::local({
[16:05:07.276]                         has_future <- base::requireNamespace("future", 
[16:05:07.276]                           quietly = TRUE)
[16:05:07.276]                         if (has_future) {
[16:05:07.276]                           ns <- base::getNamespace("future")
[16:05:07.276]                           version <- ns[[".package"]][["version"]]
[16:05:07.276]                           if (is.null(version)) 
[16:05:07.276]                             version <- utils::packageVersion("future")
[16:05:07.276]                         }
[16:05:07.276]                         else {
[16:05:07.276]                           version <- NULL
[16:05:07.276]                         }
[16:05:07.276]                         if (!has_future || version < "1.8.0") {
[16:05:07.276]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:07.276]                             "", base::R.version$version.string), 
[16:05:07.276]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:07.276]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:07.276]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:07.276]                               "release", "version")], collapse = " "), 
[16:05:07.276]                             hostname = base::Sys.info()[["nodename"]])
[16:05:07.276]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:07.276]                             info)
[16:05:07.276]                           info <- base::paste(info, collapse = "; ")
[16:05:07.276]                           if (!has_future) {
[16:05:07.276]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:07.276]                               info)
[16:05:07.276]                           }
[16:05:07.276]                           else {
[16:05:07.276]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:07.276]                               info, version)
[16:05:07.276]                           }
[16:05:07.276]                           base::stop(msg)
[16:05:07.276]                         }
[16:05:07.276]                       })
[16:05:07.276]                     }
[16:05:07.276]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:07.276]                     base::options(mc.cores = 1L)
[16:05:07.276]                   }
[16:05:07.276]                   options(future.plan = NULL)
[16:05:07.276]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.276]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:07.276]                 }
[16:05:07.276]                 ...future.workdir <- getwd()
[16:05:07.276]             }
[16:05:07.276]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:07.276]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:07.276]         }
[16:05:07.276]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:07.276]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:07.276]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:07.276]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:07.276]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:07.276]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:07.276]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:07.276]             base::names(...future.oldOptions))
[16:05:07.276]     }
[16:05:07.276]     if (FALSE) {
[16:05:07.276]     }
[16:05:07.276]     else {
[16:05:07.276]         if (TRUE) {
[16:05:07.276]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:07.276]                 open = "w")
[16:05:07.276]         }
[16:05:07.276]         else {
[16:05:07.276]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:07.276]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:07.276]         }
[16:05:07.276]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:07.276]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:07.276]             base::sink(type = "output", split = FALSE)
[16:05:07.276]             base::close(...future.stdout)
[16:05:07.276]         }, add = TRUE)
[16:05:07.276]     }
[16:05:07.276]     ...future.frame <- base::sys.nframe()
[16:05:07.276]     ...future.conditions <- base::list()
[16:05:07.276]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:07.276]     if (FALSE) {
[16:05:07.276]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:07.276]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:07.276]     }
[16:05:07.276]     ...future.result <- base::tryCatch({
[16:05:07.276]         base::withCallingHandlers({
[16:05:07.276]             ...future.value <- base::withVisible(base::local({
[16:05:07.276]                 withCallingHandlers({
[16:05:07.276]                   1
[16:05:07.276]                 }, immediateCondition = function(cond) {
[16:05:07.276]                   save_rds <- function (object, pathname, ...) 
[16:05:07.276]                   {
[16:05:07.276]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:07.276]                     if (file_test("-f", pathname_tmp)) {
[16:05:07.276]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.276]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:07.276]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.276]                         fi_tmp[["mtime"]])
[16:05:07.276]                     }
[16:05:07.276]                     tryCatch({
[16:05:07.276]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:07.276]                     }, error = function(ex) {
[16:05:07.276]                       msg <- conditionMessage(ex)
[16:05:07.276]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.276]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:07.276]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.276]                         fi_tmp[["mtime"]], msg)
[16:05:07.276]                       ex$message <- msg
[16:05:07.276]                       stop(ex)
[16:05:07.276]                     })
[16:05:07.276]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:07.276]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:07.276]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:07.276]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.276]                       fi <- file.info(pathname)
[16:05:07.276]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:07.276]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.276]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:07.276]                         fi[["size"]], fi[["mtime"]])
[16:05:07.276]                       stop(msg)
[16:05:07.276]                     }
[16:05:07.276]                     invisible(pathname)
[16:05:07.276]                   }
[16:05:07.276]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:07.276]                     rootPath = tempdir()) 
[16:05:07.276]                   {
[16:05:07.276]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:07.276]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:07.276]                       tmpdir = path, fileext = ".rds")
[16:05:07.276]                     save_rds(obj, file)
[16:05:07.276]                   }
[16:05:07.276]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:07.276]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.276]                   {
[16:05:07.276]                     inherits <- base::inherits
[16:05:07.276]                     invokeRestart <- base::invokeRestart
[16:05:07.276]                     is.null <- base::is.null
[16:05:07.276]                     muffled <- FALSE
[16:05:07.276]                     if (inherits(cond, "message")) {
[16:05:07.276]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:07.276]                       if (muffled) 
[16:05:07.276]                         invokeRestart("muffleMessage")
[16:05:07.276]                     }
[16:05:07.276]                     else if (inherits(cond, "warning")) {
[16:05:07.276]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:07.276]                       if (muffled) 
[16:05:07.276]                         invokeRestart("muffleWarning")
[16:05:07.276]                     }
[16:05:07.276]                     else if (inherits(cond, "condition")) {
[16:05:07.276]                       if (!is.null(pattern)) {
[16:05:07.276]                         computeRestarts <- base::computeRestarts
[16:05:07.276]                         grepl <- base::grepl
[16:05:07.276]                         restarts <- computeRestarts(cond)
[16:05:07.276]                         for (restart in restarts) {
[16:05:07.276]                           name <- restart$name
[16:05:07.276]                           if (is.null(name)) 
[16:05:07.276]                             next
[16:05:07.276]                           if (!grepl(pattern, name)) 
[16:05:07.276]                             next
[16:05:07.276]                           invokeRestart(restart)
[16:05:07.276]                           muffled <- TRUE
[16:05:07.276]                           break
[16:05:07.276]                         }
[16:05:07.276]                       }
[16:05:07.276]                     }
[16:05:07.276]                     invisible(muffled)
[16:05:07.276]                   }
[16:05:07.276]                   muffleCondition(cond)
[16:05:07.276]                 })
[16:05:07.276]             }))
[16:05:07.276]             future::FutureResult(value = ...future.value$value, 
[16:05:07.276]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.276]                   ...future.rng), globalenv = if (FALSE) 
[16:05:07.276]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:07.276]                     ...future.globalenv.names))
[16:05:07.276]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:07.276]         }, condition = base::local({
[16:05:07.276]             c <- base::c
[16:05:07.276]             inherits <- base::inherits
[16:05:07.276]             invokeRestart <- base::invokeRestart
[16:05:07.276]             length <- base::length
[16:05:07.276]             list <- base::list
[16:05:07.276]             seq.int <- base::seq.int
[16:05:07.276]             signalCondition <- base::signalCondition
[16:05:07.276]             sys.calls <- base::sys.calls
[16:05:07.276]             `[[` <- base::`[[`
[16:05:07.276]             `+` <- base::`+`
[16:05:07.276]             `<<-` <- base::`<<-`
[16:05:07.276]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:07.276]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:07.276]                   3L)]
[16:05:07.276]             }
[16:05:07.276]             function(cond) {
[16:05:07.276]                 is_error <- inherits(cond, "error")
[16:05:07.276]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:07.276]                   NULL)
[16:05:07.276]                 if (is_error) {
[16:05:07.276]                   sessionInformation <- function() {
[16:05:07.276]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:07.276]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:07.276]                       search = base::search(), system = base::Sys.info())
[16:05:07.276]                   }
[16:05:07.276]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.276]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:07.276]                     cond$call), session = sessionInformation(), 
[16:05:07.276]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:07.276]                   signalCondition(cond)
[16:05:07.276]                 }
[16:05:07.276]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:07.276]                 "immediateCondition"))) {
[16:05:07.276]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:07.276]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.276]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:07.276]                   if (TRUE && !signal) {
[16:05:07.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.276]                     {
[16:05:07.276]                       inherits <- base::inherits
[16:05:07.276]                       invokeRestart <- base::invokeRestart
[16:05:07.276]                       is.null <- base::is.null
[16:05:07.276]                       muffled <- FALSE
[16:05:07.276]                       if (inherits(cond, "message")) {
[16:05:07.276]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.276]                         if (muffled) 
[16:05:07.276]                           invokeRestart("muffleMessage")
[16:05:07.276]                       }
[16:05:07.276]                       else if (inherits(cond, "warning")) {
[16:05:07.276]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.276]                         if (muffled) 
[16:05:07.276]                           invokeRestart("muffleWarning")
[16:05:07.276]                       }
[16:05:07.276]                       else if (inherits(cond, "condition")) {
[16:05:07.276]                         if (!is.null(pattern)) {
[16:05:07.276]                           computeRestarts <- base::computeRestarts
[16:05:07.276]                           grepl <- base::grepl
[16:05:07.276]                           restarts <- computeRestarts(cond)
[16:05:07.276]                           for (restart in restarts) {
[16:05:07.276]                             name <- restart$name
[16:05:07.276]                             if (is.null(name)) 
[16:05:07.276]                               next
[16:05:07.276]                             if (!grepl(pattern, name)) 
[16:05:07.276]                               next
[16:05:07.276]                             invokeRestart(restart)
[16:05:07.276]                             muffled <- TRUE
[16:05:07.276]                             break
[16:05:07.276]                           }
[16:05:07.276]                         }
[16:05:07.276]                       }
[16:05:07.276]                       invisible(muffled)
[16:05:07.276]                     }
[16:05:07.276]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.276]                   }
[16:05:07.276]                 }
[16:05:07.276]                 else {
[16:05:07.276]                   if (TRUE) {
[16:05:07.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.276]                     {
[16:05:07.276]                       inherits <- base::inherits
[16:05:07.276]                       invokeRestart <- base::invokeRestart
[16:05:07.276]                       is.null <- base::is.null
[16:05:07.276]                       muffled <- FALSE
[16:05:07.276]                       if (inherits(cond, "message")) {
[16:05:07.276]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.276]                         if (muffled) 
[16:05:07.276]                           invokeRestart("muffleMessage")
[16:05:07.276]                       }
[16:05:07.276]                       else if (inherits(cond, "warning")) {
[16:05:07.276]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.276]                         if (muffled) 
[16:05:07.276]                           invokeRestart("muffleWarning")
[16:05:07.276]                       }
[16:05:07.276]                       else if (inherits(cond, "condition")) {
[16:05:07.276]                         if (!is.null(pattern)) {
[16:05:07.276]                           computeRestarts <- base::computeRestarts
[16:05:07.276]                           grepl <- base::grepl
[16:05:07.276]                           restarts <- computeRestarts(cond)
[16:05:07.276]                           for (restart in restarts) {
[16:05:07.276]                             name <- restart$name
[16:05:07.276]                             if (is.null(name)) 
[16:05:07.276]                               next
[16:05:07.276]                             if (!grepl(pattern, name)) 
[16:05:07.276]                               next
[16:05:07.276]                             invokeRestart(restart)
[16:05:07.276]                             muffled <- TRUE
[16:05:07.276]                             break
[16:05:07.276]                           }
[16:05:07.276]                         }
[16:05:07.276]                       }
[16:05:07.276]                       invisible(muffled)
[16:05:07.276]                     }
[16:05:07.276]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.276]                   }
[16:05:07.276]                 }
[16:05:07.276]             }
[16:05:07.276]         }))
[16:05:07.276]     }, error = function(ex) {
[16:05:07.276]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:07.276]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.276]                 ...future.rng), started = ...future.startTime, 
[16:05:07.276]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:07.276]             version = "1.8"), class = "FutureResult")
[16:05:07.276]     }, finally = {
[16:05:07.276]         if (!identical(...future.workdir, getwd())) 
[16:05:07.276]             setwd(...future.workdir)
[16:05:07.276]         {
[16:05:07.276]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:07.276]                 ...future.oldOptions$nwarnings <- NULL
[16:05:07.276]             }
[16:05:07.276]             base::options(...future.oldOptions)
[16:05:07.276]             if (.Platform$OS.type == "windows") {
[16:05:07.276]                 old_names <- names(...future.oldEnvVars)
[16:05:07.276]                 envs <- base::Sys.getenv()
[16:05:07.276]                 names <- names(envs)
[16:05:07.276]                 common <- intersect(names, old_names)
[16:05:07.276]                 added <- setdiff(names, old_names)
[16:05:07.276]                 removed <- setdiff(old_names, names)
[16:05:07.276]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:07.276]                   envs[common]]
[16:05:07.276]                 NAMES <- toupper(changed)
[16:05:07.276]                 args <- list()
[16:05:07.276]                 for (kk in seq_along(NAMES)) {
[16:05:07.276]                   name <- changed[[kk]]
[16:05:07.276]                   NAME <- NAMES[[kk]]
[16:05:07.276]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.276]                     next
[16:05:07.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.276]                 }
[16:05:07.276]                 NAMES <- toupper(added)
[16:05:07.276]                 for (kk in seq_along(NAMES)) {
[16:05:07.276]                   name <- added[[kk]]
[16:05:07.276]                   NAME <- NAMES[[kk]]
[16:05:07.276]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.276]                     next
[16:05:07.276]                   args[[name]] <- ""
[16:05:07.276]                 }
[16:05:07.276]                 NAMES <- toupper(removed)
[16:05:07.276]                 for (kk in seq_along(NAMES)) {
[16:05:07.276]                   name <- removed[[kk]]
[16:05:07.276]                   NAME <- NAMES[[kk]]
[16:05:07.276]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.276]                     next
[16:05:07.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.276]                 }
[16:05:07.276]                 if (length(args) > 0) 
[16:05:07.276]                   base::do.call(base::Sys.setenv, args = args)
[16:05:07.276]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:07.276]             }
[16:05:07.276]             else {
[16:05:07.276]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:07.276]             }
[16:05:07.276]             {
[16:05:07.276]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:07.276]                   0L) {
[16:05:07.276]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:07.276]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:07.276]                   base::options(opts)
[16:05:07.276]                 }
[16:05:07.276]                 {
[16:05:07.276]                   {
[16:05:07.276]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:07.276]                     NULL
[16:05:07.276]                   }
[16:05:07.276]                   options(future.plan = NULL)
[16:05:07.276]                   if (is.na(NA_character_)) 
[16:05:07.276]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.276]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:07.276]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:07.276]                     envir = parent.frame()) 
[16:05:07.276]                   {
[16:05:07.276]                     default_workers <- missing(workers)
[16:05:07.276]                     if (is.function(workers)) 
[16:05:07.276]                       workers <- workers()
[16:05:07.276]                     workers <- structure(as.integer(workers), 
[16:05:07.276]                       class = class(workers))
[16:05:07.276]                     stop_if_not(is.finite(workers), workers >= 
[16:05:07.276]                       1L)
[16:05:07.276]                     if ((workers == 1L && !inherits(workers, 
[16:05:07.276]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:07.276]                       if (default_workers) 
[16:05:07.276]                         supportsMulticore(warn = TRUE)
[16:05:07.276]                       return(sequential(..., envir = envir))
[16:05:07.276]                     }
[16:05:07.276]                     oopts <- options(mc.cores = workers)
[16:05:07.276]                     on.exit(options(oopts))
[16:05:07.276]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:07.276]                       envir = envir)
[16:05:07.276]                     if (!future$lazy) 
[16:05:07.276]                       future <- run(future)
[16:05:07.276]                     invisible(future)
[16:05:07.276]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:07.276]                 }
[16:05:07.276]             }
[16:05:07.276]         }
[16:05:07.276]     })
[16:05:07.276]     if (TRUE) {
[16:05:07.276]         base::sink(type = "output", split = FALSE)
[16:05:07.276]         if (TRUE) {
[16:05:07.276]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:07.276]         }
[16:05:07.276]         else {
[16:05:07.276]             ...future.result["stdout"] <- base::list(NULL)
[16:05:07.276]         }
[16:05:07.276]         base::close(...future.stdout)
[16:05:07.276]         ...future.stdout <- NULL
[16:05:07.276]     }
[16:05:07.276]     ...future.result$conditions <- ...future.conditions
[16:05:07.276]     ...future.result$finished <- base::Sys.time()
[16:05:07.276]     ...future.result
[16:05:07.276] }
[16:05:07.279] requestCore(): workers = 2
[16:05:07.281] MulticoreFuture started
[16:05:07.282] - Launch lazy future ... done
[16:05:07.282] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.282] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.282] plan(): Setting new future strategy stack:
[16:05:07.283] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:07.283] List of future strategies:
[16:05:07.283] 1. sequential:
[16:05:07.283]    - args: function (..., envir = parent.frame())
[16:05:07.283]    - tweaked: FALSE
[16:05:07.283]    - call: NULL
[16:05:07.284] plan(): nbrOfWorkers() = 1
[16:05:07.285] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:07.285] Searching for globals ... DONE
[16:05:07.285] Resolving globals: TRUE
[16:05:07.285] Resolving any globals that are futures ...
[16:05:07.285] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:07.286] Resolving any globals that are futures ... DONE
[16:05:07.286] plan(): Setting new future strategy stack:
[16:05:07.286] List of future strategies:
[16:05:07.286] 1. multicore:
[16:05:07.286]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.286]    - tweaked: FALSE
[16:05:07.286]    - call: plan(strategy)
[16:05:07.286] Resolving futures part of globals (recursively) ...
[16:05:07.287] resolve() on list ...
[16:05:07.287]  recursive: 99
[16:05:07.287]  length: 1
[16:05:07.287]  elements: ‘a’
[16:05:07.291] plan(): nbrOfWorkers() = 2
[16:05:07.291] Future #1
[16:05:07.291] result() for MulticoreFuture ...
[16:05:07.293] result() for MulticoreFuture ...
[16:05:07.295] result() for MulticoreFuture ... done
[16:05:07.296] result() for MulticoreFuture ... done
[16:05:07.296] result() for MulticoreFuture ...
[16:05:07.296] result() for MulticoreFuture ... done
[16:05:07.296] A MulticoreFuture was resolved
[16:05:07.297]  length: 0 (resolved future 1)
[16:05:07.297] resolve() on list ... DONE
[16:05:07.297] - globals: [1] ‘a’
[16:05:07.297] Resolving futures part of globals (recursively) ... DONE
[16:05:07.299] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[16:05:07.299] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[16:05:07.300] - globals: [1] ‘a’
[16:05:07.300] - packages: [1] ‘future’
[16:05:07.300] getGlobalsAndPackages() ... DONE
[16:05:07.300] run() for ‘Future’ ...
[16:05:07.300] - state: ‘created’
[16:05:07.301] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:07.305] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:07.305] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:07.305]   - Field: ‘label’
[16:05:07.306]   - Field: ‘local’
[16:05:07.306]   - Field: ‘owner’
[16:05:07.306]   - Field: ‘envir’
[16:05:07.306]   - Field: ‘workers’
[16:05:07.306]   - Field: ‘packages’
[16:05:07.306]   - Field: ‘gc’
[16:05:07.306]   - Field: ‘job’
[16:05:07.306]   - Field: ‘conditions’
[16:05:07.306]   - Field: ‘expr’
[16:05:07.307]   - Field: ‘uuid’
[16:05:07.307]   - Field: ‘seed’
[16:05:07.307]   - Field: ‘version’
[16:05:07.307]   - Field: ‘result’
[16:05:07.307]   - Field: ‘asynchronous’
[16:05:07.307]   - Field: ‘calls’
[16:05:07.307]   - Field: ‘globals’
[16:05:07.307]   - Field: ‘stdout’
[16:05:07.308]   - Field: ‘earlySignal’
[16:05:07.308]   - Field: ‘lazy’
[16:05:07.308]   - Field: ‘state’
[16:05:07.308] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:07.308] - Launch lazy future ...
[16:05:07.308] Packages needed by the future expression (n = 1): ‘future’
[16:05:07.308] Packages needed by future strategies (n = 0): <none>
[16:05:07.309] {
[16:05:07.309]     {
[16:05:07.309]         {
[16:05:07.309]             ...future.startTime <- base::Sys.time()
[16:05:07.309]             {
[16:05:07.309]                 {
[16:05:07.309]                   {
[16:05:07.309]                     {
[16:05:07.309]                       {
[16:05:07.309]                         base::local({
[16:05:07.309]                           has_future <- base::requireNamespace("future", 
[16:05:07.309]                             quietly = TRUE)
[16:05:07.309]                           if (has_future) {
[16:05:07.309]                             ns <- base::getNamespace("future")
[16:05:07.309]                             version <- ns[[".package"]][["version"]]
[16:05:07.309]                             if (is.null(version)) 
[16:05:07.309]                               version <- utils::packageVersion("future")
[16:05:07.309]                           }
[16:05:07.309]                           else {
[16:05:07.309]                             version <- NULL
[16:05:07.309]                           }
[16:05:07.309]                           if (!has_future || version < "1.8.0") {
[16:05:07.309]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:07.309]                               "", base::R.version$version.string), 
[16:05:07.309]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:07.309]                                 base::R.version$platform, 8 * 
[16:05:07.309]                                   base::.Machine$sizeof.pointer), 
[16:05:07.309]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:07.309]                                 "release", "version")], collapse = " "), 
[16:05:07.309]                               hostname = base::Sys.info()[["nodename"]])
[16:05:07.309]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:07.309]                               info)
[16:05:07.309]                             info <- base::paste(info, collapse = "; ")
[16:05:07.309]                             if (!has_future) {
[16:05:07.309]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:07.309]                                 info)
[16:05:07.309]                             }
[16:05:07.309]                             else {
[16:05:07.309]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:07.309]                                 info, version)
[16:05:07.309]                             }
[16:05:07.309]                             base::stop(msg)
[16:05:07.309]                           }
[16:05:07.309]                         })
[16:05:07.309]                       }
[16:05:07.309]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:07.309]                       base::options(mc.cores = 1L)
[16:05:07.309]                     }
[16:05:07.309]                     base::local({
[16:05:07.309]                       for (pkg in "future") {
[16:05:07.309]                         base::loadNamespace(pkg)
[16:05:07.309]                         base::library(pkg, character.only = TRUE)
[16:05:07.309]                       }
[16:05:07.309]                     })
[16:05:07.309]                   }
[16:05:07.309]                   options(future.plan = NULL)
[16:05:07.309]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.309]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:07.309]                 }
[16:05:07.309]                 ...future.workdir <- getwd()
[16:05:07.309]             }
[16:05:07.309]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:07.309]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:07.309]         }
[16:05:07.309]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:07.309]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:07.309]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:07.309]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:07.309]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:07.309]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:07.309]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:07.309]             base::names(...future.oldOptions))
[16:05:07.309]     }
[16:05:07.309]     if (FALSE) {
[16:05:07.309]     }
[16:05:07.309]     else {
[16:05:07.309]         if (TRUE) {
[16:05:07.309]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:07.309]                 open = "w")
[16:05:07.309]         }
[16:05:07.309]         else {
[16:05:07.309]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:07.309]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:07.309]         }
[16:05:07.309]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:07.309]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:07.309]             base::sink(type = "output", split = FALSE)
[16:05:07.309]             base::close(...future.stdout)
[16:05:07.309]         }, add = TRUE)
[16:05:07.309]     }
[16:05:07.309]     ...future.frame <- base::sys.nframe()
[16:05:07.309]     ...future.conditions <- base::list()
[16:05:07.309]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:07.309]     if (FALSE) {
[16:05:07.309]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:07.309]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:07.309]     }
[16:05:07.309]     ...future.result <- base::tryCatch({
[16:05:07.309]         base::withCallingHandlers({
[16:05:07.309]             ...future.value <- base::withVisible(base::local({
[16:05:07.309]                 withCallingHandlers({
[16:05:07.309]                   value(a) + 1
[16:05:07.309]                 }, immediateCondition = function(cond) {
[16:05:07.309]                   save_rds <- function (object, pathname, ...) 
[16:05:07.309]                   {
[16:05:07.309]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:07.309]                     if (file_test("-f", pathname_tmp)) {
[16:05:07.309]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.309]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:07.309]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.309]                         fi_tmp[["mtime"]])
[16:05:07.309]                     }
[16:05:07.309]                     tryCatch({
[16:05:07.309]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:07.309]                     }, error = function(ex) {
[16:05:07.309]                       msg <- conditionMessage(ex)
[16:05:07.309]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.309]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:07.309]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.309]                         fi_tmp[["mtime"]], msg)
[16:05:07.309]                       ex$message <- msg
[16:05:07.309]                       stop(ex)
[16:05:07.309]                     })
[16:05:07.309]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:07.309]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:07.309]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:07.309]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.309]                       fi <- file.info(pathname)
[16:05:07.309]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:07.309]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.309]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:07.309]                         fi[["size"]], fi[["mtime"]])
[16:05:07.309]                       stop(msg)
[16:05:07.309]                     }
[16:05:07.309]                     invisible(pathname)
[16:05:07.309]                   }
[16:05:07.309]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:07.309]                     rootPath = tempdir()) 
[16:05:07.309]                   {
[16:05:07.309]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:07.309]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:07.309]                       tmpdir = path, fileext = ".rds")
[16:05:07.309]                     save_rds(obj, file)
[16:05:07.309]                   }
[16:05:07.309]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:07.309]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.309]                   {
[16:05:07.309]                     inherits <- base::inherits
[16:05:07.309]                     invokeRestart <- base::invokeRestart
[16:05:07.309]                     is.null <- base::is.null
[16:05:07.309]                     muffled <- FALSE
[16:05:07.309]                     if (inherits(cond, "message")) {
[16:05:07.309]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:07.309]                       if (muffled) 
[16:05:07.309]                         invokeRestart("muffleMessage")
[16:05:07.309]                     }
[16:05:07.309]                     else if (inherits(cond, "warning")) {
[16:05:07.309]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:07.309]                       if (muffled) 
[16:05:07.309]                         invokeRestart("muffleWarning")
[16:05:07.309]                     }
[16:05:07.309]                     else if (inherits(cond, "condition")) {
[16:05:07.309]                       if (!is.null(pattern)) {
[16:05:07.309]                         computeRestarts <- base::computeRestarts
[16:05:07.309]                         grepl <- base::grepl
[16:05:07.309]                         restarts <- computeRestarts(cond)
[16:05:07.309]                         for (restart in restarts) {
[16:05:07.309]                           name <- restart$name
[16:05:07.309]                           if (is.null(name)) 
[16:05:07.309]                             next
[16:05:07.309]                           if (!grepl(pattern, name)) 
[16:05:07.309]                             next
[16:05:07.309]                           invokeRestart(restart)
[16:05:07.309]                           muffled <- TRUE
[16:05:07.309]                           break
[16:05:07.309]                         }
[16:05:07.309]                       }
[16:05:07.309]                     }
[16:05:07.309]                     invisible(muffled)
[16:05:07.309]                   }
[16:05:07.309]                   muffleCondition(cond)
[16:05:07.309]                 })
[16:05:07.309]             }))
[16:05:07.309]             future::FutureResult(value = ...future.value$value, 
[16:05:07.309]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.309]                   ...future.rng), globalenv = if (FALSE) 
[16:05:07.309]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:07.309]                     ...future.globalenv.names))
[16:05:07.309]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:07.309]         }, condition = base::local({
[16:05:07.309]             c <- base::c
[16:05:07.309]             inherits <- base::inherits
[16:05:07.309]             invokeRestart <- base::invokeRestart
[16:05:07.309]             length <- base::length
[16:05:07.309]             list <- base::list
[16:05:07.309]             seq.int <- base::seq.int
[16:05:07.309]             signalCondition <- base::signalCondition
[16:05:07.309]             sys.calls <- base::sys.calls
[16:05:07.309]             `[[` <- base::`[[`
[16:05:07.309]             `+` <- base::`+`
[16:05:07.309]             `<<-` <- base::`<<-`
[16:05:07.309]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:07.309]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:07.309]                   3L)]
[16:05:07.309]             }
[16:05:07.309]             function(cond) {
[16:05:07.309]                 is_error <- inherits(cond, "error")
[16:05:07.309]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:07.309]                   NULL)
[16:05:07.309]                 if (is_error) {
[16:05:07.309]                   sessionInformation <- function() {
[16:05:07.309]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:07.309]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:07.309]                       search = base::search(), system = base::Sys.info())
[16:05:07.309]                   }
[16:05:07.309]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.309]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:07.309]                     cond$call), session = sessionInformation(), 
[16:05:07.309]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:07.309]                   signalCondition(cond)
[16:05:07.309]                 }
[16:05:07.309]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:07.309]                 "immediateCondition"))) {
[16:05:07.309]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:07.309]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.309]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:07.309]                   if (TRUE && !signal) {
[16:05:07.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.309]                     {
[16:05:07.309]                       inherits <- base::inherits
[16:05:07.309]                       invokeRestart <- base::invokeRestart
[16:05:07.309]                       is.null <- base::is.null
[16:05:07.309]                       muffled <- FALSE
[16:05:07.309]                       if (inherits(cond, "message")) {
[16:05:07.309]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.309]                         if (muffled) 
[16:05:07.309]                           invokeRestart("muffleMessage")
[16:05:07.309]                       }
[16:05:07.309]                       else if (inherits(cond, "warning")) {
[16:05:07.309]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.309]                         if (muffled) 
[16:05:07.309]                           invokeRestart("muffleWarning")
[16:05:07.309]                       }
[16:05:07.309]                       else if (inherits(cond, "condition")) {
[16:05:07.309]                         if (!is.null(pattern)) {
[16:05:07.309]                           computeRestarts <- base::computeRestarts
[16:05:07.309]                           grepl <- base::grepl
[16:05:07.309]                           restarts <- computeRestarts(cond)
[16:05:07.309]                           for (restart in restarts) {
[16:05:07.309]                             name <- restart$name
[16:05:07.309]                             if (is.null(name)) 
[16:05:07.309]                               next
[16:05:07.309]                             if (!grepl(pattern, name)) 
[16:05:07.309]                               next
[16:05:07.309]                             invokeRestart(restart)
[16:05:07.309]                             muffled <- TRUE
[16:05:07.309]                             break
[16:05:07.309]                           }
[16:05:07.309]                         }
[16:05:07.309]                       }
[16:05:07.309]                       invisible(muffled)
[16:05:07.309]                     }
[16:05:07.309]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.309]                   }
[16:05:07.309]                 }
[16:05:07.309]                 else {
[16:05:07.309]                   if (TRUE) {
[16:05:07.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.309]                     {
[16:05:07.309]                       inherits <- base::inherits
[16:05:07.309]                       invokeRestart <- base::invokeRestart
[16:05:07.309]                       is.null <- base::is.null
[16:05:07.309]                       muffled <- FALSE
[16:05:07.309]                       if (inherits(cond, "message")) {
[16:05:07.309]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.309]                         if (muffled) 
[16:05:07.309]                           invokeRestart("muffleMessage")
[16:05:07.309]                       }
[16:05:07.309]                       else if (inherits(cond, "warning")) {
[16:05:07.309]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.309]                         if (muffled) 
[16:05:07.309]                           invokeRestart("muffleWarning")
[16:05:07.309]                       }
[16:05:07.309]                       else if (inherits(cond, "condition")) {
[16:05:07.309]                         if (!is.null(pattern)) {
[16:05:07.309]                           computeRestarts <- base::computeRestarts
[16:05:07.309]                           grepl <- base::grepl
[16:05:07.309]                           restarts <- computeRestarts(cond)
[16:05:07.309]                           for (restart in restarts) {
[16:05:07.309]                             name <- restart$name
[16:05:07.309]                             if (is.null(name)) 
[16:05:07.309]                               next
[16:05:07.309]                             if (!grepl(pattern, name)) 
[16:05:07.309]                               next
[16:05:07.309]                             invokeRestart(restart)
[16:05:07.309]                             muffled <- TRUE
[16:05:07.309]                             break
[16:05:07.309]                           }
[16:05:07.309]                         }
[16:05:07.309]                       }
[16:05:07.309]                       invisible(muffled)
[16:05:07.309]                     }
[16:05:07.309]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.309]                   }
[16:05:07.309]                 }
[16:05:07.309]             }
[16:05:07.309]         }))
[16:05:07.309]     }, error = function(ex) {
[16:05:07.309]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:07.309]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.309]                 ...future.rng), started = ...future.startTime, 
[16:05:07.309]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:07.309]             version = "1.8"), class = "FutureResult")
[16:05:07.309]     }, finally = {
[16:05:07.309]         if (!identical(...future.workdir, getwd())) 
[16:05:07.309]             setwd(...future.workdir)
[16:05:07.309]         {
[16:05:07.309]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:07.309]                 ...future.oldOptions$nwarnings <- NULL
[16:05:07.309]             }
[16:05:07.309]             base::options(...future.oldOptions)
[16:05:07.309]             if (.Platform$OS.type == "windows") {
[16:05:07.309]                 old_names <- names(...future.oldEnvVars)
[16:05:07.309]                 envs <- base::Sys.getenv()
[16:05:07.309]                 names <- names(envs)
[16:05:07.309]                 common <- intersect(names, old_names)
[16:05:07.309]                 added <- setdiff(names, old_names)
[16:05:07.309]                 removed <- setdiff(old_names, names)
[16:05:07.309]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:07.309]                   envs[common]]
[16:05:07.309]                 NAMES <- toupper(changed)
[16:05:07.309]                 args <- list()
[16:05:07.309]                 for (kk in seq_along(NAMES)) {
[16:05:07.309]                   name <- changed[[kk]]
[16:05:07.309]                   NAME <- NAMES[[kk]]
[16:05:07.309]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.309]                     next
[16:05:07.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.309]                 }
[16:05:07.309]                 NAMES <- toupper(added)
[16:05:07.309]                 for (kk in seq_along(NAMES)) {
[16:05:07.309]                   name <- added[[kk]]
[16:05:07.309]                   NAME <- NAMES[[kk]]
[16:05:07.309]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.309]                     next
[16:05:07.309]                   args[[name]] <- ""
[16:05:07.309]                 }
[16:05:07.309]                 NAMES <- toupper(removed)
[16:05:07.309]                 for (kk in seq_along(NAMES)) {
[16:05:07.309]                   name <- removed[[kk]]
[16:05:07.309]                   NAME <- NAMES[[kk]]
[16:05:07.309]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.309]                     next
[16:05:07.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.309]                 }
[16:05:07.309]                 if (length(args) > 0) 
[16:05:07.309]                   base::do.call(base::Sys.setenv, args = args)
[16:05:07.309]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:07.309]             }
[16:05:07.309]             else {
[16:05:07.309]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:07.309]             }
[16:05:07.309]             {
[16:05:07.309]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:07.309]                   0L) {
[16:05:07.309]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:07.309]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:07.309]                   base::options(opts)
[16:05:07.309]                 }
[16:05:07.309]                 {
[16:05:07.309]                   {
[16:05:07.309]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:07.309]                     NULL
[16:05:07.309]                   }
[16:05:07.309]                   options(future.plan = NULL)
[16:05:07.309]                   if (is.na(NA_character_)) 
[16:05:07.309]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.309]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:07.309]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:07.309]                     envir = parent.frame()) 
[16:05:07.309]                   {
[16:05:07.309]                     default_workers <- missing(workers)
[16:05:07.309]                     if (is.function(workers)) 
[16:05:07.309]                       workers <- workers()
[16:05:07.309]                     workers <- structure(as.integer(workers), 
[16:05:07.309]                       class = class(workers))
[16:05:07.309]                     stop_if_not(is.finite(workers), workers >= 
[16:05:07.309]                       1L)
[16:05:07.309]                     if ((workers == 1L && !inherits(workers, 
[16:05:07.309]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:07.309]                       if (default_workers) 
[16:05:07.309]                         supportsMulticore(warn = TRUE)
[16:05:07.309]                       return(sequential(..., envir = envir))
[16:05:07.309]                     }
[16:05:07.309]                     oopts <- options(mc.cores = workers)
[16:05:07.309]                     on.exit(options(oopts))
[16:05:07.309]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:07.309]                       envir = envir)
[16:05:07.309]                     if (!future$lazy) 
[16:05:07.309]                       future <- run(future)
[16:05:07.309]                     invisible(future)
[16:05:07.309]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:07.309]                 }
[16:05:07.309]             }
[16:05:07.309]         }
[16:05:07.309]     })
[16:05:07.309]     if (TRUE) {
[16:05:07.309]         base::sink(type = "output", split = FALSE)
[16:05:07.309]         if (TRUE) {
[16:05:07.309]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:07.309]         }
[16:05:07.309]         else {
[16:05:07.309]             ...future.result["stdout"] <- base::list(NULL)
[16:05:07.309]         }
[16:05:07.309]         base::close(...future.stdout)
[16:05:07.309]         ...future.stdout <- NULL
[16:05:07.309]     }
[16:05:07.309]     ...future.result$conditions <- ...future.conditions
[16:05:07.309]     ...future.result$finished <- base::Sys.time()
[16:05:07.309]     ...future.result
[16:05:07.309] }
[16:05:07.311] assign_globals() ...
[16:05:07.312] List of 1
[16:05:07.312]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a055f868f8> 
[16:05:07.312]  - attr(*, "where")=List of 1
[16:05:07.312]   ..$ a:<environment: R_EmptyEnv> 
[16:05:07.312]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:07.312]  - attr(*, "resolved")= logi TRUE
[16:05:07.312]  - attr(*, "total_size")= num 10816
[16:05:07.312]  - attr(*, "already-done")= logi TRUE
[16:05:07.314] - copied ‘a’ to environment
[16:05:07.315] assign_globals() ... done
[16:05:07.315] requestCore(): workers = 2
[16:05:07.317] MulticoreFuture started
[16:05:07.317] - Launch lazy future ... done
[16:05:07.317] run() for ‘MulticoreFuture’ ... done
[16:05:07.318] result() for MulticoreFuture ...
[16:05:07.318] plan(): Setting new future strategy stack:
[16:05:07.319] List of future strategies:
[16:05:07.319] 1. sequential:
[16:05:07.319]    - args: function (..., envir = parent.frame())
[16:05:07.319]    - tweaked: FALSE
[16:05:07.319]    - call: NULL
[16:05:07.320] plan(): nbrOfWorkers() = 1
[16:05:07.323] plan(): Setting new future strategy stack:
[16:05:07.323] List of future strategies:
[16:05:07.323] 1. multicore:
[16:05:07.323]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.323]    - tweaked: FALSE
[16:05:07.323]    - call: plan(strategy)
[16:05:07.328] plan(): nbrOfWorkers() = 2
[16:05:07.329] result() for MulticoreFuture ...
[16:05:07.330] result() for MulticoreFuture ... done
[16:05:07.330] signalConditions() ...
[16:05:07.330]  - include = ‘immediateCondition’
[16:05:07.330]  - exclude = 
[16:05:07.330]  - resignal = FALSE
[16:05:07.330]  - Number of conditions: 4
[16:05:07.331] signalConditions() ... done
[16:05:07.331] result() for MulticoreFuture ... done
[16:05:07.331] result() for MulticoreFuture ...
[16:05:07.331] result() for MulticoreFuture ... done
[16:05:07.331] signalConditions() ...
[16:05:07.332]  - include = ‘immediateCondition’
[16:05:07.332]  - exclude = 
[16:05:07.332]  - resignal = FALSE
[16:05:07.332]  - Number of conditions: 4
[16:05:07.332] signalConditions() ... done
[16:05:07.332] Future state: ‘finished’
[16:05:07.333] result() for MulticoreFuture ...
[16:05:07.333] result() for MulticoreFuture ... done
[16:05:07.333] signalConditions() ...
[16:05:07.333]  - include = ‘condition’
[16:05:07.333]  - exclude = ‘immediateCondition’
[16:05:07.333]  - resignal = TRUE
[16:05:07.333]  - Number of conditions: 4
[16:05:07.333]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.321] result() for MulticoreFuture ...
[16:05:07.333]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.321] result() for MulticoreFuture ... done
[16:05:07.334]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.322] result() for MulticoreFuture ...
[16:05:07.334]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.322] result() for MulticoreFuture ... done
[16:05:07.334] signalConditions() ... done
value(b) = 2
[16:05:07.334] result() for MulticoreFuture ...
[16:05:07.334] result() for MulticoreFuture ... done
[16:05:07.334] result() for MulticoreFuture ...
[16:05:07.335] result() for MulticoreFuture ... done
[16:05:07.335] signalConditions() ...
[16:05:07.335]  - include = ‘immediateCondition’
[16:05:07.335]  - exclude = 
[16:05:07.335]  - resignal = FALSE
[16:05:07.335]  - Number of conditions: 4
[16:05:07.335] signalConditions() ... done
[16:05:07.335] Future state: ‘finished’
[16:05:07.336] result() for MulticoreFuture ...
[16:05:07.336] result() for MulticoreFuture ... done
[16:05:07.336] signalConditions() ...
[16:05:07.336]  - include = ‘condition’
[16:05:07.336]  - exclude = ‘immediateCondition’
[16:05:07.336]  - resignal = TRUE
[16:05:07.336]  - Number of conditions: 4
[16:05:07.336]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.321] result() for MulticoreFuture ...
[16:05:07.336]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.321] result() for MulticoreFuture ... done
[16:05:07.337]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.322] result() for MulticoreFuture ...
[16:05:07.337]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.322] result() for MulticoreFuture ... done
[16:05:07.337] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.340] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.340] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:07.341] 
[16:05:07.342] Searching for globals ... DONE
[16:05:07.342] - globals: [0] <none>
[16:05:07.342] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.343] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.343] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:07.344] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:07.344] Searching for globals ... DONE
[16:05:07.345] Resolving globals: TRUE
[16:05:07.345] Resolving any globals that are futures ...
[16:05:07.345] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:07.345] Resolving any globals that are futures ... DONE
[16:05:07.345] Resolving futures part of globals (recursively) ...
[16:05:07.346] resolve() on list ...
[16:05:07.346]  recursive: 99
[16:05:07.346]  length: 1
[16:05:07.346]  elements: ‘a’
[16:05:07.346] run() for ‘Future’ ...
[16:05:07.346] - state: ‘created’
[16:05:07.347] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:07.351] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:07.351] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:07.351]   - Field: ‘label’
[16:05:07.352]   - Field: ‘local’
[16:05:07.352]   - Field: ‘owner’
[16:05:07.352]   - Field: ‘envir’
[16:05:07.352]   - Field: ‘workers’
[16:05:07.352]   - Field: ‘packages’
[16:05:07.352]   - Field: ‘gc’
[16:05:07.352]   - Field: ‘job’
[16:05:07.352]   - Field: ‘conditions’
[16:05:07.353]   - Field: ‘expr’
[16:05:07.353]   - Field: ‘uuid’
[16:05:07.353]   - Field: ‘seed’
[16:05:07.353]   - Field: ‘version’
[16:05:07.353]   - Field: ‘result’
[16:05:07.353]   - Field: ‘asynchronous’
[16:05:07.353]   - Field: ‘calls’
[16:05:07.353]   - Field: ‘globals’
[16:05:07.354]   - Field: ‘stdout’
[16:05:07.354]   - Field: ‘earlySignal’
[16:05:07.354]   - Field: ‘lazy’
[16:05:07.354]   - Field: ‘state’
[16:05:07.354] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:07.354] - Launch lazy future ...
[16:05:07.354] Packages needed by the future expression (n = 0): <none>
[16:05:07.355] Packages needed by future strategies (n = 0): <none>
[16:05:07.355] {
[16:05:07.355]     {
[16:05:07.355]         {
[16:05:07.355]             ...future.startTime <- base::Sys.time()
[16:05:07.355]             {
[16:05:07.355]                 {
[16:05:07.355]                   {
[16:05:07.355]                     {
[16:05:07.355]                       base::local({
[16:05:07.355]                         has_future <- base::requireNamespace("future", 
[16:05:07.355]                           quietly = TRUE)
[16:05:07.355]                         if (has_future) {
[16:05:07.355]                           ns <- base::getNamespace("future")
[16:05:07.355]                           version <- ns[[".package"]][["version"]]
[16:05:07.355]                           if (is.null(version)) 
[16:05:07.355]                             version <- utils::packageVersion("future")
[16:05:07.355]                         }
[16:05:07.355]                         else {
[16:05:07.355]                           version <- NULL
[16:05:07.355]                         }
[16:05:07.355]                         if (!has_future || version < "1.8.0") {
[16:05:07.355]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:07.355]                             "", base::R.version$version.string), 
[16:05:07.355]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:07.355]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:07.355]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:07.355]                               "release", "version")], collapse = " "), 
[16:05:07.355]                             hostname = base::Sys.info()[["nodename"]])
[16:05:07.355]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:07.355]                             info)
[16:05:07.355]                           info <- base::paste(info, collapse = "; ")
[16:05:07.355]                           if (!has_future) {
[16:05:07.355]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:07.355]                               info)
[16:05:07.355]                           }
[16:05:07.355]                           else {
[16:05:07.355]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:07.355]                               info, version)
[16:05:07.355]                           }
[16:05:07.355]                           base::stop(msg)
[16:05:07.355]                         }
[16:05:07.355]                       })
[16:05:07.355]                     }
[16:05:07.355]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:07.355]                     base::options(mc.cores = 1L)
[16:05:07.355]                   }
[16:05:07.355]                   options(future.plan = NULL)
[16:05:07.355]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.355]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:07.355]                 }
[16:05:07.355]                 ...future.workdir <- getwd()
[16:05:07.355]             }
[16:05:07.355]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:07.355]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:07.355]         }
[16:05:07.355]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:07.355]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:07.355]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:07.355]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:07.355]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:07.355]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:07.355]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:07.355]             base::names(...future.oldOptions))
[16:05:07.355]     }
[16:05:07.355]     if (FALSE) {
[16:05:07.355]     }
[16:05:07.355]     else {
[16:05:07.355]         if (TRUE) {
[16:05:07.355]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:07.355]                 open = "w")
[16:05:07.355]         }
[16:05:07.355]         else {
[16:05:07.355]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:07.355]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:07.355]         }
[16:05:07.355]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:07.355]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:07.355]             base::sink(type = "output", split = FALSE)
[16:05:07.355]             base::close(...future.stdout)
[16:05:07.355]         }, add = TRUE)
[16:05:07.355]     }
[16:05:07.355]     ...future.frame <- base::sys.nframe()
[16:05:07.355]     ...future.conditions <- base::list()
[16:05:07.355]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:07.355]     if (FALSE) {
[16:05:07.355]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:07.355]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:07.355]     }
[16:05:07.355]     ...future.result <- base::tryCatch({
[16:05:07.355]         base::withCallingHandlers({
[16:05:07.355]             ...future.value <- base::withVisible(base::local({
[16:05:07.355]                 withCallingHandlers({
[16:05:07.355]                   1
[16:05:07.355]                 }, immediateCondition = function(cond) {
[16:05:07.355]                   save_rds <- function (object, pathname, ...) 
[16:05:07.355]                   {
[16:05:07.355]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:07.355]                     if (file_test("-f", pathname_tmp)) {
[16:05:07.355]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.355]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:07.355]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.355]                         fi_tmp[["mtime"]])
[16:05:07.355]                     }
[16:05:07.355]                     tryCatch({
[16:05:07.355]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:07.355]                     }, error = function(ex) {
[16:05:07.355]                       msg <- conditionMessage(ex)
[16:05:07.355]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.355]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:07.355]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.355]                         fi_tmp[["mtime"]], msg)
[16:05:07.355]                       ex$message <- msg
[16:05:07.355]                       stop(ex)
[16:05:07.355]                     })
[16:05:07.355]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:07.355]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:07.355]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:07.355]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.355]                       fi <- file.info(pathname)
[16:05:07.355]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:07.355]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.355]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:07.355]                         fi[["size"]], fi[["mtime"]])
[16:05:07.355]                       stop(msg)
[16:05:07.355]                     }
[16:05:07.355]                     invisible(pathname)
[16:05:07.355]                   }
[16:05:07.355]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:07.355]                     rootPath = tempdir()) 
[16:05:07.355]                   {
[16:05:07.355]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:07.355]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:07.355]                       tmpdir = path, fileext = ".rds")
[16:05:07.355]                     save_rds(obj, file)
[16:05:07.355]                   }
[16:05:07.355]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:07.355]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.355]                   {
[16:05:07.355]                     inherits <- base::inherits
[16:05:07.355]                     invokeRestart <- base::invokeRestart
[16:05:07.355]                     is.null <- base::is.null
[16:05:07.355]                     muffled <- FALSE
[16:05:07.355]                     if (inherits(cond, "message")) {
[16:05:07.355]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:07.355]                       if (muffled) 
[16:05:07.355]                         invokeRestart("muffleMessage")
[16:05:07.355]                     }
[16:05:07.355]                     else if (inherits(cond, "warning")) {
[16:05:07.355]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:07.355]                       if (muffled) 
[16:05:07.355]                         invokeRestart("muffleWarning")
[16:05:07.355]                     }
[16:05:07.355]                     else if (inherits(cond, "condition")) {
[16:05:07.355]                       if (!is.null(pattern)) {
[16:05:07.355]                         computeRestarts <- base::computeRestarts
[16:05:07.355]                         grepl <- base::grepl
[16:05:07.355]                         restarts <- computeRestarts(cond)
[16:05:07.355]                         for (restart in restarts) {
[16:05:07.355]                           name <- restart$name
[16:05:07.355]                           if (is.null(name)) 
[16:05:07.355]                             next
[16:05:07.355]                           if (!grepl(pattern, name)) 
[16:05:07.355]                             next
[16:05:07.355]                           invokeRestart(restart)
[16:05:07.355]                           muffled <- TRUE
[16:05:07.355]                           break
[16:05:07.355]                         }
[16:05:07.355]                       }
[16:05:07.355]                     }
[16:05:07.355]                     invisible(muffled)
[16:05:07.355]                   }
[16:05:07.355]                   muffleCondition(cond)
[16:05:07.355]                 })
[16:05:07.355]             }))
[16:05:07.355]             future::FutureResult(value = ...future.value$value, 
[16:05:07.355]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.355]                   ...future.rng), globalenv = if (FALSE) 
[16:05:07.355]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:07.355]                     ...future.globalenv.names))
[16:05:07.355]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:07.355]         }, condition = base::local({
[16:05:07.355]             c <- base::c
[16:05:07.355]             inherits <- base::inherits
[16:05:07.355]             invokeRestart <- base::invokeRestart
[16:05:07.355]             length <- base::length
[16:05:07.355]             list <- base::list
[16:05:07.355]             seq.int <- base::seq.int
[16:05:07.355]             signalCondition <- base::signalCondition
[16:05:07.355]             sys.calls <- base::sys.calls
[16:05:07.355]             `[[` <- base::`[[`
[16:05:07.355]             `+` <- base::`+`
[16:05:07.355]             `<<-` <- base::`<<-`
[16:05:07.355]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:07.355]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:07.355]                   3L)]
[16:05:07.355]             }
[16:05:07.355]             function(cond) {
[16:05:07.355]                 is_error <- inherits(cond, "error")
[16:05:07.355]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:07.355]                   NULL)
[16:05:07.355]                 if (is_error) {
[16:05:07.355]                   sessionInformation <- function() {
[16:05:07.355]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:07.355]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:07.355]                       search = base::search(), system = base::Sys.info())
[16:05:07.355]                   }
[16:05:07.355]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.355]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:07.355]                     cond$call), session = sessionInformation(), 
[16:05:07.355]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:07.355]                   signalCondition(cond)
[16:05:07.355]                 }
[16:05:07.355]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:07.355]                 "immediateCondition"))) {
[16:05:07.355]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:07.355]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.355]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:07.355]                   if (TRUE && !signal) {
[16:05:07.355]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.355]                     {
[16:05:07.355]                       inherits <- base::inherits
[16:05:07.355]                       invokeRestart <- base::invokeRestart
[16:05:07.355]                       is.null <- base::is.null
[16:05:07.355]                       muffled <- FALSE
[16:05:07.355]                       if (inherits(cond, "message")) {
[16:05:07.355]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.355]                         if (muffled) 
[16:05:07.355]                           invokeRestart("muffleMessage")
[16:05:07.355]                       }
[16:05:07.355]                       else if (inherits(cond, "warning")) {
[16:05:07.355]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.355]                         if (muffled) 
[16:05:07.355]                           invokeRestart("muffleWarning")
[16:05:07.355]                       }
[16:05:07.355]                       else if (inherits(cond, "condition")) {
[16:05:07.355]                         if (!is.null(pattern)) {
[16:05:07.355]                           computeRestarts <- base::computeRestarts
[16:05:07.355]                           grepl <- base::grepl
[16:05:07.355]                           restarts <- computeRestarts(cond)
[16:05:07.355]                           for (restart in restarts) {
[16:05:07.355]                             name <- restart$name
[16:05:07.355]                             if (is.null(name)) 
[16:05:07.355]                               next
[16:05:07.355]                             if (!grepl(pattern, name)) 
[16:05:07.355]                               next
[16:05:07.355]                             invokeRestart(restart)
[16:05:07.355]                             muffled <- TRUE
[16:05:07.355]                             break
[16:05:07.355]                           }
[16:05:07.355]                         }
[16:05:07.355]                       }
[16:05:07.355]                       invisible(muffled)
[16:05:07.355]                     }
[16:05:07.355]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.355]                   }
[16:05:07.355]                 }
[16:05:07.355]                 else {
[16:05:07.355]                   if (TRUE) {
[16:05:07.355]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.355]                     {
[16:05:07.355]                       inherits <- base::inherits
[16:05:07.355]                       invokeRestart <- base::invokeRestart
[16:05:07.355]                       is.null <- base::is.null
[16:05:07.355]                       muffled <- FALSE
[16:05:07.355]                       if (inherits(cond, "message")) {
[16:05:07.355]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.355]                         if (muffled) 
[16:05:07.355]                           invokeRestart("muffleMessage")
[16:05:07.355]                       }
[16:05:07.355]                       else if (inherits(cond, "warning")) {
[16:05:07.355]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.355]                         if (muffled) 
[16:05:07.355]                           invokeRestart("muffleWarning")
[16:05:07.355]                       }
[16:05:07.355]                       else if (inherits(cond, "condition")) {
[16:05:07.355]                         if (!is.null(pattern)) {
[16:05:07.355]                           computeRestarts <- base::computeRestarts
[16:05:07.355]                           grepl <- base::grepl
[16:05:07.355]                           restarts <- computeRestarts(cond)
[16:05:07.355]                           for (restart in restarts) {
[16:05:07.355]                             name <- restart$name
[16:05:07.355]                             if (is.null(name)) 
[16:05:07.355]                               next
[16:05:07.355]                             if (!grepl(pattern, name)) 
[16:05:07.355]                               next
[16:05:07.355]                             invokeRestart(restart)
[16:05:07.355]                             muffled <- TRUE
[16:05:07.355]                             break
[16:05:07.355]                           }
[16:05:07.355]                         }
[16:05:07.355]                       }
[16:05:07.355]                       invisible(muffled)
[16:05:07.355]                     }
[16:05:07.355]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.355]                   }
[16:05:07.355]                 }
[16:05:07.355]             }
[16:05:07.355]         }))
[16:05:07.355]     }, error = function(ex) {
[16:05:07.355]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:07.355]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.355]                 ...future.rng), started = ...future.startTime, 
[16:05:07.355]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:07.355]             version = "1.8"), class = "FutureResult")
[16:05:07.355]     }, finally = {
[16:05:07.355]         if (!identical(...future.workdir, getwd())) 
[16:05:07.355]             setwd(...future.workdir)
[16:05:07.355]         {
[16:05:07.355]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:07.355]                 ...future.oldOptions$nwarnings <- NULL
[16:05:07.355]             }
[16:05:07.355]             base::options(...future.oldOptions)
[16:05:07.355]             if (.Platform$OS.type == "windows") {
[16:05:07.355]                 old_names <- names(...future.oldEnvVars)
[16:05:07.355]                 envs <- base::Sys.getenv()
[16:05:07.355]                 names <- names(envs)
[16:05:07.355]                 common <- intersect(names, old_names)
[16:05:07.355]                 added <- setdiff(names, old_names)
[16:05:07.355]                 removed <- setdiff(old_names, names)
[16:05:07.355]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:07.355]                   envs[common]]
[16:05:07.355]                 NAMES <- toupper(changed)
[16:05:07.355]                 args <- list()
[16:05:07.355]                 for (kk in seq_along(NAMES)) {
[16:05:07.355]                   name <- changed[[kk]]
[16:05:07.355]                   NAME <- NAMES[[kk]]
[16:05:07.355]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.355]                     next
[16:05:07.355]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.355]                 }
[16:05:07.355]                 NAMES <- toupper(added)
[16:05:07.355]                 for (kk in seq_along(NAMES)) {
[16:05:07.355]                   name <- added[[kk]]
[16:05:07.355]                   NAME <- NAMES[[kk]]
[16:05:07.355]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.355]                     next
[16:05:07.355]                   args[[name]] <- ""
[16:05:07.355]                 }
[16:05:07.355]                 NAMES <- toupper(removed)
[16:05:07.355]                 for (kk in seq_along(NAMES)) {
[16:05:07.355]                   name <- removed[[kk]]
[16:05:07.355]                   NAME <- NAMES[[kk]]
[16:05:07.355]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.355]                     next
[16:05:07.355]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.355]                 }
[16:05:07.355]                 if (length(args) > 0) 
[16:05:07.355]                   base::do.call(base::Sys.setenv, args = args)
[16:05:07.355]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:07.355]             }
[16:05:07.355]             else {
[16:05:07.355]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:07.355]             }
[16:05:07.355]             {
[16:05:07.355]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:07.355]                   0L) {
[16:05:07.355]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:07.355]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:07.355]                   base::options(opts)
[16:05:07.355]                 }
[16:05:07.355]                 {
[16:05:07.355]                   {
[16:05:07.355]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:07.355]                     NULL
[16:05:07.355]                   }
[16:05:07.355]                   options(future.plan = NULL)
[16:05:07.355]                   if (is.na(NA_character_)) 
[16:05:07.355]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.355]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:07.355]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:07.355]                     envir = parent.frame()) 
[16:05:07.355]                   {
[16:05:07.355]                     default_workers <- missing(workers)
[16:05:07.355]                     if (is.function(workers)) 
[16:05:07.355]                       workers <- workers()
[16:05:07.355]                     workers <- structure(as.integer(workers), 
[16:05:07.355]                       class = class(workers))
[16:05:07.355]                     stop_if_not(is.finite(workers), workers >= 
[16:05:07.355]                       1L)
[16:05:07.355]                     if ((workers == 1L && !inherits(workers, 
[16:05:07.355]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:07.355]                       if (default_workers) 
[16:05:07.355]                         supportsMulticore(warn = TRUE)
[16:05:07.355]                       return(sequential(..., envir = envir))
[16:05:07.355]                     }
[16:05:07.355]                     oopts <- options(mc.cores = workers)
[16:05:07.355]                     on.exit(options(oopts))
[16:05:07.355]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:07.355]                       envir = envir)
[16:05:07.355]                     if (!future$lazy) 
[16:05:07.355]                       future <- run(future)
[16:05:07.355]                     invisible(future)
[16:05:07.355]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:07.355]                 }
[16:05:07.355]             }
[16:05:07.355]         }
[16:05:07.355]     })
[16:05:07.355]     if (TRUE) {
[16:05:07.355]         base::sink(type = "output", split = FALSE)
[16:05:07.355]         if (TRUE) {
[16:05:07.355]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:07.355]         }
[16:05:07.355]         else {
[16:05:07.355]             ...future.result["stdout"] <- base::list(NULL)
[16:05:07.355]         }
[16:05:07.355]         base::close(...future.stdout)
[16:05:07.355]         ...future.stdout <- NULL
[16:05:07.355]     }
[16:05:07.355]     ...future.result$conditions <- ...future.conditions
[16:05:07.355]     ...future.result$finished <- base::Sys.time()
[16:05:07.355]     ...future.result
[16:05:07.355] }
[16:05:07.358] requestCore(): workers = 2
[16:05:07.360] MulticoreFuture started
[16:05:07.360] - Launch lazy future ... done
[16:05:07.360] run() for ‘MulticoreFuture’ ... done
[16:05:07.361] plan(): Setting new future strategy stack:
[16:05:07.361] List of future strategies:
[16:05:07.361] 1. sequential:
[16:05:07.361]    - args: function (..., envir = parent.frame())
[16:05:07.361]    - tweaked: FALSE
[16:05:07.361]    - call: NULL
[16:05:07.362] plan(): nbrOfWorkers() = 1
[16:05:07.365] plan(): Setting new future strategy stack:
[16:05:07.365] List of future strategies:
[16:05:07.365] 1. multicore:
[16:05:07.365]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.365]    - tweaked: FALSE
[16:05:07.365]    - call: plan(strategy)
[16:05:07.370] plan(): nbrOfWorkers() = 2
[16:05:07.370] Future #1
[16:05:07.371] result() for MulticoreFuture ...
[16:05:07.372] result() for MulticoreFuture ...
[16:05:07.372] result() for MulticoreFuture ... done
[16:05:07.372] result() for MulticoreFuture ... done
[16:05:07.372] result() for MulticoreFuture ...
[16:05:07.372] result() for MulticoreFuture ... done
[16:05:07.373] A MulticoreFuture was resolved
[16:05:07.373]  length: 0 (resolved future 1)
[16:05:07.373] resolve() on list ... DONE
[16:05:07.373] - globals: [1] ‘a’
[16:05:07.373] Resolving futures part of globals (recursively) ... DONE
[16:05:07.374] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[16:05:07.375] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[16:05:07.375] - globals: [1] ‘a’
[16:05:07.375] - packages: [1] ‘future’
[16:05:07.376] getGlobalsAndPackages() ... DONE
[16:05:07.376] run() for ‘Future’ ...
[16:05:07.376] - state: ‘created’
[16:05:07.376] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:07.380] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:07.380] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:07.381]   - Field: ‘label’
[16:05:07.381]   - Field: ‘local’
[16:05:07.381]   - Field: ‘owner’
[16:05:07.381]   - Field: ‘envir’
[16:05:07.381]   - Field: ‘workers’
[16:05:07.381]   - Field: ‘packages’
[16:05:07.381]   - Field: ‘gc’
[16:05:07.381]   - Field: ‘job’
[16:05:07.382]   - Field: ‘conditions’
[16:05:07.382]   - Field: ‘expr’
[16:05:07.382]   - Field: ‘uuid’
[16:05:07.382]   - Field: ‘seed’
[16:05:07.382]   - Field: ‘version’
[16:05:07.382]   - Field: ‘result’
[16:05:07.382]   - Field: ‘asynchronous’
[16:05:07.382]   - Field: ‘calls’
[16:05:07.382]   - Field: ‘globals’
[16:05:07.383]   - Field: ‘stdout’
[16:05:07.383]   - Field: ‘earlySignal’
[16:05:07.383]   - Field: ‘lazy’
[16:05:07.383]   - Field: ‘state’
[16:05:07.383] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:07.383] - Launch lazy future ...
[16:05:07.384] Packages needed by the future expression (n = 1): ‘future’
[16:05:07.384] Packages needed by future strategies (n = 0): <none>
[16:05:07.387] {
[16:05:07.387]     {
[16:05:07.387]         {
[16:05:07.387]             ...future.startTime <- base::Sys.time()
[16:05:07.387]             {
[16:05:07.387]                 {
[16:05:07.387]                   {
[16:05:07.387]                     {
[16:05:07.387]                       {
[16:05:07.387]                         base::local({
[16:05:07.387]                           has_future <- base::requireNamespace("future", 
[16:05:07.387]                             quietly = TRUE)
[16:05:07.387]                           if (has_future) {
[16:05:07.387]                             ns <- base::getNamespace("future")
[16:05:07.387]                             version <- ns[[".package"]][["version"]]
[16:05:07.387]                             if (is.null(version)) 
[16:05:07.387]                               version <- utils::packageVersion("future")
[16:05:07.387]                           }
[16:05:07.387]                           else {
[16:05:07.387]                             version <- NULL
[16:05:07.387]                           }
[16:05:07.387]                           if (!has_future || version < "1.8.0") {
[16:05:07.387]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:07.387]                               "", base::R.version$version.string), 
[16:05:07.387]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:07.387]                                 base::R.version$platform, 8 * 
[16:05:07.387]                                   base::.Machine$sizeof.pointer), 
[16:05:07.387]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:07.387]                                 "release", "version")], collapse = " "), 
[16:05:07.387]                               hostname = base::Sys.info()[["nodename"]])
[16:05:07.387]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:07.387]                               info)
[16:05:07.387]                             info <- base::paste(info, collapse = "; ")
[16:05:07.387]                             if (!has_future) {
[16:05:07.387]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:07.387]                                 info)
[16:05:07.387]                             }
[16:05:07.387]                             else {
[16:05:07.387]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:07.387]                                 info, version)
[16:05:07.387]                             }
[16:05:07.387]                             base::stop(msg)
[16:05:07.387]                           }
[16:05:07.387]                         })
[16:05:07.387]                       }
[16:05:07.387]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:07.387]                       base::options(mc.cores = 1L)
[16:05:07.387]                     }
[16:05:07.387]                     base::local({
[16:05:07.387]                       for (pkg in "future") {
[16:05:07.387]                         base::loadNamespace(pkg)
[16:05:07.387]                         base::library(pkg, character.only = TRUE)
[16:05:07.387]                       }
[16:05:07.387]                     })
[16:05:07.387]                   }
[16:05:07.387]                   options(future.plan = NULL)
[16:05:07.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:07.387]                 }
[16:05:07.387]                 ...future.workdir <- getwd()
[16:05:07.387]             }
[16:05:07.387]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:07.387]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:07.387]         }
[16:05:07.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:07.387]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:07.387]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:07.387]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:07.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:07.387]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:07.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:07.387]             base::names(...future.oldOptions))
[16:05:07.387]     }
[16:05:07.387]     if (FALSE) {
[16:05:07.387]     }
[16:05:07.387]     else {
[16:05:07.387]         if (TRUE) {
[16:05:07.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:07.387]                 open = "w")
[16:05:07.387]         }
[16:05:07.387]         else {
[16:05:07.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:07.387]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:07.387]         }
[16:05:07.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:07.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:07.387]             base::sink(type = "output", split = FALSE)
[16:05:07.387]             base::close(...future.stdout)
[16:05:07.387]         }, add = TRUE)
[16:05:07.387]     }
[16:05:07.387]     ...future.frame <- base::sys.nframe()
[16:05:07.387]     ...future.conditions <- base::list()
[16:05:07.387]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:07.387]     if (FALSE) {
[16:05:07.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:07.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:07.387]     }
[16:05:07.387]     ...future.result <- base::tryCatch({
[16:05:07.387]         base::withCallingHandlers({
[16:05:07.387]             ...future.value <- base::withVisible(base::local({
[16:05:07.387]                 withCallingHandlers({
[16:05:07.387]                   value(a) + 1
[16:05:07.387]                 }, immediateCondition = function(cond) {
[16:05:07.387]                   save_rds <- function (object, pathname, ...) 
[16:05:07.387]                   {
[16:05:07.387]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:07.387]                     if (file_test("-f", pathname_tmp)) {
[16:05:07.387]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.387]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:07.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.387]                         fi_tmp[["mtime"]])
[16:05:07.387]                     }
[16:05:07.387]                     tryCatch({
[16:05:07.387]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:07.387]                     }, error = function(ex) {
[16:05:07.387]                       msg <- conditionMessage(ex)
[16:05:07.387]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.387]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:07.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.387]                         fi_tmp[["mtime"]], msg)
[16:05:07.387]                       ex$message <- msg
[16:05:07.387]                       stop(ex)
[16:05:07.387]                     })
[16:05:07.387]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:07.387]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:07.387]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:07.387]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.387]                       fi <- file.info(pathname)
[16:05:07.387]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:07.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.387]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:07.387]                         fi[["size"]], fi[["mtime"]])
[16:05:07.387]                       stop(msg)
[16:05:07.387]                     }
[16:05:07.387]                     invisible(pathname)
[16:05:07.387]                   }
[16:05:07.387]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:07.387]                     rootPath = tempdir()) 
[16:05:07.387]                   {
[16:05:07.387]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:07.387]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:07.387]                       tmpdir = path, fileext = ".rds")
[16:05:07.387]                     save_rds(obj, file)
[16:05:07.387]                   }
[16:05:07.387]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:07.387]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.387]                   {
[16:05:07.387]                     inherits <- base::inherits
[16:05:07.387]                     invokeRestart <- base::invokeRestart
[16:05:07.387]                     is.null <- base::is.null
[16:05:07.387]                     muffled <- FALSE
[16:05:07.387]                     if (inherits(cond, "message")) {
[16:05:07.387]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:07.387]                       if (muffled) 
[16:05:07.387]                         invokeRestart("muffleMessage")
[16:05:07.387]                     }
[16:05:07.387]                     else if (inherits(cond, "warning")) {
[16:05:07.387]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:07.387]                       if (muffled) 
[16:05:07.387]                         invokeRestart("muffleWarning")
[16:05:07.387]                     }
[16:05:07.387]                     else if (inherits(cond, "condition")) {
[16:05:07.387]                       if (!is.null(pattern)) {
[16:05:07.387]                         computeRestarts <- base::computeRestarts
[16:05:07.387]                         grepl <- base::grepl
[16:05:07.387]                         restarts <- computeRestarts(cond)
[16:05:07.387]                         for (restart in restarts) {
[16:05:07.387]                           name <- restart$name
[16:05:07.387]                           if (is.null(name)) 
[16:05:07.387]                             next
[16:05:07.387]                           if (!grepl(pattern, name)) 
[16:05:07.387]                             next
[16:05:07.387]                           invokeRestart(restart)
[16:05:07.387]                           muffled <- TRUE
[16:05:07.387]                           break
[16:05:07.387]                         }
[16:05:07.387]                       }
[16:05:07.387]                     }
[16:05:07.387]                     invisible(muffled)
[16:05:07.387]                   }
[16:05:07.387]                   muffleCondition(cond)
[16:05:07.387]                 })
[16:05:07.387]             }))
[16:05:07.387]             future::FutureResult(value = ...future.value$value, 
[16:05:07.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.387]                   ...future.rng), globalenv = if (FALSE) 
[16:05:07.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:07.387]                     ...future.globalenv.names))
[16:05:07.387]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:07.387]         }, condition = base::local({
[16:05:07.387]             c <- base::c
[16:05:07.387]             inherits <- base::inherits
[16:05:07.387]             invokeRestart <- base::invokeRestart
[16:05:07.387]             length <- base::length
[16:05:07.387]             list <- base::list
[16:05:07.387]             seq.int <- base::seq.int
[16:05:07.387]             signalCondition <- base::signalCondition
[16:05:07.387]             sys.calls <- base::sys.calls
[16:05:07.387]             `[[` <- base::`[[`
[16:05:07.387]             `+` <- base::`+`
[16:05:07.387]             `<<-` <- base::`<<-`
[16:05:07.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:07.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:07.387]                   3L)]
[16:05:07.387]             }
[16:05:07.387]             function(cond) {
[16:05:07.387]                 is_error <- inherits(cond, "error")
[16:05:07.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:07.387]                   NULL)
[16:05:07.387]                 if (is_error) {
[16:05:07.387]                   sessionInformation <- function() {
[16:05:07.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:07.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:07.387]                       search = base::search(), system = base::Sys.info())
[16:05:07.387]                   }
[16:05:07.387]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:07.387]                     cond$call), session = sessionInformation(), 
[16:05:07.387]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:07.387]                   signalCondition(cond)
[16:05:07.387]                 }
[16:05:07.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:07.387]                 "immediateCondition"))) {
[16:05:07.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:07.387]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:07.387]                   if (TRUE && !signal) {
[16:05:07.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.387]                     {
[16:05:07.387]                       inherits <- base::inherits
[16:05:07.387]                       invokeRestart <- base::invokeRestart
[16:05:07.387]                       is.null <- base::is.null
[16:05:07.387]                       muffled <- FALSE
[16:05:07.387]                       if (inherits(cond, "message")) {
[16:05:07.387]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.387]                         if (muffled) 
[16:05:07.387]                           invokeRestart("muffleMessage")
[16:05:07.387]                       }
[16:05:07.387]                       else if (inherits(cond, "warning")) {
[16:05:07.387]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.387]                         if (muffled) 
[16:05:07.387]                           invokeRestart("muffleWarning")
[16:05:07.387]                       }
[16:05:07.387]                       else if (inherits(cond, "condition")) {
[16:05:07.387]                         if (!is.null(pattern)) {
[16:05:07.387]                           computeRestarts <- base::computeRestarts
[16:05:07.387]                           grepl <- base::grepl
[16:05:07.387]                           restarts <- computeRestarts(cond)
[16:05:07.387]                           for (restart in restarts) {
[16:05:07.387]                             name <- restart$name
[16:05:07.387]                             if (is.null(name)) 
[16:05:07.387]                               next
[16:05:07.387]                             if (!grepl(pattern, name)) 
[16:05:07.387]                               next
[16:05:07.387]                             invokeRestart(restart)
[16:05:07.387]                             muffled <- TRUE
[16:05:07.387]                             break
[16:05:07.387]                           }
[16:05:07.387]                         }
[16:05:07.387]                       }
[16:05:07.387]                       invisible(muffled)
[16:05:07.387]                     }
[16:05:07.387]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.387]                   }
[16:05:07.387]                 }
[16:05:07.387]                 else {
[16:05:07.387]                   if (TRUE) {
[16:05:07.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.387]                     {
[16:05:07.387]                       inherits <- base::inherits
[16:05:07.387]                       invokeRestart <- base::invokeRestart
[16:05:07.387]                       is.null <- base::is.null
[16:05:07.387]                       muffled <- FALSE
[16:05:07.387]                       if (inherits(cond, "message")) {
[16:05:07.387]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.387]                         if (muffled) 
[16:05:07.387]                           invokeRestart("muffleMessage")
[16:05:07.387]                       }
[16:05:07.387]                       else if (inherits(cond, "warning")) {
[16:05:07.387]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.387]                         if (muffled) 
[16:05:07.387]                           invokeRestart("muffleWarning")
[16:05:07.387]                       }
[16:05:07.387]                       else if (inherits(cond, "condition")) {
[16:05:07.387]                         if (!is.null(pattern)) {
[16:05:07.387]                           computeRestarts <- base::computeRestarts
[16:05:07.387]                           grepl <- base::grepl
[16:05:07.387]                           restarts <- computeRestarts(cond)
[16:05:07.387]                           for (restart in restarts) {
[16:05:07.387]                             name <- restart$name
[16:05:07.387]                             if (is.null(name)) 
[16:05:07.387]                               next
[16:05:07.387]                             if (!grepl(pattern, name)) 
[16:05:07.387]                               next
[16:05:07.387]                             invokeRestart(restart)
[16:05:07.387]                             muffled <- TRUE
[16:05:07.387]                             break
[16:05:07.387]                           }
[16:05:07.387]                         }
[16:05:07.387]                       }
[16:05:07.387]                       invisible(muffled)
[16:05:07.387]                     }
[16:05:07.387]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.387]                   }
[16:05:07.387]                 }
[16:05:07.387]             }
[16:05:07.387]         }))
[16:05:07.387]     }, error = function(ex) {
[16:05:07.387]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:07.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.387]                 ...future.rng), started = ...future.startTime, 
[16:05:07.387]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:07.387]             version = "1.8"), class = "FutureResult")
[16:05:07.387]     }, finally = {
[16:05:07.387]         if (!identical(...future.workdir, getwd())) 
[16:05:07.387]             setwd(...future.workdir)
[16:05:07.387]         {
[16:05:07.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:07.387]                 ...future.oldOptions$nwarnings <- NULL
[16:05:07.387]             }
[16:05:07.387]             base::options(...future.oldOptions)
[16:05:07.387]             if (.Platform$OS.type == "windows") {
[16:05:07.387]                 old_names <- names(...future.oldEnvVars)
[16:05:07.387]                 envs <- base::Sys.getenv()
[16:05:07.387]                 names <- names(envs)
[16:05:07.387]                 common <- intersect(names, old_names)
[16:05:07.387]                 added <- setdiff(names, old_names)
[16:05:07.387]                 removed <- setdiff(old_names, names)
[16:05:07.387]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:07.387]                   envs[common]]
[16:05:07.387]                 NAMES <- toupper(changed)
[16:05:07.387]                 args <- list()
[16:05:07.387]                 for (kk in seq_along(NAMES)) {
[16:05:07.387]                   name <- changed[[kk]]
[16:05:07.387]                   NAME <- NAMES[[kk]]
[16:05:07.387]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.387]                     next
[16:05:07.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.387]                 }
[16:05:07.387]                 NAMES <- toupper(added)
[16:05:07.387]                 for (kk in seq_along(NAMES)) {
[16:05:07.387]                   name <- added[[kk]]
[16:05:07.387]                   NAME <- NAMES[[kk]]
[16:05:07.387]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.387]                     next
[16:05:07.387]                   args[[name]] <- ""
[16:05:07.387]                 }
[16:05:07.387]                 NAMES <- toupper(removed)
[16:05:07.387]                 for (kk in seq_along(NAMES)) {
[16:05:07.387]                   name <- removed[[kk]]
[16:05:07.387]                   NAME <- NAMES[[kk]]
[16:05:07.387]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.387]                     next
[16:05:07.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.387]                 }
[16:05:07.387]                 if (length(args) > 0) 
[16:05:07.387]                   base::do.call(base::Sys.setenv, args = args)
[16:05:07.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:07.387]             }
[16:05:07.387]             else {
[16:05:07.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:07.387]             }
[16:05:07.387]             {
[16:05:07.387]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:07.387]                   0L) {
[16:05:07.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:07.387]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:07.387]                   base::options(opts)
[16:05:07.387]                 }
[16:05:07.387]                 {
[16:05:07.387]                   {
[16:05:07.387]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:07.387]                     NULL
[16:05:07.387]                   }
[16:05:07.387]                   options(future.plan = NULL)
[16:05:07.387]                   if (is.na(NA_character_)) 
[16:05:07.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:07.387]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:07.387]                     envir = parent.frame()) 
[16:05:07.387]                   {
[16:05:07.387]                     default_workers <- missing(workers)
[16:05:07.387]                     if (is.function(workers)) 
[16:05:07.387]                       workers <- workers()
[16:05:07.387]                     workers <- structure(as.integer(workers), 
[16:05:07.387]                       class = class(workers))
[16:05:07.387]                     stop_if_not(is.finite(workers), workers >= 
[16:05:07.387]                       1L)
[16:05:07.387]                     if ((workers == 1L && !inherits(workers, 
[16:05:07.387]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:07.387]                       if (default_workers) 
[16:05:07.387]                         supportsMulticore(warn = TRUE)
[16:05:07.387]                       return(sequential(..., envir = envir))
[16:05:07.387]                     }
[16:05:07.387]                     oopts <- options(mc.cores = workers)
[16:05:07.387]                     on.exit(options(oopts))
[16:05:07.387]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:07.387]                       envir = envir)
[16:05:07.387]                     if (!future$lazy) 
[16:05:07.387]                       future <- run(future)
[16:05:07.387]                     invisible(future)
[16:05:07.387]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:07.387]                 }
[16:05:07.387]             }
[16:05:07.387]         }
[16:05:07.387]     })
[16:05:07.387]     if (TRUE) {
[16:05:07.387]         base::sink(type = "output", split = FALSE)
[16:05:07.387]         if (TRUE) {
[16:05:07.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:07.387]         }
[16:05:07.387]         else {
[16:05:07.387]             ...future.result["stdout"] <- base::list(NULL)
[16:05:07.387]         }
[16:05:07.387]         base::close(...future.stdout)
[16:05:07.387]         ...future.stdout <- NULL
[16:05:07.387]     }
[16:05:07.387]     ...future.result$conditions <- ...future.conditions
[16:05:07.387]     ...future.result$finished <- base::Sys.time()
[16:05:07.387]     ...future.result
[16:05:07.387] }
[16:05:07.389] assign_globals() ...
[16:05:07.390] List of 1
[16:05:07.390]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a05412bc38> 
[16:05:07.390]  - attr(*, "where")=List of 1
[16:05:07.390]   ..$ a:<environment: R_EmptyEnv> 
[16:05:07.390]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:07.390]  - attr(*, "resolved")= logi TRUE
[16:05:07.390]  - attr(*, "total_size")= num 10984
[16:05:07.390]  - attr(*, "already-done")= logi TRUE
[16:05:07.393] - copied ‘a’ to environment
[16:05:07.393] assign_globals() ... done
[16:05:07.394] requestCore(): workers = 2
[16:05:07.395] MulticoreFuture started
[16:05:07.396] - Launch lazy future ... done
[16:05:07.396] run() for ‘MulticoreFuture’ ... done
[16:05:07.397] result() for MulticoreFuture ...
[16:05:07.397] plan(): Setting new future strategy stack:
[16:05:07.397] List of future strategies:
[16:05:07.397] 1. sequential:
[16:05:07.397]    - args: function (..., envir = parent.frame())
[16:05:07.397]    - tweaked: FALSE
[16:05:07.397]    - call: NULL
[16:05:07.398] plan(): nbrOfWorkers() = 1
[16:05:07.402] plan(): Setting new future strategy stack:
[16:05:07.402] List of future strategies:
[16:05:07.402] 1. multicore:
[16:05:07.402]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.402]    - tweaked: FALSE
[16:05:07.402]    - call: plan(strategy)
[16:05:07.407] plan(): nbrOfWorkers() = 2
[16:05:07.408] result() for MulticoreFuture ...
[16:05:07.408] result() for MulticoreFuture ... done
[16:05:07.409] signalConditions() ...
[16:05:07.409]  - include = ‘immediateCondition’
[16:05:07.409]  - exclude = 
[16:05:07.409]  - resignal = FALSE
[16:05:07.409]  - Number of conditions: 4
[16:05:07.409] signalConditions() ... done
[16:05:07.409] result() for MulticoreFuture ... done
[16:05:07.410] result() for MulticoreFuture ...
[16:05:07.410] result() for MulticoreFuture ... done
[16:05:07.410] signalConditions() ...
[16:05:07.410]  - include = ‘immediateCondition’
[16:05:07.410]  - exclude = 
[16:05:07.410]  - resignal = FALSE
[16:05:07.410]  - Number of conditions: 4
[16:05:07.411] signalConditions() ... done
[16:05:07.411] Future state: ‘finished’
[16:05:07.411] result() for MulticoreFuture ...
[16:05:07.411] result() for MulticoreFuture ... done
[16:05:07.411] signalConditions() ...
[16:05:07.411]  - include = ‘condition’
[16:05:07.411]  - exclude = ‘immediateCondition’
[16:05:07.411]  - resignal = TRUE
[16:05:07.412]  - Number of conditions: 4
[16:05:07.412]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.400] result() for MulticoreFuture ...
[16:05:07.412]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.400] result() for MulticoreFuture ... done
[16:05:07.412]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.401] result() for MulticoreFuture ...
[16:05:07.412]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.401] result() for MulticoreFuture ... done
[16:05:07.412] signalConditions() ... done
value(b) = 2
[16:05:07.413] result() for MulticoreFuture ...
[16:05:07.413] result() for MulticoreFuture ... done
[16:05:07.413] result() for MulticoreFuture ...
[16:05:07.413] result() for MulticoreFuture ... done
[16:05:07.413] signalConditions() ...
[16:05:07.413]  - include = ‘immediateCondition’
[16:05:07.413]  - exclude = 
[16:05:07.413]  - resignal = FALSE
[16:05:07.414]  - Number of conditions: 4
[16:05:07.414] signalConditions() ... done
[16:05:07.414] Future state: ‘finished’
[16:05:07.414] result() for MulticoreFuture ...
[16:05:07.414] result() for MulticoreFuture ... done
[16:05:07.414] signalConditions() ...
[16:05:07.414]  - include = ‘condition’
[16:05:07.414]  - exclude = ‘immediateCondition’
[16:05:07.414]  - resignal = TRUE
[16:05:07.415]  - Number of conditions: 4
[16:05:07.415]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.400] result() for MulticoreFuture ...
[16:05:07.415]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.400] result() for MulticoreFuture ... done
[16:05:07.415]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.401] result() for MulticoreFuture ...
[16:05:07.415]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.401] result() for MulticoreFuture ... done
[16:05:07.415] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.416] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.416] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:07.417] 
[16:05:07.417] Searching for globals ... DONE
[16:05:07.417] - globals: [0] <none>
[16:05:07.417] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.417] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.418] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:07.419] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:07.419] Searching for globals ... DONE
[16:05:07.419] Resolving globals: TRUE
[16:05:07.419] Resolving any globals that are futures ...
[16:05:07.419] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:07.420] Resolving any globals that are futures ... DONE
[16:05:07.420] Resolving futures part of globals (recursively) ...
[16:05:07.420] resolve() on list ...
[16:05:07.420]  recursive: 99
[16:05:07.421]  length: 1
[16:05:07.421]  elements: ‘a’
[16:05:07.421] run() for ‘Future’ ...
[16:05:07.421] - state: ‘created’
[16:05:07.421] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:07.426] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:07.426] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:07.426]   - Field: ‘label’
[16:05:07.426]   - Field: ‘local’
[16:05:07.426]   - Field: ‘owner’
[16:05:07.427]   - Field: ‘envir’
[16:05:07.427]   - Field: ‘workers’
[16:05:07.427]   - Field: ‘packages’
[16:05:07.427]   - Field: ‘gc’
[16:05:07.427]   - Field: ‘job’
[16:05:07.427]   - Field: ‘conditions’
[16:05:07.427]   - Field: ‘expr’
[16:05:07.427]   - Field: ‘uuid’
[16:05:07.428]   - Field: ‘seed’
[16:05:07.428]   - Field: ‘version’
[16:05:07.430]   - Field: ‘result’
[16:05:07.430]   - Field: ‘asynchronous’
[16:05:07.430]   - Field: ‘calls’
[16:05:07.431]   - Field: ‘globals’
[16:05:07.431]   - Field: ‘stdout’
[16:05:07.431]   - Field: ‘earlySignal’
[16:05:07.431]   - Field: ‘lazy’
[16:05:07.431]   - Field: ‘state’
[16:05:07.432] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:07.432] - Launch lazy future ...
[16:05:07.432] Packages needed by the future expression (n = 0): <none>
[16:05:07.432] Packages needed by future strategies (n = 0): <none>
[16:05:07.433] {
[16:05:07.433]     {
[16:05:07.433]         {
[16:05:07.433]             ...future.startTime <- base::Sys.time()
[16:05:07.433]             {
[16:05:07.433]                 {
[16:05:07.433]                   {
[16:05:07.433]                     {
[16:05:07.433]                       base::local({
[16:05:07.433]                         has_future <- base::requireNamespace("future", 
[16:05:07.433]                           quietly = TRUE)
[16:05:07.433]                         if (has_future) {
[16:05:07.433]                           ns <- base::getNamespace("future")
[16:05:07.433]                           version <- ns[[".package"]][["version"]]
[16:05:07.433]                           if (is.null(version)) 
[16:05:07.433]                             version <- utils::packageVersion("future")
[16:05:07.433]                         }
[16:05:07.433]                         else {
[16:05:07.433]                           version <- NULL
[16:05:07.433]                         }
[16:05:07.433]                         if (!has_future || version < "1.8.0") {
[16:05:07.433]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:07.433]                             "", base::R.version$version.string), 
[16:05:07.433]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:07.433]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:07.433]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:07.433]                               "release", "version")], collapse = " "), 
[16:05:07.433]                             hostname = base::Sys.info()[["nodename"]])
[16:05:07.433]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:07.433]                             info)
[16:05:07.433]                           info <- base::paste(info, collapse = "; ")
[16:05:07.433]                           if (!has_future) {
[16:05:07.433]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:07.433]                               info)
[16:05:07.433]                           }
[16:05:07.433]                           else {
[16:05:07.433]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:07.433]                               info, version)
[16:05:07.433]                           }
[16:05:07.433]                           base::stop(msg)
[16:05:07.433]                         }
[16:05:07.433]                       })
[16:05:07.433]                     }
[16:05:07.433]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:07.433]                     base::options(mc.cores = 1L)
[16:05:07.433]                   }
[16:05:07.433]                   options(future.plan = NULL)
[16:05:07.433]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.433]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:07.433]                 }
[16:05:07.433]                 ...future.workdir <- getwd()
[16:05:07.433]             }
[16:05:07.433]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:07.433]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:07.433]         }
[16:05:07.433]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:07.433]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:07.433]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:07.433]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:07.433]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:07.433]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:07.433]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:07.433]             base::names(...future.oldOptions))
[16:05:07.433]     }
[16:05:07.433]     if (FALSE) {
[16:05:07.433]     }
[16:05:07.433]     else {
[16:05:07.433]         if (TRUE) {
[16:05:07.433]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:07.433]                 open = "w")
[16:05:07.433]         }
[16:05:07.433]         else {
[16:05:07.433]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:07.433]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:07.433]         }
[16:05:07.433]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:07.433]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:07.433]             base::sink(type = "output", split = FALSE)
[16:05:07.433]             base::close(...future.stdout)
[16:05:07.433]         }, add = TRUE)
[16:05:07.433]     }
[16:05:07.433]     ...future.frame <- base::sys.nframe()
[16:05:07.433]     ...future.conditions <- base::list()
[16:05:07.433]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:07.433]     if (FALSE) {
[16:05:07.433]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:07.433]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:07.433]     }
[16:05:07.433]     ...future.result <- base::tryCatch({
[16:05:07.433]         base::withCallingHandlers({
[16:05:07.433]             ...future.value <- base::withVisible(base::local({
[16:05:07.433]                 withCallingHandlers({
[16:05:07.433]                   1
[16:05:07.433]                 }, immediateCondition = function(cond) {
[16:05:07.433]                   save_rds <- function (object, pathname, ...) 
[16:05:07.433]                   {
[16:05:07.433]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:07.433]                     if (file_test("-f", pathname_tmp)) {
[16:05:07.433]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.433]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:07.433]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.433]                         fi_tmp[["mtime"]])
[16:05:07.433]                     }
[16:05:07.433]                     tryCatch({
[16:05:07.433]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:07.433]                     }, error = function(ex) {
[16:05:07.433]                       msg <- conditionMessage(ex)
[16:05:07.433]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.433]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:07.433]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.433]                         fi_tmp[["mtime"]], msg)
[16:05:07.433]                       ex$message <- msg
[16:05:07.433]                       stop(ex)
[16:05:07.433]                     })
[16:05:07.433]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:07.433]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:07.433]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:07.433]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.433]                       fi <- file.info(pathname)
[16:05:07.433]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:07.433]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.433]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:07.433]                         fi[["size"]], fi[["mtime"]])
[16:05:07.433]                       stop(msg)
[16:05:07.433]                     }
[16:05:07.433]                     invisible(pathname)
[16:05:07.433]                   }
[16:05:07.433]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:07.433]                     rootPath = tempdir()) 
[16:05:07.433]                   {
[16:05:07.433]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:07.433]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:07.433]                       tmpdir = path, fileext = ".rds")
[16:05:07.433]                     save_rds(obj, file)
[16:05:07.433]                   }
[16:05:07.433]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:07.433]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.433]                   {
[16:05:07.433]                     inherits <- base::inherits
[16:05:07.433]                     invokeRestart <- base::invokeRestart
[16:05:07.433]                     is.null <- base::is.null
[16:05:07.433]                     muffled <- FALSE
[16:05:07.433]                     if (inherits(cond, "message")) {
[16:05:07.433]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:07.433]                       if (muffled) 
[16:05:07.433]                         invokeRestart("muffleMessage")
[16:05:07.433]                     }
[16:05:07.433]                     else if (inherits(cond, "warning")) {
[16:05:07.433]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:07.433]                       if (muffled) 
[16:05:07.433]                         invokeRestart("muffleWarning")
[16:05:07.433]                     }
[16:05:07.433]                     else if (inherits(cond, "condition")) {
[16:05:07.433]                       if (!is.null(pattern)) {
[16:05:07.433]                         computeRestarts <- base::computeRestarts
[16:05:07.433]                         grepl <- base::grepl
[16:05:07.433]                         restarts <- computeRestarts(cond)
[16:05:07.433]                         for (restart in restarts) {
[16:05:07.433]                           name <- restart$name
[16:05:07.433]                           if (is.null(name)) 
[16:05:07.433]                             next
[16:05:07.433]                           if (!grepl(pattern, name)) 
[16:05:07.433]                             next
[16:05:07.433]                           invokeRestart(restart)
[16:05:07.433]                           muffled <- TRUE
[16:05:07.433]                           break
[16:05:07.433]                         }
[16:05:07.433]                       }
[16:05:07.433]                     }
[16:05:07.433]                     invisible(muffled)
[16:05:07.433]                   }
[16:05:07.433]                   muffleCondition(cond)
[16:05:07.433]                 })
[16:05:07.433]             }))
[16:05:07.433]             future::FutureResult(value = ...future.value$value, 
[16:05:07.433]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.433]                   ...future.rng), globalenv = if (FALSE) 
[16:05:07.433]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:07.433]                     ...future.globalenv.names))
[16:05:07.433]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:07.433]         }, condition = base::local({
[16:05:07.433]             c <- base::c
[16:05:07.433]             inherits <- base::inherits
[16:05:07.433]             invokeRestart <- base::invokeRestart
[16:05:07.433]             length <- base::length
[16:05:07.433]             list <- base::list
[16:05:07.433]             seq.int <- base::seq.int
[16:05:07.433]             signalCondition <- base::signalCondition
[16:05:07.433]             sys.calls <- base::sys.calls
[16:05:07.433]             `[[` <- base::`[[`
[16:05:07.433]             `+` <- base::`+`
[16:05:07.433]             `<<-` <- base::`<<-`
[16:05:07.433]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:07.433]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:07.433]                   3L)]
[16:05:07.433]             }
[16:05:07.433]             function(cond) {
[16:05:07.433]                 is_error <- inherits(cond, "error")
[16:05:07.433]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:07.433]                   NULL)
[16:05:07.433]                 if (is_error) {
[16:05:07.433]                   sessionInformation <- function() {
[16:05:07.433]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:07.433]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:07.433]                       search = base::search(), system = base::Sys.info())
[16:05:07.433]                   }
[16:05:07.433]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.433]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:07.433]                     cond$call), session = sessionInformation(), 
[16:05:07.433]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:07.433]                   signalCondition(cond)
[16:05:07.433]                 }
[16:05:07.433]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:07.433]                 "immediateCondition"))) {
[16:05:07.433]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:07.433]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.433]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:07.433]                   if (TRUE && !signal) {
[16:05:07.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.433]                     {
[16:05:07.433]                       inherits <- base::inherits
[16:05:07.433]                       invokeRestart <- base::invokeRestart
[16:05:07.433]                       is.null <- base::is.null
[16:05:07.433]                       muffled <- FALSE
[16:05:07.433]                       if (inherits(cond, "message")) {
[16:05:07.433]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.433]                         if (muffled) 
[16:05:07.433]                           invokeRestart("muffleMessage")
[16:05:07.433]                       }
[16:05:07.433]                       else if (inherits(cond, "warning")) {
[16:05:07.433]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.433]                         if (muffled) 
[16:05:07.433]                           invokeRestart("muffleWarning")
[16:05:07.433]                       }
[16:05:07.433]                       else if (inherits(cond, "condition")) {
[16:05:07.433]                         if (!is.null(pattern)) {
[16:05:07.433]                           computeRestarts <- base::computeRestarts
[16:05:07.433]                           grepl <- base::grepl
[16:05:07.433]                           restarts <- computeRestarts(cond)
[16:05:07.433]                           for (restart in restarts) {
[16:05:07.433]                             name <- restart$name
[16:05:07.433]                             if (is.null(name)) 
[16:05:07.433]                               next
[16:05:07.433]                             if (!grepl(pattern, name)) 
[16:05:07.433]                               next
[16:05:07.433]                             invokeRestart(restart)
[16:05:07.433]                             muffled <- TRUE
[16:05:07.433]                             break
[16:05:07.433]                           }
[16:05:07.433]                         }
[16:05:07.433]                       }
[16:05:07.433]                       invisible(muffled)
[16:05:07.433]                     }
[16:05:07.433]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.433]                   }
[16:05:07.433]                 }
[16:05:07.433]                 else {
[16:05:07.433]                   if (TRUE) {
[16:05:07.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.433]                     {
[16:05:07.433]                       inherits <- base::inherits
[16:05:07.433]                       invokeRestart <- base::invokeRestart
[16:05:07.433]                       is.null <- base::is.null
[16:05:07.433]                       muffled <- FALSE
[16:05:07.433]                       if (inherits(cond, "message")) {
[16:05:07.433]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.433]                         if (muffled) 
[16:05:07.433]                           invokeRestart("muffleMessage")
[16:05:07.433]                       }
[16:05:07.433]                       else if (inherits(cond, "warning")) {
[16:05:07.433]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.433]                         if (muffled) 
[16:05:07.433]                           invokeRestart("muffleWarning")
[16:05:07.433]                       }
[16:05:07.433]                       else if (inherits(cond, "condition")) {
[16:05:07.433]                         if (!is.null(pattern)) {
[16:05:07.433]                           computeRestarts <- base::computeRestarts
[16:05:07.433]                           grepl <- base::grepl
[16:05:07.433]                           restarts <- computeRestarts(cond)
[16:05:07.433]                           for (restart in restarts) {
[16:05:07.433]                             name <- restart$name
[16:05:07.433]                             if (is.null(name)) 
[16:05:07.433]                               next
[16:05:07.433]                             if (!grepl(pattern, name)) 
[16:05:07.433]                               next
[16:05:07.433]                             invokeRestart(restart)
[16:05:07.433]                             muffled <- TRUE
[16:05:07.433]                             break
[16:05:07.433]                           }
[16:05:07.433]                         }
[16:05:07.433]                       }
[16:05:07.433]                       invisible(muffled)
[16:05:07.433]                     }
[16:05:07.433]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.433]                   }
[16:05:07.433]                 }
[16:05:07.433]             }
[16:05:07.433]         }))
[16:05:07.433]     }, error = function(ex) {
[16:05:07.433]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:07.433]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.433]                 ...future.rng), started = ...future.startTime, 
[16:05:07.433]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:07.433]             version = "1.8"), class = "FutureResult")
[16:05:07.433]     }, finally = {
[16:05:07.433]         if (!identical(...future.workdir, getwd())) 
[16:05:07.433]             setwd(...future.workdir)
[16:05:07.433]         {
[16:05:07.433]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:07.433]                 ...future.oldOptions$nwarnings <- NULL
[16:05:07.433]             }
[16:05:07.433]             base::options(...future.oldOptions)
[16:05:07.433]             if (.Platform$OS.type == "windows") {
[16:05:07.433]                 old_names <- names(...future.oldEnvVars)
[16:05:07.433]                 envs <- base::Sys.getenv()
[16:05:07.433]                 names <- names(envs)
[16:05:07.433]                 common <- intersect(names, old_names)
[16:05:07.433]                 added <- setdiff(names, old_names)
[16:05:07.433]                 removed <- setdiff(old_names, names)
[16:05:07.433]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:07.433]                   envs[common]]
[16:05:07.433]                 NAMES <- toupper(changed)
[16:05:07.433]                 args <- list()
[16:05:07.433]                 for (kk in seq_along(NAMES)) {
[16:05:07.433]                   name <- changed[[kk]]
[16:05:07.433]                   NAME <- NAMES[[kk]]
[16:05:07.433]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.433]                     next
[16:05:07.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.433]                 }
[16:05:07.433]                 NAMES <- toupper(added)
[16:05:07.433]                 for (kk in seq_along(NAMES)) {
[16:05:07.433]                   name <- added[[kk]]
[16:05:07.433]                   NAME <- NAMES[[kk]]
[16:05:07.433]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.433]                     next
[16:05:07.433]                   args[[name]] <- ""
[16:05:07.433]                 }
[16:05:07.433]                 NAMES <- toupper(removed)
[16:05:07.433]                 for (kk in seq_along(NAMES)) {
[16:05:07.433]                   name <- removed[[kk]]
[16:05:07.433]                   NAME <- NAMES[[kk]]
[16:05:07.433]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.433]                     next
[16:05:07.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.433]                 }
[16:05:07.433]                 if (length(args) > 0) 
[16:05:07.433]                   base::do.call(base::Sys.setenv, args = args)
[16:05:07.433]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:07.433]             }
[16:05:07.433]             else {
[16:05:07.433]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:07.433]             }
[16:05:07.433]             {
[16:05:07.433]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:07.433]                   0L) {
[16:05:07.433]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:07.433]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:07.433]                   base::options(opts)
[16:05:07.433]                 }
[16:05:07.433]                 {
[16:05:07.433]                   {
[16:05:07.433]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:07.433]                     NULL
[16:05:07.433]                   }
[16:05:07.433]                   options(future.plan = NULL)
[16:05:07.433]                   if (is.na(NA_character_)) 
[16:05:07.433]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.433]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:07.433]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:07.433]                     envir = parent.frame()) 
[16:05:07.433]                   {
[16:05:07.433]                     default_workers <- missing(workers)
[16:05:07.433]                     if (is.function(workers)) 
[16:05:07.433]                       workers <- workers()
[16:05:07.433]                     workers <- structure(as.integer(workers), 
[16:05:07.433]                       class = class(workers))
[16:05:07.433]                     stop_if_not(is.finite(workers), workers >= 
[16:05:07.433]                       1L)
[16:05:07.433]                     if ((workers == 1L && !inherits(workers, 
[16:05:07.433]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:07.433]                       if (default_workers) 
[16:05:07.433]                         supportsMulticore(warn = TRUE)
[16:05:07.433]                       return(sequential(..., envir = envir))
[16:05:07.433]                     }
[16:05:07.433]                     oopts <- options(mc.cores = workers)
[16:05:07.433]                     on.exit(options(oopts))
[16:05:07.433]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:07.433]                       envir = envir)
[16:05:07.433]                     if (!future$lazy) 
[16:05:07.433]                       future <- run(future)
[16:05:07.433]                     invisible(future)
[16:05:07.433]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:07.433]                 }
[16:05:07.433]             }
[16:05:07.433]         }
[16:05:07.433]     })
[16:05:07.433]     if (TRUE) {
[16:05:07.433]         base::sink(type = "output", split = FALSE)
[16:05:07.433]         if (TRUE) {
[16:05:07.433]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:07.433]         }
[16:05:07.433]         else {
[16:05:07.433]             ...future.result["stdout"] <- base::list(NULL)
[16:05:07.433]         }
[16:05:07.433]         base::close(...future.stdout)
[16:05:07.433]         ...future.stdout <- NULL
[16:05:07.433]     }
[16:05:07.433]     ...future.result$conditions <- ...future.conditions
[16:05:07.433]     ...future.result$finished <- base::Sys.time()
[16:05:07.433]     ...future.result
[16:05:07.433] }
[16:05:07.436] requestCore(): workers = 2
[16:05:07.438] MulticoreFuture started
[16:05:07.438] - Launch lazy future ... done
[16:05:07.438] run() for ‘MulticoreFuture’ ... done
[16:05:07.439] plan(): Setting new future strategy stack:
[16:05:07.439] List of future strategies:
[16:05:07.439] 1. sequential:
[16:05:07.439]    - args: function (..., envir = parent.frame())
[16:05:07.439]    - tweaked: FALSE
[16:05:07.439]    - call: NULL
[16:05:07.440] plan(): nbrOfWorkers() = 1
[16:05:07.443] plan(): Setting new future strategy stack:
[16:05:07.443] List of future strategies:
[16:05:07.443] 1. multicore:
[16:05:07.443]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.443]    - tweaked: FALSE
[16:05:07.443]    - call: plan(strategy)
[16:05:07.449] plan(): nbrOfWorkers() = 2
[16:05:07.460] Future #1
[16:05:07.460] result() for MulticoreFuture ...
[16:05:07.461] result() for MulticoreFuture ...
[16:05:07.461] result() for MulticoreFuture ... done
[16:05:07.461] result() for MulticoreFuture ... done
[16:05:07.462] result() for MulticoreFuture ...
[16:05:07.462] result() for MulticoreFuture ... done
[16:05:07.462] A MulticoreFuture was resolved
[16:05:07.462]  length: 0 (resolved future 1)
[16:05:07.463] resolve() on list ... DONE
[16:05:07.463] - globals: [1] ‘a’
[16:05:07.463] Resolving futures part of globals (recursively) ... DONE
[16:05:07.465] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[16:05:07.465] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[16:05:07.465] - globals: [1] ‘a’
[16:05:07.466] - packages: [1] ‘future’
[16:05:07.466] getGlobalsAndPackages() ... DONE
[16:05:07.466] run() for ‘Future’ ...
[16:05:07.466] - state: ‘created’
[16:05:07.466] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:07.470] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:07.471] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:07.471]   - Field: ‘label’
[16:05:07.471]   - Field: ‘local’
[16:05:07.471]   - Field: ‘owner’
[16:05:07.471]   - Field: ‘envir’
[16:05:07.471]   - Field: ‘workers’
[16:05:07.471]   - Field: ‘packages’
[16:05:07.472]   - Field: ‘gc’
[16:05:07.472]   - Field: ‘job’
[16:05:07.472]   - Field: ‘conditions’
[16:05:07.472]   - Field: ‘expr’
[16:05:07.472]   - Field: ‘uuid’
[16:05:07.472]   - Field: ‘seed’
[16:05:07.472]   - Field: ‘version’
[16:05:07.472]   - Field: ‘result’
[16:05:07.472]   - Field: ‘asynchronous’
[16:05:07.473]   - Field: ‘calls’
[16:05:07.473]   - Field: ‘globals’
[16:05:07.473]   - Field: ‘stdout’
[16:05:07.473]   - Field: ‘earlySignal’
[16:05:07.473]   - Field: ‘lazy’
[16:05:07.473]   - Field: ‘state’
[16:05:07.473] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:07.473] - Launch lazy future ...
[16:05:07.474] Packages needed by the future expression (n = 1): ‘future’
[16:05:07.474] Packages needed by future strategies (n = 0): <none>
[16:05:07.475] {
[16:05:07.475]     {
[16:05:07.475]         {
[16:05:07.475]             ...future.startTime <- base::Sys.time()
[16:05:07.475]             {
[16:05:07.475]                 {
[16:05:07.475]                   {
[16:05:07.475]                     {
[16:05:07.475]                       {
[16:05:07.475]                         base::local({
[16:05:07.475]                           has_future <- base::requireNamespace("future", 
[16:05:07.475]                             quietly = TRUE)
[16:05:07.475]                           if (has_future) {
[16:05:07.475]                             ns <- base::getNamespace("future")
[16:05:07.475]                             version <- ns[[".package"]][["version"]]
[16:05:07.475]                             if (is.null(version)) 
[16:05:07.475]                               version <- utils::packageVersion("future")
[16:05:07.475]                           }
[16:05:07.475]                           else {
[16:05:07.475]                             version <- NULL
[16:05:07.475]                           }
[16:05:07.475]                           if (!has_future || version < "1.8.0") {
[16:05:07.475]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:07.475]                               "", base::R.version$version.string), 
[16:05:07.475]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:07.475]                                 base::R.version$platform, 8 * 
[16:05:07.475]                                   base::.Machine$sizeof.pointer), 
[16:05:07.475]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:07.475]                                 "release", "version")], collapse = " "), 
[16:05:07.475]                               hostname = base::Sys.info()[["nodename"]])
[16:05:07.475]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:07.475]                               info)
[16:05:07.475]                             info <- base::paste(info, collapse = "; ")
[16:05:07.475]                             if (!has_future) {
[16:05:07.475]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:07.475]                                 info)
[16:05:07.475]                             }
[16:05:07.475]                             else {
[16:05:07.475]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:07.475]                                 info, version)
[16:05:07.475]                             }
[16:05:07.475]                             base::stop(msg)
[16:05:07.475]                           }
[16:05:07.475]                         })
[16:05:07.475]                       }
[16:05:07.475]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:07.475]                       base::options(mc.cores = 1L)
[16:05:07.475]                     }
[16:05:07.475]                     base::local({
[16:05:07.475]                       for (pkg in "future") {
[16:05:07.475]                         base::loadNamespace(pkg)
[16:05:07.475]                         base::library(pkg, character.only = TRUE)
[16:05:07.475]                       }
[16:05:07.475]                     })
[16:05:07.475]                   }
[16:05:07.475]                   options(future.plan = NULL)
[16:05:07.475]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.475]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:07.475]                 }
[16:05:07.475]                 ...future.workdir <- getwd()
[16:05:07.475]             }
[16:05:07.475]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:07.475]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:07.475]         }
[16:05:07.475]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:07.475]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:07.475]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:07.475]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:07.475]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:07.475]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:07.475]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:07.475]             base::names(...future.oldOptions))
[16:05:07.475]     }
[16:05:07.475]     if (FALSE) {
[16:05:07.475]     }
[16:05:07.475]     else {
[16:05:07.475]         if (TRUE) {
[16:05:07.475]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:07.475]                 open = "w")
[16:05:07.475]         }
[16:05:07.475]         else {
[16:05:07.475]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:07.475]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:07.475]         }
[16:05:07.475]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:07.475]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:07.475]             base::sink(type = "output", split = FALSE)
[16:05:07.475]             base::close(...future.stdout)
[16:05:07.475]         }, add = TRUE)
[16:05:07.475]     }
[16:05:07.475]     ...future.frame <- base::sys.nframe()
[16:05:07.475]     ...future.conditions <- base::list()
[16:05:07.475]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:07.475]     if (FALSE) {
[16:05:07.475]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:07.475]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:07.475]     }
[16:05:07.475]     ...future.result <- base::tryCatch({
[16:05:07.475]         base::withCallingHandlers({
[16:05:07.475]             ...future.value <- base::withVisible(base::local({
[16:05:07.475]                 withCallingHandlers({
[16:05:07.475]                   value(a) + 1
[16:05:07.475]                 }, immediateCondition = function(cond) {
[16:05:07.475]                   save_rds <- function (object, pathname, ...) 
[16:05:07.475]                   {
[16:05:07.475]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:07.475]                     if (file_test("-f", pathname_tmp)) {
[16:05:07.475]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.475]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:07.475]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.475]                         fi_tmp[["mtime"]])
[16:05:07.475]                     }
[16:05:07.475]                     tryCatch({
[16:05:07.475]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:07.475]                     }, error = function(ex) {
[16:05:07.475]                       msg <- conditionMessage(ex)
[16:05:07.475]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.475]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:07.475]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.475]                         fi_tmp[["mtime"]], msg)
[16:05:07.475]                       ex$message <- msg
[16:05:07.475]                       stop(ex)
[16:05:07.475]                     })
[16:05:07.475]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:07.475]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:07.475]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:07.475]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.475]                       fi <- file.info(pathname)
[16:05:07.475]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:07.475]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.475]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:07.475]                         fi[["size"]], fi[["mtime"]])
[16:05:07.475]                       stop(msg)
[16:05:07.475]                     }
[16:05:07.475]                     invisible(pathname)
[16:05:07.475]                   }
[16:05:07.475]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:07.475]                     rootPath = tempdir()) 
[16:05:07.475]                   {
[16:05:07.475]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:07.475]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:07.475]                       tmpdir = path, fileext = ".rds")
[16:05:07.475]                     save_rds(obj, file)
[16:05:07.475]                   }
[16:05:07.475]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:07.475]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.475]                   {
[16:05:07.475]                     inherits <- base::inherits
[16:05:07.475]                     invokeRestart <- base::invokeRestart
[16:05:07.475]                     is.null <- base::is.null
[16:05:07.475]                     muffled <- FALSE
[16:05:07.475]                     if (inherits(cond, "message")) {
[16:05:07.475]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:07.475]                       if (muffled) 
[16:05:07.475]                         invokeRestart("muffleMessage")
[16:05:07.475]                     }
[16:05:07.475]                     else if (inherits(cond, "warning")) {
[16:05:07.475]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:07.475]                       if (muffled) 
[16:05:07.475]                         invokeRestart("muffleWarning")
[16:05:07.475]                     }
[16:05:07.475]                     else if (inherits(cond, "condition")) {
[16:05:07.475]                       if (!is.null(pattern)) {
[16:05:07.475]                         computeRestarts <- base::computeRestarts
[16:05:07.475]                         grepl <- base::grepl
[16:05:07.475]                         restarts <- computeRestarts(cond)
[16:05:07.475]                         for (restart in restarts) {
[16:05:07.475]                           name <- restart$name
[16:05:07.475]                           if (is.null(name)) 
[16:05:07.475]                             next
[16:05:07.475]                           if (!grepl(pattern, name)) 
[16:05:07.475]                             next
[16:05:07.475]                           invokeRestart(restart)
[16:05:07.475]                           muffled <- TRUE
[16:05:07.475]                           break
[16:05:07.475]                         }
[16:05:07.475]                       }
[16:05:07.475]                     }
[16:05:07.475]                     invisible(muffled)
[16:05:07.475]                   }
[16:05:07.475]                   muffleCondition(cond)
[16:05:07.475]                 })
[16:05:07.475]             }))
[16:05:07.475]             future::FutureResult(value = ...future.value$value, 
[16:05:07.475]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.475]                   ...future.rng), globalenv = if (FALSE) 
[16:05:07.475]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:07.475]                     ...future.globalenv.names))
[16:05:07.475]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:07.475]         }, condition = base::local({
[16:05:07.475]             c <- base::c
[16:05:07.475]             inherits <- base::inherits
[16:05:07.475]             invokeRestart <- base::invokeRestart
[16:05:07.475]             length <- base::length
[16:05:07.475]             list <- base::list
[16:05:07.475]             seq.int <- base::seq.int
[16:05:07.475]             signalCondition <- base::signalCondition
[16:05:07.475]             sys.calls <- base::sys.calls
[16:05:07.475]             `[[` <- base::`[[`
[16:05:07.475]             `+` <- base::`+`
[16:05:07.475]             `<<-` <- base::`<<-`
[16:05:07.475]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:07.475]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:07.475]                   3L)]
[16:05:07.475]             }
[16:05:07.475]             function(cond) {
[16:05:07.475]                 is_error <- inherits(cond, "error")
[16:05:07.475]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:07.475]                   NULL)
[16:05:07.475]                 if (is_error) {
[16:05:07.475]                   sessionInformation <- function() {
[16:05:07.475]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:07.475]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:07.475]                       search = base::search(), system = base::Sys.info())
[16:05:07.475]                   }
[16:05:07.475]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.475]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:07.475]                     cond$call), session = sessionInformation(), 
[16:05:07.475]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:07.475]                   signalCondition(cond)
[16:05:07.475]                 }
[16:05:07.475]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:07.475]                 "immediateCondition"))) {
[16:05:07.475]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:07.475]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.475]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:07.475]                   if (TRUE && !signal) {
[16:05:07.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.475]                     {
[16:05:07.475]                       inherits <- base::inherits
[16:05:07.475]                       invokeRestart <- base::invokeRestart
[16:05:07.475]                       is.null <- base::is.null
[16:05:07.475]                       muffled <- FALSE
[16:05:07.475]                       if (inherits(cond, "message")) {
[16:05:07.475]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.475]                         if (muffled) 
[16:05:07.475]                           invokeRestart("muffleMessage")
[16:05:07.475]                       }
[16:05:07.475]                       else if (inherits(cond, "warning")) {
[16:05:07.475]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.475]                         if (muffled) 
[16:05:07.475]                           invokeRestart("muffleWarning")
[16:05:07.475]                       }
[16:05:07.475]                       else if (inherits(cond, "condition")) {
[16:05:07.475]                         if (!is.null(pattern)) {
[16:05:07.475]                           computeRestarts <- base::computeRestarts
[16:05:07.475]                           grepl <- base::grepl
[16:05:07.475]                           restarts <- computeRestarts(cond)
[16:05:07.475]                           for (restart in restarts) {
[16:05:07.475]                             name <- restart$name
[16:05:07.475]                             if (is.null(name)) 
[16:05:07.475]                               next
[16:05:07.475]                             if (!grepl(pattern, name)) 
[16:05:07.475]                               next
[16:05:07.475]                             invokeRestart(restart)
[16:05:07.475]                             muffled <- TRUE
[16:05:07.475]                             break
[16:05:07.475]                           }
[16:05:07.475]                         }
[16:05:07.475]                       }
[16:05:07.475]                       invisible(muffled)
[16:05:07.475]                     }
[16:05:07.475]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.475]                   }
[16:05:07.475]                 }
[16:05:07.475]                 else {
[16:05:07.475]                   if (TRUE) {
[16:05:07.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.475]                     {
[16:05:07.475]                       inherits <- base::inherits
[16:05:07.475]                       invokeRestart <- base::invokeRestart
[16:05:07.475]                       is.null <- base::is.null
[16:05:07.475]                       muffled <- FALSE
[16:05:07.475]                       if (inherits(cond, "message")) {
[16:05:07.475]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.475]                         if (muffled) 
[16:05:07.475]                           invokeRestart("muffleMessage")
[16:05:07.475]                       }
[16:05:07.475]                       else if (inherits(cond, "warning")) {
[16:05:07.475]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.475]                         if (muffled) 
[16:05:07.475]                           invokeRestart("muffleWarning")
[16:05:07.475]                       }
[16:05:07.475]                       else if (inherits(cond, "condition")) {
[16:05:07.475]                         if (!is.null(pattern)) {
[16:05:07.475]                           computeRestarts <- base::computeRestarts
[16:05:07.475]                           grepl <- base::grepl
[16:05:07.475]                           restarts <- computeRestarts(cond)
[16:05:07.475]                           for (restart in restarts) {
[16:05:07.475]                             name <- restart$name
[16:05:07.475]                             if (is.null(name)) 
[16:05:07.475]                               next
[16:05:07.475]                             if (!grepl(pattern, name)) 
[16:05:07.475]                               next
[16:05:07.475]                             invokeRestart(restart)
[16:05:07.475]                             muffled <- TRUE
[16:05:07.475]                             break
[16:05:07.475]                           }
[16:05:07.475]                         }
[16:05:07.475]                       }
[16:05:07.475]                       invisible(muffled)
[16:05:07.475]                     }
[16:05:07.475]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.475]                   }
[16:05:07.475]                 }
[16:05:07.475]             }
[16:05:07.475]         }))
[16:05:07.475]     }, error = function(ex) {
[16:05:07.475]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:07.475]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.475]                 ...future.rng), started = ...future.startTime, 
[16:05:07.475]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:07.475]             version = "1.8"), class = "FutureResult")
[16:05:07.475]     }, finally = {
[16:05:07.475]         if (!identical(...future.workdir, getwd())) 
[16:05:07.475]             setwd(...future.workdir)
[16:05:07.475]         {
[16:05:07.475]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:07.475]                 ...future.oldOptions$nwarnings <- NULL
[16:05:07.475]             }
[16:05:07.475]             base::options(...future.oldOptions)
[16:05:07.475]             if (.Platform$OS.type == "windows") {
[16:05:07.475]                 old_names <- names(...future.oldEnvVars)
[16:05:07.475]                 envs <- base::Sys.getenv()
[16:05:07.475]                 names <- names(envs)
[16:05:07.475]                 common <- intersect(names, old_names)
[16:05:07.475]                 added <- setdiff(names, old_names)
[16:05:07.475]                 removed <- setdiff(old_names, names)
[16:05:07.475]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:07.475]                   envs[common]]
[16:05:07.475]                 NAMES <- toupper(changed)
[16:05:07.475]                 args <- list()
[16:05:07.475]                 for (kk in seq_along(NAMES)) {
[16:05:07.475]                   name <- changed[[kk]]
[16:05:07.475]                   NAME <- NAMES[[kk]]
[16:05:07.475]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.475]                     next
[16:05:07.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.475]                 }
[16:05:07.475]                 NAMES <- toupper(added)
[16:05:07.475]                 for (kk in seq_along(NAMES)) {
[16:05:07.475]                   name <- added[[kk]]
[16:05:07.475]                   NAME <- NAMES[[kk]]
[16:05:07.475]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.475]                     next
[16:05:07.475]                   args[[name]] <- ""
[16:05:07.475]                 }
[16:05:07.475]                 NAMES <- toupper(removed)
[16:05:07.475]                 for (kk in seq_along(NAMES)) {
[16:05:07.475]                   name <- removed[[kk]]
[16:05:07.475]                   NAME <- NAMES[[kk]]
[16:05:07.475]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.475]                     next
[16:05:07.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.475]                 }
[16:05:07.475]                 if (length(args) > 0) 
[16:05:07.475]                   base::do.call(base::Sys.setenv, args = args)
[16:05:07.475]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:07.475]             }
[16:05:07.475]             else {
[16:05:07.475]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:07.475]             }
[16:05:07.475]             {
[16:05:07.475]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:07.475]                   0L) {
[16:05:07.475]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:07.475]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:07.475]                   base::options(opts)
[16:05:07.475]                 }
[16:05:07.475]                 {
[16:05:07.475]                   {
[16:05:07.475]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:07.475]                     NULL
[16:05:07.475]                   }
[16:05:07.475]                   options(future.plan = NULL)
[16:05:07.475]                   if (is.na(NA_character_)) 
[16:05:07.475]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.475]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:07.475]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:07.475]                     envir = parent.frame()) 
[16:05:07.475]                   {
[16:05:07.475]                     default_workers <- missing(workers)
[16:05:07.475]                     if (is.function(workers)) 
[16:05:07.475]                       workers <- workers()
[16:05:07.475]                     workers <- structure(as.integer(workers), 
[16:05:07.475]                       class = class(workers))
[16:05:07.475]                     stop_if_not(is.finite(workers), workers >= 
[16:05:07.475]                       1L)
[16:05:07.475]                     if ((workers == 1L && !inherits(workers, 
[16:05:07.475]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:07.475]                       if (default_workers) 
[16:05:07.475]                         supportsMulticore(warn = TRUE)
[16:05:07.475]                       return(sequential(..., envir = envir))
[16:05:07.475]                     }
[16:05:07.475]                     oopts <- options(mc.cores = workers)
[16:05:07.475]                     on.exit(options(oopts))
[16:05:07.475]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:07.475]                       envir = envir)
[16:05:07.475]                     if (!future$lazy) 
[16:05:07.475]                       future <- run(future)
[16:05:07.475]                     invisible(future)
[16:05:07.475]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:07.475]                 }
[16:05:07.475]             }
[16:05:07.475]         }
[16:05:07.475]     })
[16:05:07.475]     if (TRUE) {
[16:05:07.475]         base::sink(type = "output", split = FALSE)
[16:05:07.475]         if (TRUE) {
[16:05:07.475]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:07.475]         }
[16:05:07.475]         else {
[16:05:07.475]             ...future.result["stdout"] <- base::list(NULL)
[16:05:07.475]         }
[16:05:07.475]         base::close(...future.stdout)
[16:05:07.475]         ...future.stdout <- NULL
[16:05:07.475]     }
[16:05:07.475]     ...future.result$conditions <- ...future.conditions
[16:05:07.475]     ...future.result$finished <- base::Sys.time()
[16:05:07.475]     ...future.result
[16:05:07.475] }
[16:05:07.477] assign_globals() ...
[16:05:07.478] List of 1
[16:05:07.478]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a05639f698> 
[16:05:07.478]  - attr(*, "where")=List of 1
[16:05:07.478]   ..$ a:<environment: R_EmptyEnv> 
[16:05:07.478]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:07.478]  - attr(*, "resolved")= logi TRUE
[16:05:07.478]  - attr(*, "total_size")= num 10984
[16:05:07.478]  - attr(*, "already-done")= logi TRUE
[16:05:07.481] - copied ‘a’ to environment
[16:05:07.481] assign_globals() ... done
[16:05:07.481] requestCore(): workers = 2
[16:05:07.483] MulticoreFuture started
[16:05:07.484] - Launch lazy future ... done
[16:05:07.484] run() for ‘MulticoreFuture’ ... done
[16:05:07.484] result() for MulticoreFuture ...
[16:05:07.485] plan(): Setting new future strategy stack:
[16:05:07.485] List of future strategies:
[16:05:07.485] 1. sequential:
[16:05:07.485]    - args: function (..., envir = parent.frame())
[16:05:07.485]    - tweaked: FALSE
[16:05:07.485]    - call: NULL
[16:05:07.486] plan(): nbrOfWorkers() = 1
[16:05:07.489] plan(): Setting new future strategy stack:
[16:05:07.489] List of future strategies:
[16:05:07.489] 1. multicore:
[16:05:07.489]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.489]    - tweaked: FALSE
[16:05:07.489]    - call: plan(strategy)
[16:05:07.502] plan(): nbrOfWorkers() = 2
[16:05:07.504] result() for MulticoreFuture ...
[16:05:07.504] result() for MulticoreFuture ... done
[16:05:07.504] signalConditions() ...
[16:05:07.504]  - include = ‘immediateCondition’
[16:05:07.504]  - exclude = 
[16:05:07.504]  - resignal = FALSE
[16:05:07.505]  - Number of conditions: 4
[16:05:07.505] signalConditions() ... done
[16:05:07.505] result() for MulticoreFuture ... done
[16:05:07.505] result() for MulticoreFuture ...
[16:05:07.505] result() for MulticoreFuture ... done
[16:05:07.506] signalConditions() ...
[16:05:07.506]  - include = ‘immediateCondition’
[16:05:07.506]  - exclude = 
[16:05:07.506]  - resignal = FALSE
[16:05:07.506]  - Number of conditions: 4
[16:05:07.506] signalConditions() ... done
[16:05:07.507] Future state: ‘finished’
[16:05:07.507] result() for MulticoreFuture ...
[16:05:07.507] result() for MulticoreFuture ... done
[16:05:07.507] signalConditions() ...
[16:05:07.507]  - include = ‘condition’
[16:05:07.510]  - exclude = ‘immediateCondition’
[16:05:07.510]  - resignal = TRUE
[16:05:07.511]  - Number of conditions: 4
[16:05:07.511]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.487] result() for MulticoreFuture ...
[16:05:07.511]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.488] result() for MulticoreFuture ... done
[16:05:07.511]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.488] result() for MulticoreFuture ...
[16:05:07.512]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.488] result() for MulticoreFuture ... done
[16:05:07.512] signalConditions() ... done
value(b) = 2
[16:05:07.512] result() for MulticoreFuture ...
[16:05:07.513] result() for MulticoreFuture ... done
[16:05:07.513] result() for MulticoreFuture ...
[16:05:07.513] result() for MulticoreFuture ... done
[16:05:07.513] signalConditions() ...
[16:05:07.513]  - include = ‘immediateCondition’
[16:05:07.513]  - exclude = 
[16:05:07.514]  - resignal = FALSE
[16:05:07.514]  - Number of conditions: 4
[16:05:07.514] signalConditions() ... done
[16:05:07.514] Future state: ‘finished’
[16:05:07.514] result() for MulticoreFuture ...
[16:05:07.514] result() for MulticoreFuture ... done
[16:05:07.514] signalConditions() ...
[16:05:07.514]  - include = ‘condition’
[16:05:07.515]  - exclude = ‘immediateCondition’
[16:05:07.515]  - resignal = TRUE
[16:05:07.515]  - Number of conditions: 4
[16:05:07.515]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.487] result() for MulticoreFuture ...
[16:05:07.515]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.488] result() for MulticoreFuture ... done
[16:05:07.515]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.488] result() for MulticoreFuture ...
[16:05:07.516]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.488] result() for MulticoreFuture ... done
[16:05:07.516] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.516] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.516] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:07.518] - globals found: [2] ‘{’, ‘pkg’
[16:05:07.518] Searching for globals ... DONE
[16:05:07.518] Resolving globals: TRUE
[16:05:07.518] Resolving any globals that are futures ...
[16:05:07.518] - globals: [2] ‘{’, ‘pkg’
[16:05:07.518] Resolving any globals that are futures ... DONE
[16:05:07.519] Resolving futures part of globals (recursively) ...
[16:05:07.519] resolve() on list ...
[16:05:07.519]  recursive: 99
[16:05:07.519]  length: 1
[16:05:07.519]  elements: ‘pkg’
[16:05:07.519]  length: 0 (resolved future 1)
[16:05:07.520] resolve() on list ... DONE
[16:05:07.520] - globals: [1] ‘pkg’
[16:05:07.520] Resolving futures part of globals (recursively) ... DONE
[16:05:07.520] The total size of the 1 globals is 112 bytes (112 bytes)
[16:05:07.520] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[16:05:07.520] - globals: [1] ‘pkg’
[16:05:07.521] 
[16:05:07.521] getGlobalsAndPackages() ... DONE
[16:05:07.521] Packages needed by the future expression (n = 0): <none>
[16:05:07.521] Packages needed by future strategies (n = 0): <none>
[16:05:07.522] {
[16:05:07.522]     {
[16:05:07.522]         {
[16:05:07.522]             ...future.startTime <- base::Sys.time()
[16:05:07.522]             {
[16:05:07.522]                 {
[16:05:07.522]                   {
[16:05:07.522]                     base::local({
[16:05:07.522]                       has_future <- base::requireNamespace("future", 
[16:05:07.522]                         quietly = TRUE)
[16:05:07.522]                       if (has_future) {
[16:05:07.522]                         ns <- base::getNamespace("future")
[16:05:07.522]                         version <- ns[[".package"]][["version"]]
[16:05:07.522]                         if (is.null(version)) 
[16:05:07.522]                           version <- utils::packageVersion("future")
[16:05:07.522]                       }
[16:05:07.522]                       else {
[16:05:07.522]                         version <- NULL
[16:05:07.522]                       }
[16:05:07.522]                       if (!has_future || version < "1.8.0") {
[16:05:07.522]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:07.522]                           "", base::R.version$version.string), 
[16:05:07.522]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:07.522]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:07.522]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:07.522]                             "release", "version")], collapse = " "), 
[16:05:07.522]                           hostname = base::Sys.info()[["nodename"]])
[16:05:07.522]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:07.522]                           info)
[16:05:07.522]                         info <- base::paste(info, collapse = "; ")
[16:05:07.522]                         if (!has_future) {
[16:05:07.522]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:07.522]                             info)
[16:05:07.522]                         }
[16:05:07.522]                         else {
[16:05:07.522]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:07.522]                             info, version)
[16:05:07.522]                         }
[16:05:07.522]                         base::stop(msg)
[16:05:07.522]                       }
[16:05:07.522]                     })
[16:05:07.522]                   }
[16:05:07.522]                   options(future.plan = NULL)
[16:05:07.522]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.522]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:07.522]                 }
[16:05:07.522]                 ...future.workdir <- getwd()
[16:05:07.522]             }
[16:05:07.522]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:07.522]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:07.522]         }
[16:05:07.522]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:07.522]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:07.522]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:07.522]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:07.522]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:07.522]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:07.522]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:07.522]             base::names(...future.oldOptions))
[16:05:07.522]     }
[16:05:07.522]     if (FALSE) {
[16:05:07.522]     }
[16:05:07.522]     else {
[16:05:07.522]         if (TRUE) {
[16:05:07.522]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:07.522]                 open = "w")
[16:05:07.522]         }
[16:05:07.522]         else {
[16:05:07.522]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:07.522]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:07.522]         }
[16:05:07.522]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:07.522]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:07.522]             base::sink(type = "output", split = FALSE)
[16:05:07.522]             base::close(...future.stdout)
[16:05:07.522]         }, add = TRUE)
[16:05:07.522]     }
[16:05:07.522]     ...future.frame <- base::sys.nframe()
[16:05:07.522]     ...future.conditions <- base::list()
[16:05:07.522]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:07.522]     if (FALSE) {
[16:05:07.522]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:07.522]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:07.522]     }
[16:05:07.522]     ...future.result <- base::tryCatch({
[16:05:07.522]         base::withCallingHandlers({
[16:05:07.522]             ...future.value <- base::withVisible(base::local({
[16:05:07.522]                 pkg
[16:05:07.522]             }))
[16:05:07.522]             future::FutureResult(value = ...future.value$value, 
[16:05:07.522]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.522]                   ...future.rng), globalenv = if (FALSE) 
[16:05:07.522]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:07.522]                     ...future.globalenv.names))
[16:05:07.522]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:07.522]         }, condition = base::local({
[16:05:07.522]             c <- base::c
[16:05:07.522]             inherits <- base::inherits
[16:05:07.522]             invokeRestart <- base::invokeRestart
[16:05:07.522]             length <- base::length
[16:05:07.522]             list <- base::list
[16:05:07.522]             seq.int <- base::seq.int
[16:05:07.522]             signalCondition <- base::signalCondition
[16:05:07.522]             sys.calls <- base::sys.calls
[16:05:07.522]             `[[` <- base::`[[`
[16:05:07.522]             `+` <- base::`+`
[16:05:07.522]             `<<-` <- base::`<<-`
[16:05:07.522]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:07.522]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:07.522]                   3L)]
[16:05:07.522]             }
[16:05:07.522]             function(cond) {
[16:05:07.522]                 is_error <- inherits(cond, "error")
[16:05:07.522]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:07.522]                   NULL)
[16:05:07.522]                 if (is_error) {
[16:05:07.522]                   sessionInformation <- function() {
[16:05:07.522]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:07.522]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:07.522]                       search = base::search(), system = base::Sys.info())
[16:05:07.522]                   }
[16:05:07.522]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.522]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:07.522]                     cond$call), session = sessionInformation(), 
[16:05:07.522]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:07.522]                   signalCondition(cond)
[16:05:07.522]                 }
[16:05:07.522]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:07.522]                 "immediateCondition"))) {
[16:05:07.522]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:07.522]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.522]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:07.522]                   if (TRUE && !signal) {
[16:05:07.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.522]                     {
[16:05:07.522]                       inherits <- base::inherits
[16:05:07.522]                       invokeRestart <- base::invokeRestart
[16:05:07.522]                       is.null <- base::is.null
[16:05:07.522]                       muffled <- FALSE
[16:05:07.522]                       if (inherits(cond, "message")) {
[16:05:07.522]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.522]                         if (muffled) 
[16:05:07.522]                           invokeRestart("muffleMessage")
[16:05:07.522]                       }
[16:05:07.522]                       else if (inherits(cond, "warning")) {
[16:05:07.522]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.522]                         if (muffled) 
[16:05:07.522]                           invokeRestart("muffleWarning")
[16:05:07.522]                       }
[16:05:07.522]                       else if (inherits(cond, "condition")) {
[16:05:07.522]                         if (!is.null(pattern)) {
[16:05:07.522]                           computeRestarts <- base::computeRestarts
[16:05:07.522]                           grepl <- base::grepl
[16:05:07.522]                           restarts <- computeRestarts(cond)
[16:05:07.522]                           for (restart in restarts) {
[16:05:07.522]                             name <- restart$name
[16:05:07.522]                             if (is.null(name)) 
[16:05:07.522]                               next
[16:05:07.522]                             if (!grepl(pattern, name)) 
[16:05:07.522]                               next
[16:05:07.522]                             invokeRestart(restart)
[16:05:07.522]                             muffled <- TRUE
[16:05:07.522]                             break
[16:05:07.522]                           }
[16:05:07.522]                         }
[16:05:07.522]                       }
[16:05:07.522]                       invisible(muffled)
[16:05:07.522]                     }
[16:05:07.522]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.522]                   }
[16:05:07.522]                 }
[16:05:07.522]                 else {
[16:05:07.522]                   if (TRUE) {
[16:05:07.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.522]                     {
[16:05:07.522]                       inherits <- base::inherits
[16:05:07.522]                       invokeRestart <- base::invokeRestart
[16:05:07.522]                       is.null <- base::is.null
[16:05:07.522]                       muffled <- FALSE
[16:05:07.522]                       if (inherits(cond, "message")) {
[16:05:07.522]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.522]                         if (muffled) 
[16:05:07.522]                           invokeRestart("muffleMessage")
[16:05:07.522]                       }
[16:05:07.522]                       else if (inherits(cond, "warning")) {
[16:05:07.522]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.522]                         if (muffled) 
[16:05:07.522]                           invokeRestart("muffleWarning")
[16:05:07.522]                       }
[16:05:07.522]                       else if (inherits(cond, "condition")) {
[16:05:07.522]                         if (!is.null(pattern)) {
[16:05:07.522]                           computeRestarts <- base::computeRestarts
[16:05:07.522]                           grepl <- base::grepl
[16:05:07.522]                           restarts <- computeRestarts(cond)
[16:05:07.522]                           for (restart in restarts) {
[16:05:07.522]                             name <- restart$name
[16:05:07.522]                             if (is.null(name)) 
[16:05:07.522]                               next
[16:05:07.522]                             if (!grepl(pattern, name)) 
[16:05:07.522]                               next
[16:05:07.522]                             invokeRestart(restart)
[16:05:07.522]                             muffled <- TRUE
[16:05:07.522]                             break
[16:05:07.522]                           }
[16:05:07.522]                         }
[16:05:07.522]                       }
[16:05:07.522]                       invisible(muffled)
[16:05:07.522]                     }
[16:05:07.522]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.522]                   }
[16:05:07.522]                 }
[16:05:07.522]             }
[16:05:07.522]         }))
[16:05:07.522]     }, error = function(ex) {
[16:05:07.522]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:07.522]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.522]                 ...future.rng), started = ...future.startTime, 
[16:05:07.522]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:07.522]             version = "1.8"), class = "FutureResult")
[16:05:07.522]     }, finally = {
[16:05:07.522]         if (!identical(...future.workdir, getwd())) 
[16:05:07.522]             setwd(...future.workdir)
[16:05:07.522]         {
[16:05:07.522]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:07.522]                 ...future.oldOptions$nwarnings <- NULL
[16:05:07.522]             }
[16:05:07.522]             base::options(...future.oldOptions)
[16:05:07.522]             if (.Platform$OS.type == "windows") {
[16:05:07.522]                 old_names <- names(...future.oldEnvVars)
[16:05:07.522]                 envs <- base::Sys.getenv()
[16:05:07.522]                 names <- names(envs)
[16:05:07.522]                 common <- intersect(names, old_names)
[16:05:07.522]                 added <- setdiff(names, old_names)
[16:05:07.522]                 removed <- setdiff(old_names, names)
[16:05:07.522]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:07.522]                   envs[common]]
[16:05:07.522]                 NAMES <- toupper(changed)
[16:05:07.522]                 args <- list()
[16:05:07.522]                 for (kk in seq_along(NAMES)) {
[16:05:07.522]                   name <- changed[[kk]]
[16:05:07.522]                   NAME <- NAMES[[kk]]
[16:05:07.522]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.522]                     next
[16:05:07.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.522]                 }
[16:05:07.522]                 NAMES <- toupper(added)
[16:05:07.522]                 for (kk in seq_along(NAMES)) {
[16:05:07.522]                   name <- added[[kk]]
[16:05:07.522]                   NAME <- NAMES[[kk]]
[16:05:07.522]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.522]                     next
[16:05:07.522]                   args[[name]] <- ""
[16:05:07.522]                 }
[16:05:07.522]                 NAMES <- toupper(removed)
[16:05:07.522]                 for (kk in seq_along(NAMES)) {
[16:05:07.522]                   name <- removed[[kk]]
[16:05:07.522]                   NAME <- NAMES[[kk]]
[16:05:07.522]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.522]                     next
[16:05:07.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.522]                 }
[16:05:07.522]                 if (length(args) > 0) 
[16:05:07.522]                   base::do.call(base::Sys.setenv, args = args)
[16:05:07.522]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:07.522]             }
[16:05:07.522]             else {
[16:05:07.522]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:07.522]             }
[16:05:07.522]             {
[16:05:07.522]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:07.522]                   0L) {
[16:05:07.522]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:07.522]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:07.522]                   base::options(opts)
[16:05:07.522]                 }
[16:05:07.522]                 {
[16:05:07.522]                   {
[16:05:07.522]                     NULL
[16:05:07.522]                     RNGkind("Mersenne-Twister")
[16:05:07.522]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:07.522]                       inherits = FALSE)
[16:05:07.522]                   }
[16:05:07.522]                   options(future.plan = NULL)
[16:05:07.522]                   if (is.na(NA_character_)) 
[16:05:07.522]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.522]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:07.522]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:07.522]                     envir = parent.frame()) 
[16:05:07.522]                   {
[16:05:07.522]                     default_workers <- missing(workers)
[16:05:07.522]                     if (is.function(workers)) 
[16:05:07.522]                       workers <- workers()
[16:05:07.522]                     workers <- structure(as.integer(workers), 
[16:05:07.522]                       class = class(workers))
[16:05:07.522]                     stop_if_not(is.finite(workers), workers >= 
[16:05:07.522]                       1L)
[16:05:07.522]                     if ((workers == 1L && !inherits(workers, 
[16:05:07.522]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:07.522]                       if (default_workers) 
[16:05:07.522]                         supportsMulticore(warn = TRUE)
[16:05:07.522]                       return(sequential(..., envir = envir))
[16:05:07.522]                     }
[16:05:07.522]                     oopts <- options(mc.cores = workers)
[16:05:07.522]                     on.exit(options(oopts))
[16:05:07.522]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:07.522]                       envir = envir)
[16:05:07.522]                     if (!future$lazy) 
[16:05:07.522]                       future <- run(future)
[16:05:07.522]                     invisible(future)
[16:05:07.522]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:07.522]                 }
[16:05:07.522]             }
[16:05:07.522]         }
[16:05:07.522]     })
[16:05:07.522]     if (TRUE) {
[16:05:07.522]         base::sink(type = "output", split = FALSE)
[16:05:07.522]         if (TRUE) {
[16:05:07.522]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:07.522]         }
[16:05:07.522]         else {
[16:05:07.522]             ...future.result["stdout"] <- base::list(NULL)
[16:05:07.522]         }
[16:05:07.522]         base::close(...future.stdout)
[16:05:07.522]         ...future.stdout <- NULL
[16:05:07.522]     }
[16:05:07.522]     ...future.result$conditions <- ...future.conditions
[16:05:07.522]     ...future.result$finished <- base::Sys.time()
[16:05:07.522]     ...future.result
[16:05:07.522] }
[16:05:07.524] assign_globals() ...
[16:05:07.524] List of 1
[16:05:07.524]  $ pkg: chr "foo"
[16:05:07.524]  - attr(*, "where")=List of 1
[16:05:07.524]   ..$ pkg:<environment: R_EmptyEnv> 
[16:05:07.524]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:07.524]  - attr(*, "resolved")= logi TRUE
[16:05:07.524]  - attr(*, "total_size")= num 112
[16:05:07.526] - copied ‘pkg’ to environment
[16:05:07.527] assign_globals() ... done
[16:05:07.527] plan(): Setting new future strategy stack:
[16:05:07.527] List of future strategies:
[16:05:07.527] 1. sequential:
[16:05:07.527]    - args: function (..., envir = parent.frame())
[16:05:07.527]    - tweaked: FALSE
[16:05:07.527]    - call: NULL
[16:05:07.527] plan(): nbrOfWorkers() = 1
[16:05:07.528] plan(): Setting new future strategy stack:
[16:05:07.528] List of future strategies:
[16:05:07.528] 1. multicore:
[16:05:07.528]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.528]    - tweaked: FALSE
[16:05:07.528]    - call: plan(strategy)
[16:05:07.532] plan(): nbrOfWorkers() = 2
[16:05:07.533] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.534] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.534] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:07.536] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:05:07.536] Searching for globals ... DONE
[16:05:07.536] Resolving globals: TRUE
[16:05:07.536] Resolving any globals that are futures ...
[16:05:07.536] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:05:07.543] Resolving any globals that are futures ... DONE
[16:05:07.543] Resolving futures part of globals (recursively) ...
[16:05:07.543] resolve() on list ...
[16:05:07.543]  recursive: 99
[16:05:07.543]  length: 1
[16:05:07.544]  elements: ‘a’
[16:05:07.544]  length: 0 (resolved future 1)
[16:05:07.544] resolve() on list ... DONE
[16:05:07.544] - globals: [1] ‘a’
[16:05:07.544] Resolving futures part of globals (recursively) ... DONE
[16:05:07.544] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:07.544] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:05:07.545] - globals: [1] ‘a’
[16:05:07.545] 
[16:05:07.545] getGlobalsAndPackages() ... DONE
[16:05:07.545] run() for ‘Future’ ...
[16:05:07.545] - state: ‘created’
[16:05:07.545] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:07.549] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:07.549] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:07.550]   - Field: ‘label’
[16:05:07.550]   - Field: ‘local’
[16:05:07.550]   - Field: ‘owner’
[16:05:07.550]   - Field: ‘envir’
[16:05:07.550]   - Field: ‘workers’
[16:05:07.550]   - Field: ‘packages’
[16:05:07.550]   - Field: ‘gc’
[16:05:07.550]   - Field: ‘job’
[16:05:07.550]   - Field: ‘conditions’
[16:05:07.551]   - Field: ‘expr’
[16:05:07.551]   - Field: ‘uuid’
[16:05:07.551]   - Field: ‘seed’
[16:05:07.551]   - Field: ‘version’
[16:05:07.551]   - Field: ‘result’
[16:05:07.551]   - Field: ‘asynchronous’
[16:05:07.551]   - Field: ‘calls’
[16:05:07.551]   - Field: ‘globals’
[16:05:07.551]   - Field: ‘stdout’
[16:05:07.552]   - Field: ‘earlySignal’
[16:05:07.552]   - Field: ‘lazy’
[16:05:07.552]   - Field: ‘state’
[16:05:07.552] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:07.552] - Launch lazy future ...
[16:05:07.552] Packages needed by the future expression (n = 0): <none>
[16:05:07.552] Packages needed by future strategies (n = 0): <none>
[16:05:07.553] {
[16:05:07.553]     {
[16:05:07.553]         {
[16:05:07.553]             ...future.startTime <- base::Sys.time()
[16:05:07.553]             {
[16:05:07.553]                 {
[16:05:07.553]                   {
[16:05:07.553]                     {
[16:05:07.553]                       base::local({
[16:05:07.553]                         has_future <- base::requireNamespace("future", 
[16:05:07.553]                           quietly = TRUE)
[16:05:07.553]                         if (has_future) {
[16:05:07.553]                           ns <- base::getNamespace("future")
[16:05:07.553]                           version <- ns[[".package"]][["version"]]
[16:05:07.553]                           if (is.null(version)) 
[16:05:07.553]                             version <- utils::packageVersion("future")
[16:05:07.553]                         }
[16:05:07.553]                         else {
[16:05:07.553]                           version <- NULL
[16:05:07.553]                         }
[16:05:07.553]                         if (!has_future || version < "1.8.0") {
[16:05:07.553]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:07.553]                             "", base::R.version$version.string), 
[16:05:07.553]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:07.553]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:07.553]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:07.553]                               "release", "version")], collapse = " "), 
[16:05:07.553]                             hostname = base::Sys.info()[["nodename"]])
[16:05:07.553]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:07.553]                             info)
[16:05:07.553]                           info <- base::paste(info, collapse = "; ")
[16:05:07.553]                           if (!has_future) {
[16:05:07.553]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:07.553]                               info)
[16:05:07.553]                           }
[16:05:07.553]                           else {
[16:05:07.553]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:07.553]                               info, version)
[16:05:07.553]                           }
[16:05:07.553]                           base::stop(msg)
[16:05:07.553]                         }
[16:05:07.553]                       })
[16:05:07.553]                     }
[16:05:07.553]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:07.553]                     base::options(mc.cores = 1L)
[16:05:07.553]                   }
[16:05:07.553]                   options(future.plan = NULL)
[16:05:07.553]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.553]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:07.553]                 }
[16:05:07.553]                 ...future.workdir <- getwd()
[16:05:07.553]             }
[16:05:07.553]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:07.553]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:07.553]         }
[16:05:07.553]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:07.553]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:07.553]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:07.553]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:07.553]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:07.553]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:07.553]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:07.553]             base::names(...future.oldOptions))
[16:05:07.553]     }
[16:05:07.553]     if (FALSE) {
[16:05:07.553]     }
[16:05:07.553]     else {
[16:05:07.553]         if (TRUE) {
[16:05:07.553]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:07.553]                 open = "w")
[16:05:07.553]         }
[16:05:07.553]         else {
[16:05:07.553]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:07.553]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:07.553]         }
[16:05:07.553]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:07.553]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:07.553]             base::sink(type = "output", split = FALSE)
[16:05:07.553]             base::close(...future.stdout)
[16:05:07.553]         }, add = TRUE)
[16:05:07.553]     }
[16:05:07.553]     ...future.frame <- base::sys.nframe()
[16:05:07.553]     ...future.conditions <- base::list()
[16:05:07.553]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:07.553]     if (FALSE) {
[16:05:07.553]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:07.553]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:07.553]     }
[16:05:07.553]     ...future.result <- base::tryCatch({
[16:05:07.553]         base::withCallingHandlers({
[16:05:07.553]             ...future.value <- base::withVisible(base::local({
[16:05:07.553]                 withCallingHandlers({
[16:05:07.553]                   {
[16:05:07.553]                     b <- a
[16:05:07.553]                     a <- 2
[16:05:07.553]                     a * b
[16:05:07.553]                   }
[16:05:07.553]                 }, immediateCondition = function(cond) {
[16:05:07.553]                   save_rds <- function (object, pathname, ...) 
[16:05:07.553]                   {
[16:05:07.553]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:07.553]                     if (file_test("-f", pathname_tmp)) {
[16:05:07.553]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.553]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:07.553]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.553]                         fi_tmp[["mtime"]])
[16:05:07.553]                     }
[16:05:07.553]                     tryCatch({
[16:05:07.553]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:07.553]                     }, error = function(ex) {
[16:05:07.553]                       msg <- conditionMessage(ex)
[16:05:07.553]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.553]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:07.553]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.553]                         fi_tmp[["mtime"]], msg)
[16:05:07.553]                       ex$message <- msg
[16:05:07.553]                       stop(ex)
[16:05:07.553]                     })
[16:05:07.553]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:07.553]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:07.553]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:07.553]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.553]                       fi <- file.info(pathname)
[16:05:07.553]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:07.553]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.553]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:07.553]                         fi[["size"]], fi[["mtime"]])
[16:05:07.553]                       stop(msg)
[16:05:07.553]                     }
[16:05:07.553]                     invisible(pathname)
[16:05:07.553]                   }
[16:05:07.553]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:07.553]                     rootPath = tempdir()) 
[16:05:07.553]                   {
[16:05:07.553]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:07.553]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:07.553]                       tmpdir = path, fileext = ".rds")
[16:05:07.553]                     save_rds(obj, file)
[16:05:07.553]                   }
[16:05:07.553]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:07.553]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.553]                   {
[16:05:07.553]                     inherits <- base::inherits
[16:05:07.553]                     invokeRestart <- base::invokeRestart
[16:05:07.553]                     is.null <- base::is.null
[16:05:07.553]                     muffled <- FALSE
[16:05:07.553]                     if (inherits(cond, "message")) {
[16:05:07.553]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:07.553]                       if (muffled) 
[16:05:07.553]                         invokeRestart("muffleMessage")
[16:05:07.553]                     }
[16:05:07.553]                     else if (inherits(cond, "warning")) {
[16:05:07.553]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:07.553]                       if (muffled) 
[16:05:07.553]                         invokeRestart("muffleWarning")
[16:05:07.553]                     }
[16:05:07.553]                     else if (inherits(cond, "condition")) {
[16:05:07.553]                       if (!is.null(pattern)) {
[16:05:07.553]                         computeRestarts <- base::computeRestarts
[16:05:07.553]                         grepl <- base::grepl
[16:05:07.553]                         restarts <- computeRestarts(cond)
[16:05:07.553]                         for (restart in restarts) {
[16:05:07.553]                           name <- restart$name
[16:05:07.553]                           if (is.null(name)) 
[16:05:07.553]                             next
[16:05:07.553]                           if (!grepl(pattern, name)) 
[16:05:07.553]                             next
[16:05:07.553]                           invokeRestart(restart)
[16:05:07.553]                           muffled <- TRUE
[16:05:07.553]                           break
[16:05:07.553]                         }
[16:05:07.553]                       }
[16:05:07.553]                     }
[16:05:07.553]                     invisible(muffled)
[16:05:07.553]                   }
[16:05:07.553]                   muffleCondition(cond)
[16:05:07.553]                 })
[16:05:07.553]             }))
[16:05:07.553]             future::FutureResult(value = ...future.value$value, 
[16:05:07.553]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.553]                   ...future.rng), globalenv = if (FALSE) 
[16:05:07.553]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:07.553]                     ...future.globalenv.names))
[16:05:07.553]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:07.553]         }, condition = base::local({
[16:05:07.553]             c <- base::c
[16:05:07.553]             inherits <- base::inherits
[16:05:07.553]             invokeRestart <- base::invokeRestart
[16:05:07.553]             length <- base::length
[16:05:07.553]             list <- base::list
[16:05:07.553]             seq.int <- base::seq.int
[16:05:07.553]             signalCondition <- base::signalCondition
[16:05:07.553]             sys.calls <- base::sys.calls
[16:05:07.553]             `[[` <- base::`[[`
[16:05:07.553]             `+` <- base::`+`
[16:05:07.553]             `<<-` <- base::`<<-`
[16:05:07.553]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:07.553]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:07.553]                   3L)]
[16:05:07.553]             }
[16:05:07.553]             function(cond) {
[16:05:07.553]                 is_error <- inherits(cond, "error")
[16:05:07.553]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:07.553]                   NULL)
[16:05:07.553]                 if (is_error) {
[16:05:07.553]                   sessionInformation <- function() {
[16:05:07.553]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:07.553]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:07.553]                       search = base::search(), system = base::Sys.info())
[16:05:07.553]                   }
[16:05:07.553]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.553]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:07.553]                     cond$call), session = sessionInformation(), 
[16:05:07.553]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:07.553]                   signalCondition(cond)
[16:05:07.553]                 }
[16:05:07.553]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:07.553]                 "immediateCondition"))) {
[16:05:07.553]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:07.553]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.553]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:07.553]                   if (TRUE && !signal) {
[16:05:07.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.553]                     {
[16:05:07.553]                       inherits <- base::inherits
[16:05:07.553]                       invokeRestart <- base::invokeRestart
[16:05:07.553]                       is.null <- base::is.null
[16:05:07.553]                       muffled <- FALSE
[16:05:07.553]                       if (inherits(cond, "message")) {
[16:05:07.553]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.553]                         if (muffled) 
[16:05:07.553]                           invokeRestart("muffleMessage")
[16:05:07.553]                       }
[16:05:07.553]                       else if (inherits(cond, "warning")) {
[16:05:07.553]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.553]                         if (muffled) 
[16:05:07.553]                           invokeRestart("muffleWarning")
[16:05:07.553]                       }
[16:05:07.553]                       else if (inherits(cond, "condition")) {
[16:05:07.553]                         if (!is.null(pattern)) {
[16:05:07.553]                           computeRestarts <- base::computeRestarts
[16:05:07.553]                           grepl <- base::grepl
[16:05:07.553]                           restarts <- computeRestarts(cond)
[16:05:07.553]                           for (restart in restarts) {
[16:05:07.553]                             name <- restart$name
[16:05:07.553]                             if (is.null(name)) 
[16:05:07.553]                               next
[16:05:07.553]                             if (!grepl(pattern, name)) 
[16:05:07.553]                               next
[16:05:07.553]                             invokeRestart(restart)
[16:05:07.553]                             muffled <- TRUE
[16:05:07.553]                             break
[16:05:07.553]                           }
[16:05:07.553]                         }
[16:05:07.553]                       }
[16:05:07.553]                       invisible(muffled)
[16:05:07.553]                     }
[16:05:07.553]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.553]                   }
[16:05:07.553]                 }
[16:05:07.553]                 else {
[16:05:07.553]                   if (TRUE) {
[16:05:07.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.553]                     {
[16:05:07.553]                       inherits <- base::inherits
[16:05:07.553]                       invokeRestart <- base::invokeRestart
[16:05:07.553]                       is.null <- base::is.null
[16:05:07.553]                       muffled <- FALSE
[16:05:07.553]                       if (inherits(cond, "message")) {
[16:05:07.553]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.553]                         if (muffled) 
[16:05:07.553]                           invokeRestart("muffleMessage")
[16:05:07.553]                       }
[16:05:07.553]                       else if (inherits(cond, "warning")) {
[16:05:07.553]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.553]                         if (muffled) 
[16:05:07.553]                           invokeRestart("muffleWarning")
[16:05:07.553]                       }
[16:05:07.553]                       else if (inherits(cond, "condition")) {
[16:05:07.553]                         if (!is.null(pattern)) {
[16:05:07.553]                           computeRestarts <- base::computeRestarts
[16:05:07.553]                           grepl <- base::grepl
[16:05:07.553]                           restarts <- computeRestarts(cond)
[16:05:07.553]                           for (restart in restarts) {
[16:05:07.553]                             name <- restart$name
[16:05:07.553]                             if (is.null(name)) 
[16:05:07.553]                               next
[16:05:07.553]                             if (!grepl(pattern, name)) 
[16:05:07.553]                               next
[16:05:07.553]                             invokeRestart(restart)
[16:05:07.553]                             muffled <- TRUE
[16:05:07.553]                             break
[16:05:07.553]                           }
[16:05:07.553]                         }
[16:05:07.553]                       }
[16:05:07.553]                       invisible(muffled)
[16:05:07.553]                     }
[16:05:07.553]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.553]                   }
[16:05:07.553]                 }
[16:05:07.553]             }
[16:05:07.553]         }))
[16:05:07.553]     }, error = function(ex) {
[16:05:07.553]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:07.553]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.553]                 ...future.rng), started = ...future.startTime, 
[16:05:07.553]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:07.553]             version = "1.8"), class = "FutureResult")
[16:05:07.553]     }, finally = {
[16:05:07.553]         if (!identical(...future.workdir, getwd())) 
[16:05:07.553]             setwd(...future.workdir)
[16:05:07.553]         {
[16:05:07.553]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:07.553]                 ...future.oldOptions$nwarnings <- NULL
[16:05:07.553]             }
[16:05:07.553]             base::options(...future.oldOptions)
[16:05:07.553]             if (.Platform$OS.type == "windows") {
[16:05:07.553]                 old_names <- names(...future.oldEnvVars)
[16:05:07.553]                 envs <- base::Sys.getenv()
[16:05:07.553]                 names <- names(envs)
[16:05:07.553]                 common <- intersect(names, old_names)
[16:05:07.553]                 added <- setdiff(names, old_names)
[16:05:07.553]                 removed <- setdiff(old_names, names)
[16:05:07.553]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:07.553]                   envs[common]]
[16:05:07.553]                 NAMES <- toupper(changed)
[16:05:07.553]                 args <- list()
[16:05:07.553]                 for (kk in seq_along(NAMES)) {
[16:05:07.553]                   name <- changed[[kk]]
[16:05:07.553]                   NAME <- NAMES[[kk]]
[16:05:07.553]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.553]                     next
[16:05:07.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.553]                 }
[16:05:07.553]                 NAMES <- toupper(added)
[16:05:07.553]                 for (kk in seq_along(NAMES)) {
[16:05:07.553]                   name <- added[[kk]]
[16:05:07.553]                   NAME <- NAMES[[kk]]
[16:05:07.553]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.553]                     next
[16:05:07.553]                   args[[name]] <- ""
[16:05:07.553]                 }
[16:05:07.553]                 NAMES <- toupper(removed)
[16:05:07.553]                 for (kk in seq_along(NAMES)) {
[16:05:07.553]                   name <- removed[[kk]]
[16:05:07.553]                   NAME <- NAMES[[kk]]
[16:05:07.553]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.553]                     next
[16:05:07.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.553]                 }
[16:05:07.553]                 if (length(args) > 0) 
[16:05:07.553]                   base::do.call(base::Sys.setenv, args = args)
[16:05:07.553]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:07.553]             }
[16:05:07.553]             else {
[16:05:07.553]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:07.553]             }
[16:05:07.553]             {
[16:05:07.553]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:07.553]                   0L) {
[16:05:07.553]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:07.553]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:07.553]                   base::options(opts)
[16:05:07.553]                 }
[16:05:07.553]                 {
[16:05:07.553]                   {
[16:05:07.553]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:07.553]                     NULL
[16:05:07.553]                   }
[16:05:07.553]                   options(future.plan = NULL)
[16:05:07.553]                   if (is.na(NA_character_)) 
[16:05:07.553]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.553]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:07.553]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:07.553]                     envir = parent.frame()) 
[16:05:07.553]                   {
[16:05:07.553]                     default_workers <- missing(workers)
[16:05:07.553]                     if (is.function(workers)) 
[16:05:07.553]                       workers <- workers()
[16:05:07.553]                     workers <- structure(as.integer(workers), 
[16:05:07.553]                       class = class(workers))
[16:05:07.553]                     stop_if_not(is.finite(workers), workers >= 
[16:05:07.553]                       1L)
[16:05:07.553]                     if ((workers == 1L && !inherits(workers, 
[16:05:07.553]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:07.553]                       if (default_workers) 
[16:05:07.553]                         supportsMulticore(warn = TRUE)
[16:05:07.553]                       return(sequential(..., envir = envir))
[16:05:07.553]                     }
[16:05:07.553]                     oopts <- options(mc.cores = workers)
[16:05:07.553]                     on.exit(options(oopts))
[16:05:07.553]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:07.553]                       envir = envir)
[16:05:07.553]                     if (!future$lazy) 
[16:05:07.553]                       future <- run(future)
[16:05:07.553]                     invisible(future)
[16:05:07.553]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:07.553]                 }
[16:05:07.553]             }
[16:05:07.553]         }
[16:05:07.553]     })
[16:05:07.553]     if (TRUE) {
[16:05:07.553]         base::sink(type = "output", split = FALSE)
[16:05:07.553]         if (TRUE) {
[16:05:07.553]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:07.553]         }
[16:05:07.553]         else {
[16:05:07.553]             ...future.result["stdout"] <- base::list(NULL)
[16:05:07.553]         }
[16:05:07.553]         base::close(...future.stdout)
[16:05:07.553]         ...future.stdout <- NULL
[16:05:07.553]     }
[16:05:07.553]     ...future.result$conditions <- ...future.conditions
[16:05:07.553]     ...future.result$finished <- base::Sys.time()
[16:05:07.553]     ...future.result
[16:05:07.553] }
[16:05:07.555] assign_globals() ...
[16:05:07.555] List of 1
[16:05:07.555]  $ a: num 3
[16:05:07.555]  - attr(*, "where")=List of 1
[16:05:07.555]   ..$ a:<environment: R_EmptyEnv> 
[16:05:07.555]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:07.555]  - attr(*, "resolved")= logi TRUE
[16:05:07.555]  - attr(*, "total_size")= num 56
[16:05:07.555]  - attr(*, "already-done")= logi TRUE
[16:05:07.558] - copied ‘a’ to environment
[16:05:07.558] assign_globals() ... done
[16:05:07.558] requestCore(): workers = 2
[16:05:07.560] MulticoreFuture started
[16:05:07.561] - Launch lazy future ... done
[16:05:07.561] run() for ‘MulticoreFuture’ ... done
[16:05:07.561] result() for MulticoreFuture ...
[16:05:07.561] plan(): Setting new future strategy stack:
[16:05:07.562] List of future strategies:
[16:05:07.562] 1. sequential:
[16:05:07.562]    - args: function (..., envir = parent.frame())
[16:05:07.562]    - tweaked: FALSE
[16:05:07.562]    - call: NULL
[16:05:07.562] plan(): nbrOfWorkers() = 1
[16:05:07.565] plan(): Setting new future strategy stack:
[16:05:07.565] List of future strategies:
[16:05:07.565] 1. multicore:
[16:05:07.565]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.565]    - tweaked: FALSE
[16:05:07.565]    - call: plan(strategy)
[16:05:07.570] plan(): nbrOfWorkers() = 2
[16:05:07.571] result() for MulticoreFuture ...
[16:05:07.571] result() for MulticoreFuture ... done
[16:05:07.572] result() for MulticoreFuture ... done
[16:05:07.572] result() for MulticoreFuture ...
[16:05:07.572] result() for MulticoreFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.573] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.573] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:07.575] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:05:07.576] Searching for globals ... DONE
[16:05:07.576] Resolving globals: TRUE
[16:05:07.576] Resolving any globals that are futures ...
[16:05:07.576] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:05:07.576] Resolving any globals that are futures ... DONE
[16:05:07.577] Resolving futures part of globals (recursively) ...
[16:05:07.577] resolve() on list ...
[16:05:07.577]  recursive: 99
[16:05:07.577]  length: 1
[16:05:07.577]  elements: ‘a’
[16:05:07.578]  length: 0 (resolved future 1)
[16:05:07.578] resolve() on list ... DONE
[16:05:07.578] - globals: [1] ‘a’
[16:05:07.578] Resolving futures part of globals (recursively) ... DONE
[16:05:07.578] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:07.579] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:05:07.579] - globals: [1] ‘a’
[16:05:07.579] 
[16:05:07.579] getGlobalsAndPackages() ... DONE
[16:05:07.579] run() for ‘Future’ ...
[16:05:07.580] - state: ‘created’
[16:05:07.580] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:07.584] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:07.584] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:07.584]   - Field: ‘label’
[16:05:07.584]   - Field: ‘local’
[16:05:07.584]   - Field: ‘owner’
[16:05:07.585]   - Field: ‘envir’
[16:05:07.585]   - Field: ‘workers’
[16:05:07.585]   - Field: ‘packages’
[16:05:07.587]   - Field: ‘gc’
[16:05:07.587]   - Field: ‘job’
[16:05:07.588]   - Field: ‘conditions’
[16:05:07.588]   - Field: ‘expr’
[16:05:07.588]   - Field: ‘uuid’
[16:05:07.588]   - Field: ‘seed’
[16:05:07.588]   - Field: ‘version’
[16:05:07.588]   - Field: ‘result’
[16:05:07.589]   - Field: ‘asynchronous’
[16:05:07.589]   - Field: ‘calls’
[16:05:07.589]   - Field: ‘globals’
[16:05:07.589]   - Field: ‘stdout’
[16:05:07.589]   - Field: ‘earlySignal’
[16:05:07.589]   - Field: ‘lazy’
[16:05:07.589]   - Field: ‘state’
[16:05:07.590] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:07.590] - Launch lazy future ...
[16:05:07.590] Packages needed by the future expression (n = 0): <none>
[16:05:07.590] Packages needed by future strategies (n = 0): <none>
[16:05:07.591] {
[16:05:07.591]     {
[16:05:07.591]         {
[16:05:07.591]             ...future.startTime <- base::Sys.time()
[16:05:07.591]             {
[16:05:07.591]                 {
[16:05:07.591]                   {
[16:05:07.591]                     {
[16:05:07.591]                       base::local({
[16:05:07.591]                         has_future <- base::requireNamespace("future", 
[16:05:07.591]                           quietly = TRUE)
[16:05:07.591]                         if (has_future) {
[16:05:07.591]                           ns <- base::getNamespace("future")
[16:05:07.591]                           version <- ns[[".package"]][["version"]]
[16:05:07.591]                           if (is.null(version)) 
[16:05:07.591]                             version <- utils::packageVersion("future")
[16:05:07.591]                         }
[16:05:07.591]                         else {
[16:05:07.591]                           version <- NULL
[16:05:07.591]                         }
[16:05:07.591]                         if (!has_future || version < "1.8.0") {
[16:05:07.591]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:07.591]                             "", base::R.version$version.string), 
[16:05:07.591]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:07.591]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:07.591]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:07.591]                               "release", "version")], collapse = " "), 
[16:05:07.591]                             hostname = base::Sys.info()[["nodename"]])
[16:05:07.591]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:07.591]                             info)
[16:05:07.591]                           info <- base::paste(info, collapse = "; ")
[16:05:07.591]                           if (!has_future) {
[16:05:07.591]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:07.591]                               info)
[16:05:07.591]                           }
[16:05:07.591]                           else {
[16:05:07.591]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:07.591]                               info, version)
[16:05:07.591]                           }
[16:05:07.591]                           base::stop(msg)
[16:05:07.591]                         }
[16:05:07.591]                       })
[16:05:07.591]                     }
[16:05:07.591]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:07.591]                     base::options(mc.cores = 1L)
[16:05:07.591]                   }
[16:05:07.591]                   options(future.plan = NULL)
[16:05:07.591]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.591]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:07.591]                 }
[16:05:07.591]                 ...future.workdir <- getwd()
[16:05:07.591]             }
[16:05:07.591]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:07.591]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:07.591]         }
[16:05:07.591]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:07.591]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:07.591]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:07.591]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:07.591]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:07.591]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:07.591]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:07.591]             base::names(...future.oldOptions))
[16:05:07.591]     }
[16:05:07.591]     if (FALSE) {
[16:05:07.591]     }
[16:05:07.591]     else {
[16:05:07.591]         if (TRUE) {
[16:05:07.591]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:07.591]                 open = "w")
[16:05:07.591]         }
[16:05:07.591]         else {
[16:05:07.591]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:07.591]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:07.591]         }
[16:05:07.591]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:07.591]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:07.591]             base::sink(type = "output", split = FALSE)
[16:05:07.591]             base::close(...future.stdout)
[16:05:07.591]         }, add = TRUE)
[16:05:07.591]     }
[16:05:07.591]     ...future.frame <- base::sys.nframe()
[16:05:07.591]     ...future.conditions <- base::list()
[16:05:07.591]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:07.591]     if (FALSE) {
[16:05:07.591]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:07.591]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:07.591]     }
[16:05:07.591]     ...future.result <- base::tryCatch({
[16:05:07.591]         base::withCallingHandlers({
[16:05:07.591]             ...future.value <- base::withVisible(base::local({
[16:05:07.591]                 withCallingHandlers({
[16:05:07.591]                   {
[16:05:07.591]                     b <- a
[16:05:07.591]                     a <- 2
[16:05:07.591]                     a * b
[16:05:07.591]                   }
[16:05:07.591]                 }, immediateCondition = function(cond) {
[16:05:07.591]                   save_rds <- function (object, pathname, ...) 
[16:05:07.591]                   {
[16:05:07.591]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:07.591]                     if (file_test("-f", pathname_tmp)) {
[16:05:07.591]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.591]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:07.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.591]                         fi_tmp[["mtime"]])
[16:05:07.591]                     }
[16:05:07.591]                     tryCatch({
[16:05:07.591]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:07.591]                     }, error = function(ex) {
[16:05:07.591]                       msg <- conditionMessage(ex)
[16:05:07.591]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.591]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:07.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.591]                         fi_tmp[["mtime"]], msg)
[16:05:07.591]                       ex$message <- msg
[16:05:07.591]                       stop(ex)
[16:05:07.591]                     })
[16:05:07.591]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:07.591]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:07.591]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:07.591]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.591]                       fi <- file.info(pathname)
[16:05:07.591]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:07.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.591]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:07.591]                         fi[["size"]], fi[["mtime"]])
[16:05:07.591]                       stop(msg)
[16:05:07.591]                     }
[16:05:07.591]                     invisible(pathname)
[16:05:07.591]                   }
[16:05:07.591]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:07.591]                     rootPath = tempdir()) 
[16:05:07.591]                   {
[16:05:07.591]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:07.591]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:07.591]                       tmpdir = path, fileext = ".rds")
[16:05:07.591]                     save_rds(obj, file)
[16:05:07.591]                   }
[16:05:07.591]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:07.591]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.591]                   {
[16:05:07.591]                     inherits <- base::inherits
[16:05:07.591]                     invokeRestart <- base::invokeRestart
[16:05:07.591]                     is.null <- base::is.null
[16:05:07.591]                     muffled <- FALSE
[16:05:07.591]                     if (inherits(cond, "message")) {
[16:05:07.591]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:07.591]                       if (muffled) 
[16:05:07.591]                         invokeRestart("muffleMessage")
[16:05:07.591]                     }
[16:05:07.591]                     else if (inherits(cond, "warning")) {
[16:05:07.591]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:07.591]                       if (muffled) 
[16:05:07.591]                         invokeRestart("muffleWarning")
[16:05:07.591]                     }
[16:05:07.591]                     else if (inherits(cond, "condition")) {
[16:05:07.591]                       if (!is.null(pattern)) {
[16:05:07.591]                         computeRestarts <- base::computeRestarts
[16:05:07.591]                         grepl <- base::grepl
[16:05:07.591]                         restarts <- computeRestarts(cond)
[16:05:07.591]                         for (restart in restarts) {
[16:05:07.591]                           name <- restart$name
[16:05:07.591]                           if (is.null(name)) 
[16:05:07.591]                             next
[16:05:07.591]                           if (!grepl(pattern, name)) 
[16:05:07.591]                             next
[16:05:07.591]                           invokeRestart(restart)
[16:05:07.591]                           muffled <- TRUE
[16:05:07.591]                           break
[16:05:07.591]                         }
[16:05:07.591]                       }
[16:05:07.591]                     }
[16:05:07.591]                     invisible(muffled)
[16:05:07.591]                   }
[16:05:07.591]                   muffleCondition(cond)
[16:05:07.591]                 })
[16:05:07.591]             }))
[16:05:07.591]             future::FutureResult(value = ...future.value$value, 
[16:05:07.591]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.591]                   ...future.rng), globalenv = if (FALSE) 
[16:05:07.591]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:07.591]                     ...future.globalenv.names))
[16:05:07.591]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:07.591]         }, condition = base::local({
[16:05:07.591]             c <- base::c
[16:05:07.591]             inherits <- base::inherits
[16:05:07.591]             invokeRestart <- base::invokeRestart
[16:05:07.591]             length <- base::length
[16:05:07.591]             list <- base::list
[16:05:07.591]             seq.int <- base::seq.int
[16:05:07.591]             signalCondition <- base::signalCondition
[16:05:07.591]             sys.calls <- base::sys.calls
[16:05:07.591]             `[[` <- base::`[[`
[16:05:07.591]             `+` <- base::`+`
[16:05:07.591]             `<<-` <- base::`<<-`
[16:05:07.591]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:07.591]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:07.591]                   3L)]
[16:05:07.591]             }
[16:05:07.591]             function(cond) {
[16:05:07.591]                 is_error <- inherits(cond, "error")
[16:05:07.591]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:07.591]                   NULL)
[16:05:07.591]                 if (is_error) {
[16:05:07.591]                   sessionInformation <- function() {
[16:05:07.591]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:07.591]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:07.591]                       search = base::search(), system = base::Sys.info())
[16:05:07.591]                   }
[16:05:07.591]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.591]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:07.591]                     cond$call), session = sessionInformation(), 
[16:05:07.591]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:07.591]                   signalCondition(cond)
[16:05:07.591]                 }
[16:05:07.591]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:07.591]                 "immediateCondition"))) {
[16:05:07.591]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:07.591]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.591]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:07.591]                   if (TRUE && !signal) {
[16:05:07.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.591]                     {
[16:05:07.591]                       inherits <- base::inherits
[16:05:07.591]                       invokeRestart <- base::invokeRestart
[16:05:07.591]                       is.null <- base::is.null
[16:05:07.591]                       muffled <- FALSE
[16:05:07.591]                       if (inherits(cond, "message")) {
[16:05:07.591]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.591]                         if (muffled) 
[16:05:07.591]                           invokeRestart("muffleMessage")
[16:05:07.591]                       }
[16:05:07.591]                       else if (inherits(cond, "warning")) {
[16:05:07.591]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.591]                         if (muffled) 
[16:05:07.591]                           invokeRestart("muffleWarning")
[16:05:07.591]                       }
[16:05:07.591]                       else if (inherits(cond, "condition")) {
[16:05:07.591]                         if (!is.null(pattern)) {
[16:05:07.591]                           computeRestarts <- base::computeRestarts
[16:05:07.591]                           grepl <- base::grepl
[16:05:07.591]                           restarts <- computeRestarts(cond)
[16:05:07.591]                           for (restart in restarts) {
[16:05:07.591]                             name <- restart$name
[16:05:07.591]                             if (is.null(name)) 
[16:05:07.591]                               next
[16:05:07.591]                             if (!grepl(pattern, name)) 
[16:05:07.591]                               next
[16:05:07.591]                             invokeRestart(restart)
[16:05:07.591]                             muffled <- TRUE
[16:05:07.591]                             break
[16:05:07.591]                           }
[16:05:07.591]                         }
[16:05:07.591]                       }
[16:05:07.591]                       invisible(muffled)
[16:05:07.591]                     }
[16:05:07.591]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.591]                   }
[16:05:07.591]                 }
[16:05:07.591]                 else {
[16:05:07.591]                   if (TRUE) {
[16:05:07.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.591]                     {
[16:05:07.591]                       inherits <- base::inherits
[16:05:07.591]                       invokeRestart <- base::invokeRestart
[16:05:07.591]                       is.null <- base::is.null
[16:05:07.591]                       muffled <- FALSE
[16:05:07.591]                       if (inherits(cond, "message")) {
[16:05:07.591]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.591]                         if (muffled) 
[16:05:07.591]                           invokeRestart("muffleMessage")
[16:05:07.591]                       }
[16:05:07.591]                       else if (inherits(cond, "warning")) {
[16:05:07.591]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.591]                         if (muffled) 
[16:05:07.591]                           invokeRestart("muffleWarning")
[16:05:07.591]                       }
[16:05:07.591]                       else if (inherits(cond, "condition")) {
[16:05:07.591]                         if (!is.null(pattern)) {
[16:05:07.591]                           computeRestarts <- base::computeRestarts
[16:05:07.591]                           grepl <- base::grepl
[16:05:07.591]                           restarts <- computeRestarts(cond)
[16:05:07.591]                           for (restart in restarts) {
[16:05:07.591]                             name <- restart$name
[16:05:07.591]                             if (is.null(name)) 
[16:05:07.591]                               next
[16:05:07.591]                             if (!grepl(pattern, name)) 
[16:05:07.591]                               next
[16:05:07.591]                             invokeRestart(restart)
[16:05:07.591]                             muffled <- TRUE
[16:05:07.591]                             break
[16:05:07.591]                           }
[16:05:07.591]                         }
[16:05:07.591]                       }
[16:05:07.591]                       invisible(muffled)
[16:05:07.591]                     }
[16:05:07.591]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.591]                   }
[16:05:07.591]                 }
[16:05:07.591]             }
[16:05:07.591]         }))
[16:05:07.591]     }, error = function(ex) {
[16:05:07.591]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:07.591]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.591]                 ...future.rng), started = ...future.startTime, 
[16:05:07.591]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:07.591]             version = "1.8"), class = "FutureResult")
[16:05:07.591]     }, finally = {
[16:05:07.591]         if (!identical(...future.workdir, getwd())) 
[16:05:07.591]             setwd(...future.workdir)
[16:05:07.591]         {
[16:05:07.591]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:07.591]                 ...future.oldOptions$nwarnings <- NULL
[16:05:07.591]             }
[16:05:07.591]             base::options(...future.oldOptions)
[16:05:07.591]             if (.Platform$OS.type == "windows") {
[16:05:07.591]                 old_names <- names(...future.oldEnvVars)
[16:05:07.591]                 envs <- base::Sys.getenv()
[16:05:07.591]                 names <- names(envs)
[16:05:07.591]                 common <- intersect(names, old_names)
[16:05:07.591]                 added <- setdiff(names, old_names)
[16:05:07.591]                 removed <- setdiff(old_names, names)
[16:05:07.591]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:07.591]                   envs[common]]
[16:05:07.591]                 NAMES <- toupper(changed)
[16:05:07.591]                 args <- list()
[16:05:07.591]                 for (kk in seq_along(NAMES)) {
[16:05:07.591]                   name <- changed[[kk]]
[16:05:07.591]                   NAME <- NAMES[[kk]]
[16:05:07.591]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.591]                     next
[16:05:07.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.591]                 }
[16:05:07.591]                 NAMES <- toupper(added)
[16:05:07.591]                 for (kk in seq_along(NAMES)) {
[16:05:07.591]                   name <- added[[kk]]
[16:05:07.591]                   NAME <- NAMES[[kk]]
[16:05:07.591]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.591]                     next
[16:05:07.591]                   args[[name]] <- ""
[16:05:07.591]                 }
[16:05:07.591]                 NAMES <- toupper(removed)
[16:05:07.591]                 for (kk in seq_along(NAMES)) {
[16:05:07.591]                   name <- removed[[kk]]
[16:05:07.591]                   NAME <- NAMES[[kk]]
[16:05:07.591]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.591]                     next
[16:05:07.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.591]                 }
[16:05:07.591]                 if (length(args) > 0) 
[16:05:07.591]                   base::do.call(base::Sys.setenv, args = args)
[16:05:07.591]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:07.591]             }
[16:05:07.591]             else {
[16:05:07.591]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:07.591]             }
[16:05:07.591]             {
[16:05:07.591]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:07.591]                   0L) {
[16:05:07.591]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:07.591]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:07.591]                   base::options(opts)
[16:05:07.591]                 }
[16:05:07.591]                 {
[16:05:07.591]                   {
[16:05:07.591]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:07.591]                     NULL
[16:05:07.591]                   }
[16:05:07.591]                   options(future.plan = NULL)
[16:05:07.591]                   if (is.na(NA_character_)) 
[16:05:07.591]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.591]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:07.591]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:07.591]                     envir = parent.frame()) 
[16:05:07.591]                   {
[16:05:07.591]                     default_workers <- missing(workers)
[16:05:07.591]                     if (is.function(workers)) 
[16:05:07.591]                       workers <- workers()
[16:05:07.591]                     workers <- structure(as.integer(workers), 
[16:05:07.591]                       class = class(workers))
[16:05:07.591]                     stop_if_not(is.finite(workers), workers >= 
[16:05:07.591]                       1L)
[16:05:07.591]                     if ((workers == 1L && !inherits(workers, 
[16:05:07.591]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:07.591]                       if (default_workers) 
[16:05:07.591]                         supportsMulticore(warn = TRUE)
[16:05:07.591]                       return(sequential(..., envir = envir))
[16:05:07.591]                     }
[16:05:07.591]                     oopts <- options(mc.cores = workers)
[16:05:07.591]                     on.exit(options(oopts))
[16:05:07.591]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:07.591]                       envir = envir)
[16:05:07.591]                     if (!future$lazy) 
[16:05:07.591]                       future <- run(future)
[16:05:07.591]                     invisible(future)
[16:05:07.591]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:07.591]                 }
[16:05:07.591]             }
[16:05:07.591]         }
[16:05:07.591]     })
[16:05:07.591]     if (TRUE) {
[16:05:07.591]         base::sink(type = "output", split = FALSE)
[16:05:07.591]         if (TRUE) {
[16:05:07.591]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:07.591]         }
[16:05:07.591]         else {
[16:05:07.591]             ...future.result["stdout"] <- base::list(NULL)
[16:05:07.591]         }
[16:05:07.591]         base::close(...future.stdout)
[16:05:07.591]         ...future.stdout <- NULL
[16:05:07.591]     }
[16:05:07.591]     ...future.result$conditions <- ...future.conditions
[16:05:07.591]     ...future.result$finished <- base::Sys.time()
[16:05:07.591]     ...future.result
[16:05:07.591] }
[16:05:07.594] assign_globals() ...
[16:05:07.594] List of 1
[16:05:07.594]  $ a: num 3
[16:05:07.594]  - attr(*, "where")=List of 1
[16:05:07.594]   ..$ a:<environment: R_EmptyEnv> 
[16:05:07.594]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:07.594]  - attr(*, "resolved")= logi TRUE
[16:05:07.594]  - attr(*, "total_size")= num 56
[16:05:07.594]  - attr(*, "already-done")= logi TRUE
[16:05:07.597] - copied ‘a’ to environment
[16:05:07.597] assign_globals() ... done
[16:05:07.598] requestCore(): workers = 2
[16:05:07.600] MulticoreFuture started
[16:05:07.600] - Launch lazy future ... done
[16:05:07.600] run() for ‘MulticoreFuture’ ... done
[16:05:07.601] result() for MulticoreFuture ...
[16:05:07.601] plan(): Setting new future strategy stack:
[16:05:07.601] List of future strategies:
[16:05:07.601] 1. sequential:
[16:05:07.601]    - args: function (..., envir = parent.frame())
[16:05:07.601]    - tweaked: FALSE
[16:05:07.601]    - call: NULL
[16:05:07.602] plan(): nbrOfWorkers() = 1
[16:05:07.605] plan(): Setting new future strategy stack:
[16:05:07.605] List of future strategies:
[16:05:07.605] 1. multicore:
[16:05:07.605]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.605]    - tweaked: FALSE
[16:05:07.605]    - call: plan(strategy)
[16:05:07.610] plan(): nbrOfWorkers() = 2
[16:05:07.611] result() for MulticoreFuture ...
[16:05:07.611] result() for MulticoreFuture ... done
[16:05:07.612] result() for MulticoreFuture ... done
[16:05:07.612] result() for MulticoreFuture ...
[16:05:07.612] result() for MulticoreFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.614] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.614] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:07.617] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:07.617] Searching for globals ... DONE
[16:05:07.617] Resolving globals: TRUE
[16:05:07.617] Resolving any globals that are futures ...
[16:05:07.617] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:07.617] Resolving any globals that are futures ... DONE
[16:05:07.618] Resolving futures part of globals (recursively) ...
[16:05:07.618] resolve() on list ...
[16:05:07.618]  recursive: 99
[16:05:07.618]  length: 2
[16:05:07.619]  elements: ‘a’, ‘ii’
[16:05:07.619]  length: 1 (resolved future 1)
[16:05:07.619]  length: 0 (resolved future 2)
[16:05:07.619] resolve() on list ... DONE
[16:05:07.619] - globals: [2] ‘a’, ‘ii’
[16:05:07.619] Resolving futures part of globals (recursively) ... DONE
[16:05:07.620] The total size of the 2 globals is 112 bytes (112 bytes)
[16:05:07.620] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:05:07.620] - globals: [2] ‘a’, ‘ii’
[16:05:07.621] 
[16:05:07.621] getGlobalsAndPackages() ... DONE
[16:05:07.621] run() for ‘Future’ ...
[16:05:07.621] - state: ‘created’
[16:05:07.621] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:07.626] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:07.626] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:07.626]   - Field: ‘label’
[16:05:07.626]   - Field: ‘local’
[16:05:07.626]   - Field: ‘owner’
[16:05:07.626]   - Field: ‘envir’
[16:05:07.626]   - Field: ‘workers’
[16:05:07.626]   - Field: ‘packages’
[16:05:07.627]   - Field: ‘gc’
[16:05:07.627]   - Field: ‘job’
[16:05:07.627]   - Field: ‘conditions’
[16:05:07.627]   - Field: ‘expr’
[16:05:07.627]   - Field: ‘uuid’
[16:05:07.627]   - Field: ‘seed’
[16:05:07.627]   - Field: ‘version’
[16:05:07.627]   - Field: ‘result’
[16:05:07.628]   - Field: ‘asynchronous’
[16:05:07.628]   - Field: ‘calls’
[16:05:07.628]   - Field: ‘globals’
[16:05:07.628]   - Field: ‘stdout’
[16:05:07.628]   - Field: ‘earlySignal’
[16:05:07.628]   - Field: ‘lazy’
[16:05:07.628]   - Field: ‘state’
[16:05:07.628] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:07.628] - Launch lazy future ...
[16:05:07.629] Packages needed by the future expression (n = 0): <none>
[16:05:07.629] Packages needed by future strategies (n = 0): <none>
[16:05:07.629] {
[16:05:07.629]     {
[16:05:07.629]         {
[16:05:07.629]             ...future.startTime <- base::Sys.time()
[16:05:07.629]             {
[16:05:07.629]                 {
[16:05:07.629]                   {
[16:05:07.629]                     {
[16:05:07.629]                       base::local({
[16:05:07.629]                         has_future <- base::requireNamespace("future", 
[16:05:07.629]                           quietly = TRUE)
[16:05:07.629]                         if (has_future) {
[16:05:07.629]                           ns <- base::getNamespace("future")
[16:05:07.629]                           version <- ns[[".package"]][["version"]]
[16:05:07.629]                           if (is.null(version)) 
[16:05:07.629]                             version <- utils::packageVersion("future")
[16:05:07.629]                         }
[16:05:07.629]                         else {
[16:05:07.629]                           version <- NULL
[16:05:07.629]                         }
[16:05:07.629]                         if (!has_future || version < "1.8.0") {
[16:05:07.629]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:07.629]                             "", base::R.version$version.string), 
[16:05:07.629]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:07.629]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:07.629]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:07.629]                               "release", "version")], collapse = " "), 
[16:05:07.629]                             hostname = base::Sys.info()[["nodename"]])
[16:05:07.629]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:07.629]                             info)
[16:05:07.629]                           info <- base::paste(info, collapse = "; ")
[16:05:07.629]                           if (!has_future) {
[16:05:07.629]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:07.629]                               info)
[16:05:07.629]                           }
[16:05:07.629]                           else {
[16:05:07.629]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:07.629]                               info, version)
[16:05:07.629]                           }
[16:05:07.629]                           base::stop(msg)
[16:05:07.629]                         }
[16:05:07.629]                       })
[16:05:07.629]                     }
[16:05:07.629]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:07.629]                     base::options(mc.cores = 1L)
[16:05:07.629]                   }
[16:05:07.629]                   options(future.plan = NULL)
[16:05:07.629]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.629]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:07.629]                 }
[16:05:07.629]                 ...future.workdir <- getwd()
[16:05:07.629]             }
[16:05:07.629]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:07.629]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:07.629]         }
[16:05:07.629]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:07.629]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:07.629]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:07.629]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:07.629]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:07.629]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:07.629]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:07.629]             base::names(...future.oldOptions))
[16:05:07.629]     }
[16:05:07.629]     if (FALSE) {
[16:05:07.629]     }
[16:05:07.629]     else {
[16:05:07.629]         if (TRUE) {
[16:05:07.629]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:07.629]                 open = "w")
[16:05:07.629]         }
[16:05:07.629]         else {
[16:05:07.629]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:07.629]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:07.629]         }
[16:05:07.629]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:07.629]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:07.629]             base::sink(type = "output", split = FALSE)
[16:05:07.629]             base::close(...future.stdout)
[16:05:07.629]         }, add = TRUE)
[16:05:07.629]     }
[16:05:07.629]     ...future.frame <- base::sys.nframe()
[16:05:07.629]     ...future.conditions <- base::list()
[16:05:07.629]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:07.629]     if (FALSE) {
[16:05:07.629]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:07.629]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:07.629]     }
[16:05:07.629]     ...future.result <- base::tryCatch({
[16:05:07.629]         base::withCallingHandlers({
[16:05:07.629]             ...future.value <- base::withVisible(base::local({
[16:05:07.629]                 withCallingHandlers({
[16:05:07.629]                   {
[16:05:07.629]                     b <- a * ii
[16:05:07.629]                     a <- 0
[16:05:07.629]                     b
[16:05:07.629]                   }
[16:05:07.629]                 }, immediateCondition = function(cond) {
[16:05:07.629]                   save_rds <- function (object, pathname, ...) 
[16:05:07.629]                   {
[16:05:07.629]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:07.629]                     if (file_test("-f", pathname_tmp)) {
[16:05:07.629]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.629]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:07.629]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.629]                         fi_tmp[["mtime"]])
[16:05:07.629]                     }
[16:05:07.629]                     tryCatch({
[16:05:07.629]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:07.629]                     }, error = function(ex) {
[16:05:07.629]                       msg <- conditionMessage(ex)
[16:05:07.629]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.629]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:07.629]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.629]                         fi_tmp[["mtime"]], msg)
[16:05:07.629]                       ex$message <- msg
[16:05:07.629]                       stop(ex)
[16:05:07.629]                     })
[16:05:07.629]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:07.629]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:07.629]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:07.629]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.629]                       fi <- file.info(pathname)
[16:05:07.629]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:07.629]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.629]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:07.629]                         fi[["size"]], fi[["mtime"]])
[16:05:07.629]                       stop(msg)
[16:05:07.629]                     }
[16:05:07.629]                     invisible(pathname)
[16:05:07.629]                   }
[16:05:07.629]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:07.629]                     rootPath = tempdir()) 
[16:05:07.629]                   {
[16:05:07.629]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:07.629]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:07.629]                       tmpdir = path, fileext = ".rds")
[16:05:07.629]                     save_rds(obj, file)
[16:05:07.629]                   }
[16:05:07.629]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:07.629]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.629]                   {
[16:05:07.629]                     inherits <- base::inherits
[16:05:07.629]                     invokeRestart <- base::invokeRestart
[16:05:07.629]                     is.null <- base::is.null
[16:05:07.629]                     muffled <- FALSE
[16:05:07.629]                     if (inherits(cond, "message")) {
[16:05:07.629]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:07.629]                       if (muffled) 
[16:05:07.629]                         invokeRestart("muffleMessage")
[16:05:07.629]                     }
[16:05:07.629]                     else if (inherits(cond, "warning")) {
[16:05:07.629]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:07.629]                       if (muffled) 
[16:05:07.629]                         invokeRestart("muffleWarning")
[16:05:07.629]                     }
[16:05:07.629]                     else if (inherits(cond, "condition")) {
[16:05:07.629]                       if (!is.null(pattern)) {
[16:05:07.629]                         computeRestarts <- base::computeRestarts
[16:05:07.629]                         grepl <- base::grepl
[16:05:07.629]                         restarts <- computeRestarts(cond)
[16:05:07.629]                         for (restart in restarts) {
[16:05:07.629]                           name <- restart$name
[16:05:07.629]                           if (is.null(name)) 
[16:05:07.629]                             next
[16:05:07.629]                           if (!grepl(pattern, name)) 
[16:05:07.629]                             next
[16:05:07.629]                           invokeRestart(restart)
[16:05:07.629]                           muffled <- TRUE
[16:05:07.629]                           break
[16:05:07.629]                         }
[16:05:07.629]                       }
[16:05:07.629]                     }
[16:05:07.629]                     invisible(muffled)
[16:05:07.629]                   }
[16:05:07.629]                   muffleCondition(cond)
[16:05:07.629]                 })
[16:05:07.629]             }))
[16:05:07.629]             future::FutureResult(value = ...future.value$value, 
[16:05:07.629]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.629]                   ...future.rng), globalenv = if (FALSE) 
[16:05:07.629]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:07.629]                     ...future.globalenv.names))
[16:05:07.629]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:07.629]         }, condition = base::local({
[16:05:07.629]             c <- base::c
[16:05:07.629]             inherits <- base::inherits
[16:05:07.629]             invokeRestart <- base::invokeRestart
[16:05:07.629]             length <- base::length
[16:05:07.629]             list <- base::list
[16:05:07.629]             seq.int <- base::seq.int
[16:05:07.629]             signalCondition <- base::signalCondition
[16:05:07.629]             sys.calls <- base::sys.calls
[16:05:07.629]             `[[` <- base::`[[`
[16:05:07.629]             `+` <- base::`+`
[16:05:07.629]             `<<-` <- base::`<<-`
[16:05:07.629]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:07.629]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:07.629]                   3L)]
[16:05:07.629]             }
[16:05:07.629]             function(cond) {
[16:05:07.629]                 is_error <- inherits(cond, "error")
[16:05:07.629]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:07.629]                   NULL)
[16:05:07.629]                 if (is_error) {
[16:05:07.629]                   sessionInformation <- function() {
[16:05:07.629]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:07.629]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:07.629]                       search = base::search(), system = base::Sys.info())
[16:05:07.629]                   }
[16:05:07.629]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.629]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:07.629]                     cond$call), session = sessionInformation(), 
[16:05:07.629]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:07.629]                   signalCondition(cond)
[16:05:07.629]                 }
[16:05:07.629]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:07.629]                 "immediateCondition"))) {
[16:05:07.629]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:07.629]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.629]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:07.629]                   if (TRUE && !signal) {
[16:05:07.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.629]                     {
[16:05:07.629]                       inherits <- base::inherits
[16:05:07.629]                       invokeRestart <- base::invokeRestart
[16:05:07.629]                       is.null <- base::is.null
[16:05:07.629]                       muffled <- FALSE
[16:05:07.629]                       if (inherits(cond, "message")) {
[16:05:07.629]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.629]                         if (muffled) 
[16:05:07.629]                           invokeRestart("muffleMessage")
[16:05:07.629]                       }
[16:05:07.629]                       else if (inherits(cond, "warning")) {
[16:05:07.629]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.629]                         if (muffled) 
[16:05:07.629]                           invokeRestart("muffleWarning")
[16:05:07.629]                       }
[16:05:07.629]                       else if (inherits(cond, "condition")) {
[16:05:07.629]                         if (!is.null(pattern)) {
[16:05:07.629]                           computeRestarts <- base::computeRestarts
[16:05:07.629]                           grepl <- base::grepl
[16:05:07.629]                           restarts <- computeRestarts(cond)
[16:05:07.629]                           for (restart in restarts) {
[16:05:07.629]                             name <- restart$name
[16:05:07.629]                             if (is.null(name)) 
[16:05:07.629]                               next
[16:05:07.629]                             if (!grepl(pattern, name)) 
[16:05:07.629]                               next
[16:05:07.629]                             invokeRestart(restart)
[16:05:07.629]                             muffled <- TRUE
[16:05:07.629]                             break
[16:05:07.629]                           }
[16:05:07.629]                         }
[16:05:07.629]                       }
[16:05:07.629]                       invisible(muffled)
[16:05:07.629]                     }
[16:05:07.629]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.629]                   }
[16:05:07.629]                 }
[16:05:07.629]                 else {
[16:05:07.629]                   if (TRUE) {
[16:05:07.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.629]                     {
[16:05:07.629]                       inherits <- base::inherits
[16:05:07.629]                       invokeRestart <- base::invokeRestart
[16:05:07.629]                       is.null <- base::is.null
[16:05:07.629]                       muffled <- FALSE
[16:05:07.629]                       if (inherits(cond, "message")) {
[16:05:07.629]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.629]                         if (muffled) 
[16:05:07.629]                           invokeRestart("muffleMessage")
[16:05:07.629]                       }
[16:05:07.629]                       else if (inherits(cond, "warning")) {
[16:05:07.629]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.629]                         if (muffled) 
[16:05:07.629]                           invokeRestart("muffleWarning")
[16:05:07.629]                       }
[16:05:07.629]                       else if (inherits(cond, "condition")) {
[16:05:07.629]                         if (!is.null(pattern)) {
[16:05:07.629]                           computeRestarts <- base::computeRestarts
[16:05:07.629]                           grepl <- base::grepl
[16:05:07.629]                           restarts <- computeRestarts(cond)
[16:05:07.629]                           for (restart in restarts) {
[16:05:07.629]                             name <- restart$name
[16:05:07.629]                             if (is.null(name)) 
[16:05:07.629]                               next
[16:05:07.629]                             if (!grepl(pattern, name)) 
[16:05:07.629]                               next
[16:05:07.629]                             invokeRestart(restart)
[16:05:07.629]                             muffled <- TRUE
[16:05:07.629]                             break
[16:05:07.629]                           }
[16:05:07.629]                         }
[16:05:07.629]                       }
[16:05:07.629]                       invisible(muffled)
[16:05:07.629]                     }
[16:05:07.629]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.629]                   }
[16:05:07.629]                 }
[16:05:07.629]             }
[16:05:07.629]         }))
[16:05:07.629]     }, error = function(ex) {
[16:05:07.629]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:07.629]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.629]                 ...future.rng), started = ...future.startTime, 
[16:05:07.629]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:07.629]             version = "1.8"), class = "FutureResult")
[16:05:07.629]     }, finally = {
[16:05:07.629]         if (!identical(...future.workdir, getwd())) 
[16:05:07.629]             setwd(...future.workdir)
[16:05:07.629]         {
[16:05:07.629]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:07.629]                 ...future.oldOptions$nwarnings <- NULL
[16:05:07.629]             }
[16:05:07.629]             base::options(...future.oldOptions)
[16:05:07.629]             if (.Platform$OS.type == "windows") {
[16:05:07.629]                 old_names <- names(...future.oldEnvVars)
[16:05:07.629]                 envs <- base::Sys.getenv()
[16:05:07.629]                 names <- names(envs)
[16:05:07.629]                 common <- intersect(names, old_names)
[16:05:07.629]                 added <- setdiff(names, old_names)
[16:05:07.629]                 removed <- setdiff(old_names, names)
[16:05:07.629]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:07.629]                   envs[common]]
[16:05:07.629]                 NAMES <- toupper(changed)
[16:05:07.629]                 args <- list()
[16:05:07.629]                 for (kk in seq_along(NAMES)) {
[16:05:07.629]                   name <- changed[[kk]]
[16:05:07.629]                   NAME <- NAMES[[kk]]
[16:05:07.629]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.629]                     next
[16:05:07.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.629]                 }
[16:05:07.629]                 NAMES <- toupper(added)
[16:05:07.629]                 for (kk in seq_along(NAMES)) {
[16:05:07.629]                   name <- added[[kk]]
[16:05:07.629]                   NAME <- NAMES[[kk]]
[16:05:07.629]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.629]                     next
[16:05:07.629]                   args[[name]] <- ""
[16:05:07.629]                 }
[16:05:07.629]                 NAMES <- toupper(removed)
[16:05:07.629]                 for (kk in seq_along(NAMES)) {
[16:05:07.629]                   name <- removed[[kk]]
[16:05:07.629]                   NAME <- NAMES[[kk]]
[16:05:07.629]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.629]                     next
[16:05:07.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.629]                 }
[16:05:07.629]                 if (length(args) > 0) 
[16:05:07.629]                   base::do.call(base::Sys.setenv, args = args)
[16:05:07.629]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:07.629]             }
[16:05:07.629]             else {
[16:05:07.629]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:07.629]             }
[16:05:07.629]             {
[16:05:07.629]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:07.629]                   0L) {
[16:05:07.629]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:07.629]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:07.629]                   base::options(opts)
[16:05:07.629]                 }
[16:05:07.629]                 {
[16:05:07.629]                   {
[16:05:07.629]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:07.629]                     NULL
[16:05:07.629]                   }
[16:05:07.629]                   options(future.plan = NULL)
[16:05:07.629]                   if (is.na(NA_character_)) 
[16:05:07.629]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.629]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:07.629]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:07.629]                     envir = parent.frame()) 
[16:05:07.629]                   {
[16:05:07.629]                     default_workers <- missing(workers)
[16:05:07.629]                     if (is.function(workers)) 
[16:05:07.629]                       workers <- workers()
[16:05:07.629]                     workers <- structure(as.integer(workers), 
[16:05:07.629]                       class = class(workers))
[16:05:07.629]                     stop_if_not(is.finite(workers), workers >= 
[16:05:07.629]                       1L)
[16:05:07.629]                     if ((workers == 1L && !inherits(workers, 
[16:05:07.629]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:07.629]                       if (default_workers) 
[16:05:07.629]                         supportsMulticore(warn = TRUE)
[16:05:07.629]                       return(sequential(..., envir = envir))
[16:05:07.629]                     }
[16:05:07.629]                     oopts <- options(mc.cores = workers)
[16:05:07.629]                     on.exit(options(oopts))
[16:05:07.629]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:07.629]                       envir = envir)
[16:05:07.629]                     if (!future$lazy) 
[16:05:07.629]                       future <- run(future)
[16:05:07.629]                     invisible(future)
[16:05:07.629]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:07.629]                 }
[16:05:07.629]             }
[16:05:07.629]         }
[16:05:07.629]     })
[16:05:07.629]     if (TRUE) {
[16:05:07.629]         base::sink(type = "output", split = FALSE)
[16:05:07.629]         if (TRUE) {
[16:05:07.629]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:07.629]         }
[16:05:07.629]         else {
[16:05:07.629]             ...future.result["stdout"] <- base::list(NULL)
[16:05:07.629]         }
[16:05:07.629]         base::close(...future.stdout)
[16:05:07.629]         ...future.stdout <- NULL
[16:05:07.629]     }
[16:05:07.629]     ...future.result$conditions <- ...future.conditions
[16:05:07.629]     ...future.result$finished <- base::Sys.time()
[16:05:07.629]     ...future.result
[16:05:07.629] }
[16:05:07.632] assign_globals() ...
[16:05:07.633] List of 2
[16:05:07.633]  $ a : num 1
[16:05:07.633]  $ ii: int 1
[16:05:07.633]  - attr(*, "where")=List of 2
[16:05:07.633]   ..$ a :<environment: R_EmptyEnv> 
[16:05:07.633]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:07.633]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:07.633]  - attr(*, "resolved")= logi TRUE
[16:05:07.633]  - attr(*, "total_size")= num 112
[16:05:07.633]  - attr(*, "already-done")= logi TRUE
[16:05:07.639] - copied ‘a’ to environment
[16:05:07.639] - copied ‘ii’ to environment
[16:05:07.639] assign_globals() ... done
[16:05:07.640] requestCore(): workers = 2
[16:05:07.642] MulticoreFuture started
[16:05:07.643] - Launch lazy future ... done
[16:05:07.643] run() for ‘MulticoreFuture’ ... done
[16:05:07.644] plan(): Setting new future strategy stack:
[16:05:07.644] List of future strategies:
[16:05:07.644] 1. sequential:
[16:05:07.644]    - args: function (..., envir = parent.frame())
[16:05:07.644]    - tweaked: FALSE
[16:05:07.644]    - call: NULL
[16:05:07.645] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.646] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.646] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:07.648] plan(): Setting new future strategy stack:
[16:05:07.648] List of future strategies:
[16:05:07.648] 1. multicore:
[16:05:07.648]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.648]    - tweaked: FALSE
[16:05:07.648]    - call: plan(strategy)
[16:05:07.652] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:07.652] Searching for globals ... DONE
[16:05:07.652] Resolving globals: TRUE
[16:05:07.653] Resolving any globals that are futures ...
[16:05:07.653] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:07.653] Resolving any globals that are futures ... DONE
[16:05:07.653] plan(): nbrOfWorkers() = 2
[16:05:07.654] Resolving futures part of globals (recursively) ...
[16:05:07.655] resolve() on list ...
[16:05:07.655]  recursive: 99
[16:05:07.655]  length: 2
[16:05:07.655]  elements: ‘a’, ‘ii’
[16:05:07.655]  length: 1 (resolved future 1)
[16:05:07.655]  length: 0 (resolved future 2)
[16:05:07.656] resolve() on list ... DONE
[16:05:07.656] - globals: [2] ‘a’, ‘ii’
[16:05:07.656] Resolving futures part of globals (recursively) ... DONE
[16:05:07.656] The total size of the 2 globals is 112 bytes (112 bytes)
[16:05:07.657] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:05:07.657] - globals: [2] ‘a’, ‘ii’
[16:05:07.657] 
[16:05:07.657] getGlobalsAndPackages() ... DONE
[16:05:07.658] run() for ‘Future’ ...
[16:05:07.658] - state: ‘created’
[16:05:07.658] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:07.662] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:07.663] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:07.663]   - Field: ‘label’
[16:05:07.663]   - Field: ‘local’
[16:05:07.663]   - Field: ‘owner’
[16:05:07.663]   - Field: ‘envir’
[16:05:07.663]   - Field: ‘workers’
[16:05:07.663]   - Field: ‘packages’
[16:05:07.664]   - Field: ‘gc’
[16:05:07.664]   - Field: ‘job’
[16:05:07.664]   - Field: ‘conditions’
[16:05:07.664]   - Field: ‘expr’
[16:05:07.664]   - Field: ‘uuid’
[16:05:07.664]   - Field: ‘seed’
[16:05:07.664]   - Field: ‘version’
[16:05:07.664]   - Field: ‘result’
[16:05:07.665]   - Field: ‘asynchronous’
[16:05:07.665]   - Field: ‘calls’
[16:05:07.665]   - Field: ‘globals’
[16:05:07.665]   - Field: ‘stdout’
[16:05:07.665]   - Field: ‘earlySignal’
[16:05:07.665]   - Field: ‘lazy’
[16:05:07.665]   - Field: ‘state’
[16:05:07.665] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:07.666] - Launch lazy future ...
[16:05:07.666] Packages needed by the future expression (n = 0): <none>
[16:05:07.666] Packages needed by future strategies (n = 0): <none>
[16:05:07.667] {
[16:05:07.667]     {
[16:05:07.667]         {
[16:05:07.667]             ...future.startTime <- base::Sys.time()
[16:05:07.667]             {
[16:05:07.667]                 {
[16:05:07.667]                   {
[16:05:07.667]                     {
[16:05:07.667]                       base::local({
[16:05:07.667]                         has_future <- base::requireNamespace("future", 
[16:05:07.667]                           quietly = TRUE)
[16:05:07.667]                         if (has_future) {
[16:05:07.667]                           ns <- base::getNamespace("future")
[16:05:07.667]                           version <- ns[[".package"]][["version"]]
[16:05:07.667]                           if (is.null(version)) 
[16:05:07.667]                             version <- utils::packageVersion("future")
[16:05:07.667]                         }
[16:05:07.667]                         else {
[16:05:07.667]                           version <- NULL
[16:05:07.667]                         }
[16:05:07.667]                         if (!has_future || version < "1.8.0") {
[16:05:07.667]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:07.667]                             "", base::R.version$version.string), 
[16:05:07.667]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:07.667]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:07.667]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:07.667]                               "release", "version")], collapse = " "), 
[16:05:07.667]                             hostname = base::Sys.info()[["nodename"]])
[16:05:07.667]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:07.667]                             info)
[16:05:07.667]                           info <- base::paste(info, collapse = "; ")
[16:05:07.667]                           if (!has_future) {
[16:05:07.667]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:07.667]                               info)
[16:05:07.667]                           }
[16:05:07.667]                           else {
[16:05:07.667]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:07.667]                               info, version)
[16:05:07.667]                           }
[16:05:07.667]                           base::stop(msg)
[16:05:07.667]                         }
[16:05:07.667]                       })
[16:05:07.667]                     }
[16:05:07.667]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:07.667]                     base::options(mc.cores = 1L)
[16:05:07.667]                   }
[16:05:07.667]                   options(future.plan = NULL)
[16:05:07.667]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.667]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:07.667]                 }
[16:05:07.667]                 ...future.workdir <- getwd()
[16:05:07.667]             }
[16:05:07.667]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:07.667]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:07.667]         }
[16:05:07.667]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:07.667]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:07.667]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:07.667]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:07.667]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:07.667]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:07.667]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:07.667]             base::names(...future.oldOptions))
[16:05:07.667]     }
[16:05:07.667]     if (FALSE) {
[16:05:07.667]     }
[16:05:07.667]     else {
[16:05:07.667]         if (TRUE) {
[16:05:07.667]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:07.667]                 open = "w")
[16:05:07.667]         }
[16:05:07.667]         else {
[16:05:07.667]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:07.667]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:07.667]         }
[16:05:07.667]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:07.667]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:07.667]             base::sink(type = "output", split = FALSE)
[16:05:07.667]             base::close(...future.stdout)
[16:05:07.667]         }, add = TRUE)
[16:05:07.667]     }
[16:05:07.667]     ...future.frame <- base::sys.nframe()
[16:05:07.667]     ...future.conditions <- base::list()
[16:05:07.667]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:07.667]     if (FALSE) {
[16:05:07.667]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:07.667]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:07.667]     }
[16:05:07.667]     ...future.result <- base::tryCatch({
[16:05:07.667]         base::withCallingHandlers({
[16:05:07.667]             ...future.value <- base::withVisible(base::local({
[16:05:07.667]                 withCallingHandlers({
[16:05:07.667]                   {
[16:05:07.667]                     b <- a * ii
[16:05:07.667]                     a <- 0
[16:05:07.667]                     b
[16:05:07.667]                   }
[16:05:07.667]                 }, immediateCondition = function(cond) {
[16:05:07.667]                   save_rds <- function (object, pathname, ...) 
[16:05:07.667]                   {
[16:05:07.667]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:07.667]                     if (file_test("-f", pathname_tmp)) {
[16:05:07.667]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.667]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:07.667]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.667]                         fi_tmp[["mtime"]])
[16:05:07.667]                     }
[16:05:07.667]                     tryCatch({
[16:05:07.667]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:07.667]                     }, error = function(ex) {
[16:05:07.667]                       msg <- conditionMessage(ex)
[16:05:07.667]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.667]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:07.667]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.667]                         fi_tmp[["mtime"]], msg)
[16:05:07.667]                       ex$message <- msg
[16:05:07.667]                       stop(ex)
[16:05:07.667]                     })
[16:05:07.667]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:07.667]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:07.667]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:07.667]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.667]                       fi <- file.info(pathname)
[16:05:07.667]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:07.667]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.667]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:07.667]                         fi[["size"]], fi[["mtime"]])
[16:05:07.667]                       stop(msg)
[16:05:07.667]                     }
[16:05:07.667]                     invisible(pathname)
[16:05:07.667]                   }
[16:05:07.667]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:07.667]                     rootPath = tempdir()) 
[16:05:07.667]                   {
[16:05:07.667]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:07.667]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:07.667]                       tmpdir = path, fileext = ".rds")
[16:05:07.667]                     save_rds(obj, file)
[16:05:07.667]                   }
[16:05:07.667]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:07.667]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.667]                   {
[16:05:07.667]                     inherits <- base::inherits
[16:05:07.667]                     invokeRestart <- base::invokeRestart
[16:05:07.667]                     is.null <- base::is.null
[16:05:07.667]                     muffled <- FALSE
[16:05:07.667]                     if (inherits(cond, "message")) {
[16:05:07.667]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:07.667]                       if (muffled) 
[16:05:07.667]                         invokeRestart("muffleMessage")
[16:05:07.667]                     }
[16:05:07.667]                     else if (inherits(cond, "warning")) {
[16:05:07.667]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:07.667]                       if (muffled) 
[16:05:07.667]                         invokeRestart("muffleWarning")
[16:05:07.667]                     }
[16:05:07.667]                     else if (inherits(cond, "condition")) {
[16:05:07.667]                       if (!is.null(pattern)) {
[16:05:07.667]                         computeRestarts <- base::computeRestarts
[16:05:07.667]                         grepl <- base::grepl
[16:05:07.667]                         restarts <- computeRestarts(cond)
[16:05:07.667]                         for (restart in restarts) {
[16:05:07.667]                           name <- restart$name
[16:05:07.667]                           if (is.null(name)) 
[16:05:07.667]                             next
[16:05:07.667]                           if (!grepl(pattern, name)) 
[16:05:07.667]                             next
[16:05:07.667]                           invokeRestart(restart)
[16:05:07.667]                           muffled <- TRUE
[16:05:07.667]                           break
[16:05:07.667]                         }
[16:05:07.667]                       }
[16:05:07.667]                     }
[16:05:07.667]                     invisible(muffled)
[16:05:07.667]                   }
[16:05:07.667]                   muffleCondition(cond)
[16:05:07.667]                 })
[16:05:07.667]             }))
[16:05:07.667]             future::FutureResult(value = ...future.value$value, 
[16:05:07.667]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.667]                   ...future.rng), globalenv = if (FALSE) 
[16:05:07.667]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:07.667]                     ...future.globalenv.names))
[16:05:07.667]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:07.667]         }, condition = base::local({
[16:05:07.667]             c <- base::c
[16:05:07.667]             inherits <- base::inherits
[16:05:07.667]             invokeRestart <- base::invokeRestart
[16:05:07.667]             length <- base::length
[16:05:07.667]             list <- base::list
[16:05:07.667]             seq.int <- base::seq.int
[16:05:07.667]             signalCondition <- base::signalCondition
[16:05:07.667]             sys.calls <- base::sys.calls
[16:05:07.667]             `[[` <- base::`[[`
[16:05:07.667]             `+` <- base::`+`
[16:05:07.667]             `<<-` <- base::`<<-`
[16:05:07.667]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:07.667]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:07.667]                   3L)]
[16:05:07.667]             }
[16:05:07.667]             function(cond) {
[16:05:07.667]                 is_error <- inherits(cond, "error")
[16:05:07.667]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:07.667]                   NULL)
[16:05:07.667]                 if (is_error) {
[16:05:07.667]                   sessionInformation <- function() {
[16:05:07.667]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:07.667]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:07.667]                       search = base::search(), system = base::Sys.info())
[16:05:07.667]                   }
[16:05:07.667]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.667]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:07.667]                     cond$call), session = sessionInformation(), 
[16:05:07.667]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:07.667]                   signalCondition(cond)
[16:05:07.667]                 }
[16:05:07.667]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:07.667]                 "immediateCondition"))) {
[16:05:07.667]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:07.667]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.667]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:07.667]                   if (TRUE && !signal) {
[16:05:07.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.667]                     {
[16:05:07.667]                       inherits <- base::inherits
[16:05:07.667]                       invokeRestart <- base::invokeRestart
[16:05:07.667]                       is.null <- base::is.null
[16:05:07.667]                       muffled <- FALSE
[16:05:07.667]                       if (inherits(cond, "message")) {
[16:05:07.667]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.667]                         if (muffled) 
[16:05:07.667]                           invokeRestart("muffleMessage")
[16:05:07.667]                       }
[16:05:07.667]                       else if (inherits(cond, "warning")) {
[16:05:07.667]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.667]                         if (muffled) 
[16:05:07.667]                           invokeRestart("muffleWarning")
[16:05:07.667]                       }
[16:05:07.667]                       else if (inherits(cond, "condition")) {
[16:05:07.667]                         if (!is.null(pattern)) {
[16:05:07.667]                           computeRestarts <- base::computeRestarts
[16:05:07.667]                           grepl <- base::grepl
[16:05:07.667]                           restarts <- computeRestarts(cond)
[16:05:07.667]                           for (restart in restarts) {
[16:05:07.667]                             name <- restart$name
[16:05:07.667]                             if (is.null(name)) 
[16:05:07.667]                               next
[16:05:07.667]                             if (!grepl(pattern, name)) 
[16:05:07.667]                               next
[16:05:07.667]                             invokeRestart(restart)
[16:05:07.667]                             muffled <- TRUE
[16:05:07.667]                             break
[16:05:07.667]                           }
[16:05:07.667]                         }
[16:05:07.667]                       }
[16:05:07.667]                       invisible(muffled)
[16:05:07.667]                     }
[16:05:07.667]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.667]                   }
[16:05:07.667]                 }
[16:05:07.667]                 else {
[16:05:07.667]                   if (TRUE) {
[16:05:07.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.667]                     {
[16:05:07.667]                       inherits <- base::inherits
[16:05:07.667]                       invokeRestart <- base::invokeRestart
[16:05:07.667]                       is.null <- base::is.null
[16:05:07.667]                       muffled <- FALSE
[16:05:07.667]                       if (inherits(cond, "message")) {
[16:05:07.667]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.667]                         if (muffled) 
[16:05:07.667]                           invokeRestart("muffleMessage")
[16:05:07.667]                       }
[16:05:07.667]                       else if (inherits(cond, "warning")) {
[16:05:07.667]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.667]                         if (muffled) 
[16:05:07.667]                           invokeRestart("muffleWarning")
[16:05:07.667]                       }
[16:05:07.667]                       else if (inherits(cond, "condition")) {
[16:05:07.667]                         if (!is.null(pattern)) {
[16:05:07.667]                           computeRestarts <- base::computeRestarts
[16:05:07.667]                           grepl <- base::grepl
[16:05:07.667]                           restarts <- computeRestarts(cond)
[16:05:07.667]                           for (restart in restarts) {
[16:05:07.667]                             name <- restart$name
[16:05:07.667]                             if (is.null(name)) 
[16:05:07.667]                               next
[16:05:07.667]                             if (!grepl(pattern, name)) 
[16:05:07.667]                               next
[16:05:07.667]                             invokeRestart(restart)
[16:05:07.667]                             muffled <- TRUE
[16:05:07.667]                             break
[16:05:07.667]                           }
[16:05:07.667]                         }
[16:05:07.667]                       }
[16:05:07.667]                       invisible(muffled)
[16:05:07.667]                     }
[16:05:07.667]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.667]                   }
[16:05:07.667]                 }
[16:05:07.667]             }
[16:05:07.667]         }))
[16:05:07.667]     }, error = function(ex) {
[16:05:07.667]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:07.667]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.667]                 ...future.rng), started = ...future.startTime, 
[16:05:07.667]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:07.667]             version = "1.8"), class = "FutureResult")
[16:05:07.667]     }, finally = {
[16:05:07.667]         if (!identical(...future.workdir, getwd())) 
[16:05:07.667]             setwd(...future.workdir)
[16:05:07.667]         {
[16:05:07.667]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:07.667]                 ...future.oldOptions$nwarnings <- NULL
[16:05:07.667]             }
[16:05:07.667]             base::options(...future.oldOptions)
[16:05:07.667]             if (.Platform$OS.type == "windows") {
[16:05:07.667]                 old_names <- names(...future.oldEnvVars)
[16:05:07.667]                 envs <- base::Sys.getenv()
[16:05:07.667]                 names <- names(envs)
[16:05:07.667]                 common <- intersect(names, old_names)
[16:05:07.667]                 added <- setdiff(names, old_names)
[16:05:07.667]                 removed <- setdiff(old_names, names)
[16:05:07.667]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:07.667]                   envs[common]]
[16:05:07.667]                 NAMES <- toupper(changed)
[16:05:07.667]                 args <- list()
[16:05:07.667]                 for (kk in seq_along(NAMES)) {
[16:05:07.667]                   name <- changed[[kk]]
[16:05:07.667]                   NAME <- NAMES[[kk]]
[16:05:07.667]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.667]                     next
[16:05:07.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.667]                 }
[16:05:07.667]                 NAMES <- toupper(added)
[16:05:07.667]                 for (kk in seq_along(NAMES)) {
[16:05:07.667]                   name <- added[[kk]]
[16:05:07.667]                   NAME <- NAMES[[kk]]
[16:05:07.667]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.667]                     next
[16:05:07.667]                   args[[name]] <- ""
[16:05:07.667]                 }
[16:05:07.667]                 NAMES <- toupper(removed)
[16:05:07.667]                 for (kk in seq_along(NAMES)) {
[16:05:07.667]                   name <- removed[[kk]]
[16:05:07.667]                   NAME <- NAMES[[kk]]
[16:05:07.667]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.667]                     next
[16:05:07.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.667]                 }
[16:05:07.667]                 if (length(args) > 0) 
[16:05:07.667]                   base::do.call(base::Sys.setenv, args = args)
[16:05:07.667]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:07.667]             }
[16:05:07.667]             else {
[16:05:07.667]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:07.667]             }
[16:05:07.667]             {
[16:05:07.667]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:07.667]                   0L) {
[16:05:07.667]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:07.667]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:07.667]                   base::options(opts)
[16:05:07.667]                 }
[16:05:07.667]                 {
[16:05:07.667]                   {
[16:05:07.667]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:07.667]                     NULL
[16:05:07.667]                   }
[16:05:07.667]                   options(future.plan = NULL)
[16:05:07.667]                   if (is.na(NA_character_)) 
[16:05:07.667]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.667]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:07.667]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:07.667]                     envir = parent.frame()) 
[16:05:07.667]                   {
[16:05:07.667]                     default_workers <- missing(workers)
[16:05:07.667]                     if (is.function(workers)) 
[16:05:07.667]                       workers <- workers()
[16:05:07.667]                     workers <- structure(as.integer(workers), 
[16:05:07.667]                       class = class(workers))
[16:05:07.667]                     stop_if_not(is.finite(workers), workers >= 
[16:05:07.667]                       1L)
[16:05:07.667]                     if ((workers == 1L && !inherits(workers, 
[16:05:07.667]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:07.667]                       if (default_workers) 
[16:05:07.667]                         supportsMulticore(warn = TRUE)
[16:05:07.667]                       return(sequential(..., envir = envir))
[16:05:07.667]                     }
[16:05:07.667]                     oopts <- options(mc.cores = workers)
[16:05:07.667]                     on.exit(options(oopts))
[16:05:07.667]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:07.667]                       envir = envir)
[16:05:07.667]                     if (!future$lazy) 
[16:05:07.667]                       future <- run(future)
[16:05:07.667]                     invisible(future)
[16:05:07.667]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:07.667]                 }
[16:05:07.667]             }
[16:05:07.667]         }
[16:05:07.667]     })
[16:05:07.667]     if (TRUE) {
[16:05:07.667]         base::sink(type = "output", split = FALSE)
[16:05:07.667]         if (TRUE) {
[16:05:07.667]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:07.667]         }
[16:05:07.667]         else {
[16:05:07.667]             ...future.result["stdout"] <- base::list(NULL)
[16:05:07.667]         }
[16:05:07.667]         base::close(...future.stdout)
[16:05:07.667]         ...future.stdout <- NULL
[16:05:07.667]     }
[16:05:07.667]     ...future.result$conditions <- ...future.conditions
[16:05:07.667]     ...future.result$finished <- base::Sys.time()
[16:05:07.667]     ...future.result
[16:05:07.667] }
[16:05:07.670] assign_globals() ...
[16:05:07.670] List of 2
[16:05:07.670]  $ a : num 1
[16:05:07.670]  $ ii: int 2
[16:05:07.670]  - attr(*, "where")=List of 2
[16:05:07.670]   ..$ a :<environment: R_EmptyEnv> 
[16:05:07.670]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:07.670]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:07.670]  - attr(*, "resolved")= logi TRUE
[16:05:07.670]  - attr(*, "total_size")= num 112
[16:05:07.670]  - attr(*, "already-done")= logi TRUE
[16:05:07.675] - copied ‘a’ to environment
[16:05:07.675] - copied ‘ii’ to environment
[16:05:07.675] assign_globals() ... done
[16:05:07.675] requestCore(): workers = 2
[16:05:07.677] MulticoreFuture started
[16:05:07.678] - Launch lazy future ... done
[16:05:07.678] run() for ‘MulticoreFuture’ ... done
[16:05:07.679] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.679] getGlobalsAndPackages() ...
[16:05:07.679] List of future strategies:
[16:05:07.679] 1. sequential:
[16:05:07.679]    - args: function (..., envir = parent.frame())
[16:05:07.679]    - tweaked: FALSE
[16:05:07.679]    - call: NULL
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.680] Searching for globals...
[16:05:07.680] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:07.682] plan(): Setting new future strategy stack:
[16:05:07.682] List of future strategies:
[16:05:07.682] 1. multicore:
[16:05:07.682]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.682]    - tweaked: FALSE
[16:05:07.682]    - call: plan(strategy)
[16:05:07.692] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:07.692] plan(): nbrOfWorkers() = 2
[16:05:07.692] Searching for globals ... DONE
[16:05:07.692] Resolving globals: TRUE
[16:05:07.692] Resolving any globals that are futures ...
[16:05:07.693] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:07.693] Resolving any globals that are futures ... DONE
[16:05:07.694] Resolving futures part of globals (recursively) ...
[16:05:07.695] resolve() on list ...
[16:05:07.695]  recursive: 99
[16:05:07.695]  length: 2
[16:05:07.695]  elements: ‘a’, ‘ii’
[16:05:07.696]  length: 1 (resolved future 1)
[16:05:07.696]  length: 0 (resolved future 2)
[16:05:07.696] resolve() on list ... DONE
[16:05:07.696] - globals: [2] ‘a’, ‘ii’
[16:05:07.697] Resolving futures part of globals (recursively) ... DONE
[16:05:07.697] The total size of the 2 globals is 112 bytes (112 bytes)
[16:05:07.698] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:05:07.698] - globals: [2] ‘a’, ‘ii’
[16:05:07.698] 
[16:05:07.698] getGlobalsAndPackages() ... DONE
[16:05:07.699] run() for ‘Future’ ...
[16:05:07.699] - state: ‘created’
[16:05:07.699] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:07.704] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:07.704] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:07.704]   - Field: ‘label’
[16:05:07.704]   - Field: ‘local’
[16:05:07.704]   - Field: ‘owner’
[16:05:07.704]   - Field: ‘envir’
[16:05:07.705]   - Field: ‘workers’
[16:05:07.705]   - Field: ‘packages’
[16:05:07.705]   - Field: ‘gc’
[16:05:07.705]   - Field: ‘job’
[16:05:07.705]   - Field: ‘conditions’
[16:05:07.705]   - Field: ‘expr’
[16:05:07.705]   - Field: ‘uuid’
[16:05:07.706]   - Field: ‘seed’
[16:05:07.706]   - Field: ‘version’
[16:05:07.706]   - Field: ‘result’
[16:05:07.706]   - Field: ‘asynchronous’
[16:05:07.706]   - Field: ‘calls’
[16:05:07.706]   - Field: ‘globals’
[16:05:07.706]   - Field: ‘stdout’
[16:05:07.707]   - Field: ‘earlySignal’
[16:05:07.707]   - Field: ‘lazy’
[16:05:07.707]   - Field: ‘state’
[16:05:07.707] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:07.707] - Launch lazy future ...
[16:05:07.707] Packages needed by the future expression (n = 0): <none>
[16:05:07.708] Packages needed by future strategies (n = 0): <none>
[16:05:07.708] {
[16:05:07.708]     {
[16:05:07.708]         {
[16:05:07.708]             ...future.startTime <- base::Sys.time()
[16:05:07.708]             {
[16:05:07.708]                 {
[16:05:07.708]                   {
[16:05:07.708]                     {
[16:05:07.708]                       base::local({
[16:05:07.708]                         has_future <- base::requireNamespace("future", 
[16:05:07.708]                           quietly = TRUE)
[16:05:07.708]                         if (has_future) {
[16:05:07.708]                           ns <- base::getNamespace("future")
[16:05:07.708]                           version <- ns[[".package"]][["version"]]
[16:05:07.708]                           if (is.null(version)) 
[16:05:07.708]                             version <- utils::packageVersion("future")
[16:05:07.708]                         }
[16:05:07.708]                         else {
[16:05:07.708]                           version <- NULL
[16:05:07.708]                         }
[16:05:07.708]                         if (!has_future || version < "1.8.0") {
[16:05:07.708]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:07.708]                             "", base::R.version$version.string), 
[16:05:07.708]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:07.708]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:07.708]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:07.708]                               "release", "version")], collapse = " "), 
[16:05:07.708]                             hostname = base::Sys.info()[["nodename"]])
[16:05:07.708]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:07.708]                             info)
[16:05:07.708]                           info <- base::paste(info, collapse = "; ")
[16:05:07.708]                           if (!has_future) {
[16:05:07.708]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:07.708]                               info)
[16:05:07.708]                           }
[16:05:07.708]                           else {
[16:05:07.708]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:07.708]                               info, version)
[16:05:07.708]                           }
[16:05:07.708]                           base::stop(msg)
[16:05:07.708]                         }
[16:05:07.708]                       })
[16:05:07.708]                     }
[16:05:07.708]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:07.708]                     base::options(mc.cores = 1L)
[16:05:07.708]                   }
[16:05:07.708]                   options(future.plan = NULL)
[16:05:07.708]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.708]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:07.708]                 }
[16:05:07.708]                 ...future.workdir <- getwd()
[16:05:07.708]             }
[16:05:07.708]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:07.708]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:07.708]         }
[16:05:07.708]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:07.708]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:07.708]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:07.708]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:07.708]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:07.708]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:07.708]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:07.708]             base::names(...future.oldOptions))
[16:05:07.708]     }
[16:05:07.708]     if (FALSE) {
[16:05:07.708]     }
[16:05:07.708]     else {
[16:05:07.708]         if (TRUE) {
[16:05:07.708]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:07.708]                 open = "w")
[16:05:07.708]         }
[16:05:07.708]         else {
[16:05:07.708]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:07.708]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:07.708]         }
[16:05:07.708]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:07.708]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:07.708]             base::sink(type = "output", split = FALSE)
[16:05:07.708]             base::close(...future.stdout)
[16:05:07.708]         }, add = TRUE)
[16:05:07.708]     }
[16:05:07.708]     ...future.frame <- base::sys.nframe()
[16:05:07.708]     ...future.conditions <- base::list()
[16:05:07.708]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:07.708]     if (FALSE) {
[16:05:07.708]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:07.708]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:07.708]     }
[16:05:07.708]     ...future.result <- base::tryCatch({
[16:05:07.708]         base::withCallingHandlers({
[16:05:07.708]             ...future.value <- base::withVisible(base::local({
[16:05:07.708]                 withCallingHandlers({
[16:05:07.708]                   {
[16:05:07.708]                     b <- a * ii
[16:05:07.708]                     a <- 0
[16:05:07.708]                     b
[16:05:07.708]                   }
[16:05:07.708]                 }, immediateCondition = function(cond) {
[16:05:07.708]                   save_rds <- function (object, pathname, ...) 
[16:05:07.708]                   {
[16:05:07.708]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:07.708]                     if (file_test("-f", pathname_tmp)) {
[16:05:07.708]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.708]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:07.708]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.708]                         fi_tmp[["mtime"]])
[16:05:07.708]                     }
[16:05:07.708]                     tryCatch({
[16:05:07.708]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:07.708]                     }, error = function(ex) {
[16:05:07.708]                       msg <- conditionMessage(ex)
[16:05:07.708]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.708]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:07.708]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.708]                         fi_tmp[["mtime"]], msg)
[16:05:07.708]                       ex$message <- msg
[16:05:07.708]                       stop(ex)
[16:05:07.708]                     })
[16:05:07.708]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:07.708]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:07.708]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:07.708]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.708]                       fi <- file.info(pathname)
[16:05:07.708]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:07.708]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.708]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:07.708]                         fi[["size"]], fi[["mtime"]])
[16:05:07.708]                       stop(msg)
[16:05:07.708]                     }
[16:05:07.708]                     invisible(pathname)
[16:05:07.708]                   }
[16:05:07.708]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:07.708]                     rootPath = tempdir()) 
[16:05:07.708]                   {
[16:05:07.708]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:07.708]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:07.708]                       tmpdir = path, fileext = ".rds")
[16:05:07.708]                     save_rds(obj, file)
[16:05:07.708]                   }
[16:05:07.708]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:07.708]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.708]                   {
[16:05:07.708]                     inherits <- base::inherits
[16:05:07.708]                     invokeRestart <- base::invokeRestart
[16:05:07.708]                     is.null <- base::is.null
[16:05:07.708]                     muffled <- FALSE
[16:05:07.708]                     if (inherits(cond, "message")) {
[16:05:07.708]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:07.708]                       if (muffled) 
[16:05:07.708]                         invokeRestart("muffleMessage")
[16:05:07.708]                     }
[16:05:07.708]                     else if (inherits(cond, "warning")) {
[16:05:07.708]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:07.708]                       if (muffled) 
[16:05:07.708]                         invokeRestart("muffleWarning")
[16:05:07.708]                     }
[16:05:07.708]                     else if (inherits(cond, "condition")) {
[16:05:07.708]                       if (!is.null(pattern)) {
[16:05:07.708]                         computeRestarts <- base::computeRestarts
[16:05:07.708]                         grepl <- base::grepl
[16:05:07.708]                         restarts <- computeRestarts(cond)
[16:05:07.708]                         for (restart in restarts) {
[16:05:07.708]                           name <- restart$name
[16:05:07.708]                           if (is.null(name)) 
[16:05:07.708]                             next
[16:05:07.708]                           if (!grepl(pattern, name)) 
[16:05:07.708]                             next
[16:05:07.708]                           invokeRestart(restart)
[16:05:07.708]                           muffled <- TRUE
[16:05:07.708]                           break
[16:05:07.708]                         }
[16:05:07.708]                       }
[16:05:07.708]                     }
[16:05:07.708]                     invisible(muffled)
[16:05:07.708]                   }
[16:05:07.708]                   muffleCondition(cond)
[16:05:07.708]                 })
[16:05:07.708]             }))
[16:05:07.708]             future::FutureResult(value = ...future.value$value, 
[16:05:07.708]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.708]                   ...future.rng), globalenv = if (FALSE) 
[16:05:07.708]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:07.708]                     ...future.globalenv.names))
[16:05:07.708]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:07.708]         }, condition = base::local({
[16:05:07.708]             c <- base::c
[16:05:07.708]             inherits <- base::inherits
[16:05:07.708]             invokeRestart <- base::invokeRestart
[16:05:07.708]             length <- base::length
[16:05:07.708]             list <- base::list
[16:05:07.708]             seq.int <- base::seq.int
[16:05:07.708]             signalCondition <- base::signalCondition
[16:05:07.708]             sys.calls <- base::sys.calls
[16:05:07.708]             `[[` <- base::`[[`
[16:05:07.708]             `+` <- base::`+`
[16:05:07.708]             `<<-` <- base::`<<-`
[16:05:07.708]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:07.708]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:07.708]                   3L)]
[16:05:07.708]             }
[16:05:07.708]             function(cond) {
[16:05:07.708]                 is_error <- inherits(cond, "error")
[16:05:07.708]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:07.708]                   NULL)
[16:05:07.708]                 if (is_error) {
[16:05:07.708]                   sessionInformation <- function() {
[16:05:07.708]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:07.708]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:07.708]                       search = base::search(), system = base::Sys.info())
[16:05:07.708]                   }
[16:05:07.708]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.708]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:07.708]                     cond$call), session = sessionInformation(), 
[16:05:07.708]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:07.708]                   signalCondition(cond)
[16:05:07.708]                 }
[16:05:07.708]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:07.708]                 "immediateCondition"))) {
[16:05:07.708]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:07.708]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.708]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:07.708]                   if (TRUE && !signal) {
[16:05:07.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.708]                     {
[16:05:07.708]                       inherits <- base::inherits
[16:05:07.708]                       invokeRestart <- base::invokeRestart
[16:05:07.708]                       is.null <- base::is.null
[16:05:07.708]                       muffled <- FALSE
[16:05:07.708]                       if (inherits(cond, "message")) {
[16:05:07.708]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.708]                         if (muffled) 
[16:05:07.708]                           invokeRestart("muffleMessage")
[16:05:07.708]                       }
[16:05:07.708]                       else if (inherits(cond, "warning")) {
[16:05:07.708]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.708]                         if (muffled) 
[16:05:07.708]                           invokeRestart("muffleWarning")
[16:05:07.708]                       }
[16:05:07.708]                       else if (inherits(cond, "condition")) {
[16:05:07.708]                         if (!is.null(pattern)) {
[16:05:07.708]                           computeRestarts <- base::computeRestarts
[16:05:07.708]                           grepl <- base::grepl
[16:05:07.708]                           restarts <- computeRestarts(cond)
[16:05:07.708]                           for (restart in restarts) {
[16:05:07.708]                             name <- restart$name
[16:05:07.708]                             if (is.null(name)) 
[16:05:07.708]                               next
[16:05:07.708]                             if (!grepl(pattern, name)) 
[16:05:07.708]                               next
[16:05:07.708]                             invokeRestart(restart)
[16:05:07.708]                             muffled <- TRUE
[16:05:07.708]                             break
[16:05:07.708]                           }
[16:05:07.708]                         }
[16:05:07.708]                       }
[16:05:07.708]                       invisible(muffled)
[16:05:07.708]                     }
[16:05:07.708]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.708]                   }
[16:05:07.708]                 }
[16:05:07.708]                 else {
[16:05:07.708]                   if (TRUE) {
[16:05:07.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.708]                     {
[16:05:07.708]                       inherits <- base::inherits
[16:05:07.708]                       invokeRestart <- base::invokeRestart
[16:05:07.708]                       is.null <- base::is.null
[16:05:07.708]                       muffled <- FALSE
[16:05:07.708]                       if (inherits(cond, "message")) {
[16:05:07.708]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.708]                         if (muffled) 
[16:05:07.708]                           invokeRestart("muffleMessage")
[16:05:07.708]                       }
[16:05:07.708]                       else if (inherits(cond, "warning")) {
[16:05:07.708]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.708]                         if (muffled) 
[16:05:07.708]                           invokeRestart("muffleWarning")
[16:05:07.708]                       }
[16:05:07.708]                       else if (inherits(cond, "condition")) {
[16:05:07.708]                         if (!is.null(pattern)) {
[16:05:07.708]                           computeRestarts <- base::computeRestarts
[16:05:07.708]                           grepl <- base::grepl
[16:05:07.708]                           restarts <- computeRestarts(cond)
[16:05:07.708]                           for (restart in restarts) {
[16:05:07.708]                             name <- restart$name
[16:05:07.708]                             if (is.null(name)) 
[16:05:07.708]                               next
[16:05:07.708]                             if (!grepl(pattern, name)) 
[16:05:07.708]                               next
[16:05:07.708]                             invokeRestart(restart)
[16:05:07.708]                             muffled <- TRUE
[16:05:07.708]                             break
[16:05:07.708]                           }
[16:05:07.708]                         }
[16:05:07.708]                       }
[16:05:07.708]                       invisible(muffled)
[16:05:07.708]                     }
[16:05:07.708]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.708]                   }
[16:05:07.708]                 }
[16:05:07.708]             }
[16:05:07.708]         }))
[16:05:07.708]     }, error = function(ex) {
[16:05:07.708]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:07.708]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.708]                 ...future.rng), started = ...future.startTime, 
[16:05:07.708]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:07.708]             version = "1.8"), class = "FutureResult")
[16:05:07.708]     }, finally = {
[16:05:07.708]         if (!identical(...future.workdir, getwd())) 
[16:05:07.708]             setwd(...future.workdir)
[16:05:07.708]         {
[16:05:07.708]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:07.708]                 ...future.oldOptions$nwarnings <- NULL
[16:05:07.708]             }
[16:05:07.708]             base::options(...future.oldOptions)
[16:05:07.708]             if (.Platform$OS.type == "windows") {
[16:05:07.708]                 old_names <- names(...future.oldEnvVars)
[16:05:07.708]                 envs <- base::Sys.getenv()
[16:05:07.708]                 names <- names(envs)
[16:05:07.708]                 common <- intersect(names, old_names)
[16:05:07.708]                 added <- setdiff(names, old_names)
[16:05:07.708]                 removed <- setdiff(old_names, names)
[16:05:07.708]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:07.708]                   envs[common]]
[16:05:07.708]                 NAMES <- toupper(changed)
[16:05:07.708]                 args <- list()
[16:05:07.708]                 for (kk in seq_along(NAMES)) {
[16:05:07.708]                   name <- changed[[kk]]
[16:05:07.708]                   NAME <- NAMES[[kk]]
[16:05:07.708]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.708]                     next
[16:05:07.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.708]                 }
[16:05:07.708]                 NAMES <- toupper(added)
[16:05:07.708]                 for (kk in seq_along(NAMES)) {
[16:05:07.708]                   name <- added[[kk]]
[16:05:07.708]                   NAME <- NAMES[[kk]]
[16:05:07.708]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.708]                     next
[16:05:07.708]                   args[[name]] <- ""
[16:05:07.708]                 }
[16:05:07.708]                 NAMES <- toupper(removed)
[16:05:07.708]                 for (kk in seq_along(NAMES)) {
[16:05:07.708]                   name <- removed[[kk]]
[16:05:07.708]                   NAME <- NAMES[[kk]]
[16:05:07.708]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.708]                     next
[16:05:07.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.708]                 }
[16:05:07.708]                 if (length(args) > 0) 
[16:05:07.708]                   base::do.call(base::Sys.setenv, args = args)
[16:05:07.708]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:07.708]             }
[16:05:07.708]             else {
[16:05:07.708]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:07.708]             }
[16:05:07.708]             {
[16:05:07.708]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:07.708]                   0L) {
[16:05:07.708]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:07.708]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:07.708]                   base::options(opts)
[16:05:07.708]                 }
[16:05:07.708]                 {
[16:05:07.708]                   {
[16:05:07.708]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:07.708]                     NULL
[16:05:07.708]                   }
[16:05:07.708]                   options(future.plan = NULL)
[16:05:07.708]                   if (is.na(NA_character_)) 
[16:05:07.708]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.708]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:07.708]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:07.708]                     envir = parent.frame()) 
[16:05:07.708]                   {
[16:05:07.708]                     default_workers <- missing(workers)
[16:05:07.708]                     if (is.function(workers)) 
[16:05:07.708]                       workers <- workers()
[16:05:07.708]                     workers <- structure(as.integer(workers), 
[16:05:07.708]                       class = class(workers))
[16:05:07.708]                     stop_if_not(is.finite(workers), workers >= 
[16:05:07.708]                       1L)
[16:05:07.708]                     if ((workers == 1L && !inherits(workers, 
[16:05:07.708]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:07.708]                       if (default_workers) 
[16:05:07.708]                         supportsMulticore(warn = TRUE)
[16:05:07.708]                       return(sequential(..., envir = envir))
[16:05:07.708]                     }
[16:05:07.708]                     oopts <- options(mc.cores = workers)
[16:05:07.708]                     on.exit(options(oopts))
[16:05:07.708]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:07.708]                       envir = envir)
[16:05:07.708]                     if (!future$lazy) 
[16:05:07.708]                       future <- run(future)
[16:05:07.708]                     invisible(future)
[16:05:07.708]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:07.708]                 }
[16:05:07.708]             }
[16:05:07.708]         }
[16:05:07.708]     })
[16:05:07.708]     if (TRUE) {
[16:05:07.708]         base::sink(type = "output", split = FALSE)
[16:05:07.708]         if (TRUE) {
[16:05:07.708]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:07.708]         }
[16:05:07.708]         else {
[16:05:07.708]             ...future.result["stdout"] <- base::list(NULL)
[16:05:07.708]         }
[16:05:07.708]         base::close(...future.stdout)
[16:05:07.708]         ...future.stdout <- NULL
[16:05:07.708]     }
[16:05:07.708]     ...future.result$conditions <- ...future.conditions
[16:05:07.708]     ...future.result$finished <- base::Sys.time()
[16:05:07.708]     ...future.result
[16:05:07.708] }
[16:05:07.711] assign_globals() ...
[16:05:07.711] List of 2
[16:05:07.711]  $ a : num 1
[16:05:07.711]  $ ii: int 3
[16:05:07.711]  - attr(*, "where")=List of 2
[16:05:07.711]   ..$ a :<environment: R_EmptyEnv> 
[16:05:07.711]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:07.711]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:07.711]  - attr(*, "resolved")= logi TRUE
[16:05:07.711]  - attr(*, "total_size")= num 112
[16:05:07.711]  - attr(*, "already-done")= logi TRUE
[16:05:07.715] - copied ‘a’ to environment
[16:05:07.715] - copied ‘ii’ to environment
[16:05:07.715] assign_globals() ... done
[16:05:07.715] requestCore(): workers = 2
[16:05:07.716] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:07.738] result() for MulticoreFuture ...
[16:05:07.739] result() for MulticoreFuture ...
[16:05:07.739] result() for MulticoreFuture ... done
[16:05:07.739] result() for MulticoreFuture ... done
[16:05:07.739] result() for MulticoreFuture ...
[16:05:07.739] result() for MulticoreFuture ... done
[16:05:07.742] MulticoreFuture started
[16:05:07.742] - Launch lazy future ... done
[16:05:07.743] run() for ‘MulticoreFuture’ ... done
[16:05:07.743] plan(): Setting new future strategy stack:
[16:05:07.744] result() for MulticoreFuture ...
[16:05:07.744] result() for MulticoreFuture ... done
[16:05:07.743] List of future strategies:
[16:05:07.743] 1. sequential:
[16:05:07.743]    - args: function (..., envir = parent.frame())
[16:05:07.743]    - tweaked: FALSE
[16:05:07.743]    - call: NULL
[16:05:07.744] result() for MulticoreFuture ...
[16:05:07.745] plan(): nbrOfWorkers() = 1
[16:05:07.745] result() for MulticoreFuture ... done
[16:05:07.745] result() for MulticoreFuture ...
[16:05:07.747] result() for MulticoreFuture ...
[16:05:07.747] result() for MulticoreFuture ... done
[16:05:07.748] result() for MulticoreFuture ... done
[16:05:07.748] plan(): Setting new future strategy stack:
[16:05:07.748] result() for MulticoreFuture ...
[16:05:07.748] result() for MulticoreFuture ... done
[16:05:07.748] List of future strategies:
[16:05:07.748] 1. multicore:
[16:05:07.748]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.748]    - tweaked: FALSE
[16:05:07.748]    - call: plan(strategy)
[16:05:07.749] result() for MulticoreFuture ...
[16:05:07.753] plan(): nbrOfWorkers() = 2
[16:05:07.754] result() for MulticoreFuture ...
[16:05:07.754] result() for MulticoreFuture ... done
[16:05:07.754] result() for MulticoreFuture ... done
[16:05:07.754] result() for MulticoreFuture ...
[16:05:07.754] result() for MulticoreFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.756] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.756] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:07.759] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:07.759] Searching for globals ... DONE
[16:05:07.759] Resolving globals: TRUE
[16:05:07.759] Resolving any globals that are futures ...
[16:05:07.759] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:07.760] Resolving any globals that are futures ... DONE
[16:05:07.760] Resolving futures part of globals (recursively) ...
[16:05:07.760] resolve() on list ...
[16:05:07.761]  recursive: 99
[16:05:07.761]  length: 2
[16:05:07.761]  elements: ‘a’, ‘ii’
[16:05:07.761]  length: 1 (resolved future 1)
[16:05:07.761]  length: 0 (resolved future 2)
[16:05:07.761] resolve() on list ... DONE
[16:05:07.761] - globals: [2] ‘a’, ‘ii’
[16:05:07.761] Resolving futures part of globals (recursively) ... DONE
[16:05:07.762] The total size of the 2 globals is 112 bytes (112 bytes)
[16:05:07.762] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:05:07.762] - globals: [2] ‘a’, ‘ii’
[16:05:07.762] 
[16:05:07.762] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.763] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.764] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:07.766] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:07.766] Searching for globals ... DONE
[16:05:07.766] Resolving globals: TRUE
[16:05:07.766] Resolving any globals that are futures ...
[16:05:07.766] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:07.766] Resolving any globals that are futures ... DONE
[16:05:07.767] Resolving futures part of globals (recursively) ...
[16:05:07.767] resolve() on list ...
[16:05:07.767]  recursive: 99
[16:05:07.770]  length: 2
[16:05:07.770]  elements: ‘a’, ‘ii’
[16:05:07.770]  length: 1 (resolved future 1)
[16:05:07.770]  length: 0 (resolved future 2)
[16:05:07.770] resolve() on list ... DONE
[16:05:07.770] - globals: [2] ‘a’, ‘ii’
[16:05:07.771] Resolving futures part of globals (recursively) ... DONE
[16:05:07.771] The total size of the 2 globals is 112 bytes (112 bytes)
[16:05:07.771] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:05:07.772] - globals: [2] ‘a’, ‘ii’
[16:05:07.772] 
[16:05:07.772] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.773] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.773] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:07.776] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:07.776] Searching for globals ... DONE
[16:05:07.776] Resolving globals: TRUE
[16:05:07.776] Resolving any globals that are futures ...
[16:05:07.776] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:07.777] Resolving any globals that are futures ... DONE
[16:05:07.777] Resolving futures part of globals (recursively) ...
[16:05:07.777] resolve() on list ...
[16:05:07.777]  recursive: 99
[16:05:07.778]  length: 2
[16:05:07.778]  elements: ‘a’, ‘ii’
[16:05:07.778]  length: 1 (resolved future 1)
[16:05:07.778]  length: 0 (resolved future 2)
[16:05:07.778] resolve() on list ... DONE
[16:05:07.778] - globals: [2] ‘a’, ‘ii’
[16:05:07.778] Resolving futures part of globals (recursively) ... DONE
[16:05:07.778] The total size of the 2 globals is 112 bytes (112 bytes)
[16:05:07.779] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:05:07.779] - globals: [2] ‘a’, ‘ii’
[16:05:07.779] 
[16:05:07.779] getGlobalsAndPackages() ... DONE
[16:05:07.780] run() for ‘Future’ ...
[16:05:07.780] - state: ‘created’
[16:05:07.780] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:07.784] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:07.784] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:07.784]   - Field: ‘label’
[16:05:07.784]   - Field: ‘local’
[16:05:07.784]   - Field: ‘owner’
[16:05:07.784]   - Field: ‘envir’
[16:05:07.784]   - Field: ‘workers’
[16:05:07.785]   - Field: ‘packages’
[16:05:07.785]   - Field: ‘gc’
[16:05:07.785]   - Field: ‘job’
[16:05:07.785]   - Field: ‘conditions’
[16:05:07.785]   - Field: ‘expr’
[16:05:07.785]   - Field: ‘uuid’
[16:05:07.785]   - Field: ‘seed’
[16:05:07.785]   - Field: ‘version’
[16:05:07.785]   - Field: ‘result’
[16:05:07.785]   - Field: ‘asynchronous’
[16:05:07.786]   - Field: ‘calls’
[16:05:07.786]   - Field: ‘globals’
[16:05:07.786]   - Field: ‘stdout’
[16:05:07.786]   - Field: ‘earlySignal’
[16:05:07.786]   - Field: ‘lazy’
[16:05:07.786]   - Field: ‘state’
[16:05:07.786] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:07.786] - Launch lazy future ...
[16:05:07.787] Packages needed by the future expression (n = 0): <none>
[16:05:07.787] Packages needed by future strategies (n = 0): <none>
[16:05:07.787] {
[16:05:07.787]     {
[16:05:07.787]         {
[16:05:07.787]             ...future.startTime <- base::Sys.time()
[16:05:07.787]             {
[16:05:07.787]                 {
[16:05:07.787]                   {
[16:05:07.787]                     {
[16:05:07.787]                       base::local({
[16:05:07.787]                         has_future <- base::requireNamespace("future", 
[16:05:07.787]                           quietly = TRUE)
[16:05:07.787]                         if (has_future) {
[16:05:07.787]                           ns <- base::getNamespace("future")
[16:05:07.787]                           version <- ns[[".package"]][["version"]]
[16:05:07.787]                           if (is.null(version)) 
[16:05:07.787]                             version <- utils::packageVersion("future")
[16:05:07.787]                         }
[16:05:07.787]                         else {
[16:05:07.787]                           version <- NULL
[16:05:07.787]                         }
[16:05:07.787]                         if (!has_future || version < "1.8.0") {
[16:05:07.787]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:07.787]                             "", base::R.version$version.string), 
[16:05:07.787]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:07.787]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:07.787]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:07.787]                               "release", "version")], collapse = " "), 
[16:05:07.787]                             hostname = base::Sys.info()[["nodename"]])
[16:05:07.787]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:07.787]                             info)
[16:05:07.787]                           info <- base::paste(info, collapse = "; ")
[16:05:07.787]                           if (!has_future) {
[16:05:07.787]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:07.787]                               info)
[16:05:07.787]                           }
[16:05:07.787]                           else {
[16:05:07.787]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:07.787]                               info, version)
[16:05:07.787]                           }
[16:05:07.787]                           base::stop(msg)
[16:05:07.787]                         }
[16:05:07.787]                       })
[16:05:07.787]                     }
[16:05:07.787]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:07.787]                     base::options(mc.cores = 1L)
[16:05:07.787]                   }
[16:05:07.787]                   options(future.plan = NULL)
[16:05:07.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.787]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:07.787]                 }
[16:05:07.787]                 ...future.workdir <- getwd()
[16:05:07.787]             }
[16:05:07.787]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:07.787]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:07.787]         }
[16:05:07.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:07.787]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:07.787]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:07.787]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:07.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:07.787]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:07.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:07.787]             base::names(...future.oldOptions))
[16:05:07.787]     }
[16:05:07.787]     if (FALSE) {
[16:05:07.787]     }
[16:05:07.787]     else {
[16:05:07.787]         if (TRUE) {
[16:05:07.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:07.787]                 open = "w")
[16:05:07.787]         }
[16:05:07.787]         else {
[16:05:07.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:07.787]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:07.787]         }
[16:05:07.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:07.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:07.787]             base::sink(type = "output", split = FALSE)
[16:05:07.787]             base::close(...future.stdout)
[16:05:07.787]         }, add = TRUE)
[16:05:07.787]     }
[16:05:07.787]     ...future.frame <- base::sys.nframe()
[16:05:07.787]     ...future.conditions <- base::list()
[16:05:07.787]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:07.787]     if (FALSE) {
[16:05:07.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:07.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:07.787]     }
[16:05:07.787]     ...future.result <- base::tryCatch({
[16:05:07.787]         base::withCallingHandlers({
[16:05:07.787]             ...future.value <- base::withVisible(base::local({
[16:05:07.787]                 withCallingHandlers({
[16:05:07.787]                   {
[16:05:07.787]                     b <- a * ii
[16:05:07.787]                     a <- 0
[16:05:07.787]                     b
[16:05:07.787]                   }
[16:05:07.787]                 }, immediateCondition = function(cond) {
[16:05:07.787]                   save_rds <- function (object, pathname, ...) 
[16:05:07.787]                   {
[16:05:07.787]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:07.787]                     if (file_test("-f", pathname_tmp)) {
[16:05:07.787]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.787]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:07.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.787]                         fi_tmp[["mtime"]])
[16:05:07.787]                     }
[16:05:07.787]                     tryCatch({
[16:05:07.787]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:07.787]                     }, error = function(ex) {
[16:05:07.787]                       msg <- conditionMessage(ex)
[16:05:07.787]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.787]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:07.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.787]                         fi_tmp[["mtime"]], msg)
[16:05:07.787]                       ex$message <- msg
[16:05:07.787]                       stop(ex)
[16:05:07.787]                     })
[16:05:07.787]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:07.787]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:07.787]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:07.787]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.787]                       fi <- file.info(pathname)
[16:05:07.787]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:07.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.787]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:07.787]                         fi[["size"]], fi[["mtime"]])
[16:05:07.787]                       stop(msg)
[16:05:07.787]                     }
[16:05:07.787]                     invisible(pathname)
[16:05:07.787]                   }
[16:05:07.787]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:07.787]                     rootPath = tempdir()) 
[16:05:07.787]                   {
[16:05:07.787]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:07.787]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:07.787]                       tmpdir = path, fileext = ".rds")
[16:05:07.787]                     save_rds(obj, file)
[16:05:07.787]                   }
[16:05:07.787]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:07.787]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.787]                   {
[16:05:07.787]                     inherits <- base::inherits
[16:05:07.787]                     invokeRestart <- base::invokeRestart
[16:05:07.787]                     is.null <- base::is.null
[16:05:07.787]                     muffled <- FALSE
[16:05:07.787]                     if (inherits(cond, "message")) {
[16:05:07.787]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:07.787]                       if (muffled) 
[16:05:07.787]                         invokeRestart("muffleMessage")
[16:05:07.787]                     }
[16:05:07.787]                     else if (inherits(cond, "warning")) {
[16:05:07.787]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:07.787]                       if (muffled) 
[16:05:07.787]                         invokeRestart("muffleWarning")
[16:05:07.787]                     }
[16:05:07.787]                     else if (inherits(cond, "condition")) {
[16:05:07.787]                       if (!is.null(pattern)) {
[16:05:07.787]                         computeRestarts <- base::computeRestarts
[16:05:07.787]                         grepl <- base::grepl
[16:05:07.787]                         restarts <- computeRestarts(cond)
[16:05:07.787]                         for (restart in restarts) {
[16:05:07.787]                           name <- restart$name
[16:05:07.787]                           if (is.null(name)) 
[16:05:07.787]                             next
[16:05:07.787]                           if (!grepl(pattern, name)) 
[16:05:07.787]                             next
[16:05:07.787]                           invokeRestart(restart)
[16:05:07.787]                           muffled <- TRUE
[16:05:07.787]                           break
[16:05:07.787]                         }
[16:05:07.787]                       }
[16:05:07.787]                     }
[16:05:07.787]                     invisible(muffled)
[16:05:07.787]                   }
[16:05:07.787]                   muffleCondition(cond)
[16:05:07.787]                 })
[16:05:07.787]             }))
[16:05:07.787]             future::FutureResult(value = ...future.value$value, 
[16:05:07.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.787]                   ...future.rng), globalenv = if (FALSE) 
[16:05:07.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:07.787]                     ...future.globalenv.names))
[16:05:07.787]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:07.787]         }, condition = base::local({
[16:05:07.787]             c <- base::c
[16:05:07.787]             inherits <- base::inherits
[16:05:07.787]             invokeRestart <- base::invokeRestart
[16:05:07.787]             length <- base::length
[16:05:07.787]             list <- base::list
[16:05:07.787]             seq.int <- base::seq.int
[16:05:07.787]             signalCondition <- base::signalCondition
[16:05:07.787]             sys.calls <- base::sys.calls
[16:05:07.787]             `[[` <- base::`[[`
[16:05:07.787]             `+` <- base::`+`
[16:05:07.787]             `<<-` <- base::`<<-`
[16:05:07.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:07.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:07.787]                   3L)]
[16:05:07.787]             }
[16:05:07.787]             function(cond) {
[16:05:07.787]                 is_error <- inherits(cond, "error")
[16:05:07.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:07.787]                   NULL)
[16:05:07.787]                 if (is_error) {
[16:05:07.787]                   sessionInformation <- function() {
[16:05:07.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:07.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:07.787]                       search = base::search(), system = base::Sys.info())
[16:05:07.787]                   }
[16:05:07.787]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:07.787]                     cond$call), session = sessionInformation(), 
[16:05:07.787]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:07.787]                   signalCondition(cond)
[16:05:07.787]                 }
[16:05:07.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:07.787]                 "immediateCondition"))) {
[16:05:07.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:07.787]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:07.787]                   if (TRUE && !signal) {
[16:05:07.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.787]                     {
[16:05:07.787]                       inherits <- base::inherits
[16:05:07.787]                       invokeRestart <- base::invokeRestart
[16:05:07.787]                       is.null <- base::is.null
[16:05:07.787]                       muffled <- FALSE
[16:05:07.787]                       if (inherits(cond, "message")) {
[16:05:07.787]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.787]                         if (muffled) 
[16:05:07.787]                           invokeRestart("muffleMessage")
[16:05:07.787]                       }
[16:05:07.787]                       else if (inherits(cond, "warning")) {
[16:05:07.787]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.787]                         if (muffled) 
[16:05:07.787]                           invokeRestart("muffleWarning")
[16:05:07.787]                       }
[16:05:07.787]                       else if (inherits(cond, "condition")) {
[16:05:07.787]                         if (!is.null(pattern)) {
[16:05:07.787]                           computeRestarts <- base::computeRestarts
[16:05:07.787]                           grepl <- base::grepl
[16:05:07.787]                           restarts <- computeRestarts(cond)
[16:05:07.787]                           for (restart in restarts) {
[16:05:07.787]                             name <- restart$name
[16:05:07.787]                             if (is.null(name)) 
[16:05:07.787]                               next
[16:05:07.787]                             if (!grepl(pattern, name)) 
[16:05:07.787]                               next
[16:05:07.787]                             invokeRestart(restart)
[16:05:07.787]                             muffled <- TRUE
[16:05:07.787]                             break
[16:05:07.787]                           }
[16:05:07.787]                         }
[16:05:07.787]                       }
[16:05:07.787]                       invisible(muffled)
[16:05:07.787]                     }
[16:05:07.787]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.787]                   }
[16:05:07.787]                 }
[16:05:07.787]                 else {
[16:05:07.787]                   if (TRUE) {
[16:05:07.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.787]                     {
[16:05:07.787]                       inherits <- base::inherits
[16:05:07.787]                       invokeRestart <- base::invokeRestart
[16:05:07.787]                       is.null <- base::is.null
[16:05:07.787]                       muffled <- FALSE
[16:05:07.787]                       if (inherits(cond, "message")) {
[16:05:07.787]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.787]                         if (muffled) 
[16:05:07.787]                           invokeRestart("muffleMessage")
[16:05:07.787]                       }
[16:05:07.787]                       else if (inherits(cond, "warning")) {
[16:05:07.787]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.787]                         if (muffled) 
[16:05:07.787]                           invokeRestart("muffleWarning")
[16:05:07.787]                       }
[16:05:07.787]                       else if (inherits(cond, "condition")) {
[16:05:07.787]                         if (!is.null(pattern)) {
[16:05:07.787]                           computeRestarts <- base::computeRestarts
[16:05:07.787]                           grepl <- base::grepl
[16:05:07.787]                           restarts <- computeRestarts(cond)
[16:05:07.787]                           for (restart in restarts) {
[16:05:07.787]                             name <- restart$name
[16:05:07.787]                             if (is.null(name)) 
[16:05:07.787]                               next
[16:05:07.787]                             if (!grepl(pattern, name)) 
[16:05:07.787]                               next
[16:05:07.787]                             invokeRestart(restart)
[16:05:07.787]                             muffled <- TRUE
[16:05:07.787]                             break
[16:05:07.787]                           }
[16:05:07.787]                         }
[16:05:07.787]                       }
[16:05:07.787]                       invisible(muffled)
[16:05:07.787]                     }
[16:05:07.787]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.787]                   }
[16:05:07.787]                 }
[16:05:07.787]             }
[16:05:07.787]         }))
[16:05:07.787]     }, error = function(ex) {
[16:05:07.787]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:07.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.787]                 ...future.rng), started = ...future.startTime, 
[16:05:07.787]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:07.787]             version = "1.8"), class = "FutureResult")
[16:05:07.787]     }, finally = {
[16:05:07.787]         if (!identical(...future.workdir, getwd())) 
[16:05:07.787]             setwd(...future.workdir)
[16:05:07.787]         {
[16:05:07.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:07.787]                 ...future.oldOptions$nwarnings <- NULL
[16:05:07.787]             }
[16:05:07.787]             base::options(...future.oldOptions)
[16:05:07.787]             if (.Platform$OS.type == "windows") {
[16:05:07.787]                 old_names <- names(...future.oldEnvVars)
[16:05:07.787]                 envs <- base::Sys.getenv()
[16:05:07.787]                 names <- names(envs)
[16:05:07.787]                 common <- intersect(names, old_names)
[16:05:07.787]                 added <- setdiff(names, old_names)
[16:05:07.787]                 removed <- setdiff(old_names, names)
[16:05:07.787]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:07.787]                   envs[common]]
[16:05:07.787]                 NAMES <- toupper(changed)
[16:05:07.787]                 args <- list()
[16:05:07.787]                 for (kk in seq_along(NAMES)) {
[16:05:07.787]                   name <- changed[[kk]]
[16:05:07.787]                   NAME <- NAMES[[kk]]
[16:05:07.787]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.787]                     next
[16:05:07.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.787]                 }
[16:05:07.787]                 NAMES <- toupper(added)
[16:05:07.787]                 for (kk in seq_along(NAMES)) {
[16:05:07.787]                   name <- added[[kk]]
[16:05:07.787]                   NAME <- NAMES[[kk]]
[16:05:07.787]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.787]                     next
[16:05:07.787]                   args[[name]] <- ""
[16:05:07.787]                 }
[16:05:07.787]                 NAMES <- toupper(removed)
[16:05:07.787]                 for (kk in seq_along(NAMES)) {
[16:05:07.787]                   name <- removed[[kk]]
[16:05:07.787]                   NAME <- NAMES[[kk]]
[16:05:07.787]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.787]                     next
[16:05:07.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.787]                 }
[16:05:07.787]                 if (length(args) > 0) 
[16:05:07.787]                   base::do.call(base::Sys.setenv, args = args)
[16:05:07.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:07.787]             }
[16:05:07.787]             else {
[16:05:07.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:07.787]             }
[16:05:07.787]             {
[16:05:07.787]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:07.787]                   0L) {
[16:05:07.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:07.787]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:07.787]                   base::options(opts)
[16:05:07.787]                 }
[16:05:07.787]                 {
[16:05:07.787]                   {
[16:05:07.787]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:07.787]                     NULL
[16:05:07.787]                   }
[16:05:07.787]                   options(future.plan = NULL)
[16:05:07.787]                   if (is.na(NA_character_)) 
[16:05:07.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:07.787]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:07.787]                     envir = parent.frame()) 
[16:05:07.787]                   {
[16:05:07.787]                     default_workers <- missing(workers)
[16:05:07.787]                     if (is.function(workers)) 
[16:05:07.787]                       workers <- workers()
[16:05:07.787]                     workers <- structure(as.integer(workers), 
[16:05:07.787]                       class = class(workers))
[16:05:07.787]                     stop_if_not(is.finite(workers), workers >= 
[16:05:07.787]                       1L)
[16:05:07.787]                     if ((workers == 1L && !inherits(workers, 
[16:05:07.787]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:07.787]                       if (default_workers) 
[16:05:07.787]                         supportsMulticore(warn = TRUE)
[16:05:07.787]                       return(sequential(..., envir = envir))
[16:05:07.787]                     }
[16:05:07.787]                     oopts <- options(mc.cores = workers)
[16:05:07.787]                     on.exit(options(oopts))
[16:05:07.787]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:07.787]                       envir = envir)
[16:05:07.787]                     if (!future$lazy) 
[16:05:07.787]                       future <- run(future)
[16:05:07.787]                     invisible(future)
[16:05:07.787]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:07.787]                 }
[16:05:07.787]             }
[16:05:07.787]         }
[16:05:07.787]     })
[16:05:07.787]     if (TRUE) {
[16:05:07.787]         base::sink(type = "output", split = FALSE)
[16:05:07.787]         if (TRUE) {
[16:05:07.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:07.787]         }
[16:05:07.787]         else {
[16:05:07.787]             ...future.result["stdout"] <- base::list(NULL)
[16:05:07.787]         }
[16:05:07.787]         base::close(...future.stdout)
[16:05:07.787]         ...future.stdout <- NULL
[16:05:07.787]     }
[16:05:07.787]     ...future.result$conditions <- ...future.conditions
[16:05:07.787]     ...future.result$finished <- base::Sys.time()
[16:05:07.787]     ...future.result
[16:05:07.787] }
[16:05:07.790] assign_globals() ...
[16:05:07.790] List of 2
[16:05:07.790]  $ a : num 1
[16:05:07.790]  $ ii: int 1
[16:05:07.790]  - attr(*, "where")=List of 2
[16:05:07.790]   ..$ a :<environment: R_EmptyEnv> 
[16:05:07.790]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:07.790]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:07.790]  - attr(*, "resolved")= logi TRUE
[16:05:07.790]  - attr(*, "total_size")= num 112
[16:05:07.790]  - attr(*, "already-done")= logi TRUE
[16:05:07.793] - copied ‘a’ to environment
[16:05:07.793] - copied ‘ii’ to environment
[16:05:07.793] assign_globals() ... done
[16:05:07.794] requestCore(): workers = 2
[16:05:07.796] MulticoreFuture started
[16:05:07.796] - Launch lazy future ... done
[16:05:07.796] run() for ‘MulticoreFuture’ ... done
[16:05:07.797] result() for MulticoreFuture ...
[16:05:07.797] plan(): Setting new future strategy stack:
[16:05:07.797] List of future strategies:
[16:05:07.797] 1. sequential:
[16:05:07.797]    - args: function (..., envir = parent.frame())
[16:05:07.797]    - tweaked: FALSE
[16:05:07.797]    - call: NULL
[16:05:07.798] plan(): nbrOfWorkers() = 1
[16:05:07.800] plan(): Setting new future strategy stack:
[16:05:07.800] List of future strategies:
[16:05:07.800] 1. multicore:
[16:05:07.800]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.800]    - tweaked: FALSE
[16:05:07.800]    - call: plan(strategy)
[16:05:07.810] plan(): nbrOfWorkers() = 2
[16:05:07.812] result() for MulticoreFuture ...
[16:05:07.812] result() for MulticoreFuture ... done
[16:05:07.812] result() for MulticoreFuture ... done
[16:05:07.812] result() for MulticoreFuture ...
[16:05:07.812] result() for MulticoreFuture ... done
[16:05:07.813] run() for ‘Future’ ...
[16:05:07.813] - state: ‘created’
[16:05:07.813] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:07.820] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:07.820] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:07.821]   - Field: ‘label’
[16:05:07.821]   - Field: ‘local’
[16:05:07.821]   - Field: ‘owner’
[16:05:07.821]   - Field: ‘envir’
[16:05:07.821]   - Field: ‘workers’
[16:05:07.822]   - Field: ‘packages’
[16:05:07.822]   - Field: ‘gc’
[16:05:07.822]   - Field: ‘job’
[16:05:07.822]   - Field: ‘conditions’
[16:05:07.822]   - Field: ‘expr’
[16:05:07.822]   - Field: ‘uuid’
[16:05:07.823]   - Field: ‘seed’
[16:05:07.823]   - Field: ‘version’
[16:05:07.823]   - Field: ‘result’
[16:05:07.823]   - Field: ‘asynchronous’
[16:05:07.823]   - Field: ‘calls’
[16:05:07.823]   - Field: ‘globals’
[16:05:07.824]   - Field: ‘stdout’
[16:05:07.824]   - Field: ‘earlySignal’
[16:05:07.824]   - Field: ‘lazy’
[16:05:07.824]   - Field: ‘state’
[16:05:07.824] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:07.824] - Launch lazy future ...
[16:05:07.825] Packages needed by the future expression (n = 0): <none>
[16:05:07.825] Packages needed by future strategies (n = 0): <none>
[16:05:07.826] {
[16:05:07.826]     {
[16:05:07.826]         {
[16:05:07.826]             ...future.startTime <- base::Sys.time()
[16:05:07.826]             {
[16:05:07.826]                 {
[16:05:07.826]                   {
[16:05:07.826]                     {
[16:05:07.826]                       base::local({
[16:05:07.826]                         has_future <- base::requireNamespace("future", 
[16:05:07.826]                           quietly = TRUE)
[16:05:07.826]                         if (has_future) {
[16:05:07.826]                           ns <- base::getNamespace("future")
[16:05:07.826]                           version <- ns[[".package"]][["version"]]
[16:05:07.826]                           if (is.null(version)) 
[16:05:07.826]                             version <- utils::packageVersion("future")
[16:05:07.826]                         }
[16:05:07.826]                         else {
[16:05:07.826]                           version <- NULL
[16:05:07.826]                         }
[16:05:07.826]                         if (!has_future || version < "1.8.0") {
[16:05:07.826]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:07.826]                             "", base::R.version$version.string), 
[16:05:07.826]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:07.826]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:07.826]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:07.826]                               "release", "version")], collapse = " "), 
[16:05:07.826]                             hostname = base::Sys.info()[["nodename"]])
[16:05:07.826]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:07.826]                             info)
[16:05:07.826]                           info <- base::paste(info, collapse = "; ")
[16:05:07.826]                           if (!has_future) {
[16:05:07.826]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:07.826]                               info)
[16:05:07.826]                           }
[16:05:07.826]                           else {
[16:05:07.826]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:07.826]                               info, version)
[16:05:07.826]                           }
[16:05:07.826]                           base::stop(msg)
[16:05:07.826]                         }
[16:05:07.826]                       })
[16:05:07.826]                     }
[16:05:07.826]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:07.826]                     base::options(mc.cores = 1L)
[16:05:07.826]                   }
[16:05:07.826]                   options(future.plan = NULL)
[16:05:07.826]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.826]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:07.826]                 }
[16:05:07.826]                 ...future.workdir <- getwd()
[16:05:07.826]             }
[16:05:07.826]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:07.826]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:07.826]         }
[16:05:07.826]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:07.826]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:07.826]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:07.826]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:07.826]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:07.826]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:07.826]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:07.826]             base::names(...future.oldOptions))
[16:05:07.826]     }
[16:05:07.826]     if (FALSE) {
[16:05:07.826]     }
[16:05:07.826]     else {
[16:05:07.826]         if (TRUE) {
[16:05:07.826]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:07.826]                 open = "w")
[16:05:07.826]         }
[16:05:07.826]         else {
[16:05:07.826]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:07.826]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:07.826]         }
[16:05:07.826]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:07.826]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:07.826]             base::sink(type = "output", split = FALSE)
[16:05:07.826]             base::close(...future.stdout)
[16:05:07.826]         }, add = TRUE)
[16:05:07.826]     }
[16:05:07.826]     ...future.frame <- base::sys.nframe()
[16:05:07.826]     ...future.conditions <- base::list()
[16:05:07.826]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:07.826]     if (FALSE) {
[16:05:07.826]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:07.826]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:07.826]     }
[16:05:07.826]     ...future.result <- base::tryCatch({
[16:05:07.826]         base::withCallingHandlers({
[16:05:07.826]             ...future.value <- base::withVisible(base::local({
[16:05:07.826]                 withCallingHandlers({
[16:05:07.826]                   {
[16:05:07.826]                     b <- a * ii
[16:05:07.826]                     a <- 0
[16:05:07.826]                     b
[16:05:07.826]                   }
[16:05:07.826]                 }, immediateCondition = function(cond) {
[16:05:07.826]                   save_rds <- function (object, pathname, ...) 
[16:05:07.826]                   {
[16:05:07.826]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:07.826]                     if (file_test("-f", pathname_tmp)) {
[16:05:07.826]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.826]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:07.826]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.826]                         fi_tmp[["mtime"]])
[16:05:07.826]                     }
[16:05:07.826]                     tryCatch({
[16:05:07.826]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:07.826]                     }, error = function(ex) {
[16:05:07.826]                       msg <- conditionMessage(ex)
[16:05:07.826]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.826]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:07.826]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.826]                         fi_tmp[["mtime"]], msg)
[16:05:07.826]                       ex$message <- msg
[16:05:07.826]                       stop(ex)
[16:05:07.826]                     })
[16:05:07.826]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:07.826]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:07.826]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:07.826]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.826]                       fi <- file.info(pathname)
[16:05:07.826]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:07.826]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.826]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:07.826]                         fi[["size"]], fi[["mtime"]])
[16:05:07.826]                       stop(msg)
[16:05:07.826]                     }
[16:05:07.826]                     invisible(pathname)
[16:05:07.826]                   }
[16:05:07.826]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:07.826]                     rootPath = tempdir()) 
[16:05:07.826]                   {
[16:05:07.826]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:07.826]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:07.826]                       tmpdir = path, fileext = ".rds")
[16:05:07.826]                     save_rds(obj, file)
[16:05:07.826]                   }
[16:05:07.826]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:07.826]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.826]                   {
[16:05:07.826]                     inherits <- base::inherits
[16:05:07.826]                     invokeRestart <- base::invokeRestart
[16:05:07.826]                     is.null <- base::is.null
[16:05:07.826]                     muffled <- FALSE
[16:05:07.826]                     if (inherits(cond, "message")) {
[16:05:07.826]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:07.826]                       if (muffled) 
[16:05:07.826]                         invokeRestart("muffleMessage")
[16:05:07.826]                     }
[16:05:07.826]                     else if (inherits(cond, "warning")) {
[16:05:07.826]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:07.826]                       if (muffled) 
[16:05:07.826]                         invokeRestart("muffleWarning")
[16:05:07.826]                     }
[16:05:07.826]                     else if (inherits(cond, "condition")) {
[16:05:07.826]                       if (!is.null(pattern)) {
[16:05:07.826]                         computeRestarts <- base::computeRestarts
[16:05:07.826]                         grepl <- base::grepl
[16:05:07.826]                         restarts <- computeRestarts(cond)
[16:05:07.826]                         for (restart in restarts) {
[16:05:07.826]                           name <- restart$name
[16:05:07.826]                           if (is.null(name)) 
[16:05:07.826]                             next
[16:05:07.826]                           if (!grepl(pattern, name)) 
[16:05:07.826]                             next
[16:05:07.826]                           invokeRestart(restart)
[16:05:07.826]                           muffled <- TRUE
[16:05:07.826]                           break
[16:05:07.826]                         }
[16:05:07.826]                       }
[16:05:07.826]                     }
[16:05:07.826]                     invisible(muffled)
[16:05:07.826]                   }
[16:05:07.826]                   muffleCondition(cond)
[16:05:07.826]                 })
[16:05:07.826]             }))
[16:05:07.826]             future::FutureResult(value = ...future.value$value, 
[16:05:07.826]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.826]                   ...future.rng), globalenv = if (FALSE) 
[16:05:07.826]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:07.826]                     ...future.globalenv.names))
[16:05:07.826]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:07.826]         }, condition = base::local({
[16:05:07.826]             c <- base::c
[16:05:07.826]             inherits <- base::inherits
[16:05:07.826]             invokeRestart <- base::invokeRestart
[16:05:07.826]             length <- base::length
[16:05:07.826]             list <- base::list
[16:05:07.826]             seq.int <- base::seq.int
[16:05:07.826]             signalCondition <- base::signalCondition
[16:05:07.826]             sys.calls <- base::sys.calls
[16:05:07.826]             `[[` <- base::`[[`
[16:05:07.826]             `+` <- base::`+`
[16:05:07.826]             `<<-` <- base::`<<-`
[16:05:07.826]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:07.826]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:07.826]                   3L)]
[16:05:07.826]             }
[16:05:07.826]             function(cond) {
[16:05:07.826]                 is_error <- inherits(cond, "error")
[16:05:07.826]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:07.826]                   NULL)
[16:05:07.826]                 if (is_error) {
[16:05:07.826]                   sessionInformation <- function() {
[16:05:07.826]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:07.826]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:07.826]                       search = base::search(), system = base::Sys.info())
[16:05:07.826]                   }
[16:05:07.826]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.826]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:07.826]                     cond$call), session = sessionInformation(), 
[16:05:07.826]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:07.826]                   signalCondition(cond)
[16:05:07.826]                 }
[16:05:07.826]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:07.826]                 "immediateCondition"))) {
[16:05:07.826]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:07.826]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.826]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:07.826]                   if (TRUE && !signal) {
[16:05:07.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.826]                     {
[16:05:07.826]                       inherits <- base::inherits
[16:05:07.826]                       invokeRestart <- base::invokeRestart
[16:05:07.826]                       is.null <- base::is.null
[16:05:07.826]                       muffled <- FALSE
[16:05:07.826]                       if (inherits(cond, "message")) {
[16:05:07.826]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.826]                         if (muffled) 
[16:05:07.826]                           invokeRestart("muffleMessage")
[16:05:07.826]                       }
[16:05:07.826]                       else if (inherits(cond, "warning")) {
[16:05:07.826]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.826]                         if (muffled) 
[16:05:07.826]                           invokeRestart("muffleWarning")
[16:05:07.826]                       }
[16:05:07.826]                       else if (inherits(cond, "condition")) {
[16:05:07.826]                         if (!is.null(pattern)) {
[16:05:07.826]                           computeRestarts <- base::computeRestarts
[16:05:07.826]                           grepl <- base::grepl
[16:05:07.826]                           restarts <- computeRestarts(cond)
[16:05:07.826]                           for (restart in restarts) {
[16:05:07.826]                             name <- restart$name
[16:05:07.826]                             if (is.null(name)) 
[16:05:07.826]                               next
[16:05:07.826]                             if (!grepl(pattern, name)) 
[16:05:07.826]                               next
[16:05:07.826]                             invokeRestart(restart)
[16:05:07.826]                             muffled <- TRUE
[16:05:07.826]                             break
[16:05:07.826]                           }
[16:05:07.826]                         }
[16:05:07.826]                       }
[16:05:07.826]                       invisible(muffled)
[16:05:07.826]                     }
[16:05:07.826]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.826]                   }
[16:05:07.826]                 }
[16:05:07.826]                 else {
[16:05:07.826]                   if (TRUE) {
[16:05:07.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.826]                     {
[16:05:07.826]                       inherits <- base::inherits
[16:05:07.826]                       invokeRestart <- base::invokeRestart
[16:05:07.826]                       is.null <- base::is.null
[16:05:07.826]                       muffled <- FALSE
[16:05:07.826]                       if (inherits(cond, "message")) {
[16:05:07.826]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.826]                         if (muffled) 
[16:05:07.826]                           invokeRestart("muffleMessage")
[16:05:07.826]                       }
[16:05:07.826]                       else if (inherits(cond, "warning")) {
[16:05:07.826]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.826]                         if (muffled) 
[16:05:07.826]                           invokeRestart("muffleWarning")
[16:05:07.826]                       }
[16:05:07.826]                       else if (inherits(cond, "condition")) {
[16:05:07.826]                         if (!is.null(pattern)) {
[16:05:07.826]                           computeRestarts <- base::computeRestarts
[16:05:07.826]                           grepl <- base::grepl
[16:05:07.826]                           restarts <- computeRestarts(cond)
[16:05:07.826]                           for (restart in restarts) {
[16:05:07.826]                             name <- restart$name
[16:05:07.826]                             if (is.null(name)) 
[16:05:07.826]                               next
[16:05:07.826]                             if (!grepl(pattern, name)) 
[16:05:07.826]                               next
[16:05:07.826]                             invokeRestart(restart)
[16:05:07.826]                             muffled <- TRUE
[16:05:07.826]                             break
[16:05:07.826]                           }
[16:05:07.826]                         }
[16:05:07.826]                       }
[16:05:07.826]                       invisible(muffled)
[16:05:07.826]                     }
[16:05:07.826]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.826]                   }
[16:05:07.826]                 }
[16:05:07.826]             }
[16:05:07.826]         }))
[16:05:07.826]     }, error = function(ex) {
[16:05:07.826]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:07.826]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.826]                 ...future.rng), started = ...future.startTime, 
[16:05:07.826]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:07.826]             version = "1.8"), class = "FutureResult")
[16:05:07.826]     }, finally = {
[16:05:07.826]         if (!identical(...future.workdir, getwd())) 
[16:05:07.826]             setwd(...future.workdir)
[16:05:07.826]         {
[16:05:07.826]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:07.826]                 ...future.oldOptions$nwarnings <- NULL
[16:05:07.826]             }
[16:05:07.826]             base::options(...future.oldOptions)
[16:05:07.826]             if (.Platform$OS.type == "windows") {
[16:05:07.826]                 old_names <- names(...future.oldEnvVars)
[16:05:07.826]                 envs <- base::Sys.getenv()
[16:05:07.826]                 names <- names(envs)
[16:05:07.826]                 common <- intersect(names, old_names)
[16:05:07.826]                 added <- setdiff(names, old_names)
[16:05:07.826]                 removed <- setdiff(old_names, names)
[16:05:07.826]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:07.826]                   envs[common]]
[16:05:07.826]                 NAMES <- toupper(changed)
[16:05:07.826]                 args <- list()
[16:05:07.826]                 for (kk in seq_along(NAMES)) {
[16:05:07.826]                   name <- changed[[kk]]
[16:05:07.826]                   NAME <- NAMES[[kk]]
[16:05:07.826]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.826]                     next
[16:05:07.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.826]                 }
[16:05:07.826]                 NAMES <- toupper(added)
[16:05:07.826]                 for (kk in seq_along(NAMES)) {
[16:05:07.826]                   name <- added[[kk]]
[16:05:07.826]                   NAME <- NAMES[[kk]]
[16:05:07.826]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.826]                     next
[16:05:07.826]                   args[[name]] <- ""
[16:05:07.826]                 }
[16:05:07.826]                 NAMES <- toupper(removed)
[16:05:07.826]                 for (kk in seq_along(NAMES)) {
[16:05:07.826]                   name <- removed[[kk]]
[16:05:07.826]                   NAME <- NAMES[[kk]]
[16:05:07.826]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.826]                     next
[16:05:07.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.826]                 }
[16:05:07.826]                 if (length(args) > 0) 
[16:05:07.826]                   base::do.call(base::Sys.setenv, args = args)
[16:05:07.826]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:07.826]             }
[16:05:07.826]             else {
[16:05:07.826]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:07.826]             }
[16:05:07.826]             {
[16:05:07.826]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:07.826]                   0L) {
[16:05:07.826]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:07.826]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:07.826]                   base::options(opts)
[16:05:07.826]                 }
[16:05:07.826]                 {
[16:05:07.826]                   {
[16:05:07.826]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:07.826]                     NULL
[16:05:07.826]                   }
[16:05:07.826]                   options(future.plan = NULL)
[16:05:07.826]                   if (is.na(NA_character_)) 
[16:05:07.826]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.826]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:07.826]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:07.826]                     envir = parent.frame()) 
[16:05:07.826]                   {
[16:05:07.826]                     default_workers <- missing(workers)
[16:05:07.826]                     if (is.function(workers)) 
[16:05:07.826]                       workers <- workers()
[16:05:07.826]                     workers <- structure(as.integer(workers), 
[16:05:07.826]                       class = class(workers))
[16:05:07.826]                     stop_if_not(is.finite(workers), workers >= 
[16:05:07.826]                       1L)
[16:05:07.826]                     if ((workers == 1L && !inherits(workers, 
[16:05:07.826]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:07.826]                       if (default_workers) 
[16:05:07.826]                         supportsMulticore(warn = TRUE)
[16:05:07.826]                       return(sequential(..., envir = envir))
[16:05:07.826]                     }
[16:05:07.826]                     oopts <- options(mc.cores = workers)
[16:05:07.826]                     on.exit(options(oopts))
[16:05:07.826]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:07.826]                       envir = envir)
[16:05:07.826]                     if (!future$lazy) 
[16:05:07.826]                       future <- run(future)
[16:05:07.826]                     invisible(future)
[16:05:07.826]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:07.826]                 }
[16:05:07.826]             }
[16:05:07.826]         }
[16:05:07.826]     })
[16:05:07.826]     if (TRUE) {
[16:05:07.826]         base::sink(type = "output", split = FALSE)
[16:05:07.826]         if (TRUE) {
[16:05:07.826]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:07.826]         }
[16:05:07.826]         else {
[16:05:07.826]             ...future.result["stdout"] <- base::list(NULL)
[16:05:07.826]         }
[16:05:07.826]         base::close(...future.stdout)
[16:05:07.826]         ...future.stdout <- NULL
[16:05:07.826]     }
[16:05:07.826]     ...future.result$conditions <- ...future.conditions
[16:05:07.826]     ...future.result$finished <- base::Sys.time()
[16:05:07.826]     ...future.result
[16:05:07.826] }
[16:05:07.829] assign_globals() ...
[16:05:07.829] List of 2
[16:05:07.829]  $ a : num 1
[16:05:07.829]  $ ii: int 2
[16:05:07.829]  - attr(*, "where")=List of 2
[16:05:07.829]   ..$ a :<environment: R_EmptyEnv> 
[16:05:07.829]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:07.829]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:07.829]  - attr(*, "resolved")= logi TRUE
[16:05:07.829]  - attr(*, "total_size")= num 112
[16:05:07.829]  - attr(*, "already-done")= logi TRUE
[16:05:07.833] - copied ‘a’ to environment
[16:05:07.833] - copied ‘ii’ to environment
[16:05:07.833] assign_globals() ... done
[16:05:07.833] requestCore(): workers = 2
[16:05:07.835] MulticoreFuture started
[16:05:07.836] - Launch lazy future ... done
[16:05:07.836] run() for ‘MulticoreFuture’ ... done
[16:05:07.836] result() for MulticoreFuture ...
[16:05:07.837] plan(): Setting new future strategy stack:
[16:05:07.837] List of future strategies:
[16:05:07.837] 1. sequential:
[16:05:07.837]    - args: function (..., envir = parent.frame())
[16:05:07.837]    - tweaked: FALSE
[16:05:07.837]    - call: NULL
[16:05:07.838] plan(): nbrOfWorkers() = 1
[16:05:07.840] plan(): Setting new future strategy stack:
[16:05:07.840] List of future strategies:
[16:05:07.840] 1. multicore:
[16:05:07.840]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.840]    - tweaked: FALSE
[16:05:07.840]    - call: plan(strategy)
[16:05:07.845] plan(): nbrOfWorkers() = 2
[16:05:07.846] result() for MulticoreFuture ...
[16:05:07.846] result() for MulticoreFuture ... done
[16:05:07.847] result() for MulticoreFuture ... done
[16:05:07.847] result() for MulticoreFuture ...
[16:05:07.847] result() for MulticoreFuture ... done
[16:05:07.847] run() for ‘Future’ ...
[16:05:07.847] - state: ‘created’
[16:05:07.848] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:07.852] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:07.852] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:07.852]   - Field: ‘label’
[16:05:07.852]   - Field: ‘local’
[16:05:07.853]   - Field: ‘owner’
[16:05:07.853]   - Field: ‘envir’
[16:05:07.853]   - Field: ‘workers’
[16:05:07.853]   - Field: ‘packages’
[16:05:07.853]   - Field: ‘gc’
[16:05:07.853]   - Field: ‘job’
[16:05:07.853]   - Field: ‘conditions’
[16:05:07.853]   - Field: ‘expr’
[16:05:07.853]   - Field: ‘uuid’
[16:05:07.854]   - Field: ‘seed’
[16:05:07.854]   - Field: ‘version’
[16:05:07.854]   - Field: ‘result’
[16:05:07.854]   - Field: ‘asynchronous’
[16:05:07.854]   - Field: ‘calls’
[16:05:07.854]   - Field: ‘globals’
[16:05:07.854]   - Field: ‘stdout’
[16:05:07.854]   - Field: ‘earlySignal’
[16:05:07.855]   - Field: ‘lazy’
[16:05:07.855]   - Field: ‘state’
[16:05:07.855] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:07.855] - Launch lazy future ...
[16:05:07.855] Packages needed by the future expression (n = 0): <none>
[16:05:07.856] Packages needed by future strategies (n = 0): <none>
[16:05:07.856] {
[16:05:07.856]     {
[16:05:07.856]         {
[16:05:07.856]             ...future.startTime <- base::Sys.time()
[16:05:07.856]             {
[16:05:07.856]                 {
[16:05:07.856]                   {
[16:05:07.856]                     {
[16:05:07.856]                       base::local({
[16:05:07.856]                         has_future <- base::requireNamespace("future", 
[16:05:07.856]                           quietly = TRUE)
[16:05:07.856]                         if (has_future) {
[16:05:07.856]                           ns <- base::getNamespace("future")
[16:05:07.856]                           version <- ns[[".package"]][["version"]]
[16:05:07.856]                           if (is.null(version)) 
[16:05:07.856]                             version <- utils::packageVersion("future")
[16:05:07.856]                         }
[16:05:07.856]                         else {
[16:05:07.856]                           version <- NULL
[16:05:07.856]                         }
[16:05:07.856]                         if (!has_future || version < "1.8.0") {
[16:05:07.856]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:07.856]                             "", base::R.version$version.string), 
[16:05:07.856]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:07.856]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:07.856]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:07.856]                               "release", "version")], collapse = " "), 
[16:05:07.856]                             hostname = base::Sys.info()[["nodename"]])
[16:05:07.856]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:07.856]                             info)
[16:05:07.856]                           info <- base::paste(info, collapse = "; ")
[16:05:07.856]                           if (!has_future) {
[16:05:07.856]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:07.856]                               info)
[16:05:07.856]                           }
[16:05:07.856]                           else {
[16:05:07.856]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:07.856]                               info, version)
[16:05:07.856]                           }
[16:05:07.856]                           base::stop(msg)
[16:05:07.856]                         }
[16:05:07.856]                       })
[16:05:07.856]                     }
[16:05:07.856]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:07.856]                     base::options(mc.cores = 1L)
[16:05:07.856]                   }
[16:05:07.856]                   options(future.plan = NULL)
[16:05:07.856]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.856]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:07.856]                 }
[16:05:07.856]                 ...future.workdir <- getwd()
[16:05:07.856]             }
[16:05:07.856]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:07.856]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:07.856]         }
[16:05:07.856]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:07.856]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:07.856]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:07.856]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:07.856]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:07.856]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:07.856]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:07.856]             base::names(...future.oldOptions))
[16:05:07.856]     }
[16:05:07.856]     if (FALSE) {
[16:05:07.856]     }
[16:05:07.856]     else {
[16:05:07.856]         if (TRUE) {
[16:05:07.856]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:07.856]                 open = "w")
[16:05:07.856]         }
[16:05:07.856]         else {
[16:05:07.856]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:07.856]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:07.856]         }
[16:05:07.856]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:07.856]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:07.856]             base::sink(type = "output", split = FALSE)
[16:05:07.856]             base::close(...future.stdout)
[16:05:07.856]         }, add = TRUE)
[16:05:07.856]     }
[16:05:07.856]     ...future.frame <- base::sys.nframe()
[16:05:07.856]     ...future.conditions <- base::list()
[16:05:07.856]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:07.856]     if (FALSE) {
[16:05:07.856]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:07.856]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:07.856]     }
[16:05:07.856]     ...future.result <- base::tryCatch({
[16:05:07.856]         base::withCallingHandlers({
[16:05:07.856]             ...future.value <- base::withVisible(base::local({
[16:05:07.856]                 withCallingHandlers({
[16:05:07.856]                   {
[16:05:07.856]                     b <- a * ii
[16:05:07.856]                     a <- 0
[16:05:07.856]                     b
[16:05:07.856]                   }
[16:05:07.856]                 }, immediateCondition = function(cond) {
[16:05:07.856]                   save_rds <- function (object, pathname, ...) 
[16:05:07.856]                   {
[16:05:07.856]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:07.856]                     if (file_test("-f", pathname_tmp)) {
[16:05:07.856]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.856]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:07.856]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.856]                         fi_tmp[["mtime"]])
[16:05:07.856]                     }
[16:05:07.856]                     tryCatch({
[16:05:07.856]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:07.856]                     }, error = function(ex) {
[16:05:07.856]                       msg <- conditionMessage(ex)
[16:05:07.856]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.856]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:07.856]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.856]                         fi_tmp[["mtime"]], msg)
[16:05:07.856]                       ex$message <- msg
[16:05:07.856]                       stop(ex)
[16:05:07.856]                     })
[16:05:07.856]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:07.856]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:07.856]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:07.856]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.856]                       fi <- file.info(pathname)
[16:05:07.856]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:07.856]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.856]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:07.856]                         fi[["size"]], fi[["mtime"]])
[16:05:07.856]                       stop(msg)
[16:05:07.856]                     }
[16:05:07.856]                     invisible(pathname)
[16:05:07.856]                   }
[16:05:07.856]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:07.856]                     rootPath = tempdir()) 
[16:05:07.856]                   {
[16:05:07.856]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:07.856]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:07.856]                       tmpdir = path, fileext = ".rds")
[16:05:07.856]                     save_rds(obj, file)
[16:05:07.856]                   }
[16:05:07.856]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:07.856]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.856]                   {
[16:05:07.856]                     inherits <- base::inherits
[16:05:07.856]                     invokeRestart <- base::invokeRestart
[16:05:07.856]                     is.null <- base::is.null
[16:05:07.856]                     muffled <- FALSE
[16:05:07.856]                     if (inherits(cond, "message")) {
[16:05:07.856]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:07.856]                       if (muffled) 
[16:05:07.856]                         invokeRestart("muffleMessage")
[16:05:07.856]                     }
[16:05:07.856]                     else if (inherits(cond, "warning")) {
[16:05:07.856]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:07.856]                       if (muffled) 
[16:05:07.856]                         invokeRestart("muffleWarning")
[16:05:07.856]                     }
[16:05:07.856]                     else if (inherits(cond, "condition")) {
[16:05:07.856]                       if (!is.null(pattern)) {
[16:05:07.856]                         computeRestarts <- base::computeRestarts
[16:05:07.856]                         grepl <- base::grepl
[16:05:07.856]                         restarts <- computeRestarts(cond)
[16:05:07.856]                         for (restart in restarts) {
[16:05:07.856]                           name <- restart$name
[16:05:07.856]                           if (is.null(name)) 
[16:05:07.856]                             next
[16:05:07.856]                           if (!grepl(pattern, name)) 
[16:05:07.856]                             next
[16:05:07.856]                           invokeRestart(restart)
[16:05:07.856]                           muffled <- TRUE
[16:05:07.856]                           break
[16:05:07.856]                         }
[16:05:07.856]                       }
[16:05:07.856]                     }
[16:05:07.856]                     invisible(muffled)
[16:05:07.856]                   }
[16:05:07.856]                   muffleCondition(cond)
[16:05:07.856]                 })
[16:05:07.856]             }))
[16:05:07.856]             future::FutureResult(value = ...future.value$value, 
[16:05:07.856]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.856]                   ...future.rng), globalenv = if (FALSE) 
[16:05:07.856]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:07.856]                     ...future.globalenv.names))
[16:05:07.856]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:07.856]         }, condition = base::local({
[16:05:07.856]             c <- base::c
[16:05:07.856]             inherits <- base::inherits
[16:05:07.856]             invokeRestart <- base::invokeRestart
[16:05:07.856]             length <- base::length
[16:05:07.856]             list <- base::list
[16:05:07.856]             seq.int <- base::seq.int
[16:05:07.856]             signalCondition <- base::signalCondition
[16:05:07.856]             sys.calls <- base::sys.calls
[16:05:07.856]             `[[` <- base::`[[`
[16:05:07.856]             `+` <- base::`+`
[16:05:07.856]             `<<-` <- base::`<<-`
[16:05:07.856]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:07.856]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:07.856]                   3L)]
[16:05:07.856]             }
[16:05:07.856]             function(cond) {
[16:05:07.856]                 is_error <- inherits(cond, "error")
[16:05:07.856]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:07.856]                   NULL)
[16:05:07.856]                 if (is_error) {
[16:05:07.856]                   sessionInformation <- function() {
[16:05:07.856]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:07.856]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:07.856]                       search = base::search(), system = base::Sys.info())
[16:05:07.856]                   }
[16:05:07.856]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.856]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:07.856]                     cond$call), session = sessionInformation(), 
[16:05:07.856]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:07.856]                   signalCondition(cond)
[16:05:07.856]                 }
[16:05:07.856]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:07.856]                 "immediateCondition"))) {
[16:05:07.856]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:07.856]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.856]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:07.856]                   if (TRUE && !signal) {
[16:05:07.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.856]                     {
[16:05:07.856]                       inherits <- base::inherits
[16:05:07.856]                       invokeRestart <- base::invokeRestart
[16:05:07.856]                       is.null <- base::is.null
[16:05:07.856]                       muffled <- FALSE
[16:05:07.856]                       if (inherits(cond, "message")) {
[16:05:07.856]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.856]                         if (muffled) 
[16:05:07.856]                           invokeRestart("muffleMessage")
[16:05:07.856]                       }
[16:05:07.856]                       else if (inherits(cond, "warning")) {
[16:05:07.856]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.856]                         if (muffled) 
[16:05:07.856]                           invokeRestart("muffleWarning")
[16:05:07.856]                       }
[16:05:07.856]                       else if (inherits(cond, "condition")) {
[16:05:07.856]                         if (!is.null(pattern)) {
[16:05:07.856]                           computeRestarts <- base::computeRestarts
[16:05:07.856]                           grepl <- base::grepl
[16:05:07.856]                           restarts <- computeRestarts(cond)
[16:05:07.856]                           for (restart in restarts) {
[16:05:07.856]                             name <- restart$name
[16:05:07.856]                             if (is.null(name)) 
[16:05:07.856]                               next
[16:05:07.856]                             if (!grepl(pattern, name)) 
[16:05:07.856]                               next
[16:05:07.856]                             invokeRestart(restart)
[16:05:07.856]                             muffled <- TRUE
[16:05:07.856]                             break
[16:05:07.856]                           }
[16:05:07.856]                         }
[16:05:07.856]                       }
[16:05:07.856]                       invisible(muffled)
[16:05:07.856]                     }
[16:05:07.856]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.856]                   }
[16:05:07.856]                 }
[16:05:07.856]                 else {
[16:05:07.856]                   if (TRUE) {
[16:05:07.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.856]                     {
[16:05:07.856]                       inherits <- base::inherits
[16:05:07.856]                       invokeRestart <- base::invokeRestart
[16:05:07.856]                       is.null <- base::is.null
[16:05:07.856]                       muffled <- FALSE
[16:05:07.856]                       if (inherits(cond, "message")) {
[16:05:07.856]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.856]                         if (muffled) 
[16:05:07.856]                           invokeRestart("muffleMessage")
[16:05:07.856]                       }
[16:05:07.856]                       else if (inherits(cond, "warning")) {
[16:05:07.856]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.856]                         if (muffled) 
[16:05:07.856]                           invokeRestart("muffleWarning")
[16:05:07.856]                       }
[16:05:07.856]                       else if (inherits(cond, "condition")) {
[16:05:07.856]                         if (!is.null(pattern)) {
[16:05:07.856]                           computeRestarts <- base::computeRestarts
[16:05:07.856]                           grepl <- base::grepl
[16:05:07.856]                           restarts <- computeRestarts(cond)
[16:05:07.856]                           for (restart in restarts) {
[16:05:07.856]                             name <- restart$name
[16:05:07.856]                             if (is.null(name)) 
[16:05:07.856]                               next
[16:05:07.856]                             if (!grepl(pattern, name)) 
[16:05:07.856]                               next
[16:05:07.856]                             invokeRestart(restart)
[16:05:07.856]                             muffled <- TRUE
[16:05:07.856]                             break
[16:05:07.856]                           }
[16:05:07.856]                         }
[16:05:07.856]                       }
[16:05:07.856]                       invisible(muffled)
[16:05:07.856]                     }
[16:05:07.856]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.856]                   }
[16:05:07.856]                 }
[16:05:07.856]             }
[16:05:07.856]         }))
[16:05:07.856]     }, error = function(ex) {
[16:05:07.856]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:07.856]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.856]                 ...future.rng), started = ...future.startTime, 
[16:05:07.856]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:07.856]             version = "1.8"), class = "FutureResult")
[16:05:07.856]     }, finally = {
[16:05:07.856]         if (!identical(...future.workdir, getwd())) 
[16:05:07.856]             setwd(...future.workdir)
[16:05:07.856]         {
[16:05:07.856]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:07.856]                 ...future.oldOptions$nwarnings <- NULL
[16:05:07.856]             }
[16:05:07.856]             base::options(...future.oldOptions)
[16:05:07.856]             if (.Platform$OS.type == "windows") {
[16:05:07.856]                 old_names <- names(...future.oldEnvVars)
[16:05:07.856]                 envs <- base::Sys.getenv()
[16:05:07.856]                 names <- names(envs)
[16:05:07.856]                 common <- intersect(names, old_names)
[16:05:07.856]                 added <- setdiff(names, old_names)
[16:05:07.856]                 removed <- setdiff(old_names, names)
[16:05:07.856]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:07.856]                   envs[common]]
[16:05:07.856]                 NAMES <- toupper(changed)
[16:05:07.856]                 args <- list()
[16:05:07.856]                 for (kk in seq_along(NAMES)) {
[16:05:07.856]                   name <- changed[[kk]]
[16:05:07.856]                   NAME <- NAMES[[kk]]
[16:05:07.856]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.856]                     next
[16:05:07.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.856]                 }
[16:05:07.856]                 NAMES <- toupper(added)
[16:05:07.856]                 for (kk in seq_along(NAMES)) {
[16:05:07.856]                   name <- added[[kk]]
[16:05:07.856]                   NAME <- NAMES[[kk]]
[16:05:07.856]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.856]                     next
[16:05:07.856]                   args[[name]] <- ""
[16:05:07.856]                 }
[16:05:07.856]                 NAMES <- toupper(removed)
[16:05:07.856]                 for (kk in seq_along(NAMES)) {
[16:05:07.856]                   name <- removed[[kk]]
[16:05:07.856]                   NAME <- NAMES[[kk]]
[16:05:07.856]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.856]                     next
[16:05:07.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.856]                 }
[16:05:07.856]                 if (length(args) > 0) 
[16:05:07.856]                   base::do.call(base::Sys.setenv, args = args)
[16:05:07.856]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:07.856]             }
[16:05:07.856]             else {
[16:05:07.856]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:07.856]             }
[16:05:07.856]             {
[16:05:07.856]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:07.856]                   0L) {
[16:05:07.856]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:07.856]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:07.856]                   base::options(opts)
[16:05:07.856]                 }
[16:05:07.856]                 {
[16:05:07.856]                   {
[16:05:07.856]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:07.856]                     NULL
[16:05:07.856]                   }
[16:05:07.856]                   options(future.plan = NULL)
[16:05:07.856]                   if (is.na(NA_character_)) 
[16:05:07.856]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.856]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:07.856]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:07.856]                     envir = parent.frame()) 
[16:05:07.856]                   {
[16:05:07.856]                     default_workers <- missing(workers)
[16:05:07.856]                     if (is.function(workers)) 
[16:05:07.856]                       workers <- workers()
[16:05:07.856]                     workers <- structure(as.integer(workers), 
[16:05:07.856]                       class = class(workers))
[16:05:07.856]                     stop_if_not(is.finite(workers), workers >= 
[16:05:07.856]                       1L)
[16:05:07.856]                     if ((workers == 1L && !inherits(workers, 
[16:05:07.856]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:07.856]                       if (default_workers) 
[16:05:07.856]                         supportsMulticore(warn = TRUE)
[16:05:07.856]                       return(sequential(..., envir = envir))
[16:05:07.856]                     }
[16:05:07.856]                     oopts <- options(mc.cores = workers)
[16:05:07.856]                     on.exit(options(oopts))
[16:05:07.856]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:07.856]                       envir = envir)
[16:05:07.856]                     if (!future$lazy) 
[16:05:07.856]                       future <- run(future)
[16:05:07.856]                     invisible(future)
[16:05:07.856]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:07.856]                 }
[16:05:07.856]             }
[16:05:07.856]         }
[16:05:07.856]     })
[16:05:07.856]     if (TRUE) {
[16:05:07.856]         base::sink(type = "output", split = FALSE)
[16:05:07.856]         if (TRUE) {
[16:05:07.856]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:07.856]         }
[16:05:07.856]         else {
[16:05:07.856]             ...future.result["stdout"] <- base::list(NULL)
[16:05:07.856]         }
[16:05:07.856]         base::close(...future.stdout)
[16:05:07.856]         ...future.stdout <- NULL
[16:05:07.856]     }
[16:05:07.856]     ...future.result$conditions <- ...future.conditions
[16:05:07.856]     ...future.result$finished <- base::Sys.time()
[16:05:07.856]     ...future.result
[16:05:07.856] }
[16:05:07.859] assign_globals() ...
[16:05:07.859] List of 2
[16:05:07.859]  $ a : num 1
[16:05:07.859]  $ ii: int 3
[16:05:07.859]  - attr(*, "where")=List of 2
[16:05:07.859]   ..$ a :<environment: R_EmptyEnv> 
[16:05:07.859]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:07.859]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:07.859]  - attr(*, "resolved")= logi TRUE
[16:05:07.859]  - attr(*, "total_size")= num 112
[16:05:07.859]  - attr(*, "already-done")= logi TRUE
[16:05:07.863] - copied ‘a’ to environment
[16:05:07.863] - copied ‘ii’ to environment
[16:05:07.863] assign_globals() ... done
[16:05:07.864] requestCore(): workers = 2
[16:05:07.865] MulticoreFuture started
[16:05:07.866] - Launch lazy future ... done
[16:05:07.866] run() for ‘MulticoreFuture’ ... done
[16:05:07.866] result() for MulticoreFuture ...
[16:05:07.867] plan(): Setting new future strategy stack:
[16:05:07.867] List of future strategies:
[16:05:07.867] 1. sequential:
[16:05:07.867]    - args: function (..., envir = parent.frame())
[16:05:07.867]    - tweaked: FALSE
[16:05:07.867]    - call: NULL
[16:05:07.868] plan(): nbrOfWorkers() = 1
[16:05:07.875] plan(): Setting new future strategy stack:
[16:05:07.876] List of future strategies:
[16:05:07.876] 1. multicore:
[16:05:07.876]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.876]    - tweaked: FALSE
[16:05:07.876]    - call: plan(strategy)
[16:05:07.882] plan(): nbrOfWorkers() = 2
[16:05:07.883] result() for MulticoreFuture ...
[16:05:07.886] result() for MulticoreFuture ... done
[16:05:07.886] result() for MulticoreFuture ... done
[16:05:07.887] result() for MulticoreFuture ...
[16:05:07.887] result() for MulticoreFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.888] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.888] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:07.889] 
[16:05:07.889] Searching for globals ... DONE
[16:05:07.889] - globals: [0] <none>
[16:05:07.889] getGlobalsAndPackages() ... DONE
[16:05:07.890] run() for ‘Future’ ...
[16:05:07.890] - state: ‘created’
[16:05:07.890] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:07.895] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:07.895] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:07.895]   - Field: ‘label’
[16:05:07.895]   - Field: ‘local’
[16:05:07.896]   - Field: ‘owner’
[16:05:07.896]   - Field: ‘envir’
[16:05:07.896]   - Field: ‘workers’
[16:05:07.896]   - Field: ‘packages’
[16:05:07.896]   - Field: ‘gc’
[16:05:07.896]   - Field: ‘job’
[16:05:07.897]   - Field: ‘conditions’
[16:05:07.897]   - Field: ‘expr’
[16:05:07.897]   - Field: ‘uuid’
[16:05:07.897]   - Field: ‘seed’
[16:05:07.897]   - Field: ‘version’
[16:05:07.897]   - Field: ‘result’
[16:05:07.897]   - Field: ‘asynchronous’
[16:05:07.897]   - Field: ‘calls’
[16:05:07.898]   - Field: ‘globals’
[16:05:07.898]   - Field: ‘stdout’
[16:05:07.898]   - Field: ‘earlySignal’
[16:05:07.898]   - Field: ‘lazy’
[16:05:07.898]   - Field: ‘state’
[16:05:07.898] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:07.898] - Launch lazy future ...
[16:05:07.899] Packages needed by the future expression (n = 0): <none>
[16:05:07.899] Packages needed by future strategies (n = 0): <none>
[16:05:07.899] {
[16:05:07.899]     {
[16:05:07.899]         {
[16:05:07.899]             ...future.startTime <- base::Sys.time()
[16:05:07.899]             {
[16:05:07.899]                 {
[16:05:07.899]                   {
[16:05:07.899]                     {
[16:05:07.899]                       base::local({
[16:05:07.899]                         has_future <- base::requireNamespace("future", 
[16:05:07.899]                           quietly = TRUE)
[16:05:07.899]                         if (has_future) {
[16:05:07.899]                           ns <- base::getNamespace("future")
[16:05:07.899]                           version <- ns[[".package"]][["version"]]
[16:05:07.899]                           if (is.null(version)) 
[16:05:07.899]                             version <- utils::packageVersion("future")
[16:05:07.899]                         }
[16:05:07.899]                         else {
[16:05:07.899]                           version <- NULL
[16:05:07.899]                         }
[16:05:07.899]                         if (!has_future || version < "1.8.0") {
[16:05:07.899]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:07.899]                             "", base::R.version$version.string), 
[16:05:07.899]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:07.899]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:07.899]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:07.899]                               "release", "version")], collapse = " "), 
[16:05:07.899]                             hostname = base::Sys.info()[["nodename"]])
[16:05:07.899]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:07.899]                             info)
[16:05:07.899]                           info <- base::paste(info, collapse = "; ")
[16:05:07.899]                           if (!has_future) {
[16:05:07.899]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:07.899]                               info)
[16:05:07.899]                           }
[16:05:07.899]                           else {
[16:05:07.899]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:07.899]                               info, version)
[16:05:07.899]                           }
[16:05:07.899]                           base::stop(msg)
[16:05:07.899]                         }
[16:05:07.899]                       })
[16:05:07.899]                     }
[16:05:07.899]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:07.899]                     base::options(mc.cores = 1L)
[16:05:07.899]                   }
[16:05:07.899]                   options(future.plan = NULL)
[16:05:07.899]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.899]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:07.899]                 }
[16:05:07.899]                 ...future.workdir <- getwd()
[16:05:07.899]             }
[16:05:07.899]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:07.899]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:07.899]         }
[16:05:07.899]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:07.899]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:07.899]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:07.899]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:07.899]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:07.899]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:07.899]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:07.899]             base::names(...future.oldOptions))
[16:05:07.899]     }
[16:05:07.899]     if (FALSE) {
[16:05:07.899]     }
[16:05:07.899]     else {
[16:05:07.899]         if (TRUE) {
[16:05:07.899]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:07.899]                 open = "w")
[16:05:07.899]         }
[16:05:07.899]         else {
[16:05:07.899]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:07.899]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:07.899]         }
[16:05:07.899]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:07.899]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:07.899]             base::sink(type = "output", split = FALSE)
[16:05:07.899]             base::close(...future.stdout)
[16:05:07.899]         }, add = TRUE)
[16:05:07.899]     }
[16:05:07.899]     ...future.frame <- base::sys.nframe()
[16:05:07.899]     ...future.conditions <- base::list()
[16:05:07.899]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:07.899]     if (FALSE) {
[16:05:07.899]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:07.899]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:07.899]     }
[16:05:07.899]     ...future.result <- base::tryCatch({
[16:05:07.899]         base::withCallingHandlers({
[16:05:07.899]             ...future.value <- base::withVisible(base::local({
[16:05:07.899]                 withCallingHandlers({
[16:05:07.899]                   1
[16:05:07.899]                 }, immediateCondition = function(cond) {
[16:05:07.899]                   save_rds <- function (object, pathname, ...) 
[16:05:07.899]                   {
[16:05:07.899]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:07.899]                     if (file_test("-f", pathname_tmp)) {
[16:05:07.899]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.899]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:07.899]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.899]                         fi_tmp[["mtime"]])
[16:05:07.899]                     }
[16:05:07.899]                     tryCatch({
[16:05:07.899]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:07.899]                     }, error = function(ex) {
[16:05:07.899]                       msg <- conditionMessage(ex)
[16:05:07.899]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.899]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:07.899]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.899]                         fi_tmp[["mtime"]], msg)
[16:05:07.899]                       ex$message <- msg
[16:05:07.899]                       stop(ex)
[16:05:07.899]                     })
[16:05:07.899]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:07.899]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:07.899]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:07.899]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.899]                       fi <- file.info(pathname)
[16:05:07.899]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:07.899]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.899]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:07.899]                         fi[["size"]], fi[["mtime"]])
[16:05:07.899]                       stop(msg)
[16:05:07.899]                     }
[16:05:07.899]                     invisible(pathname)
[16:05:07.899]                   }
[16:05:07.899]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:07.899]                     rootPath = tempdir()) 
[16:05:07.899]                   {
[16:05:07.899]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:07.899]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:07.899]                       tmpdir = path, fileext = ".rds")
[16:05:07.899]                     save_rds(obj, file)
[16:05:07.899]                   }
[16:05:07.899]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:07.899]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.899]                   {
[16:05:07.899]                     inherits <- base::inherits
[16:05:07.899]                     invokeRestart <- base::invokeRestart
[16:05:07.899]                     is.null <- base::is.null
[16:05:07.899]                     muffled <- FALSE
[16:05:07.899]                     if (inherits(cond, "message")) {
[16:05:07.899]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:07.899]                       if (muffled) 
[16:05:07.899]                         invokeRestart("muffleMessage")
[16:05:07.899]                     }
[16:05:07.899]                     else if (inherits(cond, "warning")) {
[16:05:07.899]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:07.899]                       if (muffled) 
[16:05:07.899]                         invokeRestart("muffleWarning")
[16:05:07.899]                     }
[16:05:07.899]                     else if (inherits(cond, "condition")) {
[16:05:07.899]                       if (!is.null(pattern)) {
[16:05:07.899]                         computeRestarts <- base::computeRestarts
[16:05:07.899]                         grepl <- base::grepl
[16:05:07.899]                         restarts <- computeRestarts(cond)
[16:05:07.899]                         for (restart in restarts) {
[16:05:07.899]                           name <- restart$name
[16:05:07.899]                           if (is.null(name)) 
[16:05:07.899]                             next
[16:05:07.899]                           if (!grepl(pattern, name)) 
[16:05:07.899]                             next
[16:05:07.899]                           invokeRestart(restart)
[16:05:07.899]                           muffled <- TRUE
[16:05:07.899]                           break
[16:05:07.899]                         }
[16:05:07.899]                       }
[16:05:07.899]                     }
[16:05:07.899]                     invisible(muffled)
[16:05:07.899]                   }
[16:05:07.899]                   muffleCondition(cond)
[16:05:07.899]                 })
[16:05:07.899]             }))
[16:05:07.899]             future::FutureResult(value = ...future.value$value, 
[16:05:07.899]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.899]                   ...future.rng), globalenv = if (FALSE) 
[16:05:07.899]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:07.899]                     ...future.globalenv.names))
[16:05:07.899]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:07.899]         }, condition = base::local({
[16:05:07.899]             c <- base::c
[16:05:07.899]             inherits <- base::inherits
[16:05:07.899]             invokeRestart <- base::invokeRestart
[16:05:07.899]             length <- base::length
[16:05:07.899]             list <- base::list
[16:05:07.899]             seq.int <- base::seq.int
[16:05:07.899]             signalCondition <- base::signalCondition
[16:05:07.899]             sys.calls <- base::sys.calls
[16:05:07.899]             `[[` <- base::`[[`
[16:05:07.899]             `+` <- base::`+`
[16:05:07.899]             `<<-` <- base::`<<-`
[16:05:07.899]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:07.899]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:07.899]                   3L)]
[16:05:07.899]             }
[16:05:07.899]             function(cond) {
[16:05:07.899]                 is_error <- inherits(cond, "error")
[16:05:07.899]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:07.899]                   NULL)
[16:05:07.899]                 if (is_error) {
[16:05:07.899]                   sessionInformation <- function() {
[16:05:07.899]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:07.899]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:07.899]                       search = base::search(), system = base::Sys.info())
[16:05:07.899]                   }
[16:05:07.899]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.899]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:07.899]                     cond$call), session = sessionInformation(), 
[16:05:07.899]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:07.899]                   signalCondition(cond)
[16:05:07.899]                 }
[16:05:07.899]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:07.899]                 "immediateCondition"))) {
[16:05:07.899]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:07.899]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.899]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:07.899]                   if (TRUE && !signal) {
[16:05:07.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.899]                     {
[16:05:07.899]                       inherits <- base::inherits
[16:05:07.899]                       invokeRestart <- base::invokeRestart
[16:05:07.899]                       is.null <- base::is.null
[16:05:07.899]                       muffled <- FALSE
[16:05:07.899]                       if (inherits(cond, "message")) {
[16:05:07.899]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.899]                         if (muffled) 
[16:05:07.899]                           invokeRestart("muffleMessage")
[16:05:07.899]                       }
[16:05:07.899]                       else if (inherits(cond, "warning")) {
[16:05:07.899]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.899]                         if (muffled) 
[16:05:07.899]                           invokeRestart("muffleWarning")
[16:05:07.899]                       }
[16:05:07.899]                       else if (inherits(cond, "condition")) {
[16:05:07.899]                         if (!is.null(pattern)) {
[16:05:07.899]                           computeRestarts <- base::computeRestarts
[16:05:07.899]                           grepl <- base::grepl
[16:05:07.899]                           restarts <- computeRestarts(cond)
[16:05:07.899]                           for (restart in restarts) {
[16:05:07.899]                             name <- restart$name
[16:05:07.899]                             if (is.null(name)) 
[16:05:07.899]                               next
[16:05:07.899]                             if (!grepl(pattern, name)) 
[16:05:07.899]                               next
[16:05:07.899]                             invokeRestart(restart)
[16:05:07.899]                             muffled <- TRUE
[16:05:07.899]                             break
[16:05:07.899]                           }
[16:05:07.899]                         }
[16:05:07.899]                       }
[16:05:07.899]                       invisible(muffled)
[16:05:07.899]                     }
[16:05:07.899]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.899]                   }
[16:05:07.899]                 }
[16:05:07.899]                 else {
[16:05:07.899]                   if (TRUE) {
[16:05:07.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.899]                     {
[16:05:07.899]                       inherits <- base::inherits
[16:05:07.899]                       invokeRestart <- base::invokeRestart
[16:05:07.899]                       is.null <- base::is.null
[16:05:07.899]                       muffled <- FALSE
[16:05:07.899]                       if (inherits(cond, "message")) {
[16:05:07.899]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.899]                         if (muffled) 
[16:05:07.899]                           invokeRestart("muffleMessage")
[16:05:07.899]                       }
[16:05:07.899]                       else if (inherits(cond, "warning")) {
[16:05:07.899]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.899]                         if (muffled) 
[16:05:07.899]                           invokeRestart("muffleWarning")
[16:05:07.899]                       }
[16:05:07.899]                       else if (inherits(cond, "condition")) {
[16:05:07.899]                         if (!is.null(pattern)) {
[16:05:07.899]                           computeRestarts <- base::computeRestarts
[16:05:07.899]                           grepl <- base::grepl
[16:05:07.899]                           restarts <- computeRestarts(cond)
[16:05:07.899]                           for (restart in restarts) {
[16:05:07.899]                             name <- restart$name
[16:05:07.899]                             if (is.null(name)) 
[16:05:07.899]                               next
[16:05:07.899]                             if (!grepl(pattern, name)) 
[16:05:07.899]                               next
[16:05:07.899]                             invokeRestart(restart)
[16:05:07.899]                             muffled <- TRUE
[16:05:07.899]                             break
[16:05:07.899]                           }
[16:05:07.899]                         }
[16:05:07.899]                       }
[16:05:07.899]                       invisible(muffled)
[16:05:07.899]                     }
[16:05:07.899]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.899]                   }
[16:05:07.899]                 }
[16:05:07.899]             }
[16:05:07.899]         }))
[16:05:07.899]     }, error = function(ex) {
[16:05:07.899]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:07.899]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.899]                 ...future.rng), started = ...future.startTime, 
[16:05:07.899]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:07.899]             version = "1.8"), class = "FutureResult")
[16:05:07.899]     }, finally = {
[16:05:07.899]         if (!identical(...future.workdir, getwd())) 
[16:05:07.899]             setwd(...future.workdir)
[16:05:07.899]         {
[16:05:07.899]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:07.899]                 ...future.oldOptions$nwarnings <- NULL
[16:05:07.899]             }
[16:05:07.899]             base::options(...future.oldOptions)
[16:05:07.899]             if (.Platform$OS.type == "windows") {
[16:05:07.899]                 old_names <- names(...future.oldEnvVars)
[16:05:07.899]                 envs <- base::Sys.getenv()
[16:05:07.899]                 names <- names(envs)
[16:05:07.899]                 common <- intersect(names, old_names)
[16:05:07.899]                 added <- setdiff(names, old_names)
[16:05:07.899]                 removed <- setdiff(old_names, names)
[16:05:07.899]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:07.899]                   envs[common]]
[16:05:07.899]                 NAMES <- toupper(changed)
[16:05:07.899]                 args <- list()
[16:05:07.899]                 for (kk in seq_along(NAMES)) {
[16:05:07.899]                   name <- changed[[kk]]
[16:05:07.899]                   NAME <- NAMES[[kk]]
[16:05:07.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.899]                     next
[16:05:07.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.899]                 }
[16:05:07.899]                 NAMES <- toupper(added)
[16:05:07.899]                 for (kk in seq_along(NAMES)) {
[16:05:07.899]                   name <- added[[kk]]
[16:05:07.899]                   NAME <- NAMES[[kk]]
[16:05:07.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.899]                     next
[16:05:07.899]                   args[[name]] <- ""
[16:05:07.899]                 }
[16:05:07.899]                 NAMES <- toupper(removed)
[16:05:07.899]                 for (kk in seq_along(NAMES)) {
[16:05:07.899]                   name <- removed[[kk]]
[16:05:07.899]                   NAME <- NAMES[[kk]]
[16:05:07.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.899]                     next
[16:05:07.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.899]                 }
[16:05:07.899]                 if (length(args) > 0) 
[16:05:07.899]                   base::do.call(base::Sys.setenv, args = args)
[16:05:07.899]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:07.899]             }
[16:05:07.899]             else {
[16:05:07.899]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:07.899]             }
[16:05:07.899]             {
[16:05:07.899]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:07.899]                   0L) {
[16:05:07.899]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:07.899]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:07.899]                   base::options(opts)
[16:05:07.899]                 }
[16:05:07.899]                 {
[16:05:07.899]                   {
[16:05:07.899]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:07.899]                     NULL
[16:05:07.899]                   }
[16:05:07.899]                   options(future.plan = NULL)
[16:05:07.899]                   if (is.na(NA_character_)) 
[16:05:07.899]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.899]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:07.899]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:07.899]                     envir = parent.frame()) 
[16:05:07.899]                   {
[16:05:07.899]                     default_workers <- missing(workers)
[16:05:07.899]                     if (is.function(workers)) 
[16:05:07.899]                       workers <- workers()
[16:05:07.899]                     workers <- structure(as.integer(workers), 
[16:05:07.899]                       class = class(workers))
[16:05:07.899]                     stop_if_not(is.finite(workers), workers >= 
[16:05:07.899]                       1L)
[16:05:07.899]                     if ((workers == 1L && !inherits(workers, 
[16:05:07.899]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:07.899]                       if (default_workers) 
[16:05:07.899]                         supportsMulticore(warn = TRUE)
[16:05:07.899]                       return(sequential(..., envir = envir))
[16:05:07.899]                     }
[16:05:07.899]                     oopts <- options(mc.cores = workers)
[16:05:07.899]                     on.exit(options(oopts))
[16:05:07.899]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:07.899]                       envir = envir)
[16:05:07.899]                     if (!future$lazy) 
[16:05:07.899]                       future <- run(future)
[16:05:07.899]                     invisible(future)
[16:05:07.899]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:07.899]                 }
[16:05:07.899]             }
[16:05:07.899]         }
[16:05:07.899]     })
[16:05:07.899]     if (TRUE) {
[16:05:07.899]         base::sink(type = "output", split = FALSE)
[16:05:07.899]         if (TRUE) {
[16:05:07.899]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:07.899]         }
[16:05:07.899]         else {
[16:05:07.899]             ...future.result["stdout"] <- base::list(NULL)
[16:05:07.899]         }
[16:05:07.899]         base::close(...future.stdout)
[16:05:07.899]         ...future.stdout <- NULL
[16:05:07.899]     }
[16:05:07.899]     ...future.result$conditions <- ...future.conditions
[16:05:07.899]     ...future.result$finished <- base::Sys.time()
[16:05:07.899]     ...future.result
[16:05:07.899] }
[16:05:07.902] requestCore(): workers = 2
[16:05:07.904] MulticoreFuture started
[16:05:07.904] - Launch lazy future ... done
[16:05:07.905] run() for ‘MulticoreFuture’ ... done
[16:05:07.905] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.905] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.906] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:07.905] List of future strategies:
[16:05:07.905] 1. sequential:
[16:05:07.905]    - args: function (..., envir = parent.frame())
[16:05:07.905]    - tweaked: FALSE
[16:05:07.905]    - call: NULL
[16:05:07.906] plan(): nbrOfWorkers() = 1
[16:05:07.908] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:07.908] Searching for globals ... DONE
[16:05:07.908] Resolving globals: TRUE
[16:05:07.908] Resolving any globals that are futures ...
[16:05:07.908] plan(): Setting new future strategy stack:
[16:05:07.908] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:07.909] Resolving any globals that are futures ... DONE
[16:05:07.908] List of future strategies:
[16:05:07.908] 1. multicore:
[16:05:07.908]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.908]    - tweaked: FALSE
[16:05:07.908]    - call: plan(strategy)
[16:05:07.909] Resolving futures part of globals (recursively) ...
[16:05:07.910] resolve() on list ...
[16:05:07.910]  recursive: 99
[16:05:07.910]  length: 1
[16:05:07.910]  elements: ‘a’
[16:05:07.913] plan(): nbrOfWorkers() = 2
[16:05:07.913] Future #1
[16:05:07.914] result() for MulticoreFuture ...
[16:05:07.915] result() for MulticoreFuture ...
[16:05:07.915] result() for MulticoreFuture ... done
[16:05:07.915] result() for MulticoreFuture ... done
[16:05:07.915] result() for MulticoreFuture ...
[16:05:07.915] result() for MulticoreFuture ... done
[16:05:07.916] A MulticoreFuture was resolved
[16:05:07.916]  length: 0 (resolved future 1)
[16:05:07.916] resolve() on list ... DONE
[16:05:07.916] - globals: [1] ‘a’
[16:05:07.916] Resolving futures part of globals (recursively) ... DONE
[16:05:07.919] The total size of the 1 globals is 1.57 MiB (1641120 bytes)
[16:05:07.919] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[16:05:07.920] - globals: [1] ‘a’
[16:05:07.920] - packages: [1] ‘future’
[16:05:07.920] getGlobalsAndPackages() ... DONE
[16:05:07.920] run() for ‘Future’ ...
[16:05:07.920] - state: ‘created’
[16:05:07.920] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:07.925] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:07.925] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:07.925]   - Field: ‘label’
[16:05:07.925]   - Field: ‘local’
[16:05:07.925]   - Field: ‘owner’
[16:05:07.925]   - Field: ‘envir’
[16:05:07.925]   - Field: ‘workers’
[16:05:07.926]   - Field: ‘packages’
[16:05:07.926]   - Field: ‘gc’
[16:05:07.926]   - Field: ‘job’
[16:05:07.926]   - Field: ‘conditions’
[16:05:07.926]   - Field: ‘expr’
[16:05:07.926]   - Field: ‘uuid’
[16:05:07.926]   - Field: ‘seed’
[16:05:07.926]   - Field: ‘version’
[16:05:07.926]   - Field: ‘result’
[16:05:07.927]   - Field: ‘asynchronous’
[16:05:07.927]   - Field: ‘calls’
[16:05:07.927]   - Field: ‘globals’
[16:05:07.927]   - Field: ‘stdout’
[16:05:07.927]   - Field: ‘earlySignal’
[16:05:07.927]   - Field: ‘lazy’
[16:05:07.927]   - Field: ‘state’
[16:05:07.930] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:07.930] - Launch lazy future ...
[16:05:07.930] Packages needed by the future expression (n = 1): ‘future’
[16:05:07.930] Packages needed by future strategies (n = 0): <none>
[16:05:07.931] {
[16:05:07.931]     {
[16:05:07.931]         {
[16:05:07.931]             ...future.startTime <- base::Sys.time()
[16:05:07.931]             {
[16:05:07.931]                 {
[16:05:07.931]                   {
[16:05:07.931]                     {
[16:05:07.931]                       {
[16:05:07.931]                         base::local({
[16:05:07.931]                           has_future <- base::requireNamespace("future", 
[16:05:07.931]                             quietly = TRUE)
[16:05:07.931]                           if (has_future) {
[16:05:07.931]                             ns <- base::getNamespace("future")
[16:05:07.931]                             version <- ns[[".package"]][["version"]]
[16:05:07.931]                             if (is.null(version)) 
[16:05:07.931]                               version <- utils::packageVersion("future")
[16:05:07.931]                           }
[16:05:07.931]                           else {
[16:05:07.931]                             version <- NULL
[16:05:07.931]                           }
[16:05:07.931]                           if (!has_future || version < "1.8.0") {
[16:05:07.931]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:07.931]                               "", base::R.version$version.string), 
[16:05:07.931]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:07.931]                                 base::R.version$platform, 8 * 
[16:05:07.931]                                   base::.Machine$sizeof.pointer), 
[16:05:07.931]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:07.931]                                 "release", "version")], collapse = " "), 
[16:05:07.931]                               hostname = base::Sys.info()[["nodename"]])
[16:05:07.931]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:07.931]                               info)
[16:05:07.931]                             info <- base::paste(info, collapse = "; ")
[16:05:07.931]                             if (!has_future) {
[16:05:07.931]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:07.931]                                 info)
[16:05:07.931]                             }
[16:05:07.931]                             else {
[16:05:07.931]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:07.931]                                 info, version)
[16:05:07.931]                             }
[16:05:07.931]                             base::stop(msg)
[16:05:07.931]                           }
[16:05:07.931]                         })
[16:05:07.931]                       }
[16:05:07.931]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:07.931]                       base::options(mc.cores = 1L)
[16:05:07.931]                     }
[16:05:07.931]                     base::local({
[16:05:07.931]                       for (pkg in "future") {
[16:05:07.931]                         base::loadNamespace(pkg)
[16:05:07.931]                         base::library(pkg, character.only = TRUE)
[16:05:07.931]                       }
[16:05:07.931]                     })
[16:05:07.931]                   }
[16:05:07.931]                   options(future.plan = NULL)
[16:05:07.931]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.931]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:07.931]                 }
[16:05:07.931]                 ...future.workdir <- getwd()
[16:05:07.931]             }
[16:05:07.931]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:07.931]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:07.931]         }
[16:05:07.931]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:07.931]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:07.931]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:07.931]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:07.931]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:07.931]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:07.931]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:07.931]             base::names(...future.oldOptions))
[16:05:07.931]     }
[16:05:07.931]     if (FALSE) {
[16:05:07.931]     }
[16:05:07.931]     else {
[16:05:07.931]         if (TRUE) {
[16:05:07.931]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:07.931]                 open = "w")
[16:05:07.931]         }
[16:05:07.931]         else {
[16:05:07.931]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:07.931]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:07.931]         }
[16:05:07.931]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:07.931]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:07.931]             base::sink(type = "output", split = FALSE)
[16:05:07.931]             base::close(...future.stdout)
[16:05:07.931]         }, add = TRUE)
[16:05:07.931]     }
[16:05:07.931]     ...future.frame <- base::sys.nframe()
[16:05:07.931]     ...future.conditions <- base::list()
[16:05:07.931]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:07.931]     if (FALSE) {
[16:05:07.931]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:07.931]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:07.931]     }
[16:05:07.931]     ...future.result <- base::tryCatch({
[16:05:07.931]         base::withCallingHandlers({
[16:05:07.931]             ...future.value <- base::withVisible(base::local({
[16:05:07.931]                 withCallingHandlers({
[16:05:07.931]                   value(a) + 1
[16:05:07.931]                 }, immediateCondition = function(cond) {
[16:05:07.931]                   save_rds <- function (object, pathname, ...) 
[16:05:07.931]                   {
[16:05:07.931]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:07.931]                     if (file_test("-f", pathname_tmp)) {
[16:05:07.931]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.931]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:07.931]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.931]                         fi_tmp[["mtime"]])
[16:05:07.931]                     }
[16:05:07.931]                     tryCatch({
[16:05:07.931]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:07.931]                     }, error = function(ex) {
[16:05:07.931]                       msg <- conditionMessage(ex)
[16:05:07.931]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.931]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:07.931]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.931]                         fi_tmp[["mtime"]], msg)
[16:05:07.931]                       ex$message <- msg
[16:05:07.931]                       stop(ex)
[16:05:07.931]                     })
[16:05:07.931]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:07.931]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:07.931]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:07.931]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.931]                       fi <- file.info(pathname)
[16:05:07.931]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:07.931]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.931]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:07.931]                         fi[["size"]], fi[["mtime"]])
[16:05:07.931]                       stop(msg)
[16:05:07.931]                     }
[16:05:07.931]                     invisible(pathname)
[16:05:07.931]                   }
[16:05:07.931]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:07.931]                     rootPath = tempdir()) 
[16:05:07.931]                   {
[16:05:07.931]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:07.931]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:07.931]                       tmpdir = path, fileext = ".rds")
[16:05:07.931]                     save_rds(obj, file)
[16:05:07.931]                   }
[16:05:07.931]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:07.931]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.931]                   {
[16:05:07.931]                     inherits <- base::inherits
[16:05:07.931]                     invokeRestart <- base::invokeRestart
[16:05:07.931]                     is.null <- base::is.null
[16:05:07.931]                     muffled <- FALSE
[16:05:07.931]                     if (inherits(cond, "message")) {
[16:05:07.931]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:07.931]                       if (muffled) 
[16:05:07.931]                         invokeRestart("muffleMessage")
[16:05:07.931]                     }
[16:05:07.931]                     else if (inherits(cond, "warning")) {
[16:05:07.931]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:07.931]                       if (muffled) 
[16:05:07.931]                         invokeRestart("muffleWarning")
[16:05:07.931]                     }
[16:05:07.931]                     else if (inherits(cond, "condition")) {
[16:05:07.931]                       if (!is.null(pattern)) {
[16:05:07.931]                         computeRestarts <- base::computeRestarts
[16:05:07.931]                         grepl <- base::grepl
[16:05:07.931]                         restarts <- computeRestarts(cond)
[16:05:07.931]                         for (restart in restarts) {
[16:05:07.931]                           name <- restart$name
[16:05:07.931]                           if (is.null(name)) 
[16:05:07.931]                             next
[16:05:07.931]                           if (!grepl(pattern, name)) 
[16:05:07.931]                             next
[16:05:07.931]                           invokeRestart(restart)
[16:05:07.931]                           muffled <- TRUE
[16:05:07.931]                           break
[16:05:07.931]                         }
[16:05:07.931]                       }
[16:05:07.931]                     }
[16:05:07.931]                     invisible(muffled)
[16:05:07.931]                   }
[16:05:07.931]                   muffleCondition(cond)
[16:05:07.931]                 })
[16:05:07.931]             }))
[16:05:07.931]             future::FutureResult(value = ...future.value$value, 
[16:05:07.931]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.931]                   ...future.rng), globalenv = if (FALSE) 
[16:05:07.931]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:07.931]                     ...future.globalenv.names))
[16:05:07.931]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:07.931]         }, condition = base::local({
[16:05:07.931]             c <- base::c
[16:05:07.931]             inherits <- base::inherits
[16:05:07.931]             invokeRestart <- base::invokeRestart
[16:05:07.931]             length <- base::length
[16:05:07.931]             list <- base::list
[16:05:07.931]             seq.int <- base::seq.int
[16:05:07.931]             signalCondition <- base::signalCondition
[16:05:07.931]             sys.calls <- base::sys.calls
[16:05:07.931]             `[[` <- base::`[[`
[16:05:07.931]             `+` <- base::`+`
[16:05:07.931]             `<<-` <- base::`<<-`
[16:05:07.931]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:07.931]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:07.931]                   3L)]
[16:05:07.931]             }
[16:05:07.931]             function(cond) {
[16:05:07.931]                 is_error <- inherits(cond, "error")
[16:05:07.931]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:07.931]                   NULL)
[16:05:07.931]                 if (is_error) {
[16:05:07.931]                   sessionInformation <- function() {
[16:05:07.931]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:07.931]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:07.931]                       search = base::search(), system = base::Sys.info())
[16:05:07.931]                   }
[16:05:07.931]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.931]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:07.931]                     cond$call), session = sessionInformation(), 
[16:05:07.931]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:07.931]                   signalCondition(cond)
[16:05:07.931]                 }
[16:05:07.931]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:07.931]                 "immediateCondition"))) {
[16:05:07.931]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:07.931]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.931]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:07.931]                   if (TRUE && !signal) {
[16:05:07.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.931]                     {
[16:05:07.931]                       inherits <- base::inherits
[16:05:07.931]                       invokeRestart <- base::invokeRestart
[16:05:07.931]                       is.null <- base::is.null
[16:05:07.931]                       muffled <- FALSE
[16:05:07.931]                       if (inherits(cond, "message")) {
[16:05:07.931]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.931]                         if (muffled) 
[16:05:07.931]                           invokeRestart("muffleMessage")
[16:05:07.931]                       }
[16:05:07.931]                       else if (inherits(cond, "warning")) {
[16:05:07.931]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.931]                         if (muffled) 
[16:05:07.931]                           invokeRestart("muffleWarning")
[16:05:07.931]                       }
[16:05:07.931]                       else if (inherits(cond, "condition")) {
[16:05:07.931]                         if (!is.null(pattern)) {
[16:05:07.931]                           computeRestarts <- base::computeRestarts
[16:05:07.931]                           grepl <- base::grepl
[16:05:07.931]                           restarts <- computeRestarts(cond)
[16:05:07.931]                           for (restart in restarts) {
[16:05:07.931]                             name <- restart$name
[16:05:07.931]                             if (is.null(name)) 
[16:05:07.931]                               next
[16:05:07.931]                             if (!grepl(pattern, name)) 
[16:05:07.931]                               next
[16:05:07.931]                             invokeRestart(restart)
[16:05:07.931]                             muffled <- TRUE
[16:05:07.931]                             break
[16:05:07.931]                           }
[16:05:07.931]                         }
[16:05:07.931]                       }
[16:05:07.931]                       invisible(muffled)
[16:05:07.931]                     }
[16:05:07.931]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.931]                   }
[16:05:07.931]                 }
[16:05:07.931]                 else {
[16:05:07.931]                   if (TRUE) {
[16:05:07.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.931]                     {
[16:05:07.931]                       inherits <- base::inherits
[16:05:07.931]                       invokeRestart <- base::invokeRestart
[16:05:07.931]                       is.null <- base::is.null
[16:05:07.931]                       muffled <- FALSE
[16:05:07.931]                       if (inherits(cond, "message")) {
[16:05:07.931]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.931]                         if (muffled) 
[16:05:07.931]                           invokeRestart("muffleMessage")
[16:05:07.931]                       }
[16:05:07.931]                       else if (inherits(cond, "warning")) {
[16:05:07.931]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.931]                         if (muffled) 
[16:05:07.931]                           invokeRestart("muffleWarning")
[16:05:07.931]                       }
[16:05:07.931]                       else if (inherits(cond, "condition")) {
[16:05:07.931]                         if (!is.null(pattern)) {
[16:05:07.931]                           computeRestarts <- base::computeRestarts
[16:05:07.931]                           grepl <- base::grepl
[16:05:07.931]                           restarts <- computeRestarts(cond)
[16:05:07.931]                           for (restart in restarts) {
[16:05:07.931]                             name <- restart$name
[16:05:07.931]                             if (is.null(name)) 
[16:05:07.931]                               next
[16:05:07.931]                             if (!grepl(pattern, name)) 
[16:05:07.931]                               next
[16:05:07.931]                             invokeRestart(restart)
[16:05:07.931]                             muffled <- TRUE
[16:05:07.931]                             break
[16:05:07.931]                           }
[16:05:07.931]                         }
[16:05:07.931]                       }
[16:05:07.931]                       invisible(muffled)
[16:05:07.931]                     }
[16:05:07.931]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.931]                   }
[16:05:07.931]                 }
[16:05:07.931]             }
[16:05:07.931]         }))
[16:05:07.931]     }, error = function(ex) {
[16:05:07.931]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:07.931]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.931]                 ...future.rng), started = ...future.startTime, 
[16:05:07.931]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:07.931]             version = "1.8"), class = "FutureResult")
[16:05:07.931]     }, finally = {
[16:05:07.931]         if (!identical(...future.workdir, getwd())) 
[16:05:07.931]             setwd(...future.workdir)
[16:05:07.931]         {
[16:05:07.931]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:07.931]                 ...future.oldOptions$nwarnings <- NULL
[16:05:07.931]             }
[16:05:07.931]             base::options(...future.oldOptions)
[16:05:07.931]             if (.Platform$OS.type == "windows") {
[16:05:07.931]                 old_names <- names(...future.oldEnvVars)
[16:05:07.931]                 envs <- base::Sys.getenv()
[16:05:07.931]                 names <- names(envs)
[16:05:07.931]                 common <- intersect(names, old_names)
[16:05:07.931]                 added <- setdiff(names, old_names)
[16:05:07.931]                 removed <- setdiff(old_names, names)
[16:05:07.931]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:07.931]                   envs[common]]
[16:05:07.931]                 NAMES <- toupper(changed)
[16:05:07.931]                 args <- list()
[16:05:07.931]                 for (kk in seq_along(NAMES)) {
[16:05:07.931]                   name <- changed[[kk]]
[16:05:07.931]                   NAME <- NAMES[[kk]]
[16:05:07.931]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.931]                     next
[16:05:07.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.931]                 }
[16:05:07.931]                 NAMES <- toupper(added)
[16:05:07.931]                 for (kk in seq_along(NAMES)) {
[16:05:07.931]                   name <- added[[kk]]
[16:05:07.931]                   NAME <- NAMES[[kk]]
[16:05:07.931]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.931]                     next
[16:05:07.931]                   args[[name]] <- ""
[16:05:07.931]                 }
[16:05:07.931]                 NAMES <- toupper(removed)
[16:05:07.931]                 for (kk in seq_along(NAMES)) {
[16:05:07.931]                   name <- removed[[kk]]
[16:05:07.931]                   NAME <- NAMES[[kk]]
[16:05:07.931]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.931]                     next
[16:05:07.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.931]                 }
[16:05:07.931]                 if (length(args) > 0) 
[16:05:07.931]                   base::do.call(base::Sys.setenv, args = args)
[16:05:07.931]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:07.931]             }
[16:05:07.931]             else {
[16:05:07.931]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:07.931]             }
[16:05:07.931]             {
[16:05:07.931]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:07.931]                   0L) {
[16:05:07.931]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:07.931]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:07.931]                   base::options(opts)
[16:05:07.931]                 }
[16:05:07.931]                 {
[16:05:07.931]                   {
[16:05:07.931]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:07.931]                     NULL
[16:05:07.931]                   }
[16:05:07.931]                   options(future.plan = NULL)
[16:05:07.931]                   if (is.na(NA_character_)) 
[16:05:07.931]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.931]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:07.931]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:07.931]                     envir = parent.frame()) 
[16:05:07.931]                   {
[16:05:07.931]                     default_workers <- missing(workers)
[16:05:07.931]                     if (is.function(workers)) 
[16:05:07.931]                       workers <- workers()
[16:05:07.931]                     workers <- structure(as.integer(workers), 
[16:05:07.931]                       class = class(workers))
[16:05:07.931]                     stop_if_not(is.finite(workers), workers >= 
[16:05:07.931]                       1L)
[16:05:07.931]                     if ((workers == 1L && !inherits(workers, 
[16:05:07.931]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:07.931]                       if (default_workers) 
[16:05:07.931]                         supportsMulticore(warn = TRUE)
[16:05:07.931]                       return(sequential(..., envir = envir))
[16:05:07.931]                     }
[16:05:07.931]                     oopts <- options(mc.cores = workers)
[16:05:07.931]                     on.exit(options(oopts))
[16:05:07.931]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:07.931]                       envir = envir)
[16:05:07.931]                     if (!future$lazy) 
[16:05:07.931]                       future <- run(future)
[16:05:07.931]                     invisible(future)
[16:05:07.931]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:07.931]                 }
[16:05:07.931]             }
[16:05:07.931]         }
[16:05:07.931]     })
[16:05:07.931]     if (TRUE) {
[16:05:07.931]         base::sink(type = "output", split = FALSE)
[16:05:07.931]         if (TRUE) {
[16:05:07.931]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:07.931]         }
[16:05:07.931]         else {
[16:05:07.931]             ...future.result["stdout"] <- base::list(NULL)
[16:05:07.931]         }
[16:05:07.931]         base::close(...future.stdout)
[16:05:07.931]         ...future.stdout <- NULL
[16:05:07.931]     }
[16:05:07.931]     ...future.result$conditions <- ...future.conditions
[16:05:07.931]     ...future.result$finished <- base::Sys.time()
[16:05:07.931]     ...future.result
[16:05:07.931] }
[16:05:07.934] assign_globals() ...
[16:05:07.934] List of 1
[16:05:07.934]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a054b352e8> 
[16:05:07.934]  - attr(*, "where")=List of 1
[16:05:07.934]   ..$ a:<environment: R_EmptyEnv> 
[16:05:07.934]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:07.934]  - attr(*, "resolved")= logi TRUE
[16:05:07.934]  - attr(*, "total_size")= num 1641120
[16:05:07.934]  - attr(*, "already-done")= logi TRUE
[16:05:07.938] - copied ‘a’ to environment
[16:05:07.938] assign_globals() ... done
[16:05:07.938] requestCore(): workers = 2
[16:05:07.941] MulticoreFuture started
[16:05:07.941] - Launch lazy future ... done
[16:05:07.942] run() for ‘MulticoreFuture’ ... done
[16:05:07.942] plan(): Setting new future strategy stack:
[16:05:07.942] result() for MulticoreFuture ...
[16:05:07.943] List of future strategies:
[16:05:07.943] 1. sequential:
[16:05:07.943]    - args: function (..., envir = parent.frame())
[16:05:07.943]    - tweaked: FALSE
[16:05:07.943]    - call: NULL
[16:05:07.944] plan(): nbrOfWorkers() = 1
[16:05:07.948] plan(): Setting new future strategy stack:
[16:05:07.948] List of future strategies:
[16:05:07.948] 1. multicore:
[16:05:07.948]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.948]    - tweaked: FALSE
[16:05:07.948]    - call: plan(strategy)
[16:05:07.953] plan(): nbrOfWorkers() = 2
[16:05:07.954] result() for MulticoreFuture ...
[16:05:07.955] result() for MulticoreFuture ... done
[16:05:07.955] signalConditions() ...
[16:05:07.955]  - include = ‘immediateCondition’
[16:05:07.955]  - exclude = 
[16:05:07.955]  - resignal = FALSE
[16:05:07.955]  - Number of conditions: 4
[16:05:07.956] signalConditions() ... done
[16:05:07.956] result() for MulticoreFuture ... done
[16:05:07.956] result() for MulticoreFuture ...
[16:05:07.956] result() for MulticoreFuture ... done
[16:05:07.956] signalConditions() ...
[16:05:07.956]  - include = ‘immediateCondition’
[16:05:07.956]  - exclude = 
[16:05:07.957]  - resignal = FALSE
[16:05:07.957]  - Number of conditions: 4
[16:05:07.957] signalConditions() ... done
[16:05:07.957] Future state: ‘finished’
[16:05:07.957] result() for MulticoreFuture ...
[16:05:07.957] result() for MulticoreFuture ... done
[16:05:07.957] signalConditions() ...
[16:05:07.957]  - include = ‘condition’
[16:05:07.958]  - exclude = ‘immediateCondition’
[16:05:07.958]  - resignal = TRUE
[16:05:07.958]  - Number of conditions: 4
[16:05:07.958]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.945] result() for MulticoreFuture ...
[16:05:07.958]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.946] result() for MulticoreFuture ... done
[16:05:07.958]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.946] result() for MulticoreFuture ...
[16:05:07.959]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.946] result() for MulticoreFuture ... done
[16:05:07.959] signalConditions() ... done
value(b) = 2
[16:05:07.959] result() for MulticoreFuture ...
[16:05:07.959] result() for MulticoreFuture ... done
[16:05:07.959] result() for MulticoreFuture ...
[16:05:07.959] result() for MulticoreFuture ... done
[16:05:07.959] signalConditions() ...
[16:05:07.960]  - include = ‘immediateCondition’
[16:05:07.960]  - exclude = 
[16:05:07.960]  - resignal = FALSE
[16:05:07.960]  - Number of conditions: 4
[16:05:07.960] signalConditions() ... done
[16:05:07.960] Future state: ‘finished’
[16:05:07.960] result() for MulticoreFuture ...
[16:05:07.960] result() for MulticoreFuture ... done
[16:05:07.960] signalConditions() ...
[16:05:07.961]  - include = ‘condition’
[16:05:07.961]  - exclude = ‘immediateCondition’
[16:05:07.961]  - resignal = TRUE
[16:05:07.961]  - Number of conditions: 4
[16:05:07.961]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.945] result() for MulticoreFuture ...
[16:05:07.961]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.946] result() for MulticoreFuture ... done
[16:05:07.961]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.946] result() for MulticoreFuture ...
[16:05:07.961]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:07.946] result() for MulticoreFuture ... done
[16:05:07.962] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.962] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.962] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:07.963] 
[16:05:07.963] Searching for globals ... DONE
[16:05:07.963] - globals: [0] <none>
[16:05:07.963] getGlobalsAndPackages() ... DONE
[16:05:07.964] run() for ‘Future’ ...
[16:05:07.964] - state: ‘created’
[16:05:07.964] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:07.968] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:07.968] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:07.969]   - Field: ‘label’
[16:05:07.969]   - Field: ‘local’
[16:05:07.969]   - Field: ‘owner’
[16:05:07.969]   - Field: ‘envir’
[16:05:07.969]   - Field: ‘workers’
[16:05:07.969]   - Field: ‘packages’
[16:05:07.969]   - Field: ‘gc’
[16:05:07.970]   - Field: ‘job’
[16:05:07.970]   - Field: ‘conditions’
[16:05:07.970]   - Field: ‘expr’
[16:05:07.970]   - Field: ‘uuid’
[16:05:07.970]   - Field: ‘seed’
[16:05:07.970]   - Field: ‘version’
[16:05:07.970]   - Field: ‘result’
[16:05:07.970]   - Field: ‘asynchronous’
[16:05:07.971]   - Field: ‘calls’
[16:05:07.971]   - Field: ‘globals’
[16:05:07.971]   - Field: ‘stdout’
[16:05:07.971]   - Field: ‘earlySignal’
[16:05:07.971]   - Field: ‘lazy’
[16:05:07.971]   - Field: ‘state’
[16:05:07.971] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:07.971] - Launch lazy future ...
[16:05:07.972] Packages needed by the future expression (n = 0): <none>
[16:05:07.972] Packages needed by future strategies (n = 0): <none>
[16:05:07.972] {
[16:05:07.972]     {
[16:05:07.972]         {
[16:05:07.972]             ...future.startTime <- base::Sys.time()
[16:05:07.972]             {
[16:05:07.972]                 {
[16:05:07.972]                   {
[16:05:07.972]                     {
[16:05:07.972]                       base::local({
[16:05:07.972]                         has_future <- base::requireNamespace("future", 
[16:05:07.972]                           quietly = TRUE)
[16:05:07.972]                         if (has_future) {
[16:05:07.972]                           ns <- base::getNamespace("future")
[16:05:07.972]                           version <- ns[[".package"]][["version"]]
[16:05:07.972]                           if (is.null(version)) 
[16:05:07.972]                             version <- utils::packageVersion("future")
[16:05:07.972]                         }
[16:05:07.972]                         else {
[16:05:07.972]                           version <- NULL
[16:05:07.972]                         }
[16:05:07.972]                         if (!has_future || version < "1.8.0") {
[16:05:07.972]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:07.972]                             "", base::R.version$version.string), 
[16:05:07.972]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:07.972]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:07.972]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:07.972]                               "release", "version")], collapse = " "), 
[16:05:07.972]                             hostname = base::Sys.info()[["nodename"]])
[16:05:07.972]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:07.972]                             info)
[16:05:07.972]                           info <- base::paste(info, collapse = "; ")
[16:05:07.972]                           if (!has_future) {
[16:05:07.972]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:07.972]                               info)
[16:05:07.972]                           }
[16:05:07.972]                           else {
[16:05:07.972]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:07.972]                               info, version)
[16:05:07.972]                           }
[16:05:07.972]                           base::stop(msg)
[16:05:07.972]                         }
[16:05:07.972]                       })
[16:05:07.972]                     }
[16:05:07.972]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:07.972]                     base::options(mc.cores = 1L)
[16:05:07.972]                   }
[16:05:07.972]                   options(future.plan = NULL)
[16:05:07.972]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.972]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:07.972]                 }
[16:05:07.972]                 ...future.workdir <- getwd()
[16:05:07.972]             }
[16:05:07.972]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:07.972]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:07.972]         }
[16:05:07.972]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:07.972]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:07.972]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:07.972]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:07.972]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:07.972]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:07.972]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:07.972]             base::names(...future.oldOptions))
[16:05:07.972]     }
[16:05:07.972]     if (FALSE) {
[16:05:07.972]     }
[16:05:07.972]     else {
[16:05:07.972]         if (TRUE) {
[16:05:07.972]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:07.972]                 open = "w")
[16:05:07.972]         }
[16:05:07.972]         else {
[16:05:07.972]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:07.972]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:07.972]         }
[16:05:07.972]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:07.972]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:07.972]             base::sink(type = "output", split = FALSE)
[16:05:07.972]             base::close(...future.stdout)
[16:05:07.972]         }, add = TRUE)
[16:05:07.972]     }
[16:05:07.972]     ...future.frame <- base::sys.nframe()
[16:05:07.972]     ...future.conditions <- base::list()
[16:05:07.972]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:07.972]     if (FALSE) {
[16:05:07.972]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:07.972]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:07.972]     }
[16:05:07.972]     ...future.result <- base::tryCatch({
[16:05:07.972]         base::withCallingHandlers({
[16:05:07.972]             ...future.value <- base::withVisible(base::local({
[16:05:07.972]                 withCallingHandlers({
[16:05:07.972]                   1
[16:05:07.972]                 }, immediateCondition = function(cond) {
[16:05:07.972]                   save_rds <- function (object, pathname, ...) 
[16:05:07.972]                   {
[16:05:07.972]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:07.972]                     if (file_test("-f", pathname_tmp)) {
[16:05:07.972]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.972]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:07.972]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.972]                         fi_tmp[["mtime"]])
[16:05:07.972]                     }
[16:05:07.972]                     tryCatch({
[16:05:07.972]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:07.972]                     }, error = function(ex) {
[16:05:07.972]                       msg <- conditionMessage(ex)
[16:05:07.972]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.972]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:07.972]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.972]                         fi_tmp[["mtime"]], msg)
[16:05:07.972]                       ex$message <- msg
[16:05:07.972]                       stop(ex)
[16:05:07.972]                     })
[16:05:07.972]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:07.972]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:07.972]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:07.972]                       fi_tmp <- file.info(pathname_tmp)
[16:05:07.972]                       fi <- file.info(pathname)
[16:05:07.972]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:07.972]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:07.972]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:07.972]                         fi[["size"]], fi[["mtime"]])
[16:05:07.972]                       stop(msg)
[16:05:07.972]                     }
[16:05:07.972]                     invisible(pathname)
[16:05:07.972]                   }
[16:05:07.972]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:07.972]                     rootPath = tempdir()) 
[16:05:07.972]                   {
[16:05:07.972]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:07.972]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:07.972]                       tmpdir = path, fileext = ".rds")
[16:05:07.972]                     save_rds(obj, file)
[16:05:07.972]                   }
[16:05:07.972]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:07.972]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.972]                   {
[16:05:07.972]                     inherits <- base::inherits
[16:05:07.972]                     invokeRestart <- base::invokeRestart
[16:05:07.972]                     is.null <- base::is.null
[16:05:07.972]                     muffled <- FALSE
[16:05:07.972]                     if (inherits(cond, "message")) {
[16:05:07.972]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:07.972]                       if (muffled) 
[16:05:07.972]                         invokeRestart("muffleMessage")
[16:05:07.972]                     }
[16:05:07.972]                     else if (inherits(cond, "warning")) {
[16:05:07.972]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:07.972]                       if (muffled) 
[16:05:07.972]                         invokeRestart("muffleWarning")
[16:05:07.972]                     }
[16:05:07.972]                     else if (inherits(cond, "condition")) {
[16:05:07.972]                       if (!is.null(pattern)) {
[16:05:07.972]                         computeRestarts <- base::computeRestarts
[16:05:07.972]                         grepl <- base::grepl
[16:05:07.972]                         restarts <- computeRestarts(cond)
[16:05:07.972]                         for (restart in restarts) {
[16:05:07.972]                           name <- restart$name
[16:05:07.972]                           if (is.null(name)) 
[16:05:07.972]                             next
[16:05:07.972]                           if (!grepl(pattern, name)) 
[16:05:07.972]                             next
[16:05:07.972]                           invokeRestart(restart)
[16:05:07.972]                           muffled <- TRUE
[16:05:07.972]                           break
[16:05:07.972]                         }
[16:05:07.972]                       }
[16:05:07.972]                     }
[16:05:07.972]                     invisible(muffled)
[16:05:07.972]                   }
[16:05:07.972]                   muffleCondition(cond)
[16:05:07.972]                 })
[16:05:07.972]             }))
[16:05:07.972]             future::FutureResult(value = ...future.value$value, 
[16:05:07.972]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.972]                   ...future.rng), globalenv = if (FALSE) 
[16:05:07.972]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:07.972]                     ...future.globalenv.names))
[16:05:07.972]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:07.972]         }, condition = base::local({
[16:05:07.972]             c <- base::c
[16:05:07.972]             inherits <- base::inherits
[16:05:07.972]             invokeRestart <- base::invokeRestart
[16:05:07.972]             length <- base::length
[16:05:07.972]             list <- base::list
[16:05:07.972]             seq.int <- base::seq.int
[16:05:07.972]             signalCondition <- base::signalCondition
[16:05:07.972]             sys.calls <- base::sys.calls
[16:05:07.972]             `[[` <- base::`[[`
[16:05:07.972]             `+` <- base::`+`
[16:05:07.972]             `<<-` <- base::`<<-`
[16:05:07.972]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:07.972]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:07.972]                   3L)]
[16:05:07.972]             }
[16:05:07.972]             function(cond) {
[16:05:07.972]                 is_error <- inherits(cond, "error")
[16:05:07.972]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:07.972]                   NULL)
[16:05:07.972]                 if (is_error) {
[16:05:07.972]                   sessionInformation <- function() {
[16:05:07.972]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:07.972]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:07.972]                       search = base::search(), system = base::Sys.info())
[16:05:07.972]                   }
[16:05:07.972]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.972]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:07.972]                     cond$call), session = sessionInformation(), 
[16:05:07.972]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:07.972]                   signalCondition(cond)
[16:05:07.972]                 }
[16:05:07.972]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:07.972]                 "immediateCondition"))) {
[16:05:07.972]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:07.972]                   ...future.conditions[[length(...future.conditions) + 
[16:05:07.972]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:07.972]                   if (TRUE && !signal) {
[16:05:07.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.972]                     {
[16:05:07.972]                       inherits <- base::inherits
[16:05:07.972]                       invokeRestart <- base::invokeRestart
[16:05:07.972]                       is.null <- base::is.null
[16:05:07.972]                       muffled <- FALSE
[16:05:07.972]                       if (inherits(cond, "message")) {
[16:05:07.972]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.972]                         if (muffled) 
[16:05:07.972]                           invokeRestart("muffleMessage")
[16:05:07.972]                       }
[16:05:07.972]                       else if (inherits(cond, "warning")) {
[16:05:07.972]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.972]                         if (muffled) 
[16:05:07.972]                           invokeRestart("muffleWarning")
[16:05:07.972]                       }
[16:05:07.972]                       else if (inherits(cond, "condition")) {
[16:05:07.972]                         if (!is.null(pattern)) {
[16:05:07.972]                           computeRestarts <- base::computeRestarts
[16:05:07.972]                           grepl <- base::grepl
[16:05:07.972]                           restarts <- computeRestarts(cond)
[16:05:07.972]                           for (restart in restarts) {
[16:05:07.972]                             name <- restart$name
[16:05:07.972]                             if (is.null(name)) 
[16:05:07.972]                               next
[16:05:07.972]                             if (!grepl(pattern, name)) 
[16:05:07.972]                               next
[16:05:07.972]                             invokeRestart(restart)
[16:05:07.972]                             muffled <- TRUE
[16:05:07.972]                             break
[16:05:07.972]                           }
[16:05:07.972]                         }
[16:05:07.972]                       }
[16:05:07.972]                       invisible(muffled)
[16:05:07.972]                     }
[16:05:07.972]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.972]                   }
[16:05:07.972]                 }
[16:05:07.972]                 else {
[16:05:07.972]                   if (TRUE) {
[16:05:07.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:07.972]                     {
[16:05:07.972]                       inherits <- base::inherits
[16:05:07.972]                       invokeRestart <- base::invokeRestart
[16:05:07.972]                       is.null <- base::is.null
[16:05:07.972]                       muffled <- FALSE
[16:05:07.972]                       if (inherits(cond, "message")) {
[16:05:07.972]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:07.972]                         if (muffled) 
[16:05:07.972]                           invokeRestart("muffleMessage")
[16:05:07.972]                       }
[16:05:07.972]                       else if (inherits(cond, "warning")) {
[16:05:07.972]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:07.972]                         if (muffled) 
[16:05:07.972]                           invokeRestart("muffleWarning")
[16:05:07.972]                       }
[16:05:07.972]                       else if (inherits(cond, "condition")) {
[16:05:07.972]                         if (!is.null(pattern)) {
[16:05:07.972]                           computeRestarts <- base::computeRestarts
[16:05:07.972]                           grepl <- base::grepl
[16:05:07.972]                           restarts <- computeRestarts(cond)
[16:05:07.972]                           for (restart in restarts) {
[16:05:07.972]                             name <- restart$name
[16:05:07.972]                             if (is.null(name)) 
[16:05:07.972]                               next
[16:05:07.972]                             if (!grepl(pattern, name)) 
[16:05:07.972]                               next
[16:05:07.972]                             invokeRestart(restart)
[16:05:07.972]                             muffled <- TRUE
[16:05:07.972]                             break
[16:05:07.972]                           }
[16:05:07.972]                         }
[16:05:07.972]                       }
[16:05:07.972]                       invisible(muffled)
[16:05:07.972]                     }
[16:05:07.972]                     muffleCondition(cond, pattern = "^muffle")
[16:05:07.972]                   }
[16:05:07.972]                 }
[16:05:07.972]             }
[16:05:07.972]         }))
[16:05:07.972]     }, error = function(ex) {
[16:05:07.972]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:07.972]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:07.972]                 ...future.rng), started = ...future.startTime, 
[16:05:07.972]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:07.972]             version = "1.8"), class = "FutureResult")
[16:05:07.972]     }, finally = {
[16:05:07.972]         if (!identical(...future.workdir, getwd())) 
[16:05:07.972]             setwd(...future.workdir)
[16:05:07.972]         {
[16:05:07.972]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:07.972]                 ...future.oldOptions$nwarnings <- NULL
[16:05:07.972]             }
[16:05:07.972]             base::options(...future.oldOptions)
[16:05:07.972]             if (.Platform$OS.type == "windows") {
[16:05:07.972]                 old_names <- names(...future.oldEnvVars)
[16:05:07.972]                 envs <- base::Sys.getenv()
[16:05:07.972]                 names <- names(envs)
[16:05:07.972]                 common <- intersect(names, old_names)
[16:05:07.972]                 added <- setdiff(names, old_names)
[16:05:07.972]                 removed <- setdiff(old_names, names)
[16:05:07.972]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:07.972]                   envs[common]]
[16:05:07.972]                 NAMES <- toupper(changed)
[16:05:07.972]                 args <- list()
[16:05:07.972]                 for (kk in seq_along(NAMES)) {
[16:05:07.972]                   name <- changed[[kk]]
[16:05:07.972]                   NAME <- NAMES[[kk]]
[16:05:07.972]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.972]                     next
[16:05:07.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.972]                 }
[16:05:07.972]                 NAMES <- toupper(added)
[16:05:07.972]                 for (kk in seq_along(NAMES)) {
[16:05:07.972]                   name <- added[[kk]]
[16:05:07.972]                   NAME <- NAMES[[kk]]
[16:05:07.972]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.972]                     next
[16:05:07.972]                   args[[name]] <- ""
[16:05:07.972]                 }
[16:05:07.972]                 NAMES <- toupper(removed)
[16:05:07.972]                 for (kk in seq_along(NAMES)) {
[16:05:07.972]                   name <- removed[[kk]]
[16:05:07.972]                   NAME <- NAMES[[kk]]
[16:05:07.972]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:07.972]                     next
[16:05:07.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:07.972]                 }
[16:05:07.972]                 if (length(args) > 0) 
[16:05:07.972]                   base::do.call(base::Sys.setenv, args = args)
[16:05:07.972]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:07.972]             }
[16:05:07.972]             else {
[16:05:07.972]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:07.972]             }
[16:05:07.972]             {
[16:05:07.972]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:07.972]                   0L) {
[16:05:07.972]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:07.972]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:07.972]                   base::options(opts)
[16:05:07.972]                 }
[16:05:07.972]                 {
[16:05:07.972]                   {
[16:05:07.972]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:07.972]                     NULL
[16:05:07.972]                   }
[16:05:07.972]                   options(future.plan = NULL)
[16:05:07.972]                   if (is.na(NA_character_)) 
[16:05:07.972]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:07.972]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:07.972]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:07.972]                     envir = parent.frame()) 
[16:05:07.972]                   {
[16:05:07.972]                     default_workers <- missing(workers)
[16:05:07.972]                     if (is.function(workers)) 
[16:05:07.972]                       workers <- workers()
[16:05:07.972]                     workers <- structure(as.integer(workers), 
[16:05:07.972]                       class = class(workers))
[16:05:07.972]                     stop_if_not(is.finite(workers), workers >= 
[16:05:07.972]                       1L)
[16:05:07.972]                     if ((workers == 1L && !inherits(workers, 
[16:05:07.972]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:07.972]                       if (default_workers) 
[16:05:07.972]                         supportsMulticore(warn = TRUE)
[16:05:07.972]                       return(sequential(..., envir = envir))
[16:05:07.972]                     }
[16:05:07.972]                     oopts <- options(mc.cores = workers)
[16:05:07.972]                     on.exit(options(oopts))
[16:05:07.972]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:07.972]                       envir = envir)
[16:05:07.972]                     if (!future$lazy) 
[16:05:07.972]                       future <- run(future)
[16:05:07.972]                     invisible(future)
[16:05:07.972]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:07.972]                 }
[16:05:07.972]             }
[16:05:07.972]         }
[16:05:07.972]     })
[16:05:07.972]     if (TRUE) {
[16:05:07.972]         base::sink(type = "output", split = FALSE)
[16:05:07.972]         if (TRUE) {
[16:05:07.972]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:07.972]         }
[16:05:07.972]         else {
[16:05:07.972]             ...future.result["stdout"] <- base::list(NULL)
[16:05:07.972]         }
[16:05:07.972]         base::close(...future.stdout)
[16:05:07.972]         ...future.stdout <- NULL
[16:05:07.972]     }
[16:05:07.972]     ...future.result$conditions <- ...future.conditions
[16:05:07.972]     ...future.result$finished <- base::Sys.time()
[16:05:07.972]     ...future.result
[16:05:07.972] }
[16:05:07.975] requestCore(): workers = 2
[16:05:07.977] MulticoreFuture started
[16:05:07.978] - Launch lazy future ... done
[16:05:07.978] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:07.978] getGlobalsAndPackages() ...
[16:05:07.979] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:07.979] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:07.979] List of future strategies:
[16:05:07.979] 1. sequential:
[16:05:07.979]    - args: function (..., envir = parent.frame())
[16:05:07.979]    - tweaked: FALSE
[16:05:07.979]    - call: NULL
[16:05:07.980] plan(): nbrOfWorkers() = 1
[16:05:07.982] plan(): Setting new future strategy stack:
[16:05:07.985] List of future strategies:
[16:05:07.985] 1. multicore:
[16:05:07.985]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:07.985]    - tweaked: FALSE
[16:05:07.985]    - call: plan(strategy)
[16:05:07.985] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:07.986] Searching for globals ... DONE
[16:05:07.986] Resolving globals: TRUE
[16:05:07.987] Resolving any globals that are futures ...
[16:05:07.987] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:07.987] Resolving any globals that are futures ... DONE
[16:05:07.988] Resolving futures part of globals (recursively) ...
[16:05:07.989] resolve() on list ...
[16:05:07.989]  recursive: 99
[16:05:07.990]  length: 1
[16:05:07.990]  elements: ‘a’
[16:05:07.991] plan(): nbrOfWorkers() = 2
[16:05:07.991] Future #1
[16:05:07.991] result() for MulticoreFuture ...
[16:05:07.992] result() for MulticoreFuture ...
[16:05:07.993] result() for MulticoreFuture ... done
[16:05:07.993] result() for MulticoreFuture ... done
[16:05:07.993] result() for MulticoreFuture ...
[16:05:07.993] result() for MulticoreFuture ... done
[16:05:07.994] A MulticoreFuture was resolved
[16:05:07.994]  length: 0 (resolved future 1)
[16:05:07.994] resolve() on list ... DONE
[16:05:07.994] - globals: [1] ‘a’
[16:05:07.994] Resolving futures part of globals (recursively) ... DONE
[16:05:07.998] The total size of the 1 globals is 1.57 MiB (1641120 bytes)
[16:05:07.998] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[16:05:07.998] - globals: [1] ‘a’
[16:05:07.998] - packages: [1] ‘future’
[16:05:07.999] getGlobalsAndPackages() ... DONE
[16:05:07.999] run() for ‘Future’ ...
[16:05:07.999] - state: ‘created’
[16:05:07.999] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:08.003] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:08.003] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:08.003]   - Field: ‘label’
[16:05:08.004]   - Field: ‘local’
[16:05:08.004]   - Field: ‘owner’
[16:05:08.004]   - Field: ‘envir’
[16:05:08.004]   - Field: ‘workers’
[16:05:08.004]   - Field: ‘packages’
[16:05:08.004]   - Field: ‘gc’
[16:05:08.004]   - Field: ‘job’
[16:05:08.004]   - Field: ‘conditions’
[16:05:08.004]   - Field: ‘expr’
[16:05:08.005]   - Field: ‘uuid’
[16:05:08.005]   - Field: ‘seed’
[16:05:08.005]   - Field: ‘version’
[16:05:08.005]   - Field: ‘result’
[16:05:08.005]   - Field: ‘asynchronous’
[16:05:08.005]   - Field: ‘calls’
[16:05:08.005]   - Field: ‘globals’
[16:05:08.005]   - Field: ‘stdout’
[16:05:08.005]   - Field: ‘earlySignal’
[16:05:08.006]   - Field: ‘lazy’
[16:05:08.006]   - Field: ‘state’
[16:05:08.006] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:08.006] - Launch lazy future ...
[16:05:08.006] Packages needed by the future expression (n = 1): ‘future’
[16:05:08.006] Packages needed by future strategies (n = 0): <none>
[16:05:08.007] {
[16:05:08.007]     {
[16:05:08.007]         {
[16:05:08.007]             ...future.startTime <- base::Sys.time()
[16:05:08.007]             {
[16:05:08.007]                 {
[16:05:08.007]                   {
[16:05:08.007]                     {
[16:05:08.007]                       {
[16:05:08.007]                         base::local({
[16:05:08.007]                           has_future <- base::requireNamespace("future", 
[16:05:08.007]                             quietly = TRUE)
[16:05:08.007]                           if (has_future) {
[16:05:08.007]                             ns <- base::getNamespace("future")
[16:05:08.007]                             version <- ns[[".package"]][["version"]]
[16:05:08.007]                             if (is.null(version)) 
[16:05:08.007]                               version <- utils::packageVersion("future")
[16:05:08.007]                           }
[16:05:08.007]                           else {
[16:05:08.007]                             version <- NULL
[16:05:08.007]                           }
[16:05:08.007]                           if (!has_future || version < "1.8.0") {
[16:05:08.007]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:08.007]                               "", base::R.version$version.string), 
[16:05:08.007]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:08.007]                                 base::R.version$platform, 8 * 
[16:05:08.007]                                   base::.Machine$sizeof.pointer), 
[16:05:08.007]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:08.007]                                 "release", "version")], collapse = " "), 
[16:05:08.007]                               hostname = base::Sys.info()[["nodename"]])
[16:05:08.007]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:08.007]                               info)
[16:05:08.007]                             info <- base::paste(info, collapse = "; ")
[16:05:08.007]                             if (!has_future) {
[16:05:08.007]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:08.007]                                 info)
[16:05:08.007]                             }
[16:05:08.007]                             else {
[16:05:08.007]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:08.007]                                 info, version)
[16:05:08.007]                             }
[16:05:08.007]                             base::stop(msg)
[16:05:08.007]                           }
[16:05:08.007]                         })
[16:05:08.007]                       }
[16:05:08.007]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:08.007]                       base::options(mc.cores = 1L)
[16:05:08.007]                     }
[16:05:08.007]                     base::local({
[16:05:08.007]                       for (pkg in "future") {
[16:05:08.007]                         base::loadNamespace(pkg)
[16:05:08.007]                         base::library(pkg, character.only = TRUE)
[16:05:08.007]                       }
[16:05:08.007]                     })
[16:05:08.007]                   }
[16:05:08.007]                   options(future.plan = NULL)
[16:05:08.007]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:08.007]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:08.007]                 }
[16:05:08.007]                 ...future.workdir <- getwd()
[16:05:08.007]             }
[16:05:08.007]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:08.007]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:08.007]         }
[16:05:08.007]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:08.007]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:08.007]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:08.007]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:08.007]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:08.007]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:08.007]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:08.007]             base::names(...future.oldOptions))
[16:05:08.007]     }
[16:05:08.007]     if (FALSE) {
[16:05:08.007]     }
[16:05:08.007]     else {
[16:05:08.007]         if (TRUE) {
[16:05:08.007]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:08.007]                 open = "w")
[16:05:08.007]         }
[16:05:08.007]         else {
[16:05:08.007]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:08.007]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:08.007]         }
[16:05:08.007]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:08.007]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:08.007]             base::sink(type = "output", split = FALSE)
[16:05:08.007]             base::close(...future.stdout)
[16:05:08.007]         }, add = TRUE)
[16:05:08.007]     }
[16:05:08.007]     ...future.frame <- base::sys.nframe()
[16:05:08.007]     ...future.conditions <- base::list()
[16:05:08.007]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:08.007]     if (FALSE) {
[16:05:08.007]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:08.007]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:08.007]     }
[16:05:08.007]     ...future.result <- base::tryCatch({
[16:05:08.007]         base::withCallingHandlers({
[16:05:08.007]             ...future.value <- base::withVisible(base::local({
[16:05:08.007]                 withCallingHandlers({
[16:05:08.007]                   value(a) + 1
[16:05:08.007]                 }, immediateCondition = function(cond) {
[16:05:08.007]                   save_rds <- function (object, pathname, ...) 
[16:05:08.007]                   {
[16:05:08.007]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:08.007]                     if (file_test("-f", pathname_tmp)) {
[16:05:08.007]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.007]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:08.007]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.007]                         fi_tmp[["mtime"]])
[16:05:08.007]                     }
[16:05:08.007]                     tryCatch({
[16:05:08.007]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:08.007]                     }, error = function(ex) {
[16:05:08.007]                       msg <- conditionMessage(ex)
[16:05:08.007]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.007]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:08.007]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.007]                         fi_tmp[["mtime"]], msg)
[16:05:08.007]                       ex$message <- msg
[16:05:08.007]                       stop(ex)
[16:05:08.007]                     })
[16:05:08.007]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:08.007]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:08.007]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:08.007]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.007]                       fi <- file.info(pathname)
[16:05:08.007]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:08.007]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.007]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:08.007]                         fi[["size"]], fi[["mtime"]])
[16:05:08.007]                       stop(msg)
[16:05:08.007]                     }
[16:05:08.007]                     invisible(pathname)
[16:05:08.007]                   }
[16:05:08.007]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:08.007]                     rootPath = tempdir()) 
[16:05:08.007]                   {
[16:05:08.007]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:08.007]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:08.007]                       tmpdir = path, fileext = ".rds")
[16:05:08.007]                     save_rds(obj, file)
[16:05:08.007]                   }
[16:05:08.007]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:08.007]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.007]                   {
[16:05:08.007]                     inherits <- base::inherits
[16:05:08.007]                     invokeRestart <- base::invokeRestart
[16:05:08.007]                     is.null <- base::is.null
[16:05:08.007]                     muffled <- FALSE
[16:05:08.007]                     if (inherits(cond, "message")) {
[16:05:08.007]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:08.007]                       if (muffled) 
[16:05:08.007]                         invokeRestart("muffleMessage")
[16:05:08.007]                     }
[16:05:08.007]                     else if (inherits(cond, "warning")) {
[16:05:08.007]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:08.007]                       if (muffled) 
[16:05:08.007]                         invokeRestart("muffleWarning")
[16:05:08.007]                     }
[16:05:08.007]                     else if (inherits(cond, "condition")) {
[16:05:08.007]                       if (!is.null(pattern)) {
[16:05:08.007]                         computeRestarts <- base::computeRestarts
[16:05:08.007]                         grepl <- base::grepl
[16:05:08.007]                         restarts <- computeRestarts(cond)
[16:05:08.007]                         for (restart in restarts) {
[16:05:08.007]                           name <- restart$name
[16:05:08.007]                           if (is.null(name)) 
[16:05:08.007]                             next
[16:05:08.007]                           if (!grepl(pattern, name)) 
[16:05:08.007]                             next
[16:05:08.007]                           invokeRestart(restart)
[16:05:08.007]                           muffled <- TRUE
[16:05:08.007]                           break
[16:05:08.007]                         }
[16:05:08.007]                       }
[16:05:08.007]                     }
[16:05:08.007]                     invisible(muffled)
[16:05:08.007]                   }
[16:05:08.007]                   muffleCondition(cond)
[16:05:08.007]                 })
[16:05:08.007]             }))
[16:05:08.007]             future::FutureResult(value = ...future.value$value, 
[16:05:08.007]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:08.007]                   ...future.rng), globalenv = if (FALSE) 
[16:05:08.007]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:08.007]                     ...future.globalenv.names))
[16:05:08.007]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:08.007]         }, condition = base::local({
[16:05:08.007]             c <- base::c
[16:05:08.007]             inherits <- base::inherits
[16:05:08.007]             invokeRestart <- base::invokeRestart
[16:05:08.007]             length <- base::length
[16:05:08.007]             list <- base::list
[16:05:08.007]             seq.int <- base::seq.int
[16:05:08.007]             signalCondition <- base::signalCondition
[16:05:08.007]             sys.calls <- base::sys.calls
[16:05:08.007]             `[[` <- base::`[[`
[16:05:08.007]             `+` <- base::`+`
[16:05:08.007]             `<<-` <- base::`<<-`
[16:05:08.007]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:08.007]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:08.007]                   3L)]
[16:05:08.007]             }
[16:05:08.007]             function(cond) {
[16:05:08.007]                 is_error <- inherits(cond, "error")
[16:05:08.007]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:08.007]                   NULL)
[16:05:08.007]                 if (is_error) {
[16:05:08.007]                   sessionInformation <- function() {
[16:05:08.007]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:08.007]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:08.007]                       search = base::search(), system = base::Sys.info())
[16:05:08.007]                   }
[16:05:08.007]                   ...future.conditions[[length(...future.conditions) + 
[16:05:08.007]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:08.007]                     cond$call), session = sessionInformation(), 
[16:05:08.007]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:08.007]                   signalCondition(cond)
[16:05:08.007]                 }
[16:05:08.007]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:08.007]                 "immediateCondition"))) {
[16:05:08.007]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:08.007]                   ...future.conditions[[length(...future.conditions) + 
[16:05:08.007]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:08.007]                   if (TRUE && !signal) {
[16:05:08.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.007]                     {
[16:05:08.007]                       inherits <- base::inherits
[16:05:08.007]                       invokeRestart <- base::invokeRestart
[16:05:08.007]                       is.null <- base::is.null
[16:05:08.007]                       muffled <- FALSE
[16:05:08.007]                       if (inherits(cond, "message")) {
[16:05:08.007]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:08.007]                         if (muffled) 
[16:05:08.007]                           invokeRestart("muffleMessage")
[16:05:08.007]                       }
[16:05:08.007]                       else if (inherits(cond, "warning")) {
[16:05:08.007]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:08.007]                         if (muffled) 
[16:05:08.007]                           invokeRestart("muffleWarning")
[16:05:08.007]                       }
[16:05:08.007]                       else if (inherits(cond, "condition")) {
[16:05:08.007]                         if (!is.null(pattern)) {
[16:05:08.007]                           computeRestarts <- base::computeRestarts
[16:05:08.007]                           grepl <- base::grepl
[16:05:08.007]                           restarts <- computeRestarts(cond)
[16:05:08.007]                           for (restart in restarts) {
[16:05:08.007]                             name <- restart$name
[16:05:08.007]                             if (is.null(name)) 
[16:05:08.007]                               next
[16:05:08.007]                             if (!grepl(pattern, name)) 
[16:05:08.007]                               next
[16:05:08.007]                             invokeRestart(restart)
[16:05:08.007]                             muffled <- TRUE
[16:05:08.007]                             break
[16:05:08.007]                           }
[16:05:08.007]                         }
[16:05:08.007]                       }
[16:05:08.007]                       invisible(muffled)
[16:05:08.007]                     }
[16:05:08.007]                     muffleCondition(cond, pattern = "^muffle")
[16:05:08.007]                   }
[16:05:08.007]                 }
[16:05:08.007]                 else {
[16:05:08.007]                   if (TRUE) {
[16:05:08.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.007]                     {
[16:05:08.007]                       inherits <- base::inherits
[16:05:08.007]                       invokeRestart <- base::invokeRestart
[16:05:08.007]                       is.null <- base::is.null
[16:05:08.007]                       muffled <- FALSE
[16:05:08.007]                       if (inherits(cond, "message")) {
[16:05:08.007]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:08.007]                         if (muffled) 
[16:05:08.007]                           invokeRestart("muffleMessage")
[16:05:08.007]                       }
[16:05:08.007]                       else if (inherits(cond, "warning")) {
[16:05:08.007]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:08.007]                         if (muffled) 
[16:05:08.007]                           invokeRestart("muffleWarning")
[16:05:08.007]                       }
[16:05:08.007]                       else if (inherits(cond, "condition")) {
[16:05:08.007]                         if (!is.null(pattern)) {
[16:05:08.007]                           computeRestarts <- base::computeRestarts
[16:05:08.007]                           grepl <- base::grepl
[16:05:08.007]                           restarts <- computeRestarts(cond)
[16:05:08.007]                           for (restart in restarts) {
[16:05:08.007]                             name <- restart$name
[16:05:08.007]                             if (is.null(name)) 
[16:05:08.007]                               next
[16:05:08.007]                             if (!grepl(pattern, name)) 
[16:05:08.007]                               next
[16:05:08.007]                             invokeRestart(restart)
[16:05:08.007]                             muffled <- TRUE
[16:05:08.007]                             break
[16:05:08.007]                           }
[16:05:08.007]                         }
[16:05:08.007]                       }
[16:05:08.007]                       invisible(muffled)
[16:05:08.007]                     }
[16:05:08.007]                     muffleCondition(cond, pattern = "^muffle")
[16:05:08.007]                   }
[16:05:08.007]                 }
[16:05:08.007]             }
[16:05:08.007]         }))
[16:05:08.007]     }, error = function(ex) {
[16:05:08.007]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:08.007]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:08.007]                 ...future.rng), started = ...future.startTime, 
[16:05:08.007]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:08.007]             version = "1.8"), class = "FutureResult")
[16:05:08.007]     }, finally = {
[16:05:08.007]         if (!identical(...future.workdir, getwd())) 
[16:05:08.007]             setwd(...future.workdir)
[16:05:08.007]         {
[16:05:08.007]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:08.007]                 ...future.oldOptions$nwarnings <- NULL
[16:05:08.007]             }
[16:05:08.007]             base::options(...future.oldOptions)
[16:05:08.007]             if (.Platform$OS.type == "windows") {
[16:05:08.007]                 old_names <- names(...future.oldEnvVars)
[16:05:08.007]                 envs <- base::Sys.getenv()
[16:05:08.007]                 names <- names(envs)
[16:05:08.007]                 common <- intersect(names, old_names)
[16:05:08.007]                 added <- setdiff(names, old_names)
[16:05:08.007]                 removed <- setdiff(old_names, names)
[16:05:08.007]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:08.007]                   envs[common]]
[16:05:08.007]                 NAMES <- toupper(changed)
[16:05:08.007]                 args <- list()
[16:05:08.007]                 for (kk in seq_along(NAMES)) {
[16:05:08.007]                   name <- changed[[kk]]
[16:05:08.007]                   NAME <- NAMES[[kk]]
[16:05:08.007]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.007]                     next
[16:05:08.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:08.007]                 }
[16:05:08.007]                 NAMES <- toupper(added)
[16:05:08.007]                 for (kk in seq_along(NAMES)) {
[16:05:08.007]                   name <- added[[kk]]
[16:05:08.007]                   NAME <- NAMES[[kk]]
[16:05:08.007]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.007]                     next
[16:05:08.007]                   args[[name]] <- ""
[16:05:08.007]                 }
[16:05:08.007]                 NAMES <- toupper(removed)
[16:05:08.007]                 for (kk in seq_along(NAMES)) {
[16:05:08.007]                   name <- removed[[kk]]
[16:05:08.007]                   NAME <- NAMES[[kk]]
[16:05:08.007]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.007]                     next
[16:05:08.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:08.007]                 }
[16:05:08.007]                 if (length(args) > 0) 
[16:05:08.007]                   base::do.call(base::Sys.setenv, args = args)
[16:05:08.007]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:08.007]             }
[16:05:08.007]             else {
[16:05:08.007]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:08.007]             }
[16:05:08.007]             {
[16:05:08.007]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:08.007]                   0L) {
[16:05:08.007]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:08.007]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:08.007]                   base::options(opts)
[16:05:08.007]                 }
[16:05:08.007]                 {
[16:05:08.007]                   {
[16:05:08.007]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:08.007]                     NULL
[16:05:08.007]                   }
[16:05:08.007]                   options(future.plan = NULL)
[16:05:08.007]                   if (is.na(NA_character_)) 
[16:05:08.007]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:08.007]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:08.007]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:08.007]                     envir = parent.frame()) 
[16:05:08.007]                   {
[16:05:08.007]                     default_workers <- missing(workers)
[16:05:08.007]                     if (is.function(workers)) 
[16:05:08.007]                       workers <- workers()
[16:05:08.007]                     workers <- structure(as.integer(workers), 
[16:05:08.007]                       class = class(workers))
[16:05:08.007]                     stop_if_not(is.finite(workers), workers >= 
[16:05:08.007]                       1L)
[16:05:08.007]                     if ((workers == 1L && !inherits(workers, 
[16:05:08.007]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:08.007]                       if (default_workers) 
[16:05:08.007]                         supportsMulticore(warn = TRUE)
[16:05:08.007]                       return(sequential(..., envir = envir))
[16:05:08.007]                     }
[16:05:08.007]                     oopts <- options(mc.cores = workers)
[16:05:08.007]                     on.exit(options(oopts))
[16:05:08.007]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:08.007]                       envir = envir)
[16:05:08.007]                     if (!future$lazy) 
[16:05:08.007]                       future <- run(future)
[16:05:08.007]                     invisible(future)
[16:05:08.007]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:08.007]                 }
[16:05:08.007]             }
[16:05:08.007]         }
[16:05:08.007]     })
[16:05:08.007]     if (TRUE) {
[16:05:08.007]         base::sink(type = "output", split = FALSE)
[16:05:08.007]         if (TRUE) {
[16:05:08.007]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:08.007]         }
[16:05:08.007]         else {
[16:05:08.007]             ...future.result["stdout"] <- base::list(NULL)
[16:05:08.007]         }
[16:05:08.007]         base::close(...future.stdout)
[16:05:08.007]         ...future.stdout <- NULL
[16:05:08.007]     }
[16:05:08.007]     ...future.result$conditions <- ...future.conditions
[16:05:08.007]     ...future.result$finished <- base::Sys.time()
[16:05:08.007]     ...future.result
[16:05:08.007] }
[16:05:08.009] assign_globals() ...
[16:05:08.010] List of 1
[16:05:08.010]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a055fd9538> 
[16:05:08.010]  - attr(*, "where")=List of 1
[16:05:08.010]   ..$ a:<environment: R_EmptyEnv> 
[16:05:08.010]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:08.010]  - attr(*, "resolved")= logi TRUE
[16:05:08.010]  - attr(*, "total_size")= num 1641120
[16:05:08.010]  - attr(*, "already-done")= logi TRUE
[16:05:08.012] - copied ‘a’ to environment
[16:05:08.013] assign_globals() ... done
[16:05:08.013] requestCore(): workers = 2
[16:05:08.015] MulticoreFuture started
[16:05:08.015] - Launch lazy future ... done
[16:05:08.015] run() for ‘MulticoreFuture’ ... done
[16:05:08.016] result() for MulticoreFuture ...
[16:05:08.016] plan(): Setting new future strategy stack:
[16:05:08.016] List of future strategies:
[16:05:08.016] 1. sequential:
[16:05:08.016]    - args: function (..., envir = parent.frame())
[16:05:08.016]    - tweaked: FALSE
[16:05:08.016]    - call: NULL
[16:05:08.017] plan(): nbrOfWorkers() = 1
[16:05:08.021] plan(): Setting new future strategy stack:
[16:05:08.021] List of future strategies:
[16:05:08.021] 1. multicore:
[16:05:08.021]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:08.021]    - tweaked: FALSE
[16:05:08.021]    - call: plan(strategy)
[16:05:08.026] plan(): nbrOfWorkers() = 2
[16:05:08.027] result() for MulticoreFuture ...
[16:05:08.027] result() for MulticoreFuture ... done
[16:05:08.027] signalConditions() ...
[16:05:08.028]  - include = ‘immediateCondition’
[16:05:08.028]  - exclude = 
[16:05:08.028]  - resignal = FALSE
[16:05:08.028]  - Number of conditions: 4
[16:05:08.028] signalConditions() ... done
[16:05:08.028] result() for MulticoreFuture ... done
[16:05:08.028] result() for MulticoreFuture ...
[16:05:08.028] result() for MulticoreFuture ... done
[16:05:08.029] signalConditions() ...
[16:05:08.029]  - include = ‘immediateCondition’
[16:05:08.029]  - exclude = 
[16:05:08.029]  - resignal = FALSE
[16:05:08.029]  - Number of conditions: 4
[16:05:08.029] signalConditions() ... done
[16:05:08.029] Future state: ‘finished’
[16:05:08.029] result() for MulticoreFuture ...
[16:05:08.030] result() for MulticoreFuture ... done
[16:05:08.030] signalConditions() ...
[16:05:08.030]  - include = ‘condition’
[16:05:08.030]  - exclude = ‘immediateCondition’
[16:05:08.030]  - resignal = TRUE
[16:05:08.030]  - Number of conditions: 4
[16:05:08.030]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.019] result() for MulticoreFuture ...
[16:05:08.030]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.019] result() for MulticoreFuture ... done
[16:05:08.031]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.019] result() for MulticoreFuture ...
[16:05:08.033]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.020] result() for MulticoreFuture ... done
[16:05:08.034] signalConditions() ... done
value(b) = 2
[16:05:08.034] result() for MulticoreFuture ...
[16:05:08.034] result() for MulticoreFuture ... done
[16:05:08.035] result() for MulticoreFuture ...
[16:05:08.035] result() for MulticoreFuture ... done
[16:05:08.035] signalConditions() ...
[16:05:08.035]  - include = ‘immediateCondition’
[16:05:08.035]  - exclude = 
[16:05:08.035]  - resignal = FALSE
[16:05:08.035]  - Number of conditions: 4
[16:05:08.036] signalConditions() ... done
[16:05:08.036] Future state: ‘finished’
[16:05:08.036] result() for MulticoreFuture ...
[16:05:08.036] result() for MulticoreFuture ... done
[16:05:08.036] signalConditions() ...
[16:05:08.036]  - include = ‘condition’
[16:05:08.037]  - exclude = ‘immediateCondition’
[16:05:08.037]  - resignal = TRUE
[16:05:08.037]  - Number of conditions: 4
[16:05:08.037]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.019] result() for MulticoreFuture ...
[16:05:08.037]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.019] result() for MulticoreFuture ... done
[16:05:08.037]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.019] result() for MulticoreFuture ...
[16:05:08.038]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.020] result() for MulticoreFuture ... done
[16:05:08.038] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:08.038] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:08.039] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:08.039] 
[16:05:08.040] Searching for globals ... DONE
[16:05:08.040] - globals: [0] <none>
[16:05:08.040] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:08.040] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:08.041] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:08.042] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:08.042] Searching for globals ... DONE
[16:05:08.042] Resolving globals: TRUE
[16:05:08.042] Resolving any globals that are futures ...
[16:05:08.042] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:08.042] Resolving any globals that are futures ... DONE
[16:05:08.043] Resolving futures part of globals (recursively) ...
[16:05:08.043] resolve() on list ...
[16:05:08.043]  recursive: 99
[16:05:08.043]  length: 1
[16:05:08.043]  elements: ‘a’
[16:05:08.043] run() for ‘Future’ ...
[16:05:08.044] - state: ‘created’
[16:05:08.044] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:08.048] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:08.048] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:08.048]   - Field: ‘label’
[16:05:08.048]   - Field: ‘local’
[16:05:08.048]   - Field: ‘owner’
[16:05:08.049]   - Field: ‘envir’
[16:05:08.049]   - Field: ‘workers’
[16:05:08.049]   - Field: ‘packages’
[16:05:08.049]   - Field: ‘gc’
[16:05:08.049]   - Field: ‘job’
[16:05:08.049]   - Field: ‘conditions’
[16:05:08.049]   - Field: ‘expr’
[16:05:08.049]   - Field: ‘uuid’
[16:05:08.049]   - Field: ‘seed’
[16:05:08.050]   - Field: ‘version’
[16:05:08.050]   - Field: ‘result’
[16:05:08.050]   - Field: ‘asynchronous’
[16:05:08.050]   - Field: ‘calls’
[16:05:08.050]   - Field: ‘globals’
[16:05:08.050]   - Field: ‘stdout’
[16:05:08.050]   - Field: ‘earlySignal’
[16:05:08.050]   - Field: ‘lazy’
[16:05:08.050]   - Field: ‘state’
[16:05:08.051] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:08.051] - Launch lazy future ...
[16:05:08.051] Packages needed by the future expression (n = 0): <none>
[16:05:08.051] Packages needed by future strategies (n = 0): <none>
[16:05:08.052] {
[16:05:08.052]     {
[16:05:08.052]         {
[16:05:08.052]             ...future.startTime <- base::Sys.time()
[16:05:08.052]             {
[16:05:08.052]                 {
[16:05:08.052]                   {
[16:05:08.052]                     {
[16:05:08.052]                       base::local({
[16:05:08.052]                         has_future <- base::requireNamespace("future", 
[16:05:08.052]                           quietly = TRUE)
[16:05:08.052]                         if (has_future) {
[16:05:08.052]                           ns <- base::getNamespace("future")
[16:05:08.052]                           version <- ns[[".package"]][["version"]]
[16:05:08.052]                           if (is.null(version)) 
[16:05:08.052]                             version <- utils::packageVersion("future")
[16:05:08.052]                         }
[16:05:08.052]                         else {
[16:05:08.052]                           version <- NULL
[16:05:08.052]                         }
[16:05:08.052]                         if (!has_future || version < "1.8.0") {
[16:05:08.052]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:08.052]                             "", base::R.version$version.string), 
[16:05:08.052]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:08.052]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:08.052]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:08.052]                               "release", "version")], collapse = " "), 
[16:05:08.052]                             hostname = base::Sys.info()[["nodename"]])
[16:05:08.052]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:08.052]                             info)
[16:05:08.052]                           info <- base::paste(info, collapse = "; ")
[16:05:08.052]                           if (!has_future) {
[16:05:08.052]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:08.052]                               info)
[16:05:08.052]                           }
[16:05:08.052]                           else {
[16:05:08.052]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:08.052]                               info, version)
[16:05:08.052]                           }
[16:05:08.052]                           base::stop(msg)
[16:05:08.052]                         }
[16:05:08.052]                       })
[16:05:08.052]                     }
[16:05:08.052]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:08.052]                     base::options(mc.cores = 1L)
[16:05:08.052]                   }
[16:05:08.052]                   options(future.plan = NULL)
[16:05:08.052]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:08.052]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:08.052]                 }
[16:05:08.052]                 ...future.workdir <- getwd()
[16:05:08.052]             }
[16:05:08.052]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:08.052]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:08.052]         }
[16:05:08.052]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:08.052]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:08.052]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:08.052]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:08.052]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:08.052]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:08.052]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:08.052]             base::names(...future.oldOptions))
[16:05:08.052]     }
[16:05:08.052]     if (FALSE) {
[16:05:08.052]     }
[16:05:08.052]     else {
[16:05:08.052]         if (TRUE) {
[16:05:08.052]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:08.052]                 open = "w")
[16:05:08.052]         }
[16:05:08.052]         else {
[16:05:08.052]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:08.052]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:08.052]         }
[16:05:08.052]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:08.052]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:08.052]             base::sink(type = "output", split = FALSE)
[16:05:08.052]             base::close(...future.stdout)
[16:05:08.052]         }, add = TRUE)
[16:05:08.052]     }
[16:05:08.052]     ...future.frame <- base::sys.nframe()
[16:05:08.052]     ...future.conditions <- base::list()
[16:05:08.052]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:08.052]     if (FALSE) {
[16:05:08.052]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:08.052]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:08.052]     }
[16:05:08.052]     ...future.result <- base::tryCatch({
[16:05:08.052]         base::withCallingHandlers({
[16:05:08.052]             ...future.value <- base::withVisible(base::local({
[16:05:08.052]                 withCallingHandlers({
[16:05:08.052]                   1
[16:05:08.052]                 }, immediateCondition = function(cond) {
[16:05:08.052]                   save_rds <- function (object, pathname, ...) 
[16:05:08.052]                   {
[16:05:08.052]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:08.052]                     if (file_test("-f", pathname_tmp)) {
[16:05:08.052]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.052]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:08.052]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.052]                         fi_tmp[["mtime"]])
[16:05:08.052]                     }
[16:05:08.052]                     tryCatch({
[16:05:08.052]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:08.052]                     }, error = function(ex) {
[16:05:08.052]                       msg <- conditionMessage(ex)
[16:05:08.052]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.052]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:08.052]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.052]                         fi_tmp[["mtime"]], msg)
[16:05:08.052]                       ex$message <- msg
[16:05:08.052]                       stop(ex)
[16:05:08.052]                     })
[16:05:08.052]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:08.052]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:08.052]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:08.052]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.052]                       fi <- file.info(pathname)
[16:05:08.052]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:08.052]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.052]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:08.052]                         fi[["size"]], fi[["mtime"]])
[16:05:08.052]                       stop(msg)
[16:05:08.052]                     }
[16:05:08.052]                     invisible(pathname)
[16:05:08.052]                   }
[16:05:08.052]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:08.052]                     rootPath = tempdir()) 
[16:05:08.052]                   {
[16:05:08.052]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:08.052]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:08.052]                       tmpdir = path, fileext = ".rds")
[16:05:08.052]                     save_rds(obj, file)
[16:05:08.052]                   }
[16:05:08.052]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:08.052]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.052]                   {
[16:05:08.052]                     inherits <- base::inherits
[16:05:08.052]                     invokeRestart <- base::invokeRestart
[16:05:08.052]                     is.null <- base::is.null
[16:05:08.052]                     muffled <- FALSE
[16:05:08.052]                     if (inherits(cond, "message")) {
[16:05:08.052]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:08.052]                       if (muffled) 
[16:05:08.052]                         invokeRestart("muffleMessage")
[16:05:08.052]                     }
[16:05:08.052]                     else if (inherits(cond, "warning")) {
[16:05:08.052]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:08.052]                       if (muffled) 
[16:05:08.052]                         invokeRestart("muffleWarning")
[16:05:08.052]                     }
[16:05:08.052]                     else if (inherits(cond, "condition")) {
[16:05:08.052]                       if (!is.null(pattern)) {
[16:05:08.052]                         computeRestarts <- base::computeRestarts
[16:05:08.052]                         grepl <- base::grepl
[16:05:08.052]                         restarts <- computeRestarts(cond)
[16:05:08.052]                         for (restart in restarts) {
[16:05:08.052]                           name <- restart$name
[16:05:08.052]                           if (is.null(name)) 
[16:05:08.052]                             next
[16:05:08.052]                           if (!grepl(pattern, name)) 
[16:05:08.052]                             next
[16:05:08.052]                           invokeRestart(restart)
[16:05:08.052]                           muffled <- TRUE
[16:05:08.052]                           break
[16:05:08.052]                         }
[16:05:08.052]                       }
[16:05:08.052]                     }
[16:05:08.052]                     invisible(muffled)
[16:05:08.052]                   }
[16:05:08.052]                   muffleCondition(cond)
[16:05:08.052]                 })
[16:05:08.052]             }))
[16:05:08.052]             future::FutureResult(value = ...future.value$value, 
[16:05:08.052]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:08.052]                   ...future.rng), globalenv = if (FALSE) 
[16:05:08.052]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:08.052]                     ...future.globalenv.names))
[16:05:08.052]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:08.052]         }, condition = base::local({
[16:05:08.052]             c <- base::c
[16:05:08.052]             inherits <- base::inherits
[16:05:08.052]             invokeRestart <- base::invokeRestart
[16:05:08.052]             length <- base::length
[16:05:08.052]             list <- base::list
[16:05:08.052]             seq.int <- base::seq.int
[16:05:08.052]             signalCondition <- base::signalCondition
[16:05:08.052]             sys.calls <- base::sys.calls
[16:05:08.052]             `[[` <- base::`[[`
[16:05:08.052]             `+` <- base::`+`
[16:05:08.052]             `<<-` <- base::`<<-`
[16:05:08.052]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:08.052]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:08.052]                   3L)]
[16:05:08.052]             }
[16:05:08.052]             function(cond) {
[16:05:08.052]                 is_error <- inherits(cond, "error")
[16:05:08.052]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:08.052]                   NULL)
[16:05:08.052]                 if (is_error) {
[16:05:08.052]                   sessionInformation <- function() {
[16:05:08.052]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:08.052]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:08.052]                       search = base::search(), system = base::Sys.info())
[16:05:08.052]                   }
[16:05:08.052]                   ...future.conditions[[length(...future.conditions) + 
[16:05:08.052]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:08.052]                     cond$call), session = sessionInformation(), 
[16:05:08.052]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:08.052]                   signalCondition(cond)
[16:05:08.052]                 }
[16:05:08.052]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:08.052]                 "immediateCondition"))) {
[16:05:08.052]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:08.052]                   ...future.conditions[[length(...future.conditions) + 
[16:05:08.052]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:08.052]                   if (TRUE && !signal) {
[16:05:08.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.052]                     {
[16:05:08.052]                       inherits <- base::inherits
[16:05:08.052]                       invokeRestart <- base::invokeRestart
[16:05:08.052]                       is.null <- base::is.null
[16:05:08.052]                       muffled <- FALSE
[16:05:08.052]                       if (inherits(cond, "message")) {
[16:05:08.052]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:08.052]                         if (muffled) 
[16:05:08.052]                           invokeRestart("muffleMessage")
[16:05:08.052]                       }
[16:05:08.052]                       else if (inherits(cond, "warning")) {
[16:05:08.052]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:08.052]                         if (muffled) 
[16:05:08.052]                           invokeRestart("muffleWarning")
[16:05:08.052]                       }
[16:05:08.052]                       else if (inherits(cond, "condition")) {
[16:05:08.052]                         if (!is.null(pattern)) {
[16:05:08.052]                           computeRestarts <- base::computeRestarts
[16:05:08.052]                           grepl <- base::grepl
[16:05:08.052]                           restarts <- computeRestarts(cond)
[16:05:08.052]                           for (restart in restarts) {
[16:05:08.052]                             name <- restart$name
[16:05:08.052]                             if (is.null(name)) 
[16:05:08.052]                               next
[16:05:08.052]                             if (!grepl(pattern, name)) 
[16:05:08.052]                               next
[16:05:08.052]                             invokeRestart(restart)
[16:05:08.052]                             muffled <- TRUE
[16:05:08.052]                             break
[16:05:08.052]                           }
[16:05:08.052]                         }
[16:05:08.052]                       }
[16:05:08.052]                       invisible(muffled)
[16:05:08.052]                     }
[16:05:08.052]                     muffleCondition(cond, pattern = "^muffle")
[16:05:08.052]                   }
[16:05:08.052]                 }
[16:05:08.052]                 else {
[16:05:08.052]                   if (TRUE) {
[16:05:08.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.052]                     {
[16:05:08.052]                       inherits <- base::inherits
[16:05:08.052]                       invokeRestart <- base::invokeRestart
[16:05:08.052]                       is.null <- base::is.null
[16:05:08.052]                       muffled <- FALSE
[16:05:08.052]                       if (inherits(cond, "message")) {
[16:05:08.052]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:08.052]                         if (muffled) 
[16:05:08.052]                           invokeRestart("muffleMessage")
[16:05:08.052]                       }
[16:05:08.052]                       else if (inherits(cond, "warning")) {
[16:05:08.052]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:08.052]                         if (muffled) 
[16:05:08.052]                           invokeRestart("muffleWarning")
[16:05:08.052]                       }
[16:05:08.052]                       else if (inherits(cond, "condition")) {
[16:05:08.052]                         if (!is.null(pattern)) {
[16:05:08.052]                           computeRestarts <- base::computeRestarts
[16:05:08.052]                           grepl <- base::grepl
[16:05:08.052]                           restarts <- computeRestarts(cond)
[16:05:08.052]                           for (restart in restarts) {
[16:05:08.052]                             name <- restart$name
[16:05:08.052]                             if (is.null(name)) 
[16:05:08.052]                               next
[16:05:08.052]                             if (!grepl(pattern, name)) 
[16:05:08.052]                               next
[16:05:08.052]                             invokeRestart(restart)
[16:05:08.052]                             muffled <- TRUE
[16:05:08.052]                             break
[16:05:08.052]                           }
[16:05:08.052]                         }
[16:05:08.052]                       }
[16:05:08.052]                       invisible(muffled)
[16:05:08.052]                     }
[16:05:08.052]                     muffleCondition(cond, pattern = "^muffle")
[16:05:08.052]                   }
[16:05:08.052]                 }
[16:05:08.052]             }
[16:05:08.052]         }))
[16:05:08.052]     }, error = function(ex) {
[16:05:08.052]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:08.052]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:08.052]                 ...future.rng), started = ...future.startTime, 
[16:05:08.052]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:08.052]             version = "1.8"), class = "FutureResult")
[16:05:08.052]     }, finally = {
[16:05:08.052]         if (!identical(...future.workdir, getwd())) 
[16:05:08.052]             setwd(...future.workdir)
[16:05:08.052]         {
[16:05:08.052]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:08.052]                 ...future.oldOptions$nwarnings <- NULL
[16:05:08.052]             }
[16:05:08.052]             base::options(...future.oldOptions)
[16:05:08.052]             if (.Platform$OS.type == "windows") {
[16:05:08.052]                 old_names <- names(...future.oldEnvVars)
[16:05:08.052]                 envs <- base::Sys.getenv()
[16:05:08.052]                 names <- names(envs)
[16:05:08.052]                 common <- intersect(names, old_names)
[16:05:08.052]                 added <- setdiff(names, old_names)
[16:05:08.052]                 removed <- setdiff(old_names, names)
[16:05:08.052]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:08.052]                   envs[common]]
[16:05:08.052]                 NAMES <- toupper(changed)
[16:05:08.052]                 args <- list()
[16:05:08.052]                 for (kk in seq_along(NAMES)) {
[16:05:08.052]                   name <- changed[[kk]]
[16:05:08.052]                   NAME <- NAMES[[kk]]
[16:05:08.052]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.052]                     next
[16:05:08.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:08.052]                 }
[16:05:08.052]                 NAMES <- toupper(added)
[16:05:08.052]                 for (kk in seq_along(NAMES)) {
[16:05:08.052]                   name <- added[[kk]]
[16:05:08.052]                   NAME <- NAMES[[kk]]
[16:05:08.052]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.052]                     next
[16:05:08.052]                   args[[name]] <- ""
[16:05:08.052]                 }
[16:05:08.052]                 NAMES <- toupper(removed)
[16:05:08.052]                 for (kk in seq_along(NAMES)) {
[16:05:08.052]                   name <- removed[[kk]]
[16:05:08.052]                   NAME <- NAMES[[kk]]
[16:05:08.052]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.052]                     next
[16:05:08.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:08.052]                 }
[16:05:08.052]                 if (length(args) > 0) 
[16:05:08.052]                   base::do.call(base::Sys.setenv, args = args)
[16:05:08.052]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:08.052]             }
[16:05:08.052]             else {
[16:05:08.052]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:08.052]             }
[16:05:08.052]             {
[16:05:08.052]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:08.052]                   0L) {
[16:05:08.052]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:08.052]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:08.052]                   base::options(opts)
[16:05:08.052]                 }
[16:05:08.052]                 {
[16:05:08.052]                   {
[16:05:08.052]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:08.052]                     NULL
[16:05:08.052]                   }
[16:05:08.052]                   options(future.plan = NULL)
[16:05:08.052]                   if (is.na(NA_character_)) 
[16:05:08.052]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:08.052]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:08.052]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:08.052]                     envir = parent.frame()) 
[16:05:08.052]                   {
[16:05:08.052]                     default_workers <- missing(workers)
[16:05:08.052]                     if (is.function(workers)) 
[16:05:08.052]                       workers <- workers()
[16:05:08.052]                     workers <- structure(as.integer(workers), 
[16:05:08.052]                       class = class(workers))
[16:05:08.052]                     stop_if_not(is.finite(workers), workers >= 
[16:05:08.052]                       1L)
[16:05:08.052]                     if ((workers == 1L && !inherits(workers, 
[16:05:08.052]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:08.052]                       if (default_workers) 
[16:05:08.052]                         supportsMulticore(warn = TRUE)
[16:05:08.052]                       return(sequential(..., envir = envir))
[16:05:08.052]                     }
[16:05:08.052]                     oopts <- options(mc.cores = workers)
[16:05:08.052]                     on.exit(options(oopts))
[16:05:08.052]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:08.052]                       envir = envir)
[16:05:08.052]                     if (!future$lazy) 
[16:05:08.052]                       future <- run(future)
[16:05:08.052]                     invisible(future)
[16:05:08.052]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:08.052]                 }
[16:05:08.052]             }
[16:05:08.052]         }
[16:05:08.052]     })
[16:05:08.052]     if (TRUE) {
[16:05:08.052]         base::sink(type = "output", split = FALSE)
[16:05:08.052]         if (TRUE) {
[16:05:08.052]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:08.052]         }
[16:05:08.052]         else {
[16:05:08.052]             ...future.result["stdout"] <- base::list(NULL)
[16:05:08.052]         }
[16:05:08.052]         base::close(...future.stdout)
[16:05:08.052]         ...future.stdout <- NULL
[16:05:08.052]     }
[16:05:08.052]     ...future.result$conditions <- ...future.conditions
[16:05:08.052]     ...future.result$finished <- base::Sys.time()
[16:05:08.052]     ...future.result
[16:05:08.052] }
[16:05:08.054] requestCore(): workers = 2
[16:05:08.056] MulticoreFuture started
[16:05:08.057] - Launch lazy future ... done
[16:05:08.057] run() for ‘MulticoreFuture’ ... done
[16:05:08.057] plan(): Setting new future strategy stack:
[16:05:08.057] List of future strategies:
[16:05:08.057] 1. sequential:
[16:05:08.057]    - args: function (..., envir = parent.frame())
[16:05:08.057]    - tweaked: FALSE
[16:05:08.057]    - call: NULL
[16:05:08.058] plan(): nbrOfWorkers() = 1
[16:05:08.061] plan(): Setting new future strategy stack:
[16:05:08.061] List of future strategies:
[16:05:08.061] 1. multicore:
[16:05:08.061]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:08.061]    - tweaked: FALSE
[16:05:08.061]    - call: plan(strategy)
[16:05:08.066] plan(): nbrOfWorkers() = 2
[16:05:08.067] Future #1
[16:05:08.067] result() for MulticoreFuture ...
[16:05:08.068] result() for MulticoreFuture ...
[16:05:08.068] result() for MulticoreFuture ... done
[16:05:08.068] result() for MulticoreFuture ... done
[16:05:08.069] result() for MulticoreFuture ...
[16:05:08.069] result() for MulticoreFuture ... done
[16:05:08.069] A MulticoreFuture was resolved
[16:05:08.069]  length: 0 (resolved future 1)
[16:05:08.069] resolve() on list ... DONE
[16:05:08.069] - globals: [1] ‘a’
[16:05:08.070] Resolving futures part of globals (recursively) ... DONE
[16:05:08.072] The total size of the 1 globals is 1.57 MiB (1641288 bytes)
[16:05:08.073] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[16:05:08.073] - globals: [1] ‘a’
[16:05:08.073] - packages: [1] ‘future’
[16:05:08.073] getGlobalsAndPackages() ... DONE
[16:05:08.074] run() for ‘Future’ ...
[16:05:08.074] - state: ‘created’
[16:05:08.074] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:08.081] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:08.081] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:08.082]   - Field: ‘label’
[16:05:08.082]   - Field: ‘local’
[16:05:08.082]   - Field: ‘owner’
[16:05:08.082]   - Field: ‘envir’
[16:05:08.082]   - Field: ‘workers’
[16:05:08.082]   - Field: ‘packages’
[16:05:08.083]   - Field: ‘gc’
[16:05:08.083]   - Field: ‘job’
[16:05:08.083]   - Field: ‘conditions’
[16:05:08.083]   - Field: ‘expr’
[16:05:08.083]   - Field: ‘uuid’
[16:05:08.083]   - Field: ‘seed’
[16:05:08.083]   - Field: ‘version’
[16:05:08.084]   - Field: ‘result’
[16:05:08.084]   - Field: ‘asynchronous’
[16:05:08.084]   - Field: ‘calls’
[16:05:08.084]   - Field: ‘globals’
[16:05:08.084]   - Field: ‘stdout’
[16:05:08.084]   - Field: ‘earlySignal’
[16:05:08.085]   - Field: ‘lazy’
[16:05:08.085]   - Field: ‘state’
[16:05:08.085] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:08.085] - Launch lazy future ...
[16:05:08.085] Packages needed by the future expression (n = 1): ‘future’
[16:05:08.086] Packages needed by future strategies (n = 0): <none>
[16:05:08.086] {
[16:05:08.086]     {
[16:05:08.086]         {
[16:05:08.086]             ...future.startTime <- base::Sys.time()
[16:05:08.086]             {
[16:05:08.086]                 {
[16:05:08.086]                   {
[16:05:08.086]                     {
[16:05:08.086]                       {
[16:05:08.086]                         base::local({
[16:05:08.086]                           has_future <- base::requireNamespace("future", 
[16:05:08.086]                             quietly = TRUE)
[16:05:08.086]                           if (has_future) {
[16:05:08.086]                             ns <- base::getNamespace("future")
[16:05:08.086]                             version <- ns[[".package"]][["version"]]
[16:05:08.086]                             if (is.null(version)) 
[16:05:08.086]                               version <- utils::packageVersion("future")
[16:05:08.086]                           }
[16:05:08.086]                           else {
[16:05:08.086]                             version <- NULL
[16:05:08.086]                           }
[16:05:08.086]                           if (!has_future || version < "1.8.0") {
[16:05:08.086]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:08.086]                               "", base::R.version$version.string), 
[16:05:08.086]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:08.086]                                 base::R.version$platform, 8 * 
[16:05:08.086]                                   base::.Machine$sizeof.pointer), 
[16:05:08.086]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:08.086]                                 "release", "version")], collapse = " "), 
[16:05:08.086]                               hostname = base::Sys.info()[["nodename"]])
[16:05:08.086]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:08.086]                               info)
[16:05:08.086]                             info <- base::paste(info, collapse = "; ")
[16:05:08.086]                             if (!has_future) {
[16:05:08.086]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:08.086]                                 info)
[16:05:08.086]                             }
[16:05:08.086]                             else {
[16:05:08.086]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:08.086]                                 info, version)
[16:05:08.086]                             }
[16:05:08.086]                             base::stop(msg)
[16:05:08.086]                           }
[16:05:08.086]                         })
[16:05:08.086]                       }
[16:05:08.086]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:08.086]                       base::options(mc.cores = 1L)
[16:05:08.086]                     }
[16:05:08.086]                     base::local({
[16:05:08.086]                       for (pkg in "future") {
[16:05:08.086]                         base::loadNamespace(pkg)
[16:05:08.086]                         base::library(pkg, character.only = TRUE)
[16:05:08.086]                       }
[16:05:08.086]                     })
[16:05:08.086]                   }
[16:05:08.086]                   options(future.plan = NULL)
[16:05:08.086]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:08.086]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:08.086]                 }
[16:05:08.086]                 ...future.workdir <- getwd()
[16:05:08.086]             }
[16:05:08.086]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:08.086]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:08.086]         }
[16:05:08.086]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:08.086]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:08.086]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:08.086]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:08.086]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:08.086]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:08.086]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:08.086]             base::names(...future.oldOptions))
[16:05:08.086]     }
[16:05:08.086]     if (FALSE) {
[16:05:08.086]     }
[16:05:08.086]     else {
[16:05:08.086]         if (TRUE) {
[16:05:08.086]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:08.086]                 open = "w")
[16:05:08.086]         }
[16:05:08.086]         else {
[16:05:08.086]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:08.086]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:08.086]         }
[16:05:08.086]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:08.086]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:08.086]             base::sink(type = "output", split = FALSE)
[16:05:08.086]             base::close(...future.stdout)
[16:05:08.086]         }, add = TRUE)
[16:05:08.086]     }
[16:05:08.086]     ...future.frame <- base::sys.nframe()
[16:05:08.086]     ...future.conditions <- base::list()
[16:05:08.086]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:08.086]     if (FALSE) {
[16:05:08.086]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:08.086]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:08.086]     }
[16:05:08.086]     ...future.result <- base::tryCatch({
[16:05:08.086]         base::withCallingHandlers({
[16:05:08.086]             ...future.value <- base::withVisible(base::local({
[16:05:08.086]                 withCallingHandlers({
[16:05:08.086]                   value(a) + 1
[16:05:08.086]                 }, immediateCondition = function(cond) {
[16:05:08.086]                   save_rds <- function (object, pathname, ...) 
[16:05:08.086]                   {
[16:05:08.086]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:08.086]                     if (file_test("-f", pathname_tmp)) {
[16:05:08.086]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.086]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:08.086]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.086]                         fi_tmp[["mtime"]])
[16:05:08.086]                     }
[16:05:08.086]                     tryCatch({
[16:05:08.086]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:08.086]                     }, error = function(ex) {
[16:05:08.086]                       msg <- conditionMessage(ex)
[16:05:08.086]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.086]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:08.086]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.086]                         fi_tmp[["mtime"]], msg)
[16:05:08.086]                       ex$message <- msg
[16:05:08.086]                       stop(ex)
[16:05:08.086]                     })
[16:05:08.086]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:08.086]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:08.086]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:08.086]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.086]                       fi <- file.info(pathname)
[16:05:08.086]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:08.086]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.086]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:08.086]                         fi[["size"]], fi[["mtime"]])
[16:05:08.086]                       stop(msg)
[16:05:08.086]                     }
[16:05:08.086]                     invisible(pathname)
[16:05:08.086]                   }
[16:05:08.086]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:08.086]                     rootPath = tempdir()) 
[16:05:08.086]                   {
[16:05:08.086]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:08.086]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:08.086]                       tmpdir = path, fileext = ".rds")
[16:05:08.086]                     save_rds(obj, file)
[16:05:08.086]                   }
[16:05:08.086]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:08.086]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.086]                   {
[16:05:08.086]                     inherits <- base::inherits
[16:05:08.086]                     invokeRestart <- base::invokeRestart
[16:05:08.086]                     is.null <- base::is.null
[16:05:08.086]                     muffled <- FALSE
[16:05:08.086]                     if (inherits(cond, "message")) {
[16:05:08.086]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:08.086]                       if (muffled) 
[16:05:08.086]                         invokeRestart("muffleMessage")
[16:05:08.086]                     }
[16:05:08.086]                     else if (inherits(cond, "warning")) {
[16:05:08.086]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:08.086]                       if (muffled) 
[16:05:08.086]                         invokeRestart("muffleWarning")
[16:05:08.086]                     }
[16:05:08.086]                     else if (inherits(cond, "condition")) {
[16:05:08.086]                       if (!is.null(pattern)) {
[16:05:08.086]                         computeRestarts <- base::computeRestarts
[16:05:08.086]                         grepl <- base::grepl
[16:05:08.086]                         restarts <- computeRestarts(cond)
[16:05:08.086]                         for (restart in restarts) {
[16:05:08.086]                           name <- restart$name
[16:05:08.086]                           if (is.null(name)) 
[16:05:08.086]                             next
[16:05:08.086]                           if (!grepl(pattern, name)) 
[16:05:08.086]                             next
[16:05:08.086]                           invokeRestart(restart)
[16:05:08.086]                           muffled <- TRUE
[16:05:08.086]                           break
[16:05:08.086]                         }
[16:05:08.086]                       }
[16:05:08.086]                     }
[16:05:08.086]                     invisible(muffled)
[16:05:08.086]                   }
[16:05:08.086]                   muffleCondition(cond)
[16:05:08.086]                 })
[16:05:08.086]             }))
[16:05:08.086]             future::FutureResult(value = ...future.value$value, 
[16:05:08.086]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:08.086]                   ...future.rng), globalenv = if (FALSE) 
[16:05:08.086]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:08.086]                     ...future.globalenv.names))
[16:05:08.086]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:08.086]         }, condition = base::local({
[16:05:08.086]             c <- base::c
[16:05:08.086]             inherits <- base::inherits
[16:05:08.086]             invokeRestart <- base::invokeRestart
[16:05:08.086]             length <- base::length
[16:05:08.086]             list <- base::list
[16:05:08.086]             seq.int <- base::seq.int
[16:05:08.086]             signalCondition <- base::signalCondition
[16:05:08.086]             sys.calls <- base::sys.calls
[16:05:08.086]             `[[` <- base::`[[`
[16:05:08.086]             `+` <- base::`+`
[16:05:08.086]             `<<-` <- base::`<<-`
[16:05:08.086]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:08.086]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:08.086]                   3L)]
[16:05:08.086]             }
[16:05:08.086]             function(cond) {
[16:05:08.086]                 is_error <- inherits(cond, "error")
[16:05:08.086]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:08.086]                   NULL)
[16:05:08.086]                 if (is_error) {
[16:05:08.086]                   sessionInformation <- function() {
[16:05:08.086]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:08.086]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:08.086]                       search = base::search(), system = base::Sys.info())
[16:05:08.086]                   }
[16:05:08.086]                   ...future.conditions[[length(...future.conditions) + 
[16:05:08.086]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:08.086]                     cond$call), session = sessionInformation(), 
[16:05:08.086]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:08.086]                   signalCondition(cond)
[16:05:08.086]                 }
[16:05:08.086]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:08.086]                 "immediateCondition"))) {
[16:05:08.086]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:08.086]                   ...future.conditions[[length(...future.conditions) + 
[16:05:08.086]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:08.086]                   if (TRUE && !signal) {
[16:05:08.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.086]                     {
[16:05:08.086]                       inherits <- base::inherits
[16:05:08.086]                       invokeRestart <- base::invokeRestart
[16:05:08.086]                       is.null <- base::is.null
[16:05:08.086]                       muffled <- FALSE
[16:05:08.086]                       if (inherits(cond, "message")) {
[16:05:08.086]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:08.086]                         if (muffled) 
[16:05:08.086]                           invokeRestart("muffleMessage")
[16:05:08.086]                       }
[16:05:08.086]                       else if (inherits(cond, "warning")) {
[16:05:08.086]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:08.086]                         if (muffled) 
[16:05:08.086]                           invokeRestart("muffleWarning")
[16:05:08.086]                       }
[16:05:08.086]                       else if (inherits(cond, "condition")) {
[16:05:08.086]                         if (!is.null(pattern)) {
[16:05:08.086]                           computeRestarts <- base::computeRestarts
[16:05:08.086]                           grepl <- base::grepl
[16:05:08.086]                           restarts <- computeRestarts(cond)
[16:05:08.086]                           for (restart in restarts) {
[16:05:08.086]                             name <- restart$name
[16:05:08.086]                             if (is.null(name)) 
[16:05:08.086]                               next
[16:05:08.086]                             if (!grepl(pattern, name)) 
[16:05:08.086]                               next
[16:05:08.086]                             invokeRestart(restart)
[16:05:08.086]                             muffled <- TRUE
[16:05:08.086]                             break
[16:05:08.086]                           }
[16:05:08.086]                         }
[16:05:08.086]                       }
[16:05:08.086]                       invisible(muffled)
[16:05:08.086]                     }
[16:05:08.086]                     muffleCondition(cond, pattern = "^muffle")
[16:05:08.086]                   }
[16:05:08.086]                 }
[16:05:08.086]                 else {
[16:05:08.086]                   if (TRUE) {
[16:05:08.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.086]                     {
[16:05:08.086]                       inherits <- base::inherits
[16:05:08.086]                       invokeRestart <- base::invokeRestart
[16:05:08.086]                       is.null <- base::is.null
[16:05:08.086]                       muffled <- FALSE
[16:05:08.086]                       if (inherits(cond, "message")) {
[16:05:08.086]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:08.086]                         if (muffled) 
[16:05:08.086]                           invokeRestart("muffleMessage")
[16:05:08.086]                       }
[16:05:08.086]                       else if (inherits(cond, "warning")) {
[16:05:08.086]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:08.086]                         if (muffled) 
[16:05:08.086]                           invokeRestart("muffleWarning")
[16:05:08.086]                       }
[16:05:08.086]                       else if (inherits(cond, "condition")) {
[16:05:08.086]                         if (!is.null(pattern)) {
[16:05:08.086]                           computeRestarts <- base::computeRestarts
[16:05:08.086]                           grepl <- base::grepl
[16:05:08.086]                           restarts <- computeRestarts(cond)
[16:05:08.086]                           for (restart in restarts) {
[16:05:08.086]                             name <- restart$name
[16:05:08.086]                             if (is.null(name)) 
[16:05:08.086]                               next
[16:05:08.086]                             if (!grepl(pattern, name)) 
[16:05:08.086]                               next
[16:05:08.086]                             invokeRestart(restart)
[16:05:08.086]                             muffled <- TRUE
[16:05:08.086]                             break
[16:05:08.086]                           }
[16:05:08.086]                         }
[16:05:08.086]                       }
[16:05:08.086]                       invisible(muffled)
[16:05:08.086]                     }
[16:05:08.086]                     muffleCondition(cond, pattern = "^muffle")
[16:05:08.086]                   }
[16:05:08.086]                 }
[16:05:08.086]             }
[16:05:08.086]         }))
[16:05:08.086]     }, error = function(ex) {
[16:05:08.086]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:08.086]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:08.086]                 ...future.rng), started = ...future.startTime, 
[16:05:08.086]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:08.086]             version = "1.8"), class = "FutureResult")
[16:05:08.086]     }, finally = {
[16:05:08.086]         if (!identical(...future.workdir, getwd())) 
[16:05:08.086]             setwd(...future.workdir)
[16:05:08.086]         {
[16:05:08.086]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:08.086]                 ...future.oldOptions$nwarnings <- NULL
[16:05:08.086]             }
[16:05:08.086]             base::options(...future.oldOptions)
[16:05:08.086]             if (.Platform$OS.type == "windows") {
[16:05:08.086]                 old_names <- names(...future.oldEnvVars)
[16:05:08.086]                 envs <- base::Sys.getenv()
[16:05:08.086]                 names <- names(envs)
[16:05:08.086]                 common <- intersect(names, old_names)
[16:05:08.086]                 added <- setdiff(names, old_names)
[16:05:08.086]                 removed <- setdiff(old_names, names)
[16:05:08.086]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:08.086]                   envs[common]]
[16:05:08.086]                 NAMES <- toupper(changed)
[16:05:08.086]                 args <- list()
[16:05:08.086]                 for (kk in seq_along(NAMES)) {
[16:05:08.086]                   name <- changed[[kk]]
[16:05:08.086]                   NAME <- NAMES[[kk]]
[16:05:08.086]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.086]                     next
[16:05:08.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:08.086]                 }
[16:05:08.086]                 NAMES <- toupper(added)
[16:05:08.086]                 for (kk in seq_along(NAMES)) {
[16:05:08.086]                   name <- added[[kk]]
[16:05:08.086]                   NAME <- NAMES[[kk]]
[16:05:08.086]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.086]                     next
[16:05:08.086]                   args[[name]] <- ""
[16:05:08.086]                 }
[16:05:08.086]                 NAMES <- toupper(removed)
[16:05:08.086]                 for (kk in seq_along(NAMES)) {
[16:05:08.086]                   name <- removed[[kk]]
[16:05:08.086]                   NAME <- NAMES[[kk]]
[16:05:08.086]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.086]                     next
[16:05:08.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:08.086]                 }
[16:05:08.086]                 if (length(args) > 0) 
[16:05:08.086]                   base::do.call(base::Sys.setenv, args = args)
[16:05:08.086]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:08.086]             }
[16:05:08.086]             else {
[16:05:08.086]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:08.086]             }
[16:05:08.086]             {
[16:05:08.086]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:08.086]                   0L) {
[16:05:08.086]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:08.086]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:08.086]                   base::options(opts)
[16:05:08.086]                 }
[16:05:08.086]                 {
[16:05:08.086]                   {
[16:05:08.086]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:08.086]                     NULL
[16:05:08.086]                   }
[16:05:08.086]                   options(future.plan = NULL)
[16:05:08.086]                   if (is.na(NA_character_)) 
[16:05:08.086]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:08.086]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:08.086]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:08.086]                     envir = parent.frame()) 
[16:05:08.086]                   {
[16:05:08.086]                     default_workers <- missing(workers)
[16:05:08.086]                     if (is.function(workers)) 
[16:05:08.086]                       workers <- workers()
[16:05:08.086]                     workers <- structure(as.integer(workers), 
[16:05:08.086]                       class = class(workers))
[16:05:08.086]                     stop_if_not(is.finite(workers), workers >= 
[16:05:08.086]                       1L)
[16:05:08.086]                     if ((workers == 1L && !inherits(workers, 
[16:05:08.086]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:08.086]                       if (default_workers) 
[16:05:08.086]                         supportsMulticore(warn = TRUE)
[16:05:08.086]                       return(sequential(..., envir = envir))
[16:05:08.086]                     }
[16:05:08.086]                     oopts <- options(mc.cores = workers)
[16:05:08.086]                     on.exit(options(oopts))
[16:05:08.086]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:08.086]                       envir = envir)
[16:05:08.086]                     if (!future$lazy) 
[16:05:08.086]                       future <- run(future)
[16:05:08.086]                     invisible(future)
[16:05:08.086]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:08.086]                 }
[16:05:08.086]             }
[16:05:08.086]         }
[16:05:08.086]     })
[16:05:08.086]     if (TRUE) {
[16:05:08.086]         base::sink(type = "output", split = FALSE)
[16:05:08.086]         if (TRUE) {
[16:05:08.086]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:08.086]         }
[16:05:08.086]         else {
[16:05:08.086]             ...future.result["stdout"] <- base::list(NULL)
[16:05:08.086]         }
[16:05:08.086]         base::close(...future.stdout)
[16:05:08.086]         ...future.stdout <- NULL
[16:05:08.086]     }
[16:05:08.086]     ...future.result$conditions <- ...future.conditions
[16:05:08.086]     ...future.result$finished <- base::Sys.time()
[16:05:08.086]     ...future.result
[16:05:08.086] }
[16:05:08.089] assign_globals() ...
[16:05:08.089] List of 1
[16:05:08.089]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a0568c96f0> 
[16:05:08.089]  - attr(*, "where")=List of 1
[16:05:08.089]   ..$ a:<environment: R_EmptyEnv> 
[16:05:08.089]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:08.089]  - attr(*, "resolved")= logi TRUE
[16:05:08.089]  - attr(*, "total_size")= num 1641288
[16:05:08.089]  - attr(*, "already-done")= logi TRUE
[16:05:08.093] - copied ‘a’ to environment
[16:05:08.093] assign_globals() ... done
[16:05:08.093] requestCore(): workers = 2
[16:05:08.095] MulticoreFuture started
[16:05:08.096] - Launch lazy future ... done
[16:05:08.096] run() for ‘MulticoreFuture’ ... done
[16:05:08.096] result() for MulticoreFuture ...
[16:05:08.097] plan(): Setting new future strategy stack:
[16:05:08.097] List of future strategies:
[16:05:08.097] 1. sequential:
[16:05:08.097]    - args: function (..., envir = parent.frame())
[16:05:08.097]    - tweaked: FALSE
[16:05:08.097]    - call: NULL
[16:05:08.098] plan(): nbrOfWorkers() = 1
[16:05:08.101] plan(): Setting new future strategy stack:
[16:05:08.102] List of future strategies:
[16:05:08.102] 1. multicore:
[16:05:08.102]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:08.102]    - tweaked: FALSE
[16:05:08.102]    - call: plan(strategy)
[16:05:08.107] plan(): nbrOfWorkers() = 2
[16:05:08.108] result() for MulticoreFuture ...
[16:05:08.108] result() for MulticoreFuture ... done
[16:05:08.108] signalConditions() ...
[16:05:08.108]  - include = ‘immediateCondition’
[16:05:08.108]  - exclude = 
[16:05:08.109]  - resignal = FALSE
[16:05:08.109]  - Number of conditions: 4
[16:05:08.109] signalConditions() ... done
[16:05:08.109] result() for MulticoreFuture ... done
[16:05:08.109] result() for MulticoreFuture ...
[16:05:08.109] result() for MulticoreFuture ... done
[16:05:08.110] signalConditions() ...
[16:05:08.110]  - include = ‘immediateCondition’
[16:05:08.110]  - exclude = 
[16:05:08.110]  - resignal = FALSE
[16:05:08.110]  - Number of conditions: 4
[16:05:08.110] signalConditions() ... done
[16:05:08.111] Future state: ‘finished’
[16:05:08.111] result() for MulticoreFuture ...
[16:05:08.111] result() for MulticoreFuture ... done
[16:05:08.111] signalConditions() ...
[16:05:08.111]  - include = ‘condition’
[16:05:08.111]  - exclude = ‘immediateCondition’
[16:05:08.111]  - resignal = TRUE
[16:05:08.111]  - Number of conditions: 4
[16:05:08.112]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.099] result() for MulticoreFuture ...
[16:05:08.112]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.100] result() for MulticoreFuture ... done
[16:05:08.112]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.100] result() for MulticoreFuture ...
[16:05:08.112]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.100] result() for MulticoreFuture ... done
[16:05:08.112] signalConditions() ... done
value(b) = 2
[16:05:08.113] result() for MulticoreFuture ...
[16:05:08.113] result() for MulticoreFuture ... done
[16:05:08.113] result() for MulticoreFuture ...
[16:05:08.113] result() for MulticoreFuture ... done
[16:05:08.113] signalConditions() ...
[16:05:08.113]  - include = ‘immediateCondition’
[16:05:08.113]  - exclude = 
[16:05:08.113]  - resignal = FALSE
[16:05:08.113]  - Number of conditions: 4
[16:05:08.114] signalConditions() ... done
[16:05:08.114] Future state: ‘finished’
[16:05:08.114] result() for MulticoreFuture ...
[16:05:08.114] result() for MulticoreFuture ... done
[16:05:08.114] signalConditions() ...
[16:05:08.114]  - include = ‘condition’
[16:05:08.114]  - exclude = ‘immediateCondition’
[16:05:08.114]  - resignal = TRUE
[16:05:08.114]  - Number of conditions: 4
[16:05:08.115]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.099] result() for MulticoreFuture ...
[16:05:08.115]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.100] result() for MulticoreFuture ... done
[16:05:08.115]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.100] result() for MulticoreFuture ...
[16:05:08.115]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.100] result() for MulticoreFuture ... done
[16:05:08.115] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:08.116] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:08.116] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:08.116] 
[16:05:08.117] Searching for globals ... DONE
[16:05:08.117] - globals: [0] <none>
[16:05:08.117] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:08.117] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:08.117] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:08.118] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:08.119] Searching for globals ... DONE
[16:05:08.119] Resolving globals: TRUE
[16:05:08.119] Resolving any globals that are futures ...
[16:05:08.119] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:08.119] Resolving any globals that are futures ... DONE
[16:05:08.120] Resolving futures part of globals (recursively) ...
[16:05:08.120] resolve() on list ...
[16:05:08.120]  recursive: 99
[16:05:08.120]  length: 1
[16:05:08.120]  elements: ‘a’
[16:05:08.120] run() for ‘Future’ ...
[16:05:08.121] - state: ‘created’
[16:05:08.121] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:08.128] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:08.128] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:08.129]   - Field: ‘label’
[16:05:08.129]   - Field: ‘local’
[16:05:08.129]   - Field: ‘owner’
[16:05:08.129]   - Field: ‘envir’
[16:05:08.129]   - Field: ‘workers’
[16:05:08.129]   - Field: ‘packages’
[16:05:08.129]   - Field: ‘gc’
[16:05:08.130]   - Field: ‘job’
[16:05:08.130]   - Field: ‘conditions’
[16:05:08.130]   - Field: ‘expr’
[16:05:08.130]   - Field: ‘uuid’
[16:05:08.130]   - Field: ‘seed’
[16:05:08.130]   - Field: ‘version’
[16:05:08.130]   - Field: ‘result’
[16:05:08.130]   - Field: ‘asynchronous’
[16:05:08.131]   - Field: ‘calls’
[16:05:08.131]   - Field: ‘globals’
[16:05:08.131]   - Field: ‘stdout’
[16:05:08.131]   - Field: ‘earlySignal’
[16:05:08.131]   - Field: ‘lazy’
[16:05:08.131]   - Field: ‘state’
[16:05:08.132] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:08.132] - Launch lazy future ...
[16:05:08.132] Packages needed by the future expression (n = 0): <none>
[16:05:08.132] Packages needed by future strategies (n = 0): <none>
[16:05:08.133] {
[16:05:08.133]     {
[16:05:08.133]         {
[16:05:08.133]             ...future.startTime <- base::Sys.time()
[16:05:08.133]             {
[16:05:08.133]                 {
[16:05:08.133]                   {
[16:05:08.133]                     {
[16:05:08.133]                       base::local({
[16:05:08.133]                         has_future <- base::requireNamespace("future", 
[16:05:08.133]                           quietly = TRUE)
[16:05:08.133]                         if (has_future) {
[16:05:08.133]                           ns <- base::getNamespace("future")
[16:05:08.133]                           version <- ns[[".package"]][["version"]]
[16:05:08.133]                           if (is.null(version)) 
[16:05:08.133]                             version <- utils::packageVersion("future")
[16:05:08.133]                         }
[16:05:08.133]                         else {
[16:05:08.133]                           version <- NULL
[16:05:08.133]                         }
[16:05:08.133]                         if (!has_future || version < "1.8.0") {
[16:05:08.133]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:08.133]                             "", base::R.version$version.string), 
[16:05:08.133]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:08.133]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:08.133]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:08.133]                               "release", "version")], collapse = " "), 
[16:05:08.133]                             hostname = base::Sys.info()[["nodename"]])
[16:05:08.133]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:08.133]                             info)
[16:05:08.133]                           info <- base::paste(info, collapse = "; ")
[16:05:08.133]                           if (!has_future) {
[16:05:08.133]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:08.133]                               info)
[16:05:08.133]                           }
[16:05:08.133]                           else {
[16:05:08.133]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:08.133]                               info, version)
[16:05:08.133]                           }
[16:05:08.133]                           base::stop(msg)
[16:05:08.133]                         }
[16:05:08.133]                       })
[16:05:08.133]                     }
[16:05:08.133]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:08.133]                     base::options(mc.cores = 1L)
[16:05:08.133]                   }
[16:05:08.133]                   options(future.plan = NULL)
[16:05:08.133]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:08.133]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:08.133]                 }
[16:05:08.133]                 ...future.workdir <- getwd()
[16:05:08.133]             }
[16:05:08.133]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:08.133]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:08.133]         }
[16:05:08.133]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:08.133]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:08.133]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:08.133]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:08.133]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:08.133]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:08.133]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:08.133]             base::names(...future.oldOptions))
[16:05:08.133]     }
[16:05:08.133]     if (FALSE) {
[16:05:08.133]     }
[16:05:08.133]     else {
[16:05:08.133]         if (TRUE) {
[16:05:08.133]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:08.133]                 open = "w")
[16:05:08.133]         }
[16:05:08.133]         else {
[16:05:08.133]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:08.133]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:08.133]         }
[16:05:08.133]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:08.133]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:08.133]             base::sink(type = "output", split = FALSE)
[16:05:08.133]             base::close(...future.stdout)
[16:05:08.133]         }, add = TRUE)
[16:05:08.133]     }
[16:05:08.133]     ...future.frame <- base::sys.nframe()
[16:05:08.133]     ...future.conditions <- base::list()
[16:05:08.133]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:08.133]     if (FALSE) {
[16:05:08.133]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:08.133]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:08.133]     }
[16:05:08.133]     ...future.result <- base::tryCatch({
[16:05:08.133]         base::withCallingHandlers({
[16:05:08.133]             ...future.value <- base::withVisible(base::local({
[16:05:08.133]                 withCallingHandlers({
[16:05:08.133]                   1
[16:05:08.133]                 }, immediateCondition = function(cond) {
[16:05:08.133]                   save_rds <- function (object, pathname, ...) 
[16:05:08.133]                   {
[16:05:08.133]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:08.133]                     if (file_test("-f", pathname_tmp)) {
[16:05:08.133]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.133]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:08.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.133]                         fi_tmp[["mtime"]])
[16:05:08.133]                     }
[16:05:08.133]                     tryCatch({
[16:05:08.133]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:08.133]                     }, error = function(ex) {
[16:05:08.133]                       msg <- conditionMessage(ex)
[16:05:08.133]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.133]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:08.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.133]                         fi_tmp[["mtime"]], msg)
[16:05:08.133]                       ex$message <- msg
[16:05:08.133]                       stop(ex)
[16:05:08.133]                     })
[16:05:08.133]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:08.133]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:08.133]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:08.133]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.133]                       fi <- file.info(pathname)
[16:05:08.133]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:08.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.133]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:08.133]                         fi[["size"]], fi[["mtime"]])
[16:05:08.133]                       stop(msg)
[16:05:08.133]                     }
[16:05:08.133]                     invisible(pathname)
[16:05:08.133]                   }
[16:05:08.133]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:08.133]                     rootPath = tempdir()) 
[16:05:08.133]                   {
[16:05:08.133]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:08.133]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:08.133]                       tmpdir = path, fileext = ".rds")
[16:05:08.133]                     save_rds(obj, file)
[16:05:08.133]                   }
[16:05:08.133]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:08.133]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.133]                   {
[16:05:08.133]                     inherits <- base::inherits
[16:05:08.133]                     invokeRestart <- base::invokeRestart
[16:05:08.133]                     is.null <- base::is.null
[16:05:08.133]                     muffled <- FALSE
[16:05:08.133]                     if (inherits(cond, "message")) {
[16:05:08.133]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:08.133]                       if (muffled) 
[16:05:08.133]                         invokeRestart("muffleMessage")
[16:05:08.133]                     }
[16:05:08.133]                     else if (inherits(cond, "warning")) {
[16:05:08.133]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:08.133]                       if (muffled) 
[16:05:08.133]                         invokeRestart("muffleWarning")
[16:05:08.133]                     }
[16:05:08.133]                     else if (inherits(cond, "condition")) {
[16:05:08.133]                       if (!is.null(pattern)) {
[16:05:08.133]                         computeRestarts <- base::computeRestarts
[16:05:08.133]                         grepl <- base::grepl
[16:05:08.133]                         restarts <- computeRestarts(cond)
[16:05:08.133]                         for (restart in restarts) {
[16:05:08.133]                           name <- restart$name
[16:05:08.133]                           if (is.null(name)) 
[16:05:08.133]                             next
[16:05:08.133]                           if (!grepl(pattern, name)) 
[16:05:08.133]                             next
[16:05:08.133]                           invokeRestart(restart)
[16:05:08.133]                           muffled <- TRUE
[16:05:08.133]                           break
[16:05:08.133]                         }
[16:05:08.133]                       }
[16:05:08.133]                     }
[16:05:08.133]                     invisible(muffled)
[16:05:08.133]                   }
[16:05:08.133]                   muffleCondition(cond)
[16:05:08.133]                 })
[16:05:08.133]             }))
[16:05:08.133]             future::FutureResult(value = ...future.value$value, 
[16:05:08.133]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:08.133]                   ...future.rng), globalenv = if (FALSE) 
[16:05:08.133]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:08.133]                     ...future.globalenv.names))
[16:05:08.133]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:08.133]         }, condition = base::local({
[16:05:08.133]             c <- base::c
[16:05:08.133]             inherits <- base::inherits
[16:05:08.133]             invokeRestart <- base::invokeRestart
[16:05:08.133]             length <- base::length
[16:05:08.133]             list <- base::list
[16:05:08.133]             seq.int <- base::seq.int
[16:05:08.133]             signalCondition <- base::signalCondition
[16:05:08.133]             sys.calls <- base::sys.calls
[16:05:08.133]             `[[` <- base::`[[`
[16:05:08.133]             `+` <- base::`+`
[16:05:08.133]             `<<-` <- base::`<<-`
[16:05:08.133]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:08.133]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:08.133]                   3L)]
[16:05:08.133]             }
[16:05:08.133]             function(cond) {
[16:05:08.133]                 is_error <- inherits(cond, "error")
[16:05:08.133]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:08.133]                   NULL)
[16:05:08.133]                 if (is_error) {
[16:05:08.133]                   sessionInformation <- function() {
[16:05:08.133]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:08.133]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:08.133]                       search = base::search(), system = base::Sys.info())
[16:05:08.133]                   }
[16:05:08.133]                   ...future.conditions[[length(...future.conditions) + 
[16:05:08.133]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:08.133]                     cond$call), session = sessionInformation(), 
[16:05:08.133]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:08.133]                   signalCondition(cond)
[16:05:08.133]                 }
[16:05:08.133]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:08.133]                 "immediateCondition"))) {
[16:05:08.133]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:08.133]                   ...future.conditions[[length(...future.conditions) + 
[16:05:08.133]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:08.133]                   if (TRUE && !signal) {
[16:05:08.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.133]                     {
[16:05:08.133]                       inherits <- base::inherits
[16:05:08.133]                       invokeRestart <- base::invokeRestart
[16:05:08.133]                       is.null <- base::is.null
[16:05:08.133]                       muffled <- FALSE
[16:05:08.133]                       if (inherits(cond, "message")) {
[16:05:08.133]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:08.133]                         if (muffled) 
[16:05:08.133]                           invokeRestart("muffleMessage")
[16:05:08.133]                       }
[16:05:08.133]                       else if (inherits(cond, "warning")) {
[16:05:08.133]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:08.133]                         if (muffled) 
[16:05:08.133]                           invokeRestart("muffleWarning")
[16:05:08.133]                       }
[16:05:08.133]                       else if (inherits(cond, "condition")) {
[16:05:08.133]                         if (!is.null(pattern)) {
[16:05:08.133]                           computeRestarts <- base::computeRestarts
[16:05:08.133]                           grepl <- base::grepl
[16:05:08.133]                           restarts <- computeRestarts(cond)
[16:05:08.133]                           for (restart in restarts) {
[16:05:08.133]                             name <- restart$name
[16:05:08.133]                             if (is.null(name)) 
[16:05:08.133]                               next
[16:05:08.133]                             if (!grepl(pattern, name)) 
[16:05:08.133]                               next
[16:05:08.133]                             invokeRestart(restart)
[16:05:08.133]                             muffled <- TRUE
[16:05:08.133]                             break
[16:05:08.133]                           }
[16:05:08.133]                         }
[16:05:08.133]                       }
[16:05:08.133]                       invisible(muffled)
[16:05:08.133]                     }
[16:05:08.133]                     muffleCondition(cond, pattern = "^muffle")
[16:05:08.133]                   }
[16:05:08.133]                 }
[16:05:08.133]                 else {
[16:05:08.133]                   if (TRUE) {
[16:05:08.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.133]                     {
[16:05:08.133]                       inherits <- base::inherits
[16:05:08.133]                       invokeRestart <- base::invokeRestart
[16:05:08.133]                       is.null <- base::is.null
[16:05:08.133]                       muffled <- FALSE
[16:05:08.133]                       if (inherits(cond, "message")) {
[16:05:08.133]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:08.133]                         if (muffled) 
[16:05:08.133]                           invokeRestart("muffleMessage")
[16:05:08.133]                       }
[16:05:08.133]                       else if (inherits(cond, "warning")) {
[16:05:08.133]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:08.133]                         if (muffled) 
[16:05:08.133]                           invokeRestart("muffleWarning")
[16:05:08.133]                       }
[16:05:08.133]                       else if (inherits(cond, "condition")) {
[16:05:08.133]                         if (!is.null(pattern)) {
[16:05:08.133]                           computeRestarts <- base::computeRestarts
[16:05:08.133]                           grepl <- base::grepl
[16:05:08.133]                           restarts <- computeRestarts(cond)
[16:05:08.133]                           for (restart in restarts) {
[16:05:08.133]                             name <- restart$name
[16:05:08.133]                             if (is.null(name)) 
[16:05:08.133]                               next
[16:05:08.133]                             if (!grepl(pattern, name)) 
[16:05:08.133]                               next
[16:05:08.133]                             invokeRestart(restart)
[16:05:08.133]                             muffled <- TRUE
[16:05:08.133]                             break
[16:05:08.133]                           }
[16:05:08.133]                         }
[16:05:08.133]                       }
[16:05:08.133]                       invisible(muffled)
[16:05:08.133]                     }
[16:05:08.133]                     muffleCondition(cond, pattern = "^muffle")
[16:05:08.133]                   }
[16:05:08.133]                 }
[16:05:08.133]             }
[16:05:08.133]         }))
[16:05:08.133]     }, error = function(ex) {
[16:05:08.133]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:08.133]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:08.133]                 ...future.rng), started = ...future.startTime, 
[16:05:08.133]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:08.133]             version = "1.8"), class = "FutureResult")
[16:05:08.133]     }, finally = {
[16:05:08.133]         if (!identical(...future.workdir, getwd())) 
[16:05:08.133]             setwd(...future.workdir)
[16:05:08.133]         {
[16:05:08.133]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:08.133]                 ...future.oldOptions$nwarnings <- NULL
[16:05:08.133]             }
[16:05:08.133]             base::options(...future.oldOptions)
[16:05:08.133]             if (.Platform$OS.type == "windows") {
[16:05:08.133]                 old_names <- names(...future.oldEnvVars)
[16:05:08.133]                 envs <- base::Sys.getenv()
[16:05:08.133]                 names <- names(envs)
[16:05:08.133]                 common <- intersect(names, old_names)
[16:05:08.133]                 added <- setdiff(names, old_names)
[16:05:08.133]                 removed <- setdiff(old_names, names)
[16:05:08.133]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:08.133]                   envs[common]]
[16:05:08.133]                 NAMES <- toupper(changed)
[16:05:08.133]                 args <- list()
[16:05:08.133]                 for (kk in seq_along(NAMES)) {
[16:05:08.133]                   name <- changed[[kk]]
[16:05:08.133]                   NAME <- NAMES[[kk]]
[16:05:08.133]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.133]                     next
[16:05:08.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:08.133]                 }
[16:05:08.133]                 NAMES <- toupper(added)
[16:05:08.133]                 for (kk in seq_along(NAMES)) {
[16:05:08.133]                   name <- added[[kk]]
[16:05:08.133]                   NAME <- NAMES[[kk]]
[16:05:08.133]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.133]                     next
[16:05:08.133]                   args[[name]] <- ""
[16:05:08.133]                 }
[16:05:08.133]                 NAMES <- toupper(removed)
[16:05:08.133]                 for (kk in seq_along(NAMES)) {
[16:05:08.133]                   name <- removed[[kk]]
[16:05:08.133]                   NAME <- NAMES[[kk]]
[16:05:08.133]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.133]                     next
[16:05:08.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:08.133]                 }
[16:05:08.133]                 if (length(args) > 0) 
[16:05:08.133]                   base::do.call(base::Sys.setenv, args = args)
[16:05:08.133]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:08.133]             }
[16:05:08.133]             else {
[16:05:08.133]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:08.133]             }
[16:05:08.133]             {
[16:05:08.133]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:08.133]                   0L) {
[16:05:08.133]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:08.133]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:08.133]                   base::options(opts)
[16:05:08.133]                 }
[16:05:08.133]                 {
[16:05:08.133]                   {
[16:05:08.133]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:08.133]                     NULL
[16:05:08.133]                   }
[16:05:08.133]                   options(future.plan = NULL)
[16:05:08.133]                   if (is.na(NA_character_)) 
[16:05:08.133]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:08.133]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:08.133]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:08.133]                     envir = parent.frame()) 
[16:05:08.133]                   {
[16:05:08.133]                     default_workers <- missing(workers)
[16:05:08.133]                     if (is.function(workers)) 
[16:05:08.133]                       workers <- workers()
[16:05:08.133]                     workers <- structure(as.integer(workers), 
[16:05:08.133]                       class = class(workers))
[16:05:08.133]                     stop_if_not(is.finite(workers), workers >= 
[16:05:08.133]                       1L)
[16:05:08.133]                     if ((workers == 1L && !inherits(workers, 
[16:05:08.133]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:08.133]                       if (default_workers) 
[16:05:08.133]                         supportsMulticore(warn = TRUE)
[16:05:08.133]                       return(sequential(..., envir = envir))
[16:05:08.133]                     }
[16:05:08.133]                     oopts <- options(mc.cores = workers)
[16:05:08.133]                     on.exit(options(oopts))
[16:05:08.133]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:08.133]                       envir = envir)
[16:05:08.133]                     if (!future$lazy) 
[16:05:08.133]                       future <- run(future)
[16:05:08.133]                     invisible(future)
[16:05:08.133]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:08.133]                 }
[16:05:08.133]             }
[16:05:08.133]         }
[16:05:08.133]     })
[16:05:08.133]     if (TRUE) {
[16:05:08.133]         base::sink(type = "output", split = FALSE)
[16:05:08.133]         if (TRUE) {
[16:05:08.133]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:08.133]         }
[16:05:08.133]         else {
[16:05:08.133]             ...future.result["stdout"] <- base::list(NULL)
[16:05:08.133]         }
[16:05:08.133]         base::close(...future.stdout)
[16:05:08.133]         ...future.stdout <- NULL
[16:05:08.133]     }
[16:05:08.133]     ...future.result$conditions <- ...future.conditions
[16:05:08.133]     ...future.result$finished <- base::Sys.time()
[16:05:08.133]     ...future.result
[16:05:08.133] }
[16:05:08.136] requestCore(): workers = 2
[16:05:08.138] MulticoreFuture started
[16:05:08.139] - Launch lazy future ... done
[16:05:08.139] run() for ‘MulticoreFuture’ ... done
[16:05:08.139] plan(): Setting new future strategy stack:
[16:05:08.140] List of future strategies:
[16:05:08.140] 1. sequential:
[16:05:08.140]    - args: function (..., envir = parent.frame())
[16:05:08.140]    - tweaked: FALSE
[16:05:08.140]    - call: NULL
[16:05:08.141] plan(): nbrOfWorkers() = 1
[16:05:08.143] plan(): Setting new future strategy stack:
[16:05:08.143] List of future strategies:
[16:05:08.143] 1. multicore:
[16:05:08.143]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:08.143]    - tweaked: FALSE
[16:05:08.143]    - call: plan(strategy)
[16:05:08.149] plan(): nbrOfWorkers() = 2
[16:05:08.149] Future #1
[16:05:08.150] result() for MulticoreFuture ...
[16:05:08.151] result() for MulticoreFuture ...
[16:05:08.151] result() for MulticoreFuture ... done
[16:05:08.151] result() for MulticoreFuture ... done
[16:05:08.151] result() for MulticoreFuture ...
[16:05:08.151] result() for MulticoreFuture ... done
[16:05:08.152] A MulticoreFuture was resolved
[16:05:08.152]  length: 0 (resolved future 1)
[16:05:08.152] resolve() on list ... DONE
[16:05:08.152] - globals: [1] ‘a’
[16:05:08.153] Resolving futures part of globals (recursively) ... DONE
[16:05:08.156] The total size of the 1 globals is 1.57 MiB (1641288 bytes)
[16:05:08.156] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[16:05:08.156] - globals: [1] ‘a’
[16:05:08.157] - packages: [1] ‘future’
[16:05:08.157] getGlobalsAndPackages() ... DONE
[16:05:08.157] run() for ‘Future’ ...
[16:05:08.157] - state: ‘created’
[16:05:08.157] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:08.162] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:08.162] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:08.162]   - Field: ‘label’
[16:05:08.162]   - Field: ‘local’
[16:05:08.162]   - Field: ‘owner’
[16:05:08.162]   - Field: ‘envir’
[16:05:08.162]   - Field: ‘workers’
[16:05:08.162]   - Field: ‘packages’
[16:05:08.163]   - Field: ‘gc’
[16:05:08.163]   - Field: ‘job’
[16:05:08.163]   - Field: ‘conditions’
[16:05:08.163]   - Field: ‘expr’
[16:05:08.163]   - Field: ‘uuid’
[16:05:08.163]   - Field: ‘seed’
[16:05:08.163]   - Field: ‘version’
[16:05:08.163]   - Field: ‘result’
[16:05:08.164]   - Field: ‘asynchronous’
[16:05:08.164]   - Field: ‘calls’
[16:05:08.164]   - Field: ‘globals’
[16:05:08.164]   - Field: ‘stdout’
[16:05:08.164]   - Field: ‘earlySignal’
[16:05:08.164]   - Field: ‘lazy’
[16:05:08.164]   - Field: ‘state’
[16:05:08.164] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:08.165] - Launch lazy future ...
[16:05:08.165] Packages needed by the future expression (n = 1): ‘future’
[16:05:08.165] Packages needed by future strategies (n = 0): <none>
[16:05:08.166] {
[16:05:08.166]     {
[16:05:08.166]         {
[16:05:08.166]             ...future.startTime <- base::Sys.time()
[16:05:08.166]             {
[16:05:08.166]                 {
[16:05:08.166]                   {
[16:05:08.166]                     {
[16:05:08.166]                       {
[16:05:08.166]                         base::local({
[16:05:08.166]                           has_future <- base::requireNamespace("future", 
[16:05:08.166]                             quietly = TRUE)
[16:05:08.166]                           if (has_future) {
[16:05:08.166]                             ns <- base::getNamespace("future")
[16:05:08.166]                             version <- ns[[".package"]][["version"]]
[16:05:08.166]                             if (is.null(version)) 
[16:05:08.166]                               version <- utils::packageVersion("future")
[16:05:08.166]                           }
[16:05:08.166]                           else {
[16:05:08.166]                             version <- NULL
[16:05:08.166]                           }
[16:05:08.166]                           if (!has_future || version < "1.8.0") {
[16:05:08.166]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:08.166]                               "", base::R.version$version.string), 
[16:05:08.166]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:08.166]                                 base::R.version$platform, 8 * 
[16:05:08.166]                                   base::.Machine$sizeof.pointer), 
[16:05:08.166]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:08.166]                                 "release", "version")], collapse = " "), 
[16:05:08.166]                               hostname = base::Sys.info()[["nodename"]])
[16:05:08.166]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:08.166]                               info)
[16:05:08.166]                             info <- base::paste(info, collapse = "; ")
[16:05:08.166]                             if (!has_future) {
[16:05:08.166]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:08.166]                                 info)
[16:05:08.166]                             }
[16:05:08.166]                             else {
[16:05:08.166]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:08.166]                                 info, version)
[16:05:08.166]                             }
[16:05:08.166]                             base::stop(msg)
[16:05:08.166]                           }
[16:05:08.166]                         })
[16:05:08.166]                       }
[16:05:08.166]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:08.166]                       base::options(mc.cores = 1L)
[16:05:08.166]                     }
[16:05:08.166]                     base::local({
[16:05:08.166]                       for (pkg in "future") {
[16:05:08.166]                         base::loadNamespace(pkg)
[16:05:08.166]                         base::library(pkg, character.only = TRUE)
[16:05:08.166]                       }
[16:05:08.166]                     })
[16:05:08.166]                   }
[16:05:08.166]                   options(future.plan = NULL)
[16:05:08.166]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:08.166]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:08.166]                 }
[16:05:08.166]                 ...future.workdir <- getwd()
[16:05:08.166]             }
[16:05:08.166]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:08.166]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:08.166]         }
[16:05:08.166]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:08.166]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:08.166]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:08.166]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:08.166]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:08.166]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:08.166]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:08.166]             base::names(...future.oldOptions))
[16:05:08.166]     }
[16:05:08.166]     if (FALSE) {
[16:05:08.166]     }
[16:05:08.166]     else {
[16:05:08.166]         if (TRUE) {
[16:05:08.166]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:08.166]                 open = "w")
[16:05:08.166]         }
[16:05:08.166]         else {
[16:05:08.166]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:08.166]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:08.166]         }
[16:05:08.166]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:08.166]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:08.166]             base::sink(type = "output", split = FALSE)
[16:05:08.166]             base::close(...future.stdout)
[16:05:08.166]         }, add = TRUE)
[16:05:08.166]     }
[16:05:08.166]     ...future.frame <- base::sys.nframe()
[16:05:08.166]     ...future.conditions <- base::list()
[16:05:08.166]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:08.166]     if (FALSE) {
[16:05:08.166]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:08.166]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:08.166]     }
[16:05:08.166]     ...future.result <- base::tryCatch({
[16:05:08.166]         base::withCallingHandlers({
[16:05:08.166]             ...future.value <- base::withVisible(base::local({
[16:05:08.166]                 withCallingHandlers({
[16:05:08.166]                   value(a) + 1
[16:05:08.166]                 }, immediateCondition = function(cond) {
[16:05:08.166]                   save_rds <- function (object, pathname, ...) 
[16:05:08.166]                   {
[16:05:08.166]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:08.166]                     if (file_test("-f", pathname_tmp)) {
[16:05:08.166]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.166]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:08.166]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.166]                         fi_tmp[["mtime"]])
[16:05:08.166]                     }
[16:05:08.166]                     tryCatch({
[16:05:08.166]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:08.166]                     }, error = function(ex) {
[16:05:08.166]                       msg <- conditionMessage(ex)
[16:05:08.166]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.166]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:08.166]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.166]                         fi_tmp[["mtime"]], msg)
[16:05:08.166]                       ex$message <- msg
[16:05:08.166]                       stop(ex)
[16:05:08.166]                     })
[16:05:08.166]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:08.166]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:08.166]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:08.166]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.166]                       fi <- file.info(pathname)
[16:05:08.166]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:08.166]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.166]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:08.166]                         fi[["size"]], fi[["mtime"]])
[16:05:08.166]                       stop(msg)
[16:05:08.166]                     }
[16:05:08.166]                     invisible(pathname)
[16:05:08.166]                   }
[16:05:08.166]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:08.166]                     rootPath = tempdir()) 
[16:05:08.166]                   {
[16:05:08.166]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:08.166]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:08.166]                       tmpdir = path, fileext = ".rds")
[16:05:08.166]                     save_rds(obj, file)
[16:05:08.166]                   }
[16:05:08.166]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:08.166]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.166]                   {
[16:05:08.166]                     inherits <- base::inherits
[16:05:08.166]                     invokeRestart <- base::invokeRestart
[16:05:08.166]                     is.null <- base::is.null
[16:05:08.166]                     muffled <- FALSE
[16:05:08.166]                     if (inherits(cond, "message")) {
[16:05:08.166]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:08.166]                       if (muffled) 
[16:05:08.166]                         invokeRestart("muffleMessage")
[16:05:08.166]                     }
[16:05:08.166]                     else if (inherits(cond, "warning")) {
[16:05:08.166]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:08.166]                       if (muffled) 
[16:05:08.166]                         invokeRestart("muffleWarning")
[16:05:08.166]                     }
[16:05:08.166]                     else if (inherits(cond, "condition")) {
[16:05:08.166]                       if (!is.null(pattern)) {
[16:05:08.166]                         computeRestarts <- base::computeRestarts
[16:05:08.166]                         grepl <- base::grepl
[16:05:08.166]                         restarts <- computeRestarts(cond)
[16:05:08.166]                         for (restart in restarts) {
[16:05:08.166]                           name <- restart$name
[16:05:08.166]                           if (is.null(name)) 
[16:05:08.166]                             next
[16:05:08.166]                           if (!grepl(pattern, name)) 
[16:05:08.166]                             next
[16:05:08.166]                           invokeRestart(restart)
[16:05:08.166]                           muffled <- TRUE
[16:05:08.166]                           break
[16:05:08.166]                         }
[16:05:08.166]                       }
[16:05:08.166]                     }
[16:05:08.166]                     invisible(muffled)
[16:05:08.166]                   }
[16:05:08.166]                   muffleCondition(cond)
[16:05:08.166]                 })
[16:05:08.166]             }))
[16:05:08.166]             future::FutureResult(value = ...future.value$value, 
[16:05:08.166]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:08.166]                   ...future.rng), globalenv = if (FALSE) 
[16:05:08.166]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:08.166]                     ...future.globalenv.names))
[16:05:08.166]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:08.166]         }, condition = base::local({
[16:05:08.166]             c <- base::c
[16:05:08.166]             inherits <- base::inherits
[16:05:08.166]             invokeRestart <- base::invokeRestart
[16:05:08.166]             length <- base::length
[16:05:08.166]             list <- base::list
[16:05:08.166]             seq.int <- base::seq.int
[16:05:08.166]             signalCondition <- base::signalCondition
[16:05:08.166]             sys.calls <- base::sys.calls
[16:05:08.166]             `[[` <- base::`[[`
[16:05:08.166]             `+` <- base::`+`
[16:05:08.166]             `<<-` <- base::`<<-`
[16:05:08.166]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:08.166]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:08.166]                   3L)]
[16:05:08.166]             }
[16:05:08.166]             function(cond) {
[16:05:08.166]                 is_error <- inherits(cond, "error")
[16:05:08.166]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:08.166]                   NULL)
[16:05:08.166]                 if (is_error) {
[16:05:08.166]                   sessionInformation <- function() {
[16:05:08.166]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:08.166]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:08.166]                       search = base::search(), system = base::Sys.info())
[16:05:08.166]                   }
[16:05:08.166]                   ...future.conditions[[length(...future.conditions) + 
[16:05:08.166]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:08.166]                     cond$call), session = sessionInformation(), 
[16:05:08.166]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:08.166]                   signalCondition(cond)
[16:05:08.166]                 }
[16:05:08.166]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:08.166]                 "immediateCondition"))) {
[16:05:08.166]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:08.166]                   ...future.conditions[[length(...future.conditions) + 
[16:05:08.166]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:08.166]                   if (TRUE && !signal) {
[16:05:08.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.166]                     {
[16:05:08.166]                       inherits <- base::inherits
[16:05:08.166]                       invokeRestart <- base::invokeRestart
[16:05:08.166]                       is.null <- base::is.null
[16:05:08.166]                       muffled <- FALSE
[16:05:08.166]                       if (inherits(cond, "message")) {
[16:05:08.166]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:08.166]                         if (muffled) 
[16:05:08.166]                           invokeRestart("muffleMessage")
[16:05:08.166]                       }
[16:05:08.166]                       else if (inherits(cond, "warning")) {
[16:05:08.166]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:08.166]                         if (muffled) 
[16:05:08.166]                           invokeRestart("muffleWarning")
[16:05:08.166]                       }
[16:05:08.166]                       else if (inherits(cond, "condition")) {
[16:05:08.166]                         if (!is.null(pattern)) {
[16:05:08.166]                           computeRestarts <- base::computeRestarts
[16:05:08.166]                           grepl <- base::grepl
[16:05:08.166]                           restarts <- computeRestarts(cond)
[16:05:08.166]                           for (restart in restarts) {
[16:05:08.166]                             name <- restart$name
[16:05:08.166]                             if (is.null(name)) 
[16:05:08.166]                               next
[16:05:08.166]                             if (!grepl(pattern, name)) 
[16:05:08.166]                               next
[16:05:08.166]                             invokeRestart(restart)
[16:05:08.166]                             muffled <- TRUE
[16:05:08.166]                             break
[16:05:08.166]                           }
[16:05:08.166]                         }
[16:05:08.166]                       }
[16:05:08.166]                       invisible(muffled)
[16:05:08.166]                     }
[16:05:08.166]                     muffleCondition(cond, pattern = "^muffle")
[16:05:08.166]                   }
[16:05:08.166]                 }
[16:05:08.166]                 else {
[16:05:08.166]                   if (TRUE) {
[16:05:08.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.166]                     {
[16:05:08.166]                       inherits <- base::inherits
[16:05:08.166]                       invokeRestart <- base::invokeRestart
[16:05:08.166]                       is.null <- base::is.null
[16:05:08.166]                       muffled <- FALSE
[16:05:08.166]                       if (inherits(cond, "message")) {
[16:05:08.166]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:08.166]                         if (muffled) 
[16:05:08.166]                           invokeRestart("muffleMessage")
[16:05:08.166]                       }
[16:05:08.166]                       else if (inherits(cond, "warning")) {
[16:05:08.166]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:08.166]                         if (muffled) 
[16:05:08.166]                           invokeRestart("muffleWarning")
[16:05:08.166]                       }
[16:05:08.166]                       else if (inherits(cond, "condition")) {
[16:05:08.166]                         if (!is.null(pattern)) {
[16:05:08.166]                           computeRestarts <- base::computeRestarts
[16:05:08.166]                           grepl <- base::grepl
[16:05:08.166]                           restarts <- computeRestarts(cond)
[16:05:08.166]                           for (restart in restarts) {
[16:05:08.166]                             name <- restart$name
[16:05:08.166]                             if (is.null(name)) 
[16:05:08.166]                               next
[16:05:08.166]                             if (!grepl(pattern, name)) 
[16:05:08.166]                               next
[16:05:08.166]                             invokeRestart(restart)
[16:05:08.166]                             muffled <- TRUE
[16:05:08.166]                             break
[16:05:08.166]                           }
[16:05:08.166]                         }
[16:05:08.166]                       }
[16:05:08.166]                       invisible(muffled)
[16:05:08.166]                     }
[16:05:08.166]                     muffleCondition(cond, pattern = "^muffle")
[16:05:08.166]                   }
[16:05:08.166]                 }
[16:05:08.166]             }
[16:05:08.166]         }))
[16:05:08.166]     }, error = function(ex) {
[16:05:08.166]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:08.166]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:08.166]                 ...future.rng), started = ...future.startTime, 
[16:05:08.166]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:08.166]             version = "1.8"), class = "FutureResult")
[16:05:08.166]     }, finally = {
[16:05:08.166]         if (!identical(...future.workdir, getwd())) 
[16:05:08.166]             setwd(...future.workdir)
[16:05:08.166]         {
[16:05:08.166]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:08.166]                 ...future.oldOptions$nwarnings <- NULL
[16:05:08.166]             }
[16:05:08.166]             base::options(...future.oldOptions)
[16:05:08.166]             if (.Platform$OS.type == "windows") {
[16:05:08.166]                 old_names <- names(...future.oldEnvVars)
[16:05:08.166]                 envs <- base::Sys.getenv()
[16:05:08.166]                 names <- names(envs)
[16:05:08.166]                 common <- intersect(names, old_names)
[16:05:08.166]                 added <- setdiff(names, old_names)
[16:05:08.166]                 removed <- setdiff(old_names, names)
[16:05:08.166]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:08.166]                   envs[common]]
[16:05:08.166]                 NAMES <- toupper(changed)
[16:05:08.166]                 args <- list()
[16:05:08.166]                 for (kk in seq_along(NAMES)) {
[16:05:08.166]                   name <- changed[[kk]]
[16:05:08.166]                   NAME <- NAMES[[kk]]
[16:05:08.166]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.166]                     next
[16:05:08.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:08.166]                 }
[16:05:08.166]                 NAMES <- toupper(added)
[16:05:08.166]                 for (kk in seq_along(NAMES)) {
[16:05:08.166]                   name <- added[[kk]]
[16:05:08.166]                   NAME <- NAMES[[kk]]
[16:05:08.166]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.166]                     next
[16:05:08.166]                   args[[name]] <- ""
[16:05:08.166]                 }
[16:05:08.166]                 NAMES <- toupper(removed)
[16:05:08.166]                 for (kk in seq_along(NAMES)) {
[16:05:08.166]                   name <- removed[[kk]]
[16:05:08.166]                   NAME <- NAMES[[kk]]
[16:05:08.166]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.166]                     next
[16:05:08.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:08.166]                 }
[16:05:08.166]                 if (length(args) > 0) 
[16:05:08.166]                   base::do.call(base::Sys.setenv, args = args)
[16:05:08.166]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:08.166]             }
[16:05:08.166]             else {
[16:05:08.166]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:08.166]             }
[16:05:08.166]             {
[16:05:08.166]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:08.166]                   0L) {
[16:05:08.166]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:08.166]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:08.166]                   base::options(opts)
[16:05:08.166]                 }
[16:05:08.166]                 {
[16:05:08.166]                   {
[16:05:08.166]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:08.166]                     NULL
[16:05:08.166]                   }
[16:05:08.166]                   options(future.plan = NULL)
[16:05:08.166]                   if (is.na(NA_character_)) 
[16:05:08.166]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:08.166]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:08.166]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:08.166]                     envir = parent.frame()) 
[16:05:08.166]                   {
[16:05:08.166]                     default_workers <- missing(workers)
[16:05:08.166]                     if (is.function(workers)) 
[16:05:08.166]                       workers <- workers()
[16:05:08.166]                     workers <- structure(as.integer(workers), 
[16:05:08.166]                       class = class(workers))
[16:05:08.166]                     stop_if_not(is.finite(workers), workers >= 
[16:05:08.166]                       1L)
[16:05:08.166]                     if ((workers == 1L && !inherits(workers, 
[16:05:08.166]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:08.166]                       if (default_workers) 
[16:05:08.166]                         supportsMulticore(warn = TRUE)
[16:05:08.166]                       return(sequential(..., envir = envir))
[16:05:08.166]                     }
[16:05:08.166]                     oopts <- options(mc.cores = workers)
[16:05:08.166]                     on.exit(options(oopts))
[16:05:08.166]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:08.166]                       envir = envir)
[16:05:08.166]                     if (!future$lazy) 
[16:05:08.166]                       future <- run(future)
[16:05:08.166]                     invisible(future)
[16:05:08.166]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:08.166]                 }
[16:05:08.166]             }
[16:05:08.166]         }
[16:05:08.166]     })
[16:05:08.166]     if (TRUE) {
[16:05:08.166]         base::sink(type = "output", split = FALSE)
[16:05:08.166]         if (TRUE) {
[16:05:08.166]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:08.166]         }
[16:05:08.166]         else {
[16:05:08.166]             ...future.result["stdout"] <- base::list(NULL)
[16:05:08.166]         }
[16:05:08.166]         base::close(...future.stdout)
[16:05:08.166]         ...future.stdout <- NULL
[16:05:08.166]     }
[16:05:08.166]     ...future.result$conditions <- ...future.conditions
[16:05:08.166]     ...future.result$finished <- base::Sys.time()
[16:05:08.166]     ...future.result
[16:05:08.166] }
[16:05:08.168] assign_globals() ...
[16:05:08.169] List of 1
[16:05:08.169]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a0564121a8> 
[16:05:08.169]  - attr(*, "where")=List of 1
[16:05:08.169]   ..$ a:<environment: R_EmptyEnv> 
[16:05:08.169]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:08.169]  - attr(*, "resolved")= logi TRUE
[16:05:08.169]  - attr(*, "total_size")= num 1641288
[16:05:08.169]  - attr(*, "already-done")= logi TRUE
[16:05:08.172] - copied ‘a’ to environment
[16:05:08.172] assign_globals() ... done
[16:05:08.172] requestCore(): workers = 2
[16:05:08.176] MulticoreFuture started
[16:05:08.177] - Launch lazy future ... done
[16:05:08.177] run() for ‘MulticoreFuture’ ... done
[16:05:08.178] result() for MulticoreFuture ...
[16:05:08.178] plan(): Setting new future strategy stack:
[16:05:08.179] List of future strategies:
[16:05:08.179] 1. sequential:
[16:05:08.179]    - args: function (..., envir = parent.frame())
[16:05:08.179]    - tweaked: FALSE
[16:05:08.179]    - call: NULL
[16:05:08.180] plan(): nbrOfWorkers() = 1
[16:05:08.184] plan(): Setting new future strategy stack:
[16:05:08.184] List of future strategies:
[16:05:08.184] 1. multicore:
[16:05:08.184]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:08.184]    - tweaked: FALSE
[16:05:08.184]    - call: plan(strategy)
[16:05:08.191] plan(): nbrOfWorkers() = 2
[16:05:08.192] result() for MulticoreFuture ...
[16:05:08.192] result() for MulticoreFuture ... done
[16:05:08.192] signalConditions() ...
[16:05:08.192]  - include = ‘immediateCondition’
[16:05:08.193]  - exclude = 
[16:05:08.193]  - resignal = FALSE
[16:05:08.193]  - Number of conditions: 4
[16:05:08.193] signalConditions() ... done
[16:05:08.194] result() for MulticoreFuture ... done
[16:05:08.194] result() for MulticoreFuture ...
[16:05:08.194] result() for MulticoreFuture ... done
[16:05:08.194] signalConditions() ...
[16:05:08.194]  - include = ‘immediateCondition’
[16:05:08.195]  - exclude = 
[16:05:08.195]  - resignal = FALSE
[16:05:08.195]  - Number of conditions: 4
[16:05:08.195] signalConditions() ... done
[16:05:08.195] Future state: ‘finished’
[16:05:08.196] result() for MulticoreFuture ...
[16:05:08.196] result() for MulticoreFuture ... done
[16:05:08.196] signalConditions() ...
[16:05:08.196]  - include = ‘condition’
[16:05:08.196]  - exclude = ‘immediateCondition’
[16:05:08.196]  - resignal = TRUE
[16:05:08.197]  - Number of conditions: 4
[16:05:08.197]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.181] result() for MulticoreFuture ...
[16:05:08.197]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.182] result() for MulticoreFuture ... done
[16:05:08.197]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.182] result() for MulticoreFuture ...
[16:05:08.197]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.183] result() for MulticoreFuture ... done
[16:05:08.198] signalConditions() ... done
value(b) = 2
[16:05:08.198] result() for MulticoreFuture ...
[16:05:08.198] result() for MulticoreFuture ... done
[16:05:08.198] result() for MulticoreFuture ...
[16:05:08.198] result() for MulticoreFuture ... done
[16:05:08.199] signalConditions() ...
[16:05:08.199]  - include = ‘immediateCondition’
[16:05:08.199]  - exclude = 
[16:05:08.199]  - resignal = FALSE
[16:05:08.199]  - Number of conditions: 4
[16:05:08.199] signalConditions() ... done
[16:05:08.199] Future state: ‘finished’
[16:05:08.199] result() for MulticoreFuture ...
[16:05:08.200] result() for MulticoreFuture ... done
[16:05:08.200] signalConditions() ...
[16:05:08.200]  - include = ‘condition’
[16:05:08.200]  - exclude = ‘immediateCondition’
[16:05:08.200]  - resignal = TRUE
[16:05:08.200]  - Number of conditions: 4
[16:05:08.200]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.181] result() for MulticoreFuture ...
[16:05:08.201]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.182] result() for MulticoreFuture ... done
[16:05:08.201]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.182] result() for MulticoreFuture ...
[16:05:08.201]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:08.183] result() for MulticoreFuture ... done
[16:05:08.201] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:08.201] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:08.202] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:08.203] - globals found: [2] ‘{’, ‘pkg’
[16:05:08.203] Searching for globals ... DONE
[16:05:08.203] Resolving globals: TRUE
[16:05:08.203] Resolving any globals that are futures ...
[16:05:08.203] - globals: [2] ‘{’, ‘pkg’
[16:05:08.203] Resolving any globals that are futures ... DONE
[16:05:08.204] Resolving futures part of globals (recursively) ...
[16:05:08.204] resolve() on list ...
[16:05:08.204]  recursive: 99
[16:05:08.204]  length: 1
[16:05:08.204]  elements: ‘pkg’
[16:05:08.205]  length: 0 (resolved future 1)
[16:05:08.205] resolve() on list ... DONE
[16:05:08.205] - globals: [1] ‘pkg’
[16:05:08.205] Resolving futures part of globals (recursively) ... DONE
[16:05:08.205] The total size of the 1 globals is 112 bytes (112 bytes)
[16:05:08.206] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[16:05:08.206] - globals: [1] ‘pkg’
[16:05:08.206] 
[16:05:08.206] getGlobalsAndPackages() ... DONE
[16:05:08.206] Packages needed by the future expression (n = 0): <none>
[16:05:08.207] Packages needed by future strategies (n = 0): <none>
[16:05:08.207] {
[16:05:08.207]     {
[16:05:08.207]         {
[16:05:08.207]             ...future.startTime <- base::Sys.time()
[16:05:08.207]             {
[16:05:08.207]                 {
[16:05:08.207]                   {
[16:05:08.207]                     base::local({
[16:05:08.207]                       has_future <- base::requireNamespace("future", 
[16:05:08.207]                         quietly = TRUE)
[16:05:08.207]                       if (has_future) {
[16:05:08.207]                         ns <- base::getNamespace("future")
[16:05:08.207]                         version <- ns[[".package"]][["version"]]
[16:05:08.207]                         if (is.null(version)) 
[16:05:08.207]                           version <- utils::packageVersion("future")
[16:05:08.207]                       }
[16:05:08.207]                       else {
[16:05:08.207]                         version <- NULL
[16:05:08.207]                       }
[16:05:08.207]                       if (!has_future || version < "1.8.0") {
[16:05:08.207]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:08.207]                           "", base::R.version$version.string), 
[16:05:08.207]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:08.207]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:08.207]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:08.207]                             "release", "version")], collapse = " "), 
[16:05:08.207]                           hostname = base::Sys.info()[["nodename"]])
[16:05:08.207]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:08.207]                           info)
[16:05:08.207]                         info <- base::paste(info, collapse = "; ")
[16:05:08.207]                         if (!has_future) {
[16:05:08.207]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:08.207]                             info)
[16:05:08.207]                         }
[16:05:08.207]                         else {
[16:05:08.207]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:08.207]                             info, version)
[16:05:08.207]                         }
[16:05:08.207]                         base::stop(msg)
[16:05:08.207]                       }
[16:05:08.207]                     })
[16:05:08.207]                   }
[16:05:08.207]                   options(future.plan = NULL)
[16:05:08.207]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:08.207]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:08.207]                 }
[16:05:08.207]                 ...future.workdir <- getwd()
[16:05:08.207]             }
[16:05:08.207]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:08.207]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:08.207]         }
[16:05:08.207]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:08.207]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:08.207]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:08.207]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:08.207]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:08.207]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:08.207]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:08.207]             base::names(...future.oldOptions))
[16:05:08.207]     }
[16:05:08.207]     if (FALSE) {
[16:05:08.207]     }
[16:05:08.207]     else {
[16:05:08.207]         if (TRUE) {
[16:05:08.207]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:08.207]                 open = "w")
[16:05:08.207]         }
[16:05:08.207]         else {
[16:05:08.207]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:08.207]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:08.207]         }
[16:05:08.207]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:08.207]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:08.207]             base::sink(type = "output", split = FALSE)
[16:05:08.207]             base::close(...future.stdout)
[16:05:08.207]         }, add = TRUE)
[16:05:08.207]     }
[16:05:08.207]     ...future.frame <- base::sys.nframe()
[16:05:08.207]     ...future.conditions <- base::list()
[16:05:08.207]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:08.207]     if (FALSE) {
[16:05:08.207]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:08.207]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:08.207]     }
[16:05:08.207]     ...future.result <- base::tryCatch({
[16:05:08.207]         base::withCallingHandlers({
[16:05:08.207]             ...future.value <- base::withVisible(base::local({
[16:05:08.207]                 pkg
[16:05:08.207]             }))
[16:05:08.207]             future::FutureResult(value = ...future.value$value, 
[16:05:08.207]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:08.207]                   ...future.rng), globalenv = if (FALSE) 
[16:05:08.207]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:08.207]                     ...future.globalenv.names))
[16:05:08.207]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:08.207]         }, condition = base::local({
[16:05:08.207]             c <- base::c
[16:05:08.207]             inherits <- base::inherits
[16:05:08.207]             invokeRestart <- base::invokeRestart
[16:05:08.207]             length <- base::length
[16:05:08.207]             list <- base::list
[16:05:08.207]             seq.int <- base::seq.int
[16:05:08.207]             signalCondition <- base::signalCondition
[16:05:08.207]             sys.calls <- base::sys.calls
[16:05:08.207]             `[[` <- base::`[[`
[16:05:08.207]             `+` <- base::`+`
[16:05:08.207]             `<<-` <- base::`<<-`
[16:05:08.207]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:08.207]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:08.207]                   3L)]
[16:05:08.207]             }
[16:05:08.207]             function(cond) {
[16:05:08.207]                 is_error <- inherits(cond, "error")
[16:05:08.207]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:08.207]                   NULL)
[16:05:08.207]                 if (is_error) {
[16:05:08.207]                   sessionInformation <- function() {
[16:05:08.207]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:08.207]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:08.207]                       search = base::search(), system = base::Sys.info())
[16:05:08.207]                   }
[16:05:08.207]                   ...future.conditions[[length(...future.conditions) + 
[16:05:08.207]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:08.207]                     cond$call), session = sessionInformation(), 
[16:05:08.207]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:08.207]                   signalCondition(cond)
[16:05:08.207]                 }
[16:05:08.207]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:08.207]                 "immediateCondition"))) {
[16:05:08.207]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:08.207]                   ...future.conditions[[length(...future.conditions) + 
[16:05:08.207]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:08.207]                   if (TRUE && !signal) {
[16:05:08.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.207]                     {
[16:05:08.207]                       inherits <- base::inherits
[16:05:08.207]                       invokeRestart <- base::invokeRestart
[16:05:08.207]                       is.null <- base::is.null
[16:05:08.207]                       muffled <- FALSE
[16:05:08.207]                       if (inherits(cond, "message")) {
[16:05:08.207]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:08.207]                         if (muffled) 
[16:05:08.207]                           invokeRestart("muffleMessage")
[16:05:08.207]                       }
[16:05:08.207]                       else if (inherits(cond, "warning")) {
[16:05:08.207]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:08.207]                         if (muffled) 
[16:05:08.207]                           invokeRestart("muffleWarning")
[16:05:08.207]                       }
[16:05:08.207]                       else if (inherits(cond, "condition")) {
[16:05:08.207]                         if (!is.null(pattern)) {
[16:05:08.207]                           computeRestarts <- base::computeRestarts
[16:05:08.207]                           grepl <- base::grepl
[16:05:08.207]                           restarts <- computeRestarts(cond)
[16:05:08.207]                           for (restart in restarts) {
[16:05:08.207]                             name <- restart$name
[16:05:08.207]                             if (is.null(name)) 
[16:05:08.207]                               next
[16:05:08.207]                             if (!grepl(pattern, name)) 
[16:05:08.207]                               next
[16:05:08.207]                             invokeRestart(restart)
[16:05:08.207]                             muffled <- TRUE
[16:05:08.207]                             break
[16:05:08.207]                           }
[16:05:08.207]                         }
[16:05:08.207]                       }
[16:05:08.207]                       invisible(muffled)
[16:05:08.207]                     }
[16:05:08.207]                     muffleCondition(cond, pattern = "^muffle")
[16:05:08.207]                   }
[16:05:08.207]                 }
[16:05:08.207]                 else {
[16:05:08.207]                   if (TRUE) {
[16:05:08.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.207]                     {
[16:05:08.207]                       inherits <- base::inherits
[16:05:08.207]                       invokeRestart <- base::invokeRestart
[16:05:08.207]                       is.null <- base::is.null
[16:05:08.207]                       muffled <- FALSE
[16:05:08.207]                       if (inherits(cond, "message")) {
[16:05:08.207]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:08.207]                         if (muffled) 
[16:05:08.207]                           invokeRestart("muffleMessage")
[16:05:08.207]                       }
[16:05:08.207]                       else if (inherits(cond, "warning")) {
[16:05:08.207]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:08.207]                         if (muffled) 
[16:05:08.207]                           invokeRestart("muffleWarning")
[16:05:08.207]                       }
[16:05:08.207]                       else if (inherits(cond, "condition")) {
[16:05:08.207]                         if (!is.null(pattern)) {
[16:05:08.207]                           computeRestarts <- base::computeRestarts
[16:05:08.207]                           grepl <- base::grepl
[16:05:08.207]                           restarts <- computeRestarts(cond)
[16:05:08.207]                           for (restart in restarts) {
[16:05:08.207]                             name <- restart$name
[16:05:08.207]                             if (is.null(name)) 
[16:05:08.207]                               next
[16:05:08.207]                             if (!grepl(pattern, name)) 
[16:05:08.207]                               next
[16:05:08.207]                             invokeRestart(restart)
[16:05:08.207]                             muffled <- TRUE
[16:05:08.207]                             break
[16:05:08.207]                           }
[16:05:08.207]                         }
[16:05:08.207]                       }
[16:05:08.207]                       invisible(muffled)
[16:05:08.207]                     }
[16:05:08.207]                     muffleCondition(cond, pattern = "^muffle")
[16:05:08.207]                   }
[16:05:08.207]                 }
[16:05:08.207]             }
[16:05:08.207]         }))
[16:05:08.207]     }, error = function(ex) {
[16:05:08.207]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:08.207]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:08.207]                 ...future.rng), started = ...future.startTime, 
[16:05:08.207]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:08.207]             version = "1.8"), class = "FutureResult")
[16:05:08.207]     }, finally = {
[16:05:08.207]         if (!identical(...future.workdir, getwd())) 
[16:05:08.207]             setwd(...future.workdir)
[16:05:08.207]         {
[16:05:08.207]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:08.207]                 ...future.oldOptions$nwarnings <- NULL
[16:05:08.207]             }
[16:05:08.207]             base::options(...future.oldOptions)
[16:05:08.207]             if (.Platform$OS.type == "windows") {
[16:05:08.207]                 old_names <- names(...future.oldEnvVars)
[16:05:08.207]                 envs <- base::Sys.getenv()
[16:05:08.207]                 names <- names(envs)
[16:05:08.207]                 common <- intersect(names, old_names)
[16:05:08.207]                 added <- setdiff(names, old_names)
[16:05:08.207]                 removed <- setdiff(old_names, names)
[16:05:08.207]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:08.207]                   envs[common]]
[16:05:08.207]                 NAMES <- toupper(changed)
[16:05:08.207]                 args <- list()
[16:05:08.207]                 for (kk in seq_along(NAMES)) {
[16:05:08.207]                   name <- changed[[kk]]
[16:05:08.207]                   NAME <- NAMES[[kk]]
[16:05:08.207]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.207]                     next
[16:05:08.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:08.207]                 }
[16:05:08.207]                 NAMES <- toupper(added)
[16:05:08.207]                 for (kk in seq_along(NAMES)) {
[16:05:08.207]                   name <- added[[kk]]
[16:05:08.207]                   NAME <- NAMES[[kk]]
[16:05:08.207]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.207]                     next
[16:05:08.207]                   args[[name]] <- ""
[16:05:08.207]                 }
[16:05:08.207]                 NAMES <- toupper(removed)
[16:05:08.207]                 for (kk in seq_along(NAMES)) {
[16:05:08.207]                   name <- removed[[kk]]
[16:05:08.207]                   NAME <- NAMES[[kk]]
[16:05:08.207]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.207]                     next
[16:05:08.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:08.207]                 }
[16:05:08.207]                 if (length(args) > 0) 
[16:05:08.207]                   base::do.call(base::Sys.setenv, args = args)
[16:05:08.207]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:08.207]             }
[16:05:08.207]             else {
[16:05:08.207]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:08.207]             }
[16:05:08.207]             {
[16:05:08.207]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:08.207]                   0L) {
[16:05:08.207]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:08.207]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:08.207]                   base::options(opts)
[16:05:08.207]                 }
[16:05:08.207]                 {
[16:05:08.207]                   {
[16:05:08.207]                     NULL
[16:05:08.207]                     RNGkind("Mersenne-Twister")
[16:05:08.207]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:08.207]                       inherits = FALSE)
[16:05:08.207]                   }
[16:05:08.207]                   options(future.plan = NULL)
[16:05:08.207]                   if (is.na(NA_character_)) 
[16:05:08.207]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:08.207]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:08.207]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:08.207]                     envir = parent.frame()) 
[16:05:08.207]                   {
[16:05:08.207]                     default_workers <- missing(workers)
[16:05:08.207]                     if (is.function(workers)) 
[16:05:08.207]                       workers <- workers()
[16:05:08.207]                     workers <- structure(as.integer(workers), 
[16:05:08.207]                       class = class(workers))
[16:05:08.207]                     stop_if_not(is.finite(workers), workers >= 
[16:05:08.207]                       1L)
[16:05:08.207]                     if ((workers == 1L && !inherits(workers, 
[16:05:08.207]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:08.207]                       if (default_workers) 
[16:05:08.207]                         supportsMulticore(warn = TRUE)
[16:05:08.207]                       return(sequential(..., envir = envir))
[16:05:08.207]                     }
[16:05:08.207]                     oopts <- options(mc.cores = workers)
[16:05:08.207]                     on.exit(options(oopts))
[16:05:08.207]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:08.207]                       envir = envir)
[16:05:08.207]                     if (!future$lazy) 
[16:05:08.207]                       future <- run(future)
[16:05:08.207]                     invisible(future)
[16:05:08.207]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:08.207]                 }
[16:05:08.207]             }
[16:05:08.207]         }
[16:05:08.207]     })
[16:05:08.207]     if (TRUE) {
[16:05:08.207]         base::sink(type = "output", split = FALSE)
[16:05:08.207]         if (TRUE) {
[16:05:08.207]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:08.207]         }
[16:05:08.207]         else {
[16:05:08.207]             ...future.result["stdout"] <- base::list(NULL)
[16:05:08.207]         }
[16:05:08.207]         base::close(...future.stdout)
[16:05:08.207]         ...future.stdout <- NULL
[16:05:08.207]     }
[16:05:08.207]     ...future.result$conditions <- ...future.conditions
[16:05:08.207]     ...future.result$finished <- base::Sys.time()
[16:05:08.207]     ...future.result
[16:05:08.207] }
[16:05:08.209] assign_globals() ...
[16:05:08.209] List of 1
[16:05:08.209]  $ pkg: chr "foo"
[16:05:08.209]  - attr(*, "where")=List of 1
[16:05:08.209]   ..$ pkg:<environment: R_EmptyEnv> 
[16:05:08.209]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:08.209]  - attr(*, "resolved")= logi TRUE
[16:05:08.209]  - attr(*, "total_size")= num 112
[16:05:08.212] - copied ‘pkg’ to environment
[16:05:08.212] assign_globals() ... done
[16:05:08.212] plan(): Setting new future strategy stack:
[16:05:08.213] List of future strategies:
[16:05:08.213] 1. sequential:
[16:05:08.213]    - args: function (..., envir = parent.frame())
[16:05:08.213]    - tweaked: FALSE
[16:05:08.213]    - call: NULL
[16:05:08.213] plan(): nbrOfWorkers() = 1
[16:05:08.214] plan(): Setting new future strategy stack:
[16:05:08.214] List of future strategies:
[16:05:08.214] 1. multicore:
[16:05:08.214]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:08.214]    - tweaked: FALSE
[16:05:08.214]    - call: plan(strategy)
[16:05:08.218] plan(): nbrOfWorkers() = 2
[16:05:08.218] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:08.218] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:08.219] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:08.223] - globals found: [3] ‘{’, ‘<-’, ‘+’
[16:05:08.223] Searching for globals ... DONE
[16:05:08.223] Resolving globals: TRUE
[16:05:08.223] Resolving any globals that are futures ...
[16:05:08.224] - globals: [3] ‘{’, ‘<-’, ‘+’
[16:05:08.224] Resolving any globals that are futures ... DONE
[16:05:08.224] 
[16:05:08.224] 
[16:05:08.224] getGlobalsAndPackages() ... DONE
[16:05:08.225] run() for ‘Future’ ...
[16:05:08.225] - state: ‘created’
[16:05:08.225] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:08.229] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:08.229] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:08.229]   - Field: ‘label’
[16:05:08.229]   - Field: ‘local’
[16:05:08.229]   - Field: ‘owner’
[16:05:08.229]   - Field: ‘envir’
[16:05:08.229]   - Field: ‘workers’
[16:05:08.230]   - Field: ‘packages’
[16:05:08.230]   - Field: ‘gc’
[16:05:08.230]   - Field: ‘job’
[16:05:08.230]   - Field: ‘conditions’
[16:05:08.230]   - Field: ‘expr’
[16:05:08.230]   - Field: ‘uuid’
[16:05:08.230]   - Field: ‘seed’
[16:05:08.230]   - Field: ‘version’
[16:05:08.230]   - Field: ‘result’
[16:05:08.230]   - Field: ‘asynchronous’
[16:05:08.231]   - Field: ‘calls’
[16:05:08.231]   - Field: ‘globals’
[16:05:08.231]   - Field: ‘stdout’
[16:05:08.231]   - Field: ‘earlySignal’
[16:05:08.231]   - Field: ‘lazy’
[16:05:08.231]   - Field: ‘state’
[16:05:08.231] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:08.231] - Launch lazy future ...
[16:05:08.232] Packages needed by the future expression (n = 0): <none>
[16:05:08.232] Packages needed by future strategies (n = 0): <none>
[16:05:08.232] {
[16:05:08.232]     {
[16:05:08.232]         {
[16:05:08.232]             ...future.startTime <- base::Sys.time()
[16:05:08.232]             {
[16:05:08.232]                 {
[16:05:08.232]                   {
[16:05:08.232]                     {
[16:05:08.232]                       base::local({
[16:05:08.232]                         has_future <- base::requireNamespace("future", 
[16:05:08.232]                           quietly = TRUE)
[16:05:08.232]                         if (has_future) {
[16:05:08.232]                           ns <- base::getNamespace("future")
[16:05:08.232]                           version <- ns[[".package"]][["version"]]
[16:05:08.232]                           if (is.null(version)) 
[16:05:08.232]                             version <- utils::packageVersion("future")
[16:05:08.232]                         }
[16:05:08.232]                         else {
[16:05:08.232]                           version <- NULL
[16:05:08.232]                         }
[16:05:08.232]                         if (!has_future || version < "1.8.0") {
[16:05:08.232]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:08.232]                             "", base::R.version$version.string), 
[16:05:08.232]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:08.232]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:08.232]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:08.232]                               "release", "version")], collapse = " "), 
[16:05:08.232]                             hostname = base::Sys.info()[["nodename"]])
[16:05:08.232]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:08.232]                             info)
[16:05:08.232]                           info <- base::paste(info, collapse = "; ")
[16:05:08.232]                           if (!has_future) {
[16:05:08.232]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:08.232]                               info)
[16:05:08.232]                           }
[16:05:08.232]                           else {
[16:05:08.232]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:08.232]                               info, version)
[16:05:08.232]                           }
[16:05:08.232]                           base::stop(msg)
[16:05:08.232]                         }
[16:05:08.232]                       })
[16:05:08.232]                     }
[16:05:08.232]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:08.232]                     base::options(mc.cores = 1L)
[16:05:08.232]                   }
[16:05:08.232]                   options(future.plan = NULL)
[16:05:08.232]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:08.232]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:08.232]                 }
[16:05:08.232]                 ...future.workdir <- getwd()
[16:05:08.232]             }
[16:05:08.232]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:08.232]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:08.232]         }
[16:05:08.232]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:08.232]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:08.232]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:08.232]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:08.232]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:08.232]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:08.232]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:08.232]             base::names(...future.oldOptions))
[16:05:08.232]     }
[16:05:08.232]     if (FALSE) {
[16:05:08.232]     }
[16:05:08.232]     else {
[16:05:08.232]         if (TRUE) {
[16:05:08.232]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:08.232]                 open = "w")
[16:05:08.232]         }
[16:05:08.232]         else {
[16:05:08.232]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:08.232]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:08.232]         }
[16:05:08.232]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:08.232]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:08.232]             base::sink(type = "output", split = FALSE)
[16:05:08.232]             base::close(...future.stdout)
[16:05:08.232]         }, add = TRUE)
[16:05:08.232]     }
[16:05:08.232]     ...future.frame <- base::sys.nframe()
[16:05:08.232]     ...future.conditions <- base::list()
[16:05:08.232]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:08.232]     if (FALSE) {
[16:05:08.232]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:08.232]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:08.232]     }
[16:05:08.232]     ...future.result <- base::tryCatch({
[16:05:08.232]         base::withCallingHandlers({
[16:05:08.232]             ...future.value <- base::withVisible(base::local({
[16:05:08.232]                 withCallingHandlers({
[16:05:08.232]                   {
[16:05:08.232]                     x <- 0
[16:05:08.232]                     x <- x + 1
[16:05:08.232]                     x
[16:05:08.232]                   }
[16:05:08.232]                 }, immediateCondition = function(cond) {
[16:05:08.232]                   save_rds <- function (object, pathname, ...) 
[16:05:08.232]                   {
[16:05:08.232]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:08.232]                     if (file_test("-f", pathname_tmp)) {
[16:05:08.232]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.232]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:08.232]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.232]                         fi_tmp[["mtime"]])
[16:05:08.232]                     }
[16:05:08.232]                     tryCatch({
[16:05:08.232]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:08.232]                     }, error = function(ex) {
[16:05:08.232]                       msg <- conditionMessage(ex)
[16:05:08.232]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.232]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:08.232]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.232]                         fi_tmp[["mtime"]], msg)
[16:05:08.232]                       ex$message <- msg
[16:05:08.232]                       stop(ex)
[16:05:08.232]                     })
[16:05:08.232]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:08.232]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:08.232]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:08.232]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.232]                       fi <- file.info(pathname)
[16:05:08.232]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:08.232]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.232]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:08.232]                         fi[["size"]], fi[["mtime"]])
[16:05:08.232]                       stop(msg)
[16:05:08.232]                     }
[16:05:08.232]                     invisible(pathname)
[16:05:08.232]                   }
[16:05:08.232]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:08.232]                     rootPath = tempdir()) 
[16:05:08.232]                   {
[16:05:08.232]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:08.232]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:08.232]                       tmpdir = path, fileext = ".rds")
[16:05:08.232]                     save_rds(obj, file)
[16:05:08.232]                   }
[16:05:08.232]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:08.232]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.232]                   {
[16:05:08.232]                     inherits <- base::inherits
[16:05:08.232]                     invokeRestart <- base::invokeRestart
[16:05:08.232]                     is.null <- base::is.null
[16:05:08.232]                     muffled <- FALSE
[16:05:08.232]                     if (inherits(cond, "message")) {
[16:05:08.232]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:08.232]                       if (muffled) 
[16:05:08.232]                         invokeRestart("muffleMessage")
[16:05:08.232]                     }
[16:05:08.232]                     else if (inherits(cond, "warning")) {
[16:05:08.232]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:08.232]                       if (muffled) 
[16:05:08.232]                         invokeRestart("muffleWarning")
[16:05:08.232]                     }
[16:05:08.232]                     else if (inherits(cond, "condition")) {
[16:05:08.232]                       if (!is.null(pattern)) {
[16:05:08.232]                         computeRestarts <- base::computeRestarts
[16:05:08.232]                         grepl <- base::grepl
[16:05:08.232]                         restarts <- computeRestarts(cond)
[16:05:08.232]                         for (restart in restarts) {
[16:05:08.232]                           name <- restart$name
[16:05:08.232]                           if (is.null(name)) 
[16:05:08.232]                             next
[16:05:08.232]                           if (!grepl(pattern, name)) 
[16:05:08.232]                             next
[16:05:08.232]                           invokeRestart(restart)
[16:05:08.232]                           muffled <- TRUE
[16:05:08.232]                           break
[16:05:08.232]                         }
[16:05:08.232]                       }
[16:05:08.232]                     }
[16:05:08.232]                     invisible(muffled)
[16:05:08.232]                   }
[16:05:08.232]                   muffleCondition(cond)
[16:05:08.232]                 })
[16:05:08.232]             }))
[16:05:08.232]             future::FutureResult(value = ...future.value$value, 
[16:05:08.232]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:08.232]                   ...future.rng), globalenv = if (FALSE) 
[16:05:08.232]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:08.232]                     ...future.globalenv.names))
[16:05:08.232]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:08.232]         }, condition = base::local({
[16:05:08.232]             c <- base::c
[16:05:08.232]             inherits <- base::inherits
[16:05:08.232]             invokeRestart <- base::invokeRestart
[16:05:08.232]             length <- base::length
[16:05:08.232]             list <- base::list
[16:05:08.232]             seq.int <- base::seq.int
[16:05:08.232]             signalCondition <- base::signalCondition
[16:05:08.232]             sys.calls <- base::sys.calls
[16:05:08.232]             `[[` <- base::`[[`
[16:05:08.232]             `+` <- base::`+`
[16:05:08.232]             `<<-` <- base::`<<-`
[16:05:08.232]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:08.232]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:08.232]                   3L)]
[16:05:08.232]             }
[16:05:08.232]             function(cond) {
[16:05:08.232]                 is_error <- inherits(cond, "error")
[16:05:08.232]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:08.232]                   NULL)
[16:05:08.232]                 if (is_error) {
[16:05:08.232]                   sessionInformation <- function() {
[16:05:08.232]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:08.232]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:08.232]                       search = base::search(), system = base::Sys.info())
[16:05:08.232]                   }
[16:05:08.232]                   ...future.conditions[[length(...future.conditions) + 
[16:05:08.232]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:08.232]                     cond$call), session = sessionInformation(), 
[16:05:08.232]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:08.232]                   signalCondition(cond)
[16:05:08.232]                 }
[16:05:08.232]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:08.232]                 "immediateCondition"))) {
[16:05:08.232]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:08.232]                   ...future.conditions[[length(...future.conditions) + 
[16:05:08.232]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:08.232]                   if (TRUE && !signal) {
[16:05:08.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.232]                     {
[16:05:08.232]                       inherits <- base::inherits
[16:05:08.232]                       invokeRestart <- base::invokeRestart
[16:05:08.232]                       is.null <- base::is.null
[16:05:08.232]                       muffled <- FALSE
[16:05:08.232]                       if (inherits(cond, "message")) {
[16:05:08.232]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:08.232]                         if (muffled) 
[16:05:08.232]                           invokeRestart("muffleMessage")
[16:05:08.232]                       }
[16:05:08.232]                       else if (inherits(cond, "warning")) {
[16:05:08.232]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:08.232]                         if (muffled) 
[16:05:08.232]                           invokeRestart("muffleWarning")
[16:05:08.232]                       }
[16:05:08.232]                       else if (inherits(cond, "condition")) {
[16:05:08.232]                         if (!is.null(pattern)) {
[16:05:08.232]                           computeRestarts <- base::computeRestarts
[16:05:08.232]                           grepl <- base::grepl
[16:05:08.232]                           restarts <- computeRestarts(cond)
[16:05:08.232]                           for (restart in restarts) {
[16:05:08.232]                             name <- restart$name
[16:05:08.232]                             if (is.null(name)) 
[16:05:08.232]                               next
[16:05:08.232]                             if (!grepl(pattern, name)) 
[16:05:08.232]                               next
[16:05:08.232]                             invokeRestart(restart)
[16:05:08.232]                             muffled <- TRUE
[16:05:08.232]                             break
[16:05:08.232]                           }
[16:05:08.232]                         }
[16:05:08.232]                       }
[16:05:08.232]                       invisible(muffled)
[16:05:08.232]                     }
[16:05:08.232]                     muffleCondition(cond, pattern = "^muffle")
[16:05:08.232]                   }
[16:05:08.232]                 }
[16:05:08.232]                 else {
[16:05:08.232]                   if (TRUE) {
[16:05:08.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.232]                     {
[16:05:08.232]                       inherits <- base::inherits
[16:05:08.232]                       invokeRestart <- base::invokeRestart
[16:05:08.232]                       is.null <- base::is.null
[16:05:08.232]                       muffled <- FALSE
[16:05:08.232]                       if (inherits(cond, "message")) {
[16:05:08.232]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:08.232]                         if (muffled) 
[16:05:08.232]                           invokeRestart("muffleMessage")
[16:05:08.232]                       }
[16:05:08.232]                       else if (inherits(cond, "warning")) {
[16:05:08.232]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:08.232]                         if (muffled) 
[16:05:08.232]                           invokeRestart("muffleWarning")
[16:05:08.232]                       }
[16:05:08.232]                       else if (inherits(cond, "condition")) {
[16:05:08.232]                         if (!is.null(pattern)) {
[16:05:08.232]                           computeRestarts <- base::computeRestarts
[16:05:08.232]                           grepl <- base::grepl
[16:05:08.232]                           restarts <- computeRestarts(cond)
[16:05:08.232]                           for (restart in restarts) {
[16:05:08.232]                             name <- restart$name
[16:05:08.232]                             if (is.null(name)) 
[16:05:08.232]                               next
[16:05:08.232]                             if (!grepl(pattern, name)) 
[16:05:08.232]                               next
[16:05:08.232]                             invokeRestart(restart)
[16:05:08.232]                             muffled <- TRUE
[16:05:08.232]                             break
[16:05:08.232]                           }
[16:05:08.232]                         }
[16:05:08.232]                       }
[16:05:08.232]                       invisible(muffled)
[16:05:08.232]                     }
[16:05:08.232]                     muffleCondition(cond, pattern = "^muffle")
[16:05:08.232]                   }
[16:05:08.232]                 }
[16:05:08.232]             }
[16:05:08.232]         }))
[16:05:08.232]     }, error = function(ex) {
[16:05:08.232]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:08.232]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:08.232]                 ...future.rng), started = ...future.startTime, 
[16:05:08.232]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:08.232]             version = "1.8"), class = "FutureResult")
[16:05:08.232]     }, finally = {
[16:05:08.232]         if (!identical(...future.workdir, getwd())) 
[16:05:08.232]             setwd(...future.workdir)
[16:05:08.232]         {
[16:05:08.232]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:08.232]                 ...future.oldOptions$nwarnings <- NULL
[16:05:08.232]             }
[16:05:08.232]             base::options(...future.oldOptions)
[16:05:08.232]             if (.Platform$OS.type == "windows") {
[16:05:08.232]                 old_names <- names(...future.oldEnvVars)
[16:05:08.232]                 envs <- base::Sys.getenv()
[16:05:08.232]                 names <- names(envs)
[16:05:08.232]                 common <- intersect(names, old_names)
[16:05:08.232]                 added <- setdiff(names, old_names)
[16:05:08.232]                 removed <- setdiff(old_names, names)
[16:05:08.232]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:08.232]                   envs[common]]
[16:05:08.232]                 NAMES <- toupper(changed)
[16:05:08.232]                 args <- list()
[16:05:08.232]                 for (kk in seq_along(NAMES)) {
[16:05:08.232]                   name <- changed[[kk]]
[16:05:08.232]                   NAME <- NAMES[[kk]]
[16:05:08.232]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.232]                     next
[16:05:08.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:08.232]                 }
[16:05:08.232]                 NAMES <- toupper(added)
[16:05:08.232]                 for (kk in seq_along(NAMES)) {
[16:05:08.232]                   name <- added[[kk]]
[16:05:08.232]                   NAME <- NAMES[[kk]]
[16:05:08.232]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.232]                     next
[16:05:08.232]                   args[[name]] <- ""
[16:05:08.232]                 }
[16:05:08.232]                 NAMES <- toupper(removed)
[16:05:08.232]                 for (kk in seq_along(NAMES)) {
[16:05:08.232]                   name <- removed[[kk]]
[16:05:08.232]                   NAME <- NAMES[[kk]]
[16:05:08.232]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.232]                     next
[16:05:08.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:08.232]                 }
[16:05:08.232]                 if (length(args) > 0) 
[16:05:08.232]                   base::do.call(base::Sys.setenv, args = args)
[16:05:08.232]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:08.232]             }
[16:05:08.232]             else {
[16:05:08.232]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:08.232]             }
[16:05:08.232]             {
[16:05:08.232]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:08.232]                   0L) {
[16:05:08.232]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:08.232]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:08.232]                   base::options(opts)
[16:05:08.232]                 }
[16:05:08.232]                 {
[16:05:08.232]                   {
[16:05:08.232]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:08.232]                     NULL
[16:05:08.232]                   }
[16:05:08.232]                   options(future.plan = NULL)
[16:05:08.232]                   if (is.na(NA_character_)) 
[16:05:08.232]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:08.232]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:08.232]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:08.232]                     envir = parent.frame()) 
[16:05:08.232]                   {
[16:05:08.232]                     default_workers <- missing(workers)
[16:05:08.232]                     if (is.function(workers)) 
[16:05:08.232]                       workers <- workers()
[16:05:08.232]                     workers <- structure(as.integer(workers), 
[16:05:08.232]                       class = class(workers))
[16:05:08.232]                     stop_if_not(is.finite(workers), workers >= 
[16:05:08.232]                       1L)
[16:05:08.232]                     if ((workers == 1L && !inherits(workers, 
[16:05:08.232]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:08.232]                       if (default_workers) 
[16:05:08.232]                         supportsMulticore(warn = TRUE)
[16:05:08.232]                       return(sequential(..., envir = envir))
[16:05:08.232]                     }
[16:05:08.232]                     oopts <- options(mc.cores = workers)
[16:05:08.232]                     on.exit(options(oopts))
[16:05:08.232]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:08.232]                       envir = envir)
[16:05:08.232]                     if (!future$lazy) 
[16:05:08.232]                       future <- run(future)
[16:05:08.232]                     invisible(future)
[16:05:08.232]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:08.232]                 }
[16:05:08.232]             }
[16:05:08.232]         }
[16:05:08.232]     })
[16:05:08.232]     if (TRUE) {
[16:05:08.232]         base::sink(type = "output", split = FALSE)
[16:05:08.232]         if (TRUE) {
[16:05:08.232]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:08.232]         }
[16:05:08.232]         else {
[16:05:08.232]             ...future.result["stdout"] <- base::list(NULL)
[16:05:08.232]         }
[16:05:08.232]         base::close(...future.stdout)
[16:05:08.232]         ...future.stdout <- NULL
[16:05:08.232]     }
[16:05:08.232]     ...future.result$conditions <- ...future.conditions
[16:05:08.232]     ...future.result$finished <- base::Sys.time()
[16:05:08.232]     ...future.result
[16:05:08.232] }
[16:05:08.235] requestCore(): workers = 2
[16:05:08.237] MulticoreFuture started
[16:05:08.237] - Launch lazy future ... done
[16:05:08.237] run() for ‘MulticoreFuture’ ... done
[16:05:08.238] result() for MulticoreFuture ...
[16:05:08.238] plan(): Setting new future strategy stack:
[16:05:08.238] List of future strategies:
[16:05:08.238] 1. sequential:
[16:05:08.238]    - args: function (..., envir = parent.frame())
[16:05:08.238]    - tweaked: FALSE
[16:05:08.238]    - call: NULL
[16:05:08.239] plan(): nbrOfWorkers() = 1
[16:05:08.241] plan(): Setting new future strategy stack:
[16:05:08.241] List of future strategies:
[16:05:08.241] 1. multicore:
[16:05:08.241]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:08.241]    - tweaked: FALSE
[16:05:08.241]    - call: plan(strategy)
[16:05:08.246] plan(): nbrOfWorkers() = 2
[16:05:08.247] result() for MulticoreFuture ...
[16:05:08.247] result() for MulticoreFuture ... done
[16:05:08.247] result() for MulticoreFuture ... done
[16:05:08.248] result() for MulticoreFuture ...
[16:05:08.248] result() for MulticoreFuture ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:08.248] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:08.249] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:08.251] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[16:05:08.251] Searching for globals ... DONE
[16:05:08.251] Resolving globals: TRUE
[16:05:08.252] Resolving any globals that are futures ...
[16:05:08.252] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[16:05:08.252] Resolving any globals that are futures ... DONE
[16:05:08.252] Resolving futures part of globals (recursively) ...
[16:05:08.253] resolve() on list ...
[16:05:08.253]  recursive: 99
[16:05:08.253]  length: 1
[16:05:08.253]  elements: ‘x’
[16:05:08.253]  length: 0 (resolved future 1)
[16:05:08.253] resolve() on list ... DONE
[16:05:08.253] - globals: [1] ‘x’
[16:05:08.253] Resolving futures part of globals (recursively) ... DONE
[16:05:08.254] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:08.254] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[16:05:08.254] - globals: [1] ‘x’
[16:05:08.254] 
[16:05:08.255] getGlobalsAndPackages() ... DONE
[16:05:08.255] run() for ‘Future’ ...
[16:05:08.255] - state: ‘created’
[16:05:08.255] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:08.259] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:08.259] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:08.259]   - Field: ‘label’
[16:05:08.260]   - Field: ‘local’
[16:05:08.260]   - Field: ‘owner’
[16:05:08.260]   - Field: ‘envir’
[16:05:08.260]   - Field: ‘workers’
[16:05:08.260]   - Field: ‘packages’
[16:05:08.260]   - Field: ‘gc’
[16:05:08.260]   - Field: ‘job’
[16:05:08.260]   - Field: ‘conditions’
[16:05:08.260]   - Field: ‘expr’
[16:05:08.261]   - Field: ‘uuid’
[16:05:08.261]   - Field: ‘seed’
[16:05:08.261]   - Field: ‘version’
[16:05:08.261]   - Field: ‘result’
[16:05:08.261]   - Field: ‘asynchronous’
[16:05:08.261]   - Field: ‘calls’
[16:05:08.261]   - Field: ‘globals’
[16:05:08.261]   - Field: ‘stdout’
[16:05:08.262]   - Field: ‘earlySignal’
[16:05:08.264]   - Field: ‘lazy’
[16:05:08.264]   - Field: ‘state’
[16:05:08.264] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:08.264] - Launch lazy future ...
[16:05:08.265] Packages needed by the future expression (n = 0): <none>
[16:05:08.265] Packages needed by future strategies (n = 0): <none>
[16:05:08.266] {
[16:05:08.266]     {
[16:05:08.266]         {
[16:05:08.266]             ...future.startTime <- base::Sys.time()
[16:05:08.266]             {
[16:05:08.266]                 {
[16:05:08.266]                   {
[16:05:08.266]                     {
[16:05:08.266]                       base::local({
[16:05:08.266]                         has_future <- base::requireNamespace("future", 
[16:05:08.266]                           quietly = TRUE)
[16:05:08.266]                         if (has_future) {
[16:05:08.266]                           ns <- base::getNamespace("future")
[16:05:08.266]                           version <- ns[[".package"]][["version"]]
[16:05:08.266]                           if (is.null(version)) 
[16:05:08.266]                             version <- utils::packageVersion("future")
[16:05:08.266]                         }
[16:05:08.266]                         else {
[16:05:08.266]                           version <- NULL
[16:05:08.266]                         }
[16:05:08.266]                         if (!has_future || version < "1.8.0") {
[16:05:08.266]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:08.266]                             "", base::R.version$version.string), 
[16:05:08.266]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:08.266]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:08.266]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:08.266]                               "release", "version")], collapse = " "), 
[16:05:08.266]                             hostname = base::Sys.info()[["nodename"]])
[16:05:08.266]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:08.266]                             info)
[16:05:08.266]                           info <- base::paste(info, collapse = "; ")
[16:05:08.266]                           if (!has_future) {
[16:05:08.266]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:08.266]                               info)
[16:05:08.266]                           }
[16:05:08.266]                           else {
[16:05:08.266]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:08.266]                               info, version)
[16:05:08.266]                           }
[16:05:08.266]                           base::stop(msg)
[16:05:08.266]                         }
[16:05:08.266]                       })
[16:05:08.266]                     }
[16:05:08.266]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:08.266]                     base::options(mc.cores = 1L)
[16:05:08.266]                   }
[16:05:08.266]                   options(future.plan = NULL)
[16:05:08.266]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:08.266]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:08.266]                 }
[16:05:08.266]                 ...future.workdir <- getwd()
[16:05:08.266]             }
[16:05:08.266]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:08.266]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:08.266]         }
[16:05:08.266]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:08.266]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:08.266]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:08.266]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:08.266]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:08.266]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:08.266]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:08.266]             base::names(...future.oldOptions))
[16:05:08.266]     }
[16:05:08.266]     if (FALSE) {
[16:05:08.266]     }
[16:05:08.266]     else {
[16:05:08.266]         if (TRUE) {
[16:05:08.266]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:08.266]                 open = "w")
[16:05:08.266]         }
[16:05:08.266]         else {
[16:05:08.266]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:08.266]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:08.266]         }
[16:05:08.266]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:08.266]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:08.266]             base::sink(type = "output", split = FALSE)
[16:05:08.266]             base::close(...future.stdout)
[16:05:08.266]         }, add = TRUE)
[16:05:08.266]     }
[16:05:08.266]     ...future.frame <- base::sys.nframe()
[16:05:08.266]     ...future.conditions <- base::list()
[16:05:08.266]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:08.266]     if (FALSE) {
[16:05:08.266]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:08.266]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:08.266]     }
[16:05:08.266]     ...future.result <- base::tryCatch({
[16:05:08.266]         base::withCallingHandlers({
[16:05:08.266]             ...future.value <- base::withVisible(base::local({
[16:05:08.266]                 withCallingHandlers({
[16:05:08.266]                   {
[16:05:08.266]                     x <- x + 1
[16:05:08.266]                     x
[16:05:08.266]                   }
[16:05:08.266]                 }, immediateCondition = function(cond) {
[16:05:08.266]                   save_rds <- function (object, pathname, ...) 
[16:05:08.266]                   {
[16:05:08.266]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:08.266]                     if (file_test("-f", pathname_tmp)) {
[16:05:08.266]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.266]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:08.266]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.266]                         fi_tmp[["mtime"]])
[16:05:08.266]                     }
[16:05:08.266]                     tryCatch({
[16:05:08.266]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:08.266]                     }, error = function(ex) {
[16:05:08.266]                       msg <- conditionMessage(ex)
[16:05:08.266]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.266]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:08.266]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.266]                         fi_tmp[["mtime"]], msg)
[16:05:08.266]                       ex$message <- msg
[16:05:08.266]                       stop(ex)
[16:05:08.266]                     })
[16:05:08.266]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:08.266]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:08.266]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:08.266]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.266]                       fi <- file.info(pathname)
[16:05:08.266]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:08.266]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.266]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:08.266]                         fi[["size"]], fi[["mtime"]])
[16:05:08.266]                       stop(msg)
[16:05:08.266]                     }
[16:05:08.266]                     invisible(pathname)
[16:05:08.266]                   }
[16:05:08.266]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:08.266]                     rootPath = tempdir()) 
[16:05:08.266]                   {
[16:05:08.266]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:08.266]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:08.266]                       tmpdir = path, fileext = ".rds")
[16:05:08.266]                     save_rds(obj, file)
[16:05:08.266]                   }
[16:05:08.266]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:08.266]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.266]                   {
[16:05:08.266]                     inherits <- base::inherits
[16:05:08.266]                     invokeRestart <- base::invokeRestart
[16:05:08.266]                     is.null <- base::is.null
[16:05:08.266]                     muffled <- FALSE
[16:05:08.266]                     if (inherits(cond, "message")) {
[16:05:08.266]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:08.266]                       if (muffled) 
[16:05:08.266]                         invokeRestart("muffleMessage")
[16:05:08.266]                     }
[16:05:08.266]                     else if (inherits(cond, "warning")) {
[16:05:08.266]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:08.266]                       if (muffled) 
[16:05:08.266]                         invokeRestart("muffleWarning")
[16:05:08.266]                     }
[16:05:08.266]                     else if (inherits(cond, "condition")) {
[16:05:08.266]                       if (!is.null(pattern)) {
[16:05:08.266]                         computeRestarts <- base::computeRestarts
[16:05:08.266]                         grepl <- base::grepl
[16:05:08.266]                         restarts <- computeRestarts(cond)
[16:05:08.266]                         for (restart in restarts) {
[16:05:08.266]                           name <- restart$name
[16:05:08.266]                           if (is.null(name)) 
[16:05:08.266]                             next
[16:05:08.266]                           if (!grepl(pattern, name)) 
[16:05:08.266]                             next
[16:05:08.266]                           invokeRestart(restart)
[16:05:08.266]                           muffled <- TRUE
[16:05:08.266]                           break
[16:05:08.266]                         }
[16:05:08.266]                       }
[16:05:08.266]                     }
[16:05:08.266]                     invisible(muffled)
[16:05:08.266]                   }
[16:05:08.266]                   muffleCondition(cond)
[16:05:08.266]                 })
[16:05:08.266]             }))
[16:05:08.266]             future::FutureResult(value = ...future.value$value, 
[16:05:08.266]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:08.266]                   ...future.rng), globalenv = if (FALSE) 
[16:05:08.266]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:08.266]                     ...future.globalenv.names))
[16:05:08.266]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:08.266]         }, condition = base::local({
[16:05:08.266]             c <- base::c
[16:05:08.266]             inherits <- base::inherits
[16:05:08.266]             invokeRestart <- base::invokeRestart
[16:05:08.266]             length <- base::length
[16:05:08.266]             list <- base::list
[16:05:08.266]             seq.int <- base::seq.int
[16:05:08.266]             signalCondition <- base::signalCondition
[16:05:08.266]             sys.calls <- base::sys.calls
[16:05:08.266]             `[[` <- base::`[[`
[16:05:08.266]             `+` <- base::`+`
[16:05:08.266]             `<<-` <- base::`<<-`
[16:05:08.266]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:08.266]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:08.266]                   3L)]
[16:05:08.266]             }
[16:05:08.266]             function(cond) {
[16:05:08.266]                 is_error <- inherits(cond, "error")
[16:05:08.266]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:08.266]                   NULL)
[16:05:08.266]                 if (is_error) {
[16:05:08.266]                   sessionInformation <- function() {
[16:05:08.266]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:08.266]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:08.266]                       search = base::search(), system = base::Sys.info())
[16:05:08.266]                   }
[16:05:08.266]                   ...future.conditions[[length(...future.conditions) + 
[16:05:08.266]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:08.266]                     cond$call), session = sessionInformation(), 
[16:05:08.266]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:08.266]                   signalCondition(cond)
[16:05:08.266]                 }
[16:05:08.266]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:08.266]                 "immediateCondition"))) {
[16:05:08.266]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:08.266]                   ...future.conditions[[length(...future.conditions) + 
[16:05:08.266]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:08.266]                   if (TRUE && !signal) {
[16:05:08.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.266]                     {
[16:05:08.266]                       inherits <- base::inherits
[16:05:08.266]                       invokeRestart <- base::invokeRestart
[16:05:08.266]                       is.null <- base::is.null
[16:05:08.266]                       muffled <- FALSE
[16:05:08.266]                       if (inherits(cond, "message")) {
[16:05:08.266]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:08.266]                         if (muffled) 
[16:05:08.266]                           invokeRestart("muffleMessage")
[16:05:08.266]                       }
[16:05:08.266]                       else if (inherits(cond, "warning")) {
[16:05:08.266]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:08.266]                         if (muffled) 
[16:05:08.266]                           invokeRestart("muffleWarning")
[16:05:08.266]                       }
[16:05:08.266]                       else if (inherits(cond, "condition")) {
[16:05:08.266]                         if (!is.null(pattern)) {
[16:05:08.266]                           computeRestarts <- base::computeRestarts
[16:05:08.266]                           grepl <- base::grepl
[16:05:08.266]                           restarts <- computeRestarts(cond)
[16:05:08.266]                           for (restart in restarts) {
[16:05:08.266]                             name <- restart$name
[16:05:08.266]                             if (is.null(name)) 
[16:05:08.266]                               next
[16:05:08.266]                             if (!grepl(pattern, name)) 
[16:05:08.266]                               next
[16:05:08.266]                             invokeRestart(restart)
[16:05:08.266]                             muffled <- TRUE
[16:05:08.266]                             break
[16:05:08.266]                           }
[16:05:08.266]                         }
[16:05:08.266]                       }
[16:05:08.266]                       invisible(muffled)
[16:05:08.266]                     }
[16:05:08.266]                     muffleCondition(cond, pattern = "^muffle")
[16:05:08.266]                   }
[16:05:08.266]                 }
[16:05:08.266]                 else {
[16:05:08.266]                   if (TRUE) {
[16:05:08.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.266]                     {
[16:05:08.266]                       inherits <- base::inherits
[16:05:08.266]                       invokeRestart <- base::invokeRestart
[16:05:08.266]                       is.null <- base::is.null
[16:05:08.266]                       muffled <- FALSE
[16:05:08.266]                       if (inherits(cond, "message")) {
[16:05:08.266]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:08.266]                         if (muffled) 
[16:05:08.266]                           invokeRestart("muffleMessage")
[16:05:08.266]                       }
[16:05:08.266]                       else if (inherits(cond, "warning")) {
[16:05:08.266]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:08.266]                         if (muffled) 
[16:05:08.266]                           invokeRestart("muffleWarning")
[16:05:08.266]                       }
[16:05:08.266]                       else if (inherits(cond, "condition")) {
[16:05:08.266]                         if (!is.null(pattern)) {
[16:05:08.266]                           computeRestarts <- base::computeRestarts
[16:05:08.266]                           grepl <- base::grepl
[16:05:08.266]                           restarts <- computeRestarts(cond)
[16:05:08.266]                           for (restart in restarts) {
[16:05:08.266]                             name <- restart$name
[16:05:08.266]                             if (is.null(name)) 
[16:05:08.266]                               next
[16:05:08.266]                             if (!grepl(pattern, name)) 
[16:05:08.266]                               next
[16:05:08.266]                             invokeRestart(restart)
[16:05:08.266]                             muffled <- TRUE
[16:05:08.266]                             break
[16:05:08.266]                           }
[16:05:08.266]                         }
[16:05:08.266]                       }
[16:05:08.266]                       invisible(muffled)
[16:05:08.266]                     }
[16:05:08.266]                     muffleCondition(cond, pattern = "^muffle")
[16:05:08.266]                   }
[16:05:08.266]                 }
[16:05:08.266]             }
[16:05:08.266]         }))
[16:05:08.266]     }, error = function(ex) {
[16:05:08.266]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:08.266]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:08.266]                 ...future.rng), started = ...future.startTime, 
[16:05:08.266]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:08.266]             version = "1.8"), class = "FutureResult")
[16:05:08.266]     }, finally = {
[16:05:08.266]         if (!identical(...future.workdir, getwd())) 
[16:05:08.266]             setwd(...future.workdir)
[16:05:08.266]         {
[16:05:08.266]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:08.266]                 ...future.oldOptions$nwarnings <- NULL
[16:05:08.266]             }
[16:05:08.266]             base::options(...future.oldOptions)
[16:05:08.266]             if (.Platform$OS.type == "windows") {
[16:05:08.266]                 old_names <- names(...future.oldEnvVars)
[16:05:08.266]                 envs <- base::Sys.getenv()
[16:05:08.266]                 names <- names(envs)
[16:05:08.266]                 common <- intersect(names, old_names)
[16:05:08.266]                 added <- setdiff(names, old_names)
[16:05:08.266]                 removed <- setdiff(old_names, names)
[16:05:08.266]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:08.266]                   envs[common]]
[16:05:08.266]                 NAMES <- toupper(changed)
[16:05:08.266]                 args <- list()
[16:05:08.266]                 for (kk in seq_along(NAMES)) {
[16:05:08.266]                   name <- changed[[kk]]
[16:05:08.266]                   NAME <- NAMES[[kk]]
[16:05:08.266]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.266]                     next
[16:05:08.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:08.266]                 }
[16:05:08.266]                 NAMES <- toupper(added)
[16:05:08.266]                 for (kk in seq_along(NAMES)) {
[16:05:08.266]                   name <- added[[kk]]
[16:05:08.266]                   NAME <- NAMES[[kk]]
[16:05:08.266]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.266]                     next
[16:05:08.266]                   args[[name]] <- ""
[16:05:08.266]                 }
[16:05:08.266]                 NAMES <- toupper(removed)
[16:05:08.266]                 for (kk in seq_along(NAMES)) {
[16:05:08.266]                   name <- removed[[kk]]
[16:05:08.266]                   NAME <- NAMES[[kk]]
[16:05:08.266]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.266]                     next
[16:05:08.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:08.266]                 }
[16:05:08.266]                 if (length(args) > 0) 
[16:05:08.266]                   base::do.call(base::Sys.setenv, args = args)
[16:05:08.266]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:08.266]             }
[16:05:08.266]             else {
[16:05:08.266]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:08.266]             }
[16:05:08.266]             {
[16:05:08.266]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:08.266]                   0L) {
[16:05:08.266]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:08.266]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:08.266]                   base::options(opts)
[16:05:08.266]                 }
[16:05:08.266]                 {
[16:05:08.266]                   {
[16:05:08.266]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:08.266]                     NULL
[16:05:08.266]                   }
[16:05:08.266]                   options(future.plan = NULL)
[16:05:08.266]                   if (is.na(NA_character_)) 
[16:05:08.266]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:08.266]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:08.266]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:08.266]                     envir = parent.frame()) 
[16:05:08.266]                   {
[16:05:08.266]                     default_workers <- missing(workers)
[16:05:08.266]                     if (is.function(workers)) 
[16:05:08.266]                       workers <- workers()
[16:05:08.266]                     workers <- structure(as.integer(workers), 
[16:05:08.266]                       class = class(workers))
[16:05:08.266]                     stop_if_not(is.finite(workers), workers >= 
[16:05:08.266]                       1L)
[16:05:08.266]                     if ((workers == 1L && !inherits(workers, 
[16:05:08.266]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:08.266]                       if (default_workers) 
[16:05:08.266]                         supportsMulticore(warn = TRUE)
[16:05:08.266]                       return(sequential(..., envir = envir))
[16:05:08.266]                     }
[16:05:08.266]                     oopts <- options(mc.cores = workers)
[16:05:08.266]                     on.exit(options(oopts))
[16:05:08.266]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:08.266]                       envir = envir)
[16:05:08.266]                     if (!future$lazy) 
[16:05:08.266]                       future <- run(future)
[16:05:08.266]                     invisible(future)
[16:05:08.266]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:08.266]                 }
[16:05:08.266]             }
[16:05:08.266]         }
[16:05:08.266]     })
[16:05:08.266]     if (TRUE) {
[16:05:08.266]         base::sink(type = "output", split = FALSE)
[16:05:08.266]         if (TRUE) {
[16:05:08.266]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:08.266]         }
[16:05:08.266]         else {
[16:05:08.266]             ...future.result["stdout"] <- base::list(NULL)
[16:05:08.266]         }
[16:05:08.266]         base::close(...future.stdout)
[16:05:08.266]         ...future.stdout <- NULL
[16:05:08.266]     }
[16:05:08.266]     ...future.result$conditions <- ...future.conditions
[16:05:08.266]     ...future.result$finished <- base::Sys.time()
[16:05:08.266]     ...future.result
[16:05:08.266] }
[16:05:08.268] assign_globals() ...
[16:05:08.269] List of 1
[16:05:08.269]  $ x: num 1
[16:05:08.269]  - attr(*, "where")=List of 1
[16:05:08.269]   ..$ x:<environment: R_EmptyEnv> 
[16:05:08.269]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:08.269]  - attr(*, "resolved")= logi TRUE
[16:05:08.269]  - attr(*, "total_size")= num 56
[16:05:08.269]  - attr(*, "already-done")= logi TRUE
[16:05:08.272] - copied ‘x’ to environment
[16:05:08.272] assign_globals() ... done
[16:05:08.272] requestCore(): workers = 2
[16:05:08.274] MulticoreFuture started
[16:05:08.275] - Launch lazy future ... done
[16:05:08.275] run() for ‘MulticoreFuture’ ... done
[16:05:08.276] plan(): Setting new future strategy stack:
[16:05:08.276] result() for MulticoreFuture ...
[16:05:08.276] List of future strategies:
[16:05:08.276] 1. sequential:
[16:05:08.276]    - args: function (..., envir = parent.frame())
[16:05:08.276]    - tweaked: FALSE
[16:05:08.276]    - call: NULL
[16:05:08.277] plan(): nbrOfWorkers() = 1
[16:05:08.279] plan(): Setting new future strategy stack:
[16:05:08.279] List of future strategies:
[16:05:08.279] 1. multicore:
[16:05:08.279]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:08.279]    - tweaked: FALSE
[16:05:08.279]    - call: plan(strategy)
[16:05:08.285] plan(): nbrOfWorkers() = 2
[16:05:08.286] result() for MulticoreFuture ...
[16:05:08.286] result() for MulticoreFuture ... done
[16:05:08.286] result() for MulticoreFuture ... done
[16:05:08.286] result() for MulticoreFuture ...
[16:05:08.286] result() for MulticoreFuture ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:08.287] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:08.287] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:08.290] - globals found: [3] ‘{’, ‘<-’, ‘x’
[16:05:08.290] Searching for globals ... DONE
[16:05:08.290] Resolving globals: TRUE
[16:05:08.290] Resolving any globals that are futures ...
[16:05:08.290] - globals: [3] ‘{’, ‘<-’, ‘x’
[16:05:08.291] Resolving any globals that are futures ... DONE
[16:05:08.291] Resolving futures part of globals (recursively) ...
[16:05:08.291] resolve() on list ...
[16:05:08.291]  recursive: 99
[16:05:08.292]  length: 1
[16:05:08.292]  elements: ‘x’
[16:05:08.292]  length: 0 (resolved future 1)
[16:05:08.292] resolve() on list ... DONE
[16:05:08.292] - globals: [1] ‘x’
[16:05:08.292] Resolving futures part of globals (recursively) ... DONE
[16:05:08.292] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[16:05:08.293] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[16:05:08.293] - globals: [1] ‘x’
[16:05:08.293] 
[16:05:08.293] getGlobalsAndPackages() ... DONE
[16:05:08.294] run() for ‘Future’ ...
[16:05:08.294] - state: ‘created’
[16:05:08.294] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:08.298] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:08.298] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:08.298]   - Field: ‘label’
[16:05:08.298]   - Field: ‘local’
[16:05:08.298]   - Field: ‘owner’
[16:05:08.299]   - Field: ‘envir’
[16:05:08.299]   - Field: ‘workers’
[16:05:08.299]   - Field: ‘packages’
[16:05:08.299]   - Field: ‘gc’
[16:05:08.299]   - Field: ‘job’
[16:05:08.299]   - Field: ‘conditions’
[16:05:08.299]   - Field: ‘expr’
[16:05:08.299]   - Field: ‘uuid’
[16:05:08.299]   - Field: ‘seed’
[16:05:08.300]   - Field: ‘version’
[16:05:08.300]   - Field: ‘result’
[16:05:08.300]   - Field: ‘asynchronous’
[16:05:08.300]   - Field: ‘calls’
[16:05:08.300]   - Field: ‘globals’
[16:05:08.300]   - Field: ‘stdout’
[16:05:08.300]   - Field: ‘earlySignal’
[16:05:08.300]   - Field: ‘lazy’
[16:05:08.300]   - Field: ‘state’
[16:05:08.301] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:08.301] - Launch lazy future ...
[16:05:08.301] Packages needed by the future expression (n = 0): <none>
[16:05:08.301] Packages needed by future strategies (n = 0): <none>
[16:05:08.302] {
[16:05:08.302]     {
[16:05:08.302]         {
[16:05:08.302]             ...future.startTime <- base::Sys.time()
[16:05:08.302]             {
[16:05:08.302]                 {
[16:05:08.302]                   {
[16:05:08.302]                     {
[16:05:08.302]                       base::local({
[16:05:08.302]                         has_future <- base::requireNamespace("future", 
[16:05:08.302]                           quietly = TRUE)
[16:05:08.302]                         if (has_future) {
[16:05:08.302]                           ns <- base::getNamespace("future")
[16:05:08.302]                           version <- ns[[".package"]][["version"]]
[16:05:08.302]                           if (is.null(version)) 
[16:05:08.302]                             version <- utils::packageVersion("future")
[16:05:08.302]                         }
[16:05:08.302]                         else {
[16:05:08.302]                           version <- NULL
[16:05:08.302]                         }
[16:05:08.302]                         if (!has_future || version < "1.8.0") {
[16:05:08.302]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:08.302]                             "", base::R.version$version.string), 
[16:05:08.302]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:08.302]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:08.302]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:08.302]                               "release", "version")], collapse = " "), 
[16:05:08.302]                             hostname = base::Sys.info()[["nodename"]])
[16:05:08.302]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:08.302]                             info)
[16:05:08.302]                           info <- base::paste(info, collapse = "; ")
[16:05:08.302]                           if (!has_future) {
[16:05:08.302]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:08.302]                               info)
[16:05:08.302]                           }
[16:05:08.302]                           else {
[16:05:08.302]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:08.302]                               info, version)
[16:05:08.302]                           }
[16:05:08.302]                           base::stop(msg)
[16:05:08.302]                         }
[16:05:08.302]                       })
[16:05:08.302]                     }
[16:05:08.302]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:08.302]                     base::options(mc.cores = 1L)
[16:05:08.302]                   }
[16:05:08.302]                   options(future.plan = NULL)
[16:05:08.302]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:08.302]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:08.302]                 }
[16:05:08.302]                 ...future.workdir <- getwd()
[16:05:08.302]             }
[16:05:08.302]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:08.302]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:08.302]         }
[16:05:08.302]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:08.302]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:08.302]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:08.302]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:08.302]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:08.302]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:08.302]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:08.302]             base::names(...future.oldOptions))
[16:05:08.302]     }
[16:05:08.302]     if (FALSE) {
[16:05:08.302]     }
[16:05:08.302]     else {
[16:05:08.302]         if (TRUE) {
[16:05:08.302]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:08.302]                 open = "w")
[16:05:08.302]         }
[16:05:08.302]         else {
[16:05:08.302]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:08.302]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:08.302]         }
[16:05:08.302]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:08.302]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:08.302]             base::sink(type = "output", split = FALSE)
[16:05:08.302]             base::close(...future.stdout)
[16:05:08.302]         }, add = TRUE)
[16:05:08.302]     }
[16:05:08.302]     ...future.frame <- base::sys.nframe()
[16:05:08.302]     ...future.conditions <- base::list()
[16:05:08.302]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:08.302]     if (FALSE) {
[16:05:08.302]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:08.302]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:08.302]     }
[16:05:08.302]     ...future.result <- base::tryCatch({
[16:05:08.302]         base::withCallingHandlers({
[16:05:08.302]             ...future.value <- base::withVisible(base::local({
[16:05:08.302]                 withCallingHandlers({
[16:05:08.302]                   {
[16:05:08.302]                     x <- x()
[16:05:08.302]                     x
[16:05:08.302]                   }
[16:05:08.302]                 }, immediateCondition = function(cond) {
[16:05:08.302]                   save_rds <- function (object, pathname, ...) 
[16:05:08.302]                   {
[16:05:08.302]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:08.302]                     if (file_test("-f", pathname_tmp)) {
[16:05:08.302]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.302]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:08.302]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.302]                         fi_tmp[["mtime"]])
[16:05:08.302]                     }
[16:05:08.302]                     tryCatch({
[16:05:08.302]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:08.302]                     }, error = function(ex) {
[16:05:08.302]                       msg <- conditionMessage(ex)
[16:05:08.302]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.302]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:08.302]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.302]                         fi_tmp[["mtime"]], msg)
[16:05:08.302]                       ex$message <- msg
[16:05:08.302]                       stop(ex)
[16:05:08.302]                     })
[16:05:08.302]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:08.302]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:08.302]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:08.302]                       fi_tmp <- file.info(pathname_tmp)
[16:05:08.302]                       fi <- file.info(pathname)
[16:05:08.302]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:08.302]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:08.302]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:08.302]                         fi[["size"]], fi[["mtime"]])
[16:05:08.302]                       stop(msg)
[16:05:08.302]                     }
[16:05:08.302]                     invisible(pathname)
[16:05:08.302]                   }
[16:05:08.302]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:08.302]                     rootPath = tempdir()) 
[16:05:08.302]                   {
[16:05:08.302]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:08.302]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:08.302]                       tmpdir = path, fileext = ".rds")
[16:05:08.302]                     save_rds(obj, file)
[16:05:08.302]                   }
[16:05:08.302]                   saveImmediateCondition(cond, path = "/tmp/RtmptZYwiJ/.future/immediateConditions")
[16:05:08.302]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.302]                   {
[16:05:08.302]                     inherits <- base::inherits
[16:05:08.302]                     invokeRestart <- base::invokeRestart
[16:05:08.302]                     is.null <- base::is.null
[16:05:08.302]                     muffled <- FALSE
[16:05:08.302]                     if (inherits(cond, "message")) {
[16:05:08.302]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:08.302]                       if (muffled) 
[16:05:08.302]                         invokeRestart("muffleMessage")
[16:05:08.302]                     }
[16:05:08.302]                     else if (inherits(cond, "warning")) {
[16:05:08.302]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:08.302]                       if (muffled) 
[16:05:08.302]                         invokeRestart("muffleWarning")
[16:05:08.302]                     }
[16:05:08.302]                     else if (inherits(cond, "condition")) {
[16:05:08.302]                       if (!is.null(pattern)) {
[16:05:08.302]                         computeRestarts <- base::computeRestarts
[16:05:08.302]                         grepl <- base::grepl
[16:05:08.302]                         restarts <- computeRestarts(cond)
[16:05:08.302]                         for (restart in restarts) {
[16:05:08.302]                           name <- restart$name
[16:05:08.302]                           if (is.null(name)) 
[16:05:08.302]                             next
[16:05:08.302]                           if (!grepl(pattern, name)) 
[16:05:08.302]                             next
[16:05:08.302]                           invokeRestart(restart)
[16:05:08.302]                           muffled <- TRUE
[16:05:08.302]                           break
[16:05:08.302]                         }
[16:05:08.302]                       }
[16:05:08.302]                     }
[16:05:08.302]                     invisible(muffled)
[16:05:08.302]                   }
[16:05:08.302]                   muffleCondition(cond)
[16:05:08.302]                 })
[16:05:08.302]             }))
[16:05:08.302]             future::FutureResult(value = ...future.value$value, 
[16:05:08.302]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:08.302]                   ...future.rng), globalenv = if (FALSE) 
[16:05:08.302]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:08.302]                     ...future.globalenv.names))
[16:05:08.302]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:08.302]         }, condition = base::local({
[16:05:08.302]             c <- base::c
[16:05:08.302]             inherits <- base::inherits
[16:05:08.302]             invokeRestart <- base::invokeRestart
[16:05:08.302]             length <- base::length
[16:05:08.302]             list <- base::list
[16:05:08.302]             seq.int <- base::seq.int
[16:05:08.302]             signalCondition <- base::signalCondition
[16:05:08.302]             sys.calls <- base::sys.calls
[16:05:08.302]             `[[` <- base::`[[`
[16:05:08.302]             `+` <- base::`+`
[16:05:08.302]             `<<-` <- base::`<<-`
[16:05:08.302]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:08.302]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:08.302]                   3L)]
[16:05:08.302]             }
[16:05:08.302]             function(cond) {
[16:05:08.302]                 is_error <- inherits(cond, "error")
[16:05:08.302]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:08.302]                   NULL)
[16:05:08.302]                 if (is_error) {
[16:05:08.302]                   sessionInformation <- function() {
[16:05:08.302]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:08.302]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:08.302]                       search = base::search(), system = base::Sys.info())
[16:05:08.302]                   }
[16:05:08.302]                   ...future.conditions[[length(...future.conditions) + 
[16:05:08.302]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:08.302]                     cond$call), session = sessionInformation(), 
[16:05:08.302]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:08.302]                   signalCondition(cond)
[16:05:08.302]                 }
[16:05:08.302]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:08.302]                 "immediateCondition"))) {
[16:05:08.302]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:08.302]                   ...future.conditions[[length(...future.conditions) + 
[16:05:08.302]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:08.302]                   if (TRUE && !signal) {
[16:05:08.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.302]                     {
[16:05:08.302]                       inherits <- base::inherits
[16:05:08.302]                       invokeRestart <- base::invokeRestart
[16:05:08.302]                       is.null <- base::is.null
[16:05:08.302]                       muffled <- FALSE
[16:05:08.302]                       if (inherits(cond, "message")) {
[16:05:08.302]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:08.302]                         if (muffled) 
[16:05:08.302]                           invokeRestart("muffleMessage")
[16:05:08.302]                       }
[16:05:08.302]                       else if (inherits(cond, "warning")) {
[16:05:08.302]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:08.302]                         if (muffled) 
[16:05:08.302]                           invokeRestart("muffleWarning")
[16:05:08.302]                       }
[16:05:08.302]                       else if (inherits(cond, "condition")) {
[16:05:08.302]                         if (!is.null(pattern)) {
[16:05:08.302]                           computeRestarts <- base::computeRestarts
[16:05:08.302]                           grepl <- base::grepl
[16:05:08.302]                           restarts <- computeRestarts(cond)
[16:05:08.302]                           for (restart in restarts) {
[16:05:08.302]                             name <- restart$name
[16:05:08.302]                             if (is.null(name)) 
[16:05:08.302]                               next
[16:05:08.302]                             if (!grepl(pattern, name)) 
[16:05:08.302]                               next
[16:05:08.302]                             invokeRestart(restart)
[16:05:08.302]                             muffled <- TRUE
[16:05:08.302]                             break
[16:05:08.302]                           }
[16:05:08.302]                         }
[16:05:08.302]                       }
[16:05:08.302]                       invisible(muffled)
[16:05:08.302]                     }
[16:05:08.302]                     muffleCondition(cond, pattern = "^muffle")
[16:05:08.302]                   }
[16:05:08.302]                 }
[16:05:08.302]                 else {
[16:05:08.302]                   if (TRUE) {
[16:05:08.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.302]                     {
[16:05:08.302]                       inherits <- base::inherits
[16:05:08.302]                       invokeRestart <- base::invokeRestart
[16:05:08.302]                       is.null <- base::is.null
[16:05:08.302]                       muffled <- FALSE
[16:05:08.302]                       if (inherits(cond, "message")) {
[16:05:08.302]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:08.302]                         if (muffled) 
[16:05:08.302]                           invokeRestart("muffleMessage")
[16:05:08.302]                       }
[16:05:08.302]                       else if (inherits(cond, "warning")) {
[16:05:08.302]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:08.302]                         if (muffled) 
[16:05:08.302]                           invokeRestart("muffleWarning")
[16:05:08.302]                       }
[16:05:08.302]                       else if (inherits(cond, "condition")) {
[16:05:08.302]                         if (!is.null(pattern)) {
[16:05:08.302]                           computeRestarts <- base::computeRestarts
[16:05:08.302]                           grepl <- base::grepl
[16:05:08.302]                           restarts <- computeRestarts(cond)
[16:05:08.302]                           for (restart in restarts) {
[16:05:08.302]                             name <- restart$name
[16:05:08.302]                             if (is.null(name)) 
[16:05:08.302]                               next
[16:05:08.302]                             if (!grepl(pattern, name)) 
[16:05:08.302]                               next
[16:05:08.302]                             invokeRestart(restart)
[16:05:08.302]                             muffled <- TRUE
[16:05:08.302]                             break
[16:05:08.302]                           }
[16:05:08.302]                         }
[16:05:08.302]                       }
[16:05:08.302]                       invisible(muffled)
[16:05:08.302]                     }
[16:05:08.302]                     muffleCondition(cond, pattern = "^muffle")
[16:05:08.302]                   }
[16:05:08.302]                 }
[16:05:08.302]             }
[16:05:08.302]         }))
[16:05:08.302]     }, error = function(ex) {
[16:05:08.302]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:08.302]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:08.302]                 ...future.rng), started = ...future.startTime, 
[16:05:08.302]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:08.302]             version = "1.8"), class = "FutureResult")
[16:05:08.302]     }, finally = {
[16:05:08.302]         if (!identical(...future.workdir, getwd())) 
[16:05:08.302]             setwd(...future.workdir)
[16:05:08.302]         {
[16:05:08.302]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:08.302]                 ...future.oldOptions$nwarnings <- NULL
[16:05:08.302]             }
[16:05:08.302]             base::options(...future.oldOptions)
[16:05:08.302]             if (.Platform$OS.type == "windows") {
[16:05:08.302]                 old_names <- names(...future.oldEnvVars)
[16:05:08.302]                 envs <- base::Sys.getenv()
[16:05:08.302]                 names <- names(envs)
[16:05:08.302]                 common <- intersect(names, old_names)
[16:05:08.302]                 added <- setdiff(names, old_names)
[16:05:08.302]                 removed <- setdiff(old_names, names)
[16:05:08.302]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:08.302]                   envs[common]]
[16:05:08.302]                 NAMES <- toupper(changed)
[16:05:08.302]                 args <- list()
[16:05:08.302]                 for (kk in seq_along(NAMES)) {
[16:05:08.302]                   name <- changed[[kk]]
[16:05:08.302]                   NAME <- NAMES[[kk]]
[16:05:08.302]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.302]                     next
[16:05:08.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:08.302]                 }
[16:05:08.302]                 NAMES <- toupper(added)
[16:05:08.302]                 for (kk in seq_along(NAMES)) {
[16:05:08.302]                   name <- added[[kk]]
[16:05:08.302]                   NAME <- NAMES[[kk]]
[16:05:08.302]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.302]                     next
[16:05:08.302]                   args[[name]] <- ""
[16:05:08.302]                 }
[16:05:08.302]                 NAMES <- toupper(removed)
[16:05:08.302]                 for (kk in seq_along(NAMES)) {
[16:05:08.302]                   name <- removed[[kk]]
[16:05:08.302]                   NAME <- NAMES[[kk]]
[16:05:08.302]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.302]                     next
[16:05:08.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:08.302]                 }
[16:05:08.302]                 if (length(args) > 0) 
[16:05:08.302]                   base::do.call(base::Sys.setenv, args = args)
[16:05:08.302]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:08.302]             }
[16:05:08.302]             else {
[16:05:08.302]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:08.302]             }
[16:05:08.302]             {
[16:05:08.302]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:08.302]                   0L) {
[16:05:08.302]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:08.302]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:08.302]                   base::options(opts)
[16:05:08.302]                 }
[16:05:08.302]                 {
[16:05:08.302]                   {
[16:05:08.302]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:08.302]                     NULL
[16:05:08.302]                   }
[16:05:08.302]                   options(future.plan = NULL)
[16:05:08.302]                   if (is.na(NA_character_)) 
[16:05:08.302]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:08.302]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:08.302]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:08.302]                     envir = parent.frame()) 
[16:05:08.302]                   {
[16:05:08.302]                     default_workers <- missing(workers)
[16:05:08.302]                     if (is.function(workers)) 
[16:05:08.302]                       workers <- workers()
[16:05:08.302]                     workers <- structure(as.integer(workers), 
[16:05:08.302]                       class = class(workers))
[16:05:08.302]                     stop_if_not(is.finite(workers), workers >= 
[16:05:08.302]                       1L)
[16:05:08.302]                     if ((workers == 1L && !inherits(workers, 
[16:05:08.302]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:08.302]                       if (default_workers) 
[16:05:08.302]                         supportsMulticore(warn = TRUE)
[16:05:08.302]                       return(sequential(..., envir = envir))
[16:05:08.302]                     }
[16:05:08.302]                     oopts <- options(mc.cores = workers)
[16:05:08.302]                     on.exit(options(oopts))
[16:05:08.302]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:08.302]                       envir = envir)
[16:05:08.302]                     if (!future$lazy) 
[16:05:08.302]                       future <- run(future)
[16:05:08.302]                     invisible(future)
[16:05:08.302]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:08.302]                 }
[16:05:08.302]             }
[16:05:08.302]         }
[16:05:08.302]     })
[16:05:08.302]     if (TRUE) {
[16:05:08.302]         base::sink(type = "output", split = FALSE)
[16:05:08.302]         if (TRUE) {
[16:05:08.302]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:08.302]         }
[16:05:08.302]         else {
[16:05:08.302]             ...future.result["stdout"] <- base::list(NULL)
[16:05:08.302]         }
[16:05:08.302]         base::close(...future.stdout)
[16:05:08.302]         ...future.stdout <- NULL
[16:05:08.302]     }
[16:05:08.302]     ...future.result$conditions <- ...future.conditions
[16:05:08.302]     ...future.result$finished <- base::Sys.time()
[16:05:08.302]     ...future.result
[16:05:08.302] }
[16:05:08.305] assign_globals() ...
[16:05:08.305] List of 1
[16:05:08.305]  $ x:function ()  
[16:05:08.305]  - attr(*, "where")=List of 1
[16:05:08.305]   ..$ x:<environment: R_EmptyEnv> 
[16:05:08.305]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:08.305]  - attr(*, "resolved")= logi TRUE
[16:05:08.305]  - attr(*, "total_size")= num 1032
[16:05:08.305]  - attr(*, "already-done")= logi TRUE
[16:05:08.310] - reassign environment for ‘x’
[16:05:08.310] - copied ‘x’ to environment
[16:05:08.311] assign_globals() ... done
[16:05:08.311] requestCore(): workers = 2
[16:05:08.313] MulticoreFuture started
[16:05:08.313] - Launch lazy future ... done
[16:05:08.313] run() for ‘MulticoreFuture’ ... done
[16:05:08.314] result() for MulticoreFuture ...
[16:05:08.314] plan(): Setting new future strategy stack:
[16:05:08.314] List of future strategies:
[16:05:08.314] 1. sequential:
[16:05:08.314]    - args: function (..., envir = parent.frame())
[16:05:08.314]    - tweaked: FALSE
[16:05:08.314]    - call: NULL
[16:05:08.315] plan(): nbrOfWorkers() = 1
[16:05:08.318] plan(): Setting new future strategy stack:
[16:05:08.319] List of future strategies:
[16:05:08.319] 1. multicore:
[16:05:08.319]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:08.319]    - tweaked: FALSE
[16:05:08.319]    - call: plan(strategy)
[16:05:08.326] plan(): nbrOfWorkers() = 2
[16:05:08.327] result() for MulticoreFuture ...
[16:05:08.327] result() for MulticoreFuture ... done
[16:05:08.327] result() for MulticoreFuture ... done
[16:05:08.327] result() for MulticoreFuture ...
[16:05:08.328] result() for MulticoreFuture ... done
value(f) = ‘TRUE’
- plan('multisession') ...
[16:05:08.329] plan(): Setting new future strategy stack:
[16:05:08.329] List of future strategies:
[16:05:08.329] 1. multisession:
[16:05:08.329]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:08.329]    - tweaked: FALSE
[16:05:08.329]    - call: plan(strategy)
[16:05:08.330] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:05:08.330] multisession:
[16:05:08.330] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:08.330] - tweaked: FALSE
[16:05:08.330] - call: plan(strategy)
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:08.337] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:08.337] Not searching for globals
[16:05:08.338] - globals: [0] <none>
[16:05:08.338] getGlobalsAndPackages() ... DONE
[16:05:08.339] [local output] makeClusterPSOCK() ...
[16:05:08.383] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:05:08.384] [local output] Base port: 11442
[16:05:08.384] [local output] Getting setup options for 2 cluster nodes ...
[16:05:08.384] [local output]  - Node 1 of 2 ...
[16:05:08.385] [local output] localMachine=TRUE => revtunnel=FALSE

[16:05:08.386] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmptZYwiJ/worker.rank=1.parallelly.parent=86202.150bad890957.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmptZYwiJ/worker.rank=1.parallelly.parent=86202.150bad890957.pid")'’
[16:05:08.573] - Possible to infer worker's PID: TRUE
[16:05:08.573] [local output] Rscript port: 11442

[16:05:08.573] [local output]  - Node 2 of 2 ...
[16:05:08.574] [local output] localMachine=TRUE => revtunnel=FALSE

[16:05:08.574] [local output] Rscript port: 11442

[16:05:08.575] [local output] Getting setup options for 2 cluster nodes ... done
[16:05:08.575] [local output]  - Parallel setup requested for some PSOCK nodes
[16:05:08.575] [local output] Setting up PSOCK nodes in parallel
[16:05:08.576] List of 36
[16:05:08.576]  $ worker          : chr "localhost"
[16:05:08.576]   ..- attr(*, "localhost")= logi TRUE
[16:05:08.576]  $ master          : chr "localhost"
[16:05:08.576]  $ port            : int 11442
[16:05:08.576]  $ connectTimeout  : num 120
[16:05:08.576]  $ timeout         : num 2592000
[16:05:08.576]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:05:08.576]  $ homogeneous     : logi TRUE
[16:05:08.576]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:05:08.576]  $ rscript_envs    : NULL
[16:05:08.576]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:05:08.576]  $ rscript_startup : NULL
[16:05:08.576]  $ rscript_sh      : chr "sh"
[16:05:08.576]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:05:08.576]  $ methods         : logi TRUE
[16:05:08.576]  $ socketOptions   : chr "no-delay"
[16:05:08.576]  $ useXDR          : logi FALSE
[16:05:08.576]  $ outfile         : chr "/dev/null"
[16:05:08.576]  $ renice          : int NA
[16:05:08.576]  $ rshcmd          : NULL
[16:05:08.576]  $ user            : chr(0) 
[16:05:08.576]  $ revtunnel       : logi FALSE
[16:05:08.576]  $ rshlogfile      : NULL
[16:05:08.576]  $ rshopts         : chr(0) 
[16:05:08.576]  $ rank            : int 1
[16:05:08.576]  $ manual          : logi FALSE
[16:05:08.576]  $ dryrun          : logi FALSE
[16:05:08.576]  $ quiet           : logi FALSE
[16:05:08.576]  $ setup_strategy  : chr "parallel"
[16:05:08.576]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:05:08.576]  $ pidfile         : chr "/tmp/RtmptZYwiJ/worker.rank=1.parallelly.parent=86202.150bad890957.pid"
[16:05:08.576]  $ rshcmd_label    : NULL
[16:05:08.576]  $ rsh_call        : NULL
[16:05:08.576]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:05:08.576]  $ localMachine    : logi TRUE
[16:05:08.576]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:05:08.576]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:05:08.576]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:05:08.576]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:05:08.576]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:05:08.576]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:05:08.576]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:05:08.576]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:05:08.576]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:05:08.576]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:05:08.576]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:05:08.576]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:05:08.576]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:05:08.576]  $ arguments       :List of 28
[16:05:08.576]   ..$ worker          : chr "localhost"
[16:05:08.576]   ..$ master          : NULL
[16:05:08.576]   ..$ port            : int 11442
[16:05:08.576]   ..$ connectTimeout  : num 120
[16:05:08.576]   ..$ timeout         : num 2592000
[16:05:08.576]   ..$ rscript         : NULL
[16:05:08.576]   ..$ homogeneous     : NULL
[16:05:08.576]   ..$ rscript_args    : NULL
[16:05:08.576]   ..$ rscript_envs    : NULL
[16:05:08.576]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:05:08.576]   ..$ rscript_startup : NULL
[16:05:08.576]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:05:08.576]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:05:08.576]   ..$ methods         : logi TRUE
[16:05:08.576]   ..$ socketOptions   : chr "no-delay"
[16:05:08.576]   ..$ useXDR          : logi FALSE
[16:05:08.576]   ..$ outfile         : chr "/dev/null"
[16:05:08.576]   ..$ renice          : int NA
[16:05:08.576]   ..$ rshcmd          : NULL
[16:05:08.576]   ..$ user            : NULL
[16:05:08.576]   ..$ revtunnel       : logi NA
[16:05:08.576]   ..$ rshlogfile      : NULL
[16:05:08.576]   ..$ rshopts         : NULL
[16:05:08.576]   ..$ rank            : int 1
[16:05:08.576]   ..$ manual          : logi FALSE
[16:05:08.576]   ..$ dryrun          : logi FALSE
[16:05:08.576]   ..$ quiet           : logi FALSE
[16:05:08.576]   ..$ setup_strategy  : chr "parallel"
[16:05:08.576]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:05:08.593] [local output] System call to launch all workers:
[16:05:08.593] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmptZYwiJ/worker.rank=1.parallelly.parent=86202.150bad890957.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11442 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:05:08.593] [local output] Starting PSOCK main server
[16:05:08.598] [local output] Workers launched
[16:05:08.599] [local output] Waiting for workers to connect back
[16:05:08.599]  - [local output] 0 workers out of 2 ready
[16:05:08.833]  - [local output] 0 workers out of 2 ready
[16:05:08.833]  - [local output] 1 workers out of 2 ready
[16:05:08.866]  - [local output] 1 workers out of 2 ready
[16:05:08.866]  - [local output] 2 workers out of 2 ready
[16:05:08.867] [local output] Launching of workers completed
[16:05:08.867] [local output] Collecting session information from workers
[16:05:08.868] [local output]  - Worker #1 of 2
[16:05:08.868] [local output]  - Worker #2 of 2
[16:05:08.869] [local output] makeClusterPSOCK() ... done
[16:05:08.880] Packages needed by the future expression (n = 0): <none>
[16:05:08.880] Packages needed by future strategies (n = 0): <none>
[16:05:08.881] {
[16:05:08.881]     {
[16:05:08.881]         {
[16:05:08.881]             ...future.startTime <- base::Sys.time()
[16:05:08.881]             {
[16:05:08.881]                 {
[16:05:08.881]                   {
[16:05:08.881]                     {
[16:05:08.881]                       base::local({
[16:05:08.881]                         has_future <- base::requireNamespace("future", 
[16:05:08.881]                           quietly = TRUE)
[16:05:08.881]                         if (has_future) {
[16:05:08.881]                           ns <- base::getNamespace("future")
[16:05:08.881]                           version <- ns[[".package"]][["version"]]
[16:05:08.881]                           if (is.null(version)) 
[16:05:08.881]                             version <- utils::packageVersion("future")
[16:05:08.881]                         }
[16:05:08.881]                         else {
[16:05:08.881]                           version <- NULL
[16:05:08.881]                         }
[16:05:08.881]                         if (!has_future || version < "1.8.0") {
[16:05:08.881]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:08.881]                             "", base::R.version$version.string), 
[16:05:08.881]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:08.881]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:08.881]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:08.881]                               "release", "version")], collapse = " "), 
[16:05:08.881]                             hostname = base::Sys.info()[["nodename"]])
[16:05:08.881]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:08.881]                             info)
[16:05:08.881]                           info <- base::paste(info, collapse = "; ")
[16:05:08.881]                           if (!has_future) {
[16:05:08.881]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:08.881]                               info)
[16:05:08.881]                           }
[16:05:08.881]                           else {
[16:05:08.881]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:08.881]                               info, version)
[16:05:08.881]                           }
[16:05:08.881]                           base::stop(msg)
[16:05:08.881]                         }
[16:05:08.881]                       })
[16:05:08.881]                     }
[16:05:08.881]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:08.881]                     base::options(mc.cores = 1L)
[16:05:08.881]                   }
[16:05:08.881]                   options(future.plan = NULL)
[16:05:08.881]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:08.881]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:08.881]                 }
[16:05:08.881]                 ...future.workdir <- getwd()
[16:05:08.881]             }
[16:05:08.881]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:08.881]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:08.881]         }
[16:05:08.881]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:08.881]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:08.881]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:08.881]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:08.881]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:08.881]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:08.881]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:08.881]             base::names(...future.oldOptions))
[16:05:08.881]     }
[16:05:08.881]     if (FALSE) {
[16:05:08.881]     }
[16:05:08.881]     else {
[16:05:08.881]         if (TRUE) {
[16:05:08.881]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:08.881]                 open = "w")
[16:05:08.881]         }
[16:05:08.881]         else {
[16:05:08.881]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:08.881]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:08.881]         }
[16:05:08.881]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:08.881]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:08.881]             base::sink(type = "output", split = FALSE)
[16:05:08.881]             base::close(...future.stdout)
[16:05:08.881]         }, add = TRUE)
[16:05:08.881]     }
[16:05:08.881]     ...future.frame <- base::sys.nframe()
[16:05:08.881]     ...future.conditions <- base::list()
[16:05:08.881]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:08.881]     if (FALSE) {
[16:05:08.881]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:08.881]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:08.881]     }
[16:05:08.881]     ...future.result <- base::tryCatch({
[16:05:08.881]         base::withCallingHandlers({
[16:05:08.881]             ...future.value <- base::withVisible(base::local({
[16:05:08.881]                 ...future.makeSendCondition <- base::local({
[16:05:08.881]                   sendCondition <- NULL
[16:05:08.881]                   function(frame = 1L) {
[16:05:08.881]                     if (is.function(sendCondition)) 
[16:05:08.881]                       return(sendCondition)
[16:05:08.881]                     ns <- getNamespace("parallel")
[16:05:08.881]                     if (exists("sendData", mode = "function", 
[16:05:08.881]                       envir = ns)) {
[16:05:08.881]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:08.881]                         envir = ns)
[16:05:08.881]                       envir <- sys.frame(frame)
[16:05:08.881]                       master <- NULL
[16:05:08.881]                       while (!identical(envir, .GlobalEnv) && 
[16:05:08.881]                         !identical(envir, emptyenv())) {
[16:05:08.881]                         if (exists("master", mode = "list", envir = envir, 
[16:05:08.881]                           inherits = FALSE)) {
[16:05:08.881]                           master <- get("master", mode = "list", 
[16:05:08.881]                             envir = envir, inherits = FALSE)
[16:05:08.881]                           if (inherits(master, c("SOCKnode", 
[16:05:08.881]                             "SOCK0node"))) {
[16:05:08.881]                             sendCondition <<- function(cond) {
[16:05:08.881]                               data <- list(type = "VALUE", value = cond, 
[16:05:08.881]                                 success = TRUE)
[16:05:08.881]                               parallel_sendData(master, data)
[16:05:08.881]                             }
[16:05:08.881]                             return(sendCondition)
[16:05:08.881]                           }
[16:05:08.881]                         }
[16:05:08.881]                         frame <- frame + 1L
[16:05:08.881]                         envir <- sys.frame(frame)
[16:05:08.881]                       }
[16:05:08.881]                     }
[16:05:08.881]                     sendCondition <<- function(cond) NULL
[16:05:08.881]                   }
[16:05:08.881]                 })
[16:05:08.881]                 withCallingHandlers({
[16:05:08.881]                   NA
[16:05:08.881]                 }, immediateCondition = function(cond) {
[16:05:08.881]                   sendCondition <- ...future.makeSendCondition()
[16:05:08.881]                   sendCondition(cond)
[16:05:08.881]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.881]                   {
[16:05:08.881]                     inherits <- base::inherits
[16:05:08.881]                     invokeRestart <- base::invokeRestart
[16:05:08.881]                     is.null <- base::is.null
[16:05:08.881]                     muffled <- FALSE
[16:05:08.881]                     if (inherits(cond, "message")) {
[16:05:08.881]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:08.881]                       if (muffled) 
[16:05:08.881]                         invokeRestart("muffleMessage")
[16:05:08.881]                     }
[16:05:08.881]                     else if (inherits(cond, "warning")) {
[16:05:08.881]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:08.881]                       if (muffled) 
[16:05:08.881]                         invokeRestart("muffleWarning")
[16:05:08.881]                     }
[16:05:08.881]                     else if (inherits(cond, "condition")) {
[16:05:08.881]                       if (!is.null(pattern)) {
[16:05:08.881]                         computeRestarts <- base::computeRestarts
[16:05:08.881]                         grepl <- base::grepl
[16:05:08.881]                         restarts <- computeRestarts(cond)
[16:05:08.881]                         for (restart in restarts) {
[16:05:08.881]                           name <- restart$name
[16:05:08.881]                           if (is.null(name)) 
[16:05:08.881]                             next
[16:05:08.881]                           if (!grepl(pattern, name)) 
[16:05:08.881]                             next
[16:05:08.881]                           invokeRestart(restart)
[16:05:08.881]                           muffled <- TRUE
[16:05:08.881]                           break
[16:05:08.881]                         }
[16:05:08.881]                       }
[16:05:08.881]                     }
[16:05:08.881]                     invisible(muffled)
[16:05:08.881]                   }
[16:05:08.881]                   muffleCondition(cond)
[16:05:08.881]                 })
[16:05:08.881]             }))
[16:05:08.881]             future::FutureResult(value = ...future.value$value, 
[16:05:08.881]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:08.881]                   ...future.rng), globalenv = if (FALSE) 
[16:05:08.881]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:08.881]                     ...future.globalenv.names))
[16:05:08.881]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:08.881]         }, condition = base::local({
[16:05:08.881]             c <- base::c
[16:05:08.881]             inherits <- base::inherits
[16:05:08.881]             invokeRestart <- base::invokeRestart
[16:05:08.881]             length <- base::length
[16:05:08.881]             list <- base::list
[16:05:08.881]             seq.int <- base::seq.int
[16:05:08.881]             signalCondition <- base::signalCondition
[16:05:08.881]             sys.calls <- base::sys.calls
[16:05:08.881]             `[[` <- base::`[[`
[16:05:08.881]             `+` <- base::`+`
[16:05:08.881]             `<<-` <- base::`<<-`
[16:05:08.881]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:08.881]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:08.881]                   3L)]
[16:05:08.881]             }
[16:05:08.881]             function(cond) {
[16:05:08.881]                 is_error <- inherits(cond, "error")
[16:05:08.881]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:08.881]                   NULL)
[16:05:08.881]                 if (is_error) {
[16:05:08.881]                   sessionInformation <- function() {
[16:05:08.881]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:08.881]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:08.881]                       search = base::search(), system = base::Sys.info())
[16:05:08.881]                   }
[16:05:08.881]                   ...future.conditions[[length(...future.conditions) + 
[16:05:08.881]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:08.881]                     cond$call), session = sessionInformation(), 
[16:05:08.881]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:08.881]                   signalCondition(cond)
[16:05:08.881]                 }
[16:05:08.881]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:08.881]                 "immediateCondition"))) {
[16:05:08.881]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:08.881]                   ...future.conditions[[length(...future.conditions) + 
[16:05:08.881]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:08.881]                   if (TRUE && !signal) {
[16:05:08.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.881]                     {
[16:05:08.881]                       inherits <- base::inherits
[16:05:08.881]                       invokeRestart <- base::invokeRestart
[16:05:08.881]                       is.null <- base::is.null
[16:05:08.881]                       muffled <- FALSE
[16:05:08.881]                       if (inherits(cond, "message")) {
[16:05:08.881]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:08.881]                         if (muffled) 
[16:05:08.881]                           invokeRestart("muffleMessage")
[16:05:08.881]                       }
[16:05:08.881]                       else if (inherits(cond, "warning")) {
[16:05:08.881]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:08.881]                         if (muffled) 
[16:05:08.881]                           invokeRestart("muffleWarning")
[16:05:08.881]                       }
[16:05:08.881]                       else if (inherits(cond, "condition")) {
[16:05:08.881]                         if (!is.null(pattern)) {
[16:05:08.881]                           computeRestarts <- base::computeRestarts
[16:05:08.881]                           grepl <- base::grepl
[16:05:08.881]                           restarts <- computeRestarts(cond)
[16:05:08.881]                           for (restart in restarts) {
[16:05:08.881]                             name <- restart$name
[16:05:08.881]                             if (is.null(name)) 
[16:05:08.881]                               next
[16:05:08.881]                             if (!grepl(pattern, name)) 
[16:05:08.881]                               next
[16:05:08.881]                             invokeRestart(restart)
[16:05:08.881]                             muffled <- TRUE
[16:05:08.881]                             break
[16:05:08.881]                           }
[16:05:08.881]                         }
[16:05:08.881]                       }
[16:05:08.881]                       invisible(muffled)
[16:05:08.881]                     }
[16:05:08.881]                     muffleCondition(cond, pattern = "^muffle")
[16:05:08.881]                   }
[16:05:08.881]                 }
[16:05:08.881]                 else {
[16:05:08.881]                   if (TRUE) {
[16:05:08.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:08.881]                     {
[16:05:08.881]                       inherits <- base::inherits
[16:05:08.881]                       invokeRestart <- base::invokeRestart
[16:05:08.881]                       is.null <- base::is.null
[16:05:08.881]                       muffled <- FALSE
[16:05:08.881]                       if (inherits(cond, "message")) {
[16:05:08.881]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:08.881]                         if (muffled) 
[16:05:08.881]                           invokeRestart("muffleMessage")
[16:05:08.881]                       }
[16:05:08.881]                       else if (inherits(cond, "warning")) {
[16:05:08.881]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:08.881]                         if (muffled) 
[16:05:08.881]                           invokeRestart("muffleWarning")
[16:05:08.881]                       }
[16:05:08.881]                       else if (inherits(cond, "condition")) {
[16:05:08.881]                         if (!is.null(pattern)) {
[16:05:08.881]                           computeRestarts <- base::computeRestarts
[16:05:08.881]                           grepl <- base::grepl
[16:05:08.881]                           restarts <- computeRestarts(cond)
[16:05:08.881]                           for (restart in restarts) {
[16:05:08.881]                             name <- restart$name
[16:05:08.881]                             if (is.null(name)) 
[16:05:08.881]                               next
[16:05:08.881]                             if (!grepl(pattern, name)) 
[16:05:08.881]                               next
[16:05:08.881]                             invokeRestart(restart)
[16:05:08.881]                             muffled <- TRUE
[16:05:08.881]                             break
[16:05:08.881]                           }
[16:05:08.881]                         }
[16:05:08.881]                       }
[16:05:08.881]                       invisible(muffled)
[16:05:08.881]                     }
[16:05:08.881]                     muffleCondition(cond, pattern = "^muffle")
[16:05:08.881]                   }
[16:05:08.881]                 }
[16:05:08.881]             }
[16:05:08.881]         }))
[16:05:08.881]     }, error = function(ex) {
[16:05:08.881]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:08.881]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:08.881]                 ...future.rng), started = ...future.startTime, 
[16:05:08.881]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:08.881]             version = "1.8"), class = "FutureResult")
[16:05:08.881]     }, finally = {
[16:05:08.881]         if (!identical(...future.workdir, getwd())) 
[16:05:08.881]             setwd(...future.workdir)
[16:05:08.881]         {
[16:05:08.881]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:08.881]                 ...future.oldOptions$nwarnings <- NULL
[16:05:08.881]             }
[16:05:08.881]             base::options(...future.oldOptions)
[16:05:08.881]             if (.Platform$OS.type == "windows") {
[16:05:08.881]                 old_names <- names(...future.oldEnvVars)
[16:05:08.881]                 envs <- base::Sys.getenv()
[16:05:08.881]                 names <- names(envs)
[16:05:08.881]                 common <- intersect(names, old_names)
[16:05:08.881]                 added <- setdiff(names, old_names)
[16:05:08.881]                 removed <- setdiff(old_names, names)
[16:05:08.881]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:08.881]                   envs[common]]
[16:05:08.881]                 NAMES <- toupper(changed)
[16:05:08.881]                 args <- list()
[16:05:08.881]                 for (kk in seq_along(NAMES)) {
[16:05:08.881]                   name <- changed[[kk]]
[16:05:08.881]                   NAME <- NAMES[[kk]]
[16:05:08.881]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.881]                     next
[16:05:08.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:08.881]                 }
[16:05:08.881]                 NAMES <- toupper(added)
[16:05:08.881]                 for (kk in seq_along(NAMES)) {
[16:05:08.881]                   name <- added[[kk]]
[16:05:08.881]                   NAME <- NAMES[[kk]]
[16:05:08.881]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.881]                     next
[16:05:08.881]                   args[[name]] <- ""
[16:05:08.881]                 }
[16:05:08.881]                 NAMES <- toupper(removed)
[16:05:08.881]                 for (kk in seq_along(NAMES)) {
[16:05:08.881]                   name <- removed[[kk]]
[16:05:08.881]                   NAME <- NAMES[[kk]]
[16:05:08.881]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:08.881]                     next
[16:05:08.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:08.881]                 }
[16:05:08.881]                 if (length(args) > 0) 
[16:05:08.881]                   base::do.call(base::Sys.setenv, args = args)
[16:05:08.881]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:08.881]             }
[16:05:08.881]             else {
[16:05:08.881]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:08.881]             }
[16:05:08.881]             {
[16:05:08.881]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:08.881]                   0L) {
[16:05:08.881]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:08.881]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:08.881]                   base::options(opts)
[16:05:08.881]                 }
[16:05:08.881]                 {
[16:05:08.881]                   {
[16:05:08.881]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:08.881]                     NULL
[16:05:08.881]                   }
[16:05:08.881]                   options(future.plan = NULL)
[16:05:08.881]                   if (is.na(NA_character_)) 
[16:05:08.881]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:08.881]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:08.881]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:08.881]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:08.881]                     envir = parent.frame()) 
[16:05:08.881]                   {
[16:05:08.881]                     if (is.function(workers)) 
[16:05:08.881]                       workers <- workers()
[16:05:08.881]                     workers <- structure(as.integer(workers), 
[16:05:08.881]                       class = class(workers))
[16:05:08.881]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:08.881]                       workers >= 1)
[16:05:08.881]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:08.881]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:08.881]                     }
[16:05:08.881]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:08.881]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:08.881]                       envir = envir)
[16:05:08.881]                     if (!future$lazy) 
[16:05:08.881]                       future <- run(future)
[16:05:08.881]                     invisible(future)
[16:05:08.881]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:08.881]                 }
[16:05:08.881]             }
[16:05:08.881]         }
[16:05:08.881]     })
[16:05:08.881]     if (TRUE) {
[16:05:08.881]         base::sink(type = "output", split = FALSE)
[16:05:08.881]         if (TRUE) {
[16:05:08.881]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:08.881]         }
[16:05:08.881]         else {
[16:05:08.881]             ...future.result["stdout"] <- base::list(NULL)
[16:05:08.881]         }
[16:05:08.881]         base::close(...future.stdout)
[16:05:08.881]         ...future.stdout <- NULL
[16:05:08.881]     }
[16:05:08.881]     ...future.result$conditions <- ...future.conditions
[16:05:08.881]     ...future.result$finished <- base::Sys.time()
[16:05:08.881]     ...future.result
[16:05:08.881] }
[16:05:08.937] MultisessionFuture started
[16:05:08.937] result() for ClusterFuture ...
[16:05:08.938] receiveMessageFromWorker() for ClusterFuture ...
[16:05:08.938] - Validating connection of MultisessionFuture
[16:05:08.988] - received message: FutureResult
[16:05:08.988] - Received FutureResult
[16:05:08.988] - Erased future from FutureRegistry
[16:05:08.988] result() for ClusterFuture ...
[16:05:08.989] - result already collected: FutureResult
[16:05:08.989] result() for ClusterFuture ... done
[16:05:08.989] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:08.989] result() for ClusterFuture ... done
[16:05:08.989] result() for ClusterFuture ...
[16:05:08.989] - result already collected: FutureResult
[16:05:08.989] result() for ClusterFuture ... done
[16:05:08.989] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:05:08.993] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:08.993] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:08.994] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:08.995] - globals found: [3] ‘{’, ‘<-’, ‘*’
[16:05:08.995] Searching for globals ... DONE
[16:05:08.995] Resolving globals: TRUE
[16:05:08.996] Resolving any globals that are futures ...
[16:05:08.996] - globals: [3] ‘{’, ‘<-’, ‘*’
[16:05:08.996] Resolving any globals that are futures ... DONE
[16:05:08.996] 
[16:05:08.996] 
[16:05:08.996] getGlobalsAndPackages() ... DONE
[16:05:08.997] run() for ‘Future’ ...
[16:05:08.997] - state: ‘created’
[16:05:08.997] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:09.012] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:09.012] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:09.012]   - Field: ‘node’
[16:05:09.012]   - Field: ‘label’
[16:05:09.012]   - Field: ‘local’
[16:05:09.012]   - Field: ‘owner’
[16:05:09.012]   - Field: ‘envir’
[16:05:09.012]   - Field: ‘workers’
[16:05:09.012]   - Field: ‘packages’
[16:05:09.013]   - Field: ‘gc’
[16:05:09.013]   - Field: ‘conditions’
[16:05:09.013]   - Field: ‘persistent’
[16:05:09.013]   - Field: ‘expr’
[16:05:09.013]   - Field: ‘uuid’
[16:05:09.013]   - Field: ‘seed’
[16:05:09.013]   - Field: ‘version’
[16:05:09.013]   - Field: ‘result’
[16:05:09.013]   - Field: ‘asynchronous’
[16:05:09.014]   - Field: ‘calls’
[16:05:09.014]   - Field: ‘globals’
[16:05:09.014]   - Field: ‘stdout’
[16:05:09.014]   - Field: ‘earlySignal’
[16:05:09.014]   - Field: ‘lazy’
[16:05:09.014]   - Field: ‘state’
[16:05:09.014] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:09.014] - Launch lazy future ...
[16:05:09.015] Packages needed by the future expression (n = 0): <none>
[16:05:09.015] Packages needed by future strategies (n = 0): <none>
[16:05:09.015] {
[16:05:09.015]     {
[16:05:09.015]         {
[16:05:09.015]             ...future.startTime <- base::Sys.time()
[16:05:09.015]             {
[16:05:09.015]                 {
[16:05:09.015]                   {
[16:05:09.015]                     {
[16:05:09.015]                       base::local({
[16:05:09.015]                         has_future <- base::requireNamespace("future", 
[16:05:09.015]                           quietly = TRUE)
[16:05:09.015]                         if (has_future) {
[16:05:09.015]                           ns <- base::getNamespace("future")
[16:05:09.015]                           version <- ns[[".package"]][["version"]]
[16:05:09.015]                           if (is.null(version)) 
[16:05:09.015]                             version <- utils::packageVersion("future")
[16:05:09.015]                         }
[16:05:09.015]                         else {
[16:05:09.015]                           version <- NULL
[16:05:09.015]                         }
[16:05:09.015]                         if (!has_future || version < "1.8.0") {
[16:05:09.015]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:09.015]                             "", base::R.version$version.string), 
[16:05:09.015]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:09.015]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:09.015]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:09.015]                               "release", "version")], collapse = " "), 
[16:05:09.015]                             hostname = base::Sys.info()[["nodename"]])
[16:05:09.015]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:09.015]                             info)
[16:05:09.015]                           info <- base::paste(info, collapse = "; ")
[16:05:09.015]                           if (!has_future) {
[16:05:09.015]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:09.015]                               info)
[16:05:09.015]                           }
[16:05:09.015]                           else {
[16:05:09.015]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:09.015]                               info, version)
[16:05:09.015]                           }
[16:05:09.015]                           base::stop(msg)
[16:05:09.015]                         }
[16:05:09.015]                       })
[16:05:09.015]                     }
[16:05:09.015]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:09.015]                     base::options(mc.cores = 1L)
[16:05:09.015]                   }
[16:05:09.015]                   options(future.plan = NULL)
[16:05:09.015]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.015]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:09.015]                 }
[16:05:09.015]                 ...future.workdir <- getwd()
[16:05:09.015]             }
[16:05:09.015]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:09.015]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:09.015]         }
[16:05:09.015]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:09.015]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:09.015]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:09.015]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:09.015]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:09.015]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:09.015]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:09.015]             base::names(...future.oldOptions))
[16:05:09.015]     }
[16:05:09.015]     if (FALSE) {
[16:05:09.015]     }
[16:05:09.015]     else {
[16:05:09.015]         if (TRUE) {
[16:05:09.015]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:09.015]                 open = "w")
[16:05:09.015]         }
[16:05:09.015]         else {
[16:05:09.015]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:09.015]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:09.015]         }
[16:05:09.015]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:09.015]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:09.015]             base::sink(type = "output", split = FALSE)
[16:05:09.015]             base::close(...future.stdout)
[16:05:09.015]         }, add = TRUE)
[16:05:09.015]     }
[16:05:09.015]     ...future.frame <- base::sys.nframe()
[16:05:09.015]     ...future.conditions <- base::list()
[16:05:09.015]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:09.015]     if (FALSE) {
[16:05:09.015]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:09.015]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:09.015]     }
[16:05:09.015]     ...future.result <- base::tryCatch({
[16:05:09.015]         base::withCallingHandlers({
[16:05:09.015]             ...future.value <- base::withVisible(base::local({
[16:05:09.015]                 ...future.makeSendCondition <- base::local({
[16:05:09.015]                   sendCondition <- NULL
[16:05:09.015]                   function(frame = 1L) {
[16:05:09.015]                     if (is.function(sendCondition)) 
[16:05:09.015]                       return(sendCondition)
[16:05:09.015]                     ns <- getNamespace("parallel")
[16:05:09.015]                     if (exists("sendData", mode = "function", 
[16:05:09.015]                       envir = ns)) {
[16:05:09.015]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:09.015]                         envir = ns)
[16:05:09.015]                       envir <- sys.frame(frame)
[16:05:09.015]                       master <- NULL
[16:05:09.015]                       while (!identical(envir, .GlobalEnv) && 
[16:05:09.015]                         !identical(envir, emptyenv())) {
[16:05:09.015]                         if (exists("master", mode = "list", envir = envir, 
[16:05:09.015]                           inherits = FALSE)) {
[16:05:09.015]                           master <- get("master", mode = "list", 
[16:05:09.015]                             envir = envir, inherits = FALSE)
[16:05:09.015]                           if (inherits(master, c("SOCKnode", 
[16:05:09.015]                             "SOCK0node"))) {
[16:05:09.015]                             sendCondition <<- function(cond) {
[16:05:09.015]                               data <- list(type = "VALUE", value = cond, 
[16:05:09.015]                                 success = TRUE)
[16:05:09.015]                               parallel_sendData(master, data)
[16:05:09.015]                             }
[16:05:09.015]                             return(sendCondition)
[16:05:09.015]                           }
[16:05:09.015]                         }
[16:05:09.015]                         frame <- frame + 1L
[16:05:09.015]                         envir <- sys.frame(frame)
[16:05:09.015]                       }
[16:05:09.015]                     }
[16:05:09.015]                     sendCondition <<- function(cond) NULL
[16:05:09.015]                   }
[16:05:09.015]                 })
[16:05:09.015]                 withCallingHandlers({
[16:05:09.015]                   {
[16:05:09.015]                     b <- a
[16:05:09.015]                     a <- 2
[16:05:09.015]                     a * b
[16:05:09.015]                   }
[16:05:09.015]                 }, immediateCondition = function(cond) {
[16:05:09.015]                   sendCondition <- ...future.makeSendCondition()
[16:05:09.015]                   sendCondition(cond)
[16:05:09.015]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.015]                   {
[16:05:09.015]                     inherits <- base::inherits
[16:05:09.015]                     invokeRestart <- base::invokeRestart
[16:05:09.015]                     is.null <- base::is.null
[16:05:09.015]                     muffled <- FALSE
[16:05:09.015]                     if (inherits(cond, "message")) {
[16:05:09.015]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:09.015]                       if (muffled) 
[16:05:09.015]                         invokeRestart("muffleMessage")
[16:05:09.015]                     }
[16:05:09.015]                     else if (inherits(cond, "warning")) {
[16:05:09.015]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:09.015]                       if (muffled) 
[16:05:09.015]                         invokeRestart("muffleWarning")
[16:05:09.015]                     }
[16:05:09.015]                     else if (inherits(cond, "condition")) {
[16:05:09.015]                       if (!is.null(pattern)) {
[16:05:09.015]                         computeRestarts <- base::computeRestarts
[16:05:09.015]                         grepl <- base::grepl
[16:05:09.015]                         restarts <- computeRestarts(cond)
[16:05:09.015]                         for (restart in restarts) {
[16:05:09.015]                           name <- restart$name
[16:05:09.015]                           if (is.null(name)) 
[16:05:09.015]                             next
[16:05:09.015]                           if (!grepl(pattern, name)) 
[16:05:09.015]                             next
[16:05:09.015]                           invokeRestart(restart)
[16:05:09.015]                           muffled <- TRUE
[16:05:09.015]                           break
[16:05:09.015]                         }
[16:05:09.015]                       }
[16:05:09.015]                     }
[16:05:09.015]                     invisible(muffled)
[16:05:09.015]                   }
[16:05:09.015]                   muffleCondition(cond)
[16:05:09.015]                 })
[16:05:09.015]             }))
[16:05:09.015]             future::FutureResult(value = ...future.value$value, 
[16:05:09.015]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.015]                   ...future.rng), globalenv = if (FALSE) 
[16:05:09.015]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:09.015]                     ...future.globalenv.names))
[16:05:09.015]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:09.015]         }, condition = base::local({
[16:05:09.015]             c <- base::c
[16:05:09.015]             inherits <- base::inherits
[16:05:09.015]             invokeRestart <- base::invokeRestart
[16:05:09.015]             length <- base::length
[16:05:09.015]             list <- base::list
[16:05:09.015]             seq.int <- base::seq.int
[16:05:09.015]             signalCondition <- base::signalCondition
[16:05:09.015]             sys.calls <- base::sys.calls
[16:05:09.015]             `[[` <- base::`[[`
[16:05:09.015]             `+` <- base::`+`
[16:05:09.015]             `<<-` <- base::`<<-`
[16:05:09.015]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:09.015]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:09.015]                   3L)]
[16:05:09.015]             }
[16:05:09.015]             function(cond) {
[16:05:09.015]                 is_error <- inherits(cond, "error")
[16:05:09.015]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:09.015]                   NULL)
[16:05:09.015]                 if (is_error) {
[16:05:09.015]                   sessionInformation <- function() {
[16:05:09.015]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:09.015]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:09.015]                       search = base::search(), system = base::Sys.info())
[16:05:09.015]                   }
[16:05:09.015]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.015]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:09.015]                     cond$call), session = sessionInformation(), 
[16:05:09.015]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:09.015]                   signalCondition(cond)
[16:05:09.015]                 }
[16:05:09.015]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:09.015]                 "immediateCondition"))) {
[16:05:09.015]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:09.015]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.015]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:09.015]                   if (TRUE && !signal) {
[16:05:09.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.015]                     {
[16:05:09.015]                       inherits <- base::inherits
[16:05:09.015]                       invokeRestart <- base::invokeRestart
[16:05:09.015]                       is.null <- base::is.null
[16:05:09.015]                       muffled <- FALSE
[16:05:09.015]                       if (inherits(cond, "message")) {
[16:05:09.015]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.015]                         if (muffled) 
[16:05:09.015]                           invokeRestart("muffleMessage")
[16:05:09.015]                       }
[16:05:09.015]                       else if (inherits(cond, "warning")) {
[16:05:09.015]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.015]                         if (muffled) 
[16:05:09.015]                           invokeRestart("muffleWarning")
[16:05:09.015]                       }
[16:05:09.015]                       else if (inherits(cond, "condition")) {
[16:05:09.015]                         if (!is.null(pattern)) {
[16:05:09.015]                           computeRestarts <- base::computeRestarts
[16:05:09.015]                           grepl <- base::grepl
[16:05:09.015]                           restarts <- computeRestarts(cond)
[16:05:09.015]                           for (restart in restarts) {
[16:05:09.015]                             name <- restart$name
[16:05:09.015]                             if (is.null(name)) 
[16:05:09.015]                               next
[16:05:09.015]                             if (!grepl(pattern, name)) 
[16:05:09.015]                               next
[16:05:09.015]                             invokeRestart(restart)
[16:05:09.015]                             muffled <- TRUE
[16:05:09.015]                             break
[16:05:09.015]                           }
[16:05:09.015]                         }
[16:05:09.015]                       }
[16:05:09.015]                       invisible(muffled)
[16:05:09.015]                     }
[16:05:09.015]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.015]                   }
[16:05:09.015]                 }
[16:05:09.015]                 else {
[16:05:09.015]                   if (TRUE) {
[16:05:09.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.015]                     {
[16:05:09.015]                       inherits <- base::inherits
[16:05:09.015]                       invokeRestart <- base::invokeRestart
[16:05:09.015]                       is.null <- base::is.null
[16:05:09.015]                       muffled <- FALSE
[16:05:09.015]                       if (inherits(cond, "message")) {
[16:05:09.015]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.015]                         if (muffled) 
[16:05:09.015]                           invokeRestart("muffleMessage")
[16:05:09.015]                       }
[16:05:09.015]                       else if (inherits(cond, "warning")) {
[16:05:09.015]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.015]                         if (muffled) 
[16:05:09.015]                           invokeRestart("muffleWarning")
[16:05:09.015]                       }
[16:05:09.015]                       else if (inherits(cond, "condition")) {
[16:05:09.015]                         if (!is.null(pattern)) {
[16:05:09.015]                           computeRestarts <- base::computeRestarts
[16:05:09.015]                           grepl <- base::grepl
[16:05:09.015]                           restarts <- computeRestarts(cond)
[16:05:09.015]                           for (restart in restarts) {
[16:05:09.015]                             name <- restart$name
[16:05:09.015]                             if (is.null(name)) 
[16:05:09.015]                               next
[16:05:09.015]                             if (!grepl(pattern, name)) 
[16:05:09.015]                               next
[16:05:09.015]                             invokeRestart(restart)
[16:05:09.015]                             muffled <- TRUE
[16:05:09.015]                             break
[16:05:09.015]                           }
[16:05:09.015]                         }
[16:05:09.015]                       }
[16:05:09.015]                       invisible(muffled)
[16:05:09.015]                     }
[16:05:09.015]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.015]                   }
[16:05:09.015]                 }
[16:05:09.015]             }
[16:05:09.015]         }))
[16:05:09.015]     }, error = function(ex) {
[16:05:09.015]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:09.015]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.015]                 ...future.rng), started = ...future.startTime, 
[16:05:09.015]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:09.015]             version = "1.8"), class = "FutureResult")
[16:05:09.015]     }, finally = {
[16:05:09.015]         if (!identical(...future.workdir, getwd())) 
[16:05:09.015]             setwd(...future.workdir)
[16:05:09.015]         {
[16:05:09.015]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:09.015]                 ...future.oldOptions$nwarnings <- NULL
[16:05:09.015]             }
[16:05:09.015]             base::options(...future.oldOptions)
[16:05:09.015]             if (.Platform$OS.type == "windows") {
[16:05:09.015]                 old_names <- names(...future.oldEnvVars)
[16:05:09.015]                 envs <- base::Sys.getenv()
[16:05:09.015]                 names <- names(envs)
[16:05:09.015]                 common <- intersect(names, old_names)
[16:05:09.015]                 added <- setdiff(names, old_names)
[16:05:09.015]                 removed <- setdiff(old_names, names)
[16:05:09.015]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:09.015]                   envs[common]]
[16:05:09.015]                 NAMES <- toupper(changed)
[16:05:09.015]                 args <- list()
[16:05:09.015]                 for (kk in seq_along(NAMES)) {
[16:05:09.015]                   name <- changed[[kk]]
[16:05:09.015]                   NAME <- NAMES[[kk]]
[16:05:09.015]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.015]                     next
[16:05:09.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.015]                 }
[16:05:09.015]                 NAMES <- toupper(added)
[16:05:09.015]                 for (kk in seq_along(NAMES)) {
[16:05:09.015]                   name <- added[[kk]]
[16:05:09.015]                   NAME <- NAMES[[kk]]
[16:05:09.015]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.015]                     next
[16:05:09.015]                   args[[name]] <- ""
[16:05:09.015]                 }
[16:05:09.015]                 NAMES <- toupper(removed)
[16:05:09.015]                 for (kk in seq_along(NAMES)) {
[16:05:09.015]                   name <- removed[[kk]]
[16:05:09.015]                   NAME <- NAMES[[kk]]
[16:05:09.015]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.015]                     next
[16:05:09.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.015]                 }
[16:05:09.015]                 if (length(args) > 0) 
[16:05:09.015]                   base::do.call(base::Sys.setenv, args = args)
[16:05:09.015]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:09.015]             }
[16:05:09.015]             else {
[16:05:09.015]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:09.015]             }
[16:05:09.015]             {
[16:05:09.015]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:09.015]                   0L) {
[16:05:09.015]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:09.015]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:09.015]                   base::options(opts)
[16:05:09.015]                 }
[16:05:09.015]                 {
[16:05:09.015]                   {
[16:05:09.015]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:09.015]                     NULL
[16:05:09.015]                   }
[16:05:09.015]                   options(future.plan = NULL)
[16:05:09.015]                   if (is.na(NA_character_)) 
[16:05:09.015]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.015]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:09.015]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:09.015]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:09.015]                     envir = parent.frame()) 
[16:05:09.015]                   {
[16:05:09.015]                     if (is.function(workers)) 
[16:05:09.015]                       workers <- workers()
[16:05:09.015]                     workers <- structure(as.integer(workers), 
[16:05:09.015]                       class = class(workers))
[16:05:09.015]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:09.015]                       workers >= 1)
[16:05:09.015]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:09.015]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:09.015]                     }
[16:05:09.015]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:09.015]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:09.015]                       envir = envir)
[16:05:09.015]                     if (!future$lazy) 
[16:05:09.015]                       future <- run(future)
[16:05:09.015]                     invisible(future)
[16:05:09.015]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:09.015]                 }
[16:05:09.015]             }
[16:05:09.015]         }
[16:05:09.015]     })
[16:05:09.015]     if (TRUE) {
[16:05:09.015]         base::sink(type = "output", split = FALSE)
[16:05:09.015]         if (TRUE) {
[16:05:09.015]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:09.015]         }
[16:05:09.015]         else {
[16:05:09.015]             ...future.result["stdout"] <- base::list(NULL)
[16:05:09.015]         }
[16:05:09.015]         base::close(...future.stdout)
[16:05:09.015]         ...future.stdout <- NULL
[16:05:09.015]     }
[16:05:09.015]     ...future.result$conditions <- ...future.conditions
[16:05:09.015]     ...future.result$finished <- base::Sys.time()
[16:05:09.015]     ...future.result
[16:05:09.015] }
[16:05:09.019] MultisessionFuture started
[16:05:09.019] - Launch lazy future ... done
[16:05:09.019] run() for ‘MultisessionFuture’ ... done
[16:05:09.019] result() for ClusterFuture ...
[16:05:09.020] receiveMessageFromWorker() for ClusterFuture ...
[16:05:09.020] - Validating connection of MultisessionFuture
[16:05:09.064] - received message: FutureResult
[16:05:09.065] - Received FutureResult
[16:05:09.065] - Erased future from FutureRegistry
[16:05:09.065] result() for ClusterFuture ...
[16:05:09.065] - result already collected: FutureResult
[16:05:09.065] result() for ClusterFuture ... done
[16:05:09.065] signalConditions() ...
[16:05:09.065]  - include = ‘immediateCondition’
[16:05:09.065]  - exclude = 
[16:05:09.066]  - resignal = FALSE
[16:05:09.066]  - Number of conditions: 1
[16:05:09.066] signalConditions() ... done
[16:05:09.066] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:09.066] result() for ClusterFuture ... done
[16:05:09.066] result() for ClusterFuture ...
[16:05:09.066] - result already collected: FutureResult
[16:05:09.066] result() for ClusterFuture ... done
[16:05:09.066] signalConditions() ...
[16:05:09.067]  - include = ‘immediateCondition’
[16:05:09.067]  - exclude = 
[16:05:09.067]  - resignal = FALSE
[16:05:09.067]  - Number of conditions: 1
[16:05:09.067] signalConditions() ... done
[16:05:09.067] Future state: ‘finished’
[16:05:09.067] result() for ClusterFuture ...
[16:05:09.067] - result already collected: FutureResult
[16:05:09.068] result() for ClusterFuture ... done
[16:05:09.068] signalConditions() ...
[16:05:09.068]  - include = ‘condition’
[16:05:09.068]  - exclude = ‘immediateCondition’
[16:05:09.068]  - resignal = TRUE
[16:05:09.068]  - Number of conditions: 1
[16:05:09.068]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:05:09.068] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "11666ca4073c" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:05:09"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:09.085] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:09.085] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:09.087] - globals found: [3] ‘{’, ‘<-’, ‘*’
[16:05:09.087] Searching for globals ... DONE
[16:05:09.087] Resolving globals: TRUE
[16:05:09.087] Resolving any globals that are futures ...
[16:05:09.087] - globals: [3] ‘{’, ‘<-’, ‘*’
[16:05:09.087] Resolving any globals that are futures ... DONE
[16:05:09.088] 
[16:05:09.088] 
[16:05:09.088] getGlobalsAndPackages() ... DONE
[16:05:09.088] run() for ‘Future’ ...
[16:05:09.089] - state: ‘created’
[16:05:09.089] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:09.103] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:09.103] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:09.103]   - Field: ‘node’
[16:05:09.103]   - Field: ‘label’
[16:05:09.104]   - Field: ‘local’
[16:05:09.104]   - Field: ‘owner’
[16:05:09.104]   - Field: ‘envir’
[16:05:09.104]   - Field: ‘workers’
[16:05:09.104]   - Field: ‘packages’
[16:05:09.104]   - Field: ‘gc’
[16:05:09.104]   - Field: ‘conditions’
[16:05:09.104]   - Field: ‘persistent’
[16:05:09.104]   - Field: ‘expr’
[16:05:09.104]   - Field: ‘uuid’
[16:05:09.105]   - Field: ‘seed’
[16:05:09.105]   - Field: ‘version’
[16:05:09.105]   - Field: ‘result’
[16:05:09.105]   - Field: ‘asynchronous’
[16:05:09.105]   - Field: ‘calls’
[16:05:09.105]   - Field: ‘globals’
[16:05:09.105]   - Field: ‘stdout’
[16:05:09.105]   - Field: ‘earlySignal’
[16:05:09.106]   - Field: ‘lazy’
[16:05:09.106]   - Field: ‘state’
[16:05:09.106] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:09.106] - Launch lazy future ...
[16:05:09.106] Packages needed by the future expression (n = 0): <none>
[16:05:09.106] Packages needed by future strategies (n = 0): <none>
[16:05:09.107] {
[16:05:09.107]     {
[16:05:09.107]         {
[16:05:09.107]             ...future.startTime <- base::Sys.time()
[16:05:09.107]             {
[16:05:09.107]                 {
[16:05:09.107]                   {
[16:05:09.107]                     {
[16:05:09.107]                       base::local({
[16:05:09.107]                         has_future <- base::requireNamespace("future", 
[16:05:09.107]                           quietly = TRUE)
[16:05:09.107]                         if (has_future) {
[16:05:09.107]                           ns <- base::getNamespace("future")
[16:05:09.107]                           version <- ns[[".package"]][["version"]]
[16:05:09.107]                           if (is.null(version)) 
[16:05:09.107]                             version <- utils::packageVersion("future")
[16:05:09.107]                         }
[16:05:09.107]                         else {
[16:05:09.107]                           version <- NULL
[16:05:09.107]                         }
[16:05:09.107]                         if (!has_future || version < "1.8.0") {
[16:05:09.107]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:09.107]                             "", base::R.version$version.string), 
[16:05:09.107]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:09.107]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:09.107]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:09.107]                               "release", "version")], collapse = " "), 
[16:05:09.107]                             hostname = base::Sys.info()[["nodename"]])
[16:05:09.107]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:09.107]                             info)
[16:05:09.107]                           info <- base::paste(info, collapse = "; ")
[16:05:09.107]                           if (!has_future) {
[16:05:09.107]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:09.107]                               info)
[16:05:09.107]                           }
[16:05:09.107]                           else {
[16:05:09.107]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:09.107]                               info, version)
[16:05:09.107]                           }
[16:05:09.107]                           base::stop(msg)
[16:05:09.107]                         }
[16:05:09.107]                       })
[16:05:09.107]                     }
[16:05:09.107]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:09.107]                     base::options(mc.cores = 1L)
[16:05:09.107]                   }
[16:05:09.107]                   options(future.plan = NULL)
[16:05:09.107]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.107]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:09.107]                 }
[16:05:09.107]                 ...future.workdir <- getwd()
[16:05:09.107]             }
[16:05:09.107]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:09.107]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:09.107]         }
[16:05:09.107]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:09.107]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:09.107]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:09.107]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:09.107]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:09.107]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:09.107]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:09.107]             base::names(...future.oldOptions))
[16:05:09.107]     }
[16:05:09.107]     if (FALSE) {
[16:05:09.107]     }
[16:05:09.107]     else {
[16:05:09.107]         if (TRUE) {
[16:05:09.107]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:09.107]                 open = "w")
[16:05:09.107]         }
[16:05:09.107]         else {
[16:05:09.107]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:09.107]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:09.107]         }
[16:05:09.107]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:09.107]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:09.107]             base::sink(type = "output", split = FALSE)
[16:05:09.107]             base::close(...future.stdout)
[16:05:09.107]         }, add = TRUE)
[16:05:09.107]     }
[16:05:09.107]     ...future.frame <- base::sys.nframe()
[16:05:09.107]     ...future.conditions <- base::list()
[16:05:09.107]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:09.107]     if (FALSE) {
[16:05:09.107]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:09.107]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:09.107]     }
[16:05:09.107]     ...future.result <- base::tryCatch({
[16:05:09.107]         base::withCallingHandlers({
[16:05:09.107]             ...future.value <- base::withVisible(base::local({
[16:05:09.107]                 ...future.makeSendCondition <- base::local({
[16:05:09.107]                   sendCondition <- NULL
[16:05:09.107]                   function(frame = 1L) {
[16:05:09.107]                     if (is.function(sendCondition)) 
[16:05:09.107]                       return(sendCondition)
[16:05:09.107]                     ns <- getNamespace("parallel")
[16:05:09.107]                     if (exists("sendData", mode = "function", 
[16:05:09.107]                       envir = ns)) {
[16:05:09.107]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:09.107]                         envir = ns)
[16:05:09.107]                       envir <- sys.frame(frame)
[16:05:09.107]                       master <- NULL
[16:05:09.107]                       while (!identical(envir, .GlobalEnv) && 
[16:05:09.107]                         !identical(envir, emptyenv())) {
[16:05:09.107]                         if (exists("master", mode = "list", envir = envir, 
[16:05:09.107]                           inherits = FALSE)) {
[16:05:09.107]                           master <- get("master", mode = "list", 
[16:05:09.107]                             envir = envir, inherits = FALSE)
[16:05:09.107]                           if (inherits(master, c("SOCKnode", 
[16:05:09.107]                             "SOCK0node"))) {
[16:05:09.107]                             sendCondition <<- function(cond) {
[16:05:09.107]                               data <- list(type = "VALUE", value = cond, 
[16:05:09.107]                                 success = TRUE)
[16:05:09.107]                               parallel_sendData(master, data)
[16:05:09.107]                             }
[16:05:09.107]                             return(sendCondition)
[16:05:09.107]                           }
[16:05:09.107]                         }
[16:05:09.107]                         frame <- frame + 1L
[16:05:09.107]                         envir <- sys.frame(frame)
[16:05:09.107]                       }
[16:05:09.107]                     }
[16:05:09.107]                     sendCondition <<- function(cond) NULL
[16:05:09.107]                   }
[16:05:09.107]                 })
[16:05:09.107]                 withCallingHandlers({
[16:05:09.107]                   {
[16:05:09.107]                     b <- a
[16:05:09.107]                     a <- 2
[16:05:09.107]                     a * b
[16:05:09.107]                   }
[16:05:09.107]                 }, immediateCondition = function(cond) {
[16:05:09.107]                   sendCondition <- ...future.makeSendCondition()
[16:05:09.107]                   sendCondition(cond)
[16:05:09.107]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.107]                   {
[16:05:09.107]                     inherits <- base::inherits
[16:05:09.107]                     invokeRestart <- base::invokeRestart
[16:05:09.107]                     is.null <- base::is.null
[16:05:09.107]                     muffled <- FALSE
[16:05:09.107]                     if (inherits(cond, "message")) {
[16:05:09.107]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:09.107]                       if (muffled) 
[16:05:09.107]                         invokeRestart("muffleMessage")
[16:05:09.107]                     }
[16:05:09.107]                     else if (inherits(cond, "warning")) {
[16:05:09.107]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:09.107]                       if (muffled) 
[16:05:09.107]                         invokeRestart("muffleWarning")
[16:05:09.107]                     }
[16:05:09.107]                     else if (inherits(cond, "condition")) {
[16:05:09.107]                       if (!is.null(pattern)) {
[16:05:09.107]                         computeRestarts <- base::computeRestarts
[16:05:09.107]                         grepl <- base::grepl
[16:05:09.107]                         restarts <- computeRestarts(cond)
[16:05:09.107]                         for (restart in restarts) {
[16:05:09.107]                           name <- restart$name
[16:05:09.107]                           if (is.null(name)) 
[16:05:09.107]                             next
[16:05:09.107]                           if (!grepl(pattern, name)) 
[16:05:09.107]                             next
[16:05:09.107]                           invokeRestart(restart)
[16:05:09.107]                           muffled <- TRUE
[16:05:09.107]                           break
[16:05:09.107]                         }
[16:05:09.107]                       }
[16:05:09.107]                     }
[16:05:09.107]                     invisible(muffled)
[16:05:09.107]                   }
[16:05:09.107]                   muffleCondition(cond)
[16:05:09.107]                 })
[16:05:09.107]             }))
[16:05:09.107]             future::FutureResult(value = ...future.value$value, 
[16:05:09.107]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.107]                   ...future.rng), globalenv = if (FALSE) 
[16:05:09.107]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:09.107]                     ...future.globalenv.names))
[16:05:09.107]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:09.107]         }, condition = base::local({
[16:05:09.107]             c <- base::c
[16:05:09.107]             inherits <- base::inherits
[16:05:09.107]             invokeRestart <- base::invokeRestart
[16:05:09.107]             length <- base::length
[16:05:09.107]             list <- base::list
[16:05:09.107]             seq.int <- base::seq.int
[16:05:09.107]             signalCondition <- base::signalCondition
[16:05:09.107]             sys.calls <- base::sys.calls
[16:05:09.107]             `[[` <- base::`[[`
[16:05:09.107]             `+` <- base::`+`
[16:05:09.107]             `<<-` <- base::`<<-`
[16:05:09.107]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:09.107]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:09.107]                   3L)]
[16:05:09.107]             }
[16:05:09.107]             function(cond) {
[16:05:09.107]                 is_error <- inherits(cond, "error")
[16:05:09.107]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:09.107]                   NULL)
[16:05:09.107]                 if (is_error) {
[16:05:09.107]                   sessionInformation <- function() {
[16:05:09.107]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:09.107]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:09.107]                       search = base::search(), system = base::Sys.info())
[16:05:09.107]                   }
[16:05:09.107]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.107]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:09.107]                     cond$call), session = sessionInformation(), 
[16:05:09.107]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:09.107]                   signalCondition(cond)
[16:05:09.107]                 }
[16:05:09.107]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:09.107]                 "immediateCondition"))) {
[16:05:09.107]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:09.107]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.107]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:09.107]                   if (TRUE && !signal) {
[16:05:09.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.107]                     {
[16:05:09.107]                       inherits <- base::inherits
[16:05:09.107]                       invokeRestart <- base::invokeRestart
[16:05:09.107]                       is.null <- base::is.null
[16:05:09.107]                       muffled <- FALSE
[16:05:09.107]                       if (inherits(cond, "message")) {
[16:05:09.107]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.107]                         if (muffled) 
[16:05:09.107]                           invokeRestart("muffleMessage")
[16:05:09.107]                       }
[16:05:09.107]                       else if (inherits(cond, "warning")) {
[16:05:09.107]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.107]                         if (muffled) 
[16:05:09.107]                           invokeRestart("muffleWarning")
[16:05:09.107]                       }
[16:05:09.107]                       else if (inherits(cond, "condition")) {
[16:05:09.107]                         if (!is.null(pattern)) {
[16:05:09.107]                           computeRestarts <- base::computeRestarts
[16:05:09.107]                           grepl <- base::grepl
[16:05:09.107]                           restarts <- computeRestarts(cond)
[16:05:09.107]                           for (restart in restarts) {
[16:05:09.107]                             name <- restart$name
[16:05:09.107]                             if (is.null(name)) 
[16:05:09.107]                               next
[16:05:09.107]                             if (!grepl(pattern, name)) 
[16:05:09.107]                               next
[16:05:09.107]                             invokeRestart(restart)
[16:05:09.107]                             muffled <- TRUE
[16:05:09.107]                             break
[16:05:09.107]                           }
[16:05:09.107]                         }
[16:05:09.107]                       }
[16:05:09.107]                       invisible(muffled)
[16:05:09.107]                     }
[16:05:09.107]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.107]                   }
[16:05:09.107]                 }
[16:05:09.107]                 else {
[16:05:09.107]                   if (TRUE) {
[16:05:09.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.107]                     {
[16:05:09.107]                       inherits <- base::inherits
[16:05:09.107]                       invokeRestart <- base::invokeRestart
[16:05:09.107]                       is.null <- base::is.null
[16:05:09.107]                       muffled <- FALSE
[16:05:09.107]                       if (inherits(cond, "message")) {
[16:05:09.107]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.107]                         if (muffled) 
[16:05:09.107]                           invokeRestart("muffleMessage")
[16:05:09.107]                       }
[16:05:09.107]                       else if (inherits(cond, "warning")) {
[16:05:09.107]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.107]                         if (muffled) 
[16:05:09.107]                           invokeRestart("muffleWarning")
[16:05:09.107]                       }
[16:05:09.107]                       else if (inherits(cond, "condition")) {
[16:05:09.107]                         if (!is.null(pattern)) {
[16:05:09.107]                           computeRestarts <- base::computeRestarts
[16:05:09.107]                           grepl <- base::grepl
[16:05:09.107]                           restarts <- computeRestarts(cond)
[16:05:09.107]                           for (restart in restarts) {
[16:05:09.107]                             name <- restart$name
[16:05:09.107]                             if (is.null(name)) 
[16:05:09.107]                               next
[16:05:09.107]                             if (!grepl(pattern, name)) 
[16:05:09.107]                               next
[16:05:09.107]                             invokeRestart(restart)
[16:05:09.107]                             muffled <- TRUE
[16:05:09.107]                             break
[16:05:09.107]                           }
[16:05:09.107]                         }
[16:05:09.107]                       }
[16:05:09.107]                       invisible(muffled)
[16:05:09.107]                     }
[16:05:09.107]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.107]                   }
[16:05:09.107]                 }
[16:05:09.107]             }
[16:05:09.107]         }))
[16:05:09.107]     }, error = function(ex) {
[16:05:09.107]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:09.107]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.107]                 ...future.rng), started = ...future.startTime, 
[16:05:09.107]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:09.107]             version = "1.8"), class = "FutureResult")
[16:05:09.107]     }, finally = {
[16:05:09.107]         if (!identical(...future.workdir, getwd())) 
[16:05:09.107]             setwd(...future.workdir)
[16:05:09.107]         {
[16:05:09.107]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:09.107]                 ...future.oldOptions$nwarnings <- NULL
[16:05:09.107]             }
[16:05:09.107]             base::options(...future.oldOptions)
[16:05:09.107]             if (.Platform$OS.type == "windows") {
[16:05:09.107]                 old_names <- names(...future.oldEnvVars)
[16:05:09.107]                 envs <- base::Sys.getenv()
[16:05:09.107]                 names <- names(envs)
[16:05:09.107]                 common <- intersect(names, old_names)
[16:05:09.107]                 added <- setdiff(names, old_names)
[16:05:09.107]                 removed <- setdiff(old_names, names)
[16:05:09.107]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:09.107]                   envs[common]]
[16:05:09.107]                 NAMES <- toupper(changed)
[16:05:09.107]                 args <- list()
[16:05:09.107]                 for (kk in seq_along(NAMES)) {
[16:05:09.107]                   name <- changed[[kk]]
[16:05:09.107]                   NAME <- NAMES[[kk]]
[16:05:09.107]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.107]                     next
[16:05:09.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.107]                 }
[16:05:09.107]                 NAMES <- toupper(added)
[16:05:09.107]                 for (kk in seq_along(NAMES)) {
[16:05:09.107]                   name <- added[[kk]]
[16:05:09.107]                   NAME <- NAMES[[kk]]
[16:05:09.107]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.107]                     next
[16:05:09.107]                   args[[name]] <- ""
[16:05:09.107]                 }
[16:05:09.107]                 NAMES <- toupper(removed)
[16:05:09.107]                 for (kk in seq_along(NAMES)) {
[16:05:09.107]                   name <- removed[[kk]]
[16:05:09.107]                   NAME <- NAMES[[kk]]
[16:05:09.107]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.107]                     next
[16:05:09.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.107]                 }
[16:05:09.107]                 if (length(args) > 0) 
[16:05:09.107]                   base::do.call(base::Sys.setenv, args = args)
[16:05:09.107]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:09.107]             }
[16:05:09.107]             else {
[16:05:09.107]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:09.107]             }
[16:05:09.107]             {
[16:05:09.107]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:09.107]                   0L) {
[16:05:09.107]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:09.107]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:09.107]                   base::options(opts)
[16:05:09.107]                 }
[16:05:09.107]                 {
[16:05:09.107]                   {
[16:05:09.107]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:09.107]                     NULL
[16:05:09.107]                   }
[16:05:09.107]                   options(future.plan = NULL)
[16:05:09.107]                   if (is.na(NA_character_)) 
[16:05:09.107]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.107]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:09.107]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:09.107]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:09.107]                     envir = parent.frame()) 
[16:05:09.107]                   {
[16:05:09.107]                     if (is.function(workers)) 
[16:05:09.107]                       workers <- workers()
[16:05:09.107]                     workers <- structure(as.integer(workers), 
[16:05:09.107]                       class = class(workers))
[16:05:09.107]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:09.107]                       workers >= 1)
[16:05:09.107]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:09.107]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:09.107]                     }
[16:05:09.107]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:09.107]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:09.107]                       envir = envir)
[16:05:09.107]                     if (!future$lazy) 
[16:05:09.107]                       future <- run(future)
[16:05:09.107]                     invisible(future)
[16:05:09.107]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:09.107]                 }
[16:05:09.107]             }
[16:05:09.107]         }
[16:05:09.107]     })
[16:05:09.107]     if (TRUE) {
[16:05:09.107]         base::sink(type = "output", split = FALSE)
[16:05:09.107]         if (TRUE) {
[16:05:09.107]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:09.107]         }
[16:05:09.107]         else {
[16:05:09.107]             ...future.result["stdout"] <- base::list(NULL)
[16:05:09.107]         }
[16:05:09.107]         base::close(...future.stdout)
[16:05:09.107]         ...future.stdout <- NULL
[16:05:09.107]     }
[16:05:09.107]     ...future.result$conditions <- ...future.conditions
[16:05:09.107]     ...future.result$finished <- base::Sys.time()
[16:05:09.107]     ...future.result
[16:05:09.107] }
[16:05:09.113] MultisessionFuture started
[16:05:09.113] - Launch lazy future ... done
[16:05:09.113] run() for ‘MultisessionFuture’ ... done
[16:05:09.113] result() for ClusterFuture ...
[16:05:09.113] receiveMessageFromWorker() for ClusterFuture ...
[16:05:09.113] - Validating connection of MultisessionFuture
[16:05:09.160] - received message: FutureResult
[16:05:09.160] - Received FutureResult
[16:05:09.161] - Erased future from FutureRegistry
[16:05:09.161] result() for ClusterFuture ...
[16:05:09.161] - result already collected: FutureResult
[16:05:09.161] result() for ClusterFuture ... done
[16:05:09.161] signalConditions() ...
[16:05:09.161]  - include = ‘immediateCondition’
[16:05:09.161]  - exclude = 
[16:05:09.161]  - resignal = FALSE
[16:05:09.161]  - Number of conditions: 1
[16:05:09.161] signalConditions() ... done
[16:05:09.161] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:09.161] result() for ClusterFuture ... done
[16:05:09.162] result() for ClusterFuture ...
[16:05:09.162] - result already collected: FutureResult
[16:05:09.162] result() for ClusterFuture ... done
[16:05:09.162] signalConditions() ...
[16:05:09.162]  - include = ‘immediateCondition’
[16:05:09.162]  - exclude = 
[16:05:09.162]  - resignal = FALSE
[16:05:09.162]  - Number of conditions: 1
[16:05:09.162] signalConditions() ... done
[16:05:09.162] Future state: ‘finished’
[16:05:09.162] result() for ClusterFuture ...
[16:05:09.163] - result already collected: FutureResult
[16:05:09.163] result() for ClusterFuture ... done
[16:05:09.163] signalConditions() ...
[16:05:09.163]  - include = ‘condition’
[16:05:09.163]  - exclude = ‘immediateCondition’
[16:05:09.163]  - resignal = TRUE
[16:05:09.163]  - Number of conditions: 1
[16:05:09.163]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:05:09.163] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "11666ca4073c" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:05:09"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:09.177] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:09.177] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:09.178] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:09.179] Searching for globals ... DONE
[16:05:09.179] Resolving globals: TRUE
[16:05:09.179] Resolving any globals that are futures ...
[16:05:09.179] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:09.179] Resolving any globals that are futures ... DONE
[16:05:09.179] Resolving futures part of globals (recursively) ...
[16:05:09.180] resolve() on list ...
[16:05:09.180]  recursive: 99
[16:05:09.180]  length: 1
[16:05:09.180]  elements: ‘ii’
[16:05:09.180]  length: 0 (resolved future 1)
[16:05:09.180] resolve() on list ... DONE
[16:05:09.180] - globals: [1] ‘ii’
[16:05:09.180] Resolving futures part of globals (recursively) ... DONE
[16:05:09.180] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:09.181] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:09.181] - globals: [1] ‘ii’
[16:05:09.181] 
[16:05:09.181] getGlobalsAndPackages() ... DONE
[16:05:09.181] run() for ‘Future’ ...
[16:05:09.181] - state: ‘created’
[16:05:09.182] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:09.196] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:09.196] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:09.196]   - Field: ‘node’
[16:05:09.196]   - Field: ‘label’
[16:05:09.196]   - Field: ‘local’
[16:05:09.196]   - Field: ‘owner’
[16:05:09.196]   - Field: ‘envir’
[16:05:09.196]   - Field: ‘workers’
[16:05:09.196]   - Field: ‘packages’
[16:05:09.197]   - Field: ‘gc’
[16:05:09.197]   - Field: ‘conditions’
[16:05:09.197]   - Field: ‘persistent’
[16:05:09.197]   - Field: ‘expr’
[16:05:09.197]   - Field: ‘uuid’
[16:05:09.197]   - Field: ‘seed’
[16:05:09.197]   - Field: ‘version’
[16:05:09.197]   - Field: ‘result’
[16:05:09.197]   - Field: ‘asynchronous’
[16:05:09.197]   - Field: ‘calls’
[16:05:09.197]   - Field: ‘globals’
[16:05:09.198]   - Field: ‘stdout’
[16:05:09.198]   - Field: ‘earlySignal’
[16:05:09.198]   - Field: ‘lazy’
[16:05:09.198]   - Field: ‘state’
[16:05:09.198] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:09.198] - Launch lazy future ...
[16:05:09.198] Packages needed by the future expression (n = 0): <none>
[16:05:09.198] Packages needed by future strategies (n = 0): <none>
[16:05:09.199] {
[16:05:09.199]     {
[16:05:09.199]         {
[16:05:09.199]             ...future.startTime <- base::Sys.time()
[16:05:09.199]             {
[16:05:09.199]                 {
[16:05:09.199]                   {
[16:05:09.199]                     {
[16:05:09.199]                       base::local({
[16:05:09.199]                         has_future <- base::requireNamespace("future", 
[16:05:09.199]                           quietly = TRUE)
[16:05:09.199]                         if (has_future) {
[16:05:09.199]                           ns <- base::getNamespace("future")
[16:05:09.199]                           version <- ns[[".package"]][["version"]]
[16:05:09.199]                           if (is.null(version)) 
[16:05:09.199]                             version <- utils::packageVersion("future")
[16:05:09.199]                         }
[16:05:09.199]                         else {
[16:05:09.199]                           version <- NULL
[16:05:09.199]                         }
[16:05:09.199]                         if (!has_future || version < "1.8.0") {
[16:05:09.199]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:09.199]                             "", base::R.version$version.string), 
[16:05:09.199]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:09.199]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:09.199]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:09.199]                               "release", "version")], collapse = " "), 
[16:05:09.199]                             hostname = base::Sys.info()[["nodename"]])
[16:05:09.199]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:09.199]                             info)
[16:05:09.199]                           info <- base::paste(info, collapse = "; ")
[16:05:09.199]                           if (!has_future) {
[16:05:09.199]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:09.199]                               info)
[16:05:09.199]                           }
[16:05:09.199]                           else {
[16:05:09.199]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:09.199]                               info, version)
[16:05:09.199]                           }
[16:05:09.199]                           base::stop(msg)
[16:05:09.199]                         }
[16:05:09.199]                       })
[16:05:09.199]                     }
[16:05:09.199]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:09.199]                     base::options(mc.cores = 1L)
[16:05:09.199]                   }
[16:05:09.199]                   options(future.plan = NULL)
[16:05:09.199]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.199]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:09.199]                 }
[16:05:09.199]                 ...future.workdir <- getwd()
[16:05:09.199]             }
[16:05:09.199]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:09.199]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:09.199]         }
[16:05:09.199]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:09.199]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:09.199]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:09.199]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:09.199]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:09.199]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:09.199]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:09.199]             base::names(...future.oldOptions))
[16:05:09.199]     }
[16:05:09.199]     if (FALSE) {
[16:05:09.199]     }
[16:05:09.199]     else {
[16:05:09.199]         if (TRUE) {
[16:05:09.199]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:09.199]                 open = "w")
[16:05:09.199]         }
[16:05:09.199]         else {
[16:05:09.199]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:09.199]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:09.199]         }
[16:05:09.199]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:09.199]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:09.199]             base::sink(type = "output", split = FALSE)
[16:05:09.199]             base::close(...future.stdout)
[16:05:09.199]         }, add = TRUE)
[16:05:09.199]     }
[16:05:09.199]     ...future.frame <- base::sys.nframe()
[16:05:09.199]     ...future.conditions <- base::list()
[16:05:09.199]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:09.199]     if (FALSE) {
[16:05:09.199]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:09.199]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:09.199]     }
[16:05:09.199]     ...future.result <- base::tryCatch({
[16:05:09.199]         base::withCallingHandlers({
[16:05:09.199]             ...future.value <- base::withVisible(base::local({
[16:05:09.199]                 ...future.makeSendCondition <- base::local({
[16:05:09.199]                   sendCondition <- NULL
[16:05:09.199]                   function(frame = 1L) {
[16:05:09.199]                     if (is.function(sendCondition)) 
[16:05:09.199]                       return(sendCondition)
[16:05:09.199]                     ns <- getNamespace("parallel")
[16:05:09.199]                     if (exists("sendData", mode = "function", 
[16:05:09.199]                       envir = ns)) {
[16:05:09.199]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:09.199]                         envir = ns)
[16:05:09.199]                       envir <- sys.frame(frame)
[16:05:09.199]                       master <- NULL
[16:05:09.199]                       while (!identical(envir, .GlobalEnv) && 
[16:05:09.199]                         !identical(envir, emptyenv())) {
[16:05:09.199]                         if (exists("master", mode = "list", envir = envir, 
[16:05:09.199]                           inherits = FALSE)) {
[16:05:09.199]                           master <- get("master", mode = "list", 
[16:05:09.199]                             envir = envir, inherits = FALSE)
[16:05:09.199]                           if (inherits(master, c("SOCKnode", 
[16:05:09.199]                             "SOCK0node"))) {
[16:05:09.199]                             sendCondition <<- function(cond) {
[16:05:09.199]                               data <- list(type = "VALUE", value = cond, 
[16:05:09.199]                                 success = TRUE)
[16:05:09.199]                               parallel_sendData(master, data)
[16:05:09.199]                             }
[16:05:09.199]                             return(sendCondition)
[16:05:09.199]                           }
[16:05:09.199]                         }
[16:05:09.199]                         frame <- frame + 1L
[16:05:09.199]                         envir <- sys.frame(frame)
[16:05:09.199]                       }
[16:05:09.199]                     }
[16:05:09.199]                     sendCondition <<- function(cond) NULL
[16:05:09.199]                   }
[16:05:09.199]                 })
[16:05:09.199]                 withCallingHandlers({
[16:05:09.199]                   {
[16:05:09.199]                     b <- a * ii
[16:05:09.199]                     a <- 0
[16:05:09.199]                     b
[16:05:09.199]                   }
[16:05:09.199]                 }, immediateCondition = function(cond) {
[16:05:09.199]                   sendCondition <- ...future.makeSendCondition()
[16:05:09.199]                   sendCondition(cond)
[16:05:09.199]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.199]                   {
[16:05:09.199]                     inherits <- base::inherits
[16:05:09.199]                     invokeRestart <- base::invokeRestart
[16:05:09.199]                     is.null <- base::is.null
[16:05:09.199]                     muffled <- FALSE
[16:05:09.199]                     if (inherits(cond, "message")) {
[16:05:09.199]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:09.199]                       if (muffled) 
[16:05:09.199]                         invokeRestart("muffleMessage")
[16:05:09.199]                     }
[16:05:09.199]                     else if (inherits(cond, "warning")) {
[16:05:09.199]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:09.199]                       if (muffled) 
[16:05:09.199]                         invokeRestart("muffleWarning")
[16:05:09.199]                     }
[16:05:09.199]                     else if (inherits(cond, "condition")) {
[16:05:09.199]                       if (!is.null(pattern)) {
[16:05:09.199]                         computeRestarts <- base::computeRestarts
[16:05:09.199]                         grepl <- base::grepl
[16:05:09.199]                         restarts <- computeRestarts(cond)
[16:05:09.199]                         for (restart in restarts) {
[16:05:09.199]                           name <- restart$name
[16:05:09.199]                           if (is.null(name)) 
[16:05:09.199]                             next
[16:05:09.199]                           if (!grepl(pattern, name)) 
[16:05:09.199]                             next
[16:05:09.199]                           invokeRestart(restart)
[16:05:09.199]                           muffled <- TRUE
[16:05:09.199]                           break
[16:05:09.199]                         }
[16:05:09.199]                       }
[16:05:09.199]                     }
[16:05:09.199]                     invisible(muffled)
[16:05:09.199]                   }
[16:05:09.199]                   muffleCondition(cond)
[16:05:09.199]                 })
[16:05:09.199]             }))
[16:05:09.199]             future::FutureResult(value = ...future.value$value, 
[16:05:09.199]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.199]                   ...future.rng), globalenv = if (FALSE) 
[16:05:09.199]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:09.199]                     ...future.globalenv.names))
[16:05:09.199]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:09.199]         }, condition = base::local({
[16:05:09.199]             c <- base::c
[16:05:09.199]             inherits <- base::inherits
[16:05:09.199]             invokeRestart <- base::invokeRestart
[16:05:09.199]             length <- base::length
[16:05:09.199]             list <- base::list
[16:05:09.199]             seq.int <- base::seq.int
[16:05:09.199]             signalCondition <- base::signalCondition
[16:05:09.199]             sys.calls <- base::sys.calls
[16:05:09.199]             `[[` <- base::`[[`
[16:05:09.199]             `+` <- base::`+`
[16:05:09.199]             `<<-` <- base::`<<-`
[16:05:09.199]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:09.199]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:09.199]                   3L)]
[16:05:09.199]             }
[16:05:09.199]             function(cond) {
[16:05:09.199]                 is_error <- inherits(cond, "error")
[16:05:09.199]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:09.199]                   NULL)
[16:05:09.199]                 if (is_error) {
[16:05:09.199]                   sessionInformation <- function() {
[16:05:09.199]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:09.199]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:09.199]                       search = base::search(), system = base::Sys.info())
[16:05:09.199]                   }
[16:05:09.199]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.199]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:09.199]                     cond$call), session = sessionInformation(), 
[16:05:09.199]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:09.199]                   signalCondition(cond)
[16:05:09.199]                 }
[16:05:09.199]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:09.199]                 "immediateCondition"))) {
[16:05:09.199]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:09.199]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.199]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:09.199]                   if (TRUE && !signal) {
[16:05:09.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.199]                     {
[16:05:09.199]                       inherits <- base::inherits
[16:05:09.199]                       invokeRestart <- base::invokeRestart
[16:05:09.199]                       is.null <- base::is.null
[16:05:09.199]                       muffled <- FALSE
[16:05:09.199]                       if (inherits(cond, "message")) {
[16:05:09.199]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.199]                         if (muffled) 
[16:05:09.199]                           invokeRestart("muffleMessage")
[16:05:09.199]                       }
[16:05:09.199]                       else if (inherits(cond, "warning")) {
[16:05:09.199]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.199]                         if (muffled) 
[16:05:09.199]                           invokeRestart("muffleWarning")
[16:05:09.199]                       }
[16:05:09.199]                       else if (inherits(cond, "condition")) {
[16:05:09.199]                         if (!is.null(pattern)) {
[16:05:09.199]                           computeRestarts <- base::computeRestarts
[16:05:09.199]                           grepl <- base::grepl
[16:05:09.199]                           restarts <- computeRestarts(cond)
[16:05:09.199]                           for (restart in restarts) {
[16:05:09.199]                             name <- restart$name
[16:05:09.199]                             if (is.null(name)) 
[16:05:09.199]                               next
[16:05:09.199]                             if (!grepl(pattern, name)) 
[16:05:09.199]                               next
[16:05:09.199]                             invokeRestart(restart)
[16:05:09.199]                             muffled <- TRUE
[16:05:09.199]                             break
[16:05:09.199]                           }
[16:05:09.199]                         }
[16:05:09.199]                       }
[16:05:09.199]                       invisible(muffled)
[16:05:09.199]                     }
[16:05:09.199]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.199]                   }
[16:05:09.199]                 }
[16:05:09.199]                 else {
[16:05:09.199]                   if (TRUE) {
[16:05:09.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.199]                     {
[16:05:09.199]                       inherits <- base::inherits
[16:05:09.199]                       invokeRestart <- base::invokeRestart
[16:05:09.199]                       is.null <- base::is.null
[16:05:09.199]                       muffled <- FALSE
[16:05:09.199]                       if (inherits(cond, "message")) {
[16:05:09.199]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.199]                         if (muffled) 
[16:05:09.199]                           invokeRestart("muffleMessage")
[16:05:09.199]                       }
[16:05:09.199]                       else if (inherits(cond, "warning")) {
[16:05:09.199]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.199]                         if (muffled) 
[16:05:09.199]                           invokeRestart("muffleWarning")
[16:05:09.199]                       }
[16:05:09.199]                       else if (inherits(cond, "condition")) {
[16:05:09.199]                         if (!is.null(pattern)) {
[16:05:09.199]                           computeRestarts <- base::computeRestarts
[16:05:09.199]                           grepl <- base::grepl
[16:05:09.199]                           restarts <- computeRestarts(cond)
[16:05:09.199]                           for (restart in restarts) {
[16:05:09.199]                             name <- restart$name
[16:05:09.199]                             if (is.null(name)) 
[16:05:09.199]                               next
[16:05:09.199]                             if (!grepl(pattern, name)) 
[16:05:09.199]                               next
[16:05:09.199]                             invokeRestart(restart)
[16:05:09.199]                             muffled <- TRUE
[16:05:09.199]                             break
[16:05:09.199]                           }
[16:05:09.199]                         }
[16:05:09.199]                       }
[16:05:09.199]                       invisible(muffled)
[16:05:09.199]                     }
[16:05:09.199]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.199]                   }
[16:05:09.199]                 }
[16:05:09.199]             }
[16:05:09.199]         }))
[16:05:09.199]     }, error = function(ex) {
[16:05:09.199]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:09.199]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.199]                 ...future.rng), started = ...future.startTime, 
[16:05:09.199]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:09.199]             version = "1.8"), class = "FutureResult")
[16:05:09.199]     }, finally = {
[16:05:09.199]         if (!identical(...future.workdir, getwd())) 
[16:05:09.199]             setwd(...future.workdir)
[16:05:09.199]         {
[16:05:09.199]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:09.199]                 ...future.oldOptions$nwarnings <- NULL
[16:05:09.199]             }
[16:05:09.199]             base::options(...future.oldOptions)
[16:05:09.199]             if (.Platform$OS.type == "windows") {
[16:05:09.199]                 old_names <- names(...future.oldEnvVars)
[16:05:09.199]                 envs <- base::Sys.getenv()
[16:05:09.199]                 names <- names(envs)
[16:05:09.199]                 common <- intersect(names, old_names)
[16:05:09.199]                 added <- setdiff(names, old_names)
[16:05:09.199]                 removed <- setdiff(old_names, names)
[16:05:09.199]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:09.199]                   envs[common]]
[16:05:09.199]                 NAMES <- toupper(changed)
[16:05:09.199]                 args <- list()
[16:05:09.199]                 for (kk in seq_along(NAMES)) {
[16:05:09.199]                   name <- changed[[kk]]
[16:05:09.199]                   NAME <- NAMES[[kk]]
[16:05:09.199]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.199]                     next
[16:05:09.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.199]                 }
[16:05:09.199]                 NAMES <- toupper(added)
[16:05:09.199]                 for (kk in seq_along(NAMES)) {
[16:05:09.199]                   name <- added[[kk]]
[16:05:09.199]                   NAME <- NAMES[[kk]]
[16:05:09.199]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.199]                     next
[16:05:09.199]                   args[[name]] <- ""
[16:05:09.199]                 }
[16:05:09.199]                 NAMES <- toupper(removed)
[16:05:09.199]                 for (kk in seq_along(NAMES)) {
[16:05:09.199]                   name <- removed[[kk]]
[16:05:09.199]                   NAME <- NAMES[[kk]]
[16:05:09.199]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.199]                     next
[16:05:09.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.199]                 }
[16:05:09.199]                 if (length(args) > 0) 
[16:05:09.199]                   base::do.call(base::Sys.setenv, args = args)
[16:05:09.199]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:09.199]             }
[16:05:09.199]             else {
[16:05:09.199]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:09.199]             }
[16:05:09.199]             {
[16:05:09.199]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:09.199]                   0L) {
[16:05:09.199]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:09.199]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:09.199]                   base::options(opts)
[16:05:09.199]                 }
[16:05:09.199]                 {
[16:05:09.199]                   {
[16:05:09.199]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:09.199]                     NULL
[16:05:09.199]                   }
[16:05:09.199]                   options(future.plan = NULL)
[16:05:09.199]                   if (is.na(NA_character_)) 
[16:05:09.199]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.199]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:09.199]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:09.199]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:09.199]                     envir = parent.frame()) 
[16:05:09.199]                   {
[16:05:09.199]                     if (is.function(workers)) 
[16:05:09.199]                       workers <- workers()
[16:05:09.199]                     workers <- structure(as.integer(workers), 
[16:05:09.199]                       class = class(workers))
[16:05:09.199]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:09.199]                       workers >= 1)
[16:05:09.199]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:09.199]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:09.199]                     }
[16:05:09.199]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:09.199]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:09.199]                       envir = envir)
[16:05:09.199]                     if (!future$lazy) 
[16:05:09.199]                       future <- run(future)
[16:05:09.199]                     invisible(future)
[16:05:09.199]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:09.199]                 }
[16:05:09.199]             }
[16:05:09.199]         }
[16:05:09.199]     })
[16:05:09.199]     if (TRUE) {
[16:05:09.199]         base::sink(type = "output", split = FALSE)
[16:05:09.199]         if (TRUE) {
[16:05:09.199]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:09.199]         }
[16:05:09.199]         else {
[16:05:09.199]             ...future.result["stdout"] <- base::list(NULL)
[16:05:09.199]         }
[16:05:09.199]         base::close(...future.stdout)
[16:05:09.199]         ...future.stdout <- NULL
[16:05:09.199]     }
[16:05:09.199]     ...future.result$conditions <- ...future.conditions
[16:05:09.199]     ...future.result$finished <- base::Sys.time()
[16:05:09.199]     ...future.result
[16:05:09.199] }
[16:05:09.201] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:05:09.202] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:05:09.202] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:05:09.202] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:05:09.203] MultisessionFuture started
[16:05:09.203] - Launch lazy future ... done
[16:05:09.203] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:09.204] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:09.204] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:09.205] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:09.205] Searching for globals ... DONE
[16:05:09.205] Resolving globals: TRUE
[16:05:09.205] Resolving any globals that are futures ...
[16:05:09.205] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:09.206] Resolving any globals that are futures ... DONE
[16:05:09.206] Resolving futures part of globals (recursively) ...
[16:05:09.206] resolve() on list ...
[16:05:09.206]  recursive: 99
[16:05:09.206]  length: 1
[16:05:09.206]  elements: ‘ii’
[16:05:09.207]  length: 0 (resolved future 1)
[16:05:09.207] resolve() on list ... DONE
[16:05:09.207] - globals: [1] ‘ii’
[16:05:09.207] Resolving futures part of globals (recursively) ... DONE
[16:05:09.207] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:09.207] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:09.207] - globals: [1] ‘ii’
[16:05:09.208] 
[16:05:09.208] getGlobalsAndPackages() ... DONE
[16:05:09.208] run() for ‘Future’ ...
[16:05:09.208] - state: ‘created’
[16:05:09.208] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:09.221] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:09.222] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:09.222]   - Field: ‘node’
[16:05:09.222]   - Field: ‘label’
[16:05:09.222]   - Field: ‘local’
[16:05:09.222]   - Field: ‘owner’
[16:05:09.222]   - Field: ‘envir’
[16:05:09.222]   - Field: ‘workers’
[16:05:09.222]   - Field: ‘packages’
[16:05:09.222]   - Field: ‘gc’
[16:05:09.222]   - Field: ‘conditions’
[16:05:09.223]   - Field: ‘persistent’
[16:05:09.223]   - Field: ‘expr’
[16:05:09.223]   - Field: ‘uuid’
[16:05:09.223]   - Field: ‘seed’
[16:05:09.223]   - Field: ‘version’
[16:05:09.223]   - Field: ‘result’
[16:05:09.223]   - Field: ‘asynchronous’
[16:05:09.223]   - Field: ‘calls’
[16:05:09.223]   - Field: ‘globals’
[16:05:09.223]   - Field: ‘stdout’
[16:05:09.224]   - Field: ‘earlySignal’
[16:05:09.224]   - Field: ‘lazy’
[16:05:09.224]   - Field: ‘state’
[16:05:09.224] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:09.224] - Launch lazy future ...
[16:05:09.224] Packages needed by the future expression (n = 0): <none>
[16:05:09.224] Packages needed by future strategies (n = 0): <none>
[16:05:09.225] {
[16:05:09.225]     {
[16:05:09.225]         {
[16:05:09.225]             ...future.startTime <- base::Sys.time()
[16:05:09.225]             {
[16:05:09.225]                 {
[16:05:09.225]                   {
[16:05:09.225]                     {
[16:05:09.225]                       base::local({
[16:05:09.225]                         has_future <- base::requireNamespace("future", 
[16:05:09.225]                           quietly = TRUE)
[16:05:09.225]                         if (has_future) {
[16:05:09.225]                           ns <- base::getNamespace("future")
[16:05:09.225]                           version <- ns[[".package"]][["version"]]
[16:05:09.225]                           if (is.null(version)) 
[16:05:09.225]                             version <- utils::packageVersion("future")
[16:05:09.225]                         }
[16:05:09.225]                         else {
[16:05:09.225]                           version <- NULL
[16:05:09.225]                         }
[16:05:09.225]                         if (!has_future || version < "1.8.0") {
[16:05:09.225]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:09.225]                             "", base::R.version$version.string), 
[16:05:09.225]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:09.225]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:09.225]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:09.225]                               "release", "version")], collapse = " "), 
[16:05:09.225]                             hostname = base::Sys.info()[["nodename"]])
[16:05:09.225]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:09.225]                             info)
[16:05:09.225]                           info <- base::paste(info, collapse = "; ")
[16:05:09.225]                           if (!has_future) {
[16:05:09.225]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:09.225]                               info)
[16:05:09.225]                           }
[16:05:09.225]                           else {
[16:05:09.225]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:09.225]                               info, version)
[16:05:09.225]                           }
[16:05:09.225]                           base::stop(msg)
[16:05:09.225]                         }
[16:05:09.225]                       })
[16:05:09.225]                     }
[16:05:09.225]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:09.225]                     base::options(mc.cores = 1L)
[16:05:09.225]                   }
[16:05:09.225]                   options(future.plan = NULL)
[16:05:09.225]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.225]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:09.225]                 }
[16:05:09.225]                 ...future.workdir <- getwd()
[16:05:09.225]             }
[16:05:09.225]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:09.225]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:09.225]         }
[16:05:09.225]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:09.225]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:09.225]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:09.225]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:09.225]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:09.225]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:09.225]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:09.225]             base::names(...future.oldOptions))
[16:05:09.225]     }
[16:05:09.225]     if (FALSE) {
[16:05:09.225]     }
[16:05:09.225]     else {
[16:05:09.225]         if (TRUE) {
[16:05:09.225]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:09.225]                 open = "w")
[16:05:09.225]         }
[16:05:09.225]         else {
[16:05:09.225]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:09.225]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:09.225]         }
[16:05:09.225]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:09.225]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:09.225]             base::sink(type = "output", split = FALSE)
[16:05:09.225]             base::close(...future.stdout)
[16:05:09.225]         }, add = TRUE)
[16:05:09.225]     }
[16:05:09.225]     ...future.frame <- base::sys.nframe()
[16:05:09.225]     ...future.conditions <- base::list()
[16:05:09.225]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:09.225]     if (FALSE) {
[16:05:09.225]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:09.225]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:09.225]     }
[16:05:09.225]     ...future.result <- base::tryCatch({
[16:05:09.225]         base::withCallingHandlers({
[16:05:09.225]             ...future.value <- base::withVisible(base::local({
[16:05:09.225]                 ...future.makeSendCondition <- base::local({
[16:05:09.225]                   sendCondition <- NULL
[16:05:09.225]                   function(frame = 1L) {
[16:05:09.225]                     if (is.function(sendCondition)) 
[16:05:09.225]                       return(sendCondition)
[16:05:09.225]                     ns <- getNamespace("parallel")
[16:05:09.225]                     if (exists("sendData", mode = "function", 
[16:05:09.225]                       envir = ns)) {
[16:05:09.225]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:09.225]                         envir = ns)
[16:05:09.225]                       envir <- sys.frame(frame)
[16:05:09.225]                       master <- NULL
[16:05:09.225]                       while (!identical(envir, .GlobalEnv) && 
[16:05:09.225]                         !identical(envir, emptyenv())) {
[16:05:09.225]                         if (exists("master", mode = "list", envir = envir, 
[16:05:09.225]                           inherits = FALSE)) {
[16:05:09.225]                           master <- get("master", mode = "list", 
[16:05:09.225]                             envir = envir, inherits = FALSE)
[16:05:09.225]                           if (inherits(master, c("SOCKnode", 
[16:05:09.225]                             "SOCK0node"))) {
[16:05:09.225]                             sendCondition <<- function(cond) {
[16:05:09.225]                               data <- list(type = "VALUE", value = cond, 
[16:05:09.225]                                 success = TRUE)
[16:05:09.225]                               parallel_sendData(master, data)
[16:05:09.225]                             }
[16:05:09.225]                             return(sendCondition)
[16:05:09.225]                           }
[16:05:09.225]                         }
[16:05:09.225]                         frame <- frame + 1L
[16:05:09.225]                         envir <- sys.frame(frame)
[16:05:09.225]                       }
[16:05:09.225]                     }
[16:05:09.225]                     sendCondition <<- function(cond) NULL
[16:05:09.225]                   }
[16:05:09.225]                 })
[16:05:09.225]                 withCallingHandlers({
[16:05:09.225]                   {
[16:05:09.225]                     b <- a * ii
[16:05:09.225]                     a <- 0
[16:05:09.225]                     b
[16:05:09.225]                   }
[16:05:09.225]                 }, immediateCondition = function(cond) {
[16:05:09.225]                   sendCondition <- ...future.makeSendCondition()
[16:05:09.225]                   sendCondition(cond)
[16:05:09.225]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.225]                   {
[16:05:09.225]                     inherits <- base::inherits
[16:05:09.225]                     invokeRestart <- base::invokeRestart
[16:05:09.225]                     is.null <- base::is.null
[16:05:09.225]                     muffled <- FALSE
[16:05:09.225]                     if (inherits(cond, "message")) {
[16:05:09.225]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:09.225]                       if (muffled) 
[16:05:09.225]                         invokeRestart("muffleMessage")
[16:05:09.225]                     }
[16:05:09.225]                     else if (inherits(cond, "warning")) {
[16:05:09.225]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:09.225]                       if (muffled) 
[16:05:09.225]                         invokeRestart("muffleWarning")
[16:05:09.225]                     }
[16:05:09.225]                     else if (inherits(cond, "condition")) {
[16:05:09.225]                       if (!is.null(pattern)) {
[16:05:09.225]                         computeRestarts <- base::computeRestarts
[16:05:09.225]                         grepl <- base::grepl
[16:05:09.225]                         restarts <- computeRestarts(cond)
[16:05:09.225]                         for (restart in restarts) {
[16:05:09.225]                           name <- restart$name
[16:05:09.225]                           if (is.null(name)) 
[16:05:09.225]                             next
[16:05:09.225]                           if (!grepl(pattern, name)) 
[16:05:09.225]                             next
[16:05:09.225]                           invokeRestart(restart)
[16:05:09.225]                           muffled <- TRUE
[16:05:09.225]                           break
[16:05:09.225]                         }
[16:05:09.225]                       }
[16:05:09.225]                     }
[16:05:09.225]                     invisible(muffled)
[16:05:09.225]                   }
[16:05:09.225]                   muffleCondition(cond)
[16:05:09.225]                 })
[16:05:09.225]             }))
[16:05:09.225]             future::FutureResult(value = ...future.value$value, 
[16:05:09.225]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.225]                   ...future.rng), globalenv = if (FALSE) 
[16:05:09.225]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:09.225]                     ...future.globalenv.names))
[16:05:09.225]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:09.225]         }, condition = base::local({
[16:05:09.225]             c <- base::c
[16:05:09.225]             inherits <- base::inherits
[16:05:09.225]             invokeRestart <- base::invokeRestart
[16:05:09.225]             length <- base::length
[16:05:09.225]             list <- base::list
[16:05:09.225]             seq.int <- base::seq.int
[16:05:09.225]             signalCondition <- base::signalCondition
[16:05:09.225]             sys.calls <- base::sys.calls
[16:05:09.225]             `[[` <- base::`[[`
[16:05:09.225]             `+` <- base::`+`
[16:05:09.225]             `<<-` <- base::`<<-`
[16:05:09.225]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:09.225]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:09.225]                   3L)]
[16:05:09.225]             }
[16:05:09.225]             function(cond) {
[16:05:09.225]                 is_error <- inherits(cond, "error")
[16:05:09.225]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:09.225]                   NULL)
[16:05:09.225]                 if (is_error) {
[16:05:09.225]                   sessionInformation <- function() {
[16:05:09.225]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:09.225]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:09.225]                       search = base::search(), system = base::Sys.info())
[16:05:09.225]                   }
[16:05:09.225]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.225]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:09.225]                     cond$call), session = sessionInformation(), 
[16:05:09.225]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:09.225]                   signalCondition(cond)
[16:05:09.225]                 }
[16:05:09.225]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:09.225]                 "immediateCondition"))) {
[16:05:09.225]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:09.225]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.225]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:09.225]                   if (TRUE && !signal) {
[16:05:09.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.225]                     {
[16:05:09.225]                       inherits <- base::inherits
[16:05:09.225]                       invokeRestart <- base::invokeRestart
[16:05:09.225]                       is.null <- base::is.null
[16:05:09.225]                       muffled <- FALSE
[16:05:09.225]                       if (inherits(cond, "message")) {
[16:05:09.225]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.225]                         if (muffled) 
[16:05:09.225]                           invokeRestart("muffleMessage")
[16:05:09.225]                       }
[16:05:09.225]                       else if (inherits(cond, "warning")) {
[16:05:09.225]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.225]                         if (muffled) 
[16:05:09.225]                           invokeRestart("muffleWarning")
[16:05:09.225]                       }
[16:05:09.225]                       else if (inherits(cond, "condition")) {
[16:05:09.225]                         if (!is.null(pattern)) {
[16:05:09.225]                           computeRestarts <- base::computeRestarts
[16:05:09.225]                           grepl <- base::grepl
[16:05:09.225]                           restarts <- computeRestarts(cond)
[16:05:09.225]                           for (restart in restarts) {
[16:05:09.225]                             name <- restart$name
[16:05:09.225]                             if (is.null(name)) 
[16:05:09.225]                               next
[16:05:09.225]                             if (!grepl(pattern, name)) 
[16:05:09.225]                               next
[16:05:09.225]                             invokeRestart(restart)
[16:05:09.225]                             muffled <- TRUE
[16:05:09.225]                             break
[16:05:09.225]                           }
[16:05:09.225]                         }
[16:05:09.225]                       }
[16:05:09.225]                       invisible(muffled)
[16:05:09.225]                     }
[16:05:09.225]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.225]                   }
[16:05:09.225]                 }
[16:05:09.225]                 else {
[16:05:09.225]                   if (TRUE) {
[16:05:09.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.225]                     {
[16:05:09.225]                       inherits <- base::inherits
[16:05:09.225]                       invokeRestart <- base::invokeRestart
[16:05:09.225]                       is.null <- base::is.null
[16:05:09.225]                       muffled <- FALSE
[16:05:09.225]                       if (inherits(cond, "message")) {
[16:05:09.225]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.225]                         if (muffled) 
[16:05:09.225]                           invokeRestart("muffleMessage")
[16:05:09.225]                       }
[16:05:09.225]                       else if (inherits(cond, "warning")) {
[16:05:09.225]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.225]                         if (muffled) 
[16:05:09.225]                           invokeRestart("muffleWarning")
[16:05:09.225]                       }
[16:05:09.225]                       else if (inherits(cond, "condition")) {
[16:05:09.225]                         if (!is.null(pattern)) {
[16:05:09.225]                           computeRestarts <- base::computeRestarts
[16:05:09.225]                           grepl <- base::grepl
[16:05:09.225]                           restarts <- computeRestarts(cond)
[16:05:09.225]                           for (restart in restarts) {
[16:05:09.225]                             name <- restart$name
[16:05:09.225]                             if (is.null(name)) 
[16:05:09.225]                               next
[16:05:09.225]                             if (!grepl(pattern, name)) 
[16:05:09.225]                               next
[16:05:09.225]                             invokeRestart(restart)
[16:05:09.225]                             muffled <- TRUE
[16:05:09.225]                             break
[16:05:09.225]                           }
[16:05:09.225]                         }
[16:05:09.225]                       }
[16:05:09.225]                       invisible(muffled)
[16:05:09.225]                     }
[16:05:09.225]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.225]                   }
[16:05:09.225]                 }
[16:05:09.225]             }
[16:05:09.225]         }))
[16:05:09.225]     }, error = function(ex) {
[16:05:09.225]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:09.225]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.225]                 ...future.rng), started = ...future.startTime, 
[16:05:09.225]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:09.225]             version = "1.8"), class = "FutureResult")
[16:05:09.225]     }, finally = {
[16:05:09.225]         if (!identical(...future.workdir, getwd())) 
[16:05:09.225]             setwd(...future.workdir)
[16:05:09.225]         {
[16:05:09.225]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:09.225]                 ...future.oldOptions$nwarnings <- NULL
[16:05:09.225]             }
[16:05:09.225]             base::options(...future.oldOptions)
[16:05:09.225]             if (.Platform$OS.type == "windows") {
[16:05:09.225]                 old_names <- names(...future.oldEnvVars)
[16:05:09.225]                 envs <- base::Sys.getenv()
[16:05:09.225]                 names <- names(envs)
[16:05:09.225]                 common <- intersect(names, old_names)
[16:05:09.225]                 added <- setdiff(names, old_names)
[16:05:09.225]                 removed <- setdiff(old_names, names)
[16:05:09.225]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:09.225]                   envs[common]]
[16:05:09.225]                 NAMES <- toupper(changed)
[16:05:09.225]                 args <- list()
[16:05:09.225]                 for (kk in seq_along(NAMES)) {
[16:05:09.225]                   name <- changed[[kk]]
[16:05:09.225]                   NAME <- NAMES[[kk]]
[16:05:09.225]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.225]                     next
[16:05:09.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.225]                 }
[16:05:09.225]                 NAMES <- toupper(added)
[16:05:09.225]                 for (kk in seq_along(NAMES)) {
[16:05:09.225]                   name <- added[[kk]]
[16:05:09.225]                   NAME <- NAMES[[kk]]
[16:05:09.225]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.225]                     next
[16:05:09.225]                   args[[name]] <- ""
[16:05:09.225]                 }
[16:05:09.225]                 NAMES <- toupper(removed)
[16:05:09.225]                 for (kk in seq_along(NAMES)) {
[16:05:09.225]                   name <- removed[[kk]]
[16:05:09.225]                   NAME <- NAMES[[kk]]
[16:05:09.225]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.225]                     next
[16:05:09.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.225]                 }
[16:05:09.225]                 if (length(args) > 0) 
[16:05:09.225]                   base::do.call(base::Sys.setenv, args = args)
[16:05:09.225]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:09.225]             }
[16:05:09.225]             else {
[16:05:09.225]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:09.225]             }
[16:05:09.225]             {
[16:05:09.225]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:09.225]                   0L) {
[16:05:09.225]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:09.225]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:09.225]                   base::options(opts)
[16:05:09.225]                 }
[16:05:09.225]                 {
[16:05:09.225]                   {
[16:05:09.225]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:09.225]                     NULL
[16:05:09.225]                   }
[16:05:09.225]                   options(future.plan = NULL)
[16:05:09.225]                   if (is.na(NA_character_)) 
[16:05:09.225]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.225]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:09.225]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:09.225]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:09.225]                     envir = parent.frame()) 
[16:05:09.225]                   {
[16:05:09.225]                     if (is.function(workers)) 
[16:05:09.225]                       workers <- workers()
[16:05:09.225]                     workers <- structure(as.integer(workers), 
[16:05:09.225]                       class = class(workers))
[16:05:09.225]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:09.225]                       workers >= 1)
[16:05:09.225]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:09.225]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:09.225]                     }
[16:05:09.225]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:09.225]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:09.225]                       envir = envir)
[16:05:09.225]                     if (!future$lazy) 
[16:05:09.225]                       future <- run(future)
[16:05:09.225]                     invisible(future)
[16:05:09.225]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:09.225]                 }
[16:05:09.225]             }
[16:05:09.225]         }
[16:05:09.225]     })
[16:05:09.225]     if (TRUE) {
[16:05:09.225]         base::sink(type = "output", split = FALSE)
[16:05:09.225]         if (TRUE) {
[16:05:09.225]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:09.225]         }
[16:05:09.225]         else {
[16:05:09.225]             ...future.result["stdout"] <- base::list(NULL)
[16:05:09.225]         }
[16:05:09.225]         base::close(...future.stdout)
[16:05:09.225]         ...future.stdout <- NULL
[16:05:09.225]     }
[16:05:09.225]     ...future.result$conditions <- ...future.conditions
[16:05:09.225]     ...future.result$finished <- base::Sys.time()
[16:05:09.225]     ...future.result
[16:05:09.225] }
[16:05:09.278] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[16:05:09.278] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[16:05:09.278] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[16:05:09.279] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[16:05:09.279] MultisessionFuture started
[16:05:09.279] - Launch lazy future ... done
[16:05:09.279] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:09.280] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:09.280] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:09.282] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:09.282] Searching for globals ... DONE
[16:05:09.282] Resolving globals: TRUE
[16:05:09.282] Resolving any globals that are futures ...
[16:05:09.282] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:09.282] Resolving any globals that are futures ... DONE
[16:05:09.282] Resolving futures part of globals (recursively) ...
[16:05:09.283] resolve() on list ...
[16:05:09.283]  recursive: 99
[16:05:09.283]  length: 1
[16:05:09.283]  elements: ‘ii’
[16:05:09.283]  length: 0 (resolved future 1)
[16:05:09.283] resolve() on list ... DONE
[16:05:09.283] - globals: [1] ‘ii’
[16:05:09.283] Resolving futures part of globals (recursively) ... DONE
[16:05:09.284] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:09.284] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:09.284] - globals: [1] ‘ii’
[16:05:09.284] 
[16:05:09.284] getGlobalsAndPackages() ... DONE
[16:05:09.284] run() for ‘Future’ ...
[16:05:09.285] - state: ‘created’
[16:05:09.285] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:09.298] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:09.298] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:09.299]   - Field: ‘node’
[16:05:09.299]   - Field: ‘label’
[16:05:09.299]   - Field: ‘local’
[16:05:09.299]   - Field: ‘owner’
[16:05:09.299]   - Field: ‘envir’
[16:05:09.299]   - Field: ‘workers’
[16:05:09.299]   - Field: ‘packages’
[16:05:09.299]   - Field: ‘gc’
[16:05:09.299]   - Field: ‘conditions’
[16:05:09.299]   - Field: ‘persistent’
[16:05:09.300]   - Field: ‘expr’
[16:05:09.300]   - Field: ‘uuid’
[16:05:09.300]   - Field: ‘seed’
[16:05:09.300]   - Field: ‘version’
[16:05:09.300]   - Field: ‘result’
[16:05:09.300]   - Field: ‘asynchronous’
[16:05:09.300]   - Field: ‘calls’
[16:05:09.300]   - Field: ‘globals’
[16:05:09.300]   - Field: ‘stdout’
[16:05:09.300]   - Field: ‘earlySignal’
[16:05:09.300]   - Field: ‘lazy’
[16:05:09.301]   - Field: ‘state’
[16:05:09.301] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:09.301] - Launch lazy future ...
[16:05:09.301] Packages needed by the future expression (n = 0): <none>
[16:05:09.301] Packages needed by future strategies (n = 0): <none>
[16:05:09.302] {
[16:05:09.302]     {
[16:05:09.302]         {
[16:05:09.302]             ...future.startTime <- base::Sys.time()
[16:05:09.302]             {
[16:05:09.302]                 {
[16:05:09.302]                   {
[16:05:09.302]                     {
[16:05:09.302]                       base::local({
[16:05:09.302]                         has_future <- base::requireNamespace("future", 
[16:05:09.302]                           quietly = TRUE)
[16:05:09.302]                         if (has_future) {
[16:05:09.302]                           ns <- base::getNamespace("future")
[16:05:09.302]                           version <- ns[[".package"]][["version"]]
[16:05:09.302]                           if (is.null(version)) 
[16:05:09.302]                             version <- utils::packageVersion("future")
[16:05:09.302]                         }
[16:05:09.302]                         else {
[16:05:09.302]                           version <- NULL
[16:05:09.302]                         }
[16:05:09.302]                         if (!has_future || version < "1.8.0") {
[16:05:09.302]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:09.302]                             "", base::R.version$version.string), 
[16:05:09.302]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:09.302]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:09.302]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:09.302]                               "release", "version")], collapse = " "), 
[16:05:09.302]                             hostname = base::Sys.info()[["nodename"]])
[16:05:09.302]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:09.302]                             info)
[16:05:09.302]                           info <- base::paste(info, collapse = "; ")
[16:05:09.302]                           if (!has_future) {
[16:05:09.302]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:09.302]                               info)
[16:05:09.302]                           }
[16:05:09.302]                           else {
[16:05:09.302]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:09.302]                               info, version)
[16:05:09.302]                           }
[16:05:09.302]                           base::stop(msg)
[16:05:09.302]                         }
[16:05:09.302]                       })
[16:05:09.302]                     }
[16:05:09.302]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:09.302]                     base::options(mc.cores = 1L)
[16:05:09.302]                   }
[16:05:09.302]                   options(future.plan = NULL)
[16:05:09.302]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.302]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:09.302]                 }
[16:05:09.302]                 ...future.workdir <- getwd()
[16:05:09.302]             }
[16:05:09.302]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:09.302]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:09.302]         }
[16:05:09.302]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:09.302]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:09.302]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:09.302]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:09.302]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:09.302]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:09.302]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:09.302]             base::names(...future.oldOptions))
[16:05:09.302]     }
[16:05:09.302]     if (FALSE) {
[16:05:09.302]     }
[16:05:09.302]     else {
[16:05:09.302]         if (TRUE) {
[16:05:09.302]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:09.302]                 open = "w")
[16:05:09.302]         }
[16:05:09.302]         else {
[16:05:09.302]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:09.302]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:09.302]         }
[16:05:09.302]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:09.302]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:09.302]             base::sink(type = "output", split = FALSE)
[16:05:09.302]             base::close(...future.stdout)
[16:05:09.302]         }, add = TRUE)
[16:05:09.302]     }
[16:05:09.302]     ...future.frame <- base::sys.nframe()
[16:05:09.302]     ...future.conditions <- base::list()
[16:05:09.302]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:09.302]     if (FALSE) {
[16:05:09.302]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:09.302]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:09.302]     }
[16:05:09.302]     ...future.result <- base::tryCatch({
[16:05:09.302]         base::withCallingHandlers({
[16:05:09.302]             ...future.value <- base::withVisible(base::local({
[16:05:09.302]                 ...future.makeSendCondition <- base::local({
[16:05:09.302]                   sendCondition <- NULL
[16:05:09.302]                   function(frame = 1L) {
[16:05:09.302]                     if (is.function(sendCondition)) 
[16:05:09.302]                       return(sendCondition)
[16:05:09.302]                     ns <- getNamespace("parallel")
[16:05:09.302]                     if (exists("sendData", mode = "function", 
[16:05:09.302]                       envir = ns)) {
[16:05:09.302]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:09.302]                         envir = ns)
[16:05:09.302]                       envir <- sys.frame(frame)
[16:05:09.302]                       master <- NULL
[16:05:09.302]                       while (!identical(envir, .GlobalEnv) && 
[16:05:09.302]                         !identical(envir, emptyenv())) {
[16:05:09.302]                         if (exists("master", mode = "list", envir = envir, 
[16:05:09.302]                           inherits = FALSE)) {
[16:05:09.302]                           master <- get("master", mode = "list", 
[16:05:09.302]                             envir = envir, inherits = FALSE)
[16:05:09.302]                           if (inherits(master, c("SOCKnode", 
[16:05:09.302]                             "SOCK0node"))) {
[16:05:09.302]                             sendCondition <<- function(cond) {
[16:05:09.302]                               data <- list(type = "VALUE", value = cond, 
[16:05:09.302]                                 success = TRUE)
[16:05:09.302]                               parallel_sendData(master, data)
[16:05:09.302]                             }
[16:05:09.302]                             return(sendCondition)
[16:05:09.302]                           }
[16:05:09.302]                         }
[16:05:09.302]                         frame <- frame + 1L
[16:05:09.302]                         envir <- sys.frame(frame)
[16:05:09.302]                       }
[16:05:09.302]                     }
[16:05:09.302]                     sendCondition <<- function(cond) NULL
[16:05:09.302]                   }
[16:05:09.302]                 })
[16:05:09.302]                 withCallingHandlers({
[16:05:09.302]                   {
[16:05:09.302]                     b <- a * ii
[16:05:09.302]                     a <- 0
[16:05:09.302]                     b
[16:05:09.302]                   }
[16:05:09.302]                 }, immediateCondition = function(cond) {
[16:05:09.302]                   sendCondition <- ...future.makeSendCondition()
[16:05:09.302]                   sendCondition(cond)
[16:05:09.302]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.302]                   {
[16:05:09.302]                     inherits <- base::inherits
[16:05:09.302]                     invokeRestart <- base::invokeRestart
[16:05:09.302]                     is.null <- base::is.null
[16:05:09.302]                     muffled <- FALSE
[16:05:09.302]                     if (inherits(cond, "message")) {
[16:05:09.302]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:09.302]                       if (muffled) 
[16:05:09.302]                         invokeRestart("muffleMessage")
[16:05:09.302]                     }
[16:05:09.302]                     else if (inherits(cond, "warning")) {
[16:05:09.302]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:09.302]                       if (muffled) 
[16:05:09.302]                         invokeRestart("muffleWarning")
[16:05:09.302]                     }
[16:05:09.302]                     else if (inherits(cond, "condition")) {
[16:05:09.302]                       if (!is.null(pattern)) {
[16:05:09.302]                         computeRestarts <- base::computeRestarts
[16:05:09.302]                         grepl <- base::grepl
[16:05:09.302]                         restarts <- computeRestarts(cond)
[16:05:09.302]                         for (restart in restarts) {
[16:05:09.302]                           name <- restart$name
[16:05:09.302]                           if (is.null(name)) 
[16:05:09.302]                             next
[16:05:09.302]                           if (!grepl(pattern, name)) 
[16:05:09.302]                             next
[16:05:09.302]                           invokeRestart(restart)
[16:05:09.302]                           muffled <- TRUE
[16:05:09.302]                           break
[16:05:09.302]                         }
[16:05:09.302]                       }
[16:05:09.302]                     }
[16:05:09.302]                     invisible(muffled)
[16:05:09.302]                   }
[16:05:09.302]                   muffleCondition(cond)
[16:05:09.302]                 })
[16:05:09.302]             }))
[16:05:09.302]             future::FutureResult(value = ...future.value$value, 
[16:05:09.302]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.302]                   ...future.rng), globalenv = if (FALSE) 
[16:05:09.302]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:09.302]                     ...future.globalenv.names))
[16:05:09.302]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:09.302]         }, condition = base::local({
[16:05:09.302]             c <- base::c
[16:05:09.302]             inherits <- base::inherits
[16:05:09.302]             invokeRestart <- base::invokeRestart
[16:05:09.302]             length <- base::length
[16:05:09.302]             list <- base::list
[16:05:09.302]             seq.int <- base::seq.int
[16:05:09.302]             signalCondition <- base::signalCondition
[16:05:09.302]             sys.calls <- base::sys.calls
[16:05:09.302]             `[[` <- base::`[[`
[16:05:09.302]             `+` <- base::`+`
[16:05:09.302]             `<<-` <- base::`<<-`
[16:05:09.302]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:09.302]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:09.302]                   3L)]
[16:05:09.302]             }
[16:05:09.302]             function(cond) {
[16:05:09.302]                 is_error <- inherits(cond, "error")
[16:05:09.302]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:09.302]                   NULL)
[16:05:09.302]                 if (is_error) {
[16:05:09.302]                   sessionInformation <- function() {
[16:05:09.302]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:09.302]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:09.302]                       search = base::search(), system = base::Sys.info())
[16:05:09.302]                   }
[16:05:09.302]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.302]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:09.302]                     cond$call), session = sessionInformation(), 
[16:05:09.302]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:09.302]                   signalCondition(cond)
[16:05:09.302]                 }
[16:05:09.302]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:09.302]                 "immediateCondition"))) {
[16:05:09.302]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:09.302]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.302]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:09.302]                   if (TRUE && !signal) {
[16:05:09.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.302]                     {
[16:05:09.302]                       inherits <- base::inherits
[16:05:09.302]                       invokeRestart <- base::invokeRestart
[16:05:09.302]                       is.null <- base::is.null
[16:05:09.302]                       muffled <- FALSE
[16:05:09.302]                       if (inherits(cond, "message")) {
[16:05:09.302]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.302]                         if (muffled) 
[16:05:09.302]                           invokeRestart("muffleMessage")
[16:05:09.302]                       }
[16:05:09.302]                       else if (inherits(cond, "warning")) {
[16:05:09.302]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.302]                         if (muffled) 
[16:05:09.302]                           invokeRestart("muffleWarning")
[16:05:09.302]                       }
[16:05:09.302]                       else if (inherits(cond, "condition")) {
[16:05:09.302]                         if (!is.null(pattern)) {
[16:05:09.302]                           computeRestarts <- base::computeRestarts
[16:05:09.302]                           grepl <- base::grepl
[16:05:09.302]                           restarts <- computeRestarts(cond)
[16:05:09.302]                           for (restart in restarts) {
[16:05:09.302]                             name <- restart$name
[16:05:09.302]                             if (is.null(name)) 
[16:05:09.302]                               next
[16:05:09.302]                             if (!grepl(pattern, name)) 
[16:05:09.302]                               next
[16:05:09.302]                             invokeRestart(restart)
[16:05:09.302]                             muffled <- TRUE
[16:05:09.302]                             break
[16:05:09.302]                           }
[16:05:09.302]                         }
[16:05:09.302]                       }
[16:05:09.302]                       invisible(muffled)
[16:05:09.302]                     }
[16:05:09.302]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.302]                   }
[16:05:09.302]                 }
[16:05:09.302]                 else {
[16:05:09.302]                   if (TRUE) {
[16:05:09.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.302]                     {
[16:05:09.302]                       inherits <- base::inherits
[16:05:09.302]                       invokeRestart <- base::invokeRestart
[16:05:09.302]                       is.null <- base::is.null
[16:05:09.302]                       muffled <- FALSE
[16:05:09.302]                       if (inherits(cond, "message")) {
[16:05:09.302]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.302]                         if (muffled) 
[16:05:09.302]                           invokeRestart("muffleMessage")
[16:05:09.302]                       }
[16:05:09.302]                       else if (inherits(cond, "warning")) {
[16:05:09.302]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.302]                         if (muffled) 
[16:05:09.302]                           invokeRestart("muffleWarning")
[16:05:09.302]                       }
[16:05:09.302]                       else if (inherits(cond, "condition")) {
[16:05:09.302]                         if (!is.null(pattern)) {
[16:05:09.302]                           computeRestarts <- base::computeRestarts
[16:05:09.302]                           grepl <- base::grepl
[16:05:09.302]                           restarts <- computeRestarts(cond)
[16:05:09.302]                           for (restart in restarts) {
[16:05:09.302]                             name <- restart$name
[16:05:09.302]                             if (is.null(name)) 
[16:05:09.302]                               next
[16:05:09.302]                             if (!grepl(pattern, name)) 
[16:05:09.302]                               next
[16:05:09.302]                             invokeRestart(restart)
[16:05:09.302]                             muffled <- TRUE
[16:05:09.302]                             break
[16:05:09.302]                           }
[16:05:09.302]                         }
[16:05:09.302]                       }
[16:05:09.302]                       invisible(muffled)
[16:05:09.302]                     }
[16:05:09.302]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.302]                   }
[16:05:09.302]                 }
[16:05:09.302]             }
[16:05:09.302]         }))
[16:05:09.302]     }, error = function(ex) {
[16:05:09.302]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:09.302]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.302]                 ...future.rng), started = ...future.startTime, 
[16:05:09.302]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:09.302]             version = "1.8"), class = "FutureResult")
[16:05:09.302]     }, finally = {
[16:05:09.302]         if (!identical(...future.workdir, getwd())) 
[16:05:09.302]             setwd(...future.workdir)
[16:05:09.302]         {
[16:05:09.302]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:09.302]                 ...future.oldOptions$nwarnings <- NULL
[16:05:09.302]             }
[16:05:09.302]             base::options(...future.oldOptions)
[16:05:09.302]             if (.Platform$OS.type == "windows") {
[16:05:09.302]                 old_names <- names(...future.oldEnvVars)
[16:05:09.302]                 envs <- base::Sys.getenv()
[16:05:09.302]                 names <- names(envs)
[16:05:09.302]                 common <- intersect(names, old_names)
[16:05:09.302]                 added <- setdiff(names, old_names)
[16:05:09.302]                 removed <- setdiff(old_names, names)
[16:05:09.302]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:09.302]                   envs[common]]
[16:05:09.302]                 NAMES <- toupper(changed)
[16:05:09.302]                 args <- list()
[16:05:09.302]                 for (kk in seq_along(NAMES)) {
[16:05:09.302]                   name <- changed[[kk]]
[16:05:09.302]                   NAME <- NAMES[[kk]]
[16:05:09.302]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.302]                     next
[16:05:09.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.302]                 }
[16:05:09.302]                 NAMES <- toupper(added)
[16:05:09.302]                 for (kk in seq_along(NAMES)) {
[16:05:09.302]                   name <- added[[kk]]
[16:05:09.302]                   NAME <- NAMES[[kk]]
[16:05:09.302]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.302]                     next
[16:05:09.302]                   args[[name]] <- ""
[16:05:09.302]                 }
[16:05:09.302]                 NAMES <- toupper(removed)
[16:05:09.302]                 for (kk in seq_along(NAMES)) {
[16:05:09.302]                   name <- removed[[kk]]
[16:05:09.302]                   NAME <- NAMES[[kk]]
[16:05:09.302]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.302]                     next
[16:05:09.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.302]                 }
[16:05:09.302]                 if (length(args) > 0) 
[16:05:09.302]                   base::do.call(base::Sys.setenv, args = args)
[16:05:09.302]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:09.302]             }
[16:05:09.302]             else {
[16:05:09.302]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:09.302]             }
[16:05:09.302]             {
[16:05:09.302]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:09.302]                   0L) {
[16:05:09.302]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:09.302]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:09.302]                   base::options(opts)
[16:05:09.302]                 }
[16:05:09.302]                 {
[16:05:09.302]                   {
[16:05:09.302]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:09.302]                     NULL
[16:05:09.302]                   }
[16:05:09.302]                   options(future.plan = NULL)
[16:05:09.302]                   if (is.na(NA_character_)) 
[16:05:09.302]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.302]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:09.302]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:09.302]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:09.302]                     envir = parent.frame()) 
[16:05:09.302]                   {
[16:05:09.302]                     if (is.function(workers)) 
[16:05:09.302]                       workers <- workers()
[16:05:09.302]                     workers <- structure(as.integer(workers), 
[16:05:09.302]                       class = class(workers))
[16:05:09.302]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:09.302]                       workers >= 1)
[16:05:09.302]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:09.302]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:09.302]                     }
[16:05:09.302]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:09.302]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:09.302]                       envir = envir)
[16:05:09.302]                     if (!future$lazy) 
[16:05:09.302]                       future <- run(future)
[16:05:09.302]                     invisible(future)
[16:05:09.302]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:09.302]                 }
[16:05:09.302]             }
[16:05:09.302]         }
[16:05:09.302]     })
[16:05:09.302]     if (TRUE) {
[16:05:09.302]         base::sink(type = "output", split = FALSE)
[16:05:09.302]         if (TRUE) {
[16:05:09.302]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:09.302]         }
[16:05:09.302]         else {
[16:05:09.302]             ...future.result["stdout"] <- base::list(NULL)
[16:05:09.302]         }
[16:05:09.302]         base::close(...future.stdout)
[16:05:09.302]         ...future.stdout <- NULL
[16:05:09.302]     }
[16:05:09.302]     ...future.result$conditions <- ...future.conditions
[16:05:09.302]     ...future.result$finished <- base::Sys.time()
[16:05:09.302]     ...future.result
[16:05:09.302] }
[16:05:09.304] Poll #1 (0): usedNodes() = 2, workers = 2
[16:05:09.315] receiveMessageFromWorker() for ClusterFuture ...
[16:05:09.315] - Validating connection of MultisessionFuture
[16:05:09.315] - received message: FutureResult
[16:05:09.315] - Received FutureResult
[16:05:09.315] - Erased future from FutureRegistry
[16:05:09.316] result() for ClusterFuture ...
[16:05:09.316] - result already collected: FutureResult
[16:05:09.316] result() for ClusterFuture ... done
[16:05:09.316] signalConditions() ...
[16:05:09.316]  - include = ‘immediateCondition’
[16:05:09.316]  - exclude = 
[16:05:09.316]  - resignal = FALSE
[16:05:09.316]  - Number of conditions: 1
[16:05:09.316] signalConditions() ... done
[16:05:09.316] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:09.317] result() for ClusterFuture ...
[16:05:09.317] - result already collected: FutureResult
[16:05:09.317] result() for ClusterFuture ... done
[16:05:09.317] result() for ClusterFuture ...
[16:05:09.317] - result already collected: FutureResult
[16:05:09.317] result() for ClusterFuture ... done
[16:05:09.317] signalConditions() ...
[16:05:09.317]  - include = ‘immediateCondition’
[16:05:09.317]  - exclude = 
[16:05:09.317]  - resignal = FALSE
[16:05:09.317]  - Number of conditions: 1
[16:05:09.317] signalConditions() ... done
[16:05:09.318] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:05:09.318] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:05:09.319] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:05:09.319] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:05:09.319] MultisessionFuture started
[16:05:09.320] - Launch lazy future ... done
[16:05:09.320] run() for ‘MultisessionFuture’ ... done
[16:05:09.320] result() for ClusterFuture ...
[16:05:09.320] - result already collected: FutureResult
[16:05:09.320] result() for ClusterFuture ... done
[16:05:09.320] result() for ClusterFuture ...
[16:05:09.320] - result already collected: FutureResult
[16:05:09.320] result() for ClusterFuture ... done
[16:05:09.321] signalConditions() ...
[16:05:09.321]  - include = ‘immediateCondition’
[16:05:09.321]  - exclude = 
[16:05:09.321]  - resignal = FALSE
[16:05:09.321]  - Number of conditions: 1
[16:05:09.321] signalConditions() ... done
[16:05:09.321] Future state: ‘finished’
[16:05:09.321] result() for ClusterFuture ...
[16:05:09.321] - result already collected: FutureResult
[16:05:09.321] result() for ClusterFuture ... done
[16:05:09.321] signalConditions() ...
[16:05:09.322]  - include = ‘condition’
[16:05:09.322]  - exclude = ‘immediateCondition’
[16:05:09.322]  - resignal = TRUE
[16:05:09.322]  - Number of conditions: 1
[16:05:09.322]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:05:09.322] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "11666ca4073c" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:05:09"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:09.337] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:09.337] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:09.339] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:09.339] Searching for globals ... DONE
[16:05:09.339] Resolving globals: TRUE
[16:05:09.339] Resolving any globals that are futures ...
[16:05:09.339] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:09.339] Resolving any globals that are futures ... DONE
[16:05:09.339] Resolving futures part of globals (recursively) ...
[16:05:09.340] resolve() on list ...
[16:05:09.340]  recursive: 99
[16:05:09.340]  length: 1
[16:05:09.340]  elements: ‘ii’
[16:05:09.340]  length: 0 (resolved future 1)
[16:05:09.340] resolve() on list ... DONE
[16:05:09.340] - globals: [1] ‘ii’
[16:05:09.340] Resolving futures part of globals (recursively) ... DONE
[16:05:09.340] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:09.341] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:09.341] - globals: [1] ‘ii’
[16:05:09.341] 
[16:05:09.341] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:09.342] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:09.342] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:09.343] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:09.343] Searching for globals ... DONE
[16:05:09.343] Resolving globals: TRUE
[16:05:09.343] Resolving any globals that are futures ...
[16:05:09.343] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:09.344] Resolving any globals that are futures ... DONE
[16:05:09.344] Resolving futures part of globals (recursively) ...
[16:05:09.344] resolve() on list ...
[16:05:09.344]  recursive: 99
[16:05:09.344]  length: 1
[16:05:09.344]  elements: ‘ii’
[16:05:09.344]  length: 0 (resolved future 1)
[16:05:09.345] resolve() on list ... DONE
[16:05:09.345] - globals: [1] ‘ii’
[16:05:09.345] Resolving futures part of globals (recursively) ... DONE
[16:05:09.345] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:09.345] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:09.345] - globals: [1] ‘ii’
[16:05:09.345] 
[16:05:09.346] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:09.346] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:09.346] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:09.347] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:09.348] Searching for globals ... DONE
[16:05:09.348] Resolving globals: TRUE
[16:05:09.348] Resolving any globals that are futures ...
[16:05:09.348] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:05:09.348] Resolving any globals that are futures ... DONE
[16:05:09.348] Resolving futures part of globals (recursively) ...
[16:05:09.348] resolve() on list ...
[16:05:09.349]  recursive: 99
[16:05:09.349]  length: 1
[16:05:09.349]  elements: ‘ii’
[16:05:09.349]  length: 0 (resolved future 1)
[16:05:09.349] resolve() on list ... DONE
[16:05:09.349] - globals: [1] ‘ii’
[16:05:09.349] Resolving futures part of globals (recursively) ... DONE
[16:05:09.349] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:09.350] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:09.350] - globals: [1] ‘ii’
[16:05:09.350] 
[16:05:09.350] getGlobalsAndPackages() ... DONE
[16:05:09.350] run() for ‘Future’ ...
[16:05:09.350] - state: ‘created’
[16:05:09.350] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:09.366] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:09.366] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:09.366]   - Field: ‘node’
[16:05:09.366]   - Field: ‘label’
[16:05:09.366]   - Field: ‘local’
[16:05:09.367]   - Field: ‘owner’
[16:05:09.367]   - Field: ‘envir’
[16:05:09.367]   - Field: ‘workers’
[16:05:09.367]   - Field: ‘packages’
[16:05:09.367]   - Field: ‘gc’
[16:05:09.367]   - Field: ‘conditions’
[16:05:09.367]   - Field: ‘persistent’
[16:05:09.368]   - Field: ‘expr’
[16:05:09.368]   - Field: ‘uuid’
[16:05:09.368]   - Field: ‘seed’
[16:05:09.368]   - Field: ‘version’
[16:05:09.368]   - Field: ‘result’
[16:05:09.368]   - Field: ‘asynchronous’
[16:05:09.368]   - Field: ‘calls’
[16:05:09.369]   - Field: ‘globals’
[16:05:09.369]   - Field: ‘stdout’
[16:05:09.369]   - Field: ‘earlySignal’
[16:05:09.369]   - Field: ‘lazy’
[16:05:09.369]   - Field: ‘state’
[16:05:09.369] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:09.370] - Launch lazy future ...
[16:05:09.370] Packages needed by the future expression (n = 0): <none>
[16:05:09.370] Packages needed by future strategies (n = 0): <none>
[16:05:09.371] {
[16:05:09.371]     {
[16:05:09.371]         {
[16:05:09.371]             ...future.startTime <- base::Sys.time()
[16:05:09.371]             {
[16:05:09.371]                 {
[16:05:09.371]                   {
[16:05:09.371]                     {
[16:05:09.371]                       base::local({
[16:05:09.371]                         has_future <- base::requireNamespace("future", 
[16:05:09.371]                           quietly = TRUE)
[16:05:09.371]                         if (has_future) {
[16:05:09.371]                           ns <- base::getNamespace("future")
[16:05:09.371]                           version <- ns[[".package"]][["version"]]
[16:05:09.371]                           if (is.null(version)) 
[16:05:09.371]                             version <- utils::packageVersion("future")
[16:05:09.371]                         }
[16:05:09.371]                         else {
[16:05:09.371]                           version <- NULL
[16:05:09.371]                         }
[16:05:09.371]                         if (!has_future || version < "1.8.0") {
[16:05:09.371]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:09.371]                             "", base::R.version$version.string), 
[16:05:09.371]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:09.371]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:09.371]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:09.371]                               "release", "version")], collapse = " "), 
[16:05:09.371]                             hostname = base::Sys.info()[["nodename"]])
[16:05:09.371]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:09.371]                             info)
[16:05:09.371]                           info <- base::paste(info, collapse = "; ")
[16:05:09.371]                           if (!has_future) {
[16:05:09.371]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:09.371]                               info)
[16:05:09.371]                           }
[16:05:09.371]                           else {
[16:05:09.371]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:09.371]                               info, version)
[16:05:09.371]                           }
[16:05:09.371]                           base::stop(msg)
[16:05:09.371]                         }
[16:05:09.371]                       })
[16:05:09.371]                     }
[16:05:09.371]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:09.371]                     base::options(mc.cores = 1L)
[16:05:09.371]                   }
[16:05:09.371]                   options(future.plan = NULL)
[16:05:09.371]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.371]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:09.371]                 }
[16:05:09.371]                 ...future.workdir <- getwd()
[16:05:09.371]             }
[16:05:09.371]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:09.371]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:09.371]         }
[16:05:09.371]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:09.371]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:09.371]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:09.371]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:09.371]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:09.371]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:09.371]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:09.371]             base::names(...future.oldOptions))
[16:05:09.371]     }
[16:05:09.371]     if (FALSE) {
[16:05:09.371]     }
[16:05:09.371]     else {
[16:05:09.371]         if (TRUE) {
[16:05:09.371]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:09.371]                 open = "w")
[16:05:09.371]         }
[16:05:09.371]         else {
[16:05:09.371]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:09.371]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:09.371]         }
[16:05:09.371]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:09.371]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:09.371]             base::sink(type = "output", split = FALSE)
[16:05:09.371]             base::close(...future.stdout)
[16:05:09.371]         }, add = TRUE)
[16:05:09.371]     }
[16:05:09.371]     ...future.frame <- base::sys.nframe()
[16:05:09.371]     ...future.conditions <- base::list()
[16:05:09.371]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:09.371]     if (FALSE) {
[16:05:09.371]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:09.371]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:09.371]     }
[16:05:09.371]     ...future.result <- base::tryCatch({
[16:05:09.371]         base::withCallingHandlers({
[16:05:09.371]             ...future.value <- base::withVisible(base::local({
[16:05:09.371]                 ...future.makeSendCondition <- base::local({
[16:05:09.371]                   sendCondition <- NULL
[16:05:09.371]                   function(frame = 1L) {
[16:05:09.371]                     if (is.function(sendCondition)) 
[16:05:09.371]                       return(sendCondition)
[16:05:09.371]                     ns <- getNamespace("parallel")
[16:05:09.371]                     if (exists("sendData", mode = "function", 
[16:05:09.371]                       envir = ns)) {
[16:05:09.371]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:09.371]                         envir = ns)
[16:05:09.371]                       envir <- sys.frame(frame)
[16:05:09.371]                       master <- NULL
[16:05:09.371]                       while (!identical(envir, .GlobalEnv) && 
[16:05:09.371]                         !identical(envir, emptyenv())) {
[16:05:09.371]                         if (exists("master", mode = "list", envir = envir, 
[16:05:09.371]                           inherits = FALSE)) {
[16:05:09.371]                           master <- get("master", mode = "list", 
[16:05:09.371]                             envir = envir, inherits = FALSE)
[16:05:09.371]                           if (inherits(master, c("SOCKnode", 
[16:05:09.371]                             "SOCK0node"))) {
[16:05:09.371]                             sendCondition <<- function(cond) {
[16:05:09.371]                               data <- list(type = "VALUE", value = cond, 
[16:05:09.371]                                 success = TRUE)
[16:05:09.371]                               parallel_sendData(master, data)
[16:05:09.371]                             }
[16:05:09.371]                             return(sendCondition)
[16:05:09.371]                           }
[16:05:09.371]                         }
[16:05:09.371]                         frame <- frame + 1L
[16:05:09.371]                         envir <- sys.frame(frame)
[16:05:09.371]                       }
[16:05:09.371]                     }
[16:05:09.371]                     sendCondition <<- function(cond) NULL
[16:05:09.371]                   }
[16:05:09.371]                 })
[16:05:09.371]                 withCallingHandlers({
[16:05:09.371]                   {
[16:05:09.371]                     b <- a * ii
[16:05:09.371]                     a <- 0
[16:05:09.371]                     b
[16:05:09.371]                   }
[16:05:09.371]                 }, immediateCondition = function(cond) {
[16:05:09.371]                   sendCondition <- ...future.makeSendCondition()
[16:05:09.371]                   sendCondition(cond)
[16:05:09.371]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.371]                   {
[16:05:09.371]                     inherits <- base::inherits
[16:05:09.371]                     invokeRestart <- base::invokeRestart
[16:05:09.371]                     is.null <- base::is.null
[16:05:09.371]                     muffled <- FALSE
[16:05:09.371]                     if (inherits(cond, "message")) {
[16:05:09.371]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:09.371]                       if (muffled) 
[16:05:09.371]                         invokeRestart("muffleMessage")
[16:05:09.371]                     }
[16:05:09.371]                     else if (inherits(cond, "warning")) {
[16:05:09.371]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:09.371]                       if (muffled) 
[16:05:09.371]                         invokeRestart("muffleWarning")
[16:05:09.371]                     }
[16:05:09.371]                     else if (inherits(cond, "condition")) {
[16:05:09.371]                       if (!is.null(pattern)) {
[16:05:09.371]                         computeRestarts <- base::computeRestarts
[16:05:09.371]                         grepl <- base::grepl
[16:05:09.371]                         restarts <- computeRestarts(cond)
[16:05:09.371]                         for (restart in restarts) {
[16:05:09.371]                           name <- restart$name
[16:05:09.371]                           if (is.null(name)) 
[16:05:09.371]                             next
[16:05:09.371]                           if (!grepl(pattern, name)) 
[16:05:09.371]                             next
[16:05:09.371]                           invokeRestart(restart)
[16:05:09.371]                           muffled <- TRUE
[16:05:09.371]                           break
[16:05:09.371]                         }
[16:05:09.371]                       }
[16:05:09.371]                     }
[16:05:09.371]                     invisible(muffled)
[16:05:09.371]                   }
[16:05:09.371]                   muffleCondition(cond)
[16:05:09.371]                 })
[16:05:09.371]             }))
[16:05:09.371]             future::FutureResult(value = ...future.value$value, 
[16:05:09.371]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.371]                   ...future.rng), globalenv = if (FALSE) 
[16:05:09.371]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:09.371]                     ...future.globalenv.names))
[16:05:09.371]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:09.371]         }, condition = base::local({
[16:05:09.371]             c <- base::c
[16:05:09.371]             inherits <- base::inherits
[16:05:09.371]             invokeRestart <- base::invokeRestart
[16:05:09.371]             length <- base::length
[16:05:09.371]             list <- base::list
[16:05:09.371]             seq.int <- base::seq.int
[16:05:09.371]             signalCondition <- base::signalCondition
[16:05:09.371]             sys.calls <- base::sys.calls
[16:05:09.371]             `[[` <- base::`[[`
[16:05:09.371]             `+` <- base::`+`
[16:05:09.371]             `<<-` <- base::`<<-`
[16:05:09.371]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:09.371]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:09.371]                   3L)]
[16:05:09.371]             }
[16:05:09.371]             function(cond) {
[16:05:09.371]                 is_error <- inherits(cond, "error")
[16:05:09.371]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:09.371]                   NULL)
[16:05:09.371]                 if (is_error) {
[16:05:09.371]                   sessionInformation <- function() {
[16:05:09.371]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:09.371]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:09.371]                       search = base::search(), system = base::Sys.info())
[16:05:09.371]                   }
[16:05:09.371]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.371]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:09.371]                     cond$call), session = sessionInformation(), 
[16:05:09.371]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:09.371]                   signalCondition(cond)
[16:05:09.371]                 }
[16:05:09.371]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:09.371]                 "immediateCondition"))) {
[16:05:09.371]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:09.371]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.371]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:09.371]                   if (TRUE && !signal) {
[16:05:09.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.371]                     {
[16:05:09.371]                       inherits <- base::inherits
[16:05:09.371]                       invokeRestart <- base::invokeRestart
[16:05:09.371]                       is.null <- base::is.null
[16:05:09.371]                       muffled <- FALSE
[16:05:09.371]                       if (inherits(cond, "message")) {
[16:05:09.371]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.371]                         if (muffled) 
[16:05:09.371]                           invokeRestart("muffleMessage")
[16:05:09.371]                       }
[16:05:09.371]                       else if (inherits(cond, "warning")) {
[16:05:09.371]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.371]                         if (muffled) 
[16:05:09.371]                           invokeRestart("muffleWarning")
[16:05:09.371]                       }
[16:05:09.371]                       else if (inherits(cond, "condition")) {
[16:05:09.371]                         if (!is.null(pattern)) {
[16:05:09.371]                           computeRestarts <- base::computeRestarts
[16:05:09.371]                           grepl <- base::grepl
[16:05:09.371]                           restarts <- computeRestarts(cond)
[16:05:09.371]                           for (restart in restarts) {
[16:05:09.371]                             name <- restart$name
[16:05:09.371]                             if (is.null(name)) 
[16:05:09.371]                               next
[16:05:09.371]                             if (!grepl(pattern, name)) 
[16:05:09.371]                               next
[16:05:09.371]                             invokeRestart(restart)
[16:05:09.371]                             muffled <- TRUE
[16:05:09.371]                             break
[16:05:09.371]                           }
[16:05:09.371]                         }
[16:05:09.371]                       }
[16:05:09.371]                       invisible(muffled)
[16:05:09.371]                     }
[16:05:09.371]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.371]                   }
[16:05:09.371]                 }
[16:05:09.371]                 else {
[16:05:09.371]                   if (TRUE) {
[16:05:09.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.371]                     {
[16:05:09.371]                       inherits <- base::inherits
[16:05:09.371]                       invokeRestart <- base::invokeRestart
[16:05:09.371]                       is.null <- base::is.null
[16:05:09.371]                       muffled <- FALSE
[16:05:09.371]                       if (inherits(cond, "message")) {
[16:05:09.371]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.371]                         if (muffled) 
[16:05:09.371]                           invokeRestart("muffleMessage")
[16:05:09.371]                       }
[16:05:09.371]                       else if (inherits(cond, "warning")) {
[16:05:09.371]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.371]                         if (muffled) 
[16:05:09.371]                           invokeRestart("muffleWarning")
[16:05:09.371]                       }
[16:05:09.371]                       else if (inherits(cond, "condition")) {
[16:05:09.371]                         if (!is.null(pattern)) {
[16:05:09.371]                           computeRestarts <- base::computeRestarts
[16:05:09.371]                           grepl <- base::grepl
[16:05:09.371]                           restarts <- computeRestarts(cond)
[16:05:09.371]                           for (restart in restarts) {
[16:05:09.371]                             name <- restart$name
[16:05:09.371]                             if (is.null(name)) 
[16:05:09.371]                               next
[16:05:09.371]                             if (!grepl(pattern, name)) 
[16:05:09.371]                               next
[16:05:09.371]                             invokeRestart(restart)
[16:05:09.371]                             muffled <- TRUE
[16:05:09.371]                             break
[16:05:09.371]                           }
[16:05:09.371]                         }
[16:05:09.371]                       }
[16:05:09.371]                       invisible(muffled)
[16:05:09.371]                     }
[16:05:09.371]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.371]                   }
[16:05:09.371]                 }
[16:05:09.371]             }
[16:05:09.371]         }))
[16:05:09.371]     }, error = function(ex) {
[16:05:09.371]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:09.371]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.371]                 ...future.rng), started = ...future.startTime, 
[16:05:09.371]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:09.371]             version = "1.8"), class = "FutureResult")
[16:05:09.371]     }, finally = {
[16:05:09.371]         if (!identical(...future.workdir, getwd())) 
[16:05:09.371]             setwd(...future.workdir)
[16:05:09.371]         {
[16:05:09.371]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:09.371]                 ...future.oldOptions$nwarnings <- NULL
[16:05:09.371]             }
[16:05:09.371]             base::options(...future.oldOptions)
[16:05:09.371]             if (.Platform$OS.type == "windows") {
[16:05:09.371]                 old_names <- names(...future.oldEnvVars)
[16:05:09.371]                 envs <- base::Sys.getenv()
[16:05:09.371]                 names <- names(envs)
[16:05:09.371]                 common <- intersect(names, old_names)
[16:05:09.371]                 added <- setdiff(names, old_names)
[16:05:09.371]                 removed <- setdiff(old_names, names)
[16:05:09.371]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:09.371]                   envs[common]]
[16:05:09.371]                 NAMES <- toupper(changed)
[16:05:09.371]                 args <- list()
[16:05:09.371]                 for (kk in seq_along(NAMES)) {
[16:05:09.371]                   name <- changed[[kk]]
[16:05:09.371]                   NAME <- NAMES[[kk]]
[16:05:09.371]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.371]                     next
[16:05:09.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.371]                 }
[16:05:09.371]                 NAMES <- toupper(added)
[16:05:09.371]                 for (kk in seq_along(NAMES)) {
[16:05:09.371]                   name <- added[[kk]]
[16:05:09.371]                   NAME <- NAMES[[kk]]
[16:05:09.371]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.371]                     next
[16:05:09.371]                   args[[name]] <- ""
[16:05:09.371]                 }
[16:05:09.371]                 NAMES <- toupper(removed)
[16:05:09.371]                 for (kk in seq_along(NAMES)) {
[16:05:09.371]                   name <- removed[[kk]]
[16:05:09.371]                   NAME <- NAMES[[kk]]
[16:05:09.371]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.371]                     next
[16:05:09.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.371]                 }
[16:05:09.371]                 if (length(args) > 0) 
[16:05:09.371]                   base::do.call(base::Sys.setenv, args = args)
[16:05:09.371]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:09.371]             }
[16:05:09.371]             else {
[16:05:09.371]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:09.371]             }
[16:05:09.371]             {
[16:05:09.371]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:09.371]                   0L) {
[16:05:09.371]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:09.371]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:09.371]                   base::options(opts)
[16:05:09.371]                 }
[16:05:09.371]                 {
[16:05:09.371]                   {
[16:05:09.371]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:09.371]                     NULL
[16:05:09.371]                   }
[16:05:09.371]                   options(future.plan = NULL)
[16:05:09.371]                   if (is.na(NA_character_)) 
[16:05:09.371]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.371]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:09.371]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:09.371]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:09.371]                     envir = parent.frame()) 
[16:05:09.371]                   {
[16:05:09.371]                     if (is.function(workers)) 
[16:05:09.371]                       workers <- workers()
[16:05:09.371]                     workers <- structure(as.integer(workers), 
[16:05:09.371]                       class = class(workers))
[16:05:09.371]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:09.371]                       workers >= 1)
[16:05:09.371]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:09.371]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:09.371]                     }
[16:05:09.371]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:09.371]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:09.371]                       envir = envir)
[16:05:09.371]                     if (!future$lazy) 
[16:05:09.371]                       future <- run(future)
[16:05:09.371]                     invisible(future)
[16:05:09.371]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:09.371]                 }
[16:05:09.371]             }
[16:05:09.371]         }
[16:05:09.371]     })
[16:05:09.371]     if (TRUE) {
[16:05:09.371]         base::sink(type = "output", split = FALSE)
[16:05:09.371]         if (TRUE) {
[16:05:09.371]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:09.371]         }
[16:05:09.371]         else {
[16:05:09.371]             ...future.result["stdout"] <- base::list(NULL)
[16:05:09.371]         }
[16:05:09.371]         base::close(...future.stdout)
[16:05:09.371]         ...future.stdout <- NULL
[16:05:09.371]     }
[16:05:09.371]     ...future.result$conditions <- ...future.conditions
[16:05:09.371]     ...future.result$finished <- base::Sys.time()
[16:05:09.371]     ...future.result
[16:05:09.371] }
[16:05:09.374] Poll #1 (0): usedNodes() = 2, workers = 2
[16:05:09.384] receiveMessageFromWorker() for ClusterFuture ...
[16:05:09.385] - Validating connection of MultisessionFuture
[16:05:09.385] - received message: FutureResult
[16:05:09.385] - Received FutureResult
[16:05:09.385] - Erased future from FutureRegistry
[16:05:09.385] result() for ClusterFuture ...
[16:05:09.385] - result already collected: FutureResult
[16:05:09.385] result() for ClusterFuture ... done
[16:05:09.386] signalConditions() ...
[16:05:09.386]  - include = ‘immediateCondition’
[16:05:09.386]  - exclude = 
[16:05:09.386]  - resignal = FALSE
[16:05:09.386]  - Number of conditions: 1
[16:05:09.386] signalConditions() ... done
[16:05:09.386] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:09.386] result() for ClusterFuture ...
[16:05:09.386] - result already collected: FutureResult
[16:05:09.386] result() for ClusterFuture ... done
[16:05:09.387] result() for ClusterFuture ...
[16:05:09.387] - result already collected: FutureResult
[16:05:09.387] result() for ClusterFuture ... done
[16:05:09.387] signalConditions() ...
[16:05:09.387]  - include = ‘immediateCondition’
[16:05:09.387]  - exclude = 
[16:05:09.387]  - resignal = FALSE
[16:05:09.387]  - Number of conditions: 1
[16:05:09.387] signalConditions() ... done
[16:05:09.388] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[16:05:09.388] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[16:05:09.388] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[16:05:09.388] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[16:05:09.389] MultisessionFuture started
[16:05:09.389] - Launch lazy future ... done
[16:05:09.389] run() for ‘MultisessionFuture’ ... done
[16:05:09.389] result() for ClusterFuture ...
[16:05:09.389] receiveMessageFromWorker() for ClusterFuture ...
[16:05:09.389] - Validating connection of MultisessionFuture
[16:05:09.437] - received message: FutureResult
[16:05:09.437] - Received FutureResult
[16:05:09.437] - Erased future from FutureRegistry
[16:05:09.437] result() for ClusterFuture ...
[16:05:09.437] - result already collected: FutureResult
[16:05:09.437] result() for ClusterFuture ... done
[16:05:09.437] signalConditions() ...
[16:05:09.437]  - include = ‘immediateCondition’
[16:05:09.438]  - exclude = 
[16:05:09.438]  - resignal = FALSE
[16:05:09.438]  - Number of conditions: 1
[16:05:09.438] signalConditions() ... done
[16:05:09.438] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:09.438] result() for ClusterFuture ... done
[16:05:09.438] result() for ClusterFuture ...
[16:05:09.438] - result already collected: FutureResult
[16:05:09.438] result() for ClusterFuture ... done
[16:05:09.438] signalConditions() ...
[16:05:09.438]  - include = ‘immediateCondition’
[16:05:09.439]  - exclude = 
[16:05:09.439]  - resignal = FALSE
[16:05:09.439]  - Number of conditions: 1
[16:05:09.439] signalConditions() ... done
[16:05:09.439] Future state: ‘finished’
[16:05:09.439] result() for ClusterFuture ...
[16:05:09.439] - result already collected: FutureResult
[16:05:09.439] result() for ClusterFuture ... done
[16:05:09.439] signalConditions() ...
[16:05:09.439]  - include = ‘condition’
[16:05:09.440]  - exclude = ‘immediateCondition’
[16:05:09.440]  - resignal = TRUE
[16:05:09.440]  - Number of conditions: 1
[16:05:09.440]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:05:09.440] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.2"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "10"
  .. .. .. .. ..$ day           : chr "31"
  .. .. .. .. ..$ svn rev       : chr "85441"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.2 (2023-10-31)"
  .. .. .. .. ..$ nickname      : chr "Eye Holes"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "11666ca4073c" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:05:09"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:09.454] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:09.454] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:09.455] 
[16:05:09.455] Searching for globals ... DONE
[16:05:09.455] - globals: [0] <none>
[16:05:09.455] getGlobalsAndPackages() ... DONE
[16:05:09.455] run() for ‘Future’ ...
[16:05:09.455] - state: ‘created’
[16:05:09.456] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:09.469] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:09.469] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:09.469]   - Field: ‘node’
[16:05:09.470]   - Field: ‘label’
[16:05:09.470]   - Field: ‘local’
[16:05:09.470]   - Field: ‘owner’
[16:05:09.470]   - Field: ‘envir’
[16:05:09.470]   - Field: ‘workers’
[16:05:09.470]   - Field: ‘packages’
[16:05:09.470]   - Field: ‘gc’
[16:05:09.470]   - Field: ‘conditions’
[16:05:09.470]   - Field: ‘persistent’
[16:05:09.470]   - Field: ‘expr’
[16:05:09.471]   - Field: ‘uuid’
[16:05:09.471]   - Field: ‘seed’
[16:05:09.471]   - Field: ‘version’
[16:05:09.471]   - Field: ‘result’
[16:05:09.471]   - Field: ‘asynchronous’
[16:05:09.471]   - Field: ‘calls’
[16:05:09.471]   - Field: ‘globals’
[16:05:09.471]   - Field: ‘stdout’
[16:05:09.471]   - Field: ‘earlySignal’
[16:05:09.471]   - Field: ‘lazy’
[16:05:09.471]   - Field: ‘state’
[16:05:09.472] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:09.472] - Launch lazy future ...
[16:05:09.472] Packages needed by the future expression (n = 0): <none>
[16:05:09.472] Packages needed by future strategies (n = 0): <none>
[16:05:09.472] {
[16:05:09.472]     {
[16:05:09.472]         {
[16:05:09.472]             ...future.startTime <- base::Sys.time()
[16:05:09.472]             {
[16:05:09.472]                 {
[16:05:09.472]                   {
[16:05:09.472]                     {
[16:05:09.472]                       base::local({
[16:05:09.472]                         has_future <- base::requireNamespace("future", 
[16:05:09.472]                           quietly = TRUE)
[16:05:09.472]                         if (has_future) {
[16:05:09.472]                           ns <- base::getNamespace("future")
[16:05:09.472]                           version <- ns[[".package"]][["version"]]
[16:05:09.472]                           if (is.null(version)) 
[16:05:09.472]                             version <- utils::packageVersion("future")
[16:05:09.472]                         }
[16:05:09.472]                         else {
[16:05:09.472]                           version <- NULL
[16:05:09.472]                         }
[16:05:09.472]                         if (!has_future || version < "1.8.0") {
[16:05:09.472]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:09.472]                             "", base::R.version$version.string), 
[16:05:09.472]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:09.472]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:09.472]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:09.472]                               "release", "version")], collapse = " "), 
[16:05:09.472]                             hostname = base::Sys.info()[["nodename"]])
[16:05:09.472]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:09.472]                             info)
[16:05:09.472]                           info <- base::paste(info, collapse = "; ")
[16:05:09.472]                           if (!has_future) {
[16:05:09.472]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:09.472]                               info)
[16:05:09.472]                           }
[16:05:09.472]                           else {
[16:05:09.472]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:09.472]                               info, version)
[16:05:09.472]                           }
[16:05:09.472]                           base::stop(msg)
[16:05:09.472]                         }
[16:05:09.472]                       })
[16:05:09.472]                     }
[16:05:09.472]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:09.472]                     base::options(mc.cores = 1L)
[16:05:09.472]                   }
[16:05:09.472]                   options(future.plan = NULL)
[16:05:09.472]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.472]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:09.472]                 }
[16:05:09.472]                 ...future.workdir <- getwd()
[16:05:09.472]             }
[16:05:09.472]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:09.472]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:09.472]         }
[16:05:09.472]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:09.472]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:09.472]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:09.472]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:09.472]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:09.472]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:09.472]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:09.472]             base::names(...future.oldOptions))
[16:05:09.472]     }
[16:05:09.472]     if (FALSE) {
[16:05:09.472]     }
[16:05:09.472]     else {
[16:05:09.472]         if (TRUE) {
[16:05:09.472]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:09.472]                 open = "w")
[16:05:09.472]         }
[16:05:09.472]         else {
[16:05:09.472]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:09.472]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:09.472]         }
[16:05:09.472]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:09.472]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:09.472]             base::sink(type = "output", split = FALSE)
[16:05:09.472]             base::close(...future.stdout)
[16:05:09.472]         }, add = TRUE)
[16:05:09.472]     }
[16:05:09.472]     ...future.frame <- base::sys.nframe()
[16:05:09.472]     ...future.conditions <- base::list()
[16:05:09.472]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:09.472]     if (FALSE) {
[16:05:09.472]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:09.472]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:09.472]     }
[16:05:09.472]     ...future.result <- base::tryCatch({
[16:05:09.472]         base::withCallingHandlers({
[16:05:09.472]             ...future.value <- base::withVisible(base::local({
[16:05:09.472]                 ...future.makeSendCondition <- base::local({
[16:05:09.472]                   sendCondition <- NULL
[16:05:09.472]                   function(frame = 1L) {
[16:05:09.472]                     if (is.function(sendCondition)) 
[16:05:09.472]                       return(sendCondition)
[16:05:09.472]                     ns <- getNamespace("parallel")
[16:05:09.472]                     if (exists("sendData", mode = "function", 
[16:05:09.472]                       envir = ns)) {
[16:05:09.472]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:09.472]                         envir = ns)
[16:05:09.472]                       envir <- sys.frame(frame)
[16:05:09.472]                       master <- NULL
[16:05:09.472]                       while (!identical(envir, .GlobalEnv) && 
[16:05:09.472]                         !identical(envir, emptyenv())) {
[16:05:09.472]                         if (exists("master", mode = "list", envir = envir, 
[16:05:09.472]                           inherits = FALSE)) {
[16:05:09.472]                           master <- get("master", mode = "list", 
[16:05:09.472]                             envir = envir, inherits = FALSE)
[16:05:09.472]                           if (inherits(master, c("SOCKnode", 
[16:05:09.472]                             "SOCK0node"))) {
[16:05:09.472]                             sendCondition <<- function(cond) {
[16:05:09.472]                               data <- list(type = "VALUE", value = cond, 
[16:05:09.472]                                 success = TRUE)
[16:05:09.472]                               parallel_sendData(master, data)
[16:05:09.472]                             }
[16:05:09.472]                             return(sendCondition)
[16:05:09.472]                           }
[16:05:09.472]                         }
[16:05:09.472]                         frame <- frame + 1L
[16:05:09.472]                         envir <- sys.frame(frame)
[16:05:09.472]                       }
[16:05:09.472]                     }
[16:05:09.472]                     sendCondition <<- function(cond) NULL
[16:05:09.472]                   }
[16:05:09.472]                 })
[16:05:09.472]                 withCallingHandlers({
[16:05:09.472]                   1
[16:05:09.472]                 }, immediateCondition = function(cond) {
[16:05:09.472]                   sendCondition <- ...future.makeSendCondition()
[16:05:09.472]                   sendCondition(cond)
[16:05:09.472]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.472]                   {
[16:05:09.472]                     inherits <- base::inherits
[16:05:09.472]                     invokeRestart <- base::invokeRestart
[16:05:09.472]                     is.null <- base::is.null
[16:05:09.472]                     muffled <- FALSE
[16:05:09.472]                     if (inherits(cond, "message")) {
[16:05:09.472]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:09.472]                       if (muffled) 
[16:05:09.472]                         invokeRestart("muffleMessage")
[16:05:09.472]                     }
[16:05:09.472]                     else if (inherits(cond, "warning")) {
[16:05:09.472]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:09.472]                       if (muffled) 
[16:05:09.472]                         invokeRestart("muffleWarning")
[16:05:09.472]                     }
[16:05:09.472]                     else if (inherits(cond, "condition")) {
[16:05:09.472]                       if (!is.null(pattern)) {
[16:05:09.472]                         computeRestarts <- base::computeRestarts
[16:05:09.472]                         grepl <- base::grepl
[16:05:09.472]                         restarts <- computeRestarts(cond)
[16:05:09.472]                         for (restart in restarts) {
[16:05:09.472]                           name <- restart$name
[16:05:09.472]                           if (is.null(name)) 
[16:05:09.472]                             next
[16:05:09.472]                           if (!grepl(pattern, name)) 
[16:05:09.472]                             next
[16:05:09.472]                           invokeRestart(restart)
[16:05:09.472]                           muffled <- TRUE
[16:05:09.472]                           break
[16:05:09.472]                         }
[16:05:09.472]                       }
[16:05:09.472]                     }
[16:05:09.472]                     invisible(muffled)
[16:05:09.472]                   }
[16:05:09.472]                   muffleCondition(cond)
[16:05:09.472]                 })
[16:05:09.472]             }))
[16:05:09.472]             future::FutureResult(value = ...future.value$value, 
[16:05:09.472]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.472]                   ...future.rng), globalenv = if (FALSE) 
[16:05:09.472]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:09.472]                     ...future.globalenv.names))
[16:05:09.472]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:09.472]         }, condition = base::local({
[16:05:09.472]             c <- base::c
[16:05:09.472]             inherits <- base::inherits
[16:05:09.472]             invokeRestart <- base::invokeRestart
[16:05:09.472]             length <- base::length
[16:05:09.472]             list <- base::list
[16:05:09.472]             seq.int <- base::seq.int
[16:05:09.472]             signalCondition <- base::signalCondition
[16:05:09.472]             sys.calls <- base::sys.calls
[16:05:09.472]             `[[` <- base::`[[`
[16:05:09.472]             `+` <- base::`+`
[16:05:09.472]             `<<-` <- base::`<<-`
[16:05:09.472]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:09.472]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:09.472]                   3L)]
[16:05:09.472]             }
[16:05:09.472]             function(cond) {
[16:05:09.472]                 is_error <- inherits(cond, "error")
[16:05:09.472]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:09.472]                   NULL)
[16:05:09.472]                 if (is_error) {
[16:05:09.472]                   sessionInformation <- function() {
[16:05:09.472]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:09.472]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:09.472]                       search = base::search(), system = base::Sys.info())
[16:05:09.472]                   }
[16:05:09.472]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.472]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:09.472]                     cond$call), session = sessionInformation(), 
[16:05:09.472]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:09.472]                   signalCondition(cond)
[16:05:09.472]                 }
[16:05:09.472]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:09.472]                 "immediateCondition"))) {
[16:05:09.472]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:09.472]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.472]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:09.472]                   if (TRUE && !signal) {
[16:05:09.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.472]                     {
[16:05:09.472]                       inherits <- base::inherits
[16:05:09.472]                       invokeRestart <- base::invokeRestart
[16:05:09.472]                       is.null <- base::is.null
[16:05:09.472]                       muffled <- FALSE
[16:05:09.472]                       if (inherits(cond, "message")) {
[16:05:09.472]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.472]                         if (muffled) 
[16:05:09.472]                           invokeRestart("muffleMessage")
[16:05:09.472]                       }
[16:05:09.472]                       else if (inherits(cond, "warning")) {
[16:05:09.472]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.472]                         if (muffled) 
[16:05:09.472]                           invokeRestart("muffleWarning")
[16:05:09.472]                       }
[16:05:09.472]                       else if (inherits(cond, "condition")) {
[16:05:09.472]                         if (!is.null(pattern)) {
[16:05:09.472]                           computeRestarts <- base::computeRestarts
[16:05:09.472]                           grepl <- base::grepl
[16:05:09.472]                           restarts <- computeRestarts(cond)
[16:05:09.472]                           for (restart in restarts) {
[16:05:09.472]                             name <- restart$name
[16:05:09.472]                             if (is.null(name)) 
[16:05:09.472]                               next
[16:05:09.472]                             if (!grepl(pattern, name)) 
[16:05:09.472]                               next
[16:05:09.472]                             invokeRestart(restart)
[16:05:09.472]                             muffled <- TRUE
[16:05:09.472]                             break
[16:05:09.472]                           }
[16:05:09.472]                         }
[16:05:09.472]                       }
[16:05:09.472]                       invisible(muffled)
[16:05:09.472]                     }
[16:05:09.472]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.472]                   }
[16:05:09.472]                 }
[16:05:09.472]                 else {
[16:05:09.472]                   if (TRUE) {
[16:05:09.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.472]                     {
[16:05:09.472]                       inherits <- base::inherits
[16:05:09.472]                       invokeRestart <- base::invokeRestart
[16:05:09.472]                       is.null <- base::is.null
[16:05:09.472]                       muffled <- FALSE
[16:05:09.472]                       if (inherits(cond, "message")) {
[16:05:09.472]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.472]                         if (muffled) 
[16:05:09.472]                           invokeRestart("muffleMessage")
[16:05:09.472]                       }
[16:05:09.472]                       else if (inherits(cond, "warning")) {
[16:05:09.472]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.472]                         if (muffled) 
[16:05:09.472]                           invokeRestart("muffleWarning")
[16:05:09.472]                       }
[16:05:09.472]                       else if (inherits(cond, "condition")) {
[16:05:09.472]                         if (!is.null(pattern)) {
[16:05:09.472]                           computeRestarts <- base::computeRestarts
[16:05:09.472]                           grepl <- base::grepl
[16:05:09.472]                           restarts <- computeRestarts(cond)
[16:05:09.472]                           for (restart in restarts) {
[16:05:09.472]                             name <- restart$name
[16:05:09.472]                             if (is.null(name)) 
[16:05:09.472]                               next
[16:05:09.472]                             if (!grepl(pattern, name)) 
[16:05:09.472]                               next
[16:05:09.472]                             invokeRestart(restart)
[16:05:09.472]                             muffled <- TRUE
[16:05:09.472]                             break
[16:05:09.472]                           }
[16:05:09.472]                         }
[16:05:09.472]                       }
[16:05:09.472]                       invisible(muffled)
[16:05:09.472]                     }
[16:05:09.472]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.472]                   }
[16:05:09.472]                 }
[16:05:09.472]             }
[16:05:09.472]         }))
[16:05:09.472]     }, error = function(ex) {
[16:05:09.472]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:09.472]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.472]                 ...future.rng), started = ...future.startTime, 
[16:05:09.472]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:09.472]             version = "1.8"), class = "FutureResult")
[16:05:09.472]     }, finally = {
[16:05:09.472]         if (!identical(...future.workdir, getwd())) 
[16:05:09.472]             setwd(...future.workdir)
[16:05:09.472]         {
[16:05:09.472]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:09.472]                 ...future.oldOptions$nwarnings <- NULL
[16:05:09.472]             }
[16:05:09.472]             base::options(...future.oldOptions)
[16:05:09.472]             if (.Platform$OS.type == "windows") {
[16:05:09.472]                 old_names <- names(...future.oldEnvVars)
[16:05:09.472]                 envs <- base::Sys.getenv()
[16:05:09.472]                 names <- names(envs)
[16:05:09.472]                 common <- intersect(names, old_names)
[16:05:09.472]                 added <- setdiff(names, old_names)
[16:05:09.472]                 removed <- setdiff(old_names, names)
[16:05:09.472]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:09.472]                   envs[common]]
[16:05:09.472]                 NAMES <- toupper(changed)
[16:05:09.472]                 args <- list()
[16:05:09.472]                 for (kk in seq_along(NAMES)) {
[16:05:09.472]                   name <- changed[[kk]]
[16:05:09.472]                   NAME <- NAMES[[kk]]
[16:05:09.472]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.472]                     next
[16:05:09.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.472]                 }
[16:05:09.472]                 NAMES <- toupper(added)
[16:05:09.472]                 for (kk in seq_along(NAMES)) {
[16:05:09.472]                   name <- added[[kk]]
[16:05:09.472]                   NAME <- NAMES[[kk]]
[16:05:09.472]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.472]                     next
[16:05:09.472]                   args[[name]] <- ""
[16:05:09.472]                 }
[16:05:09.472]                 NAMES <- toupper(removed)
[16:05:09.472]                 for (kk in seq_along(NAMES)) {
[16:05:09.472]                   name <- removed[[kk]]
[16:05:09.472]                   NAME <- NAMES[[kk]]
[16:05:09.472]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.472]                     next
[16:05:09.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.472]                 }
[16:05:09.472]                 if (length(args) > 0) 
[16:05:09.472]                   base::do.call(base::Sys.setenv, args = args)
[16:05:09.472]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:09.472]             }
[16:05:09.472]             else {
[16:05:09.472]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:09.472]             }
[16:05:09.472]             {
[16:05:09.472]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:09.472]                   0L) {
[16:05:09.472]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:09.472]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:09.472]                   base::options(opts)
[16:05:09.472]                 }
[16:05:09.472]                 {
[16:05:09.472]                   {
[16:05:09.472]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:09.472]                     NULL
[16:05:09.472]                   }
[16:05:09.472]                   options(future.plan = NULL)
[16:05:09.472]                   if (is.na(NA_character_)) 
[16:05:09.472]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.472]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:09.472]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:09.472]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:09.472]                     envir = parent.frame()) 
[16:05:09.472]                   {
[16:05:09.472]                     if (is.function(workers)) 
[16:05:09.472]                       workers <- workers()
[16:05:09.472]                     workers <- structure(as.integer(workers), 
[16:05:09.472]                       class = class(workers))
[16:05:09.472]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:09.472]                       workers >= 1)
[16:05:09.472]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:09.472]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:09.472]                     }
[16:05:09.472]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:09.472]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:09.472]                       envir = envir)
[16:05:09.472]                     if (!future$lazy) 
[16:05:09.472]                       future <- run(future)
[16:05:09.472]                     invisible(future)
[16:05:09.472]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:09.472]                 }
[16:05:09.472]             }
[16:05:09.472]         }
[16:05:09.472]     })
[16:05:09.472]     if (TRUE) {
[16:05:09.472]         base::sink(type = "output", split = FALSE)
[16:05:09.472]         if (TRUE) {
[16:05:09.472]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:09.472]         }
[16:05:09.472]         else {
[16:05:09.472]             ...future.result["stdout"] <- base::list(NULL)
[16:05:09.472]         }
[16:05:09.472]         base::close(...future.stdout)
[16:05:09.472]         ...future.stdout <- NULL
[16:05:09.472]     }
[16:05:09.472]     ...future.result$conditions <- ...future.conditions
[16:05:09.472]     ...future.result$finished <- base::Sys.time()
[16:05:09.472]     ...future.result
[16:05:09.472] }
[16:05:09.476] MultisessionFuture started
[16:05:09.476] - Launch lazy future ... done
[16:05:09.476] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:09.476] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:09.476] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:09.477] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:09.477] Searching for globals ... DONE
[16:05:09.477] Resolving globals: TRUE
[16:05:09.477] Resolving any globals that are futures ...
[16:05:09.478] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:09.478] Resolving any globals that are futures ... DONE
[16:05:09.478] Resolving futures part of globals (recursively) ...
[16:05:09.478] resolve() on list ...
[16:05:09.478]  recursive: 99
[16:05:09.478]  length: 1
[16:05:09.478]  elements: ‘a’
[16:05:09.524] receiveMessageFromWorker() for ClusterFuture ...
[16:05:09.524] - Validating connection of MultisessionFuture
[16:05:09.524] - received message: FutureResult
[16:05:09.525] - Received FutureResult
[16:05:09.525] - Erased future from FutureRegistry
[16:05:09.525] result() for ClusterFuture ...
[16:05:09.525] - result already collected: FutureResult
[16:05:09.525] result() for ClusterFuture ... done
[16:05:09.525] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:09.525] Future #1
[16:05:09.525] result() for ClusterFuture ...
[16:05:09.525] - result already collected: FutureResult
[16:05:09.525] result() for ClusterFuture ... done
[16:05:09.525] result() for ClusterFuture ...
[16:05:09.526] - result already collected: FutureResult
[16:05:09.526] result() for ClusterFuture ... done
[16:05:09.526] A MultisessionFuture was resolved
[16:05:09.526]  length: 0 (resolved future 1)
[16:05:09.526] resolve() on list ... DONE
[16:05:09.526] - globals: [1] ‘a’
[16:05:09.526] Resolving futures part of globals (recursively) ... DONE
[16:05:09.527] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[16:05:09.528] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[16:05:09.528] - globals: [1] ‘a’
[16:05:09.528] - packages: [1] ‘future’
[16:05:09.528] getGlobalsAndPackages() ... DONE
[16:05:09.528] run() for ‘Future’ ...
[16:05:09.528] - state: ‘created’
[16:05:09.528] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:09.542] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:09.542] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:09.542]   - Field: ‘node’
[16:05:09.542]   - Field: ‘label’
[16:05:09.543]   - Field: ‘local’
[16:05:09.543]   - Field: ‘owner’
[16:05:09.545]   - Field: ‘envir’
[16:05:09.545]   - Field: ‘workers’
[16:05:09.545]   - Field: ‘packages’
[16:05:09.545]   - Field: ‘gc’
[16:05:09.545]   - Field: ‘conditions’
[16:05:09.545]   - Field: ‘persistent’
[16:05:09.545]   - Field: ‘expr’
[16:05:09.545]   - Field: ‘uuid’
[16:05:09.545]   - Field: ‘seed’
[16:05:09.545]   - Field: ‘version’
[16:05:09.546]   - Field: ‘result’
[16:05:09.546]   - Field: ‘asynchronous’
[16:05:09.546]   - Field: ‘calls’
[16:05:09.546]   - Field: ‘globals’
[16:05:09.546]   - Field: ‘stdout’
[16:05:09.546]   - Field: ‘earlySignal’
[16:05:09.546]   - Field: ‘lazy’
[16:05:09.546]   - Field: ‘state’
[16:05:09.546] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:09.546] - Launch lazy future ...
[16:05:09.547] Packages needed by the future expression (n = 1): ‘future’
[16:05:09.547] Packages needed by future strategies (n = 0): <none>
[16:05:09.547] {
[16:05:09.547]     {
[16:05:09.547]         {
[16:05:09.547]             ...future.startTime <- base::Sys.time()
[16:05:09.547]             {
[16:05:09.547]                 {
[16:05:09.547]                   {
[16:05:09.547]                     {
[16:05:09.547]                       {
[16:05:09.547]                         base::local({
[16:05:09.547]                           has_future <- base::requireNamespace("future", 
[16:05:09.547]                             quietly = TRUE)
[16:05:09.547]                           if (has_future) {
[16:05:09.547]                             ns <- base::getNamespace("future")
[16:05:09.547]                             version <- ns[[".package"]][["version"]]
[16:05:09.547]                             if (is.null(version)) 
[16:05:09.547]                               version <- utils::packageVersion("future")
[16:05:09.547]                           }
[16:05:09.547]                           else {
[16:05:09.547]                             version <- NULL
[16:05:09.547]                           }
[16:05:09.547]                           if (!has_future || version < "1.8.0") {
[16:05:09.547]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:09.547]                               "", base::R.version$version.string), 
[16:05:09.547]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:09.547]                                 base::R.version$platform, 8 * 
[16:05:09.547]                                   base::.Machine$sizeof.pointer), 
[16:05:09.547]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:09.547]                                 "release", "version")], collapse = " "), 
[16:05:09.547]                               hostname = base::Sys.info()[["nodename"]])
[16:05:09.547]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:09.547]                               info)
[16:05:09.547]                             info <- base::paste(info, collapse = "; ")
[16:05:09.547]                             if (!has_future) {
[16:05:09.547]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:09.547]                                 info)
[16:05:09.547]                             }
[16:05:09.547]                             else {
[16:05:09.547]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:09.547]                                 info, version)
[16:05:09.547]                             }
[16:05:09.547]                             base::stop(msg)
[16:05:09.547]                           }
[16:05:09.547]                         })
[16:05:09.547]                       }
[16:05:09.547]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:09.547]                       base::options(mc.cores = 1L)
[16:05:09.547]                     }
[16:05:09.547]                     base::local({
[16:05:09.547]                       for (pkg in "future") {
[16:05:09.547]                         base::loadNamespace(pkg)
[16:05:09.547]                         base::library(pkg, character.only = TRUE)
[16:05:09.547]                       }
[16:05:09.547]                     })
[16:05:09.547]                   }
[16:05:09.547]                   options(future.plan = NULL)
[16:05:09.547]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.547]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:09.547]                 }
[16:05:09.547]                 ...future.workdir <- getwd()
[16:05:09.547]             }
[16:05:09.547]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:09.547]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:09.547]         }
[16:05:09.547]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:09.547]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:09.547]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:09.547]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:09.547]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:09.547]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:09.547]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:09.547]             base::names(...future.oldOptions))
[16:05:09.547]     }
[16:05:09.547]     if (FALSE) {
[16:05:09.547]     }
[16:05:09.547]     else {
[16:05:09.547]         if (TRUE) {
[16:05:09.547]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:09.547]                 open = "w")
[16:05:09.547]         }
[16:05:09.547]         else {
[16:05:09.547]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:09.547]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:09.547]         }
[16:05:09.547]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:09.547]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:09.547]             base::sink(type = "output", split = FALSE)
[16:05:09.547]             base::close(...future.stdout)
[16:05:09.547]         }, add = TRUE)
[16:05:09.547]     }
[16:05:09.547]     ...future.frame <- base::sys.nframe()
[16:05:09.547]     ...future.conditions <- base::list()
[16:05:09.547]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:09.547]     if (FALSE) {
[16:05:09.547]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:09.547]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:09.547]     }
[16:05:09.547]     ...future.result <- base::tryCatch({
[16:05:09.547]         base::withCallingHandlers({
[16:05:09.547]             ...future.value <- base::withVisible(base::local({
[16:05:09.547]                 ...future.makeSendCondition <- base::local({
[16:05:09.547]                   sendCondition <- NULL
[16:05:09.547]                   function(frame = 1L) {
[16:05:09.547]                     if (is.function(sendCondition)) 
[16:05:09.547]                       return(sendCondition)
[16:05:09.547]                     ns <- getNamespace("parallel")
[16:05:09.547]                     if (exists("sendData", mode = "function", 
[16:05:09.547]                       envir = ns)) {
[16:05:09.547]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:09.547]                         envir = ns)
[16:05:09.547]                       envir <- sys.frame(frame)
[16:05:09.547]                       master <- NULL
[16:05:09.547]                       while (!identical(envir, .GlobalEnv) && 
[16:05:09.547]                         !identical(envir, emptyenv())) {
[16:05:09.547]                         if (exists("master", mode = "list", envir = envir, 
[16:05:09.547]                           inherits = FALSE)) {
[16:05:09.547]                           master <- get("master", mode = "list", 
[16:05:09.547]                             envir = envir, inherits = FALSE)
[16:05:09.547]                           if (inherits(master, c("SOCKnode", 
[16:05:09.547]                             "SOCK0node"))) {
[16:05:09.547]                             sendCondition <<- function(cond) {
[16:05:09.547]                               data <- list(type = "VALUE", value = cond, 
[16:05:09.547]                                 success = TRUE)
[16:05:09.547]                               parallel_sendData(master, data)
[16:05:09.547]                             }
[16:05:09.547]                             return(sendCondition)
[16:05:09.547]                           }
[16:05:09.547]                         }
[16:05:09.547]                         frame <- frame + 1L
[16:05:09.547]                         envir <- sys.frame(frame)
[16:05:09.547]                       }
[16:05:09.547]                     }
[16:05:09.547]                     sendCondition <<- function(cond) NULL
[16:05:09.547]                   }
[16:05:09.547]                 })
[16:05:09.547]                 withCallingHandlers({
[16:05:09.547]                   value(a) + 1
[16:05:09.547]                 }, immediateCondition = function(cond) {
[16:05:09.547]                   sendCondition <- ...future.makeSendCondition()
[16:05:09.547]                   sendCondition(cond)
[16:05:09.547]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.547]                   {
[16:05:09.547]                     inherits <- base::inherits
[16:05:09.547]                     invokeRestart <- base::invokeRestart
[16:05:09.547]                     is.null <- base::is.null
[16:05:09.547]                     muffled <- FALSE
[16:05:09.547]                     if (inherits(cond, "message")) {
[16:05:09.547]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:09.547]                       if (muffled) 
[16:05:09.547]                         invokeRestart("muffleMessage")
[16:05:09.547]                     }
[16:05:09.547]                     else if (inherits(cond, "warning")) {
[16:05:09.547]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:09.547]                       if (muffled) 
[16:05:09.547]                         invokeRestart("muffleWarning")
[16:05:09.547]                     }
[16:05:09.547]                     else if (inherits(cond, "condition")) {
[16:05:09.547]                       if (!is.null(pattern)) {
[16:05:09.547]                         computeRestarts <- base::computeRestarts
[16:05:09.547]                         grepl <- base::grepl
[16:05:09.547]                         restarts <- computeRestarts(cond)
[16:05:09.547]                         for (restart in restarts) {
[16:05:09.547]                           name <- restart$name
[16:05:09.547]                           if (is.null(name)) 
[16:05:09.547]                             next
[16:05:09.547]                           if (!grepl(pattern, name)) 
[16:05:09.547]                             next
[16:05:09.547]                           invokeRestart(restart)
[16:05:09.547]                           muffled <- TRUE
[16:05:09.547]                           break
[16:05:09.547]                         }
[16:05:09.547]                       }
[16:05:09.547]                     }
[16:05:09.547]                     invisible(muffled)
[16:05:09.547]                   }
[16:05:09.547]                   muffleCondition(cond)
[16:05:09.547]                 })
[16:05:09.547]             }))
[16:05:09.547]             future::FutureResult(value = ...future.value$value, 
[16:05:09.547]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.547]                   ...future.rng), globalenv = if (FALSE) 
[16:05:09.547]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:09.547]                     ...future.globalenv.names))
[16:05:09.547]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:09.547]         }, condition = base::local({
[16:05:09.547]             c <- base::c
[16:05:09.547]             inherits <- base::inherits
[16:05:09.547]             invokeRestart <- base::invokeRestart
[16:05:09.547]             length <- base::length
[16:05:09.547]             list <- base::list
[16:05:09.547]             seq.int <- base::seq.int
[16:05:09.547]             signalCondition <- base::signalCondition
[16:05:09.547]             sys.calls <- base::sys.calls
[16:05:09.547]             `[[` <- base::`[[`
[16:05:09.547]             `+` <- base::`+`
[16:05:09.547]             `<<-` <- base::`<<-`
[16:05:09.547]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:09.547]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:09.547]                   3L)]
[16:05:09.547]             }
[16:05:09.547]             function(cond) {
[16:05:09.547]                 is_error <- inherits(cond, "error")
[16:05:09.547]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:09.547]                   NULL)
[16:05:09.547]                 if (is_error) {
[16:05:09.547]                   sessionInformation <- function() {
[16:05:09.547]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:09.547]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:09.547]                       search = base::search(), system = base::Sys.info())
[16:05:09.547]                   }
[16:05:09.547]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.547]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:09.547]                     cond$call), session = sessionInformation(), 
[16:05:09.547]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:09.547]                   signalCondition(cond)
[16:05:09.547]                 }
[16:05:09.547]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:09.547]                 "immediateCondition"))) {
[16:05:09.547]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:09.547]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.547]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:09.547]                   if (TRUE && !signal) {
[16:05:09.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.547]                     {
[16:05:09.547]                       inherits <- base::inherits
[16:05:09.547]                       invokeRestart <- base::invokeRestart
[16:05:09.547]                       is.null <- base::is.null
[16:05:09.547]                       muffled <- FALSE
[16:05:09.547]                       if (inherits(cond, "message")) {
[16:05:09.547]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.547]                         if (muffled) 
[16:05:09.547]                           invokeRestart("muffleMessage")
[16:05:09.547]                       }
[16:05:09.547]                       else if (inherits(cond, "warning")) {
[16:05:09.547]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.547]                         if (muffled) 
[16:05:09.547]                           invokeRestart("muffleWarning")
[16:05:09.547]                       }
[16:05:09.547]                       else if (inherits(cond, "condition")) {
[16:05:09.547]                         if (!is.null(pattern)) {
[16:05:09.547]                           computeRestarts <- base::computeRestarts
[16:05:09.547]                           grepl <- base::grepl
[16:05:09.547]                           restarts <- computeRestarts(cond)
[16:05:09.547]                           for (restart in restarts) {
[16:05:09.547]                             name <- restart$name
[16:05:09.547]                             if (is.null(name)) 
[16:05:09.547]                               next
[16:05:09.547]                             if (!grepl(pattern, name)) 
[16:05:09.547]                               next
[16:05:09.547]                             invokeRestart(restart)
[16:05:09.547]                             muffled <- TRUE
[16:05:09.547]                             break
[16:05:09.547]                           }
[16:05:09.547]                         }
[16:05:09.547]                       }
[16:05:09.547]                       invisible(muffled)
[16:05:09.547]                     }
[16:05:09.547]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.547]                   }
[16:05:09.547]                 }
[16:05:09.547]                 else {
[16:05:09.547]                   if (TRUE) {
[16:05:09.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.547]                     {
[16:05:09.547]                       inherits <- base::inherits
[16:05:09.547]                       invokeRestart <- base::invokeRestart
[16:05:09.547]                       is.null <- base::is.null
[16:05:09.547]                       muffled <- FALSE
[16:05:09.547]                       if (inherits(cond, "message")) {
[16:05:09.547]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.547]                         if (muffled) 
[16:05:09.547]                           invokeRestart("muffleMessage")
[16:05:09.547]                       }
[16:05:09.547]                       else if (inherits(cond, "warning")) {
[16:05:09.547]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.547]                         if (muffled) 
[16:05:09.547]                           invokeRestart("muffleWarning")
[16:05:09.547]                       }
[16:05:09.547]                       else if (inherits(cond, "condition")) {
[16:05:09.547]                         if (!is.null(pattern)) {
[16:05:09.547]                           computeRestarts <- base::computeRestarts
[16:05:09.547]                           grepl <- base::grepl
[16:05:09.547]                           restarts <- computeRestarts(cond)
[16:05:09.547]                           for (restart in restarts) {
[16:05:09.547]                             name <- restart$name
[16:05:09.547]                             if (is.null(name)) 
[16:05:09.547]                               next
[16:05:09.547]                             if (!grepl(pattern, name)) 
[16:05:09.547]                               next
[16:05:09.547]                             invokeRestart(restart)
[16:05:09.547]                             muffled <- TRUE
[16:05:09.547]                             break
[16:05:09.547]                           }
[16:05:09.547]                         }
[16:05:09.547]                       }
[16:05:09.547]                       invisible(muffled)
[16:05:09.547]                     }
[16:05:09.547]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.547]                   }
[16:05:09.547]                 }
[16:05:09.547]             }
[16:05:09.547]         }))
[16:05:09.547]     }, error = function(ex) {
[16:05:09.547]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:09.547]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.547]                 ...future.rng), started = ...future.startTime, 
[16:05:09.547]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:09.547]             version = "1.8"), class = "FutureResult")
[16:05:09.547]     }, finally = {
[16:05:09.547]         if (!identical(...future.workdir, getwd())) 
[16:05:09.547]             setwd(...future.workdir)
[16:05:09.547]         {
[16:05:09.547]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:09.547]                 ...future.oldOptions$nwarnings <- NULL
[16:05:09.547]             }
[16:05:09.547]             base::options(...future.oldOptions)
[16:05:09.547]             if (.Platform$OS.type == "windows") {
[16:05:09.547]                 old_names <- names(...future.oldEnvVars)
[16:05:09.547]                 envs <- base::Sys.getenv()
[16:05:09.547]                 names <- names(envs)
[16:05:09.547]                 common <- intersect(names, old_names)
[16:05:09.547]                 added <- setdiff(names, old_names)
[16:05:09.547]                 removed <- setdiff(old_names, names)
[16:05:09.547]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:09.547]                   envs[common]]
[16:05:09.547]                 NAMES <- toupper(changed)
[16:05:09.547]                 args <- list()
[16:05:09.547]                 for (kk in seq_along(NAMES)) {
[16:05:09.547]                   name <- changed[[kk]]
[16:05:09.547]                   NAME <- NAMES[[kk]]
[16:05:09.547]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.547]                     next
[16:05:09.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.547]                 }
[16:05:09.547]                 NAMES <- toupper(added)
[16:05:09.547]                 for (kk in seq_along(NAMES)) {
[16:05:09.547]                   name <- added[[kk]]
[16:05:09.547]                   NAME <- NAMES[[kk]]
[16:05:09.547]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.547]                     next
[16:05:09.547]                   args[[name]] <- ""
[16:05:09.547]                 }
[16:05:09.547]                 NAMES <- toupper(removed)
[16:05:09.547]                 for (kk in seq_along(NAMES)) {
[16:05:09.547]                   name <- removed[[kk]]
[16:05:09.547]                   NAME <- NAMES[[kk]]
[16:05:09.547]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.547]                     next
[16:05:09.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.547]                 }
[16:05:09.547]                 if (length(args) > 0) 
[16:05:09.547]                   base::do.call(base::Sys.setenv, args = args)
[16:05:09.547]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:09.547]             }
[16:05:09.547]             else {
[16:05:09.547]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:09.547]             }
[16:05:09.547]             {
[16:05:09.547]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:09.547]                   0L) {
[16:05:09.547]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:09.547]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:09.547]                   base::options(opts)
[16:05:09.547]                 }
[16:05:09.547]                 {
[16:05:09.547]                   {
[16:05:09.547]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:09.547]                     NULL
[16:05:09.547]                   }
[16:05:09.547]                   options(future.plan = NULL)
[16:05:09.547]                   if (is.na(NA_character_)) 
[16:05:09.547]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.547]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:09.547]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:09.547]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:09.547]                     envir = parent.frame()) 
[16:05:09.547]                   {
[16:05:09.547]                     if (is.function(workers)) 
[16:05:09.547]                       workers <- workers()
[16:05:09.547]                     workers <- structure(as.integer(workers), 
[16:05:09.547]                       class = class(workers))
[16:05:09.547]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:09.547]                       workers >= 1)
[16:05:09.547]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:09.547]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:09.547]                     }
[16:05:09.547]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:09.547]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:09.547]                       envir = envir)
[16:05:09.547]                     if (!future$lazy) 
[16:05:09.547]                       future <- run(future)
[16:05:09.547]                     invisible(future)
[16:05:09.547]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:09.547]                 }
[16:05:09.547]             }
[16:05:09.547]         }
[16:05:09.547]     })
[16:05:09.547]     if (TRUE) {
[16:05:09.547]         base::sink(type = "output", split = FALSE)
[16:05:09.547]         if (TRUE) {
[16:05:09.547]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:09.547]         }
[16:05:09.547]         else {
[16:05:09.547]             ...future.result["stdout"] <- base::list(NULL)
[16:05:09.547]         }
[16:05:09.547]         base::close(...future.stdout)
[16:05:09.547]         ...future.stdout <- NULL
[16:05:09.547]     }
[16:05:09.547]     ...future.result$conditions <- ...future.conditions
[16:05:09.547]     ...future.result$finished <- base::Sys.time()
[16:05:09.547]     ...future.result
[16:05:09.547] }
[16:05:09.550] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[16:05:09.551] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[16:05:09.603] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[16:05:09.604] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[16:05:09.604] MultisessionFuture started
[16:05:09.604] - Launch lazy future ... done
[16:05:09.604] run() for ‘MultisessionFuture’ ... done
[16:05:09.605] result() for ClusterFuture ...
[16:05:09.605] receiveMessageFromWorker() for ClusterFuture ...
[16:05:09.605] - Validating connection of MultisessionFuture
[16:05:09.656] - received message: FutureResult
[16:05:09.656] - Received FutureResult
[16:05:09.656] - Erased future from FutureRegistry
[16:05:09.656] result() for ClusterFuture ...
[16:05:09.656] - result already collected: FutureResult
[16:05:09.656] result() for ClusterFuture ... done
[16:05:09.656] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:09.657] result() for ClusterFuture ... done
[16:05:09.657] result() for ClusterFuture ...
[16:05:09.657] - result already collected: FutureResult
[16:05:09.657] result() for ClusterFuture ... done
value(b) = 2
[16:05:09.657] result() for ClusterFuture ...
[16:05:09.657] - result already collected: FutureResult
[16:05:09.657] result() for ClusterFuture ... done
[16:05:09.657] result() for ClusterFuture ...
[16:05:09.657] - result already collected: FutureResult
[16:05:09.658] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:09.658] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:09.658] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:09.659] 
[16:05:09.659] Searching for globals ... DONE
[16:05:09.659] - globals: [0] <none>
[16:05:09.659] getGlobalsAndPackages() ... DONE
[16:05:09.659] run() for ‘Future’ ...
[16:05:09.659] - state: ‘created’
[16:05:09.659] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:09.673] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:09.673] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:09.674]   - Field: ‘node’
[16:05:09.674]   - Field: ‘label’
[16:05:09.674]   - Field: ‘local’
[16:05:09.674]   - Field: ‘owner’
[16:05:09.674]   - Field: ‘envir’
[16:05:09.674]   - Field: ‘workers’
[16:05:09.674]   - Field: ‘packages’
[16:05:09.674]   - Field: ‘gc’
[16:05:09.674]   - Field: ‘conditions’
[16:05:09.674]   - Field: ‘persistent’
[16:05:09.675]   - Field: ‘expr’
[16:05:09.675]   - Field: ‘uuid’
[16:05:09.675]   - Field: ‘seed’
[16:05:09.675]   - Field: ‘version’
[16:05:09.675]   - Field: ‘result’
[16:05:09.675]   - Field: ‘asynchronous’
[16:05:09.675]   - Field: ‘calls’
[16:05:09.675]   - Field: ‘globals’
[16:05:09.675]   - Field: ‘stdout’
[16:05:09.675]   - Field: ‘earlySignal’
[16:05:09.676]   - Field: ‘lazy’
[16:05:09.676]   - Field: ‘state’
[16:05:09.676] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:09.676] - Launch lazy future ...
[16:05:09.676] Packages needed by the future expression (n = 0): <none>
[16:05:09.676] Packages needed by future strategies (n = 0): <none>
[16:05:09.677] {
[16:05:09.677]     {
[16:05:09.677]         {
[16:05:09.677]             ...future.startTime <- base::Sys.time()
[16:05:09.677]             {
[16:05:09.677]                 {
[16:05:09.677]                   {
[16:05:09.677]                     {
[16:05:09.677]                       base::local({
[16:05:09.677]                         has_future <- base::requireNamespace("future", 
[16:05:09.677]                           quietly = TRUE)
[16:05:09.677]                         if (has_future) {
[16:05:09.677]                           ns <- base::getNamespace("future")
[16:05:09.677]                           version <- ns[[".package"]][["version"]]
[16:05:09.677]                           if (is.null(version)) 
[16:05:09.677]                             version <- utils::packageVersion("future")
[16:05:09.677]                         }
[16:05:09.677]                         else {
[16:05:09.677]                           version <- NULL
[16:05:09.677]                         }
[16:05:09.677]                         if (!has_future || version < "1.8.0") {
[16:05:09.677]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:09.677]                             "", base::R.version$version.string), 
[16:05:09.677]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:09.677]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:09.677]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:09.677]                               "release", "version")], collapse = " "), 
[16:05:09.677]                             hostname = base::Sys.info()[["nodename"]])
[16:05:09.677]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:09.677]                             info)
[16:05:09.677]                           info <- base::paste(info, collapse = "; ")
[16:05:09.677]                           if (!has_future) {
[16:05:09.677]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:09.677]                               info)
[16:05:09.677]                           }
[16:05:09.677]                           else {
[16:05:09.677]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:09.677]                               info, version)
[16:05:09.677]                           }
[16:05:09.677]                           base::stop(msg)
[16:05:09.677]                         }
[16:05:09.677]                       })
[16:05:09.677]                     }
[16:05:09.677]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:09.677]                     base::options(mc.cores = 1L)
[16:05:09.677]                   }
[16:05:09.677]                   options(future.plan = NULL)
[16:05:09.677]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.677]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:09.677]                 }
[16:05:09.677]                 ...future.workdir <- getwd()
[16:05:09.677]             }
[16:05:09.677]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:09.677]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:09.677]         }
[16:05:09.677]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:09.677]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:09.677]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:09.677]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:09.677]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:09.677]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:09.677]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:09.677]             base::names(...future.oldOptions))
[16:05:09.677]     }
[16:05:09.677]     if (FALSE) {
[16:05:09.677]     }
[16:05:09.677]     else {
[16:05:09.677]         if (TRUE) {
[16:05:09.677]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:09.677]                 open = "w")
[16:05:09.677]         }
[16:05:09.677]         else {
[16:05:09.677]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:09.677]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:09.677]         }
[16:05:09.677]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:09.677]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:09.677]             base::sink(type = "output", split = FALSE)
[16:05:09.677]             base::close(...future.stdout)
[16:05:09.677]         }, add = TRUE)
[16:05:09.677]     }
[16:05:09.677]     ...future.frame <- base::sys.nframe()
[16:05:09.677]     ...future.conditions <- base::list()
[16:05:09.677]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:09.677]     if (FALSE) {
[16:05:09.677]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:09.677]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:09.677]     }
[16:05:09.677]     ...future.result <- base::tryCatch({
[16:05:09.677]         base::withCallingHandlers({
[16:05:09.677]             ...future.value <- base::withVisible(base::local({
[16:05:09.677]                 ...future.makeSendCondition <- base::local({
[16:05:09.677]                   sendCondition <- NULL
[16:05:09.677]                   function(frame = 1L) {
[16:05:09.677]                     if (is.function(sendCondition)) 
[16:05:09.677]                       return(sendCondition)
[16:05:09.677]                     ns <- getNamespace("parallel")
[16:05:09.677]                     if (exists("sendData", mode = "function", 
[16:05:09.677]                       envir = ns)) {
[16:05:09.677]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:09.677]                         envir = ns)
[16:05:09.677]                       envir <- sys.frame(frame)
[16:05:09.677]                       master <- NULL
[16:05:09.677]                       while (!identical(envir, .GlobalEnv) && 
[16:05:09.677]                         !identical(envir, emptyenv())) {
[16:05:09.677]                         if (exists("master", mode = "list", envir = envir, 
[16:05:09.677]                           inherits = FALSE)) {
[16:05:09.677]                           master <- get("master", mode = "list", 
[16:05:09.677]                             envir = envir, inherits = FALSE)
[16:05:09.677]                           if (inherits(master, c("SOCKnode", 
[16:05:09.677]                             "SOCK0node"))) {
[16:05:09.677]                             sendCondition <<- function(cond) {
[16:05:09.677]                               data <- list(type = "VALUE", value = cond, 
[16:05:09.677]                                 success = TRUE)
[16:05:09.677]                               parallel_sendData(master, data)
[16:05:09.677]                             }
[16:05:09.677]                             return(sendCondition)
[16:05:09.677]                           }
[16:05:09.677]                         }
[16:05:09.677]                         frame <- frame + 1L
[16:05:09.677]                         envir <- sys.frame(frame)
[16:05:09.677]                       }
[16:05:09.677]                     }
[16:05:09.677]                     sendCondition <<- function(cond) NULL
[16:05:09.677]                   }
[16:05:09.677]                 })
[16:05:09.677]                 withCallingHandlers({
[16:05:09.677]                   1
[16:05:09.677]                 }, immediateCondition = function(cond) {
[16:05:09.677]                   sendCondition <- ...future.makeSendCondition()
[16:05:09.677]                   sendCondition(cond)
[16:05:09.677]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.677]                   {
[16:05:09.677]                     inherits <- base::inherits
[16:05:09.677]                     invokeRestart <- base::invokeRestart
[16:05:09.677]                     is.null <- base::is.null
[16:05:09.677]                     muffled <- FALSE
[16:05:09.677]                     if (inherits(cond, "message")) {
[16:05:09.677]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:09.677]                       if (muffled) 
[16:05:09.677]                         invokeRestart("muffleMessage")
[16:05:09.677]                     }
[16:05:09.677]                     else if (inherits(cond, "warning")) {
[16:05:09.677]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:09.677]                       if (muffled) 
[16:05:09.677]                         invokeRestart("muffleWarning")
[16:05:09.677]                     }
[16:05:09.677]                     else if (inherits(cond, "condition")) {
[16:05:09.677]                       if (!is.null(pattern)) {
[16:05:09.677]                         computeRestarts <- base::computeRestarts
[16:05:09.677]                         grepl <- base::grepl
[16:05:09.677]                         restarts <- computeRestarts(cond)
[16:05:09.677]                         for (restart in restarts) {
[16:05:09.677]                           name <- restart$name
[16:05:09.677]                           if (is.null(name)) 
[16:05:09.677]                             next
[16:05:09.677]                           if (!grepl(pattern, name)) 
[16:05:09.677]                             next
[16:05:09.677]                           invokeRestart(restart)
[16:05:09.677]                           muffled <- TRUE
[16:05:09.677]                           break
[16:05:09.677]                         }
[16:05:09.677]                       }
[16:05:09.677]                     }
[16:05:09.677]                     invisible(muffled)
[16:05:09.677]                   }
[16:05:09.677]                   muffleCondition(cond)
[16:05:09.677]                 })
[16:05:09.677]             }))
[16:05:09.677]             future::FutureResult(value = ...future.value$value, 
[16:05:09.677]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.677]                   ...future.rng), globalenv = if (FALSE) 
[16:05:09.677]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:09.677]                     ...future.globalenv.names))
[16:05:09.677]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:09.677]         }, condition = base::local({
[16:05:09.677]             c <- base::c
[16:05:09.677]             inherits <- base::inherits
[16:05:09.677]             invokeRestart <- base::invokeRestart
[16:05:09.677]             length <- base::length
[16:05:09.677]             list <- base::list
[16:05:09.677]             seq.int <- base::seq.int
[16:05:09.677]             signalCondition <- base::signalCondition
[16:05:09.677]             sys.calls <- base::sys.calls
[16:05:09.677]             `[[` <- base::`[[`
[16:05:09.677]             `+` <- base::`+`
[16:05:09.677]             `<<-` <- base::`<<-`
[16:05:09.677]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:09.677]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:09.677]                   3L)]
[16:05:09.677]             }
[16:05:09.677]             function(cond) {
[16:05:09.677]                 is_error <- inherits(cond, "error")
[16:05:09.677]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:09.677]                   NULL)
[16:05:09.677]                 if (is_error) {
[16:05:09.677]                   sessionInformation <- function() {
[16:05:09.677]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:09.677]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:09.677]                       search = base::search(), system = base::Sys.info())
[16:05:09.677]                   }
[16:05:09.677]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.677]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:09.677]                     cond$call), session = sessionInformation(), 
[16:05:09.677]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:09.677]                   signalCondition(cond)
[16:05:09.677]                 }
[16:05:09.677]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:09.677]                 "immediateCondition"))) {
[16:05:09.677]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:09.677]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.677]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:09.677]                   if (TRUE && !signal) {
[16:05:09.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.677]                     {
[16:05:09.677]                       inherits <- base::inherits
[16:05:09.677]                       invokeRestart <- base::invokeRestart
[16:05:09.677]                       is.null <- base::is.null
[16:05:09.677]                       muffled <- FALSE
[16:05:09.677]                       if (inherits(cond, "message")) {
[16:05:09.677]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.677]                         if (muffled) 
[16:05:09.677]                           invokeRestart("muffleMessage")
[16:05:09.677]                       }
[16:05:09.677]                       else if (inherits(cond, "warning")) {
[16:05:09.677]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.677]                         if (muffled) 
[16:05:09.677]                           invokeRestart("muffleWarning")
[16:05:09.677]                       }
[16:05:09.677]                       else if (inherits(cond, "condition")) {
[16:05:09.677]                         if (!is.null(pattern)) {
[16:05:09.677]                           computeRestarts <- base::computeRestarts
[16:05:09.677]                           grepl <- base::grepl
[16:05:09.677]                           restarts <- computeRestarts(cond)
[16:05:09.677]                           for (restart in restarts) {
[16:05:09.677]                             name <- restart$name
[16:05:09.677]                             if (is.null(name)) 
[16:05:09.677]                               next
[16:05:09.677]                             if (!grepl(pattern, name)) 
[16:05:09.677]                               next
[16:05:09.677]                             invokeRestart(restart)
[16:05:09.677]                             muffled <- TRUE
[16:05:09.677]                             break
[16:05:09.677]                           }
[16:05:09.677]                         }
[16:05:09.677]                       }
[16:05:09.677]                       invisible(muffled)
[16:05:09.677]                     }
[16:05:09.677]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.677]                   }
[16:05:09.677]                 }
[16:05:09.677]                 else {
[16:05:09.677]                   if (TRUE) {
[16:05:09.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.677]                     {
[16:05:09.677]                       inherits <- base::inherits
[16:05:09.677]                       invokeRestart <- base::invokeRestart
[16:05:09.677]                       is.null <- base::is.null
[16:05:09.677]                       muffled <- FALSE
[16:05:09.677]                       if (inherits(cond, "message")) {
[16:05:09.677]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.677]                         if (muffled) 
[16:05:09.677]                           invokeRestart("muffleMessage")
[16:05:09.677]                       }
[16:05:09.677]                       else if (inherits(cond, "warning")) {
[16:05:09.677]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.677]                         if (muffled) 
[16:05:09.677]                           invokeRestart("muffleWarning")
[16:05:09.677]                       }
[16:05:09.677]                       else if (inherits(cond, "condition")) {
[16:05:09.677]                         if (!is.null(pattern)) {
[16:05:09.677]                           computeRestarts <- base::computeRestarts
[16:05:09.677]                           grepl <- base::grepl
[16:05:09.677]                           restarts <- computeRestarts(cond)
[16:05:09.677]                           for (restart in restarts) {
[16:05:09.677]                             name <- restart$name
[16:05:09.677]                             if (is.null(name)) 
[16:05:09.677]                               next
[16:05:09.677]                             if (!grepl(pattern, name)) 
[16:05:09.677]                               next
[16:05:09.677]                             invokeRestart(restart)
[16:05:09.677]                             muffled <- TRUE
[16:05:09.677]                             break
[16:05:09.677]                           }
[16:05:09.677]                         }
[16:05:09.677]                       }
[16:05:09.677]                       invisible(muffled)
[16:05:09.677]                     }
[16:05:09.677]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.677]                   }
[16:05:09.677]                 }
[16:05:09.677]             }
[16:05:09.677]         }))
[16:05:09.677]     }, error = function(ex) {
[16:05:09.677]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:09.677]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.677]                 ...future.rng), started = ...future.startTime, 
[16:05:09.677]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:09.677]             version = "1.8"), class = "FutureResult")
[16:05:09.677]     }, finally = {
[16:05:09.677]         if (!identical(...future.workdir, getwd())) 
[16:05:09.677]             setwd(...future.workdir)
[16:05:09.677]         {
[16:05:09.677]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:09.677]                 ...future.oldOptions$nwarnings <- NULL
[16:05:09.677]             }
[16:05:09.677]             base::options(...future.oldOptions)
[16:05:09.677]             if (.Platform$OS.type == "windows") {
[16:05:09.677]                 old_names <- names(...future.oldEnvVars)
[16:05:09.677]                 envs <- base::Sys.getenv()
[16:05:09.677]                 names <- names(envs)
[16:05:09.677]                 common <- intersect(names, old_names)
[16:05:09.677]                 added <- setdiff(names, old_names)
[16:05:09.677]                 removed <- setdiff(old_names, names)
[16:05:09.677]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:09.677]                   envs[common]]
[16:05:09.677]                 NAMES <- toupper(changed)
[16:05:09.677]                 args <- list()
[16:05:09.677]                 for (kk in seq_along(NAMES)) {
[16:05:09.677]                   name <- changed[[kk]]
[16:05:09.677]                   NAME <- NAMES[[kk]]
[16:05:09.677]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.677]                     next
[16:05:09.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.677]                 }
[16:05:09.677]                 NAMES <- toupper(added)
[16:05:09.677]                 for (kk in seq_along(NAMES)) {
[16:05:09.677]                   name <- added[[kk]]
[16:05:09.677]                   NAME <- NAMES[[kk]]
[16:05:09.677]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.677]                     next
[16:05:09.677]                   args[[name]] <- ""
[16:05:09.677]                 }
[16:05:09.677]                 NAMES <- toupper(removed)
[16:05:09.677]                 for (kk in seq_along(NAMES)) {
[16:05:09.677]                   name <- removed[[kk]]
[16:05:09.677]                   NAME <- NAMES[[kk]]
[16:05:09.677]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.677]                     next
[16:05:09.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.677]                 }
[16:05:09.677]                 if (length(args) > 0) 
[16:05:09.677]                   base::do.call(base::Sys.setenv, args = args)
[16:05:09.677]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:09.677]             }
[16:05:09.677]             else {
[16:05:09.677]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:09.677]             }
[16:05:09.677]             {
[16:05:09.677]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:09.677]                   0L) {
[16:05:09.677]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:09.677]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:09.677]                   base::options(opts)
[16:05:09.677]                 }
[16:05:09.677]                 {
[16:05:09.677]                   {
[16:05:09.677]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:09.677]                     NULL
[16:05:09.677]                   }
[16:05:09.677]                   options(future.plan = NULL)
[16:05:09.677]                   if (is.na(NA_character_)) 
[16:05:09.677]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.677]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:09.677]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:09.677]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:09.677]                     envir = parent.frame()) 
[16:05:09.677]                   {
[16:05:09.677]                     if (is.function(workers)) 
[16:05:09.677]                       workers <- workers()
[16:05:09.677]                     workers <- structure(as.integer(workers), 
[16:05:09.677]                       class = class(workers))
[16:05:09.677]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:09.677]                       workers >= 1)
[16:05:09.677]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:09.677]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:09.677]                     }
[16:05:09.677]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:09.677]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:09.677]                       envir = envir)
[16:05:09.677]                     if (!future$lazy) 
[16:05:09.677]                       future <- run(future)
[16:05:09.677]                     invisible(future)
[16:05:09.677]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:09.677]                 }
[16:05:09.677]             }
[16:05:09.677]         }
[16:05:09.677]     })
[16:05:09.677]     if (TRUE) {
[16:05:09.677]         base::sink(type = "output", split = FALSE)
[16:05:09.677]         if (TRUE) {
[16:05:09.677]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:09.677]         }
[16:05:09.677]         else {
[16:05:09.677]             ...future.result["stdout"] <- base::list(NULL)
[16:05:09.677]         }
[16:05:09.677]         base::close(...future.stdout)
[16:05:09.677]         ...future.stdout <- NULL
[16:05:09.677]     }
[16:05:09.677]     ...future.result$conditions <- ...future.conditions
[16:05:09.677]     ...future.result$finished <- base::Sys.time()
[16:05:09.677]     ...future.result
[16:05:09.677] }
[16:05:09.680] MultisessionFuture started
[16:05:09.680] - Launch lazy future ... done
[16:05:09.680] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:09.680] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:09.680] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:09.681] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:09.681] Searching for globals ... DONE
[16:05:09.681] Resolving globals: TRUE
[16:05:09.682] Resolving any globals that are futures ...
[16:05:09.682] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:09.682] Resolving any globals that are futures ... DONE
[16:05:09.682] Resolving futures part of globals (recursively) ...
[16:05:09.682] resolve() on list ...
[16:05:09.682]  recursive: 99
[16:05:09.682]  length: 1
[16:05:09.683]  elements: ‘a’
[16:05:09.728] receiveMessageFromWorker() for ClusterFuture ...
[16:05:09.728] - Validating connection of MultisessionFuture
[16:05:09.728] - received message: FutureResult
[16:05:09.728] - Received FutureResult
[16:05:09.729] - Erased future from FutureRegistry
[16:05:09.729] result() for ClusterFuture ...
[16:05:09.729] - result already collected: FutureResult
[16:05:09.729] result() for ClusterFuture ... done
[16:05:09.729] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:09.729] Future #1
[16:05:09.729] result() for ClusterFuture ...
[16:05:09.729] - result already collected: FutureResult
[16:05:09.729] result() for ClusterFuture ... done
[16:05:09.729] result() for ClusterFuture ...
[16:05:09.730] - result already collected: FutureResult
[16:05:09.730] result() for ClusterFuture ... done
[16:05:09.730] A MultisessionFuture was resolved
[16:05:09.730]  length: 0 (resolved future 1)
[16:05:09.730] resolve() on list ... DONE
[16:05:09.730] - globals: [1] ‘a’
[16:05:09.730] Resolving futures part of globals (recursively) ... DONE
[16:05:09.731] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[16:05:09.732] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[16:05:09.732] - globals: [1] ‘a’
[16:05:09.732] - packages: [1] ‘future’
[16:05:09.732] getGlobalsAndPackages() ... DONE
[16:05:09.732] run() for ‘Future’ ...
[16:05:09.732] - state: ‘created’
[16:05:09.733] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:09.746] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:09.746] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:09.746]   - Field: ‘node’
[16:05:09.747]   - Field: ‘label’
[16:05:09.747]   - Field: ‘local’
[16:05:09.747]   - Field: ‘owner’
[16:05:09.747]   - Field: ‘envir’
[16:05:09.747]   - Field: ‘workers’
[16:05:09.747]   - Field: ‘packages’
[16:05:09.747]   - Field: ‘gc’
[16:05:09.747]   - Field: ‘conditions’
[16:05:09.747]   - Field: ‘persistent’
[16:05:09.747]   - Field: ‘expr’
[16:05:09.748]   - Field: ‘uuid’
[16:05:09.748]   - Field: ‘seed’
[16:05:09.748]   - Field: ‘version’
[16:05:09.748]   - Field: ‘result’
[16:05:09.748]   - Field: ‘asynchronous’
[16:05:09.748]   - Field: ‘calls’
[16:05:09.748]   - Field: ‘globals’
[16:05:09.748]   - Field: ‘stdout’
[16:05:09.748]   - Field: ‘earlySignal’
[16:05:09.748]   - Field: ‘lazy’
[16:05:09.748]   - Field: ‘state’
[16:05:09.749] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:09.749] - Launch lazy future ...
[16:05:09.749] Packages needed by the future expression (n = 1): ‘future’
[16:05:09.749] Packages needed by future strategies (n = 0): <none>
[16:05:09.750] {
[16:05:09.750]     {
[16:05:09.750]         {
[16:05:09.750]             ...future.startTime <- base::Sys.time()
[16:05:09.750]             {
[16:05:09.750]                 {
[16:05:09.750]                   {
[16:05:09.750]                     {
[16:05:09.750]                       {
[16:05:09.750]                         base::local({
[16:05:09.750]                           has_future <- base::requireNamespace("future", 
[16:05:09.750]                             quietly = TRUE)
[16:05:09.750]                           if (has_future) {
[16:05:09.750]                             ns <- base::getNamespace("future")
[16:05:09.750]                             version <- ns[[".package"]][["version"]]
[16:05:09.750]                             if (is.null(version)) 
[16:05:09.750]                               version <- utils::packageVersion("future")
[16:05:09.750]                           }
[16:05:09.750]                           else {
[16:05:09.750]                             version <- NULL
[16:05:09.750]                           }
[16:05:09.750]                           if (!has_future || version < "1.8.0") {
[16:05:09.750]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:09.750]                               "", base::R.version$version.string), 
[16:05:09.750]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:09.750]                                 base::R.version$platform, 8 * 
[16:05:09.750]                                   base::.Machine$sizeof.pointer), 
[16:05:09.750]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:09.750]                                 "release", "version")], collapse = " "), 
[16:05:09.750]                               hostname = base::Sys.info()[["nodename"]])
[16:05:09.750]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:09.750]                               info)
[16:05:09.750]                             info <- base::paste(info, collapse = "; ")
[16:05:09.750]                             if (!has_future) {
[16:05:09.750]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:09.750]                                 info)
[16:05:09.750]                             }
[16:05:09.750]                             else {
[16:05:09.750]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:09.750]                                 info, version)
[16:05:09.750]                             }
[16:05:09.750]                             base::stop(msg)
[16:05:09.750]                           }
[16:05:09.750]                         })
[16:05:09.750]                       }
[16:05:09.750]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:09.750]                       base::options(mc.cores = 1L)
[16:05:09.750]                     }
[16:05:09.750]                     base::local({
[16:05:09.750]                       for (pkg in "future") {
[16:05:09.750]                         base::loadNamespace(pkg)
[16:05:09.750]                         base::library(pkg, character.only = TRUE)
[16:05:09.750]                       }
[16:05:09.750]                     })
[16:05:09.750]                   }
[16:05:09.750]                   options(future.plan = NULL)
[16:05:09.750]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.750]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:09.750]                 }
[16:05:09.750]                 ...future.workdir <- getwd()
[16:05:09.750]             }
[16:05:09.750]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:09.750]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:09.750]         }
[16:05:09.750]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:09.750]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:09.750]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:09.750]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:09.750]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:09.750]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:09.750]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:09.750]             base::names(...future.oldOptions))
[16:05:09.750]     }
[16:05:09.750]     if (FALSE) {
[16:05:09.750]     }
[16:05:09.750]     else {
[16:05:09.750]         if (TRUE) {
[16:05:09.750]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:09.750]                 open = "w")
[16:05:09.750]         }
[16:05:09.750]         else {
[16:05:09.750]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:09.750]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:09.750]         }
[16:05:09.750]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:09.750]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:09.750]             base::sink(type = "output", split = FALSE)
[16:05:09.750]             base::close(...future.stdout)
[16:05:09.750]         }, add = TRUE)
[16:05:09.750]     }
[16:05:09.750]     ...future.frame <- base::sys.nframe()
[16:05:09.750]     ...future.conditions <- base::list()
[16:05:09.750]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:09.750]     if (FALSE) {
[16:05:09.750]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:09.750]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:09.750]     }
[16:05:09.750]     ...future.result <- base::tryCatch({
[16:05:09.750]         base::withCallingHandlers({
[16:05:09.750]             ...future.value <- base::withVisible(base::local({
[16:05:09.750]                 ...future.makeSendCondition <- base::local({
[16:05:09.750]                   sendCondition <- NULL
[16:05:09.750]                   function(frame = 1L) {
[16:05:09.750]                     if (is.function(sendCondition)) 
[16:05:09.750]                       return(sendCondition)
[16:05:09.750]                     ns <- getNamespace("parallel")
[16:05:09.750]                     if (exists("sendData", mode = "function", 
[16:05:09.750]                       envir = ns)) {
[16:05:09.750]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:09.750]                         envir = ns)
[16:05:09.750]                       envir <- sys.frame(frame)
[16:05:09.750]                       master <- NULL
[16:05:09.750]                       while (!identical(envir, .GlobalEnv) && 
[16:05:09.750]                         !identical(envir, emptyenv())) {
[16:05:09.750]                         if (exists("master", mode = "list", envir = envir, 
[16:05:09.750]                           inherits = FALSE)) {
[16:05:09.750]                           master <- get("master", mode = "list", 
[16:05:09.750]                             envir = envir, inherits = FALSE)
[16:05:09.750]                           if (inherits(master, c("SOCKnode", 
[16:05:09.750]                             "SOCK0node"))) {
[16:05:09.750]                             sendCondition <<- function(cond) {
[16:05:09.750]                               data <- list(type = "VALUE", value = cond, 
[16:05:09.750]                                 success = TRUE)
[16:05:09.750]                               parallel_sendData(master, data)
[16:05:09.750]                             }
[16:05:09.750]                             return(sendCondition)
[16:05:09.750]                           }
[16:05:09.750]                         }
[16:05:09.750]                         frame <- frame + 1L
[16:05:09.750]                         envir <- sys.frame(frame)
[16:05:09.750]                       }
[16:05:09.750]                     }
[16:05:09.750]                     sendCondition <<- function(cond) NULL
[16:05:09.750]                   }
[16:05:09.750]                 })
[16:05:09.750]                 withCallingHandlers({
[16:05:09.750]                   value(a) + 1
[16:05:09.750]                 }, immediateCondition = function(cond) {
[16:05:09.750]                   sendCondition <- ...future.makeSendCondition()
[16:05:09.750]                   sendCondition(cond)
[16:05:09.750]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.750]                   {
[16:05:09.750]                     inherits <- base::inherits
[16:05:09.750]                     invokeRestart <- base::invokeRestart
[16:05:09.750]                     is.null <- base::is.null
[16:05:09.750]                     muffled <- FALSE
[16:05:09.750]                     if (inherits(cond, "message")) {
[16:05:09.750]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:09.750]                       if (muffled) 
[16:05:09.750]                         invokeRestart("muffleMessage")
[16:05:09.750]                     }
[16:05:09.750]                     else if (inherits(cond, "warning")) {
[16:05:09.750]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:09.750]                       if (muffled) 
[16:05:09.750]                         invokeRestart("muffleWarning")
[16:05:09.750]                     }
[16:05:09.750]                     else if (inherits(cond, "condition")) {
[16:05:09.750]                       if (!is.null(pattern)) {
[16:05:09.750]                         computeRestarts <- base::computeRestarts
[16:05:09.750]                         grepl <- base::grepl
[16:05:09.750]                         restarts <- computeRestarts(cond)
[16:05:09.750]                         for (restart in restarts) {
[16:05:09.750]                           name <- restart$name
[16:05:09.750]                           if (is.null(name)) 
[16:05:09.750]                             next
[16:05:09.750]                           if (!grepl(pattern, name)) 
[16:05:09.750]                             next
[16:05:09.750]                           invokeRestart(restart)
[16:05:09.750]                           muffled <- TRUE
[16:05:09.750]                           break
[16:05:09.750]                         }
[16:05:09.750]                       }
[16:05:09.750]                     }
[16:05:09.750]                     invisible(muffled)
[16:05:09.750]                   }
[16:05:09.750]                   muffleCondition(cond)
[16:05:09.750]                 })
[16:05:09.750]             }))
[16:05:09.750]             future::FutureResult(value = ...future.value$value, 
[16:05:09.750]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.750]                   ...future.rng), globalenv = if (FALSE) 
[16:05:09.750]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:09.750]                     ...future.globalenv.names))
[16:05:09.750]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:09.750]         }, condition = base::local({
[16:05:09.750]             c <- base::c
[16:05:09.750]             inherits <- base::inherits
[16:05:09.750]             invokeRestart <- base::invokeRestart
[16:05:09.750]             length <- base::length
[16:05:09.750]             list <- base::list
[16:05:09.750]             seq.int <- base::seq.int
[16:05:09.750]             signalCondition <- base::signalCondition
[16:05:09.750]             sys.calls <- base::sys.calls
[16:05:09.750]             `[[` <- base::`[[`
[16:05:09.750]             `+` <- base::`+`
[16:05:09.750]             `<<-` <- base::`<<-`
[16:05:09.750]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:09.750]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:09.750]                   3L)]
[16:05:09.750]             }
[16:05:09.750]             function(cond) {
[16:05:09.750]                 is_error <- inherits(cond, "error")
[16:05:09.750]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:09.750]                   NULL)
[16:05:09.750]                 if (is_error) {
[16:05:09.750]                   sessionInformation <- function() {
[16:05:09.750]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:09.750]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:09.750]                       search = base::search(), system = base::Sys.info())
[16:05:09.750]                   }
[16:05:09.750]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.750]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:09.750]                     cond$call), session = sessionInformation(), 
[16:05:09.750]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:09.750]                   signalCondition(cond)
[16:05:09.750]                 }
[16:05:09.750]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:09.750]                 "immediateCondition"))) {
[16:05:09.750]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:09.750]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.750]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:09.750]                   if (TRUE && !signal) {
[16:05:09.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.750]                     {
[16:05:09.750]                       inherits <- base::inherits
[16:05:09.750]                       invokeRestart <- base::invokeRestart
[16:05:09.750]                       is.null <- base::is.null
[16:05:09.750]                       muffled <- FALSE
[16:05:09.750]                       if (inherits(cond, "message")) {
[16:05:09.750]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.750]                         if (muffled) 
[16:05:09.750]                           invokeRestart("muffleMessage")
[16:05:09.750]                       }
[16:05:09.750]                       else if (inherits(cond, "warning")) {
[16:05:09.750]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.750]                         if (muffled) 
[16:05:09.750]                           invokeRestart("muffleWarning")
[16:05:09.750]                       }
[16:05:09.750]                       else if (inherits(cond, "condition")) {
[16:05:09.750]                         if (!is.null(pattern)) {
[16:05:09.750]                           computeRestarts <- base::computeRestarts
[16:05:09.750]                           grepl <- base::grepl
[16:05:09.750]                           restarts <- computeRestarts(cond)
[16:05:09.750]                           for (restart in restarts) {
[16:05:09.750]                             name <- restart$name
[16:05:09.750]                             if (is.null(name)) 
[16:05:09.750]                               next
[16:05:09.750]                             if (!grepl(pattern, name)) 
[16:05:09.750]                               next
[16:05:09.750]                             invokeRestart(restart)
[16:05:09.750]                             muffled <- TRUE
[16:05:09.750]                             break
[16:05:09.750]                           }
[16:05:09.750]                         }
[16:05:09.750]                       }
[16:05:09.750]                       invisible(muffled)
[16:05:09.750]                     }
[16:05:09.750]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.750]                   }
[16:05:09.750]                 }
[16:05:09.750]                 else {
[16:05:09.750]                   if (TRUE) {
[16:05:09.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.750]                     {
[16:05:09.750]                       inherits <- base::inherits
[16:05:09.750]                       invokeRestart <- base::invokeRestart
[16:05:09.750]                       is.null <- base::is.null
[16:05:09.750]                       muffled <- FALSE
[16:05:09.750]                       if (inherits(cond, "message")) {
[16:05:09.750]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.750]                         if (muffled) 
[16:05:09.750]                           invokeRestart("muffleMessage")
[16:05:09.750]                       }
[16:05:09.750]                       else if (inherits(cond, "warning")) {
[16:05:09.750]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.750]                         if (muffled) 
[16:05:09.750]                           invokeRestart("muffleWarning")
[16:05:09.750]                       }
[16:05:09.750]                       else if (inherits(cond, "condition")) {
[16:05:09.750]                         if (!is.null(pattern)) {
[16:05:09.750]                           computeRestarts <- base::computeRestarts
[16:05:09.750]                           grepl <- base::grepl
[16:05:09.750]                           restarts <- computeRestarts(cond)
[16:05:09.750]                           for (restart in restarts) {
[16:05:09.750]                             name <- restart$name
[16:05:09.750]                             if (is.null(name)) 
[16:05:09.750]                               next
[16:05:09.750]                             if (!grepl(pattern, name)) 
[16:05:09.750]                               next
[16:05:09.750]                             invokeRestart(restart)
[16:05:09.750]                             muffled <- TRUE
[16:05:09.750]                             break
[16:05:09.750]                           }
[16:05:09.750]                         }
[16:05:09.750]                       }
[16:05:09.750]                       invisible(muffled)
[16:05:09.750]                     }
[16:05:09.750]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.750]                   }
[16:05:09.750]                 }
[16:05:09.750]             }
[16:05:09.750]         }))
[16:05:09.750]     }, error = function(ex) {
[16:05:09.750]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:09.750]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.750]                 ...future.rng), started = ...future.startTime, 
[16:05:09.750]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:09.750]             version = "1.8"), class = "FutureResult")
[16:05:09.750]     }, finally = {
[16:05:09.750]         if (!identical(...future.workdir, getwd())) 
[16:05:09.750]             setwd(...future.workdir)
[16:05:09.750]         {
[16:05:09.750]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:09.750]                 ...future.oldOptions$nwarnings <- NULL
[16:05:09.750]             }
[16:05:09.750]             base::options(...future.oldOptions)
[16:05:09.750]             if (.Platform$OS.type == "windows") {
[16:05:09.750]                 old_names <- names(...future.oldEnvVars)
[16:05:09.750]                 envs <- base::Sys.getenv()
[16:05:09.750]                 names <- names(envs)
[16:05:09.750]                 common <- intersect(names, old_names)
[16:05:09.750]                 added <- setdiff(names, old_names)
[16:05:09.750]                 removed <- setdiff(old_names, names)
[16:05:09.750]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:09.750]                   envs[common]]
[16:05:09.750]                 NAMES <- toupper(changed)
[16:05:09.750]                 args <- list()
[16:05:09.750]                 for (kk in seq_along(NAMES)) {
[16:05:09.750]                   name <- changed[[kk]]
[16:05:09.750]                   NAME <- NAMES[[kk]]
[16:05:09.750]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.750]                     next
[16:05:09.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.750]                 }
[16:05:09.750]                 NAMES <- toupper(added)
[16:05:09.750]                 for (kk in seq_along(NAMES)) {
[16:05:09.750]                   name <- added[[kk]]
[16:05:09.750]                   NAME <- NAMES[[kk]]
[16:05:09.750]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.750]                     next
[16:05:09.750]                   args[[name]] <- ""
[16:05:09.750]                 }
[16:05:09.750]                 NAMES <- toupper(removed)
[16:05:09.750]                 for (kk in seq_along(NAMES)) {
[16:05:09.750]                   name <- removed[[kk]]
[16:05:09.750]                   NAME <- NAMES[[kk]]
[16:05:09.750]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.750]                     next
[16:05:09.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.750]                 }
[16:05:09.750]                 if (length(args) > 0) 
[16:05:09.750]                   base::do.call(base::Sys.setenv, args = args)
[16:05:09.750]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:09.750]             }
[16:05:09.750]             else {
[16:05:09.750]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:09.750]             }
[16:05:09.750]             {
[16:05:09.750]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:09.750]                   0L) {
[16:05:09.750]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:09.750]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:09.750]                   base::options(opts)
[16:05:09.750]                 }
[16:05:09.750]                 {
[16:05:09.750]                   {
[16:05:09.750]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:09.750]                     NULL
[16:05:09.750]                   }
[16:05:09.750]                   options(future.plan = NULL)
[16:05:09.750]                   if (is.na(NA_character_)) 
[16:05:09.750]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.750]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:09.750]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:09.750]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:09.750]                     envir = parent.frame()) 
[16:05:09.750]                   {
[16:05:09.750]                     if (is.function(workers)) 
[16:05:09.750]                       workers <- workers()
[16:05:09.750]                     workers <- structure(as.integer(workers), 
[16:05:09.750]                       class = class(workers))
[16:05:09.750]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:09.750]                       workers >= 1)
[16:05:09.750]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:09.750]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:09.750]                     }
[16:05:09.750]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:09.750]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:09.750]                       envir = envir)
[16:05:09.750]                     if (!future$lazy) 
[16:05:09.750]                       future <- run(future)
[16:05:09.750]                     invisible(future)
[16:05:09.750]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:09.750]                 }
[16:05:09.750]             }
[16:05:09.750]         }
[16:05:09.750]     })
[16:05:09.750]     if (TRUE) {
[16:05:09.750]         base::sink(type = "output", split = FALSE)
[16:05:09.750]         if (TRUE) {
[16:05:09.750]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:09.750]         }
[16:05:09.750]         else {
[16:05:09.750]             ...future.result["stdout"] <- base::list(NULL)
[16:05:09.750]         }
[16:05:09.750]         base::close(...future.stdout)
[16:05:09.750]         ...future.stdout <- NULL
[16:05:09.750]     }
[16:05:09.750]     ...future.result$conditions <- ...future.conditions
[16:05:09.750]     ...future.result$finished <- base::Sys.time()
[16:05:09.750]     ...future.result
[16:05:09.750] }
[16:05:09.752] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[16:05:09.753] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[16:05:09.803] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[16:05:09.803] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[16:05:09.804] MultisessionFuture started
[16:05:09.804] - Launch lazy future ... done
[16:05:09.804] run() for ‘MultisessionFuture’ ... done
[16:05:09.804] result() for ClusterFuture ...
[16:05:09.804] receiveMessageFromWorker() for ClusterFuture ...
[16:05:09.805] - Validating connection of MultisessionFuture
[16:05:09.852] - received message: FutureResult
[16:05:09.853] - Received FutureResult
[16:05:09.853] - Erased future from FutureRegistry
[16:05:09.853] result() for ClusterFuture ...
[16:05:09.853] - result already collected: FutureResult
[16:05:09.853] result() for ClusterFuture ... done
[16:05:09.853] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:09.853] result() for ClusterFuture ... done
[16:05:09.853] result() for ClusterFuture ...
[16:05:09.853] - result already collected: FutureResult
[16:05:09.853] result() for ClusterFuture ... done
value(b) = 2
[16:05:09.854] result() for ClusterFuture ...
[16:05:09.854] - result already collected: FutureResult
[16:05:09.854] result() for ClusterFuture ... done
[16:05:09.854] result() for ClusterFuture ...
[16:05:09.854] - result already collected: FutureResult
[16:05:09.854] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:09.854] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:09.855] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:09.855] 
[16:05:09.855] Searching for globals ... DONE
[16:05:09.855] - globals: [0] <none>
[16:05:09.856] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:09.856] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:09.856] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:09.857] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:09.857] Searching for globals ... DONE
[16:05:09.857] Resolving globals: TRUE
[16:05:09.857] Resolving any globals that are futures ...
[16:05:09.857] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:09.857] Resolving any globals that are futures ... DONE
[16:05:09.858] Resolving futures part of globals (recursively) ...
[16:05:09.858] resolve() on list ...
[16:05:09.858]  recursive: 99
[16:05:09.858]  length: 1
[16:05:09.858]  elements: ‘a’
[16:05:09.858] run() for ‘Future’ ...
[16:05:09.858] - state: ‘created’
[16:05:09.859] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:09.872] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:09.873] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:09.873]   - Field: ‘node’
[16:05:09.873]   - Field: ‘label’
[16:05:09.873]   - Field: ‘local’
[16:05:09.873]   - Field: ‘owner’
[16:05:09.873]   - Field: ‘envir’
[16:05:09.873]   - Field: ‘workers’
[16:05:09.873]   - Field: ‘packages’
[16:05:09.873]   - Field: ‘gc’
[16:05:09.873]   - Field: ‘conditions’
[16:05:09.874]   - Field: ‘persistent’
[16:05:09.874]   - Field: ‘expr’
[16:05:09.874]   - Field: ‘uuid’
[16:05:09.874]   - Field: ‘seed’
[16:05:09.874]   - Field: ‘version’
[16:05:09.874]   - Field: ‘result’
[16:05:09.874]   - Field: ‘asynchronous’
[16:05:09.874]   - Field: ‘calls’
[16:05:09.874]   - Field: ‘globals’
[16:05:09.874]   - Field: ‘stdout’
[16:05:09.874]   - Field: ‘earlySignal’
[16:05:09.875]   - Field: ‘lazy’
[16:05:09.875]   - Field: ‘state’
[16:05:09.875] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:09.875] - Launch lazy future ...
[16:05:09.875] Packages needed by the future expression (n = 0): <none>
[16:05:09.875] Packages needed by future strategies (n = 0): <none>
[16:05:09.876] {
[16:05:09.876]     {
[16:05:09.876]         {
[16:05:09.876]             ...future.startTime <- base::Sys.time()
[16:05:09.876]             {
[16:05:09.876]                 {
[16:05:09.876]                   {
[16:05:09.876]                     {
[16:05:09.876]                       base::local({
[16:05:09.876]                         has_future <- base::requireNamespace("future", 
[16:05:09.876]                           quietly = TRUE)
[16:05:09.876]                         if (has_future) {
[16:05:09.876]                           ns <- base::getNamespace("future")
[16:05:09.876]                           version <- ns[[".package"]][["version"]]
[16:05:09.876]                           if (is.null(version)) 
[16:05:09.876]                             version <- utils::packageVersion("future")
[16:05:09.876]                         }
[16:05:09.876]                         else {
[16:05:09.876]                           version <- NULL
[16:05:09.876]                         }
[16:05:09.876]                         if (!has_future || version < "1.8.0") {
[16:05:09.876]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:09.876]                             "", base::R.version$version.string), 
[16:05:09.876]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:09.876]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:09.876]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:09.876]                               "release", "version")], collapse = " "), 
[16:05:09.876]                             hostname = base::Sys.info()[["nodename"]])
[16:05:09.876]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:09.876]                             info)
[16:05:09.876]                           info <- base::paste(info, collapse = "; ")
[16:05:09.876]                           if (!has_future) {
[16:05:09.876]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:09.876]                               info)
[16:05:09.876]                           }
[16:05:09.876]                           else {
[16:05:09.876]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:09.876]                               info, version)
[16:05:09.876]                           }
[16:05:09.876]                           base::stop(msg)
[16:05:09.876]                         }
[16:05:09.876]                       })
[16:05:09.876]                     }
[16:05:09.876]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:09.876]                     base::options(mc.cores = 1L)
[16:05:09.876]                   }
[16:05:09.876]                   options(future.plan = NULL)
[16:05:09.876]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.876]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:09.876]                 }
[16:05:09.876]                 ...future.workdir <- getwd()
[16:05:09.876]             }
[16:05:09.876]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:09.876]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:09.876]         }
[16:05:09.876]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:09.876]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:09.876]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:09.876]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:09.876]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:09.876]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:09.876]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:09.876]             base::names(...future.oldOptions))
[16:05:09.876]     }
[16:05:09.876]     if (FALSE) {
[16:05:09.876]     }
[16:05:09.876]     else {
[16:05:09.876]         if (TRUE) {
[16:05:09.876]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:09.876]                 open = "w")
[16:05:09.876]         }
[16:05:09.876]         else {
[16:05:09.876]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:09.876]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:09.876]         }
[16:05:09.876]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:09.876]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:09.876]             base::sink(type = "output", split = FALSE)
[16:05:09.876]             base::close(...future.stdout)
[16:05:09.876]         }, add = TRUE)
[16:05:09.876]     }
[16:05:09.876]     ...future.frame <- base::sys.nframe()
[16:05:09.876]     ...future.conditions <- base::list()
[16:05:09.876]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:09.876]     if (FALSE) {
[16:05:09.876]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:09.876]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:09.876]     }
[16:05:09.876]     ...future.result <- base::tryCatch({
[16:05:09.876]         base::withCallingHandlers({
[16:05:09.876]             ...future.value <- base::withVisible(base::local({
[16:05:09.876]                 ...future.makeSendCondition <- base::local({
[16:05:09.876]                   sendCondition <- NULL
[16:05:09.876]                   function(frame = 1L) {
[16:05:09.876]                     if (is.function(sendCondition)) 
[16:05:09.876]                       return(sendCondition)
[16:05:09.876]                     ns <- getNamespace("parallel")
[16:05:09.876]                     if (exists("sendData", mode = "function", 
[16:05:09.876]                       envir = ns)) {
[16:05:09.876]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:09.876]                         envir = ns)
[16:05:09.876]                       envir <- sys.frame(frame)
[16:05:09.876]                       master <- NULL
[16:05:09.876]                       while (!identical(envir, .GlobalEnv) && 
[16:05:09.876]                         !identical(envir, emptyenv())) {
[16:05:09.876]                         if (exists("master", mode = "list", envir = envir, 
[16:05:09.876]                           inherits = FALSE)) {
[16:05:09.876]                           master <- get("master", mode = "list", 
[16:05:09.876]                             envir = envir, inherits = FALSE)
[16:05:09.876]                           if (inherits(master, c("SOCKnode", 
[16:05:09.876]                             "SOCK0node"))) {
[16:05:09.876]                             sendCondition <<- function(cond) {
[16:05:09.876]                               data <- list(type = "VALUE", value = cond, 
[16:05:09.876]                                 success = TRUE)
[16:05:09.876]                               parallel_sendData(master, data)
[16:05:09.876]                             }
[16:05:09.876]                             return(sendCondition)
[16:05:09.876]                           }
[16:05:09.876]                         }
[16:05:09.876]                         frame <- frame + 1L
[16:05:09.876]                         envir <- sys.frame(frame)
[16:05:09.876]                       }
[16:05:09.876]                     }
[16:05:09.876]                     sendCondition <<- function(cond) NULL
[16:05:09.876]                   }
[16:05:09.876]                 })
[16:05:09.876]                 withCallingHandlers({
[16:05:09.876]                   1
[16:05:09.876]                 }, immediateCondition = function(cond) {
[16:05:09.876]                   sendCondition <- ...future.makeSendCondition()
[16:05:09.876]                   sendCondition(cond)
[16:05:09.876]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.876]                   {
[16:05:09.876]                     inherits <- base::inherits
[16:05:09.876]                     invokeRestart <- base::invokeRestart
[16:05:09.876]                     is.null <- base::is.null
[16:05:09.876]                     muffled <- FALSE
[16:05:09.876]                     if (inherits(cond, "message")) {
[16:05:09.876]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:09.876]                       if (muffled) 
[16:05:09.876]                         invokeRestart("muffleMessage")
[16:05:09.876]                     }
[16:05:09.876]                     else if (inherits(cond, "warning")) {
[16:05:09.876]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:09.876]                       if (muffled) 
[16:05:09.876]                         invokeRestart("muffleWarning")
[16:05:09.876]                     }
[16:05:09.876]                     else if (inherits(cond, "condition")) {
[16:05:09.876]                       if (!is.null(pattern)) {
[16:05:09.876]                         computeRestarts <- base::computeRestarts
[16:05:09.876]                         grepl <- base::grepl
[16:05:09.876]                         restarts <- computeRestarts(cond)
[16:05:09.876]                         for (restart in restarts) {
[16:05:09.876]                           name <- restart$name
[16:05:09.876]                           if (is.null(name)) 
[16:05:09.876]                             next
[16:05:09.876]                           if (!grepl(pattern, name)) 
[16:05:09.876]                             next
[16:05:09.876]                           invokeRestart(restart)
[16:05:09.876]                           muffled <- TRUE
[16:05:09.876]                           break
[16:05:09.876]                         }
[16:05:09.876]                       }
[16:05:09.876]                     }
[16:05:09.876]                     invisible(muffled)
[16:05:09.876]                   }
[16:05:09.876]                   muffleCondition(cond)
[16:05:09.876]                 })
[16:05:09.876]             }))
[16:05:09.876]             future::FutureResult(value = ...future.value$value, 
[16:05:09.876]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.876]                   ...future.rng), globalenv = if (FALSE) 
[16:05:09.876]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:09.876]                     ...future.globalenv.names))
[16:05:09.876]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:09.876]         }, condition = base::local({
[16:05:09.876]             c <- base::c
[16:05:09.876]             inherits <- base::inherits
[16:05:09.876]             invokeRestart <- base::invokeRestart
[16:05:09.876]             length <- base::length
[16:05:09.876]             list <- base::list
[16:05:09.876]             seq.int <- base::seq.int
[16:05:09.876]             signalCondition <- base::signalCondition
[16:05:09.876]             sys.calls <- base::sys.calls
[16:05:09.876]             `[[` <- base::`[[`
[16:05:09.876]             `+` <- base::`+`
[16:05:09.876]             `<<-` <- base::`<<-`
[16:05:09.876]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:09.876]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:09.876]                   3L)]
[16:05:09.876]             }
[16:05:09.876]             function(cond) {
[16:05:09.876]                 is_error <- inherits(cond, "error")
[16:05:09.876]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:09.876]                   NULL)
[16:05:09.876]                 if (is_error) {
[16:05:09.876]                   sessionInformation <- function() {
[16:05:09.876]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:09.876]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:09.876]                       search = base::search(), system = base::Sys.info())
[16:05:09.876]                   }
[16:05:09.876]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.876]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:09.876]                     cond$call), session = sessionInformation(), 
[16:05:09.876]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:09.876]                   signalCondition(cond)
[16:05:09.876]                 }
[16:05:09.876]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:09.876]                 "immediateCondition"))) {
[16:05:09.876]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:09.876]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.876]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:09.876]                   if (TRUE && !signal) {
[16:05:09.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.876]                     {
[16:05:09.876]                       inherits <- base::inherits
[16:05:09.876]                       invokeRestart <- base::invokeRestart
[16:05:09.876]                       is.null <- base::is.null
[16:05:09.876]                       muffled <- FALSE
[16:05:09.876]                       if (inherits(cond, "message")) {
[16:05:09.876]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.876]                         if (muffled) 
[16:05:09.876]                           invokeRestart("muffleMessage")
[16:05:09.876]                       }
[16:05:09.876]                       else if (inherits(cond, "warning")) {
[16:05:09.876]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.876]                         if (muffled) 
[16:05:09.876]                           invokeRestart("muffleWarning")
[16:05:09.876]                       }
[16:05:09.876]                       else if (inherits(cond, "condition")) {
[16:05:09.876]                         if (!is.null(pattern)) {
[16:05:09.876]                           computeRestarts <- base::computeRestarts
[16:05:09.876]                           grepl <- base::grepl
[16:05:09.876]                           restarts <- computeRestarts(cond)
[16:05:09.876]                           for (restart in restarts) {
[16:05:09.876]                             name <- restart$name
[16:05:09.876]                             if (is.null(name)) 
[16:05:09.876]                               next
[16:05:09.876]                             if (!grepl(pattern, name)) 
[16:05:09.876]                               next
[16:05:09.876]                             invokeRestart(restart)
[16:05:09.876]                             muffled <- TRUE
[16:05:09.876]                             break
[16:05:09.876]                           }
[16:05:09.876]                         }
[16:05:09.876]                       }
[16:05:09.876]                       invisible(muffled)
[16:05:09.876]                     }
[16:05:09.876]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.876]                   }
[16:05:09.876]                 }
[16:05:09.876]                 else {
[16:05:09.876]                   if (TRUE) {
[16:05:09.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.876]                     {
[16:05:09.876]                       inherits <- base::inherits
[16:05:09.876]                       invokeRestart <- base::invokeRestart
[16:05:09.876]                       is.null <- base::is.null
[16:05:09.876]                       muffled <- FALSE
[16:05:09.876]                       if (inherits(cond, "message")) {
[16:05:09.876]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.876]                         if (muffled) 
[16:05:09.876]                           invokeRestart("muffleMessage")
[16:05:09.876]                       }
[16:05:09.876]                       else if (inherits(cond, "warning")) {
[16:05:09.876]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.876]                         if (muffled) 
[16:05:09.876]                           invokeRestart("muffleWarning")
[16:05:09.876]                       }
[16:05:09.876]                       else if (inherits(cond, "condition")) {
[16:05:09.876]                         if (!is.null(pattern)) {
[16:05:09.876]                           computeRestarts <- base::computeRestarts
[16:05:09.876]                           grepl <- base::grepl
[16:05:09.876]                           restarts <- computeRestarts(cond)
[16:05:09.876]                           for (restart in restarts) {
[16:05:09.876]                             name <- restart$name
[16:05:09.876]                             if (is.null(name)) 
[16:05:09.876]                               next
[16:05:09.876]                             if (!grepl(pattern, name)) 
[16:05:09.876]                               next
[16:05:09.876]                             invokeRestart(restart)
[16:05:09.876]                             muffled <- TRUE
[16:05:09.876]                             break
[16:05:09.876]                           }
[16:05:09.876]                         }
[16:05:09.876]                       }
[16:05:09.876]                       invisible(muffled)
[16:05:09.876]                     }
[16:05:09.876]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.876]                   }
[16:05:09.876]                 }
[16:05:09.876]             }
[16:05:09.876]         }))
[16:05:09.876]     }, error = function(ex) {
[16:05:09.876]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:09.876]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.876]                 ...future.rng), started = ...future.startTime, 
[16:05:09.876]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:09.876]             version = "1.8"), class = "FutureResult")
[16:05:09.876]     }, finally = {
[16:05:09.876]         if (!identical(...future.workdir, getwd())) 
[16:05:09.876]             setwd(...future.workdir)
[16:05:09.876]         {
[16:05:09.876]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:09.876]                 ...future.oldOptions$nwarnings <- NULL
[16:05:09.876]             }
[16:05:09.876]             base::options(...future.oldOptions)
[16:05:09.876]             if (.Platform$OS.type == "windows") {
[16:05:09.876]                 old_names <- names(...future.oldEnvVars)
[16:05:09.876]                 envs <- base::Sys.getenv()
[16:05:09.876]                 names <- names(envs)
[16:05:09.876]                 common <- intersect(names, old_names)
[16:05:09.876]                 added <- setdiff(names, old_names)
[16:05:09.876]                 removed <- setdiff(old_names, names)
[16:05:09.876]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:09.876]                   envs[common]]
[16:05:09.876]                 NAMES <- toupper(changed)
[16:05:09.876]                 args <- list()
[16:05:09.876]                 for (kk in seq_along(NAMES)) {
[16:05:09.876]                   name <- changed[[kk]]
[16:05:09.876]                   NAME <- NAMES[[kk]]
[16:05:09.876]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.876]                     next
[16:05:09.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.876]                 }
[16:05:09.876]                 NAMES <- toupper(added)
[16:05:09.876]                 for (kk in seq_along(NAMES)) {
[16:05:09.876]                   name <- added[[kk]]
[16:05:09.876]                   NAME <- NAMES[[kk]]
[16:05:09.876]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.876]                     next
[16:05:09.876]                   args[[name]] <- ""
[16:05:09.876]                 }
[16:05:09.876]                 NAMES <- toupper(removed)
[16:05:09.876]                 for (kk in seq_along(NAMES)) {
[16:05:09.876]                   name <- removed[[kk]]
[16:05:09.876]                   NAME <- NAMES[[kk]]
[16:05:09.876]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.876]                     next
[16:05:09.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.876]                 }
[16:05:09.876]                 if (length(args) > 0) 
[16:05:09.876]                   base::do.call(base::Sys.setenv, args = args)
[16:05:09.876]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:09.876]             }
[16:05:09.876]             else {
[16:05:09.876]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:09.876]             }
[16:05:09.876]             {
[16:05:09.876]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:09.876]                   0L) {
[16:05:09.876]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:09.876]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:09.876]                   base::options(opts)
[16:05:09.876]                 }
[16:05:09.876]                 {
[16:05:09.876]                   {
[16:05:09.876]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:09.876]                     NULL
[16:05:09.876]                   }
[16:05:09.876]                   options(future.plan = NULL)
[16:05:09.876]                   if (is.na(NA_character_)) 
[16:05:09.876]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.876]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:09.876]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:09.876]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:09.876]                     envir = parent.frame()) 
[16:05:09.876]                   {
[16:05:09.876]                     if (is.function(workers)) 
[16:05:09.876]                       workers <- workers()
[16:05:09.876]                     workers <- structure(as.integer(workers), 
[16:05:09.876]                       class = class(workers))
[16:05:09.876]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:09.876]                       workers >= 1)
[16:05:09.876]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:09.876]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:09.876]                     }
[16:05:09.876]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:09.876]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:09.876]                       envir = envir)
[16:05:09.876]                     if (!future$lazy) 
[16:05:09.876]                       future <- run(future)
[16:05:09.876]                     invisible(future)
[16:05:09.876]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:09.876]                 }
[16:05:09.876]             }
[16:05:09.876]         }
[16:05:09.876]     })
[16:05:09.876]     if (TRUE) {
[16:05:09.876]         base::sink(type = "output", split = FALSE)
[16:05:09.876]         if (TRUE) {
[16:05:09.876]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:09.876]         }
[16:05:09.876]         else {
[16:05:09.876]             ...future.result["stdout"] <- base::list(NULL)
[16:05:09.876]         }
[16:05:09.876]         base::close(...future.stdout)
[16:05:09.876]         ...future.stdout <- NULL
[16:05:09.876]     }
[16:05:09.876]     ...future.result$conditions <- ...future.conditions
[16:05:09.876]     ...future.result$finished <- base::Sys.time()
[16:05:09.876]     ...future.result
[16:05:09.876] }
[16:05:09.879] MultisessionFuture started
[16:05:09.879] - Launch lazy future ... done
[16:05:09.879] run() for ‘MultisessionFuture’ ... done
[16:05:09.924] receiveMessageFromWorker() for ClusterFuture ...
[16:05:09.924] - Validating connection of MultisessionFuture
[16:05:09.924] - received message: FutureResult
[16:05:09.924] - Received FutureResult
[16:05:09.924] - Erased future from FutureRegistry
[16:05:09.924] result() for ClusterFuture ...
[16:05:09.925] - result already collected: FutureResult
[16:05:09.925] result() for ClusterFuture ... done
[16:05:09.925] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:09.925] Future #1
[16:05:09.925] result() for ClusterFuture ...
[16:05:09.925] - result already collected: FutureResult
[16:05:09.925] result() for ClusterFuture ... done
[16:05:09.925] result() for ClusterFuture ...
[16:05:09.925] - result already collected: FutureResult
[16:05:09.925] result() for ClusterFuture ... done
[16:05:09.926] A MultisessionFuture was resolved
[16:05:09.926]  length: 0 (resolved future 1)
[16:05:09.926] resolve() on list ... DONE
[16:05:09.926] - globals: [1] ‘a’
[16:05:09.926] Resolving futures part of globals (recursively) ... DONE
[16:05:09.927] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[16:05:09.927] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[16:05:09.927] - globals: [1] ‘a’
[16:05:09.928] - packages: [1] ‘future’
[16:05:09.928] getGlobalsAndPackages() ... DONE
[16:05:09.928] run() for ‘Future’ ...
[16:05:09.928] - state: ‘created’
[16:05:09.928] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:09.942] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:09.942] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:09.942]   - Field: ‘node’
[16:05:09.942]   - Field: ‘label’
[16:05:09.942]   - Field: ‘local’
[16:05:09.943]   - Field: ‘owner’
[16:05:09.943]   - Field: ‘envir’
[16:05:09.943]   - Field: ‘workers’
[16:05:09.943]   - Field: ‘packages’
[16:05:09.943]   - Field: ‘gc’
[16:05:09.943]   - Field: ‘conditions’
[16:05:09.943]   - Field: ‘persistent’
[16:05:09.943]   - Field: ‘expr’
[16:05:09.943]   - Field: ‘uuid’
[16:05:09.943]   - Field: ‘seed’
[16:05:09.943]   - Field: ‘version’
[16:05:09.944]   - Field: ‘result’
[16:05:09.944]   - Field: ‘asynchronous’
[16:05:09.944]   - Field: ‘calls’
[16:05:09.944]   - Field: ‘globals’
[16:05:09.944]   - Field: ‘stdout’
[16:05:09.944]   - Field: ‘earlySignal’
[16:05:09.944]   - Field: ‘lazy’
[16:05:09.944]   - Field: ‘state’
[16:05:09.944] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:09.944] - Launch lazy future ...
[16:05:09.945] Packages needed by the future expression (n = 1): ‘future’
[16:05:09.945] Packages needed by future strategies (n = 0): <none>
[16:05:09.945] {
[16:05:09.945]     {
[16:05:09.945]         {
[16:05:09.945]             ...future.startTime <- base::Sys.time()
[16:05:09.945]             {
[16:05:09.945]                 {
[16:05:09.945]                   {
[16:05:09.945]                     {
[16:05:09.945]                       {
[16:05:09.945]                         base::local({
[16:05:09.945]                           has_future <- base::requireNamespace("future", 
[16:05:09.945]                             quietly = TRUE)
[16:05:09.945]                           if (has_future) {
[16:05:09.945]                             ns <- base::getNamespace("future")
[16:05:09.945]                             version <- ns[[".package"]][["version"]]
[16:05:09.945]                             if (is.null(version)) 
[16:05:09.945]                               version <- utils::packageVersion("future")
[16:05:09.945]                           }
[16:05:09.945]                           else {
[16:05:09.945]                             version <- NULL
[16:05:09.945]                           }
[16:05:09.945]                           if (!has_future || version < "1.8.0") {
[16:05:09.945]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:09.945]                               "", base::R.version$version.string), 
[16:05:09.945]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:09.945]                                 base::R.version$platform, 8 * 
[16:05:09.945]                                   base::.Machine$sizeof.pointer), 
[16:05:09.945]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:09.945]                                 "release", "version")], collapse = " "), 
[16:05:09.945]                               hostname = base::Sys.info()[["nodename"]])
[16:05:09.945]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:09.945]                               info)
[16:05:09.945]                             info <- base::paste(info, collapse = "; ")
[16:05:09.945]                             if (!has_future) {
[16:05:09.945]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:09.945]                                 info)
[16:05:09.945]                             }
[16:05:09.945]                             else {
[16:05:09.945]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:09.945]                                 info, version)
[16:05:09.945]                             }
[16:05:09.945]                             base::stop(msg)
[16:05:09.945]                           }
[16:05:09.945]                         })
[16:05:09.945]                       }
[16:05:09.945]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:09.945]                       base::options(mc.cores = 1L)
[16:05:09.945]                     }
[16:05:09.945]                     base::local({
[16:05:09.945]                       for (pkg in "future") {
[16:05:09.945]                         base::loadNamespace(pkg)
[16:05:09.945]                         base::library(pkg, character.only = TRUE)
[16:05:09.945]                       }
[16:05:09.945]                     })
[16:05:09.945]                   }
[16:05:09.945]                   options(future.plan = NULL)
[16:05:09.945]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.945]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:09.945]                 }
[16:05:09.945]                 ...future.workdir <- getwd()
[16:05:09.945]             }
[16:05:09.945]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:09.945]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:09.945]         }
[16:05:09.945]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:09.945]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:09.945]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:09.945]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:09.945]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:09.945]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:09.945]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:09.945]             base::names(...future.oldOptions))
[16:05:09.945]     }
[16:05:09.945]     if (FALSE) {
[16:05:09.945]     }
[16:05:09.945]     else {
[16:05:09.945]         if (TRUE) {
[16:05:09.945]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:09.945]                 open = "w")
[16:05:09.945]         }
[16:05:09.945]         else {
[16:05:09.945]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:09.945]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:09.945]         }
[16:05:09.945]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:09.945]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:09.945]             base::sink(type = "output", split = FALSE)
[16:05:09.945]             base::close(...future.stdout)
[16:05:09.945]         }, add = TRUE)
[16:05:09.945]     }
[16:05:09.945]     ...future.frame <- base::sys.nframe()
[16:05:09.945]     ...future.conditions <- base::list()
[16:05:09.945]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:09.945]     if (FALSE) {
[16:05:09.945]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:09.945]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:09.945]     }
[16:05:09.945]     ...future.result <- base::tryCatch({
[16:05:09.945]         base::withCallingHandlers({
[16:05:09.945]             ...future.value <- base::withVisible(base::local({
[16:05:09.945]                 ...future.makeSendCondition <- base::local({
[16:05:09.945]                   sendCondition <- NULL
[16:05:09.945]                   function(frame = 1L) {
[16:05:09.945]                     if (is.function(sendCondition)) 
[16:05:09.945]                       return(sendCondition)
[16:05:09.945]                     ns <- getNamespace("parallel")
[16:05:09.945]                     if (exists("sendData", mode = "function", 
[16:05:09.945]                       envir = ns)) {
[16:05:09.945]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:09.945]                         envir = ns)
[16:05:09.945]                       envir <- sys.frame(frame)
[16:05:09.945]                       master <- NULL
[16:05:09.945]                       while (!identical(envir, .GlobalEnv) && 
[16:05:09.945]                         !identical(envir, emptyenv())) {
[16:05:09.945]                         if (exists("master", mode = "list", envir = envir, 
[16:05:09.945]                           inherits = FALSE)) {
[16:05:09.945]                           master <- get("master", mode = "list", 
[16:05:09.945]                             envir = envir, inherits = FALSE)
[16:05:09.945]                           if (inherits(master, c("SOCKnode", 
[16:05:09.945]                             "SOCK0node"))) {
[16:05:09.945]                             sendCondition <<- function(cond) {
[16:05:09.945]                               data <- list(type = "VALUE", value = cond, 
[16:05:09.945]                                 success = TRUE)
[16:05:09.945]                               parallel_sendData(master, data)
[16:05:09.945]                             }
[16:05:09.945]                             return(sendCondition)
[16:05:09.945]                           }
[16:05:09.945]                         }
[16:05:09.945]                         frame <- frame + 1L
[16:05:09.945]                         envir <- sys.frame(frame)
[16:05:09.945]                       }
[16:05:09.945]                     }
[16:05:09.945]                     sendCondition <<- function(cond) NULL
[16:05:09.945]                   }
[16:05:09.945]                 })
[16:05:09.945]                 withCallingHandlers({
[16:05:09.945]                   value(a) + 1
[16:05:09.945]                 }, immediateCondition = function(cond) {
[16:05:09.945]                   sendCondition <- ...future.makeSendCondition()
[16:05:09.945]                   sendCondition(cond)
[16:05:09.945]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.945]                   {
[16:05:09.945]                     inherits <- base::inherits
[16:05:09.945]                     invokeRestart <- base::invokeRestart
[16:05:09.945]                     is.null <- base::is.null
[16:05:09.945]                     muffled <- FALSE
[16:05:09.945]                     if (inherits(cond, "message")) {
[16:05:09.945]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:09.945]                       if (muffled) 
[16:05:09.945]                         invokeRestart("muffleMessage")
[16:05:09.945]                     }
[16:05:09.945]                     else if (inherits(cond, "warning")) {
[16:05:09.945]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:09.945]                       if (muffled) 
[16:05:09.945]                         invokeRestart("muffleWarning")
[16:05:09.945]                     }
[16:05:09.945]                     else if (inherits(cond, "condition")) {
[16:05:09.945]                       if (!is.null(pattern)) {
[16:05:09.945]                         computeRestarts <- base::computeRestarts
[16:05:09.945]                         grepl <- base::grepl
[16:05:09.945]                         restarts <- computeRestarts(cond)
[16:05:09.945]                         for (restart in restarts) {
[16:05:09.945]                           name <- restart$name
[16:05:09.945]                           if (is.null(name)) 
[16:05:09.945]                             next
[16:05:09.945]                           if (!grepl(pattern, name)) 
[16:05:09.945]                             next
[16:05:09.945]                           invokeRestart(restart)
[16:05:09.945]                           muffled <- TRUE
[16:05:09.945]                           break
[16:05:09.945]                         }
[16:05:09.945]                       }
[16:05:09.945]                     }
[16:05:09.945]                     invisible(muffled)
[16:05:09.945]                   }
[16:05:09.945]                   muffleCondition(cond)
[16:05:09.945]                 })
[16:05:09.945]             }))
[16:05:09.945]             future::FutureResult(value = ...future.value$value, 
[16:05:09.945]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.945]                   ...future.rng), globalenv = if (FALSE) 
[16:05:09.945]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:09.945]                     ...future.globalenv.names))
[16:05:09.945]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:09.945]         }, condition = base::local({
[16:05:09.945]             c <- base::c
[16:05:09.945]             inherits <- base::inherits
[16:05:09.945]             invokeRestart <- base::invokeRestart
[16:05:09.945]             length <- base::length
[16:05:09.945]             list <- base::list
[16:05:09.945]             seq.int <- base::seq.int
[16:05:09.945]             signalCondition <- base::signalCondition
[16:05:09.945]             sys.calls <- base::sys.calls
[16:05:09.945]             `[[` <- base::`[[`
[16:05:09.945]             `+` <- base::`+`
[16:05:09.945]             `<<-` <- base::`<<-`
[16:05:09.945]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:09.945]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:09.945]                   3L)]
[16:05:09.945]             }
[16:05:09.945]             function(cond) {
[16:05:09.945]                 is_error <- inherits(cond, "error")
[16:05:09.945]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:09.945]                   NULL)
[16:05:09.945]                 if (is_error) {
[16:05:09.945]                   sessionInformation <- function() {
[16:05:09.945]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:09.945]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:09.945]                       search = base::search(), system = base::Sys.info())
[16:05:09.945]                   }
[16:05:09.945]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.945]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:09.945]                     cond$call), session = sessionInformation(), 
[16:05:09.945]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:09.945]                   signalCondition(cond)
[16:05:09.945]                 }
[16:05:09.945]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:09.945]                 "immediateCondition"))) {
[16:05:09.945]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:09.945]                   ...future.conditions[[length(...future.conditions) + 
[16:05:09.945]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:09.945]                   if (TRUE && !signal) {
[16:05:09.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.945]                     {
[16:05:09.945]                       inherits <- base::inherits
[16:05:09.945]                       invokeRestart <- base::invokeRestart
[16:05:09.945]                       is.null <- base::is.null
[16:05:09.945]                       muffled <- FALSE
[16:05:09.945]                       if (inherits(cond, "message")) {
[16:05:09.945]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.945]                         if (muffled) 
[16:05:09.945]                           invokeRestart("muffleMessage")
[16:05:09.945]                       }
[16:05:09.945]                       else if (inherits(cond, "warning")) {
[16:05:09.945]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.945]                         if (muffled) 
[16:05:09.945]                           invokeRestart("muffleWarning")
[16:05:09.945]                       }
[16:05:09.945]                       else if (inherits(cond, "condition")) {
[16:05:09.945]                         if (!is.null(pattern)) {
[16:05:09.945]                           computeRestarts <- base::computeRestarts
[16:05:09.945]                           grepl <- base::grepl
[16:05:09.945]                           restarts <- computeRestarts(cond)
[16:05:09.945]                           for (restart in restarts) {
[16:05:09.945]                             name <- restart$name
[16:05:09.945]                             if (is.null(name)) 
[16:05:09.945]                               next
[16:05:09.945]                             if (!grepl(pattern, name)) 
[16:05:09.945]                               next
[16:05:09.945]                             invokeRestart(restart)
[16:05:09.945]                             muffled <- TRUE
[16:05:09.945]                             break
[16:05:09.945]                           }
[16:05:09.945]                         }
[16:05:09.945]                       }
[16:05:09.945]                       invisible(muffled)
[16:05:09.945]                     }
[16:05:09.945]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.945]                   }
[16:05:09.945]                 }
[16:05:09.945]                 else {
[16:05:09.945]                   if (TRUE) {
[16:05:09.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:09.945]                     {
[16:05:09.945]                       inherits <- base::inherits
[16:05:09.945]                       invokeRestart <- base::invokeRestart
[16:05:09.945]                       is.null <- base::is.null
[16:05:09.945]                       muffled <- FALSE
[16:05:09.945]                       if (inherits(cond, "message")) {
[16:05:09.945]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:09.945]                         if (muffled) 
[16:05:09.945]                           invokeRestart("muffleMessage")
[16:05:09.945]                       }
[16:05:09.945]                       else if (inherits(cond, "warning")) {
[16:05:09.945]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:09.945]                         if (muffled) 
[16:05:09.945]                           invokeRestart("muffleWarning")
[16:05:09.945]                       }
[16:05:09.945]                       else if (inherits(cond, "condition")) {
[16:05:09.945]                         if (!is.null(pattern)) {
[16:05:09.945]                           computeRestarts <- base::computeRestarts
[16:05:09.945]                           grepl <- base::grepl
[16:05:09.945]                           restarts <- computeRestarts(cond)
[16:05:09.945]                           for (restart in restarts) {
[16:05:09.945]                             name <- restart$name
[16:05:09.945]                             if (is.null(name)) 
[16:05:09.945]                               next
[16:05:09.945]                             if (!grepl(pattern, name)) 
[16:05:09.945]                               next
[16:05:09.945]                             invokeRestart(restart)
[16:05:09.945]                             muffled <- TRUE
[16:05:09.945]                             break
[16:05:09.945]                           }
[16:05:09.945]                         }
[16:05:09.945]                       }
[16:05:09.945]                       invisible(muffled)
[16:05:09.945]                     }
[16:05:09.945]                     muffleCondition(cond, pattern = "^muffle")
[16:05:09.945]                   }
[16:05:09.945]                 }
[16:05:09.945]             }
[16:05:09.945]         }))
[16:05:09.945]     }, error = function(ex) {
[16:05:09.945]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:09.945]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:09.945]                 ...future.rng), started = ...future.startTime, 
[16:05:09.945]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:09.945]             version = "1.8"), class = "FutureResult")
[16:05:09.945]     }, finally = {
[16:05:09.945]         if (!identical(...future.workdir, getwd())) 
[16:05:09.945]             setwd(...future.workdir)
[16:05:09.945]         {
[16:05:09.945]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:09.945]                 ...future.oldOptions$nwarnings <- NULL
[16:05:09.945]             }
[16:05:09.945]             base::options(...future.oldOptions)
[16:05:09.945]             if (.Platform$OS.type == "windows") {
[16:05:09.945]                 old_names <- names(...future.oldEnvVars)
[16:05:09.945]                 envs <- base::Sys.getenv()
[16:05:09.945]                 names <- names(envs)
[16:05:09.945]                 common <- intersect(names, old_names)
[16:05:09.945]                 added <- setdiff(names, old_names)
[16:05:09.945]                 removed <- setdiff(old_names, names)
[16:05:09.945]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:09.945]                   envs[common]]
[16:05:09.945]                 NAMES <- toupper(changed)
[16:05:09.945]                 args <- list()
[16:05:09.945]                 for (kk in seq_along(NAMES)) {
[16:05:09.945]                   name <- changed[[kk]]
[16:05:09.945]                   NAME <- NAMES[[kk]]
[16:05:09.945]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.945]                     next
[16:05:09.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.945]                 }
[16:05:09.945]                 NAMES <- toupper(added)
[16:05:09.945]                 for (kk in seq_along(NAMES)) {
[16:05:09.945]                   name <- added[[kk]]
[16:05:09.945]                   NAME <- NAMES[[kk]]
[16:05:09.945]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.945]                     next
[16:05:09.945]                   args[[name]] <- ""
[16:05:09.945]                 }
[16:05:09.945]                 NAMES <- toupper(removed)
[16:05:09.945]                 for (kk in seq_along(NAMES)) {
[16:05:09.945]                   name <- removed[[kk]]
[16:05:09.945]                   NAME <- NAMES[[kk]]
[16:05:09.945]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:09.945]                     next
[16:05:09.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:09.945]                 }
[16:05:09.945]                 if (length(args) > 0) 
[16:05:09.945]                   base::do.call(base::Sys.setenv, args = args)
[16:05:09.945]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:09.945]             }
[16:05:09.945]             else {
[16:05:09.945]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:09.945]             }
[16:05:09.945]             {
[16:05:09.945]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:09.945]                   0L) {
[16:05:09.945]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:09.945]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:09.945]                   base::options(opts)
[16:05:09.945]                 }
[16:05:09.945]                 {
[16:05:09.945]                   {
[16:05:09.945]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:09.945]                     NULL
[16:05:09.945]                   }
[16:05:09.945]                   options(future.plan = NULL)
[16:05:09.945]                   if (is.na(NA_character_)) 
[16:05:09.945]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:09.945]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:09.945]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:09.945]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:09.945]                     envir = parent.frame()) 
[16:05:09.945]                   {
[16:05:09.945]                     if (is.function(workers)) 
[16:05:09.945]                       workers <- workers()
[16:05:09.945]                     workers <- structure(as.integer(workers), 
[16:05:09.945]                       class = class(workers))
[16:05:09.945]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:09.945]                       workers >= 1)
[16:05:09.945]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:09.945]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:09.945]                     }
[16:05:09.945]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:09.945]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:09.945]                       envir = envir)
[16:05:09.945]                     if (!future$lazy) 
[16:05:09.945]                       future <- run(future)
[16:05:09.945]                     invisible(future)
[16:05:09.945]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:09.945]                 }
[16:05:09.945]             }
[16:05:09.945]         }
[16:05:09.945]     })
[16:05:09.945]     if (TRUE) {
[16:05:09.945]         base::sink(type = "output", split = FALSE)
[16:05:09.945]         if (TRUE) {
[16:05:09.945]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:09.945]         }
[16:05:09.945]         else {
[16:05:09.945]             ...future.result["stdout"] <- base::list(NULL)
[16:05:09.945]         }
[16:05:09.945]         base::close(...future.stdout)
[16:05:09.945]         ...future.stdout <- NULL
[16:05:09.945]     }
[16:05:09.945]     ...future.result$conditions <- ...future.conditions
[16:05:09.945]     ...future.result$finished <- base::Sys.time()
[16:05:09.945]     ...future.result
[16:05:09.945] }
[16:05:09.948] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[16:05:09.949] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[16:05:09.999] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[16:05:09.999] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[16:05:10.000] MultisessionFuture started
[16:05:10.000] - Launch lazy future ... done
[16:05:10.000] run() for ‘MultisessionFuture’ ... done
[16:05:10.000] result() for ClusterFuture ...
[16:05:10.000] receiveMessageFromWorker() for ClusterFuture ...
[16:05:10.001] - Validating connection of MultisessionFuture
[16:05:10.048] - received message: FutureResult
[16:05:10.048] - Received FutureResult
[16:05:10.048] - Erased future from FutureRegistry
[16:05:10.049] result() for ClusterFuture ...
[16:05:10.049] - result already collected: FutureResult
[16:05:10.049] result() for ClusterFuture ... done
[16:05:10.049] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:10.049] result() for ClusterFuture ... done
[16:05:10.049] result() for ClusterFuture ...
[16:05:10.049] - result already collected: FutureResult
[16:05:10.049] result() for ClusterFuture ... done
value(b) = 2
[16:05:10.049] result() for ClusterFuture ...
[16:05:10.050] - result already collected: FutureResult
[16:05:10.050] result() for ClusterFuture ... done
[16:05:10.050] result() for ClusterFuture ...
[16:05:10.050] - result already collected: FutureResult
[16:05:10.050] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:10.050] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:10.050] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:10.051] 
[16:05:10.051] Searching for globals ... DONE
[16:05:10.051] - globals: [0] <none>
[16:05:10.051] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:10.052] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:10.052] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:10.053] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:10.053] Searching for globals ... DONE
[16:05:10.053] Resolving globals: TRUE
[16:05:10.053] Resolving any globals that are futures ...
[16:05:10.053] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:10.053] Resolving any globals that are futures ... DONE
[16:05:10.054] Resolving futures part of globals (recursively) ...
[16:05:10.054] resolve() on list ...
[16:05:10.054]  recursive: 99
[16:05:10.054]  length: 1
[16:05:10.054]  elements: ‘a’
[16:05:10.054] run() for ‘Future’ ...
[16:05:10.054] - state: ‘created’
[16:05:10.057] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:10.071] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:10.071] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:10.071]   - Field: ‘node’
[16:05:10.071]   - Field: ‘label’
[16:05:10.071]   - Field: ‘local’
[16:05:10.072]   - Field: ‘owner’
[16:05:10.072]   - Field: ‘envir’
[16:05:10.072]   - Field: ‘workers’
[16:05:10.072]   - Field: ‘packages’
[16:05:10.072]   - Field: ‘gc’
[16:05:10.072]   - Field: ‘conditions’
[16:05:10.072]   - Field: ‘persistent’
[16:05:10.072]   - Field: ‘expr’
[16:05:10.072]   - Field: ‘uuid’
[16:05:10.072]   - Field: ‘seed’
[16:05:10.072]   - Field: ‘version’
[16:05:10.073]   - Field: ‘result’
[16:05:10.073]   - Field: ‘asynchronous’
[16:05:10.073]   - Field: ‘calls’
[16:05:10.073]   - Field: ‘globals’
[16:05:10.073]   - Field: ‘stdout’
[16:05:10.073]   - Field: ‘earlySignal’
[16:05:10.073]   - Field: ‘lazy’
[16:05:10.073]   - Field: ‘state’
[16:05:10.073] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:10.073] - Launch lazy future ...
[16:05:10.074] Packages needed by the future expression (n = 0): <none>
[16:05:10.074] Packages needed by future strategies (n = 0): <none>
[16:05:10.074] {
[16:05:10.074]     {
[16:05:10.074]         {
[16:05:10.074]             ...future.startTime <- base::Sys.time()
[16:05:10.074]             {
[16:05:10.074]                 {
[16:05:10.074]                   {
[16:05:10.074]                     {
[16:05:10.074]                       base::local({
[16:05:10.074]                         has_future <- base::requireNamespace("future", 
[16:05:10.074]                           quietly = TRUE)
[16:05:10.074]                         if (has_future) {
[16:05:10.074]                           ns <- base::getNamespace("future")
[16:05:10.074]                           version <- ns[[".package"]][["version"]]
[16:05:10.074]                           if (is.null(version)) 
[16:05:10.074]                             version <- utils::packageVersion("future")
[16:05:10.074]                         }
[16:05:10.074]                         else {
[16:05:10.074]                           version <- NULL
[16:05:10.074]                         }
[16:05:10.074]                         if (!has_future || version < "1.8.0") {
[16:05:10.074]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:10.074]                             "", base::R.version$version.string), 
[16:05:10.074]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:10.074]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:10.074]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:10.074]                               "release", "version")], collapse = " "), 
[16:05:10.074]                             hostname = base::Sys.info()[["nodename"]])
[16:05:10.074]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:10.074]                             info)
[16:05:10.074]                           info <- base::paste(info, collapse = "; ")
[16:05:10.074]                           if (!has_future) {
[16:05:10.074]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:10.074]                               info)
[16:05:10.074]                           }
[16:05:10.074]                           else {
[16:05:10.074]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:10.074]                               info, version)
[16:05:10.074]                           }
[16:05:10.074]                           base::stop(msg)
[16:05:10.074]                         }
[16:05:10.074]                       })
[16:05:10.074]                     }
[16:05:10.074]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:10.074]                     base::options(mc.cores = 1L)
[16:05:10.074]                   }
[16:05:10.074]                   options(future.plan = NULL)
[16:05:10.074]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.074]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:10.074]                 }
[16:05:10.074]                 ...future.workdir <- getwd()
[16:05:10.074]             }
[16:05:10.074]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:10.074]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:10.074]         }
[16:05:10.074]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:10.074]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:10.074]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:10.074]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:10.074]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:10.074]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:10.074]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:10.074]             base::names(...future.oldOptions))
[16:05:10.074]     }
[16:05:10.074]     if (FALSE) {
[16:05:10.074]     }
[16:05:10.074]     else {
[16:05:10.074]         if (TRUE) {
[16:05:10.074]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:10.074]                 open = "w")
[16:05:10.074]         }
[16:05:10.074]         else {
[16:05:10.074]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:10.074]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:10.074]         }
[16:05:10.074]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:10.074]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:10.074]             base::sink(type = "output", split = FALSE)
[16:05:10.074]             base::close(...future.stdout)
[16:05:10.074]         }, add = TRUE)
[16:05:10.074]     }
[16:05:10.074]     ...future.frame <- base::sys.nframe()
[16:05:10.074]     ...future.conditions <- base::list()
[16:05:10.074]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:10.074]     if (FALSE) {
[16:05:10.074]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:10.074]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:10.074]     }
[16:05:10.074]     ...future.result <- base::tryCatch({
[16:05:10.074]         base::withCallingHandlers({
[16:05:10.074]             ...future.value <- base::withVisible(base::local({
[16:05:10.074]                 ...future.makeSendCondition <- base::local({
[16:05:10.074]                   sendCondition <- NULL
[16:05:10.074]                   function(frame = 1L) {
[16:05:10.074]                     if (is.function(sendCondition)) 
[16:05:10.074]                       return(sendCondition)
[16:05:10.074]                     ns <- getNamespace("parallel")
[16:05:10.074]                     if (exists("sendData", mode = "function", 
[16:05:10.074]                       envir = ns)) {
[16:05:10.074]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:10.074]                         envir = ns)
[16:05:10.074]                       envir <- sys.frame(frame)
[16:05:10.074]                       master <- NULL
[16:05:10.074]                       while (!identical(envir, .GlobalEnv) && 
[16:05:10.074]                         !identical(envir, emptyenv())) {
[16:05:10.074]                         if (exists("master", mode = "list", envir = envir, 
[16:05:10.074]                           inherits = FALSE)) {
[16:05:10.074]                           master <- get("master", mode = "list", 
[16:05:10.074]                             envir = envir, inherits = FALSE)
[16:05:10.074]                           if (inherits(master, c("SOCKnode", 
[16:05:10.074]                             "SOCK0node"))) {
[16:05:10.074]                             sendCondition <<- function(cond) {
[16:05:10.074]                               data <- list(type = "VALUE", value = cond, 
[16:05:10.074]                                 success = TRUE)
[16:05:10.074]                               parallel_sendData(master, data)
[16:05:10.074]                             }
[16:05:10.074]                             return(sendCondition)
[16:05:10.074]                           }
[16:05:10.074]                         }
[16:05:10.074]                         frame <- frame + 1L
[16:05:10.074]                         envir <- sys.frame(frame)
[16:05:10.074]                       }
[16:05:10.074]                     }
[16:05:10.074]                     sendCondition <<- function(cond) NULL
[16:05:10.074]                   }
[16:05:10.074]                 })
[16:05:10.074]                 withCallingHandlers({
[16:05:10.074]                   1
[16:05:10.074]                 }, immediateCondition = function(cond) {
[16:05:10.074]                   sendCondition <- ...future.makeSendCondition()
[16:05:10.074]                   sendCondition(cond)
[16:05:10.074]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.074]                   {
[16:05:10.074]                     inherits <- base::inherits
[16:05:10.074]                     invokeRestart <- base::invokeRestart
[16:05:10.074]                     is.null <- base::is.null
[16:05:10.074]                     muffled <- FALSE
[16:05:10.074]                     if (inherits(cond, "message")) {
[16:05:10.074]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:10.074]                       if (muffled) 
[16:05:10.074]                         invokeRestart("muffleMessage")
[16:05:10.074]                     }
[16:05:10.074]                     else if (inherits(cond, "warning")) {
[16:05:10.074]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:10.074]                       if (muffled) 
[16:05:10.074]                         invokeRestart("muffleWarning")
[16:05:10.074]                     }
[16:05:10.074]                     else if (inherits(cond, "condition")) {
[16:05:10.074]                       if (!is.null(pattern)) {
[16:05:10.074]                         computeRestarts <- base::computeRestarts
[16:05:10.074]                         grepl <- base::grepl
[16:05:10.074]                         restarts <- computeRestarts(cond)
[16:05:10.074]                         for (restart in restarts) {
[16:05:10.074]                           name <- restart$name
[16:05:10.074]                           if (is.null(name)) 
[16:05:10.074]                             next
[16:05:10.074]                           if (!grepl(pattern, name)) 
[16:05:10.074]                             next
[16:05:10.074]                           invokeRestart(restart)
[16:05:10.074]                           muffled <- TRUE
[16:05:10.074]                           break
[16:05:10.074]                         }
[16:05:10.074]                       }
[16:05:10.074]                     }
[16:05:10.074]                     invisible(muffled)
[16:05:10.074]                   }
[16:05:10.074]                   muffleCondition(cond)
[16:05:10.074]                 })
[16:05:10.074]             }))
[16:05:10.074]             future::FutureResult(value = ...future.value$value, 
[16:05:10.074]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.074]                   ...future.rng), globalenv = if (FALSE) 
[16:05:10.074]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:10.074]                     ...future.globalenv.names))
[16:05:10.074]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:10.074]         }, condition = base::local({
[16:05:10.074]             c <- base::c
[16:05:10.074]             inherits <- base::inherits
[16:05:10.074]             invokeRestart <- base::invokeRestart
[16:05:10.074]             length <- base::length
[16:05:10.074]             list <- base::list
[16:05:10.074]             seq.int <- base::seq.int
[16:05:10.074]             signalCondition <- base::signalCondition
[16:05:10.074]             sys.calls <- base::sys.calls
[16:05:10.074]             `[[` <- base::`[[`
[16:05:10.074]             `+` <- base::`+`
[16:05:10.074]             `<<-` <- base::`<<-`
[16:05:10.074]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:10.074]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:10.074]                   3L)]
[16:05:10.074]             }
[16:05:10.074]             function(cond) {
[16:05:10.074]                 is_error <- inherits(cond, "error")
[16:05:10.074]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:10.074]                   NULL)
[16:05:10.074]                 if (is_error) {
[16:05:10.074]                   sessionInformation <- function() {
[16:05:10.074]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:10.074]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:10.074]                       search = base::search(), system = base::Sys.info())
[16:05:10.074]                   }
[16:05:10.074]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.074]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:10.074]                     cond$call), session = sessionInformation(), 
[16:05:10.074]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:10.074]                   signalCondition(cond)
[16:05:10.074]                 }
[16:05:10.074]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:10.074]                 "immediateCondition"))) {
[16:05:10.074]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:10.074]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.074]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:10.074]                   if (TRUE && !signal) {
[16:05:10.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.074]                     {
[16:05:10.074]                       inherits <- base::inherits
[16:05:10.074]                       invokeRestart <- base::invokeRestart
[16:05:10.074]                       is.null <- base::is.null
[16:05:10.074]                       muffled <- FALSE
[16:05:10.074]                       if (inherits(cond, "message")) {
[16:05:10.074]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.074]                         if (muffled) 
[16:05:10.074]                           invokeRestart("muffleMessage")
[16:05:10.074]                       }
[16:05:10.074]                       else if (inherits(cond, "warning")) {
[16:05:10.074]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.074]                         if (muffled) 
[16:05:10.074]                           invokeRestart("muffleWarning")
[16:05:10.074]                       }
[16:05:10.074]                       else if (inherits(cond, "condition")) {
[16:05:10.074]                         if (!is.null(pattern)) {
[16:05:10.074]                           computeRestarts <- base::computeRestarts
[16:05:10.074]                           grepl <- base::grepl
[16:05:10.074]                           restarts <- computeRestarts(cond)
[16:05:10.074]                           for (restart in restarts) {
[16:05:10.074]                             name <- restart$name
[16:05:10.074]                             if (is.null(name)) 
[16:05:10.074]                               next
[16:05:10.074]                             if (!grepl(pattern, name)) 
[16:05:10.074]                               next
[16:05:10.074]                             invokeRestart(restart)
[16:05:10.074]                             muffled <- TRUE
[16:05:10.074]                             break
[16:05:10.074]                           }
[16:05:10.074]                         }
[16:05:10.074]                       }
[16:05:10.074]                       invisible(muffled)
[16:05:10.074]                     }
[16:05:10.074]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.074]                   }
[16:05:10.074]                 }
[16:05:10.074]                 else {
[16:05:10.074]                   if (TRUE) {
[16:05:10.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.074]                     {
[16:05:10.074]                       inherits <- base::inherits
[16:05:10.074]                       invokeRestart <- base::invokeRestart
[16:05:10.074]                       is.null <- base::is.null
[16:05:10.074]                       muffled <- FALSE
[16:05:10.074]                       if (inherits(cond, "message")) {
[16:05:10.074]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.074]                         if (muffled) 
[16:05:10.074]                           invokeRestart("muffleMessage")
[16:05:10.074]                       }
[16:05:10.074]                       else if (inherits(cond, "warning")) {
[16:05:10.074]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.074]                         if (muffled) 
[16:05:10.074]                           invokeRestart("muffleWarning")
[16:05:10.074]                       }
[16:05:10.074]                       else if (inherits(cond, "condition")) {
[16:05:10.074]                         if (!is.null(pattern)) {
[16:05:10.074]                           computeRestarts <- base::computeRestarts
[16:05:10.074]                           grepl <- base::grepl
[16:05:10.074]                           restarts <- computeRestarts(cond)
[16:05:10.074]                           for (restart in restarts) {
[16:05:10.074]                             name <- restart$name
[16:05:10.074]                             if (is.null(name)) 
[16:05:10.074]                               next
[16:05:10.074]                             if (!grepl(pattern, name)) 
[16:05:10.074]                               next
[16:05:10.074]                             invokeRestart(restart)
[16:05:10.074]                             muffled <- TRUE
[16:05:10.074]                             break
[16:05:10.074]                           }
[16:05:10.074]                         }
[16:05:10.074]                       }
[16:05:10.074]                       invisible(muffled)
[16:05:10.074]                     }
[16:05:10.074]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.074]                   }
[16:05:10.074]                 }
[16:05:10.074]             }
[16:05:10.074]         }))
[16:05:10.074]     }, error = function(ex) {
[16:05:10.074]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:10.074]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.074]                 ...future.rng), started = ...future.startTime, 
[16:05:10.074]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:10.074]             version = "1.8"), class = "FutureResult")
[16:05:10.074]     }, finally = {
[16:05:10.074]         if (!identical(...future.workdir, getwd())) 
[16:05:10.074]             setwd(...future.workdir)
[16:05:10.074]         {
[16:05:10.074]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:10.074]                 ...future.oldOptions$nwarnings <- NULL
[16:05:10.074]             }
[16:05:10.074]             base::options(...future.oldOptions)
[16:05:10.074]             if (.Platform$OS.type == "windows") {
[16:05:10.074]                 old_names <- names(...future.oldEnvVars)
[16:05:10.074]                 envs <- base::Sys.getenv()
[16:05:10.074]                 names <- names(envs)
[16:05:10.074]                 common <- intersect(names, old_names)
[16:05:10.074]                 added <- setdiff(names, old_names)
[16:05:10.074]                 removed <- setdiff(old_names, names)
[16:05:10.074]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:10.074]                   envs[common]]
[16:05:10.074]                 NAMES <- toupper(changed)
[16:05:10.074]                 args <- list()
[16:05:10.074]                 for (kk in seq_along(NAMES)) {
[16:05:10.074]                   name <- changed[[kk]]
[16:05:10.074]                   NAME <- NAMES[[kk]]
[16:05:10.074]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.074]                     next
[16:05:10.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.074]                 }
[16:05:10.074]                 NAMES <- toupper(added)
[16:05:10.074]                 for (kk in seq_along(NAMES)) {
[16:05:10.074]                   name <- added[[kk]]
[16:05:10.074]                   NAME <- NAMES[[kk]]
[16:05:10.074]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.074]                     next
[16:05:10.074]                   args[[name]] <- ""
[16:05:10.074]                 }
[16:05:10.074]                 NAMES <- toupper(removed)
[16:05:10.074]                 for (kk in seq_along(NAMES)) {
[16:05:10.074]                   name <- removed[[kk]]
[16:05:10.074]                   NAME <- NAMES[[kk]]
[16:05:10.074]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.074]                     next
[16:05:10.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.074]                 }
[16:05:10.074]                 if (length(args) > 0) 
[16:05:10.074]                   base::do.call(base::Sys.setenv, args = args)
[16:05:10.074]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:10.074]             }
[16:05:10.074]             else {
[16:05:10.074]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:10.074]             }
[16:05:10.074]             {
[16:05:10.074]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:10.074]                   0L) {
[16:05:10.074]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:10.074]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:10.074]                   base::options(opts)
[16:05:10.074]                 }
[16:05:10.074]                 {
[16:05:10.074]                   {
[16:05:10.074]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:10.074]                     NULL
[16:05:10.074]                   }
[16:05:10.074]                   options(future.plan = NULL)
[16:05:10.074]                   if (is.na(NA_character_)) 
[16:05:10.074]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.074]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:10.074]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:10.074]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:10.074]                     envir = parent.frame()) 
[16:05:10.074]                   {
[16:05:10.074]                     if (is.function(workers)) 
[16:05:10.074]                       workers <- workers()
[16:05:10.074]                     workers <- structure(as.integer(workers), 
[16:05:10.074]                       class = class(workers))
[16:05:10.074]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:10.074]                       workers >= 1)
[16:05:10.074]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:10.074]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:10.074]                     }
[16:05:10.074]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:10.074]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:10.074]                       envir = envir)
[16:05:10.074]                     if (!future$lazy) 
[16:05:10.074]                       future <- run(future)
[16:05:10.074]                     invisible(future)
[16:05:10.074]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:10.074]                 }
[16:05:10.074]             }
[16:05:10.074]         }
[16:05:10.074]     })
[16:05:10.074]     if (TRUE) {
[16:05:10.074]         base::sink(type = "output", split = FALSE)
[16:05:10.074]         if (TRUE) {
[16:05:10.074]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:10.074]         }
[16:05:10.074]         else {
[16:05:10.074]             ...future.result["stdout"] <- base::list(NULL)
[16:05:10.074]         }
[16:05:10.074]         base::close(...future.stdout)
[16:05:10.074]         ...future.stdout <- NULL
[16:05:10.074]     }
[16:05:10.074]     ...future.result$conditions <- ...future.conditions
[16:05:10.074]     ...future.result$finished <- base::Sys.time()
[16:05:10.074]     ...future.result
[16:05:10.074] }
[16:05:10.077] MultisessionFuture started
[16:05:10.077] - Launch lazy future ... done
[16:05:10.077] run() for ‘MultisessionFuture’ ... done
[16:05:10.124] receiveMessageFromWorker() for ClusterFuture ...
[16:05:10.124] - Validating connection of MultisessionFuture
[16:05:10.124] - received message: FutureResult
[16:05:10.124] - Received FutureResult
[16:05:10.124] - Erased future from FutureRegistry
[16:05:10.124] result() for ClusterFuture ...
[16:05:10.125] - result already collected: FutureResult
[16:05:10.125] result() for ClusterFuture ... done
[16:05:10.125] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:10.125] Future #1
[16:05:10.125] result() for ClusterFuture ...
[16:05:10.125] - result already collected: FutureResult
[16:05:10.125] result() for ClusterFuture ... done
[16:05:10.125] result() for ClusterFuture ...
[16:05:10.125] - result already collected: FutureResult
[16:05:10.125] result() for ClusterFuture ... done
[16:05:10.125] A MultisessionFuture was resolved
[16:05:10.126]  length: 0 (resolved future 1)
[16:05:10.126] resolve() on list ... DONE
[16:05:10.126] - globals: [1] ‘a’
[16:05:10.126] Resolving futures part of globals (recursively) ... DONE
[16:05:10.127] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[16:05:10.127] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[16:05:10.127] - globals: [1] ‘a’
[16:05:10.127] - packages: [1] ‘future’
[16:05:10.127] getGlobalsAndPackages() ... DONE
[16:05:10.128] run() for ‘Future’ ...
[16:05:10.128] - state: ‘created’
[16:05:10.128] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:10.142] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:10.142] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:10.142]   - Field: ‘node’
[16:05:10.142]   - Field: ‘label’
[16:05:10.142]   - Field: ‘local’
[16:05:10.142]   - Field: ‘owner’
[16:05:10.142]   - Field: ‘envir’
[16:05:10.142]   - Field: ‘workers’
[16:05:10.142]   - Field: ‘packages’
[16:05:10.143]   - Field: ‘gc’
[16:05:10.143]   - Field: ‘conditions’
[16:05:10.143]   - Field: ‘persistent’
[16:05:10.143]   - Field: ‘expr’
[16:05:10.143]   - Field: ‘uuid’
[16:05:10.143]   - Field: ‘seed’
[16:05:10.143]   - Field: ‘version’
[16:05:10.143]   - Field: ‘result’
[16:05:10.143]   - Field: ‘asynchronous’
[16:05:10.143]   - Field: ‘calls’
[16:05:10.144]   - Field: ‘globals’
[16:05:10.144]   - Field: ‘stdout’
[16:05:10.144]   - Field: ‘earlySignal’
[16:05:10.144]   - Field: ‘lazy’
[16:05:10.144]   - Field: ‘state’
[16:05:10.144] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:10.144] - Launch lazy future ...
[16:05:10.144] Packages needed by the future expression (n = 1): ‘future’
[16:05:10.145] Packages needed by future strategies (n = 0): <none>
[16:05:10.145] {
[16:05:10.145]     {
[16:05:10.145]         {
[16:05:10.145]             ...future.startTime <- base::Sys.time()
[16:05:10.145]             {
[16:05:10.145]                 {
[16:05:10.145]                   {
[16:05:10.145]                     {
[16:05:10.145]                       {
[16:05:10.145]                         base::local({
[16:05:10.145]                           has_future <- base::requireNamespace("future", 
[16:05:10.145]                             quietly = TRUE)
[16:05:10.145]                           if (has_future) {
[16:05:10.145]                             ns <- base::getNamespace("future")
[16:05:10.145]                             version <- ns[[".package"]][["version"]]
[16:05:10.145]                             if (is.null(version)) 
[16:05:10.145]                               version <- utils::packageVersion("future")
[16:05:10.145]                           }
[16:05:10.145]                           else {
[16:05:10.145]                             version <- NULL
[16:05:10.145]                           }
[16:05:10.145]                           if (!has_future || version < "1.8.0") {
[16:05:10.145]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:10.145]                               "", base::R.version$version.string), 
[16:05:10.145]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:10.145]                                 base::R.version$platform, 8 * 
[16:05:10.145]                                   base::.Machine$sizeof.pointer), 
[16:05:10.145]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:10.145]                                 "release", "version")], collapse = " "), 
[16:05:10.145]                               hostname = base::Sys.info()[["nodename"]])
[16:05:10.145]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:10.145]                               info)
[16:05:10.145]                             info <- base::paste(info, collapse = "; ")
[16:05:10.145]                             if (!has_future) {
[16:05:10.145]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:10.145]                                 info)
[16:05:10.145]                             }
[16:05:10.145]                             else {
[16:05:10.145]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:10.145]                                 info, version)
[16:05:10.145]                             }
[16:05:10.145]                             base::stop(msg)
[16:05:10.145]                           }
[16:05:10.145]                         })
[16:05:10.145]                       }
[16:05:10.145]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:10.145]                       base::options(mc.cores = 1L)
[16:05:10.145]                     }
[16:05:10.145]                     base::local({
[16:05:10.145]                       for (pkg in "future") {
[16:05:10.145]                         base::loadNamespace(pkg)
[16:05:10.145]                         base::library(pkg, character.only = TRUE)
[16:05:10.145]                       }
[16:05:10.145]                     })
[16:05:10.145]                   }
[16:05:10.145]                   options(future.plan = NULL)
[16:05:10.145]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.145]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:10.145]                 }
[16:05:10.145]                 ...future.workdir <- getwd()
[16:05:10.145]             }
[16:05:10.145]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:10.145]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:10.145]         }
[16:05:10.145]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:10.145]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:10.145]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:10.145]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:10.145]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:10.145]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:10.145]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:10.145]             base::names(...future.oldOptions))
[16:05:10.145]     }
[16:05:10.145]     if (FALSE) {
[16:05:10.145]     }
[16:05:10.145]     else {
[16:05:10.145]         if (TRUE) {
[16:05:10.145]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:10.145]                 open = "w")
[16:05:10.145]         }
[16:05:10.145]         else {
[16:05:10.145]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:10.145]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:10.145]         }
[16:05:10.145]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:10.145]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:10.145]             base::sink(type = "output", split = FALSE)
[16:05:10.145]             base::close(...future.stdout)
[16:05:10.145]         }, add = TRUE)
[16:05:10.145]     }
[16:05:10.145]     ...future.frame <- base::sys.nframe()
[16:05:10.145]     ...future.conditions <- base::list()
[16:05:10.145]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:10.145]     if (FALSE) {
[16:05:10.145]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:10.145]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:10.145]     }
[16:05:10.145]     ...future.result <- base::tryCatch({
[16:05:10.145]         base::withCallingHandlers({
[16:05:10.145]             ...future.value <- base::withVisible(base::local({
[16:05:10.145]                 ...future.makeSendCondition <- base::local({
[16:05:10.145]                   sendCondition <- NULL
[16:05:10.145]                   function(frame = 1L) {
[16:05:10.145]                     if (is.function(sendCondition)) 
[16:05:10.145]                       return(sendCondition)
[16:05:10.145]                     ns <- getNamespace("parallel")
[16:05:10.145]                     if (exists("sendData", mode = "function", 
[16:05:10.145]                       envir = ns)) {
[16:05:10.145]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:10.145]                         envir = ns)
[16:05:10.145]                       envir <- sys.frame(frame)
[16:05:10.145]                       master <- NULL
[16:05:10.145]                       while (!identical(envir, .GlobalEnv) && 
[16:05:10.145]                         !identical(envir, emptyenv())) {
[16:05:10.145]                         if (exists("master", mode = "list", envir = envir, 
[16:05:10.145]                           inherits = FALSE)) {
[16:05:10.145]                           master <- get("master", mode = "list", 
[16:05:10.145]                             envir = envir, inherits = FALSE)
[16:05:10.145]                           if (inherits(master, c("SOCKnode", 
[16:05:10.145]                             "SOCK0node"))) {
[16:05:10.145]                             sendCondition <<- function(cond) {
[16:05:10.145]                               data <- list(type = "VALUE", value = cond, 
[16:05:10.145]                                 success = TRUE)
[16:05:10.145]                               parallel_sendData(master, data)
[16:05:10.145]                             }
[16:05:10.145]                             return(sendCondition)
[16:05:10.145]                           }
[16:05:10.145]                         }
[16:05:10.145]                         frame <- frame + 1L
[16:05:10.145]                         envir <- sys.frame(frame)
[16:05:10.145]                       }
[16:05:10.145]                     }
[16:05:10.145]                     sendCondition <<- function(cond) NULL
[16:05:10.145]                   }
[16:05:10.145]                 })
[16:05:10.145]                 withCallingHandlers({
[16:05:10.145]                   value(a) + 1
[16:05:10.145]                 }, immediateCondition = function(cond) {
[16:05:10.145]                   sendCondition <- ...future.makeSendCondition()
[16:05:10.145]                   sendCondition(cond)
[16:05:10.145]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.145]                   {
[16:05:10.145]                     inherits <- base::inherits
[16:05:10.145]                     invokeRestart <- base::invokeRestart
[16:05:10.145]                     is.null <- base::is.null
[16:05:10.145]                     muffled <- FALSE
[16:05:10.145]                     if (inherits(cond, "message")) {
[16:05:10.145]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:10.145]                       if (muffled) 
[16:05:10.145]                         invokeRestart("muffleMessage")
[16:05:10.145]                     }
[16:05:10.145]                     else if (inherits(cond, "warning")) {
[16:05:10.145]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:10.145]                       if (muffled) 
[16:05:10.145]                         invokeRestart("muffleWarning")
[16:05:10.145]                     }
[16:05:10.145]                     else if (inherits(cond, "condition")) {
[16:05:10.145]                       if (!is.null(pattern)) {
[16:05:10.145]                         computeRestarts <- base::computeRestarts
[16:05:10.145]                         grepl <- base::grepl
[16:05:10.145]                         restarts <- computeRestarts(cond)
[16:05:10.145]                         for (restart in restarts) {
[16:05:10.145]                           name <- restart$name
[16:05:10.145]                           if (is.null(name)) 
[16:05:10.145]                             next
[16:05:10.145]                           if (!grepl(pattern, name)) 
[16:05:10.145]                             next
[16:05:10.145]                           invokeRestart(restart)
[16:05:10.145]                           muffled <- TRUE
[16:05:10.145]                           break
[16:05:10.145]                         }
[16:05:10.145]                       }
[16:05:10.145]                     }
[16:05:10.145]                     invisible(muffled)
[16:05:10.145]                   }
[16:05:10.145]                   muffleCondition(cond)
[16:05:10.145]                 })
[16:05:10.145]             }))
[16:05:10.145]             future::FutureResult(value = ...future.value$value, 
[16:05:10.145]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.145]                   ...future.rng), globalenv = if (FALSE) 
[16:05:10.145]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:10.145]                     ...future.globalenv.names))
[16:05:10.145]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:10.145]         }, condition = base::local({
[16:05:10.145]             c <- base::c
[16:05:10.145]             inherits <- base::inherits
[16:05:10.145]             invokeRestart <- base::invokeRestart
[16:05:10.145]             length <- base::length
[16:05:10.145]             list <- base::list
[16:05:10.145]             seq.int <- base::seq.int
[16:05:10.145]             signalCondition <- base::signalCondition
[16:05:10.145]             sys.calls <- base::sys.calls
[16:05:10.145]             `[[` <- base::`[[`
[16:05:10.145]             `+` <- base::`+`
[16:05:10.145]             `<<-` <- base::`<<-`
[16:05:10.145]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:10.145]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:10.145]                   3L)]
[16:05:10.145]             }
[16:05:10.145]             function(cond) {
[16:05:10.145]                 is_error <- inherits(cond, "error")
[16:05:10.145]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:10.145]                   NULL)
[16:05:10.145]                 if (is_error) {
[16:05:10.145]                   sessionInformation <- function() {
[16:05:10.145]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:10.145]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:10.145]                       search = base::search(), system = base::Sys.info())
[16:05:10.145]                   }
[16:05:10.145]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.145]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:10.145]                     cond$call), session = sessionInformation(), 
[16:05:10.145]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:10.145]                   signalCondition(cond)
[16:05:10.145]                 }
[16:05:10.145]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:10.145]                 "immediateCondition"))) {
[16:05:10.145]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:10.145]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.145]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:10.145]                   if (TRUE && !signal) {
[16:05:10.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.145]                     {
[16:05:10.145]                       inherits <- base::inherits
[16:05:10.145]                       invokeRestart <- base::invokeRestart
[16:05:10.145]                       is.null <- base::is.null
[16:05:10.145]                       muffled <- FALSE
[16:05:10.145]                       if (inherits(cond, "message")) {
[16:05:10.145]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.145]                         if (muffled) 
[16:05:10.145]                           invokeRestart("muffleMessage")
[16:05:10.145]                       }
[16:05:10.145]                       else if (inherits(cond, "warning")) {
[16:05:10.145]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.145]                         if (muffled) 
[16:05:10.145]                           invokeRestart("muffleWarning")
[16:05:10.145]                       }
[16:05:10.145]                       else if (inherits(cond, "condition")) {
[16:05:10.145]                         if (!is.null(pattern)) {
[16:05:10.145]                           computeRestarts <- base::computeRestarts
[16:05:10.145]                           grepl <- base::grepl
[16:05:10.145]                           restarts <- computeRestarts(cond)
[16:05:10.145]                           for (restart in restarts) {
[16:05:10.145]                             name <- restart$name
[16:05:10.145]                             if (is.null(name)) 
[16:05:10.145]                               next
[16:05:10.145]                             if (!grepl(pattern, name)) 
[16:05:10.145]                               next
[16:05:10.145]                             invokeRestart(restart)
[16:05:10.145]                             muffled <- TRUE
[16:05:10.145]                             break
[16:05:10.145]                           }
[16:05:10.145]                         }
[16:05:10.145]                       }
[16:05:10.145]                       invisible(muffled)
[16:05:10.145]                     }
[16:05:10.145]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.145]                   }
[16:05:10.145]                 }
[16:05:10.145]                 else {
[16:05:10.145]                   if (TRUE) {
[16:05:10.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.145]                     {
[16:05:10.145]                       inherits <- base::inherits
[16:05:10.145]                       invokeRestart <- base::invokeRestart
[16:05:10.145]                       is.null <- base::is.null
[16:05:10.145]                       muffled <- FALSE
[16:05:10.145]                       if (inherits(cond, "message")) {
[16:05:10.145]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.145]                         if (muffled) 
[16:05:10.145]                           invokeRestart("muffleMessage")
[16:05:10.145]                       }
[16:05:10.145]                       else if (inherits(cond, "warning")) {
[16:05:10.145]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.145]                         if (muffled) 
[16:05:10.145]                           invokeRestart("muffleWarning")
[16:05:10.145]                       }
[16:05:10.145]                       else if (inherits(cond, "condition")) {
[16:05:10.145]                         if (!is.null(pattern)) {
[16:05:10.145]                           computeRestarts <- base::computeRestarts
[16:05:10.145]                           grepl <- base::grepl
[16:05:10.145]                           restarts <- computeRestarts(cond)
[16:05:10.145]                           for (restart in restarts) {
[16:05:10.145]                             name <- restart$name
[16:05:10.145]                             if (is.null(name)) 
[16:05:10.145]                               next
[16:05:10.145]                             if (!grepl(pattern, name)) 
[16:05:10.145]                               next
[16:05:10.145]                             invokeRestart(restart)
[16:05:10.145]                             muffled <- TRUE
[16:05:10.145]                             break
[16:05:10.145]                           }
[16:05:10.145]                         }
[16:05:10.145]                       }
[16:05:10.145]                       invisible(muffled)
[16:05:10.145]                     }
[16:05:10.145]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.145]                   }
[16:05:10.145]                 }
[16:05:10.145]             }
[16:05:10.145]         }))
[16:05:10.145]     }, error = function(ex) {
[16:05:10.145]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:10.145]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.145]                 ...future.rng), started = ...future.startTime, 
[16:05:10.145]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:10.145]             version = "1.8"), class = "FutureResult")
[16:05:10.145]     }, finally = {
[16:05:10.145]         if (!identical(...future.workdir, getwd())) 
[16:05:10.145]             setwd(...future.workdir)
[16:05:10.145]         {
[16:05:10.145]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:10.145]                 ...future.oldOptions$nwarnings <- NULL
[16:05:10.145]             }
[16:05:10.145]             base::options(...future.oldOptions)
[16:05:10.145]             if (.Platform$OS.type == "windows") {
[16:05:10.145]                 old_names <- names(...future.oldEnvVars)
[16:05:10.145]                 envs <- base::Sys.getenv()
[16:05:10.145]                 names <- names(envs)
[16:05:10.145]                 common <- intersect(names, old_names)
[16:05:10.145]                 added <- setdiff(names, old_names)
[16:05:10.145]                 removed <- setdiff(old_names, names)
[16:05:10.145]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:10.145]                   envs[common]]
[16:05:10.145]                 NAMES <- toupper(changed)
[16:05:10.145]                 args <- list()
[16:05:10.145]                 for (kk in seq_along(NAMES)) {
[16:05:10.145]                   name <- changed[[kk]]
[16:05:10.145]                   NAME <- NAMES[[kk]]
[16:05:10.145]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.145]                     next
[16:05:10.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.145]                 }
[16:05:10.145]                 NAMES <- toupper(added)
[16:05:10.145]                 for (kk in seq_along(NAMES)) {
[16:05:10.145]                   name <- added[[kk]]
[16:05:10.145]                   NAME <- NAMES[[kk]]
[16:05:10.145]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.145]                     next
[16:05:10.145]                   args[[name]] <- ""
[16:05:10.145]                 }
[16:05:10.145]                 NAMES <- toupper(removed)
[16:05:10.145]                 for (kk in seq_along(NAMES)) {
[16:05:10.145]                   name <- removed[[kk]]
[16:05:10.145]                   NAME <- NAMES[[kk]]
[16:05:10.145]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.145]                     next
[16:05:10.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.145]                 }
[16:05:10.145]                 if (length(args) > 0) 
[16:05:10.145]                   base::do.call(base::Sys.setenv, args = args)
[16:05:10.145]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:10.145]             }
[16:05:10.145]             else {
[16:05:10.145]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:10.145]             }
[16:05:10.145]             {
[16:05:10.145]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:10.145]                   0L) {
[16:05:10.145]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:10.145]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:10.145]                   base::options(opts)
[16:05:10.145]                 }
[16:05:10.145]                 {
[16:05:10.145]                   {
[16:05:10.145]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:10.145]                     NULL
[16:05:10.145]                   }
[16:05:10.145]                   options(future.plan = NULL)
[16:05:10.145]                   if (is.na(NA_character_)) 
[16:05:10.145]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.145]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:10.145]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:10.145]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:10.145]                     envir = parent.frame()) 
[16:05:10.145]                   {
[16:05:10.145]                     if (is.function(workers)) 
[16:05:10.145]                       workers <- workers()
[16:05:10.145]                     workers <- structure(as.integer(workers), 
[16:05:10.145]                       class = class(workers))
[16:05:10.145]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:10.145]                       workers >= 1)
[16:05:10.145]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:10.145]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:10.145]                     }
[16:05:10.145]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:10.145]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:10.145]                       envir = envir)
[16:05:10.145]                     if (!future$lazy) 
[16:05:10.145]                       future <- run(future)
[16:05:10.145]                     invisible(future)
[16:05:10.145]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:10.145]                 }
[16:05:10.145]             }
[16:05:10.145]         }
[16:05:10.145]     })
[16:05:10.145]     if (TRUE) {
[16:05:10.145]         base::sink(type = "output", split = FALSE)
[16:05:10.145]         if (TRUE) {
[16:05:10.145]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:10.145]         }
[16:05:10.145]         else {
[16:05:10.145]             ...future.result["stdout"] <- base::list(NULL)
[16:05:10.145]         }
[16:05:10.145]         base::close(...future.stdout)
[16:05:10.145]         ...future.stdout <- NULL
[16:05:10.145]     }
[16:05:10.145]     ...future.result$conditions <- ...future.conditions
[16:05:10.145]     ...future.result$finished <- base::Sys.time()
[16:05:10.145]     ...future.result
[16:05:10.145] }
[16:05:10.148] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[16:05:10.149] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[16:05:10.199] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[16:05:10.199] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[16:05:10.200] MultisessionFuture started
[16:05:10.200] - Launch lazy future ... done
[16:05:10.200] run() for ‘MultisessionFuture’ ... done
[16:05:10.200] result() for ClusterFuture ...
[16:05:10.201] receiveMessageFromWorker() for ClusterFuture ...
[16:05:10.201] - Validating connection of MultisessionFuture
[16:05:10.249] - received message: FutureResult
[16:05:10.249] - Received FutureResult
[16:05:10.249] - Erased future from FutureRegistry
[16:05:10.249] result() for ClusterFuture ...
[16:05:10.249] - result already collected: FutureResult
[16:05:10.249] result() for ClusterFuture ... done
[16:05:10.249] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:10.250] result() for ClusterFuture ... done
[16:05:10.250] result() for ClusterFuture ...
[16:05:10.250] - result already collected: FutureResult
[16:05:10.250] result() for ClusterFuture ... done
value(b) = 2
[16:05:10.250] result() for ClusterFuture ...
[16:05:10.250] - result already collected: FutureResult
[16:05:10.250] result() for ClusterFuture ... done
[16:05:10.250] result() for ClusterFuture ...
[16:05:10.250] - result already collected: FutureResult
[16:05:10.251] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:10.251] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:10.251] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:05:10.252] - globals found: [2] ‘{’, ‘pkg’
[16:05:10.252] Searching for globals ... DONE
[16:05:10.252] Resolving globals: TRUE
[16:05:10.252] Resolving any globals that are futures ...
[16:05:10.252] - globals: [2] ‘{’, ‘pkg’
[16:05:10.252] Resolving any globals that are futures ... DONE
[16:05:10.253] Resolving futures part of globals (recursively) ...
[16:05:10.253] resolve() on list ...
[16:05:10.253]  recursive: 99
[16:05:10.253]  length: 1
[16:05:10.253]  elements: ‘pkg’
[16:05:10.253]  length: 0 (resolved future 1)
[16:05:10.253] resolve() on list ... DONE
[16:05:10.254] - globals: [1] ‘pkg’
[16:05:10.254] Resolving futures part of globals (recursively) ... DONE
[16:05:10.254] The total size of the 1 globals is 112 bytes (112 bytes)
[16:05:10.254] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[16:05:10.254] - globals: [1] ‘pkg’
[16:05:10.254] 
[16:05:10.254] getGlobalsAndPackages() ... DONE
[16:05:10.255] Packages needed by the future expression (n = 0): <none>
[16:05:10.255] Packages needed by future strategies (n = 0): <none>
[16:05:10.255] {
[16:05:10.255]     {
[16:05:10.255]         {
[16:05:10.255]             ...future.startTime <- base::Sys.time()
[16:05:10.255]             {
[16:05:10.255]                 {
[16:05:10.255]                   {
[16:05:10.255]                     base::local({
[16:05:10.255]                       has_future <- base::requireNamespace("future", 
[16:05:10.255]                         quietly = TRUE)
[16:05:10.255]                       if (has_future) {
[16:05:10.255]                         ns <- base::getNamespace("future")
[16:05:10.255]                         version <- ns[[".package"]][["version"]]
[16:05:10.255]                         if (is.null(version)) 
[16:05:10.255]                           version <- utils::packageVersion("future")
[16:05:10.255]                       }
[16:05:10.255]                       else {
[16:05:10.255]                         version <- NULL
[16:05:10.255]                       }
[16:05:10.255]                       if (!has_future || version < "1.8.0") {
[16:05:10.255]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:10.255]                           "", base::R.version$version.string), 
[16:05:10.255]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:10.255]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:10.255]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:10.255]                             "release", "version")], collapse = " "), 
[16:05:10.255]                           hostname = base::Sys.info()[["nodename"]])
[16:05:10.255]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:10.255]                           info)
[16:05:10.255]                         info <- base::paste(info, collapse = "; ")
[16:05:10.255]                         if (!has_future) {
[16:05:10.255]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:10.255]                             info)
[16:05:10.255]                         }
[16:05:10.255]                         else {
[16:05:10.255]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:10.255]                             info, version)
[16:05:10.255]                         }
[16:05:10.255]                         base::stop(msg)
[16:05:10.255]                       }
[16:05:10.255]                     })
[16:05:10.255]                   }
[16:05:10.255]                   options(future.plan = NULL)
[16:05:10.255]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.255]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:10.255]                 }
[16:05:10.255]                 ...future.workdir <- getwd()
[16:05:10.255]             }
[16:05:10.255]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:10.255]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:10.255]         }
[16:05:10.255]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:10.255]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:05:10.255]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:10.255]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:10.255]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:10.255]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:10.255]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:10.255]             base::names(...future.oldOptions))
[16:05:10.255]     }
[16:05:10.255]     if (FALSE) {
[16:05:10.255]     }
[16:05:10.255]     else {
[16:05:10.255]         if (TRUE) {
[16:05:10.255]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:10.255]                 open = "w")
[16:05:10.255]         }
[16:05:10.255]         else {
[16:05:10.255]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:10.255]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:10.255]         }
[16:05:10.255]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:10.255]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:10.255]             base::sink(type = "output", split = FALSE)
[16:05:10.255]             base::close(...future.stdout)
[16:05:10.255]         }, add = TRUE)
[16:05:10.255]     }
[16:05:10.255]     ...future.frame <- base::sys.nframe()
[16:05:10.255]     ...future.conditions <- base::list()
[16:05:10.255]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:10.255]     if (FALSE) {
[16:05:10.255]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:10.255]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:10.255]     }
[16:05:10.255]     ...future.result <- base::tryCatch({
[16:05:10.255]         base::withCallingHandlers({
[16:05:10.255]             ...future.value <- base::withVisible(base::local({
[16:05:10.255]                 pkg
[16:05:10.255]             }))
[16:05:10.255]             future::FutureResult(value = ...future.value$value, 
[16:05:10.255]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.255]                   ...future.rng), globalenv = if (FALSE) 
[16:05:10.255]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:10.255]                     ...future.globalenv.names))
[16:05:10.255]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:10.255]         }, condition = base::local({
[16:05:10.255]             c <- base::c
[16:05:10.255]             inherits <- base::inherits
[16:05:10.255]             invokeRestart <- base::invokeRestart
[16:05:10.255]             length <- base::length
[16:05:10.255]             list <- base::list
[16:05:10.255]             seq.int <- base::seq.int
[16:05:10.255]             signalCondition <- base::signalCondition
[16:05:10.255]             sys.calls <- base::sys.calls
[16:05:10.255]             `[[` <- base::`[[`
[16:05:10.255]             `+` <- base::`+`
[16:05:10.255]             `<<-` <- base::`<<-`
[16:05:10.255]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:10.255]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:10.255]                   3L)]
[16:05:10.255]             }
[16:05:10.255]             function(cond) {
[16:05:10.255]                 is_error <- inherits(cond, "error")
[16:05:10.255]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:10.255]                   NULL)
[16:05:10.255]                 if (is_error) {
[16:05:10.255]                   sessionInformation <- function() {
[16:05:10.255]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:10.255]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:10.255]                       search = base::search(), system = base::Sys.info())
[16:05:10.255]                   }
[16:05:10.255]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.255]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:10.255]                     cond$call), session = sessionInformation(), 
[16:05:10.255]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:10.255]                   signalCondition(cond)
[16:05:10.255]                 }
[16:05:10.255]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:10.255]                 "immediateCondition"))) {
[16:05:10.255]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:10.255]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.255]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:10.255]                   if (TRUE && !signal) {
[16:05:10.255]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.255]                     {
[16:05:10.255]                       inherits <- base::inherits
[16:05:10.255]                       invokeRestart <- base::invokeRestart
[16:05:10.255]                       is.null <- base::is.null
[16:05:10.255]                       muffled <- FALSE
[16:05:10.255]                       if (inherits(cond, "message")) {
[16:05:10.255]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.255]                         if (muffled) 
[16:05:10.255]                           invokeRestart("muffleMessage")
[16:05:10.255]                       }
[16:05:10.255]                       else if (inherits(cond, "warning")) {
[16:05:10.255]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.255]                         if (muffled) 
[16:05:10.255]                           invokeRestart("muffleWarning")
[16:05:10.255]                       }
[16:05:10.255]                       else if (inherits(cond, "condition")) {
[16:05:10.255]                         if (!is.null(pattern)) {
[16:05:10.255]                           computeRestarts <- base::computeRestarts
[16:05:10.255]                           grepl <- base::grepl
[16:05:10.255]                           restarts <- computeRestarts(cond)
[16:05:10.255]                           for (restart in restarts) {
[16:05:10.255]                             name <- restart$name
[16:05:10.255]                             if (is.null(name)) 
[16:05:10.255]                               next
[16:05:10.255]                             if (!grepl(pattern, name)) 
[16:05:10.255]                               next
[16:05:10.255]                             invokeRestart(restart)
[16:05:10.255]                             muffled <- TRUE
[16:05:10.255]                             break
[16:05:10.255]                           }
[16:05:10.255]                         }
[16:05:10.255]                       }
[16:05:10.255]                       invisible(muffled)
[16:05:10.255]                     }
[16:05:10.255]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.255]                   }
[16:05:10.255]                 }
[16:05:10.255]                 else {
[16:05:10.255]                   if (TRUE) {
[16:05:10.255]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.255]                     {
[16:05:10.255]                       inherits <- base::inherits
[16:05:10.255]                       invokeRestart <- base::invokeRestart
[16:05:10.255]                       is.null <- base::is.null
[16:05:10.255]                       muffled <- FALSE
[16:05:10.255]                       if (inherits(cond, "message")) {
[16:05:10.255]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.255]                         if (muffled) 
[16:05:10.255]                           invokeRestart("muffleMessage")
[16:05:10.255]                       }
[16:05:10.255]                       else if (inherits(cond, "warning")) {
[16:05:10.255]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.255]                         if (muffled) 
[16:05:10.255]                           invokeRestart("muffleWarning")
[16:05:10.255]                       }
[16:05:10.255]                       else if (inherits(cond, "condition")) {
[16:05:10.255]                         if (!is.null(pattern)) {
[16:05:10.255]                           computeRestarts <- base::computeRestarts
[16:05:10.255]                           grepl <- base::grepl
[16:05:10.255]                           restarts <- computeRestarts(cond)
[16:05:10.255]                           for (restart in restarts) {
[16:05:10.255]                             name <- restart$name
[16:05:10.255]                             if (is.null(name)) 
[16:05:10.255]                               next
[16:05:10.255]                             if (!grepl(pattern, name)) 
[16:05:10.255]                               next
[16:05:10.255]                             invokeRestart(restart)
[16:05:10.255]                             muffled <- TRUE
[16:05:10.255]                             break
[16:05:10.255]                           }
[16:05:10.255]                         }
[16:05:10.255]                       }
[16:05:10.255]                       invisible(muffled)
[16:05:10.255]                     }
[16:05:10.255]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.255]                   }
[16:05:10.255]                 }
[16:05:10.255]             }
[16:05:10.255]         }))
[16:05:10.255]     }, error = function(ex) {
[16:05:10.255]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:10.255]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.255]                 ...future.rng), started = ...future.startTime, 
[16:05:10.255]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:10.255]             version = "1.8"), class = "FutureResult")
[16:05:10.255]     }, finally = {
[16:05:10.255]         if (!identical(...future.workdir, getwd())) 
[16:05:10.255]             setwd(...future.workdir)
[16:05:10.255]         {
[16:05:10.255]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:10.255]                 ...future.oldOptions$nwarnings <- NULL
[16:05:10.255]             }
[16:05:10.255]             base::options(...future.oldOptions)
[16:05:10.255]             if (.Platform$OS.type == "windows") {
[16:05:10.255]                 old_names <- names(...future.oldEnvVars)
[16:05:10.255]                 envs <- base::Sys.getenv()
[16:05:10.255]                 names <- names(envs)
[16:05:10.255]                 common <- intersect(names, old_names)
[16:05:10.255]                 added <- setdiff(names, old_names)
[16:05:10.255]                 removed <- setdiff(old_names, names)
[16:05:10.255]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:10.255]                   envs[common]]
[16:05:10.255]                 NAMES <- toupper(changed)
[16:05:10.255]                 args <- list()
[16:05:10.255]                 for (kk in seq_along(NAMES)) {
[16:05:10.255]                   name <- changed[[kk]]
[16:05:10.255]                   NAME <- NAMES[[kk]]
[16:05:10.255]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.255]                     next
[16:05:10.255]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.255]                 }
[16:05:10.255]                 NAMES <- toupper(added)
[16:05:10.255]                 for (kk in seq_along(NAMES)) {
[16:05:10.255]                   name <- added[[kk]]
[16:05:10.255]                   NAME <- NAMES[[kk]]
[16:05:10.255]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.255]                     next
[16:05:10.255]                   args[[name]] <- ""
[16:05:10.255]                 }
[16:05:10.255]                 NAMES <- toupper(removed)
[16:05:10.255]                 for (kk in seq_along(NAMES)) {
[16:05:10.255]                   name <- removed[[kk]]
[16:05:10.255]                   NAME <- NAMES[[kk]]
[16:05:10.255]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.255]                     next
[16:05:10.255]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.255]                 }
[16:05:10.255]                 if (length(args) > 0) 
[16:05:10.255]                   base::do.call(base::Sys.setenv, args = args)
[16:05:10.255]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:10.255]             }
[16:05:10.255]             else {
[16:05:10.255]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:10.255]             }
[16:05:10.255]             {
[16:05:10.255]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:10.255]                   0L) {
[16:05:10.255]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:10.255]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:10.255]                   base::options(opts)
[16:05:10.255]                 }
[16:05:10.255]                 {
[16:05:10.255]                   {
[16:05:10.255]                     NULL
[16:05:10.255]                     RNGkind("Mersenne-Twister")
[16:05:10.255]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:10.255]                       inherits = FALSE)
[16:05:10.255]                   }
[16:05:10.255]                   options(future.plan = NULL)
[16:05:10.255]                   if (is.na(NA_character_)) 
[16:05:10.255]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.255]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:10.255]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:10.255]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:10.255]                     envir = parent.frame()) 
[16:05:10.255]                   {
[16:05:10.255]                     if (is.function(workers)) 
[16:05:10.255]                       workers <- workers()
[16:05:10.255]                     workers <- structure(as.integer(workers), 
[16:05:10.255]                       class = class(workers))
[16:05:10.255]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:10.255]                       workers >= 1)
[16:05:10.255]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:10.255]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:10.255]                     }
[16:05:10.255]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:10.255]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:10.255]                       envir = envir)
[16:05:10.255]                     if (!future$lazy) 
[16:05:10.255]                       future <- run(future)
[16:05:10.255]                     invisible(future)
[16:05:10.255]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:10.255]                 }
[16:05:10.255]             }
[16:05:10.255]         }
[16:05:10.255]     })
[16:05:10.255]     if (TRUE) {
[16:05:10.255]         base::sink(type = "output", split = FALSE)
[16:05:10.255]         if (TRUE) {
[16:05:10.255]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:10.255]         }
[16:05:10.255]         else {
[16:05:10.255]             ...future.result["stdout"] <- base::list(NULL)
[16:05:10.255]         }
[16:05:10.255]         base::close(...future.stdout)
[16:05:10.255]         ...future.stdout <- NULL
[16:05:10.255]     }
[16:05:10.255]     ...future.result$conditions <- ...future.conditions
[16:05:10.255]     ...future.result$finished <- base::Sys.time()
[16:05:10.255]     ...future.result
[16:05:10.255] }
[16:05:10.257] assign_globals() ...
[16:05:10.257] List of 1
[16:05:10.257]  $ pkg: chr "foo"
[16:05:10.257]  - attr(*, "where")=List of 1
[16:05:10.257]   ..$ pkg:<environment: R_EmptyEnv> 
[16:05:10.257]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:10.257]  - attr(*, "resolved")= logi TRUE
[16:05:10.257]  - attr(*, "total_size")= num 112
[16:05:10.259] - copied ‘pkg’ to environment
[16:05:10.259] assign_globals() ... done
[16:05:10.260] plan(): Setting new future strategy stack:
[16:05:10.260] List of future strategies:
[16:05:10.260] 1. sequential:
[16:05:10.260]    - args: function (..., envir = parent.frame())
[16:05:10.260]    - tweaked: FALSE
[16:05:10.260]    - call: NULL
[16:05:10.260] plan(): nbrOfWorkers() = 1
[16:05:10.261] plan(): Setting new future strategy stack:
[16:05:10.261] List of future strategies:
[16:05:10.261] 1. multisession:
[16:05:10.261]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:10.261]    - tweaked: FALSE
[16:05:10.261]    - call: plan(strategy)
[16:05:10.265] plan(): nbrOfWorkers() = 2
[16:05:10.265] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:10.265] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:10.266] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:10.267] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:05:10.268] Searching for globals ... DONE
[16:05:10.268] Resolving globals: TRUE
[16:05:10.268] Resolving any globals that are futures ...
[16:05:10.268] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:05:10.268] Resolving any globals that are futures ... DONE
[16:05:10.268] Resolving futures part of globals (recursively) ...
[16:05:10.269] resolve() on list ...
[16:05:10.269]  recursive: 99
[16:05:10.269]  length: 1
[16:05:10.269]  elements: ‘a’
[16:05:10.269]  length: 0 (resolved future 1)
[16:05:10.269] resolve() on list ... DONE
[16:05:10.269] - globals: [1] ‘a’
[16:05:10.269] Resolving futures part of globals (recursively) ... DONE
[16:05:10.269] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:10.270] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:05:10.270] - globals: [1] ‘a’
[16:05:10.270] 
[16:05:10.270] getGlobalsAndPackages() ... DONE
[16:05:10.270] run() for ‘Future’ ...
[16:05:10.270] - state: ‘created’
[16:05:10.270] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:10.284] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:10.284] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:10.284]   - Field: ‘node’
[16:05:10.284]   - Field: ‘label’
[16:05:10.284]   - Field: ‘local’
[16:05:10.284]   - Field: ‘owner’
[16:05:10.284]   - Field: ‘envir’
[16:05:10.284]   - Field: ‘workers’
[16:05:10.285]   - Field: ‘packages’
[16:05:10.285]   - Field: ‘gc’
[16:05:10.285]   - Field: ‘conditions’
[16:05:10.285]   - Field: ‘persistent’
[16:05:10.285]   - Field: ‘expr’
[16:05:10.285]   - Field: ‘uuid’
[16:05:10.285]   - Field: ‘seed’
[16:05:10.285]   - Field: ‘version’
[16:05:10.285]   - Field: ‘result’
[16:05:10.285]   - Field: ‘asynchronous’
[16:05:10.285]   - Field: ‘calls’
[16:05:10.286]   - Field: ‘globals’
[16:05:10.286]   - Field: ‘stdout’
[16:05:10.286]   - Field: ‘earlySignal’
[16:05:10.286]   - Field: ‘lazy’
[16:05:10.286]   - Field: ‘state’
[16:05:10.286] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:10.286] - Launch lazy future ...
[16:05:10.286] Packages needed by the future expression (n = 0): <none>
[16:05:10.287] Packages needed by future strategies (n = 0): <none>
[16:05:10.287] {
[16:05:10.287]     {
[16:05:10.287]         {
[16:05:10.287]             ...future.startTime <- base::Sys.time()
[16:05:10.287]             {
[16:05:10.287]                 {
[16:05:10.287]                   {
[16:05:10.287]                     {
[16:05:10.287]                       base::local({
[16:05:10.287]                         has_future <- base::requireNamespace("future", 
[16:05:10.287]                           quietly = TRUE)
[16:05:10.287]                         if (has_future) {
[16:05:10.287]                           ns <- base::getNamespace("future")
[16:05:10.287]                           version <- ns[[".package"]][["version"]]
[16:05:10.287]                           if (is.null(version)) 
[16:05:10.287]                             version <- utils::packageVersion("future")
[16:05:10.287]                         }
[16:05:10.287]                         else {
[16:05:10.287]                           version <- NULL
[16:05:10.287]                         }
[16:05:10.287]                         if (!has_future || version < "1.8.0") {
[16:05:10.287]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:10.287]                             "", base::R.version$version.string), 
[16:05:10.287]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:10.287]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:10.287]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:10.287]                               "release", "version")], collapse = " "), 
[16:05:10.287]                             hostname = base::Sys.info()[["nodename"]])
[16:05:10.287]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:10.287]                             info)
[16:05:10.287]                           info <- base::paste(info, collapse = "; ")
[16:05:10.287]                           if (!has_future) {
[16:05:10.287]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:10.287]                               info)
[16:05:10.287]                           }
[16:05:10.287]                           else {
[16:05:10.287]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:10.287]                               info, version)
[16:05:10.287]                           }
[16:05:10.287]                           base::stop(msg)
[16:05:10.287]                         }
[16:05:10.287]                       })
[16:05:10.287]                     }
[16:05:10.287]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:10.287]                     base::options(mc.cores = 1L)
[16:05:10.287]                   }
[16:05:10.287]                   options(future.plan = NULL)
[16:05:10.287]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.287]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:10.287]                 }
[16:05:10.287]                 ...future.workdir <- getwd()
[16:05:10.287]             }
[16:05:10.287]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:10.287]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:10.287]         }
[16:05:10.287]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:10.287]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:10.287]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:10.287]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:10.287]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:10.287]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:10.287]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:10.287]             base::names(...future.oldOptions))
[16:05:10.287]     }
[16:05:10.287]     if (FALSE) {
[16:05:10.287]     }
[16:05:10.287]     else {
[16:05:10.287]         if (TRUE) {
[16:05:10.287]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:10.287]                 open = "w")
[16:05:10.287]         }
[16:05:10.287]         else {
[16:05:10.287]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:10.287]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:10.287]         }
[16:05:10.287]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:10.287]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:10.287]             base::sink(type = "output", split = FALSE)
[16:05:10.287]             base::close(...future.stdout)
[16:05:10.287]         }, add = TRUE)
[16:05:10.287]     }
[16:05:10.287]     ...future.frame <- base::sys.nframe()
[16:05:10.287]     ...future.conditions <- base::list()
[16:05:10.287]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:10.287]     if (FALSE) {
[16:05:10.287]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:10.287]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:10.287]     }
[16:05:10.287]     ...future.result <- base::tryCatch({
[16:05:10.287]         base::withCallingHandlers({
[16:05:10.287]             ...future.value <- base::withVisible(base::local({
[16:05:10.287]                 ...future.makeSendCondition <- base::local({
[16:05:10.287]                   sendCondition <- NULL
[16:05:10.287]                   function(frame = 1L) {
[16:05:10.287]                     if (is.function(sendCondition)) 
[16:05:10.287]                       return(sendCondition)
[16:05:10.287]                     ns <- getNamespace("parallel")
[16:05:10.287]                     if (exists("sendData", mode = "function", 
[16:05:10.287]                       envir = ns)) {
[16:05:10.287]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:10.287]                         envir = ns)
[16:05:10.287]                       envir <- sys.frame(frame)
[16:05:10.287]                       master <- NULL
[16:05:10.287]                       while (!identical(envir, .GlobalEnv) && 
[16:05:10.287]                         !identical(envir, emptyenv())) {
[16:05:10.287]                         if (exists("master", mode = "list", envir = envir, 
[16:05:10.287]                           inherits = FALSE)) {
[16:05:10.287]                           master <- get("master", mode = "list", 
[16:05:10.287]                             envir = envir, inherits = FALSE)
[16:05:10.287]                           if (inherits(master, c("SOCKnode", 
[16:05:10.287]                             "SOCK0node"))) {
[16:05:10.287]                             sendCondition <<- function(cond) {
[16:05:10.287]                               data <- list(type = "VALUE", value = cond, 
[16:05:10.287]                                 success = TRUE)
[16:05:10.287]                               parallel_sendData(master, data)
[16:05:10.287]                             }
[16:05:10.287]                             return(sendCondition)
[16:05:10.287]                           }
[16:05:10.287]                         }
[16:05:10.287]                         frame <- frame + 1L
[16:05:10.287]                         envir <- sys.frame(frame)
[16:05:10.287]                       }
[16:05:10.287]                     }
[16:05:10.287]                     sendCondition <<- function(cond) NULL
[16:05:10.287]                   }
[16:05:10.287]                 })
[16:05:10.287]                 withCallingHandlers({
[16:05:10.287]                   {
[16:05:10.287]                     b <- a
[16:05:10.287]                     a <- 2
[16:05:10.287]                     a * b
[16:05:10.287]                   }
[16:05:10.287]                 }, immediateCondition = function(cond) {
[16:05:10.287]                   sendCondition <- ...future.makeSendCondition()
[16:05:10.287]                   sendCondition(cond)
[16:05:10.287]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.287]                   {
[16:05:10.287]                     inherits <- base::inherits
[16:05:10.287]                     invokeRestart <- base::invokeRestart
[16:05:10.287]                     is.null <- base::is.null
[16:05:10.287]                     muffled <- FALSE
[16:05:10.287]                     if (inherits(cond, "message")) {
[16:05:10.287]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:10.287]                       if (muffled) 
[16:05:10.287]                         invokeRestart("muffleMessage")
[16:05:10.287]                     }
[16:05:10.287]                     else if (inherits(cond, "warning")) {
[16:05:10.287]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:10.287]                       if (muffled) 
[16:05:10.287]                         invokeRestart("muffleWarning")
[16:05:10.287]                     }
[16:05:10.287]                     else if (inherits(cond, "condition")) {
[16:05:10.287]                       if (!is.null(pattern)) {
[16:05:10.287]                         computeRestarts <- base::computeRestarts
[16:05:10.287]                         grepl <- base::grepl
[16:05:10.287]                         restarts <- computeRestarts(cond)
[16:05:10.287]                         for (restart in restarts) {
[16:05:10.287]                           name <- restart$name
[16:05:10.287]                           if (is.null(name)) 
[16:05:10.287]                             next
[16:05:10.287]                           if (!grepl(pattern, name)) 
[16:05:10.287]                             next
[16:05:10.287]                           invokeRestart(restart)
[16:05:10.287]                           muffled <- TRUE
[16:05:10.287]                           break
[16:05:10.287]                         }
[16:05:10.287]                       }
[16:05:10.287]                     }
[16:05:10.287]                     invisible(muffled)
[16:05:10.287]                   }
[16:05:10.287]                   muffleCondition(cond)
[16:05:10.287]                 })
[16:05:10.287]             }))
[16:05:10.287]             future::FutureResult(value = ...future.value$value, 
[16:05:10.287]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.287]                   ...future.rng), globalenv = if (FALSE) 
[16:05:10.287]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:10.287]                     ...future.globalenv.names))
[16:05:10.287]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:10.287]         }, condition = base::local({
[16:05:10.287]             c <- base::c
[16:05:10.287]             inherits <- base::inherits
[16:05:10.287]             invokeRestart <- base::invokeRestart
[16:05:10.287]             length <- base::length
[16:05:10.287]             list <- base::list
[16:05:10.287]             seq.int <- base::seq.int
[16:05:10.287]             signalCondition <- base::signalCondition
[16:05:10.287]             sys.calls <- base::sys.calls
[16:05:10.287]             `[[` <- base::`[[`
[16:05:10.287]             `+` <- base::`+`
[16:05:10.287]             `<<-` <- base::`<<-`
[16:05:10.287]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:10.287]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:10.287]                   3L)]
[16:05:10.287]             }
[16:05:10.287]             function(cond) {
[16:05:10.287]                 is_error <- inherits(cond, "error")
[16:05:10.287]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:10.287]                   NULL)
[16:05:10.287]                 if (is_error) {
[16:05:10.287]                   sessionInformation <- function() {
[16:05:10.287]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:10.287]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:10.287]                       search = base::search(), system = base::Sys.info())
[16:05:10.287]                   }
[16:05:10.287]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.287]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:10.287]                     cond$call), session = sessionInformation(), 
[16:05:10.287]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:10.287]                   signalCondition(cond)
[16:05:10.287]                 }
[16:05:10.287]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:10.287]                 "immediateCondition"))) {
[16:05:10.287]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:10.287]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.287]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:10.287]                   if (TRUE && !signal) {
[16:05:10.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.287]                     {
[16:05:10.287]                       inherits <- base::inherits
[16:05:10.287]                       invokeRestart <- base::invokeRestart
[16:05:10.287]                       is.null <- base::is.null
[16:05:10.287]                       muffled <- FALSE
[16:05:10.287]                       if (inherits(cond, "message")) {
[16:05:10.287]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.287]                         if (muffled) 
[16:05:10.287]                           invokeRestart("muffleMessage")
[16:05:10.287]                       }
[16:05:10.287]                       else if (inherits(cond, "warning")) {
[16:05:10.287]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.287]                         if (muffled) 
[16:05:10.287]                           invokeRestart("muffleWarning")
[16:05:10.287]                       }
[16:05:10.287]                       else if (inherits(cond, "condition")) {
[16:05:10.287]                         if (!is.null(pattern)) {
[16:05:10.287]                           computeRestarts <- base::computeRestarts
[16:05:10.287]                           grepl <- base::grepl
[16:05:10.287]                           restarts <- computeRestarts(cond)
[16:05:10.287]                           for (restart in restarts) {
[16:05:10.287]                             name <- restart$name
[16:05:10.287]                             if (is.null(name)) 
[16:05:10.287]                               next
[16:05:10.287]                             if (!grepl(pattern, name)) 
[16:05:10.287]                               next
[16:05:10.287]                             invokeRestart(restart)
[16:05:10.287]                             muffled <- TRUE
[16:05:10.287]                             break
[16:05:10.287]                           }
[16:05:10.287]                         }
[16:05:10.287]                       }
[16:05:10.287]                       invisible(muffled)
[16:05:10.287]                     }
[16:05:10.287]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.287]                   }
[16:05:10.287]                 }
[16:05:10.287]                 else {
[16:05:10.287]                   if (TRUE) {
[16:05:10.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.287]                     {
[16:05:10.287]                       inherits <- base::inherits
[16:05:10.287]                       invokeRestart <- base::invokeRestart
[16:05:10.287]                       is.null <- base::is.null
[16:05:10.287]                       muffled <- FALSE
[16:05:10.287]                       if (inherits(cond, "message")) {
[16:05:10.287]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.287]                         if (muffled) 
[16:05:10.287]                           invokeRestart("muffleMessage")
[16:05:10.287]                       }
[16:05:10.287]                       else if (inherits(cond, "warning")) {
[16:05:10.287]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.287]                         if (muffled) 
[16:05:10.287]                           invokeRestart("muffleWarning")
[16:05:10.287]                       }
[16:05:10.287]                       else if (inherits(cond, "condition")) {
[16:05:10.287]                         if (!is.null(pattern)) {
[16:05:10.287]                           computeRestarts <- base::computeRestarts
[16:05:10.287]                           grepl <- base::grepl
[16:05:10.287]                           restarts <- computeRestarts(cond)
[16:05:10.287]                           for (restart in restarts) {
[16:05:10.287]                             name <- restart$name
[16:05:10.287]                             if (is.null(name)) 
[16:05:10.287]                               next
[16:05:10.287]                             if (!grepl(pattern, name)) 
[16:05:10.287]                               next
[16:05:10.287]                             invokeRestart(restart)
[16:05:10.287]                             muffled <- TRUE
[16:05:10.287]                             break
[16:05:10.287]                           }
[16:05:10.287]                         }
[16:05:10.287]                       }
[16:05:10.287]                       invisible(muffled)
[16:05:10.287]                     }
[16:05:10.287]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.287]                   }
[16:05:10.287]                 }
[16:05:10.287]             }
[16:05:10.287]         }))
[16:05:10.287]     }, error = function(ex) {
[16:05:10.287]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:10.287]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.287]                 ...future.rng), started = ...future.startTime, 
[16:05:10.287]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:10.287]             version = "1.8"), class = "FutureResult")
[16:05:10.287]     }, finally = {
[16:05:10.287]         if (!identical(...future.workdir, getwd())) 
[16:05:10.287]             setwd(...future.workdir)
[16:05:10.287]         {
[16:05:10.287]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:10.287]                 ...future.oldOptions$nwarnings <- NULL
[16:05:10.287]             }
[16:05:10.287]             base::options(...future.oldOptions)
[16:05:10.287]             if (.Platform$OS.type == "windows") {
[16:05:10.287]                 old_names <- names(...future.oldEnvVars)
[16:05:10.287]                 envs <- base::Sys.getenv()
[16:05:10.287]                 names <- names(envs)
[16:05:10.287]                 common <- intersect(names, old_names)
[16:05:10.287]                 added <- setdiff(names, old_names)
[16:05:10.287]                 removed <- setdiff(old_names, names)
[16:05:10.287]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:10.287]                   envs[common]]
[16:05:10.287]                 NAMES <- toupper(changed)
[16:05:10.287]                 args <- list()
[16:05:10.287]                 for (kk in seq_along(NAMES)) {
[16:05:10.287]                   name <- changed[[kk]]
[16:05:10.287]                   NAME <- NAMES[[kk]]
[16:05:10.287]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.287]                     next
[16:05:10.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.287]                 }
[16:05:10.287]                 NAMES <- toupper(added)
[16:05:10.287]                 for (kk in seq_along(NAMES)) {
[16:05:10.287]                   name <- added[[kk]]
[16:05:10.287]                   NAME <- NAMES[[kk]]
[16:05:10.287]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.287]                     next
[16:05:10.287]                   args[[name]] <- ""
[16:05:10.287]                 }
[16:05:10.287]                 NAMES <- toupper(removed)
[16:05:10.287]                 for (kk in seq_along(NAMES)) {
[16:05:10.287]                   name <- removed[[kk]]
[16:05:10.287]                   NAME <- NAMES[[kk]]
[16:05:10.287]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.287]                     next
[16:05:10.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.287]                 }
[16:05:10.287]                 if (length(args) > 0) 
[16:05:10.287]                   base::do.call(base::Sys.setenv, args = args)
[16:05:10.287]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:10.287]             }
[16:05:10.287]             else {
[16:05:10.287]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:10.287]             }
[16:05:10.287]             {
[16:05:10.287]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:10.287]                   0L) {
[16:05:10.287]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:10.287]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:10.287]                   base::options(opts)
[16:05:10.287]                 }
[16:05:10.287]                 {
[16:05:10.287]                   {
[16:05:10.287]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:10.287]                     NULL
[16:05:10.287]                   }
[16:05:10.287]                   options(future.plan = NULL)
[16:05:10.287]                   if (is.na(NA_character_)) 
[16:05:10.287]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.287]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:10.287]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:10.287]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:10.287]                     envir = parent.frame()) 
[16:05:10.287]                   {
[16:05:10.287]                     if (is.function(workers)) 
[16:05:10.287]                       workers <- workers()
[16:05:10.287]                     workers <- structure(as.integer(workers), 
[16:05:10.287]                       class = class(workers))
[16:05:10.287]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:10.287]                       workers >= 1)
[16:05:10.287]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:10.287]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:10.287]                     }
[16:05:10.287]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:10.287]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:10.287]                       envir = envir)
[16:05:10.287]                     if (!future$lazy) 
[16:05:10.287]                       future <- run(future)
[16:05:10.287]                     invisible(future)
[16:05:10.287]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:10.287]                 }
[16:05:10.287]             }
[16:05:10.287]         }
[16:05:10.287]     })
[16:05:10.287]     if (TRUE) {
[16:05:10.287]         base::sink(type = "output", split = FALSE)
[16:05:10.287]         if (TRUE) {
[16:05:10.287]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:10.287]         }
[16:05:10.287]         else {
[16:05:10.287]             ...future.result["stdout"] <- base::list(NULL)
[16:05:10.287]         }
[16:05:10.287]         base::close(...future.stdout)
[16:05:10.287]         ...future.stdout <- NULL
[16:05:10.287]     }
[16:05:10.287]     ...future.result$conditions <- ...future.conditions
[16:05:10.287]     ...future.result$finished <- base::Sys.time()
[16:05:10.287]     ...future.result
[16:05:10.287] }
[16:05:10.290] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[16:05:10.290] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[16:05:10.290] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[16:05:10.290] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[16:05:10.291] MultisessionFuture started
[16:05:10.291] - Launch lazy future ... done
[16:05:10.291] run() for ‘MultisessionFuture’ ... done
[16:05:10.291] result() for ClusterFuture ...
[16:05:10.291] receiveMessageFromWorker() for ClusterFuture ...
[16:05:10.291] - Validating connection of MultisessionFuture
[16:05:10.336] - received message: FutureResult
[16:05:10.337] - Received FutureResult
[16:05:10.337] - Erased future from FutureRegistry
[16:05:10.337] result() for ClusterFuture ...
[16:05:10.337] - result already collected: FutureResult
[16:05:10.337] result() for ClusterFuture ... done
[16:05:10.337] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:10.337] result() for ClusterFuture ... done
[16:05:10.337] result() for ClusterFuture ...
[16:05:10.337] - result already collected: FutureResult
[16:05:10.338] result() for ClusterFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:10.338] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:10.338] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:10.340] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:05:10.340] Searching for globals ... DONE
[16:05:10.340] Resolving globals: TRUE
[16:05:10.341] Resolving any globals that are futures ...
[16:05:10.341] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:05:10.341] Resolving any globals that are futures ... DONE
[16:05:10.341] Resolving futures part of globals (recursively) ...
[16:05:10.341] resolve() on list ...
[16:05:10.341]  recursive: 99
[16:05:10.341]  length: 1
[16:05:10.342]  elements: ‘a’
[16:05:10.342]  length: 0 (resolved future 1)
[16:05:10.342] resolve() on list ... DONE
[16:05:10.342] - globals: [1] ‘a’
[16:05:10.342] Resolving futures part of globals (recursively) ... DONE
[16:05:10.342] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:10.342] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:05:10.343] - globals: [1] ‘a’
[16:05:10.343] 
[16:05:10.343] getGlobalsAndPackages() ... DONE
[16:05:10.343] run() for ‘Future’ ...
[16:05:10.343] - state: ‘created’
[16:05:10.343] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:10.357] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:10.357] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:10.357]   - Field: ‘node’
[16:05:10.358]   - Field: ‘label’
[16:05:10.358]   - Field: ‘local’
[16:05:10.358]   - Field: ‘owner’
[16:05:10.358]   - Field: ‘envir’
[16:05:10.358]   - Field: ‘workers’
[16:05:10.358]   - Field: ‘packages’
[16:05:10.358]   - Field: ‘gc’
[16:05:10.358]   - Field: ‘conditions’
[16:05:10.358]   - Field: ‘persistent’
[16:05:10.358]   - Field: ‘expr’
[16:05:10.358]   - Field: ‘uuid’
[16:05:10.359]   - Field: ‘seed’
[16:05:10.359]   - Field: ‘version’
[16:05:10.359]   - Field: ‘result’
[16:05:10.359]   - Field: ‘asynchronous’
[16:05:10.359]   - Field: ‘calls’
[16:05:10.359]   - Field: ‘globals’
[16:05:10.359]   - Field: ‘stdout’
[16:05:10.359]   - Field: ‘earlySignal’
[16:05:10.359]   - Field: ‘lazy’
[16:05:10.359]   - Field: ‘state’
[16:05:10.359] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:10.360] - Launch lazy future ...
[16:05:10.360] Packages needed by the future expression (n = 0): <none>
[16:05:10.360] Packages needed by future strategies (n = 0): <none>
[16:05:10.360] {
[16:05:10.360]     {
[16:05:10.360]         {
[16:05:10.360]             ...future.startTime <- base::Sys.time()
[16:05:10.360]             {
[16:05:10.360]                 {
[16:05:10.360]                   {
[16:05:10.360]                     {
[16:05:10.360]                       base::local({
[16:05:10.360]                         has_future <- base::requireNamespace("future", 
[16:05:10.360]                           quietly = TRUE)
[16:05:10.360]                         if (has_future) {
[16:05:10.360]                           ns <- base::getNamespace("future")
[16:05:10.360]                           version <- ns[[".package"]][["version"]]
[16:05:10.360]                           if (is.null(version)) 
[16:05:10.360]                             version <- utils::packageVersion("future")
[16:05:10.360]                         }
[16:05:10.360]                         else {
[16:05:10.360]                           version <- NULL
[16:05:10.360]                         }
[16:05:10.360]                         if (!has_future || version < "1.8.0") {
[16:05:10.360]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:10.360]                             "", base::R.version$version.string), 
[16:05:10.360]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:10.360]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:10.360]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:10.360]                               "release", "version")], collapse = " "), 
[16:05:10.360]                             hostname = base::Sys.info()[["nodename"]])
[16:05:10.360]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:10.360]                             info)
[16:05:10.360]                           info <- base::paste(info, collapse = "; ")
[16:05:10.360]                           if (!has_future) {
[16:05:10.360]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:10.360]                               info)
[16:05:10.360]                           }
[16:05:10.360]                           else {
[16:05:10.360]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:10.360]                               info, version)
[16:05:10.360]                           }
[16:05:10.360]                           base::stop(msg)
[16:05:10.360]                         }
[16:05:10.360]                       })
[16:05:10.360]                     }
[16:05:10.360]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:10.360]                     base::options(mc.cores = 1L)
[16:05:10.360]                   }
[16:05:10.360]                   options(future.plan = NULL)
[16:05:10.360]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.360]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:10.360]                 }
[16:05:10.360]                 ...future.workdir <- getwd()
[16:05:10.360]             }
[16:05:10.360]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:10.360]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:10.360]         }
[16:05:10.360]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:10.360]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:10.360]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:10.360]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:10.360]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:10.360]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:10.360]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:10.360]             base::names(...future.oldOptions))
[16:05:10.360]     }
[16:05:10.360]     if (FALSE) {
[16:05:10.360]     }
[16:05:10.360]     else {
[16:05:10.360]         if (TRUE) {
[16:05:10.360]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:10.360]                 open = "w")
[16:05:10.360]         }
[16:05:10.360]         else {
[16:05:10.360]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:10.360]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:10.360]         }
[16:05:10.360]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:10.360]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:10.360]             base::sink(type = "output", split = FALSE)
[16:05:10.360]             base::close(...future.stdout)
[16:05:10.360]         }, add = TRUE)
[16:05:10.360]     }
[16:05:10.360]     ...future.frame <- base::sys.nframe()
[16:05:10.360]     ...future.conditions <- base::list()
[16:05:10.360]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:10.360]     if (FALSE) {
[16:05:10.360]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:10.360]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:10.360]     }
[16:05:10.360]     ...future.result <- base::tryCatch({
[16:05:10.360]         base::withCallingHandlers({
[16:05:10.360]             ...future.value <- base::withVisible(base::local({
[16:05:10.360]                 ...future.makeSendCondition <- base::local({
[16:05:10.360]                   sendCondition <- NULL
[16:05:10.360]                   function(frame = 1L) {
[16:05:10.360]                     if (is.function(sendCondition)) 
[16:05:10.360]                       return(sendCondition)
[16:05:10.360]                     ns <- getNamespace("parallel")
[16:05:10.360]                     if (exists("sendData", mode = "function", 
[16:05:10.360]                       envir = ns)) {
[16:05:10.360]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:10.360]                         envir = ns)
[16:05:10.360]                       envir <- sys.frame(frame)
[16:05:10.360]                       master <- NULL
[16:05:10.360]                       while (!identical(envir, .GlobalEnv) && 
[16:05:10.360]                         !identical(envir, emptyenv())) {
[16:05:10.360]                         if (exists("master", mode = "list", envir = envir, 
[16:05:10.360]                           inherits = FALSE)) {
[16:05:10.360]                           master <- get("master", mode = "list", 
[16:05:10.360]                             envir = envir, inherits = FALSE)
[16:05:10.360]                           if (inherits(master, c("SOCKnode", 
[16:05:10.360]                             "SOCK0node"))) {
[16:05:10.360]                             sendCondition <<- function(cond) {
[16:05:10.360]                               data <- list(type = "VALUE", value = cond, 
[16:05:10.360]                                 success = TRUE)
[16:05:10.360]                               parallel_sendData(master, data)
[16:05:10.360]                             }
[16:05:10.360]                             return(sendCondition)
[16:05:10.360]                           }
[16:05:10.360]                         }
[16:05:10.360]                         frame <- frame + 1L
[16:05:10.360]                         envir <- sys.frame(frame)
[16:05:10.360]                       }
[16:05:10.360]                     }
[16:05:10.360]                     sendCondition <<- function(cond) NULL
[16:05:10.360]                   }
[16:05:10.360]                 })
[16:05:10.360]                 withCallingHandlers({
[16:05:10.360]                   {
[16:05:10.360]                     b <- a
[16:05:10.360]                     a <- 2
[16:05:10.360]                     a * b
[16:05:10.360]                   }
[16:05:10.360]                 }, immediateCondition = function(cond) {
[16:05:10.360]                   sendCondition <- ...future.makeSendCondition()
[16:05:10.360]                   sendCondition(cond)
[16:05:10.360]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.360]                   {
[16:05:10.360]                     inherits <- base::inherits
[16:05:10.360]                     invokeRestart <- base::invokeRestart
[16:05:10.360]                     is.null <- base::is.null
[16:05:10.360]                     muffled <- FALSE
[16:05:10.360]                     if (inherits(cond, "message")) {
[16:05:10.360]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:10.360]                       if (muffled) 
[16:05:10.360]                         invokeRestart("muffleMessage")
[16:05:10.360]                     }
[16:05:10.360]                     else if (inherits(cond, "warning")) {
[16:05:10.360]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:10.360]                       if (muffled) 
[16:05:10.360]                         invokeRestart("muffleWarning")
[16:05:10.360]                     }
[16:05:10.360]                     else if (inherits(cond, "condition")) {
[16:05:10.360]                       if (!is.null(pattern)) {
[16:05:10.360]                         computeRestarts <- base::computeRestarts
[16:05:10.360]                         grepl <- base::grepl
[16:05:10.360]                         restarts <- computeRestarts(cond)
[16:05:10.360]                         for (restart in restarts) {
[16:05:10.360]                           name <- restart$name
[16:05:10.360]                           if (is.null(name)) 
[16:05:10.360]                             next
[16:05:10.360]                           if (!grepl(pattern, name)) 
[16:05:10.360]                             next
[16:05:10.360]                           invokeRestart(restart)
[16:05:10.360]                           muffled <- TRUE
[16:05:10.360]                           break
[16:05:10.360]                         }
[16:05:10.360]                       }
[16:05:10.360]                     }
[16:05:10.360]                     invisible(muffled)
[16:05:10.360]                   }
[16:05:10.360]                   muffleCondition(cond)
[16:05:10.360]                 })
[16:05:10.360]             }))
[16:05:10.360]             future::FutureResult(value = ...future.value$value, 
[16:05:10.360]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.360]                   ...future.rng), globalenv = if (FALSE) 
[16:05:10.360]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:10.360]                     ...future.globalenv.names))
[16:05:10.360]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:10.360]         }, condition = base::local({
[16:05:10.360]             c <- base::c
[16:05:10.360]             inherits <- base::inherits
[16:05:10.360]             invokeRestart <- base::invokeRestart
[16:05:10.360]             length <- base::length
[16:05:10.360]             list <- base::list
[16:05:10.360]             seq.int <- base::seq.int
[16:05:10.360]             signalCondition <- base::signalCondition
[16:05:10.360]             sys.calls <- base::sys.calls
[16:05:10.360]             `[[` <- base::`[[`
[16:05:10.360]             `+` <- base::`+`
[16:05:10.360]             `<<-` <- base::`<<-`
[16:05:10.360]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:10.360]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:10.360]                   3L)]
[16:05:10.360]             }
[16:05:10.360]             function(cond) {
[16:05:10.360]                 is_error <- inherits(cond, "error")
[16:05:10.360]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:10.360]                   NULL)
[16:05:10.360]                 if (is_error) {
[16:05:10.360]                   sessionInformation <- function() {
[16:05:10.360]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:10.360]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:10.360]                       search = base::search(), system = base::Sys.info())
[16:05:10.360]                   }
[16:05:10.360]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.360]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:10.360]                     cond$call), session = sessionInformation(), 
[16:05:10.360]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:10.360]                   signalCondition(cond)
[16:05:10.360]                 }
[16:05:10.360]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:10.360]                 "immediateCondition"))) {
[16:05:10.360]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:10.360]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.360]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:10.360]                   if (TRUE && !signal) {
[16:05:10.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.360]                     {
[16:05:10.360]                       inherits <- base::inherits
[16:05:10.360]                       invokeRestart <- base::invokeRestart
[16:05:10.360]                       is.null <- base::is.null
[16:05:10.360]                       muffled <- FALSE
[16:05:10.360]                       if (inherits(cond, "message")) {
[16:05:10.360]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.360]                         if (muffled) 
[16:05:10.360]                           invokeRestart("muffleMessage")
[16:05:10.360]                       }
[16:05:10.360]                       else if (inherits(cond, "warning")) {
[16:05:10.360]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.360]                         if (muffled) 
[16:05:10.360]                           invokeRestart("muffleWarning")
[16:05:10.360]                       }
[16:05:10.360]                       else if (inherits(cond, "condition")) {
[16:05:10.360]                         if (!is.null(pattern)) {
[16:05:10.360]                           computeRestarts <- base::computeRestarts
[16:05:10.360]                           grepl <- base::grepl
[16:05:10.360]                           restarts <- computeRestarts(cond)
[16:05:10.360]                           for (restart in restarts) {
[16:05:10.360]                             name <- restart$name
[16:05:10.360]                             if (is.null(name)) 
[16:05:10.360]                               next
[16:05:10.360]                             if (!grepl(pattern, name)) 
[16:05:10.360]                               next
[16:05:10.360]                             invokeRestart(restart)
[16:05:10.360]                             muffled <- TRUE
[16:05:10.360]                             break
[16:05:10.360]                           }
[16:05:10.360]                         }
[16:05:10.360]                       }
[16:05:10.360]                       invisible(muffled)
[16:05:10.360]                     }
[16:05:10.360]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.360]                   }
[16:05:10.360]                 }
[16:05:10.360]                 else {
[16:05:10.360]                   if (TRUE) {
[16:05:10.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.360]                     {
[16:05:10.360]                       inherits <- base::inherits
[16:05:10.360]                       invokeRestart <- base::invokeRestart
[16:05:10.360]                       is.null <- base::is.null
[16:05:10.360]                       muffled <- FALSE
[16:05:10.360]                       if (inherits(cond, "message")) {
[16:05:10.360]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.360]                         if (muffled) 
[16:05:10.360]                           invokeRestart("muffleMessage")
[16:05:10.360]                       }
[16:05:10.360]                       else if (inherits(cond, "warning")) {
[16:05:10.360]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.360]                         if (muffled) 
[16:05:10.360]                           invokeRestart("muffleWarning")
[16:05:10.360]                       }
[16:05:10.360]                       else if (inherits(cond, "condition")) {
[16:05:10.360]                         if (!is.null(pattern)) {
[16:05:10.360]                           computeRestarts <- base::computeRestarts
[16:05:10.360]                           grepl <- base::grepl
[16:05:10.360]                           restarts <- computeRestarts(cond)
[16:05:10.360]                           for (restart in restarts) {
[16:05:10.360]                             name <- restart$name
[16:05:10.360]                             if (is.null(name)) 
[16:05:10.360]                               next
[16:05:10.360]                             if (!grepl(pattern, name)) 
[16:05:10.360]                               next
[16:05:10.360]                             invokeRestart(restart)
[16:05:10.360]                             muffled <- TRUE
[16:05:10.360]                             break
[16:05:10.360]                           }
[16:05:10.360]                         }
[16:05:10.360]                       }
[16:05:10.360]                       invisible(muffled)
[16:05:10.360]                     }
[16:05:10.360]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.360]                   }
[16:05:10.360]                 }
[16:05:10.360]             }
[16:05:10.360]         }))
[16:05:10.360]     }, error = function(ex) {
[16:05:10.360]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:10.360]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.360]                 ...future.rng), started = ...future.startTime, 
[16:05:10.360]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:10.360]             version = "1.8"), class = "FutureResult")
[16:05:10.360]     }, finally = {
[16:05:10.360]         if (!identical(...future.workdir, getwd())) 
[16:05:10.360]             setwd(...future.workdir)
[16:05:10.360]         {
[16:05:10.360]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:10.360]                 ...future.oldOptions$nwarnings <- NULL
[16:05:10.360]             }
[16:05:10.360]             base::options(...future.oldOptions)
[16:05:10.360]             if (.Platform$OS.type == "windows") {
[16:05:10.360]                 old_names <- names(...future.oldEnvVars)
[16:05:10.360]                 envs <- base::Sys.getenv()
[16:05:10.360]                 names <- names(envs)
[16:05:10.360]                 common <- intersect(names, old_names)
[16:05:10.360]                 added <- setdiff(names, old_names)
[16:05:10.360]                 removed <- setdiff(old_names, names)
[16:05:10.360]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:10.360]                   envs[common]]
[16:05:10.360]                 NAMES <- toupper(changed)
[16:05:10.360]                 args <- list()
[16:05:10.360]                 for (kk in seq_along(NAMES)) {
[16:05:10.360]                   name <- changed[[kk]]
[16:05:10.360]                   NAME <- NAMES[[kk]]
[16:05:10.360]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.360]                     next
[16:05:10.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.360]                 }
[16:05:10.360]                 NAMES <- toupper(added)
[16:05:10.360]                 for (kk in seq_along(NAMES)) {
[16:05:10.360]                   name <- added[[kk]]
[16:05:10.360]                   NAME <- NAMES[[kk]]
[16:05:10.360]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.360]                     next
[16:05:10.360]                   args[[name]] <- ""
[16:05:10.360]                 }
[16:05:10.360]                 NAMES <- toupper(removed)
[16:05:10.360]                 for (kk in seq_along(NAMES)) {
[16:05:10.360]                   name <- removed[[kk]]
[16:05:10.360]                   NAME <- NAMES[[kk]]
[16:05:10.360]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.360]                     next
[16:05:10.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.360]                 }
[16:05:10.360]                 if (length(args) > 0) 
[16:05:10.360]                   base::do.call(base::Sys.setenv, args = args)
[16:05:10.360]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:10.360]             }
[16:05:10.360]             else {
[16:05:10.360]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:10.360]             }
[16:05:10.360]             {
[16:05:10.360]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:10.360]                   0L) {
[16:05:10.360]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:10.360]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:10.360]                   base::options(opts)
[16:05:10.360]                 }
[16:05:10.360]                 {
[16:05:10.360]                   {
[16:05:10.360]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:10.360]                     NULL
[16:05:10.360]                   }
[16:05:10.360]                   options(future.plan = NULL)
[16:05:10.360]                   if (is.na(NA_character_)) 
[16:05:10.360]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.360]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:10.360]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:10.360]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:10.360]                     envir = parent.frame()) 
[16:05:10.360]                   {
[16:05:10.360]                     if (is.function(workers)) 
[16:05:10.360]                       workers <- workers()
[16:05:10.360]                     workers <- structure(as.integer(workers), 
[16:05:10.360]                       class = class(workers))
[16:05:10.360]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:10.360]                       workers >= 1)
[16:05:10.360]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:10.360]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:10.360]                     }
[16:05:10.360]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:10.360]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:10.360]                       envir = envir)
[16:05:10.360]                     if (!future$lazy) 
[16:05:10.360]                       future <- run(future)
[16:05:10.360]                     invisible(future)
[16:05:10.360]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:10.360]                 }
[16:05:10.360]             }
[16:05:10.360]         }
[16:05:10.360]     })
[16:05:10.360]     if (TRUE) {
[16:05:10.360]         base::sink(type = "output", split = FALSE)
[16:05:10.360]         if (TRUE) {
[16:05:10.360]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:10.360]         }
[16:05:10.360]         else {
[16:05:10.360]             ...future.result["stdout"] <- base::list(NULL)
[16:05:10.360]         }
[16:05:10.360]         base::close(...future.stdout)
[16:05:10.360]         ...future.stdout <- NULL
[16:05:10.360]     }
[16:05:10.360]     ...future.result$conditions <- ...future.conditions
[16:05:10.360]     ...future.result$finished <- base::Sys.time()
[16:05:10.360]     ...future.result
[16:05:10.360] }
[16:05:10.363] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[16:05:10.363] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[16:05:10.364] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[16:05:10.364] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[16:05:10.364] MultisessionFuture started
[16:05:10.364] - Launch lazy future ... done
[16:05:10.364] run() for ‘MultisessionFuture’ ... done
[16:05:10.365] result() for ClusterFuture ...
[16:05:10.365] receiveMessageFromWorker() for ClusterFuture ...
[16:05:10.365] - Validating connection of MultisessionFuture
[16:05:10.412] - received message: FutureResult
[16:05:10.412] - Received FutureResult
[16:05:10.412] - Erased future from FutureRegistry
[16:05:10.413] result() for ClusterFuture ...
[16:05:10.413] - result already collected: FutureResult
[16:05:10.413] result() for ClusterFuture ... done
[16:05:10.413] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:10.413] result() for ClusterFuture ... done
[16:05:10.413] result() for ClusterFuture ...
[16:05:10.413] - result already collected: FutureResult
[16:05:10.413] result() for ClusterFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:10.414] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:10.414] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:10.416] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:10.416] Searching for globals ... DONE
[16:05:10.416] Resolving globals: TRUE
[16:05:10.416] Resolving any globals that are futures ...
[16:05:10.416] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:10.417] Resolving any globals that are futures ... DONE
[16:05:10.417] Resolving futures part of globals (recursively) ...
[16:05:10.417] resolve() on list ...
[16:05:10.417]  recursive: 99
[16:05:10.417]  length: 2
[16:05:10.417]  elements: ‘a’, ‘ii’
[16:05:10.418]  length: 1 (resolved future 1)
[16:05:10.418]  length: 0 (resolved future 2)
[16:05:10.418] resolve() on list ... DONE
[16:05:10.418] - globals: [2] ‘a’, ‘ii’
[16:05:10.418] Resolving futures part of globals (recursively) ... DONE
[16:05:10.418] The total size of the 2 globals is 112 bytes (112 bytes)
[16:05:10.421] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:05:10.421] - globals: [2] ‘a’, ‘ii’
[16:05:10.421] 
[16:05:10.421] getGlobalsAndPackages() ... DONE
[16:05:10.421] run() for ‘Future’ ...
[16:05:10.421] - state: ‘created’
[16:05:10.421] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:10.436] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:10.436] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:10.436]   - Field: ‘node’
[16:05:10.436]   - Field: ‘label’
[16:05:10.436]   - Field: ‘local’
[16:05:10.437]   - Field: ‘owner’
[16:05:10.437]   - Field: ‘envir’
[16:05:10.437]   - Field: ‘workers’
[16:05:10.437]   - Field: ‘packages’
[16:05:10.437]   - Field: ‘gc’
[16:05:10.437]   - Field: ‘conditions’
[16:05:10.437]   - Field: ‘persistent’
[16:05:10.437]   - Field: ‘expr’
[16:05:10.437]   - Field: ‘uuid’
[16:05:10.437]   - Field: ‘seed’
[16:05:10.437]   - Field: ‘version’
[16:05:10.438]   - Field: ‘result’
[16:05:10.438]   - Field: ‘asynchronous’
[16:05:10.438]   - Field: ‘calls’
[16:05:10.438]   - Field: ‘globals’
[16:05:10.438]   - Field: ‘stdout’
[16:05:10.438]   - Field: ‘earlySignal’
[16:05:10.438]   - Field: ‘lazy’
[16:05:10.438]   - Field: ‘state’
[16:05:10.438] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:10.438] - Launch lazy future ...
[16:05:10.439] Packages needed by the future expression (n = 0): <none>
[16:05:10.439] Packages needed by future strategies (n = 0): <none>
[16:05:10.439] {
[16:05:10.439]     {
[16:05:10.439]         {
[16:05:10.439]             ...future.startTime <- base::Sys.time()
[16:05:10.439]             {
[16:05:10.439]                 {
[16:05:10.439]                   {
[16:05:10.439]                     {
[16:05:10.439]                       base::local({
[16:05:10.439]                         has_future <- base::requireNamespace("future", 
[16:05:10.439]                           quietly = TRUE)
[16:05:10.439]                         if (has_future) {
[16:05:10.439]                           ns <- base::getNamespace("future")
[16:05:10.439]                           version <- ns[[".package"]][["version"]]
[16:05:10.439]                           if (is.null(version)) 
[16:05:10.439]                             version <- utils::packageVersion("future")
[16:05:10.439]                         }
[16:05:10.439]                         else {
[16:05:10.439]                           version <- NULL
[16:05:10.439]                         }
[16:05:10.439]                         if (!has_future || version < "1.8.0") {
[16:05:10.439]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:10.439]                             "", base::R.version$version.string), 
[16:05:10.439]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:10.439]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:10.439]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:10.439]                               "release", "version")], collapse = " "), 
[16:05:10.439]                             hostname = base::Sys.info()[["nodename"]])
[16:05:10.439]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:10.439]                             info)
[16:05:10.439]                           info <- base::paste(info, collapse = "; ")
[16:05:10.439]                           if (!has_future) {
[16:05:10.439]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:10.439]                               info)
[16:05:10.439]                           }
[16:05:10.439]                           else {
[16:05:10.439]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:10.439]                               info, version)
[16:05:10.439]                           }
[16:05:10.439]                           base::stop(msg)
[16:05:10.439]                         }
[16:05:10.439]                       })
[16:05:10.439]                     }
[16:05:10.439]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:10.439]                     base::options(mc.cores = 1L)
[16:05:10.439]                   }
[16:05:10.439]                   options(future.plan = NULL)
[16:05:10.439]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.439]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:10.439]                 }
[16:05:10.439]                 ...future.workdir <- getwd()
[16:05:10.439]             }
[16:05:10.439]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:10.439]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:10.439]         }
[16:05:10.439]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:10.439]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:10.439]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:10.439]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:10.439]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:10.439]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:10.439]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:10.439]             base::names(...future.oldOptions))
[16:05:10.439]     }
[16:05:10.439]     if (FALSE) {
[16:05:10.439]     }
[16:05:10.439]     else {
[16:05:10.439]         if (TRUE) {
[16:05:10.439]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:10.439]                 open = "w")
[16:05:10.439]         }
[16:05:10.439]         else {
[16:05:10.439]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:10.439]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:10.439]         }
[16:05:10.439]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:10.439]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:10.439]             base::sink(type = "output", split = FALSE)
[16:05:10.439]             base::close(...future.stdout)
[16:05:10.439]         }, add = TRUE)
[16:05:10.439]     }
[16:05:10.439]     ...future.frame <- base::sys.nframe()
[16:05:10.439]     ...future.conditions <- base::list()
[16:05:10.439]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:10.439]     if (FALSE) {
[16:05:10.439]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:10.439]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:10.439]     }
[16:05:10.439]     ...future.result <- base::tryCatch({
[16:05:10.439]         base::withCallingHandlers({
[16:05:10.439]             ...future.value <- base::withVisible(base::local({
[16:05:10.439]                 ...future.makeSendCondition <- base::local({
[16:05:10.439]                   sendCondition <- NULL
[16:05:10.439]                   function(frame = 1L) {
[16:05:10.439]                     if (is.function(sendCondition)) 
[16:05:10.439]                       return(sendCondition)
[16:05:10.439]                     ns <- getNamespace("parallel")
[16:05:10.439]                     if (exists("sendData", mode = "function", 
[16:05:10.439]                       envir = ns)) {
[16:05:10.439]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:10.439]                         envir = ns)
[16:05:10.439]                       envir <- sys.frame(frame)
[16:05:10.439]                       master <- NULL
[16:05:10.439]                       while (!identical(envir, .GlobalEnv) && 
[16:05:10.439]                         !identical(envir, emptyenv())) {
[16:05:10.439]                         if (exists("master", mode = "list", envir = envir, 
[16:05:10.439]                           inherits = FALSE)) {
[16:05:10.439]                           master <- get("master", mode = "list", 
[16:05:10.439]                             envir = envir, inherits = FALSE)
[16:05:10.439]                           if (inherits(master, c("SOCKnode", 
[16:05:10.439]                             "SOCK0node"))) {
[16:05:10.439]                             sendCondition <<- function(cond) {
[16:05:10.439]                               data <- list(type = "VALUE", value = cond, 
[16:05:10.439]                                 success = TRUE)
[16:05:10.439]                               parallel_sendData(master, data)
[16:05:10.439]                             }
[16:05:10.439]                             return(sendCondition)
[16:05:10.439]                           }
[16:05:10.439]                         }
[16:05:10.439]                         frame <- frame + 1L
[16:05:10.439]                         envir <- sys.frame(frame)
[16:05:10.439]                       }
[16:05:10.439]                     }
[16:05:10.439]                     sendCondition <<- function(cond) NULL
[16:05:10.439]                   }
[16:05:10.439]                 })
[16:05:10.439]                 withCallingHandlers({
[16:05:10.439]                   {
[16:05:10.439]                     b <- a * ii
[16:05:10.439]                     a <- 0
[16:05:10.439]                     b
[16:05:10.439]                   }
[16:05:10.439]                 }, immediateCondition = function(cond) {
[16:05:10.439]                   sendCondition <- ...future.makeSendCondition()
[16:05:10.439]                   sendCondition(cond)
[16:05:10.439]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.439]                   {
[16:05:10.439]                     inherits <- base::inherits
[16:05:10.439]                     invokeRestart <- base::invokeRestart
[16:05:10.439]                     is.null <- base::is.null
[16:05:10.439]                     muffled <- FALSE
[16:05:10.439]                     if (inherits(cond, "message")) {
[16:05:10.439]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:10.439]                       if (muffled) 
[16:05:10.439]                         invokeRestart("muffleMessage")
[16:05:10.439]                     }
[16:05:10.439]                     else if (inherits(cond, "warning")) {
[16:05:10.439]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:10.439]                       if (muffled) 
[16:05:10.439]                         invokeRestart("muffleWarning")
[16:05:10.439]                     }
[16:05:10.439]                     else if (inherits(cond, "condition")) {
[16:05:10.439]                       if (!is.null(pattern)) {
[16:05:10.439]                         computeRestarts <- base::computeRestarts
[16:05:10.439]                         grepl <- base::grepl
[16:05:10.439]                         restarts <- computeRestarts(cond)
[16:05:10.439]                         for (restart in restarts) {
[16:05:10.439]                           name <- restart$name
[16:05:10.439]                           if (is.null(name)) 
[16:05:10.439]                             next
[16:05:10.439]                           if (!grepl(pattern, name)) 
[16:05:10.439]                             next
[16:05:10.439]                           invokeRestart(restart)
[16:05:10.439]                           muffled <- TRUE
[16:05:10.439]                           break
[16:05:10.439]                         }
[16:05:10.439]                       }
[16:05:10.439]                     }
[16:05:10.439]                     invisible(muffled)
[16:05:10.439]                   }
[16:05:10.439]                   muffleCondition(cond)
[16:05:10.439]                 })
[16:05:10.439]             }))
[16:05:10.439]             future::FutureResult(value = ...future.value$value, 
[16:05:10.439]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.439]                   ...future.rng), globalenv = if (FALSE) 
[16:05:10.439]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:10.439]                     ...future.globalenv.names))
[16:05:10.439]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:10.439]         }, condition = base::local({
[16:05:10.439]             c <- base::c
[16:05:10.439]             inherits <- base::inherits
[16:05:10.439]             invokeRestart <- base::invokeRestart
[16:05:10.439]             length <- base::length
[16:05:10.439]             list <- base::list
[16:05:10.439]             seq.int <- base::seq.int
[16:05:10.439]             signalCondition <- base::signalCondition
[16:05:10.439]             sys.calls <- base::sys.calls
[16:05:10.439]             `[[` <- base::`[[`
[16:05:10.439]             `+` <- base::`+`
[16:05:10.439]             `<<-` <- base::`<<-`
[16:05:10.439]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:10.439]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:10.439]                   3L)]
[16:05:10.439]             }
[16:05:10.439]             function(cond) {
[16:05:10.439]                 is_error <- inherits(cond, "error")
[16:05:10.439]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:10.439]                   NULL)
[16:05:10.439]                 if (is_error) {
[16:05:10.439]                   sessionInformation <- function() {
[16:05:10.439]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:10.439]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:10.439]                       search = base::search(), system = base::Sys.info())
[16:05:10.439]                   }
[16:05:10.439]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.439]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:10.439]                     cond$call), session = sessionInformation(), 
[16:05:10.439]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:10.439]                   signalCondition(cond)
[16:05:10.439]                 }
[16:05:10.439]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:10.439]                 "immediateCondition"))) {
[16:05:10.439]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:10.439]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.439]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:10.439]                   if (TRUE && !signal) {
[16:05:10.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.439]                     {
[16:05:10.439]                       inherits <- base::inherits
[16:05:10.439]                       invokeRestart <- base::invokeRestart
[16:05:10.439]                       is.null <- base::is.null
[16:05:10.439]                       muffled <- FALSE
[16:05:10.439]                       if (inherits(cond, "message")) {
[16:05:10.439]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.439]                         if (muffled) 
[16:05:10.439]                           invokeRestart("muffleMessage")
[16:05:10.439]                       }
[16:05:10.439]                       else if (inherits(cond, "warning")) {
[16:05:10.439]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.439]                         if (muffled) 
[16:05:10.439]                           invokeRestart("muffleWarning")
[16:05:10.439]                       }
[16:05:10.439]                       else if (inherits(cond, "condition")) {
[16:05:10.439]                         if (!is.null(pattern)) {
[16:05:10.439]                           computeRestarts <- base::computeRestarts
[16:05:10.439]                           grepl <- base::grepl
[16:05:10.439]                           restarts <- computeRestarts(cond)
[16:05:10.439]                           for (restart in restarts) {
[16:05:10.439]                             name <- restart$name
[16:05:10.439]                             if (is.null(name)) 
[16:05:10.439]                               next
[16:05:10.439]                             if (!grepl(pattern, name)) 
[16:05:10.439]                               next
[16:05:10.439]                             invokeRestart(restart)
[16:05:10.439]                             muffled <- TRUE
[16:05:10.439]                             break
[16:05:10.439]                           }
[16:05:10.439]                         }
[16:05:10.439]                       }
[16:05:10.439]                       invisible(muffled)
[16:05:10.439]                     }
[16:05:10.439]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.439]                   }
[16:05:10.439]                 }
[16:05:10.439]                 else {
[16:05:10.439]                   if (TRUE) {
[16:05:10.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.439]                     {
[16:05:10.439]                       inherits <- base::inherits
[16:05:10.439]                       invokeRestart <- base::invokeRestart
[16:05:10.439]                       is.null <- base::is.null
[16:05:10.439]                       muffled <- FALSE
[16:05:10.439]                       if (inherits(cond, "message")) {
[16:05:10.439]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.439]                         if (muffled) 
[16:05:10.439]                           invokeRestart("muffleMessage")
[16:05:10.439]                       }
[16:05:10.439]                       else if (inherits(cond, "warning")) {
[16:05:10.439]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.439]                         if (muffled) 
[16:05:10.439]                           invokeRestart("muffleWarning")
[16:05:10.439]                       }
[16:05:10.439]                       else if (inherits(cond, "condition")) {
[16:05:10.439]                         if (!is.null(pattern)) {
[16:05:10.439]                           computeRestarts <- base::computeRestarts
[16:05:10.439]                           grepl <- base::grepl
[16:05:10.439]                           restarts <- computeRestarts(cond)
[16:05:10.439]                           for (restart in restarts) {
[16:05:10.439]                             name <- restart$name
[16:05:10.439]                             if (is.null(name)) 
[16:05:10.439]                               next
[16:05:10.439]                             if (!grepl(pattern, name)) 
[16:05:10.439]                               next
[16:05:10.439]                             invokeRestart(restart)
[16:05:10.439]                             muffled <- TRUE
[16:05:10.439]                             break
[16:05:10.439]                           }
[16:05:10.439]                         }
[16:05:10.439]                       }
[16:05:10.439]                       invisible(muffled)
[16:05:10.439]                     }
[16:05:10.439]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.439]                   }
[16:05:10.439]                 }
[16:05:10.439]             }
[16:05:10.439]         }))
[16:05:10.439]     }, error = function(ex) {
[16:05:10.439]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:10.439]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.439]                 ...future.rng), started = ...future.startTime, 
[16:05:10.439]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:10.439]             version = "1.8"), class = "FutureResult")
[16:05:10.439]     }, finally = {
[16:05:10.439]         if (!identical(...future.workdir, getwd())) 
[16:05:10.439]             setwd(...future.workdir)
[16:05:10.439]         {
[16:05:10.439]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:10.439]                 ...future.oldOptions$nwarnings <- NULL
[16:05:10.439]             }
[16:05:10.439]             base::options(...future.oldOptions)
[16:05:10.439]             if (.Platform$OS.type == "windows") {
[16:05:10.439]                 old_names <- names(...future.oldEnvVars)
[16:05:10.439]                 envs <- base::Sys.getenv()
[16:05:10.439]                 names <- names(envs)
[16:05:10.439]                 common <- intersect(names, old_names)
[16:05:10.439]                 added <- setdiff(names, old_names)
[16:05:10.439]                 removed <- setdiff(old_names, names)
[16:05:10.439]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:10.439]                   envs[common]]
[16:05:10.439]                 NAMES <- toupper(changed)
[16:05:10.439]                 args <- list()
[16:05:10.439]                 for (kk in seq_along(NAMES)) {
[16:05:10.439]                   name <- changed[[kk]]
[16:05:10.439]                   NAME <- NAMES[[kk]]
[16:05:10.439]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.439]                     next
[16:05:10.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.439]                 }
[16:05:10.439]                 NAMES <- toupper(added)
[16:05:10.439]                 for (kk in seq_along(NAMES)) {
[16:05:10.439]                   name <- added[[kk]]
[16:05:10.439]                   NAME <- NAMES[[kk]]
[16:05:10.439]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.439]                     next
[16:05:10.439]                   args[[name]] <- ""
[16:05:10.439]                 }
[16:05:10.439]                 NAMES <- toupper(removed)
[16:05:10.439]                 for (kk in seq_along(NAMES)) {
[16:05:10.439]                   name <- removed[[kk]]
[16:05:10.439]                   NAME <- NAMES[[kk]]
[16:05:10.439]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.439]                     next
[16:05:10.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.439]                 }
[16:05:10.439]                 if (length(args) > 0) 
[16:05:10.439]                   base::do.call(base::Sys.setenv, args = args)
[16:05:10.439]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:10.439]             }
[16:05:10.439]             else {
[16:05:10.439]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:10.439]             }
[16:05:10.439]             {
[16:05:10.439]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:10.439]                   0L) {
[16:05:10.439]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:10.439]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:10.439]                   base::options(opts)
[16:05:10.439]                 }
[16:05:10.439]                 {
[16:05:10.439]                   {
[16:05:10.439]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:10.439]                     NULL
[16:05:10.439]                   }
[16:05:10.439]                   options(future.plan = NULL)
[16:05:10.439]                   if (is.na(NA_character_)) 
[16:05:10.439]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.439]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:10.439]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:10.439]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:10.439]                     envir = parent.frame()) 
[16:05:10.439]                   {
[16:05:10.439]                     if (is.function(workers)) 
[16:05:10.439]                       workers <- workers()
[16:05:10.439]                     workers <- structure(as.integer(workers), 
[16:05:10.439]                       class = class(workers))
[16:05:10.439]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:10.439]                       workers >= 1)
[16:05:10.439]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:10.439]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:10.439]                     }
[16:05:10.439]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:10.439]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:10.439]                       envir = envir)
[16:05:10.439]                     if (!future$lazy) 
[16:05:10.439]                       future <- run(future)
[16:05:10.439]                     invisible(future)
[16:05:10.439]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:10.439]                 }
[16:05:10.439]             }
[16:05:10.439]         }
[16:05:10.439]     })
[16:05:10.439]     if (TRUE) {
[16:05:10.439]         base::sink(type = "output", split = FALSE)
[16:05:10.439]         if (TRUE) {
[16:05:10.439]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:10.439]         }
[16:05:10.439]         else {
[16:05:10.439]             ...future.result["stdout"] <- base::list(NULL)
[16:05:10.439]         }
[16:05:10.439]         base::close(...future.stdout)
[16:05:10.439]         ...future.stdout <- NULL
[16:05:10.439]     }
[16:05:10.439]     ...future.result$conditions <- ...future.conditions
[16:05:10.439]     ...future.result$finished <- base::Sys.time()
[16:05:10.439]     ...future.result
[16:05:10.439] }
[16:05:10.442] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[16:05:10.442] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[16:05:10.442] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[16:05:10.442] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[16:05:10.443] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[16:05:10.443] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[16:05:10.443] MultisessionFuture started
[16:05:10.443] - Launch lazy future ... done
[16:05:10.444] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:10.444] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:10.444] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:10.446] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:10.446] Searching for globals ... DONE
[16:05:10.446] Resolving globals: TRUE
[16:05:10.446] Resolving any globals that are futures ...
[16:05:10.446] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:10.447] Resolving any globals that are futures ... DONE
[16:05:10.447] Resolving futures part of globals (recursively) ...
[16:05:10.447] resolve() on list ...
[16:05:10.447]  recursive: 99
[16:05:10.447]  length: 2
[16:05:10.447]  elements: ‘a’, ‘ii’
[16:05:10.448]  length: 1 (resolved future 1)
[16:05:10.448]  length: 0 (resolved future 2)
[16:05:10.448] resolve() on list ... DONE
[16:05:10.448] - globals: [2] ‘a’, ‘ii’
[16:05:10.448] Resolving futures part of globals (recursively) ... DONE
[16:05:10.448] The total size of the 2 globals is 112 bytes (112 bytes)
[16:05:10.449] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:05:10.449] - globals: [2] ‘a’, ‘ii’
[16:05:10.449] 
[16:05:10.449] getGlobalsAndPackages() ... DONE
[16:05:10.449] run() for ‘Future’ ...
[16:05:10.449] - state: ‘created’
[16:05:10.449] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:10.464] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:10.464] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:10.464]   - Field: ‘node’
[16:05:10.464]   - Field: ‘label’
[16:05:10.464]   - Field: ‘local’
[16:05:10.464]   - Field: ‘owner’
[16:05:10.464]   - Field: ‘envir’
[16:05:10.464]   - Field: ‘workers’
[16:05:10.464]   - Field: ‘packages’
[16:05:10.465]   - Field: ‘gc’
[16:05:10.465]   - Field: ‘conditions’
[16:05:10.465]   - Field: ‘persistent’
[16:05:10.465]   - Field: ‘expr’
[16:05:10.465]   - Field: ‘uuid’
[16:05:10.465]   - Field: ‘seed’
[16:05:10.465]   - Field: ‘version’
[16:05:10.465]   - Field: ‘result’
[16:05:10.465]   - Field: ‘asynchronous’
[16:05:10.465]   - Field: ‘calls’
[16:05:10.465]   - Field: ‘globals’
[16:05:10.466]   - Field: ‘stdout’
[16:05:10.466]   - Field: ‘earlySignal’
[16:05:10.466]   - Field: ‘lazy’
[16:05:10.466]   - Field: ‘state’
[16:05:10.466] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:10.466] - Launch lazy future ...
[16:05:10.466] Packages needed by the future expression (n = 0): <none>
[16:05:10.466] Packages needed by future strategies (n = 0): <none>
[16:05:10.467] {
[16:05:10.467]     {
[16:05:10.467]         {
[16:05:10.467]             ...future.startTime <- base::Sys.time()
[16:05:10.467]             {
[16:05:10.467]                 {
[16:05:10.467]                   {
[16:05:10.467]                     {
[16:05:10.467]                       base::local({
[16:05:10.467]                         has_future <- base::requireNamespace("future", 
[16:05:10.467]                           quietly = TRUE)
[16:05:10.467]                         if (has_future) {
[16:05:10.467]                           ns <- base::getNamespace("future")
[16:05:10.467]                           version <- ns[[".package"]][["version"]]
[16:05:10.467]                           if (is.null(version)) 
[16:05:10.467]                             version <- utils::packageVersion("future")
[16:05:10.467]                         }
[16:05:10.467]                         else {
[16:05:10.467]                           version <- NULL
[16:05:10.467]                         }
[16:05:10.467]                         if (!has_future || version < "1.8.0") {
[16:05:10.467]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:10.467]                             "", base::R.version$version.string), 
[16:05:10.467]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:10.467]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:10.467]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:10.467]                               "release", "version")], collapse = " "), 
[16:05:10.467]                             hostname = base::Sys.info()[["nodename"]])
[16:05:10.467]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:10.467]                             info)
[16:05:10.467]                           info <- base::paste(info, collapse = "; ")
[16:05:10.467]                           if (!has_future) {
[16:05:10.467]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:10.467]                               info)
[16:05:10.467]                           }
[16:05:10.467]                           else {
[16:05:10.467]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:10.467]                               info, version)
[16:05:10.467]                           }
[16:05:10.467]                           base::stop(msg)
[16:05:10.467]                         }
[16:05:10.467]                       })
[16:05:10.467]                     }
[16:05:10.467]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:10.467]                     base::options(mc.cores = 1L)
[16:05:10.467]                   }
[16:05:10.467]                   options(future.plan = NULL)
[16:05:10.467]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.467]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:10.467]                 }
[16:05:10.467]                 ...future.workdir <- getwd()
[16:05:10.467]             }
[16:05:10.467]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:10.467]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:10.467]         }
[16:05:10.467]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:10.467]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:10.467]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:10.467]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:10.467]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:10.467]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:10.467]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:10.467]             base::names(...future.oldOptions))
[16:05:10.467]     }
[16:05:10.467]     if (FALSE) {
[16:05:10.467]     }
[16:05:10.467]     else {
[16:05:10.467]         if (TRUE) {
[16:05:10.467]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:10.467]                 open = "w")
[16:05:10.467]         }
[16:05:10.467]         else {
[16:05:10.467]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:10.467]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:10.467]         }
[16:05:10.467]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:10.467]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:10.467]             base::sink(type = "output", split = FALSE)
[16:05:10.467]             base::close(...future.stdout)
[16:05:10.467]         }, add = TRUE)
[16:05:10.467]     }
[16:05:10.467]     ...future.frame <- base::sys.nframe()
[16:05:10.467]     ...future.conditions <- base::list()
[16:05:10.467]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:10.467]     if (FALSE) {
[16:05:10.467]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:10.467]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:10.467]     }
[16:05:10.467]     ...future.result <- base::tryCatch({
[16:05:10.467]         base::withCallingHandlers({
[16:05:10.467]             ...future.value <- base::withVisible(base::local({
[16:05:10.467]                 ...future.makeSendCondition <- base::local({
[16:05:10.467]                   sendCondition <- NULL
[16:05:10.467]                   function(frame = 1L) {
[16:05:10.467]                     if (is.function(sendCondition)) 
[16:05:10.467]                       return(sendCondition)
[16:05:10.467]                     ns <- getNamespace("parallel")
[16:05:10.467]                     if (exists("sendData", mode = "function", 
[16:05:10.467]                       envir = ns)) {
[16:05:10.467]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:10.467]                         envir = ns)
[16:05:10.467]                       envir <- sys.frame(frame)
[16:05:10.467]                       master <- NULL
[16:05:10.467]                       while (!identical(envir, .GlobalEnv) && 
[16:05:10.467]                         !identical(envir, emptyenv())) {
[16:05:10.467]                         if (exists("master", mode = "list", envir = envir, 
[16:05:10.467]                           inherits = FALSE)) {
[16:05:10.467]                           master <- get("master", mode = "list", 
[16:05:10.467]                             envir = envir, inherits = FALSE)
[16:05:10.467]                           if (inherits(master, c("SOCKnode", 
[16:05:10.467]                             "SOCK0node"))) {
[16:05:10.467]                             sendCondition <<- function(cond) {
[16:05:10.467]                               data <- list(type = "VALUE", value = cond, 
[16:05:10.467]                                 success = TRUE)
[16:05:10.467]                               parallel_sendData(master, data)
[16:05:10.467]                             }
[16:05:10.467]                             return(sendCondition)
[16:05:10.467]                           }
[16:05:10.467]                         }
[16:05:10.467]                         frame <- frame + 1L
[16:05:10.467]                         envir <- sys.frame(frame)
[16:05:10.467]                       }
[16:05:10.467]                     }
[16:05:10.467]                     sendCondition <<- function(cond) NULL
[16:05:10.467]                   }
[16:05:10.467]                 })
[16:05:10.467]                 withCallingHandlers({
[16:05:10.467]                   {
[16:05:10.467]                     b <- a * ii
[16:05:10.467]                     a <- 0
[16:05:10.467]                     b
[16:05:10.467]                   }
[16:05:10.467]                 }, immediateCondition = function(cond) {
[16:05:10.467]                   sendCondition <- ...future.makeSendCondition()
[16:05:10.467]                   sendCondition(cond)
[16:05:10.467]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.467]                   {
[16:05:10.467]                     inherits <- base::inherits
[16:05:10.467]                     invokeRestart <- base::invokeRestart
[16:05:10.467]                     is.null <- base::is.null
[16:05:10.467]                     muffled <- FALSE
[16:05:10.467]                     if (inherits(cond, "message")) {
[16:05:10.467]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:10.467]                       if (muffled) 
[16:05:10.467]                         invokeRestart("muffleMessage")
[16:05:10.467]                     }
[16:05:10.467]                     else if (inherits(cond, "warning")) {
[16:05:10.467]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:10.467]                       if (muffled) 
[16:05:10.467]                         invokeRestart("muffleWarning")
[16:05:10.467]                     }
[16:05:10.467]                     else if (inherits(cond, "condition")) {
[16:05:10.467]                       if (!is.null(pattern)) {
[16:05:10.467]                         computeRestarts <- base::computeRestarts
[16:05:10.467]                         grepl <- base::grepl
[16:05:10.467]                         restarts <- computeRestarts(cond)
[16:05:10.467]                         for (restart in restarts) {
[16:05:10.467]                           name <- restart$name
[16:05:10.467]                           if (is.null(name)) 
[16:05:10.467]                             next
[16:05:10.467]                           if (!grepl(pattern, name)) 
[16:05:10.467]                             next
[16:05:10.467]                           invokeRestart(restart)
[16:05:10.467]                           muffled <- TRUE
[16:05:10.467]                           break
[16:05:10.467]                         }
[16:05:10.467]                       }
[16:05:10.467]                     }
[16:05:10.467]                     invisible(muffled)
[16:05:10.467]                   }
[16:05:10.467]                   muffleCondition(cond)
[16:05:10.467]                 })
[16:05:10.467]             }))
[16:05:10.467]             future::FutureResult(value = ...future.value$value, 
[16:05:10.467]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.467]                   ...future.rng), globalenv = if (FALSE) 
[16:05:10.467]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:10.467]                     ...future.globalenv.names))
[16:05:10.467]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:10.467]         }, condition = base::local({
[16:05:10.467]             c <- base::c
[16:05:10.467]             inherits <- base::inherits
[16:05:10.467]             invokeRestart <- base::invokeRestart
[16:05:10.467]             length <- base::length
[16:05:10.467]             list <- base::list
[16:05:10.467]             seq.int <- base::seq.int
[16:05:10.467]             signalCondition <- base::signalCondition
[16:05:10.467]             sys.calls <- base::sys.calls
[16:05:10.467]             `[[` <- base::`[[`
[16:05:10.467]             `+` <- base::`+`
[16:05:10.467]             `<<-` <- base::`<<-`
[16:05:10.467]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:10.467]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:10.467]                   3L)]
[16:05:10.467]             }
[16:05:10.467]             function(cond) {
[16:05:10.467]                 is_error <- inherits(cond, "error")
[16:05:10.467]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:10.467]                   NULL)
[16:05:10.467]                 if (is_error) {
[16:05:10.467]                   sessionInformation <- function() {
[16:05:10.467]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:10.467]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:10.467]                       search = base::search(), system = base::Sys.info())
[16:05:10.467]                   }
[16:05:10.467]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.467]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:10.467]                     cond$call), session = sessionInformation(), 
[16:05:10.467]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:10.467]                   signalCondition(cond)
[16:05:10.467]                 }
[16:05:10.467]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:10.467]                 "immediateCondition"))) {
[16:05:10.467]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:10.467]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.467]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:10.467]                   if (TRUE && !signal) {
[16:05:10.467]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.467]                     {
[16:05:10.467]                       inherits <- base::inherits
[16:05:10.467]                       invokeRestart <- base::invokeRestart
[16:05:10.467]                       is.null <- base::is.null
[16:05:10.467]                       muffled <- FALSE
[16:05:10.467]                       if (inherits(cond, "message")) {
[16:05:10.467]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.467]                         if (muffled) 
[16:05:10.467]                           invokeRestart("muffleMessage")
[16:05:10.467]                       }
[16:05:10.467]                       else if (inherits(cond, "warning")) {
[16:05:10.467]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.467]                         if (muffled) 
[16:05:10.467]                           invokeRestart("muffleWarning")
[16:05:10.467]                       }
[16:05:10.467]                       else if (inherits(cond, "condition")) {
[16:05:10.467]                         if (!is.null(pattern)) {
[16:05:10.467]                           computeRestarts <- base::computeRestarts
[16:05:10.467]                           grepl <- base::grepl
[16:05:10.467]                           restarts <- computeRestarts(cond)
[16:05:10.467]                           for (restart in restarts) {
[16:05:10.467]                             name <- restart$name
[16:05:10.467]                             if (is.null(name)) 
[16:05:10.467]                               next
[16:05:10.467]                             if (!grepl(pattern, name)) 
[16:05:10.467]                               next
[16:05:10.467]                             invokeRestart(restart)
[16:05:10.467]                             muffled <- TRUE
[16:05:10.467]                             break
[16:05:10.467]                           }
[16:05:10.467]                         }
[16:05:10.467]                       }
[16:05:10.467]                       invisible(muffled)
[16:05:10.467]                     }
[16:05:10.467]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.467]                   }
[16:05:10.467]                 }
[16:05:10.467]                 else {
[16:05:10.467]                   if (TRUE) {
[16:05:10.467]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.467]                     {
[16:05:10.467]                       inherits <- base::inherits
[16:05:10.467]                       invokeRestart <- base::invokeRestart
[16:05:10.467]                       is.null <- base::is.null
[16:05:10.467]                       muffled <- FALSE
[16:05:10.467]                       if (inherits(cond, "message")) {
[16:05:10.467]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.467]                         if (muffled) 
[16:05:10.467]                           invokeRestart("muffleMessage")
[16:05:10.467]                       }
[16:05:10.467]                       else if (inherits(cond, "warning")) {
[16:05:10.467]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.467]                         if (muffled) 
[16:05:10.467]                           invokeRestart("muffleWarning")
[16:05:10.467]                       }
[16:05:10.467]                       else if (inherits(cond, "condition")) {
[16:05:10.467]                         if (!is.null(pattern)) {
[16:05:10.467]                           computeRestarts <- base::computeRestarts
[16:05:10.467]                           grepl <- base::grepl
[16:05:10.467]                           restarts <- computeRestarts(cond)
[16:05:10.467]                           for (restart in restarts) {
[16:05:10.467]                             name <- restart$name
[16:05:10.467]                             if (is.null(name)) 
[16:05:10.467]                               next
[16:05:10.467]                             if (!grepl(pattern, name)) 
[16:05:10.467]                               next
[16:05:10.467]                             invokeRestart(restart)
[16:05:10.467]                             muffled <- TRUE
[16:05:10.467]                             break
[16:05:10.467]                           }
[16:05:10.467]                         }
[16:05:10.467]                       }
[16:05:10.467]                       invisible(muffled)
[16:05:10.467]                     }
[16:05:10.467]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.467]                   }
[16:05:10.467]                 }
[16:05:10.467]             }
[16:05:10.467]         }))
[16:05:10.467]     }, error = function(ex) {
[16:05:10.467]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:10.467]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.467]                 ...future.rng), started = ...future.startTime, 
[16:05:10.467]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:10.467]             version = "1.8"), class = "FutureResult")
[16:05:10.467]     }, finally = {
[16:05:10.467]         if (!identical(...future.workdir, getwd())) 
[16:05:10.467]             setwd(...future.workdir)
[16:05:10.467]         {
[16:05:10.467]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:10.467]                 ...future.oldOptions$nwarnings <- NULL
[16:05:10.467]             }
[16:05:10.467]             base::options(...future.oldOptions)
[16:05:10.467]             if (.Platform$OS.type == "windows") {
[16:05:10.467]                 old_names <- names(...future.oldEnvVars)
[16:05:10.467]                 envs <- base::Sys.getenv()
[16:05:10.467]                 names <- names(envs)
[16:05:10.467]                 common <- intersect(names, old_names)
[16:05:10.467]                 added <- setdiff(names, old_names)
[16:05:10.467]                 removed <- setdiff(old_names, names)
[16:05:10.467]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:10.467]                   envs[common]]
[16:05:10.467]                 NAMES <- toupper(changed)
[16:05:10.467]                 args <- list()
[16:05:10.467]                 for (kk in seq_along(NAMES)) {
[16:05:10.467]                   name <- changed[[kk]]
[16:05:10.467]                   NAME <- NAMES[[kk]]
[16:05:10.467]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.467]                     next
[16:05:10.467]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.467]                 }
[16:05:10.467]                 NAMES <- toupper(added)
[16:05:10.467]                 for (kk in seq_along(NAMES)) {
[16:05:10.467]                   name <- added[[kk]]
[16:05:10.467]                   NAME <- NAMES[[kk]]
[16:05:10.467]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.467]                     next
[16:05:10.467]                   args[[name]] <- ""
[16:05:10.467]                 }
[16:05:10.467]                 NAMES <- toupper(removed)
[16:05:10.467]                 for (kk in seq_along(NAMES)) {
[16:05:10.467]                   name <- removed[[kk]]
[16:05:10.467]                   NAME <- NAMES[[kk]]
[16:05:10.467]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.467]                     next
[16:05:10.467]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.467]                 }
[16:05:10.467]                 if (length(args) > 0) 
[16:05:10.467]                   base::do.call(base::Sys.setenv, args = args)
[16:05:10.467]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:10.467]             }
[16:05:10.467]             else {
[16:05:10.467]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:10.467]             }
[16:05:10.467]             {
[16:05:10.467]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:10.467]                   0L) {
[16:05:10.467]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:10.467]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:10.467]                   base::options(opts)
[16:05:10.467]                 }
[16:05:10.467]                 {
[16:05:10.467]                   {
[16:05:10.467]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:10.467]                     NULL
[16:05:10.467]                   }
[16:05:10.467]                   options(future.plan = NULL)
[16:05:10.467]                   if (is.na(NA_character_)) 
[16:05:10.467]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.467]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:10.467]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:10.467]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:10.467]                     envir = parent.frame()) 
[16:05:10.467]                   {
[16:05:10.467]                     if (is.function(workers)) 
[16:05:10.467]                       workers <- workers()
[16:05:10.467]                     workers <- structure(as.integer(workers), 
[16:05:10.467]                       class = class(workers))
[16:05:10.467]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:10.467]                       workers >= 1)
[16:05:10.467]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:10.467]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:10.467]                     }
[16:05:10.467]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:10.467]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:10.467]                       envir = envir)
[16:05:10.467]                     if (!future$lazy) 
[16:05:10.467]                       future <- run(future)
[16:05:10.467]                     invisible(future)
[16:05:10.467]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:10.467]                 }
[16:05:10.467]             }
[16:05:10.467]         }
[16:05:10.467]     })
[16:05:10.467]     if (TRUE) {
[16:05:10.467]         base::sink(type = "output", split = FALSE)
[16:05:10.467]         if (TRUE) {
[16:05:10.467]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:10.467]         }
[16:05:10.467]         else {
[16:05:10.467]             ...future.result["stdout"] <- base::list(NULL)
[16:05:10.467]         }
[16:05:10.467]         base::close(...future.stdout)
[16:05:10.467]         ...future.stdout <- NULL
[16:05:10.467]     }
[16:05:10.467]     ...future.result$conditions <- ...future.conditions
[16:05:10.467]     ...future.result$finished <- base::Sys.time()
[16:05:10.467]     ...future.result
[16:05:10.467] }
[16:05:10.469] Poll #1 (0): usedNodes() = 2, workers = 2
[16:05:10.480] receiveMessageFromWorker() for ClusterFuture ...
[16:05:10.480] - Validating connection of MultisessionFuture
[16:05:10.480] - received message: FutureResult
[16:05:10.480] - Received FutureResult
[16:05:10.481] - Erased future from FutureRegistry
[16:05:10.481] result() for ClusterFuture ...
[16:05:10.481] - result already collected: FutureResult
[16:05:10.481] result() for ClusterFuture ... done
[16:05:10.481] signalConditions() ...
[16:05:10.481]  - include = ‘immediateCondition’
[16:05:10.481]  - exclude = 
[16:05:10.481]  - resignal = FALSE
[16:05:10.481]  - Number of conditions: 1
[16:05:10.481] signalConditions() ... done
[16:05:10.482] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:10.482] result() for ClusterFuture ...
[16:05:10.482] - result already collected: FutureResult
[16:05:10.482] result() for ClusterFuture ... done
[16:05:10.482] result() for ClusterFuture ...
[16:05:10.482] - result already collected: FutureResult
[16:05:10.482] result() for ClusterFuture ... done
[16:05:10.482] signalConditions() ...
[16:05:10.482]  - include = ‘immediateCondition’
[16:05:10.482]  - exclude = 
[16:05:10.482]  - resignal = FALSE
[16:05:10.483]  - Number of conditions: 1
[16:05:10.483] signalConditions() ... done
[16:05:10.483] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[16:05:10.484] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:05:10.484] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:05:10.484] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:05:10.484] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:05:10.484] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[16:05:10.485] MultisessionFuture started
[16:05:10.485] - Launch lazy future ... done
[16:05:10.485] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:10.486] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:10.486] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:10.488] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:10.488] Searching for globals ... DONE
[16:05:10.488] Resolving globals: TRUE
[16:05:10.488] Resolving any globals that are futures ...
[16:05:10.488] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:10.488] Resolving any globals that are futures ... DONE
[16:05:10.489] Resolving futures part of globals (recursively) ...
[16:05:10.489] resolve() on list ...
[16:05:10.489]  recursive: 99
[16:05:10.489]  length: 2
[16:05:10.489]  elements: ‘a’, ‘ii’
[16:05:10.489]  length: 1 (resolved future 1)
[16:05:10.490]  length: 0 (resolved future 2)
[16:05:10.490] resolve() on list ... DONE
[16:05:10.490] - globals: [2] ‘a’, ‘ii’
[16:05:10.490] Resolving futures part of globals (recursively) ... DONE
[16:05:10.490] The total size of the 2 globals is 112 bytes (112 bytes)
[16:05:10.490] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:05:10.490] - globals: [2] ‘a’, ‘ii’
[16:05:10.491] 
[16:05:10.491] getGlobalsAndPackages() ... DONE
[16:05:10.491] run() for ‘Future’ ...
[16:05:10.491] - state: ‘created’
[16:05:10.491] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:10.505] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:10.505] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:10.505]   - Field: ‘node’
[16:05:10.506]   - Field: ‘label’
[16:05:10.506]   - Field: ‘local’
[16:05:10.506]   - Field: ‘owner’
[16:05:10.506]   - Field: ‘envir’
[16:05:10.506]   - Field: ‘workers’
[16:05:10.506]   - Field: ‘packages’
[16:05:10.506]   - Field: ‘gc’
[16:05:10.506]   - Field: ‘conditions’
[16:05:10.506]   - Field: ‘persistent’
[16:05:10.506]   - Field: ‘expr’
[16:05:10.507]   - Field: ‘uuid’
[16:05:10.507]   - Field: ‘seed’
[16:05:10.507]   - Field: ‘version’
[16:05:10.507]   - Field: ‘result’
[16:05:10.507]   - Field: ‘asynchronous’
[16:05:10.507]   - Field: ‘calls’
[16:05:10.507]   - Field: ‘globals’
[16:05:10.507]   - Field: ‘stdout’
[16:05:10.507]   - Field: ‘earlySignal’
[16:05:10.507]   - Field: ‘lazy’
[16:05:10.508]   - Field: ‘state’
[16:05:10.508] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:10.508] - Launch lazy future ...
[16:05:10.508] Packages needed by the future expression (n = 0): <none>
[16:05:10.508] Packages needed by future strategies (n = 0): <none>
[16:05:10.509] {
[16:05:10.509]     {
[16:05:10.509]         {
[16:05:10.509]             ...future.startTime <- base::Sys.time()
[16:05:10.509]             {
[16:05:10.509]                 {
[16:05:10.509]                   {
[16:05:10.509]                     {
[16:05:10.509]                       base::local({
[16:05:10.509]                         has_future <- base::requireNamespace("future", 
[16:05:10.509]                           quietly = TRUE)
[16:05:10.509]                         if (has_future) {
[16:05:10.509]                           ns <- base::getNamespace("future")
[16:05:10.509]                           version <- ns[[".package"]][["version"]]
[16:05:10.509]                           if (is.null(version)) 
[16:05:10.509]                             version <- utils::packageVersion("future")
[16:05:10.509]                         }
[16:05:10.509]                         else {
[16:05:10.509]                           version <- NULL
[16:05:10.509]                         }
[16:05:10.509]                         if (!has_future || version < "1.8.0") {
[16:05:10.509]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:10.509]                             "", base::R.version$version.string), 
[16:05:10.509]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:10.509]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:10.509]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:10.509]                               "release", "version")], collapse = " "), 
[16:05:10.509]                             hostname = base::Sys.info()[["nodename"]])
[16:05:10.509]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:10.509]                             info)
[16:05:10.509]                           info <- base::paste(info, collapse = "; ")
[16:05:10.509]                           if (!has_future) {
[16:05:10.509]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:10.509]                               info)
[16:05:10.509]                           }
[16:05:10.509]                           else {
[16:05:10.509]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:10.509]                               info, version)
[16:05:10.509]                           }
[16:05:10.509]                           base::stop(msg)
[16:05:10.509]                         }
[16:05:10.509]                       })
[16:05:10.509]                     }
[16:05:10.509]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:10.509]                     base::options(mc.cores = 1L)
[16:05:10.509]                   }
[16:05:10.509]                   options(future.plan = NULL)
[16:05:10.509]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.509]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:10.509]                 }
[16:05:10.509]                 ...future.workdir <- getwd()
[16:05:10.509]             }
[16:05:10.509]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:10.509]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:10.509]         }
[16:05:10.509]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:10.509]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:10.509]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:10.509]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:10.509]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:10.509]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:10.509]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:10.509]             base::names(...future.oldOptions))
[16:05:10.509]     }
[16:05:10.509]     if (FALSE) {
[16:05:10.509]     }
[16:05:10.509]     else {
[16:05:10.509]         if (TRUE) {
[16:05:10.509]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:10.509]                 open = "w")
[16:05:10.509]         }
[16:05:10.509]         else {
[16:05:10.509]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:10.509]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:10.509]         }
[16:05:10.509]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:10.509]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:10.509]             base::sink(type = "output", split = FALSE)
[16:05:10.509]             base::close(...future.stdout)
[16:05:10.509]         }, add = TRUE)
[16:05:10.509]     }
[16:05:10.509]     ...future.frame <- base::sys.nframe()
[16:05:10.509]     ...future.conditions <- base::list()
[16:05:10.509]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:10.509]     if (FALSE) {
[16:05:10.509]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:10.509]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:10.509]     }
[16:05:10.509]     ...future.result <- base::tryCatch({
[16:05:10.509]         base::withCallingHandlers({
[16:05:10.509]             ...future.value <- base::withVisible(base::local({
[16:05:10.509]                 ...future.makeSendCondition <- base::local({
[16:05:10.509]                   sendCondition <- NULL
[16:05:10.509]                   function(frame = 1L) {
[16:05:10.509]                     if (is.function(sendCondition)) 
[16:05:10.509]                       return(sendCondition)
[16:05:10.509]                     ns <- getNamespace("parallel")
[16:05:10.509]                     if (exists("sendData", mode = "function", 
[16:05:10.509]                       envir = ns)) {
[16:05:10.509]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:10.509]                         envir = ns)
[16:05:10.509]                       envir <- sys.frame(frame)
[16:05:10.509]                       master <- NULL
[16:05:10.509]                       while (!identical(envir, .GlobalEnv) && 
[16:05:10.509]                         !identical(envir, emptyenv())) {
[16:05:10.509]                         if (exists("master", mode = "list", envir = envir, 
[16:05:10.509]                           inherits = FALSE)) {
[16:05:10.509]                           master <- get("master", mode = "list", 
[16:05:10.509]                             envir = envir, inherits = FALSE)
[16:05:10.509]                           if (inherits(master, c("SOCKnode", 
[16:05:10.509]                             "SOCK0node"))) {
[16:05:10.509]                             sendCondition <<- function(cond) {
[16:05:10.509]                               data <- list(type = "VALUE", value = cond, 
[16:05:10.509]                                 success = TRUE)
[16:05:10.509]                               parallel_sendData(master, data)
[16:05:10.509]                             }
[16:05:10.509]                             return(sendCondition)
[16:05:10.509]                           }
[16:05:10.509]                         }
[16:05:10.509]                         frame <- frame + 1L
[16:05:10.509]                         envir <- sys.frame(frame)
[16:05:10.509]                       }
[16:05:10.509]                     }
[16:05:10.509]                     sendCondition <<- function(cond) NULL
[16:05:10.509]                   }
[16:05:10.509]                 })
[16:05:10.509]                 withCallingHandlers({
[16:05:10.509]                   {
[16:05:10.509]                     b <- a * ii
[16:05:10.509]                     a <- 0
[16:05:10.509]                     b
[16:05:10.509]                   }
[16:05:10.509]                 }, immediateCondition = function(cond) {
[16:05:10.509]                   sendCondition <- ...future.makeSendCondition()
[16:05:10.509]                   sendCondition(cond)
[16:05:10.509]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.509]                   {
[16:05:10.509]                     inherits <- base::inherits
[16:05:10.509]                     invokeRestart <- base::invokeRestart
[16:05:10.509]                     is.null <- base::is.null
[16:05:10.509]                     muffled <- FALSE
[16:05:10.509]                     if (inherits(cond, "message")) {
[16:05:10.509]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:10.509]                       if (muffled) 
[16:05:10.509]                         invokeRestart("muffleMessage")
[16:05:10.509]                     }
[16:05:10.509]                     else if (inherits(cond, "warning")) {
[16:05:10.509]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:10.509]                       if (muffled) 
[16:05:10.509]                         invokeRestart("muffleWarning")
[16:05:10.509]                     }
[16:05:10.509]                     else if (inherits(cond, "condition")) {
[16:05:10.509]                       if (!is.null(pattern)) {
[16:05:10.509]                         computeRestarts <- base::computeRestarts
[16:05:10.509]                         grepl <- base::grepl
[16:05:10.509]                         restarts <- computeRestarts(cond)
[16:05:10.509]                         for (restart in restarts) {
[16:05:10.509]                           name <- restart$name
[16:05:10.509]                           if (is.null(name)) 
[16:05:10.509]                             next
[16:05:10.509]                           if (!grepl(pattern, name)) 
[16:05:10.509]                             next
[16:05:10.509]                           invokeRestart(restart)
[16:05:10.509]                           muffled <- TRUE
[16:05:10.509]                           break
[16:05:10.509]                         }
[16:05:10.509]                       }
[16:05:10.509]                     }
[16:05:10.509]                     invisible(muffled)
[16:05:10.509]                   }
[16:05:10.509]                   muffleCondition(cond)
[16:05:10.509]                 })
[16:05:10.509]             }))
[16:05:10.509]             future::FutureResult(value = ...future.value$value, 
[16:05:10.509]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.509]                   ...future.rng), globalenv = if (FALSE) 
[16:05:10.509]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:10.509]                     ...future.globalenv.names))
[16:05:10.509]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:10.509]         }, condition = base::local({
[16:05:10.509]             c <- base::c
[16:05:10.509]             inherits <- base::inherits
[16:05:10.509]             invokeRestart <- base::invokeRestart
[16:05:10.509]             length <- base::length
[16:05:10.509]             list <- base::list
[16:05:10.509]             seq.int <- base::seq.int
[16:05:10.509]             signalCondition <- base::signalCondition
[16:05:10.509]             sys.calls <- base::sys.calls
[16:05:10.509]             `[[` <- base::`[[`
[16:05:10.509]             `+` <- base::`+`
[16:05:10.509]             `<<-` <- base::`<<-`
[16:05:10.509]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:10.509]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:10.509]                   3L)]
[16:05:10.509]             }
[16:05:10.509]             function(cond) {
[16:05:10.509]                 is_error <- inherits(cond, "error")
[16:05:10.509]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:10.509]                   NULL)
[16:05:10.509]                 if (is_error) {
[16:05:10.509]                   sessionInformation <- function() {
[16:05:10.509]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:10.509]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:10.509]                       search = base::search(), system = base::Sys.info())
[16:05:10.509]                   }
[16:05:10.509]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.509]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:10.509]                     cond$call), session = sessionInformation(), 
[16:05:10.509]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:10.509]                   signalCondition(cond)
[16:05:10.509]                 }
[16:05:10.509]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:10.509]                 "immediateCondition"))) {
[16:05:10.509]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:10.509]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.509]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:10.509]                   if (TRUE && !signal) {
[16:05:10.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.509]                     {
[16:05:10.509]                       inherits <- base::inherits
[16:05:10.509]                       invokeRestart <- base::invokeRestart
[16:05:10.509]                       is.null <- base::is.null
[16:05:10.509]                       muffled <- FALSE
[16:05:10.509]                       if (inherits(cond, "message")) {
[16:05:10.509]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.509]                         if (muffled) 
[16:05:10.509]                           invokeRestart("muffleMessage")
[16:05:10.509]                       }
[16:05:10.509]                       else if (inherits(cond, "warning")) {
[16:05:10.509]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.509]                         if (muffled) 
[16:05:10.509]                           invokeRestart("muffleWarning")
[16:05:10.509]                       }
[16:05:10.509]                       else if (inherits(cond, "condition")) {
[16:05:10.509]                         if (!is.null(pattern)) {
[16:05:10.509]                           computeRestarts <- base::computeRestarts
[16:05:10.509]                           grepl <- base::grepl
[16:05:10.509]                           restarts <- computeRestarts(cond)
[16:05:10.509]                           for (restart in restarts) {
[16:05:10.509]                             name <- restart$name
[16:05:10.509]                             if (is.null(name)) 
[16:05:10.509]                               next
[16:05:10.509]                             if (!grepl(pattern, name)) 
[16:05:10.509]                               next
[16:05:10.509]                             invokeRestart(restart)
[16:05:10.509]                             muffled <- TRUE
[16:05:10.509]                             break
[16:05:10.509]                           }
[16:05:10.509]                         }
[16:05:10.509]                       }
[16:05:10.509]                       invisible(muffled)
[16:05:10.509]                     }
[16:05:10.509]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.509]                   }
[16:05:10.509]                 }
[16:05:10.509]                 else {
[16:05:10.509]                   if (TRUE) {
[16:05:10.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.509]                     {
[16:05:10.509]                       inherits <- base::inherits
[16:05:10.509]                       invokeRestart <- base::invokeRestart
[16:05:10.509]                       is.null <- base::is.null
[16:05:10.509]                       muffled <- FALSE
[16:05:10.509]                       if (inherits(cond, "message")) {
[16:05:10.509]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.509]                         if (muffled) 
[16:05:10.509]                           invokeRestart("muffleMessage")
[16:05:10.509]                       }
[16:05:10.509]                       else if (inherits(cond, "warning")) {
[16:05:10.509]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.509]                         if (muffled) 
[16:05:10.509]                           invokeRestart("muffleWarning")
[16:05:10.509]                       }
[16:05:10.509]                       else if (inherits(cond, "condition")) {
[16:05:10.509]                         if (!is.null(pattern)) {
[16:05:10.509]                           computeRestarts <- base::computeRestarts
[16:05:10.509]                           grepl <- base::grepl
[16:05:10.509]                           restarts <- computeRestarts(cond)
[16:05:10.509]                           for (restart in restarts) {
[16:05:10.509]                             name <- restart$name
[16:05:10.509]                             if (is.null(name)) 
[16:05:10.509]                               next
[16:05:10.509]                             if (!grepl(pattern, name)) 
[16:05:10.509]                               next
[16:05:10.509]                             invokeRestart(restart)
[16:05:10.509]                             muffled <- TRUE
[16:05:10.509]                             break
[16:05:10.509]                           }
[16:05:10.509]                         }
[16:05:10.509]                       }
[16:05:10.509]                       invisible(muffled)
[16:05:10.509]                     }
[16:05:10.509]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.509]                   }
[16:05:10.509]                 }
[16:05:10.509]             }
[16:05:10.509]         }))
[16:05:10.509]     }, error = function(ex) {
[16:05:10.509]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:10.509]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.509]                 ...future.rng), started = ...future.startTime, 
[16:05:10.509]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:10.509]             version = "1.8"), class = "FutureResult")
[16:05:10.509]     }, finally = {
[16:05:10.509]         if (!identical(...future.workdir, getwd())) 
[16:05:10.509]             setwd(...future.workdir)
[16:05:10.509]         {
[16:05:10.509]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:10.509]                 ...future.oldOptions$nwarnings <- NULL
[16:05:10.509]             }
[16:05:10.509]             base::options(...future.oldOptions)
[16:05:10.509]             if (.Platform$OS.type == "windows") {
[16:05:10.509]                 old_names <- names(...future.oldEnvVars)
[16:05:10.509]                 envs <- base::Sys.getenv()
[16:05:10.509]                 names <- names(envs)
[16:05:10.509]                 common <- intersect(names, old_names)
[16:05:10.509]                 added <- setdiff(names, old_names)
[16:05:10.509]                 removed <- setdiff(old_names, names)
[16:05:10.509]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:10.509]                   envs[common]]
[16:05:10.509]                 NAMES <- toupper(changed)
[16:05:10.509]                 args <- list()
[16:05:10.509]                 for (kk in seq_along(NAMES)) {
[16:05:10.509]                   name <- changed[[kk]]
[16:05:10.509]                   NAME <- NAMES[[kk]]
[16:05:10.509]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.509]                     next
[16:05:10.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.509]                 }
[16:05:10.509]                 NAMES <- toupper(added)
[16:05:10.509]                 for (kk in seq_along(NAMES)) {
[16:05:10.509]                   name <- added[[kk]]
[16:05:10.509]                   NAME <- NAMES[[kk]]
[16:05:10.509]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.509]                     next
[16:05:10.509]                   args[[name]] <- ""
[16:05:10.509]                 }
[16:05:10.509]                 NAMES <- toupper(removed)
[16:05:10.509]                 for (kk in seq_along(NAMES)) {
[16:05:10.509]                   name <- removed[[kk]]
[16:05:10.509]                   NAME <- NAMES[[kk]]
[16:05:10.509]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.509]                     next
[16:05:10.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.509]                 }
[16:05:10.509]                 if (length(args) > 0) 
[16:05:10.509]                   base::do.call(base::Sys.setenv, args = args)
[16:05:10.509]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:10.509]             }
[16:05:10.509]             else {
[16:05:10.509]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:10.509]             }
[16:05:10.509]             {
[16:05:10.509]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:10.509]                   0L) {
[16:05:10.509]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:10.509]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:10.509]                   base::options(opts)
[16:05:10.509]                 }
[16:05:10.509]                 {
[16:05:10.509]                   {
[16:05:10.509]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:10.509]                     NULL
[16:05:10.509]                   }
[16:05:10.509]                   options(future.plan = NULL)
[16:05:10.509]                   if (is.na(NA_character_)) 
[16:05:10.509]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.509]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:10.509]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:10.509]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:10.509]                     envir = parent.frame()) 
[16:05:10.509]                   {
[16:05:10.509]                     if (is.function(workers)) 
[16:05:10.509]                       workers <- workers()
[16:05:10.509]                     workers <- structure(as.integer(workers), 
[16:05:10.509]                       class = class(workers))
[16:05:10.509]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:10.509]                       workers >= 1)
[16:05:10.509]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:10.509]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:10.509]                     }
[16:05:10.509]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:10.509]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:10.509]                       envir = envir)
[16:05:10.509]                     if (!future$lazy) 
[16:05:10.509]                       future <- run(future)
[16:05:10.509]                     invisible(future)
[16:05:10.509]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:10.509]                 }
[16:05:10.509]             }
[16:05:10.509]         }
[16:05:10.509]     })
[16:05:10.509]     if (TRUE) {
[16:05:10.509]         base::sink(type = "output", split = FALSE)
[16:05:10.509]         if (TRUE) {
[16:05:10.509]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:10.509]         }
[16:05:10.509]         else {
[16:05:10.509]             ...future.result["stdout"] <- base::list(NULL)
[16:05:10.509]         }
[16:05:10.509]         base::close(...future.stdout)
[16:05:10.509]         ...future.stdout <- NULL
[16:05:10.509]     }
[16:05:10.509]     ...future.result$conditions <- ...future.conditions
[16:05:10.509]     ...future.result$finished <- base::Sys.time()
[16:05:10.509]     ...future.result
[16:05:10.509] }
[16:05:10.511] Poll #1 (0): usedNodes() = 2, workers = 2
[16:05:10.522] receiveMessageFromWorker() for ClusterFuture ...
[16:05:10.522] - Validating connection of MultisessionFuture
[16:05:10.522] - received message: FutureResult
[16:05:10.522] - Received FutureResult
[16:05:10.522] - Erased future from FutureRegistry
[16:05:10.522] result() for ClusterFuture ...
[16:05:10.522] - result already collected: FutureResult
[16:05:10.522] result() for ClusterFuture ... done
[16:05:10.523] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:10.523] result() for ClusterFuture ...
[16:05:10.523] - result already collected: FutureResult
[16:05:10.523] result() for ClusterFuture ... done
[16:05:10.523] result() for ClusterFuture ...
[16:05:10.523] - result already collected: FutureResult
[16:05:10.523] result() for ClusterFuture ... done
[16:05:10.524] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[16:05:10.524] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[16:05:10.525] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[16:05:10.525] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[16:05:10.525] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[16:05:10.525] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[16:05:10.526] MultisessionFuture started
[16:05:10.526] - Launch lazy future ... done
[16:05:10.526] run() for ‘MultisessionFuture’ ... done
[16:05:10.526] result() for ClusterFuture ...
[16:05:10.526] - result already collected: FutureResult
[16:05:10.526] result() for ClusterFuture ... done
[16:05:10.526] result() for ClusterFuture ...
[16:05:10.527] - result already collected: FutureResult
[16:05:10.527] result() for ClusterFuture ... done
[16:05:10.527] result() for ClusterFuture ...
[16:05:10.527] receiveMessageFromWorker() for ClusterFuture ...
[16:05:10.527] - Validating connection of MultisessionFuture
[16:05:10.532] - received message: FutureResult
[16:05:10.532] - Received FutureResult
[16:05:10.532] - Erased future from FutureRegistry
[16:05:10.532] result() for ClusterFuture ...
[16:05:10.532] - result already collected: FutureResult
[16:05:10.532] result() for ClusterFuture ... done
[16:05:10.533] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:10.533] result() for ClusterFuture ... done
[16:05:10.533] result() for ClusterFuture ...
[16:05:10.533] - result already collected: FutureResult
[16:05:10.533] result() for ClusterFuture ... done
[16:05:10.533] result() for ClusterFuture ...
[16:05:10.533] receiveMessageFromWorker() for ClusterFuture ...
[16:05:10.533] - Validating connection of MultisessionFuture
[16:05:10.572] - received message: FutureResult
[16:05:10.573] - Received FutureResult
[16:05:10.573] - Erased future from FutureRegistry
[16:05:10.573] result() for ClusterFuture ...
[16:05:10.573] - result already collected: FutureResult
[16:05:10.573] result() for ClusterFuture ... done
[16:05:10.573] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:10.573] result() for ClusterFuture ... done
[16:05:10.573] result() for ClusterFuture ...
[16:05:10.573] - result already collected: FutureResult
[16:05:10.573] result() for ClusterFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:10.574] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:10.574] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:10.576] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:10.576] Searching for globals ... DONE
[16:05:10.577] Resolving globals: TRUE
[16:05:10.577] Resolving any globals that are futures ...
[16:05:10.577] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:10.577] Resolving any globals that are futures ... DONE
[16:05:10.577] Resolving futures part of globals (recursively) ...
[16:05:10.577] resolve() on list ...
[16:05:10.578]  recursive: 99
[16:05:10.578]  length: 2
[16:05:10.578]  elements: ‘a’, ‘ii’
[16:05:10.578]  length: 1 (resolved future 1)
[16:05:10.578]  length: 0 (resolved future 2)
[16:05:10.578] resolve() on list ... DONE
[16:05:10.578] - globals: [2] ‘a’, ‘ii’
[16:05:10.578] Resolving futures part of globals (recursively) ... DONE
[16:05:10.578] The total size of the 2 globals is 112 bytes (112 bytes)
[16:05:10.579] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:05:10.579] - globals: [2] ‘a’, ‘ii’
[16:05:10.579] 
[16:05:10.579] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:10.580] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:10.580] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:10.582] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:10.582] Searching for globals ... DONE
[16:05:10.582] Resolving globals: TRUE
[16:05:10.582] Resolving any globals that are futures ...
[16:05:10.582] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:10.582] Resolving any globals that are futures ... DONE
[16:05:10.583] Resolving futures part of globals (recursively) ...
[16:05:10.583] resolve() on list ...
[16:05:10.583]  recursive: 99
[16:05:10.583]  length: 2
[16:05:10.583]  elements: ‘a’, ‘ii’
[16:05:10.583]  length: 1 (resolved future 1)
[16:05:10.583]  length: 0 (resolved future 2)
[16:05:10.583] resolve() on list ... DONE
[16:05:10.584] - globals: [2] ‘a’, ‘ii’
[16:05:10.584] Resolving futures part of globals (recursively) ... DONE
[16:05:10.584] The total size of the 2 globals is 112 bytes (112 bytes)
[16:05:10.584] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:05:10.584] - globals: [2] ‘a’, ‘ii’
[16:05:10.584] 
[16:05:10.585] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:10.585] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:10.585] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:10.587] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:10.587] Searching for globals ... DONE
[16:05:10.587] Resolving globals: TRUE
[16:05:10.587] Resolving any globals that are futures ...
[16:05:10.587] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:05:10.588] Resolving any globals that are futures ... DONE
[16:05:10.588] Resolving futures part of globals (recursively) ...
[16:05:10.588] resolve() on list ...
[16:05:10.588]  recursive: 99
[16:05:10.588]  length: 2
[16:05:10.588]  elements: ‘a’, ‘ii’
[16:05:10.588]  length: 1 (resolved future 1)
[16:05:10.589]  length: 0 (resolved future 2)
[16:05:10.589] resolve() on list ... DONE
[16:05:10.589] - globals: [2] ‘a’, ‘ii’
[16:05:10.589] Resolving futures part of globals (recursively) ... DONE
[16:05:10.589] The total size of the 2 globals is 112 bytes (112 bytes)
[16:05:10.589] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:05:10.589] - globals: [2] ‘a’, ‘ii’
[16:05:10.590] 
[16:05:10.590] getGlobalsAndPackages() ... DONE
[16:05:10.590] run() for ‘Future’ ...
[16:05:10.590] - state: ‘created’
[16:05:10.590] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:10.605] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:10.605] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:10.605]   - Field: ‘node’
[16:05:10.605]   - Field: ‘label’
[16:05:10.605]   - Field: ‘local’
[16:05:10.605]   - Field: ‘owner’
[16:05:10.605]   - Field: ‘envir’
[16:05:10.605]   - Field: ‘workers’
[16:05:10.605]   - Field: ‘packages’
[16:05:10.606]   - Field: ‘gc’
[16:05:10.606]   - Field: ‘conditions’
[16:05:10.606]   - Field: ‘persistent’
[16:05:10.606]   - Field: ‘expr’
[16:05:10.606]   - Field: ‘uuid’
[16:05:10.606]   - Field: ‘seed’
[16:05:10.606]   - Field: ‘version’
[16:05:10.606]   - Field: ‘result’
[16:05:10.606]   - Field: ‘asynchronous’
[16:05:10.606]   - Field: ‘calls’
[16:05:10.606]   - Field: ‘globals’
[16:05:10.607]   - Field: ‘stdout’
[16:05:10.607]   - Field: ‘earlySignal’
[16:05:10.607]   - Field: ‘lazy’
[16:05:10.607]   - Field: ‘state’
[16:05:10.609] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:10.609] - Launch lazy future ...
[16:05:10.610] Packages needed by the future expression (n = 0): <none>
[16:05:10.610] Packages needed by future strategies (n = 0): <none>
[16:05:10.610] {
[16:05:10.610]     {
[16:05:10.610]         {
[16:05:10.610]             ...future.startTime <- base::Sys.time()
[16:05:10.610]             {
[16:05:10.610]                 {
[16:05:10.610]                   {
[16:05:10.610]                     {
[16:05:10.610]                       base::local({
[16:05:10.610]                         has_future <- base::requireNamespace("future", 
[16:05:10.610]                           quietly = TRUE)
[16:05:10.610]                         if (has_future) {
[16:05:10.610]                           ns <- base::getNamespace("future")
[16:05:10.610]                           version <- ns[[".package"]][["version"]]
[16:05:10.610]                           if (is.null(version)) 
[16:05:10.610]                             version <- utils::packageVersion("future")
[16:05:10.610]                         }
[16:05:10.610]                         else {
[16:05:10.610]                           version <- NULL
[16:05:10.610]                         }
[16:05:10.610]                         if (!has_future || version < "1.8.0") {
[16:05:10.610]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:10.610]                             "", base::R.version$version.string), 
[16:05:10.610]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:10.610]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:10.610]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:10.610]                               "release", "version")], collapse = " "), 
[16:05:10.610]                             hostname = base::Sys.info()[["nodename"]])
[16:05:10.610]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:10.610]                             info)
[16:05:10.610]                           info <- base::paste(info, collapse = "; ")
[16:05:10.610]                           if (!has_future) {
[16:05:10.610]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:10.610]                               info)
[16:05:10.610]                           }
[16:05:10.610]                           else {
[16:05:10.610]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:10.610]                               info, version)
[16:05:10.610]                           }
[16:05:10.610]                           base::stop(msg)
[16:05:10.610]                         }
[16:05:10.610]                       })
[16:05:10.610]                     }
[16:05:10.610]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:10.610]                     base::options(mc.cores = 1L)
[16:05:10.610]                   }
[16:05:10.610]                   options(future.plan = NULL)
[16:05:10.610]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.610]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:10.610]                 }
[16:05:10.610]                 ...future.workdir <- getwd()
[16:05:10.610]             }
[16:05:10.610]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:10.610]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:10.610]         }
[16:05:10.610]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:10.610]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:10.610]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:10.610]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:10.610]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:10.610]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:10.610]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:10.610]             base::names(...future.oldOptions))
[16:05:10.610]     }
[16:05:10.610]     if (FALSE) {
[16:05:10.610]     }
[16:05:10.610]     else {
[16:05:10.610]         if (TRUE) {
[16:05:10.610]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:10.610]                 open = "w")
[16:05:10.610]         }
[16:05:10.610]         else {
[16:05:10.610]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:10.610]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:10.610]         }
[16:05:10.610]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:10.610]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:10.610]             base::sink(type = "output", split = FALSE)
[16:05:10.610]             base::close(...future.stdout)
[16:05:10.610]         }, add = TRUE)
[16:05:10.610]     }
[16:05:10.610]     ...future.frame <- base::sys.nframe()
[16:05:10.610]     ...future.conditions <- base::list()
[16:05:10.610]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:10.610]     if (FALSE) {
[16:05:10.610]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:10.610]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:10.610]     }
[16:05:10.610]     ...future.result <- base::tryCatch({
[16:05:10.610]         base::withCallingHandlers({
[16:05:10.610]             ...future.value <- base::withVisible(base::local({
[16:05:10.610]                 ...future.makeSendCondition <- base::local({
[16:05:10.610]                   sendCondition <- NULL
[16:05:10.610]                   function(frame = 1L) {
[16:05:10.610]                     if (is.function(sendCondition)) 
[16:05:10.610]                       return(sendCondition)
[16:05:10.610]                     ns <- getNamespace("parallel")
[16:05:10.610]                     if (exists("sendData", mode = "function", 
[16:05:10.610]                       envir = ns)) {
[16:05:10.610]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:10.610]                         envir = ns)
[16:05:10.610]                       envir <- sys.frame(frame)
[16:05:10.610]                       master <- NULL
[16:05:10.610]                       while (!identical(envir, .GlobalEnv) && 
[16:05:10.610]                         !identical(envir, emptyenv())) {
[16:05:10.610]                         if (exists("master", mode = "list", envir = envir, 
[16:05:10.610]                           inherits = FALSE)) {
[16:05:10.610]                           master <- get("master", mode = "list", 
[16:05:10.610]                             envir = envir, inherits = FALSE)
[16:05:10.610]                           if (inherits(master, c("SOCKnode", 
[16:05:10.610]                             "SOCK0node"))) {
[16:05:10.610]                             sendCondition <<- function(cond) {
[16:05:10.610]                               data <- list(type = "VALUE", value = cond, 
[16:05:10.610]                                 success = TRUE)
[16:05:10.610]                               parallel_sendData(master, data)
[16:05:10.610]                             }
[16:05:10.610]                             return(sendCondition)
[16:05:10.610]                           }
[16:05:10.610]                         }
[16:05:10.610]                         frame <- frame + 1L
[16:05:10.610]                         envir <- sys.frame(frame)
[16:05:10.610]                       }
[16:05:10.610]                     }
[16:05:10.610]                     sendCondition <<- function(cond) NULL
[16:05:10.610]                   }
[16:05:10.610]                 })
[16:05:10.610]                 withCallingHandlers({
[16:05:10.610]                   {
[16:05:10.610]                     b <- a * ii
[16:05:10.610]                     a <- 0
[16:05:10.610]                     b
[16:05:10.610]                   }
[16:05:10.610]                 }, immediateCondition = function(cond) {
[16:05:10.610]                   sendCondition <- ...future.makeSendCondition()
[16:05:10.610]                   sendCondition(cond)
[16:05:10.610]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.610]                   {
[16:05:10.610]                     inherits <- base::inherits
[16:05:10.610]                     invokeRestart <- base::invokeRestart
[16:05:10.610]                     is.null <- base::is.null
[16:05:10.610]                     muffled <- FALSE
[16:05:10.610]                     if (inherits(cond, "message")) {
[16:05:10.610]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:10.610]                       if (muffled) 
[16:05:10.610]                         invokeRestart("muffleMessage")
[16:05:10.610]                     }
[16:05:10.610]                     else if (inherits(cond, "warning")) {
[16:05:10.610]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:10.610]                       if (muffled) 
[16:05:10.610]                         invokeRestart("muffleWarning")
[16:05:10.610]                     }
[16:05:10.610]                     else if (inherits(cond, "condition")) {
[16:05:10.610]                       if (!is.null(pattern)) {
[16:05:10.610]                         computeRestarts <- base::computeRestarts
[16:05:10.610]                         grepl <- base::grepl
[16:05:10.610]                         restarts <- computeRestarts(cond)
[16:05:10.610]                         for (restart in restarts) {
[16:05:10.610]                           name <- restart$name
[16:05:10.610]                           if (is.null(name)) 
[16:05:10.610]                             next
[16:05:10.610]                           if (!grepl(pattern, name)) 
[16:05:10.610]                             next
[16:05:10.610]                           invokeRestart(restart)
[16:05:10.610]                           muffled <- TRUE
[16:05:10.610]                           break
[16:05:10.610]                         }
[16:05:10.610]                       }
[16:05:10.610]                     }
[16:05:10.610]                     invisible(muffled)
[16:05:10.610]                   }
[16:05:10.610]                   muffleCondition(cond)
[16:05:10.610]                 })
[16:05:10.610]             }))
[16:05:10.610]             future::FutureResult(value = ...future.value$value, 
[16:05:10.610]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.610]                   ...future.rng), globalenv = if (FALSE) 
[16:05:10.610]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:10.610]                     ...future.globalenv.names))
[16:05:10.610]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:10.610]         }, condition = base::local({
[16:05:10.610]             c <- base::c
[16:05:10.610]             inherits <- base::inherits
[16:05:10.610]             invokeRestart <- base::invokeRestart
[16:05:10.610]             length <- base::length
[16:05:10.610]             list <- base::list
[16:05:10.610]             seq.int <- base::seq.int
[16:05:10.610]             signalCondition <- base::signalCondition
[16:05:10.610]             sys.calls <- base::sys.calls
[16:05:10.610]             `[[` <- base::`[[`
[16:05:10.610]             `+` <- base::`+`
[16:05:10.610]             `<<-` <- base::`<<-`
[16:05:10.610]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:10.610]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:10.610]                   3L)]
[16:05:10.610]             }
[16:05:10.610]             function(cond) {
[16:05:10.610]                 is_error <- inherits(cond, "error")
[16:05:10.610]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:10.610]                   NULL)
[16:05:10.610]                 if (is_error) {
[16:05:10.610]                   sessionInformation <- function() {
[16:05:10.610]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:10.610]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:10.610]                       search = base::search(), system = base::Sys.info())
[16:05:10.610]                   }
[16:05:10.610]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.610]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:10.610]                     cond$call), session = sessionInformation(), 
[16:05:10.610]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:10.610]                   signalCondition(cond)
[16:05:10.610]                 }
[16:05:10.610]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:10.610]                 "immediateCondition"))) {
[16:05:10.610]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:10.610]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.610]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:10.610]                   if (TRUE && !signal) {
[16:05:10.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.610]                     {
[16:05:10.610]                       inherits <- base::inherits
[16:05:10.610]                       invokeRestart <- base::invokeRestart
[16:05:10.610]                       is.null <- base::is.null
[16:05:10.610]                       muffled <- FALSE
[16:05:10.610]                       if (inherits(cond, "message")) {
[16:05:10.610]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.610]                         if (muffled) 
[16:05:10.610]                           invokeRestart("muffleMessage")
[16:05:10.610]                       }
[16:05:10.610]                       else if (inherits(cond, "warning")) {
[16:05:10.610]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.610]                         if (muffled) 
[16:05:10.610]                           invokeRestart("muffleWarning")
[16:05:10.610]                       }
[16:05:10.610]                       else if (inherits(cond, "condition")) {
[16:05:10.610]                         if (!is.null(pattern)) {
[16:05:10.610]                           computeRestarts <- base::computeRestarts
[16:05:10.610]                           grepl <- base::grepl
[16:05:10.610]                           restarts <- computeRestarts(cond)
[16:05:10.610]                           for (restart in restarts) {
[16:05:10.610]                             name <- restart$name
[16:05:10.610]                             if (is.null(name)) 
[16:05:10.610]                               next
[16:05:10.610]                             if (!grepl(pattern, name)) 
[16:05:10.610]                               next
[16:05:10.610]                             invokeRestart(restart)
[16:05:10.610]                             muffled <- TRUE
[16:05:10.610]                             break
[16:05:10.610]                           }
[16:05:10.610]                         }
[16:05:10.610]                       }
[16:05:10.610]                       invisible(muffled)
[16:05:10.610]                     }
[16:05:10.610]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.610]                   }
[16:05:10.610]                 }
[16:05:10.610]                 else {
[16:05:10.610]                   if (TRUE) {
[16:05:10.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.610]                     {
[16:05:10.610]                       inherits <- base::inherits
[16:05:10.610]                       invokeRestart <- base::invokeRestart
[16:05:10.610]                       is.null <- base::is.null
[16:05:10.610]                       muffled <- FALSE
[16:05:10.610]                       if (inherits(cond, "message")) {
[16:05:10.610]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.610]                         if (muffled) 
[16:05:10.610]                           invokeRestart("muffleMessage")
[16:05:10.610]                       }
[16:05:10.610]                       else if (inherits(cond, "warning")) {
[16:05:10.610]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.610]                         if (muffled) 
[16:05:10.610]                           invokeRestart("muffleWarning")
[16:05:10.610]                       }
[16:05:10.610]                       else if (inherits(cond, "condition")) {
[16:05:10.610]                         if (!is.null(pattern)) {
[16:05:10.610]                           computeRestarts <- base::computeRestarts
[16:05:10.610]                           grepl <- base::grepl
[16:05:10.610]                           restarts <- computeRestarts(cond)
[16:05:10.610]                           for (restart in restarts) {
[16:05:10.610]                             name <- restart$name
[16:05:10.610]                             if (is.null(name)) 
[16:05:10.610]                               next
[16:05:10.610]                             if (!grepl(pattern, name)) 
[16:05:10.610]                               next
[16:05:10.610]                             invokeRestart(restart)
[16:05:10.610]                             muffled <- TRUE
[16:05:10.610]                             break
[16:05:10.610]                           }
[16:05:10.610]                         }
[16:05:10.610]                       }
[16:05:10.610]                       invisible(muffled)
[16:05:10.610]                     }
[16:05:10.610]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.610]                   }
[16:05:10.610]                 }
[16:05:10.610]             }
[16:05:10.610]         }))
[16:05:10.610]     }, error = function(ex) {
[16:05:10.610]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:10.610]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.610]                 ...future.rng), started = ...future.startTime, 
[16:05:10.610]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:10.610]             version = "1.8"), class = "FutureResult")
[16:05:10.610]     }, finally = {
[16:05:10.610]         if (!identical(...future.workdir, getwd())) 
[16:05:10.610]             setwd(...future.workdir)
[16:05:10.610]         {
[16:05:10.610]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:10.610]                 ...future.oldOptions$nwarnings <- NULL
[16:05:10.610]             }
[16:05:10.610]             base::options(...future.oldOptions)
[16:05:10.610]             if (.Platform$OS.type == "windows") {
[16:05:10.610]                 old_names <- names(...future.oldEnvVars)
[16:05:10.610]                 envs <- base::Sys.getenv()
[16:05:10.610]                 names <- names(envs)
[16:05:10.610]                 common <- intersect(names, old_names)
[16:05:10.610]                 added <- setdiff(names, old_names)
[16:05:10.610]                 removed <- setdiff(old_names, names)
[16:05:10.610]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:10.610]                   envs[common]]
[16:05:10.610]                 NAMES <- toupper(changed)
[16:05:10.610]                 args <- list()
[16:05:10.610]                 for (kk in seq_along(NAMES)) {
[16:05:10.610]                   name <- changed[[kk]]
[16:05:10.610]                   NAME <- NAMES[[kk]]
[16:05:10.610]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.610]                     next
[16:05:10.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.610]                 }
[16:05:10.610]                 NAMES <- toupper(added)
[16:05:10.610]                 for (kk in seq_along(NAMES)) {
[16:05:10.610]                   name <- added[[kk]]
[16:05:10.610]                   NAME <- NAMES[[kk]]
[16:05:10.610]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.610]                     next
[16:05:10.610]                   args[[name]] <- ""
[16:05:10.610]                 }
[16:05:10.610]                 NAMES <- toupper(removed)
[16:05:10.610]                 for (kk in seq_along(NAMES)) {
[16:05:10.610]                   name <- removed[[kk]]
[16:05:10.610]                   NAME <- NAMES[[kk]]
[16:05:10.610]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.610]                     next
[16:05:10.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.610]                 }
[16:05:10.610]                 if (length(args) > 0) 
[16:05:10.610]                   base::do.call(base::Sys.setenv, args = args)
[16:05:10.610]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:10.610]             }
[16:05:10.610]             else {
[16:05:10.610]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:10.610]             }
[16:05:10.610]             {
[16:05:10.610]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:10.610]                   0L) {
[16:05:10.610]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:10.610]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:10.610]                   base::options(opts)
[16:05:10.610]                 }
[16:05:10.610]                 {
[16:05:10.610]                   {
[16:05:10.610]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:10.610]                     NULL
[16:05:10.610]                   }
[16:05:10.610]                   options(future.plan = NULL)
[16:05:10.610]                   if (is.na(NA_character_)) 
[16:05:10.610]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.610]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:10.610]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:10.610]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:10.610]                     envir = parent.frame()) 
[16:05:10.610]                   {
[16:05:10.610]                     if (is.function(workers)) 
[16:05:10.610]                       workers <- workers()
[16:05:10.610]                     workers <- structure(as.integer(workers), 
[16:05:10.610]                       class = class(workers))
[16:05:10.610]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:10.610]                       workers >= 1)
[16:05:10.610]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:10.610]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:10.610]                     }
[16:05:10.610]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:10.610]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:10.610]                       envir = envir)
[16:05:10.610]                     if (!future$lazy) 
[16:05:10.610]                       future <- run(future)
[16:05:10.610]                     invisible(future)
[16:05:10.610]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:10.610]                 }
[16:05:10.610]             }
[16:05:10.610]         }
[16:05:10.610]     })
[16:05:10.610]     if (TRUE) {
[16:05:10.610]         base::sink(type = "output", split = FALSE)
[16:05:10.610]         if (TRUE) {
[16:05:10.610]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:10.610]         }
[16:05:10.610]         else {
[16:05:10.610]             ...future.result["stdout"] <- base::list(NULL)
[16:05:10.610]         }
[16:05:10.610]         base::close(...future.stdout)
[16:05:10.610]         ...future.stdout <- NULL
[16:05:10.610]     }
[16:05:10.610]     ...future.result$conditions <- ...future.conditions
[16:05:10.610]     ...future.result$finished <- base::Sys.time()
[16:05:10.610]     ...future.result
[16:05:10.610] }
[16:05:10.613] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[16:05:10.613] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:05:10.613] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:05:10.614] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:05:10.614] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:05:10.614] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[16:05:10.615] MultisessionFuture started
[16:05:10.615] - Launch lazy future ... done
[16:05:10.615] run() for ‘MultisessionFuture’ ... done
[16:05:10.615] result() for ClusterFuture ...
[16:05:10.615] receiveMessageFromWorker() for ClusterFuture ...
[16:05:10.615] - Validating connection of MultisessionFuture
[16:05:10.660] - received message: FutureResult
[16:05:10.660] - Received FutureResult
[16:05:10.660] - Erased future from FutureRegistry
[16:05:10.661] result() for ClusterFuture ...
[16:05:10.661] - result already collected: FutureResult
[16:05:10.661] result() for ClusterFuture ... done
[16:05:10.661] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:10.661] result() for ClusterFuture ... done
[16:05:10.661] result() for ClusterFuture ...
[16:05:10.661] - result already collected: FutureResult
[16:05:10.661] result() for ClusterFuture ... done
[16:05:10.661] run() for ‘Future’ ...
[16:05:10.662] - state: ‘created’
[16:05:10.662] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:10.676] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:10.676] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:10.676]   - Field: ‘node’
[16:05:10.676]   - Field: ‘label’
[16:05:10.676]   - Field: ‘local’
[16:05:10.676]   - Field: ‘owner’
[16:05:10.677]   - Field: ‘envir’
[16:05:10.677]   - Field: ‘workers’
[16:05:10.677]   - Field: ‘packages’
[16:05:10.677]   - Field: ‘gc’
[16:05:10.677]   - Field: ‘conditions’
[16:05:10.677]   - Field: ‘persistent’
[16:05:10.677]   - Field: ‘expr’
[16:05:10.677]   - Field: ‘uuid’
[16:05:10.677]   - Field: ‘seed’
[16:05:10.677]   - Field: ‘version’
[16:05:10.677]   - Field: ‘result’
[16:05:10.678]   - Field: ‘asynchronous’
[16:05:10.678]   - Field: ‘calls’
[16:05:10.678]   - Field: ‘globals’
[16:05:10.678]   - Field: ‘stdout’
[16:05:10.678]   - Field: ‘earlySignal’
[16:05:10.678]   - Field: ‘lazy’
[16:05:10.678]   - Field: ‘state’
[16:05:10.678] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:10.678] - Launch lazy future ...
[16:05:10.679] Packages needed by the future expression (n = 0): <none>
[16:05:10.679] Packages needed by future strategies (n = 0): <none>
[16:05:10.679] {
[16:05:10.679]     {
[16:05:10.679]         {
[16:05:10.679]             ...future.startTime <- base::Sys.time()
[16:05:10.679]             {
[16:05:10.679]                 {
[16:05:10.679]                   {
[16:05:10.679]                     {
[16:05:10.679]                       base::local({
[16:05:10.679]                         has_future <- base::requireNamespace("future", 
[16:05:10.679]                           quietly = TRUE)
[16:05:10.679]                         if (has_future) {
[16:05:10.679]                           ns <- base::getNamespace("future")
[16:05:10.679]                           version <- ns[[".package"]][["version"]]
[16:05:10.679]                           if (is.null(version)) 
[16:05:10.679]                             version <- utils::packageVersion("future")
[16:05:10.679]                         }
[16:05:10.679]                         else {
[16:05:10.679]                           version <- NULL
[16:05:10.679]                         }
[16:05:10.679]                         if (!has_future || version < "1.8.0") {
[16:05:10.679]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:10.679]                             "", base::R.version$version.string), 
[16:05:10.679]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:10.679]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:10.679]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:10.679]                               "release", "version")], collapse = " "), 
[16:05:10.679]                             hostname = base::Sys.info()[["nodename"]])
[16:05:10.679]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:10.679]                             info)
[16:05:10.679]                           info <- base::paste(info, collapse = "; ")
[16:05:10.679]                           if (!has_future) {
[16:05:10.679]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:10.679]                               info)
[16:05:10.679]                           }
[16:05:10.679]                           else {
[16:05:10.679]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:10.679]                               info, version)
[16:05:10.679]                           }
[16:05:10.679]                           base::stop(msg)
[16:05:10.679]                         }
[16:05:10.679]                       })
[16:05:10.679]                     }
[16:05:10.679]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:10.679]                     base::options(mc.cores = 1L)
[16:05:10.679]                   }
[16:05:10.679]                   options(future.plan = NULL)
[16:05:10.679]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.679]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:10.679]                 }
[16:05:10.679]                 ...future.workdir <- getwd()
[16:05:10.679]             }
[16:05:10.679]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:10.679]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:10.679]         }
[16:05:10.679]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:10.679]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:10.679]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:10.679]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:10.679]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:10.679]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:10.679]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:10.679]             base::names(...future.oldOptions))
[16:05:10.679]     }
[16:05:10.679]     if (FALSE) {
[16:05:10.679]     }
[16:05:10.679]     else {
[16:05:10.679]         if (TRUE) {
[16:05:10.679]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:10.679]                 open = "w")
[16:05:10.679]         }
[16:05:10.679]         else {
[16:05:10.679]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:10.679]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:10.679]         }
[16:05:10.679]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:10.679]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:10.679]             base::sink(type = "output", split = FALSE)
[16:05:10.679]             base::close(...future.stdout)
[16:05:10.679]         }, add = TRUE)
[16:05:10.679]     }
[16:05:10.679]     ...future.frame <- base::sys.nframe()
[16:05:10.679]     ...future.conditions <- base::list()
[16:05:10.679]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:10.679]     if (FALSE) {
[16:05:10.679]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:10.679]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:10.679]     }
[16:05:10.679]     ...future.result <- base::tryCatch({
[16:05:10.679]         base::withCallingHandlers({
[16:05:10.679]             ...future.value <- base::withVisible(base::local({
[16:05:10.679]                 ...future.makeSendCondition <- base::local({
[16:05:10.679]                   sendCondition <- NULL
[16:05:10.679]                   function(frame = 1L) {
[16:05:10.679]                     if (is.function(sendCondition)) 
[16:05:10.679]                       return(sendCondition)
[16:05:10.679]                     ns <- getNamespace("parallel")
[16:05:10.679]                     if (exists("sendData", mode = "function", 
[16:05:10.679]                       envir = ns)) {
[16:05:10.679]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:10.679]                         envir = ns)
[16:05:10.679]                       envir <- sys.frame(frame)
[16:05:10.679]                       master <- NULL
[16:05:10.679]                       while (!identical(envir, .GlobalEnv) && 
[16:05:10.679]                         !identical(envir, emptyenv())) {
[16:05:10.679]                         if (exists("master", mode = "list", envir = envir, 
[16:05:10.679]                           inherits = FALSE)) {
[16:05:10.679]                           master <- get("master", mode = "list", 
[16:05:10.679]                             envir = envir, inherits = FALSE)
[16:05:10.679]                           if (inherits(master, c("SOCKnode", 
[16:05:10.679]                             "SOCK0node"))) {
[16:05:10.679]                             sendCondition <<- function(cond) {
[16:05:10.679]                               data <- list(type = "VALUE", value = cond, 
[16:05:10.679]                                 success = TRUE)
[16:05:10.679]                               parallel_sendData(master, data)
[16:05:10.679]                             }
[16:05:10.679]                             return(sendCondition)
[16:05:10.679]                           }
[16:05:10.679]                         }
[16:05:10.679]                         frame <- frame + 1L
[16:05:10.679]                         envir <- sys.frame(frame)
[16:05:10.679]                       }
[16:05:10.679]                     }
[16:05:10.679]                     sendCondition <<- function(cond) NULL
[16:05:10.679]                   }
[16:05:10.679]                 })
[16:05:10.679]                 withCallingHandlers({
[16:05:10.679]                   {
[16:05:10.679]                     b <- a * ii
[16:05:10.679]                     a <- 0
[16:05:10.679]                     b
[16:05:10.679]                   }
[16:05:10.679]                 }, immediateCondition = function(cond) {
[16:05:10.679]                   sendCondition <- ...future.makeSendCondition()
[16:05:10.679]                   sendCondition(cond)
[16:05:10.679]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.679]                   {
[16:05:10.679]                     inherits <- base::inherits
[16:05:10.679]                     invokeRestart <- base::invokeRestart
[16:05:10.679]                     is.null <- base::is.null
[16:05:10.679]                     muffled <- FALSE
[16:05:10.679]                     if (inherits(cond, "message")) {
[16:05:10.679]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:10.679]                       if (muffled) 
[16:05:10.679]                         invokeRestart("muffleMessage")
[16:05:10.679]                     }
[16:05:10.679]                     else if (inherits(cond, "warning")) {
[16:05:10.679]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:10.679]                       if (muffled) 
[16:05:10.679]                         invokeRestart("muffleWarning")
[16:05:10.679]                     }
[16:05:10.679]                     else if (inherits(cond, "condition")) {
[16:05:10.679]                       if (!is.null(pattern)) {
[16:05:10.679]                         computeRestarts <- base::computeRestarts
[16:05:10.679]                         grepl <- base::grepl
[16:05:10.679]                         restarts <- computeRestarts(cond)
[16:05:10.679]                         for (restart in restarts) {
[16:05:10.679]                           name <- restart$name
[16:05:10.679]                           if (is.null(name)) 
[16:05:10.679]                             next
[16:05:10.679]                           if (!grepl(pattern, name)) 
[16:05:10.679]                             next
[16:05:10.679]                           invokeRestart(restart)
[16:05:10.679]                           muffled <- TRUE
[16:05:10.679]                           break
[16:05:10.679]                         }
[16:05:10.679]                       }
[16:05:10.679]                     }
[16:05:10.679]                     invisible(muffled)
[16:05:10.679]                   }
[16:05:10.679]                   muffleCondition(cond)
[16:05:10.679]                 })
[16:05:10.679]             }))
[16:05:10.679]             future::FutureResult(value = ...future.value$value, 
[16:05:10.679]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.679]                   ...future.rng), globalenv = if (FALSE) 
[16:05:10.679]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:10.679]                     ...future.globalenv.names))
[16:05:10.679]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:10.679]         }, condition = base::local({
[16:05:10.679]             c <- base::c
[16:05:10.679]             inherits <- base::inherits
[16:05:10.679]             invokeRestart <- base::invokeRestart
[16:05:10.679]             length <- base::length
[16:05:10.679]             list <- base::list
[16:05:10.679]             seq.int <- base::seq.int
[16:05:10.679]             signalCondition <- base::signalCondition
[16:05:10.679]             sys.calls <- base::sys.calls
[16:05:10.679]             `[[` <- base::`[[`
[16:05:10.679]             `+` <- base::`+`
[16:05:10.679]             `<<-` <- base::`<<-`
[16:05:10.679]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:10.679]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:10.679]                   3L)]
[16:05:10.679]             }
[16:05:10.679]             function(cond) {
[16:05:10.679]                 is_error <- inherits(cond, "error")
[16:05:10.679]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:10.679]                   NULL)
[16:05:10.679]                 if (is_error) {
[16:05:10.679]                   sessionInformation <- function() {
[16:05:10.679]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:10.679]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:10.679]                       search = base::search(), system = base::Sys.info())
[16:05:10.679]                   }
[16:05:10.679]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.679]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:10.679]                     cond$call), session = sessionInformation(), 
[16:05:10.679]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:10.679]                   signalCondition(cond)
[16:05:10.679]                 }
[16:05:10.679]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:10.679]                 "immediateCondition"))) {
[16:05:10.679]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:10.679]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.679]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:10.679]                   if (TRUE && !signal) {
[16:05:10.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.679]                     {
[16:05:10.679]                       inherits <- base::inherits
[16:05:10.679]                       invokeRestart <- base::invokeRestart
[16:05:10.679]                       is.null <- base::is.null
[16:05:10.679]                       muffled <- FALSE
[16:05:10.679]                       if (inherits(cond, "message")) {
[16:05:10.679]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.679]                         if (muffled) 
[16:05:10.679]                           invokeRestart("muffleMessage")
[16:05:10.679]                       }
[16:05:10.679]                       else if (inherits(cond, "warning")) {
[16:05:10.679]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.679]                         if (muffled) 
[16:05:10.679]                           invokeRestart("muffleWarning")
[16:05:10.679]                       }
[16:05:10.679]                       else if (inherits(cond, "condition")) {
[16:05:10.679]                         if (!is.null(pattern)) {
[16:05:10.679]                           computeRestarts <- base::computeRestarts
[16:05:10.679]                           grepl <- base::grepl
[16:05:10.679]                           restarts <- computeRestarts(cond)
[16:05:10.679]                           for (restart in restarts) {
[16:05:10.679]                             name <- restart$name
[16:05:10.679]                             if (is.null(name)) 
[16:05:10.679]                               next
[16:05:10.679]                             if (!grepl(pattern, name)) 
[16:05:10.679]                               next
[16:05:10.679]                             invokeRestart(restart)
[16:05:10.679]                             muffled <- TRUE
[16:05:10.679]                             break
[16:05:10.679]                           }
[16:05:10.679]                         }
[16:05:10.679]                       }
[16:05:10.679]                       invisible(muffled)
[16:05:10.679]                     }
[16:05:10.679]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.679]                   }
[16:05:10.679]                 }
[16:05:10.679]                 else {
[16:05:10.679]                   if (TRUE) {
[16:05:10.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.679]                     {
[16:05:10.679]                       inherits <- base::inherits
[16:05:10.679]                       invokeRestart <- base::invokeRestart
[16:05:10.679]                       is.null <- base::is.null
[16:05:10.679]                       muffled <- FALSE
[16:05:10.679]                       if (inherits(cond, "message")) {
[16:05:10.679]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.679]                         if (muffled) 
[16:05:10.679]                           invokeRestart("muffleMessage")
[16:05:10.679]                       }
[16:05:10.679]                       else if (inherits(cond, "warning")) {
[16:05:10.679]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.679]                         if (muffled) 
[16:05:10.679]                           invokeRestart("muffleWarning")
[16:05:10.679]                       }
[16:05:10.679]                       else if (inherits(cond, "condition")) {
[16:05:10.679]                         if (!is.null(pattern)) {
[16:05:10.679]                           computeRestarts <- base::computeRestarts
[16:05:10.679]                           grepl <- base::grepl
[16:05:10.679]                           restarts <- computeRestarts(cond)
[16:05:10.679]                           for (restart in restarts) {
[16:05:10.679]                             name <- restart$name
[16:05:10.679]                             if (is.null(name)) 
[16:05:10.679]                               next
[16:05:10.679]                             if (!grepl(pattern, name)) 
[16:05:10.679]                               next
[16:05:10.679]                             invokeRestart(restart)
[16:05:10.679]                             muffled <- TRUE
[16:05:10.679]                             break
[16:05:10.679]                           }
[16:05:10.679]                         }
[16:05:10.679]                       }
[16:05:10.679]                       invisible(muffled)
[16:05:10.679]                     }
[16:05:10.679]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.679]                   }
[16:05:10.679]                 }
[16:05:10.679]             }
[16:05:10.679]         }))
[16:05:10.679]     }, error = function(ex) {
[16:05:10.679]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:10.679]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.679]                 ...future.rng), started = ...future.startTime, 
[16:05:10.679]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:10.679]             version = "1.8"), class = "FutureResult")
[16:05:10.679]     }, finally = {
[16:05:10.679]         if (!identical(...future.workdir, getwd())) 
[16:05:10.679]             setwd(...future.workdir)
[16:05:10.679]         {
[16:05:10.679]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:10.679]                 ...future.oldOptions$nwarnings <- NULL
[16:05:10.679]             }
[16:05:10.679]             base::options(...future.oldOptions)
[16:05:10.679]             if (.Platform$OS.type == "windows") {
[16:05:10.679]                 old_names <- names(...future.oldEnvVars)
[16:05:10.679]                 envs <- base::Sys.getenv()
[16:05:10.679]                 names <- names(envs)
[16:05:10.679]                 common <- intersect(names, old_names)
[16:05:10.679]                 added <- setdiff(names, old_names)
[16:05:10.679]                 removed <- setdiff(old_names, names)
[16:05:10.679]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:10.679]                   envs[common]]
[16:05:10.679]                 NAMES <- toupper(changed)
[16:05:10.679]                 args <- list()
[16:05:10.679]                 for (kk in seq_along(NAMES)) {
[16:05:10.679]                   name <- changed[[kk]]
[16:05:10.679]                   NAME <- NAMES[[kk]]
[16:05:10.679]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.679]                     next
[16:05:10.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.679]                 }
[16:05:10.679]                 NAMES <- toupper(added)
[16:05:10.679]                 for (kk in seq_along(NAMES)) {
[16:05:10.679]                   name <- added[[kk]]
[16:05:10.679]                   NAME <- NAMES[[kk]]
[16:05:10.679]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.679]                     next
[16:05:10.679]                   args[[name]] <- ""
[16:05:10.679]                 }
[16:05:10.679]                 NAMES <- toupper(removed)
[16:05:10.679]                 for (kk in seq_along(NAMES)) {
[16:05:10.679]                   name <- removed[[kk]]
[16:05:10.679]                   NAME <- NAMES[[kk]]
[16:05:10.679]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.679]                     next
[16:05:10.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.679]                 }
[16:05:10.679]                 if (length(args) > 0) 
[16:05:10.679]                   base::do.call(base::Sys.setenv, args = args)
[16:05:10.679]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:10.679]             }
[16:05:10.679]             else {
[16:05:10.679]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:10.679]             }
[16:05:10.679]             {
[16:05:10.679]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:10.679]                   0L) {
[16:05:10.679]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:10.679]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:10.679]                   base::options(opts)
[16:05:10.679]                 }
[16:05:10.679]                 {
[16:05:10.679]                   {
[16:05:10.679]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:10.679]                     NULL
[16:05:10.679]                   }
[16:05:10.679]                   options(future.plan = NULL)
[16:05:10.679]                   if (is.na(NA_character_)) 
[16:05:10.679]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.679]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:10.679]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:10.679]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:10.679]                     envir = parent.frame()) 
[16:05:10.679]                   {
[16:05:10.679]                     if (is.function(workers)) 
[16:05:10.679]                       workers <- workers()
[16:05:10.679]                     workers <- structure(as.integer(workers), 
[16:05:10.679]                       class = class(workers))
[16:05:10.679]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:10.679]                       workers >= 1)
[16:05:10.679]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:10.679]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:10.679]                     }
[16:05:10.679]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:10.679]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:10.679]                       envir = envir)
[16:05:10.679]                     if (!future$lazy) 
[16:05:10.679]                       future <- run(future)
[16:05:10.679]                     invisible(future)
[16:05:10.679]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:10.679]                 }
[16:05:10.679]             }
[16:05:10.679]         }
[16:05:10.679]     })
[16:05:10.679]     if (TRUE) {
[16:05:10.679]         base::sink(type = "output", split = FALSE)
[16:05:10.679]         if (TRUE) {
[16:05:10.679]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:10.679]         }
[16:05:10.679]         else {
[16:05:10.679]             ...future.result["stdout"] <- base::list(NULL)
[16:05:10.679]         }
[16:05:10.679]         base::close(...future.stdout)
[16:05:10.679]         ...future.stdout <- NULL
[16:05:10.679]     }
[16:05:10.679]     ...future.result$conditions <- ...future.conditions
[16:05:10.679]     ...future.result$finished <- base::Sys.time()
[16:05:10.679]     ...future.result
[16:05:10.679] }
[16:05:10.682] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[16:05:10.682] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:05:10.683] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:05:10.683] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:05:10.683] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:05:10.683] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[16:05:10.684] MultisessionFuture started
[16:05:10.684] - Launch lazy future ... done
[16:05:10.684] run() for ‘MultisessionFuture’ ... done
[16:05:10.684] result() for ClusterFuture ...
[16:05:10.684] receiveMessageFromWorker() for ClusterFuture ...
[16:05:10.684] - Validating connection of MultisessionFuture
[16:05:10.732] - received message: FutureResult
[16:05:10.732] - Received FutureResult
[16:05:10.733] - Erased future from FutureRegistry
[16:05:10.733] result() for ClusterFuture ...
[16:05:10.733] - result already collected: FutureResult
[16:05:10.733] result() for ClusterFuture ... done
[16:05:10.733] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:10.733] result() for ClusterFuture ... done
[16:05:10.733] result() for ClusterFuture ...
[16:05:10.733] - result already collected: FutureResult
[16:05:10.733] result() for ClusterFuture ... done
[16:05:10.734] run() for ‘Future’ ...
[16:05:10.734] - state: ‘created’
[16:05:10.734] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:10.749] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:10.749] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:10.749]   - Field: ‘node’
[16:05:10.749]   - Field: ‘label’
[16:05:10.749]   - Field: ‘local’
[16:05:10.749]   - Field: ‘owner’
[16:05:10.749]   - Field: ‘envir’
[16:05:10.749]   - Field: ‘workers’
[16:05:10.750]   - Field: ‘packages’
[16:05:10.750]   - Field: ‘gc’
[16:05:10.750]   - Field: ‘conditions’
[16:05:10.750]   - Field: ‘persistent’
[16:05:10.750]   - Field: ‘expr’
[16:05:10.750]   - Field: ‘uuid’
[16:05:10.750]   - Field: ‘seed’
[16:05:10.750]   - Field: ‘version’
[16:05:10.750]   - Field: ‘result’
[16:05:10.750]   - Field: ‘asynchronous’
[16:05:10.750]   - Field: ‘calls’
[16:05:10.751]   - Field: ‘globals’
[16:05:10.751]   - Field: ‘stdout’
[16:05:10.751]   - Field: ‘earlySignal’
[16:05:10.751]   - Field: ‘lazy’
[16:05:10.751]   - Field: ‘state’
[16:05:10.751] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:10.751] - Launch lazy future ...
[16:05:10.752] Packages needed by the future expression (n = 0): <none>
[16:05:10.752] Packages needed by future strategies (n = 0): <none>
[16:05:10.752] {
[16:05:10.752]     {
[16:05:10.752]         {
[16:05:10.752]             ...future.startTime <- base::Sys.time()
[16:05:10.752]             {
[16:05:10.752]                 {
[16:05:10.752]                   {
[16:05:10.752]                     {
[16:05:10.752]                       base::local({
[16:05:10.752]                         has_future <- base::requireNamespace("future", 
[16:05:10.752]                           quietly = TRUE)
[16:05:10.752]                         if (has_future) {
[16:05:10.752]                           ns <- base::getNamespace("future")
[16:05:10.752]                           version <- ns[[".package"]][["version"]]
[16:05:10.752]                           if (is.null(version)) 
[16:05:10.752]                             version <- utils::packageVersion("future")
[16:05:10.752]                         }
[16:05:10.752]                         else {
[16:05:10.752]                           version <- NULL
[16:05:10.752]                         }
[16:05:10.752]                         if (!has_future || version < "1.8.0") {
[16:05:10.752]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:10.752]                             "", base::R.version$version.string), 
[16:05:10.752]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:10.752]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:10.752]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:10.752]                               "release", "version")], collapse = " "), 
[16:05:10.752]                             hostname = base::Sys.info()[["nodename"]])
[16:05:10.752]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:10.752]                             info)
[16:05:10.752]                           info <- base::paste(info, collapse = "; ")
[16:05:10.752]                           if (!has_future) {
[16:05:10.752]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:10.752]                               info)
[16:05:10.752]                           }
[16:05:10.752]                           else {
[16:05:10.752]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:10.752]                               info, version)
[16:05:10.752]                           }
[16:05:10.752]                           base::stop(msg)
[16:05:10.752]                         }
[16:05:10.752]                       })
[16:05:10.752]                     }
[16:05:10.752]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:10.752]                     base::options(mc.cores = 1L)
[16:05:10.752]                   }
[16:05:10.752]                   options(future.plan = NULL)
[16:05:10.752]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.752]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:10.752]                 }
[16:05:10.752]                 ...future.workdir <- getwd()
[16:05:10.752]             }
[16:05:10.752]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:10.752]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:10.752]         }
[16:05:10.752]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:10.752]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:10.752]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:10.752]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:10.752]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:10.752]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:10.752]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:10.752]             base::names(...future.oldOptions))
[16:05:10.752]     }
[16:05:10.752]     if (FALSE) {
[16:05:10.752]     }
[16:05:10.752]     else {
[16:05:10.752]         if (TRUE) {
[16:05:10.752]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:10.752]                 open = "w")
[16:05:10.752]         }
[16:05:10.752]         else {
[16:05:10.752]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:10.752]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:10.752]         }
[16:05:10.752]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:10.752]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:10.752]             base::sink(type = "output", split = FALSE)
[16:05:10.752]             base::close(...future.stdout)
[16:05:10.752]         }, add = TRUE)
[16:05:10.752]     }
[16:05:10.752]     ...future.frame <- base::sys.nframe()
[16:05:10.752]     ...future.conditions <- base::list()
[16:05:10.752]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:10.752]     if (FALSE) {
[16:05:10.752]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:10.752]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:10.752]     }
[16:05:10.752]     ...future.result <- base::tryCatch({
[16:05:10.752]         base::withCallingHandlers({
[16:05:10.752]             ...future.value <- base::withVisible(base::local({
[16:05:10.752]                 ...future.makeSendCondition <- base::local({
[16:05:10.752]                   sendCondition <- NULL
[16:05:10.752]                   function(frame = 1L) {
[16:05:10.752]                     if (is.function(sendCondition)) 
[16:05:10.752]                       return(sendCondition)
[16:05:10.752]                     ns <- getNamespace("parallel")
[16:05:10.752]                     if (exists("sendData", mode = "function", 
[16:05:10.752]                       envir = ns)) {
[16:05:10.752]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:10.752]                         envir = ns)
[16:05:10.752]                       envir <- sys.frame(frame)
[16:05:10.752]                       master <- NULL
[16:05:10.752]                       while (!identical(envir, .GlobalEnv) && 
[16:05:10.752]                         !identical(envir, emptyenv())) {
[16:05:10.752]                         if (exists("master", mode = "list", envir = envir, 
[16:05:10.752]                           inherits = FALSE)) {
[16:05:10.752]                           master <- get("master", mode = "list", 
[16:05:10.752]                             envir = envir, inherits = FALSE)
[16:05:10.752]                           if (inherits(master, c("SOCKnode", 
[16:05:10.752]                             "SOCK0node"))) {
[16:05:10.752]                             sendCondition <<- function(cond) {
[16:05:10.752]                               data <- list(type = "VALUE", value = cond, 
[16:05:10.752]                                 success = TRUE)
[16:05:10.752]                               parallel_sendData(master, data)
[16:05:10.752]                             }
[16:05:10.752]                             return(sendCondition)
[16:05:10.752]                           }
[16:05:10.752]                         }
[16:05:10.752]                         frame <- frame + 1L
[16:05:10.752]                         envir <- sys.frame(frame)
[16:05:10.752]                       }
[16:05:10.752]                     }
[16:05:10.752]                     sendCondition <<- function(cond) NULL
[16:05:10.752]                   }
[16:05:10.752]                 })
[16:05:10.752]                 withCallingHandlers({
[16:05:10.752]                   {
[16:05:10.752]                     b <- a * ii
[16:05:10.752]                     a <- 0
[16:05:10.752]                     b
[16:05:10.752]                   }
[16:05:10.752]                 }, immediateCondition = function(cond) {
[16:05:10.752]                   sendCondition <- ...future.makeSendCondition()
[16:05:10.752]                   sendCondition(cond)
[16:05:10.752]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.752]                   {
[16:05:10.752]                     inherits <- base::inherits
[16:05:10.752]                     invokeRestart <- base::invokeRestart
[16:05:10.752]                     is.null <- base::is.null
[16:05:10.752]                     muffled <- FALSE
[16:05:10.752]                     if (inherits(cond, "message")) {
[16:05:10.752]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:10.752]                       if (muffled) 
[16:05:10.752]                         invokeRestart("muffleMessage")
[16:05:10.752]                     }
[16:05:10.752]                     else if (inherits(cond, "warning")) {
[16:05:10.752]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:10.752]                       if (muffled) 
[16:05:10.752]                         invokeRestart("muffleWarning")
[16:05:10.752]                     }
[16:05:10.752]                     else if (inherits(cond, "condition")) {
[16:05:10.752]                       if (!is.null(pattern)) {
[16:05:10.752]                         computeRestarts <- base::computeRestarts
[16:05:10.752]                         grepl <- base::grepl
[16:05:10.752]                         restarts <- computeRestarts(cond)
[16:05:10.752]                         for (restart in restarts) {
[16:05:10.752]                           name <- restart$name
[16:05:10.752]                           if (is.null(name)) 
[16:05:10.752]                             next
[16:05:10.752]                           if (!grepl(pattern, name)) 
[16:05:10.752]                             next
[16:05:10.752]                           invokeRestart(restart)
[16:05:10.752]                           muffled <- TRUE
[16:05:10.752]                           break
[16:05:10.752]                         }
[16:05:10.752]                       }
[16:05:10.752]                     }
[16:05:10.752]                     invisible(muffled)
[16:05:10.752]                   }
[16:05:10.752]                   muffleCondition(cond)
[16:05:10.752]                 })
[16:05:10.752]             }))
[16:05:10.752]             future::FutureResult(value = ...future.value$value, 
[16:05:10.752]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.752]                   ...future.rng), globalenv = if (FALSE) 
[16:05:10.752]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:10.752]                     ...future.globalenv.names))
[16:05:10.752]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:10.752]         }, condition = base::local({
[16:05:10.752]             c <- base::c
[16:05:10.752]             inherits <- base::inherits
[16:05:10.752]             invokeRestart <- base::invokeRestart
[16:05:10.752]             length <- base::length
[16:05:10.752]             list <- base::list
[16:05:10.752]             seq.int <- base::seq.int
[16:05:10.752]             signalCondition <- base::signalCondition
[16:05:10.752]             sys.calls <- base::sys.calls
[16:05:10.752]             `[[` <- base::`[[`
[16:05:10.752]             `+` <- base::`+`
[16:05:10.752]             `<<-` <- base::`<<-`
[16:05:10.752]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:10.752]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:10.752]                   3L)]
[16:05:10.752]             }
[16:05:10.752]             function(cond) {
[16:05:10.752]                 is_error <- inherits(cond, "error")
[16:05:10.752]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:10.752]                   NULL)
[16:05:10.752]                 if (is_error) {
[16:05:10.752]                   sessionInformation <- function() {
[16:05:10.752]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:10.752]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:10.752]                       search = base::search(), system = base::Sys.info())
[16:05:10.752]                   }
[16:05:10.752]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.752]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:10.752]                     cond$call), session = sessionInformation(), 
[16:05:10.752]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:10.752]                   signalCondition(cond)
[16:05:10.752]                 }
[16:05:10.752]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:10.752]                 "immediateCondition"))) {
[16:05:10.752]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:10.752]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.752]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:10.752]                   if (TRUE && !signal) {
[16:05:10.752]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.752]                     {
[16:05:10.752]                       inherits <- base::inherits
[16:05:10.752]                       invokeRestart <- base::invokeRestart
[16:05:10.752]                       is.null <- base::is.null
[16:05:10.752]                       muffled <- FALSE
[16:05:10.752]                       if (inherits(cond, "message")) {
[16:05:10.752]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.752]                         if (muffled) 
[16:05:10.752]                           invokeRestart("muffleMessage")
[16:05:10.752]                       }
[16:05:10.752]                       else if (inherits(cond, "warning")) {
[16:05:10.752]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.752]                         if (muffled) 
[16:05:10.752]                           invokeRestart("muffleWarning")
[16:05:10.752]                       }
[16:05:10.752]                       else if (inherits(cond, "condition")) {
[16:05:10.752]                         if (!is.null(pattern)) {
[16:05:10.752]                           computeRestarts <- base::computeRestarts
[16:05:10.752]                           grepl <- base::grepl
[16:05:10.752]                           restarts <- computeRestarts(cond)
[16:05:10.752]                           for (restart in restarts) {
[16:05:10.752]                             name <- restart$name
[16:05:10.752]                             if (is.null(name)) 
[16:05:10.752]                               next
[16:05:10.752]                             if (!grepl(pattern, name)) 
[16:05:10.752]                               next
[16:05:10.752]                             invokeRestart(restart)
[16:05:10.752]                             muffled <- TRUE
[16:05:10.752]                             break
[16:05:10.752]                           }
[16:05:10.752]                         }
[16:05:10.752]                       }
[16:05:10.752]                       invisible(muffled)
[16:05:10.752]                     }
[16:05:10.752]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.752]                   }
[16:05:10.752]                 }
[16:05:10.752]                 else {
[16:05:10.752]                   if (TRUE) {
[16:05:10.752]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.752]                     {
[16:05:10.752]                       inherits <- base::inherits
[16:05:10.752]                       invokeRestart <- base::invokeRestart
[16:05:10.752]                       is.null <- base::is.null
[16:05:10.752]                       muffled <- FALSE
[16:05:10.752]                       if (inherits(cond, "message")) {
[16:05:10.752]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.752]                         if (muffled) 
[16:05:10.752]                           invokeRestart("muffleMessage")
[16:05:10.752]                       }
[16:05:10.752]                       else if (inherits(cond, "warning")) {
[16:05:10.752]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.752]                         if (muffled) 
[16:05:10.752]                           invokeRestart("muffleWarning")
[16:05:10.752]                       }
[16:05:10.752]                       else if (inherits(cond, "condition")) {
[16:05:10.752]                         if (!is.null(pattern)) {
[16:05:10.752]                           computeRestarts <- base::computeRestarts
[16:05:10.752]                           grepl <- base::grepl
[16:05:10.752]                           restarts <- computeRestarts(cond)
[16:05:10.752]                           for (restart in restarts) {
[16:05:10.752]                             name <- restart$name
[16:05:10.752]                             if (is.null(name)) 
[16:05:10.752]                               next
[16:05:10.752]                             if (!grepl(pattern, name)) 
[16:05:10.752]                               next
[16:05:10.752]                             invokeRestart(restart)
[16:05:10.752]                             muffled <- TRUE
[16:05:10.752]                             break
[16:05:10.752]                           }
[16:05:10.752]                         }
[16:05:10.752]                       }
[16:05:10.752]                       invisible(muffled)
[16:05:10.752]                     }
[16:05:10.752]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.752]                   }
[16:05:10.752]                 }
[16:05:10.752]             }
[16:05:10.752]         }))
[16:05:10.752]     }, error = function(ex) {
[16:05:10.752]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:10.752]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.752]                 ...future.rng), started = ...future.startTime, 
[16:05:10.752]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:10.752]             version = "1.8"), class = "FutureResult")
[16:05:10.752]     }, finally = {
[16:05:10.752]         if (!identical(...future.workdir, getwd())) 
[16:05:10.752]             setwd(...future.workdir)
[16:05:10.752]         {
[16:05:10.752]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:10.752]                 ...future.oldOptions$nwarnings <- NULL
[16:05:10.752]             }
[16:05:10.752]             base::options(...future.oldOptions)
[16:05:10.752]             if (.Platform$OS.type == "windows") {
[16:05:10.752]                 old_names <- names(...future.oldEnvVars)
[16:05:10.752]                 envs <- base::Sys.getenv()
[16:05:10.752]                 names <- names(envs)
[16:05:10.752]                 common <- intersect(names, old_names)
[16:05:10.752]                 added <- setdiff(names, old_names)
[16:05:10.752]                 removed <- setdiff(old_names, names)
[16:05:10.752]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:10.752]                   envs[common]]
[16:05:10.752]                 NAMES <- toupper(changed)
[16:05:10.752]                 args <- list()
[16:05:10.752]                 for (kk in seq_along(NAMES)) {
[16:05:10.752]                   name <- changed[[kk]]
[16:05:10.752]                   NAME <- NAMES[[kk]]
[16:05:10.752]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.752]                     next
[16:05:10.752]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.752]                 }
[16:05:10.752]                 NAMES <- toupper(added)
[16:05:10.752]                 for (kk in seq_along(NAMES)) {
[16:05:10.752]                   name <- added[[kk]]
[16:05:10.752]                   NAME <- NAMES[[kk]]
[16:05:10.752]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.752]                     next
[16:05:10.752]                   args[[name]] <- ""
[16:05:10.752]                 }
[16:05:10.752]                 NAMES <- toupper(removed)
[16:05:10.752]                 for (kk in seq_along(NAMES)) {
[16:05:10.752]                   name <- removed[[kk]]
[16:05:10.752]                   NAME <- NAMES[[kk]]
[16:05:10.752]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.752]                     next
[16:05:10.752]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.752]                 }
[16:05:10.752]                 if (length(args) > 0) 
[16:05:10.752]                   base::do.call(base::Sys.setenv, args = args)
[16:05:10.752]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:10.752]             }
[16:05:10.752]             else {
[16:05:10.752]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:10.752]             }
[16:05:10.752]             {
[16:05:10.752]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:10.752]                   0L) {
[16:05:10.752]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:10.752]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:10.752]                   base::options(opts)
[16:05:10.752]                 }
[16:05:10.752]                 {
[16:05:10.752]                   {
[16:05:10.752]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:10.752]                     NULL
[16:05:10.752]                   }
[16:05:10.752]                   options(future.plan = NULL)
[16:05:10.752]                   if (is.na(NA_character_)) 
[16:05:10.752]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.752]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:10.752]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:10.752]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:10.752]                     envir = parent.frame()) 
[16:05:10.752]                   {
[16:05:10.752]                     if (is.function(workers)) 
[16:05:10.752]                       workers <- workers()
[16:05:10.752]                     workers <- structure(as.integer(workers), 
[16:05:10.752]                       class = class(workers))
[16:05:10.752]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:10.752]                       workers >= 1)
[16:05:10.752]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:10.752]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:10.752]                     }
[16:05:10.752]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:10.752]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:10.752]                       envir = envir)
[16:05:10.752]                     if (!future$lazy) 
[16:05:10.752]                       future <- run(future)
[16:05:10.752]                     invisible(future)
[16:05:10.752]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:10.752]                 }
[16:05:10.752]             }
[16:05:10.752]         }
[16:05:10.752]     })
[16:05:10.752]     if (TRUE) {
[16:05:10.752]         base::sink(type = "output", split = FALSE)
[16:05:10.752]         if (TRUE) {
[16:05:10.752]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:10.752]         }
[16:05:10.752]         else {
[16:05:10.752]             ...future.result["stdout"] <- base::list(NULL)
[16:05:10.752]         }
[16:05:10.752]         base::close(...future.stdout)
[16:05:10.752]         ...future.stdout <- NULL
[16:05:10.752]     }
[16:05:10.752]     ...future.result$conditions <- ...future.conditions
[16:05:10.752]     ...future.result$finished <- base::Sys.time()
[16:05:10.752]     ...future.result
[16:05:10.752] }
[16:05:10.755] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[16:05:10.755] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:05:10.756] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:05:10.756] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:05:10.756] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:05:10.756] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[16:05:10.757] MultisessionFuture started
[16:05:10.757] - Launch lazy future ... done
[16:05:10.757] run() for ‘MultisessionFuture’ ... done
[16:05:10.757] result() for ClusterFuture ...
[16:05:10.757] receiveMessageFromWorker() for ClusterFuture ...
[16:05:10.757] - Validating connection of MultisessionFuture
[16:05:10.804] - received message: FutureResult
[16:05:10.804] - Received FutureResult
[16:05:10.804] - Erased future from FutureRegistry
[16:05:10.804] result() for ClusterFuture ...
[16:05:10.805] - result already collected: FutureResult
[16:05:10.805] result() for ClusterFuture ... done
[16:05:10.805] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:10.805] result() for ClusterFuture ... done
[16:05:10.805] result() for ClusterFuture ...
[16:05:10.805] - result already collected: FutureResult
[16:05:10.805] result() for ClusterFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:10.806] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:10.806] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:10.806] 
[16:05:10.806] Searching for globals ... DONE
[16:05:10.806] - globals: [0] <none>
[16:05:10.807] getGlobalsAndPackages() ... DONE
[16:05:10.807] run() for ‘Future’ ...
[16:05:10.807] - state: ‘created’
[16:05:10.807] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:10.821] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:10.821] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:10.821]   - Field: ‘node’
[16:05:10.821]   - Field: ‘label’
[16:05:10.821]   - Field: ‘local’
[16:05:10.821]   - Field: ‘owner’
[16:05:10.822]   - Field: ‘envir’
[16:05:10.822]   - Field: ‘workers’
[16:05:10.822]   - Field: ‘packages’
[16:05:10.822]   - Field: ‘gc’
[16:05:10.822]   - Field: ‘conditions’
[16:05:10.822]   - Field: ‘persistent’
[16:05:10.822]   - Field: ‘expr’
[16:05:10.822]   - Field: ‘uuid’
[16:05:10.822]   - Field: ‘seed’
[16:05:10.822]   - Field: ‘version’
[16:05:10.822]   - Field: ‘result’
[16:05:10.823]   - Field: ‘asynchronous’
[16:05:10.823]   - Field: ‘calls’
[16:05:10.823]   - Field: ‘globals’
[16:05:10.823]   - Field: ‘stdout’
[16:05:10.823]   - Field: ‘earlySignal’
[16:05:10.823]   - Field: ‘lazy’
[16:05:10.823]   - Field: ‘state’
[16:05:10.823] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:10.823] - Launch lazy future ...
[16:05:10.824] Packages needed by the future expression (n = 0): <none>
[16:05:10.824] Packages needed by future strategies (n = 0): <none>
[16:05:10.824] {
[16:05:10.824]     {
[16:05:10.824]         {
[16:05:10.824]             ...future.startTime <- base::Sys.time()
[16:05:10.824]             {
[16:05:10.824]                 {
[16:05:10.824]                   {
[16:05:10.824]                     {
[16:05:10.824]                       base::local({
[16:05:10.824]                         has_future <- base::requireNamespace("future", 
[16:05:10.824]                           quietly = TRUE)
[16:05:10.824]                         if (has_future) {
[16:05:10.824]                           ns <- base::getNamespace("future")
[16:05:10.824]                           version <- ns[[".package"]][["version"]]
[16:05:10.824]                           if (is.null(version)) 
[16:05:10.824]                             version <- utils::packageVersion("future")
[16:05:10.824]                         }
[16:05:10.824]                         else {
[16:05:10.824]                           version <- NULL
[16:05:10.824]                         }
[16:05:10.824]                         if (!has_future || version < "1.8.0") {
[16:05:10.824]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:10.824]                             "", base::R.version$version.string), 
[16:05:10.824]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:10.824]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:10.824]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:10.824]                               "release", "version")], collapse = " "), 
[16:05:10.824]                             hostname = base::Sys.info()[["nodename"]])
[16:05:10.824]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:10.824]                             info)
[16:05:10.824]                           info <- base::paste(info, collapse = "; ")
[16:05:10.824]                           if (!has_future) {
[16:05:10.824]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:10.824]                               info)
[16:05:10.824]                           }
[16:05:10.824]                           else {
[16:05:10.824]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:10.824]                               info, version)
[16:05:10.824]                           }
[16:05:10.824]                           base::stop(msg)
[16:05:10.824]                         }
[16:05:10.824]                       })
[16:05:10.824]                     }
[16:05:10.824]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:10.824]                     base::options(mc.cores = 1L)
[16:05:10.824]                   }
[16:05:10.824]                   options(future.plan = NULL)
[16:05:10.824]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.824]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:10.824]                 }
[16:05:10.824]                 ...future.workdir <- getwd()
[16:05:10.824]             }
[16:05:10.824]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:10.824]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:10.824]         }
[16:05:10.824]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:10.824]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:10.824]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:10.824]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:10.824]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:10.824]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:10.824]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:10.824]             base::names(...future.oldOptions))
[16:05:10.824]     }
[16:05:10.824]     if (FALSE) {
[16:05:10.824]     }
[16:05:10.824]     else {
[16:05:10.824]         if (TRUE) {
[16:05:10.824]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:10.824]                 open = "w")
[16:05:10.824]         }
[16:05:10.824]         else {
[16:05:10.824]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:10.824]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:10.824]         }
[16:05:10.824]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:10.824]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:10.824]             base::sink(type = "output", split = FALSE)
[16:05:10.824]             base::close(...future.stdout)
[16:05:10.824]         }, add = TRUE)
[16:05:10.824]     }
[16:05:10.824]     ...future.frame <- base::sys.nframe()
[16:05:10.824]     ...future.conditions <- base::list()
[16:05:10.824]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:10.824]     if (FALSE) {
[16:05:10.824]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:10.824]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:10.824]     }
[16:05:10.824]     ...future.result <- base::tryCatch({
[16:05:10.824]         base::withCallingHandlers({
[16:05:10.824]             ...future.value <- base::withVisible(base::local({
[16:05:10.824]                 ...future.makeSendCondition <- base::local({
[16:05:10.824]                   sendCondition <- NULL
[16:05:10.824]                   function(frame = 1L) {
[16:05:10.824]                     if (is.function(sendCondition)) 
[16:05:10.824]                       return(sendCondition)
[16:05:10.824]                     ns <- getNamespace("parallel")
[16:05:10.824]                     if (exists("sendData", mode = "function", 
[16:05:10.824]                       envir = ns)) {
[16:05:10.824]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:10.824]                         envir = ns)
[16:05:10.824]                       envir <- sys.frame(frame)
[16:05:10.824]                       master <- NULL
[16:05:10.824]                       while (!identical(envir, .GlobalEnv) && 
[16:05:10.824]                         !identical(envir, emptyenv())) {
[16:05:10.824]                         if (exists("master", mode = "list", envir = envir, 
[16:05:10.824]                           inherits = FALSE)) {
[16:05:10.824]                           master <- get("master", mode = "list", 
[16:05:10.824]                             envir = envir, inherits = FALSE)
[16:05:10.824]                           if (inherits(master, c("SOCKnode", 
[16:05:10.824]                             "SOCK0node"))) {
[16:05:10.824]                             sendCondition <<- function(cond) {
[16:05:10.824]                               data <- list(type = "VALUE", value = cond, 
[16:05:10.824]                                 success = TRUE)
[16:05:10.824]                               parallel_sendData(master, data)
[16:05:10.824]                             }
[16:05:10.824]                             return(sendCondition)
[16:05:10.824]                           }
[16:05:10.824]                         }
[16:05:10.824]                         frame <- frame + 1L
[16:05:10.824]                         envir <- sys.frame(frame)
[16:05:10.824]                       }
[16:05:10.824]                     }
[16:05:10.824]                     sendCondition <<- function(cond) NULL
[16:05:10.824]                   }
[16:05:10.824]                 })
[16:05:10.824]                 withCallingHandlers({
[16:05:10.824]                   1
[16:05:10.824]                 }, immediateCondition = function(cond) {
[16:05:10.824]                   sendCondition <- ...future.makeSendCondition()
[16:05:10.824]                   sendCondition(cond)
[16:05:10.824]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.824]                   {
[16:05:10.824]                     inherits <- base::inherits
[16:05:10.824]                     invokeRestart <- base::invokeRestart
[16:05:10.824]                     is.null <- base::is.null
[16:05:10.824]                     muffled <- FALSE
[16:05:10.824]                     if (inherits(cond, "message")) {
[16:05:10.824]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:10.824]                       if (muffled) 
[16:05:10.824]                         invokeRestart("muffleMessage")
[16:05:10.824]                     }
[16:05:10.824]                     else if (inherits(cond, "warning")) {
[16:05:10.824]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:10.824]                       if (muffled) 
[16:05:10.824]                         invokeRestart("muffleWarning")
[16:05:10.824]                     }
[16:05:10.824]                     else if (inherits(cond, "condition")) {
[16:05:10.824]                       if (!is.null(pattern)) {
[16:05:10.824]                         computeRestarts <- base::computeRestarts
[16:05:10.824]                         grepl <- base::grepl
[16:05:10.824]                         restarts <- computeRestarts(cond)
[16:05:10.824]                         for (restart in restarts) {
[16:05:10.824]                           name <- restart$name
[16:05:10.824]                           if (is.null(name)) 
[16:05:10.824]                             next
[16:05:10.824]                           if (!grepl(pattern, name)) 
[16:05:10.824]                             next
[16:05:10.824]                           invokeRestart(restart)
[16:05:10.824]                           muffled <- TRUE
[16:05:10.824]                           break
[16:05:10.824]                         }
[16:05:10.824]                       }
[16:05:10.824]                     }
[16:05:10.824]                     invisible(muffled)
[16:05:10.824]                   }
[16:05:10.824]                   muffleCondition(cond)
[16:05:10.824]                 })
[16:05:10.824]             }))
[16:05:10.824]             future::FutureResult(value = ...future.value$value, 
[16:05:10.824]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.824]                   ...future.rng), globalenv = if (FALSE) 
[16:05:10.824]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:10.824]                     ...future.globalenv.names))
[16:05:10.824]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:10.824]         }, condition = base::local({
[16:05:10.824]             c <- base::c
[16:05:10.824]             inherits <- base::inherits
[16:05:10.824]             invokeRestart <- base::invokeRestart
[16:05:10.824]             length <- base::length
[16:05:10.824]             list <- base::list
[16:05:10.824]             seq.int <- base::seq.int
[16:05:10.824]             signalCondition <- base::signalCondition
[16:05:10.824]             sys.calls <- base::sys.calls
[16:05:10.824]             `[[` <- base::`[[`
[16:05:10.824]             `+` <- base::`+`
[16:05:10.824]             `<<-` <- base::`<<-`
[16:05:10.824]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:10.824]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:10.824]                   3L)]
[16:05:10.824]             }
[16:05:10.824]             function(cond) {
[16:05:10.824]                 is_error <- inherits(cond, "error")
[16:05:10.824]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:10.824]                   NULL)
[16:05:10.824]                 if (is_error) {
[16:05:10.824]                   sessionInformation <- function() {
[16:05:10.824]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:10.824]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:10.824]                       search = base::search(), system = base::Sys.info())
[16:05:10.824]                   }
[16:05:10.824]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.824]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:10.824]                     cond$call), session = sessionInformation(), 
[16:05:10.824]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:10.824]                   signalCondition(cond)
[16:05:10.824]                 }
[16:05:10.824]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:10.824]                 "immediateCondition"))) {
[16:05:10.824]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:10.824]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.824]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:10.824]                   if (TRUE && !signal) {
[16:05:10.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.824]                     {
[16:05:10.824]                       inherits <- base::inherits
[16:05:10.824]                       invokeRestart <- base::invokeRestart
[16:05:10.824]                       is.null <- base::is.null
[16:05:10.824]                       muffled <- FALSE
[16:05:10.824]                       if (inherits(cond, "message")) {
[16:05:10.824]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.824]                         if (muffled) 
[16:05:10.824]                           invokeRestart("muffleMessage")
[16:05:10.824]                       }
[16:05:10.824]                       else if (inherits(cond, "warning")) {
[16:05:10.824]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.824]                         if (muffled) 
[16:05:10.824]                           invokeRestart("muffleWarning")
[16:05:10.824]                       }
[16:05:10.824]                       else if (inherits(cond, "condition")) {
[16:05:10.824]                         if (!is.null(pattern)) {
[16:05:10.824]                           computeRestarts <- base::computeRestarts
[16:05:10.824]                           grepl <- base::grepl
[16:05:10.824]                           restarts <- computeRestarts(cond)
[16:05:10.824]                           for (restart in restarts) {
[16:05:10.824]                             name <- restart$name
[16:05:10.824]                             if (is.null(name)) 
[16:05:10.824]                               next
[16:05:10.824]                             if (!grepl(pattern, name)) 
[16:05:10.824]                               next
[16:05:10.824]                             invokeRestart(restart)
[16:05:10.824]                             muffled <- TRUE
[16:05:10.824]                             break
[16:05:10.824]                           }
[16:05:10.824]                         }
[16:05:10.824]                       }
[16:05:10.824]                       invisible(muffled)
[16:05:10.824]                     }
[16:05:10.824]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.824]                   }
[16:05:10.824]                 }
[16:05:10.824]                 else {
[16:05:10.824]                   if (TRUE) {
[16:05:10.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.824]                     {
[16:05:10.824]                       inherits <- base::inherits
[16:05:10.824]                       invokeRestart <- base::invokeRestart
[16:05:10.824]                       is.null <- base::is.null
[16:05:10.824]                       muffled <- FALSE
[16:05:10.824]                       if (inherits(cond, "message")) {
[16:05:10.824]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.824]                         if (muffled) 
[16:05:10.824]                           invokeRestart("muffleMessage")
[16:05:10.824]                       }
[16:05:10.824]                       else if (inherits(cond, "warning")) {
[16:05:10.824]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.824]                         if (muffled) 
[16:05:10.824]                           invokeRestart("muffleWarning")
[16:05:10.824]                       }
[16:05:10.824]                       else if (inherits(cond, "condition")) {
[16:05:10.824]                         if (!is.null(pattern)) {
[16:05:10.824]                           computeRestarts <- base::computeRestarts
[16:05:10.824]                           grepl <- base::grepl
[16:05:10.824]                           restarts <- computeRestarts(cond)
[16:05:10.824]                           for (restart in restarts) {
[16:05:10.824]                             name <- restart$name
[16:05:10.824]                             if (is.null(name)) 
[16:05:10.824]                               next
[16:05:10.824]                             if (!grepl(pattern, name)) 
[16:05:10.824]                               next
[16:05:10.824]                             invokeRestart(restart)
[16:05:10.824]                             muffled <- TRUE
[16:05:10.824]                             break
[16:05:10.824]                           }
[16:05:10.824]                         }
[16:05:10.824]                       }
[16:05:10.824]                       invisible(muffled)
[16:05:10.824]                     }
[16:05:10.824]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.824]                   }
[16:05:10.824]                 }
[16:05:10.824]             }
[16:05:10.824]         }))
[16:05:10.824]     }, error = function(ex) {
[16:05:10.824]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:10.824]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.824]                 ...future.rng), started = ...future.startTime, 
[16:05:10.824]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:10.824]             version = "1.8"), class = "FutureResult")
[16:05:10.824]     }, finally = {
[16:05:10.824]         if (!identical(...future.workdir, getwd())) 
[16:05:10.824]             setwd(...future.workdir)
[16:05:10.824]         {
[16:05:10.824]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:10.824]                 ...future.oldOptions$nwarnings <- NULL
[16:05:10.824]             }
[16:05:10.824]             base::options(...future.oldOptions)
[16:05:10.824]             if (.Platform$OS.type == "windows") {
[16:05:10.824]                 old_names <- names(...future.oldEnvVars)
[16:05:10.824]                 envs <- base::Sys.getenv()
[16:05:10.824]                 names <- names(envs)
[16:05:10.824]                 common <- intersect(names, old_names)
[16:05:10.824]                 added <- setdiff(names, old_names)
[16:05:10.824]                 removed <- setdiff(old_names, names)
[16:05:10.824]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:10.824]                   envs[common]]
[16:05:10.824]                 NAMES <- toupper(changed)
[16:05:10.824]                 args <- list()
[16:05:10.824]                 for (kk in seq_along(NAMES)) {
[16:05:10.824]                   name <- changed[[kk]]
[16:05:10.824]                   NAME <- NAMES[[kk]]
[16:05:10.824]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.824]                     next
[16:05:10.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.824]                 }
[16:05:10.824]                 NAMES <- toupper(added)
[16:05:10.824]                 for (kk in seq_along(NAMES)) {
[16:05:10.824]                   name <- added[[kk]]
[16:05:10.824]                   NAME <- NAMES[[kk]]
[16:05:10.824]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.824]                     next
[16:05:10.824]                   args[[name]] <- ""
[16:05:10.824]                 }
[16:05:10.824]                 NAMES <- toupper(removed)
[16:05:10.824]                 for (kk in seq_along(NAMES)) {
[16:05:10.824]                   name <- removed[[kk]]
[16:05:10.824]                   NAME <- NAMES[[kk]]
[16:05:10.824]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.824]                     next
[16:05:10.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.824]                 }
[16:05:10.824]                 if (length(args) > 0) 
[16:05:10.824]                   base::do.call(base::Sys.setenv, args = args)
[16:05:10.824]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:10.824]             }
[16:05:10.824]             else {
[16:05:10.824]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:10.824]             }
[16:05:10.824]             {
[16:05:10.824]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:10.824]                   0L) {
[16:05:10.824]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:10.824]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:10.824]                   base::options(opts)
[16:05:10.824]                 }
[16:05:10.824]                 {
[16:05:10.824]                   {
[16:05:10.824]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:10.824]                     NULL
[16:05:10.824]                   }
[16:05:10.824]                   options(future.plan = NULL)
[16:05:10.824]                   if (is.na(NA_character_)) 
[16:05:10.824]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.824]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:10.824]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:10.824]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:10.824]                     envir = parent.frame()) 
[16:05:10.824]                   {
[16:05:10.824]                     if (is.function(workers)) 
[16:05:10.824]                       workers <- workers()
[16:05:10.824]                     workers <- structure(as.integer(workers), 
[16:05:10.824]                       class = class(workers))
[16:05:10.824]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:10.824]                       workers >= 1)
[16:05:10.824]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:10.824]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:10.824]                     }
[16:05:10.824]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:10.824]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:10.824]                       envir = envir)
[16:05:10.824]                     if (!future$lazy) 
[16:05:10.824]                       future <- run(future)
[16:05:10.824]                     invisible(future)
[16:05:10.824]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:10.824]                 }
[16:05:10.824]             }
[16:05:10.824]         }
[16:05:10.824]     })
[16:05:10.824]     if (TRUE) {
[16:05:10.824]         base::sink(type = "output", split = FALSE)
[16:05:10.824]         if (TRUE) {
[16:05:10.824]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:10.824]         }
[16:05:10.824]         else {
[16:05:10.824]             ...future.result["stdout"] <- base::list(NULL)
[16:05:10.824]         }
[16:05:10.824]         base::close(...future.stdout)
[16:05:10.824]         ...future.stdout <- NULL
[16:05:10.824]     }
[16:05:10.824]     ...future.result$conditions <- ...future.conditions
[16:05:10.824]     ...future.result$finished <- base::Sys.time()
[16:05:10.824]     ...future.result
[16:05:10.824] }
[16:05:10.827] MultisessionFuture started
[16:05:10.828] - Launch lazy future ... done
[16:05:10.828] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:10.828] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:10.828] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:10.829] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:10.829] Searching for globals ... DONE
[16:05:10.829] Resolving globals: TRUE
[16:05:10.829] Resolving any globals that are futures ...
[16:05:10.829] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:10.829] Resolving any globals that are futures ... DONE
[16:05:10.830] Resolving futures part of globals (recursively) ...
[16:05:10.830] resolve() on list ...
[16:05:10.830]  recursive: 99
[16:05:10.830]  length: 1
[16:05:10.830]  elements: ‘a’
[16:05:10.876] receiveMessageFromWorker() for ClusterFuture ...
[16:05:10.876] - Validating connection of MultisessionFuture
[16:05:10.876] - received message: FutureResult
[16:05:10.876] - Received FutureResult
[16:05:10.877] - Erased future from FutureRegistry
[16:05:10.877] result() for ClusterFuture ...
[16:05:10.877] - result already collected: FutureResult
[16:05:10.877] result() for ClusterFuture ... done
[16:05:10.877] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:10.877] Future #1
[16:05:10.877] result() for ClusterFuture ...
[16:05:10.877] - result already collected: FutureResult
[16:05:10.877] result() for ClusterFuture ... done
[16:05:10.877] result() for ClusterFuture ...
[16:05:10.878] - result already collected: FutureResult
[16:05:10.878] result() for ClusterFuture ... done
[16:05:10.878] A MultisessionFuture was resolved
[16:05:10.878]  length: 0 (resolved future 1)
[16:05:10.878] resolve() on list ... DONE
[16:05:10.878] - globals: [1] ‘a’
[16:05:10.878] Resolving futures part of globals (recursively) ... DONE
[16:05:10.880] The total size of the 1 globals is 1.56 MiB (1640840 bytes)
[16:05:10.881] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.56 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.56 MiB of class ‘environment’)
[16:05:10.881] - globals: [1] ‘a’
[16:05:10.881] - packages: [1] ‘future’
[16:05:10.881] getGlobalsAndPackages() ... DONE
[16:05:10.881] run() for ‘Future’ ...
[16:05:10.881] - state: ‘created’
[16:05:10.882] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:10.896] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:10.896] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:10.896]   - Field: ‘node’
[16:05:10.896]   - Field: ‘label’
[16:05:10.896]   - Field: ‘local’
[16:05:10.896]   - Field: ‘owner’
[16:05:10.896]   - Field: ‘envir’
[16:05:10.897]   - Field: ‘workers’
[16:05:10.897]   - Field: ‘packages’
[16:05:10.897]   - Field: ‘gc’
[16:05:10.897]   - Field: ‘conditions’
[16:05:10.897]   - Field: ‘persistent’
[16:05:10.897]   - Field: ‘expr’
[16:05:10.897]   - Field: ‘uuid’
[16:05:10.897]   - Field: ‘seed’
[16:05:10.897]   - Field: ‘version’
[16:05:10.897]   - Field: ‘result’
[16:05:10.898]   - Field: ‘asynchronous’
[16:05:10.898]   - Field: ‘calls’
[16:05:10.898]   - Field: ‘globals’
[16:05:10.898]   - Field: ‘stdout’
[16:05:10.898]   - Field: ‘earlySignal’
[16:05:10.898]   - Field: ‘lazy’
[16:05:10.898]   - Field: ‘state’
[16:05:10.898] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:10.898] - Launch lazy future ...
[16:05:10.899] Packages needed by the future expression (n = 1): ‘future’
[16:05:10.899] Packages needed by future strategies (n = 0): <none>
[16:05:10.899] {
[16:05:10.899]     {
[16:05:10.899]         {
[16:05:10.899]             ...future.startTime <- base::Sys.time()
[16:05:10.899]             {
[16:05:10.899]                 {
[16:05:10.899]                   {
[16:05:10.899]                     {
[16:05:10.899]                       {
[16:05:10.899]                         base::local({
[16:05:10.899]                           has_future <- base::requireNamespace("future", 
[16:05:10.899]                             quietly = TRUE)
[16:05:10.899]                           if (has_future) {
[16:05:10.899]                             ns <- base::getNamespace("future")
[16:05:10.899]                             version <- ns[[".package"]][["version"]]
[16:05:10.899]                             if (is.null(version)) 
[16:05:10.899]                               version <- utils::packageVersion("future")
[16:05:10.899]                           }
[16:05:10.899]                           else {
[16:05:10.899]                             version <- NULL
[16:05:10.899]                           }
[16:05:10.899]                           if (!has_future || version < "1.8.0") {
[16:05:10.899]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:10.899]                               "", base::R.version$version.string), 
[16:05:10.899]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:10.899]                                 base::R.version$platform, 8 * 
[16:05:10.899]                                   base::.Machine$sizeof.pointer), 
[16:05:10.899]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:10.899]                                 "release", "version")], collapse = " "), 
[16:05:10.899]                               hostname = base::Sys.info()[["nodename"]])
[16:05:10.899]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:10.899]                               info)
[16:05:10.899]                             info <- base::paste(info, collapse = "; ")
[16:05:10.899]                             if (!has_future) {
[16:05:10.899]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:10.899]                                 info)
[16:05:10.899]                             }
[16:05:10.899]                             else {
[16:05:10.899]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:10.899]                                 info, version)
[16:05:10.899]                             }
[16:05:10.899]                             base::stop(msg)
[16:05:10.899]                           }
[16:05:10.899]                         })
[16:05:10.899]                       }
[16:05:10.899]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:10.899]                       base::options(mc.cores = 1L)
[16:05:10.899]                     }
[16:05:10.899]                     base::local({
[16:05:10.899]                       for (pkg in "future") {
[16:05:10.899]                         base::loadNamespace(pkg)
[16:05:10.899]                         base::library(pkg, character.only = TRUE)
[16:05:10.899]                       }
[16:05:10.899]                     })
[16:05:10.899]                   }
[16:05:10.899]                   options(future.plan = NULL)
[16:05:10.899]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.899]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:10.899]                 }
[16:05:10.899]                 ...future.workdir <- getwd()
[16:05:10.899]             }
[16:05:10.899]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:10.899]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:10.899]         }
[16:05:10.899]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:10.899]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:10.899]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:10.899]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:10.899]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:10.899]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:10.899]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:10.899]             base::names(...future.oldOptions))
[16:05:10.899]     }
[16:05:10.899]     if (FALSE) {
[16:05:10.899]     }
[16:05:10.899]     else {
[16:05:10.899]         if (TRUE) {
[16:05:10.899]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:10.899]                 open = "w")
[16:05:10.899]         }
[16:05:10.899]         else {
[16:05:10.899]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:10.899]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:10.899]         }
[16:05:10.899]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:10.899]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:10.899]             base::sink(type = "output", split = FALSE)
[16:05:10.899]             base::close(...future.stdout)
[16:05:10.899]         }, add = TRUE)
[16:05:10.899]     }
[16:05:10.899]     ...future.frame <- base::sys.nframe()
[16:05:10.899]     ...future.conditions <- base::list()
[16:05:10.899]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:10.899]     if (FALSE) {
[16:05:10.899]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:10.899]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:10.899]     }
[16:05:10.899]     ...future.result <- base::tryCatch({
[16:05:10.899]         base::withCallingHandlers({
[16:05:10.899]             ...future.value <- base::withVisible(base::local({
[16:05:10.899]                 ...future.makeSendCondition <- base::local({
[16:05:10.899]                   sendCondition <- NULL
[16:05:10.899]                   function(frame = 1L) {
[16:05:10.899]                     if (is.function(sendCondition)) 
[16:05:10.899]                       return(sendCondition)
[16:05:10.899]                     ns <- getNamespace("parallel")
[16:05:10.899]                     if (exists("sendData", mode = "function", 
[16:05:10.899]                       envir = ns)) {
[16:05:10.899]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:10.899]                         envir = ns)
[16:05:10.899]                       envir <- sys.frame(frame)
[16:05:10.899]                       master <- NULL
[16:05:10.899]                       while (!identical(envir, .GlobalEnv) && 
[16:05:10.899]                         !identical(envir, emptyenv())) {
[16:05:10.899]                         if (exists("master", mode = "list", envir = envir, 
[16:05:10.899]                           inherits = FALSE)) {
[16:05:10.899]                           master <- get("master", mode = "list", 
[16:05:10.899]                             envir = envir, inherits = FALSE)
[16:05:10.899]                           if (inherits(master, c("SOCKnode", 
[16:05:10.899]                             "SOCK0node"))) {
[16:05:10.899]                             sendCondition <<- function(cond) {
[16:05:10.899]                               data <- list(type = "VALUE", value = cond, 
[16:05:10.899]                                 success = TRUE)
[16:05:10.899]                               parallel_sendData(master, data)
[16:05:10.899]                             }
[16:05:10.899]                             return(sendCondition)
[16:05:10.899]                           }
[16:05:10.899]                         }
[16:05:10.899]                         frame <- frame + 1L
[16:05:10.899]                         envir <- sys.frame(frame)
[16:05:10.899]                       }
[16:05:10.899]                     }
[16:05:10.899]                     sendCondition <<- function(cond) NULL
[16:05:10.899]                   }
[16:05:10.899]                 })
[16:05:10.899]                 withCallingHandlers({
[16:05:10.899]                   value(a) + 1
[16:05:10.899]                 }, immediateCondition = function(cond) {
[16:05:10.899]                   sendCondition <- ...future.makeSendCondition()
[16:05:10.899]                   sendCondition(cond)
[16:05:10.899]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.899]                   {
[16:05:10.899]                     inherits <- base::inherits
[16:05:10.899]                     invokeRestart <- base::invokeRestart
[16:05:10.899]                     is.null <- base::is.null
[16:05:10.899]                     muffled <- FALSE
[16:05:10.899]                     if (inherits(cond, "message")) {
[16:05:10.899]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:10.899]                       if (muffled) 
[16:05:10.899]                         invokeRestart("muffleMessage")
[16:05:10.899]                     }
[16:05:10.899]                     else if (inherits(cond, "warning")) {
[16:05:10.899]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:10.899]                       if (muffled) 
[16:05:10.899]                         invokeRestart("muffleWarning")
[16:05:10.899]                     }
[16:05:10.899]                     else if (inherits(cond, "condition")) {
[16:05:10.899]                       if (!is.null(pattern)) {
[16:05:10.899]                         computeRestarts <- base::computeRestarts
[16:05:10.899]                         grepl <- base::grepl
[16:05:10.899]                         restarts <- computeRestarts(cond)
[16:05:10.899]                         for (restart in restarts) {
[16:05:10.899]                           name <- restart$name
[16:05:10.899]                           if (is.null(name)) 
[16:05:10.899]                             next
[16:05:10.899]                           if (!grepl(pattern, name)) 
[16:05:10.899]                             next
[16:05:10.899]                           invokeRestart(restart)
[16:05:10.899]                           muffled <- TRUE
[16:05:10.899]                           break
[16:05:10.899]                         }
[16:05:10.899]                       }
[16:05:10.899]                     }
[16:05:10.899]                     invisible(muffled)
[16:05:10.899]                   }
[16:05:10.899]                   muffleCondition(cond)
[16:05:10.899]                 })
[16:05:10.899]             }))
[16:05:10.899]             future::FutureResult(value = ...future.value$value, 
[16:05:10.899]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.899]                   ...future.rng), globalenv = if (FALSE) 
[16:05:10.899]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:10.899]                     ...future.globalenv.names))
[16:05:10.899]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:10.899]         }, condition = base::local({
[16:05:10.899]             c <- base::c
[16:05:10.899]             inherits <- base::inherits
[16:05:10.899]             invokeRestart <- base::invokeRestart
[16:05:10.899]             length <- base::length
[16:05:10.899]             list <- base::list
[16:05:10.899]             seq.int <- base::seq.int
[16:05:10.899]             signalCondition <- base::signalCondition
[16:05:10.899]             sys.calls <- base::sys.calls
[16:05:10.899]             `[[` <- base::`[[`
[16:05:10.899]             `+` <- base::`+`
[16:05:10.899]             `<<-` <- base::`<<-`
[16:05:10.899]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:10.899]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:10.899]                   3L)]
[16:05:10.899]             }
[16:05:10.899]             function(cond) {
[16:05:10.899]                 is_error <- inherits(cond, "error")
[16:05:10.899]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:10.899]                   NULL)
[16:05:10.899]                 if (is_error) {
[16:05:10.899]                   sessionInformation <- function() {
[16:05:10.899]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:10.899]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:10.899]                       search = base::search(), system = base::Sys.info())
[16:05:10.899]                   }
[16:05:10.899]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.899]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:10.899]                     cond$call), session = sessionInformation(), 
[16:05:10.899]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:10.899]                   signalCondition(cond)
[16:05:10.899]                 }
[16:05:10.899]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:10.899]                 "immediateCondition"))) {
[16:05:10.899]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:10.899]                   ...future.conditions[[length(...future.conditions) + 
[16:05:10.899]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:10.899]                   if (TRUE && !signal) {
[16:05:10.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.899]                     {
[16:05:10.899]                       inherits <- base::inherits
[16:05:10.899]                       invokeRestart <- base::invokeRestart
[16:05:10.899]                       is.null <- base::is.null
[16:05:10.899]                       muffled <- FALSE
[16:05:10.899]                       if (inherits(cond, "message")) {
[16:05:10.899]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.899]                         if (muffled) 
[16:05:10.899]                           invokeRestart("muffleMessage")
[16:05:10.899]                       }
[16:05:10.899]                       else if (inherits(cond, "warning")) {
[16:05:10.899]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.899]                         if (muffled) 
[16:05:10.899]                           invokeRestart("muffleWarning")
[16:05:10.899]                       }
[16:05:10.899]                       else if (inherits(cond, "condition")) {
[16:05:10.899]                         if (!is.null(pattern)) {
[16:05:10.899]                           computeRestarts <- base::computeRestarts
[16:05:10.899]                           grepl <- base::grepl
[16:05:10.899]                           restarts <- computeRestarts(cond)
[16:05:10.899]                           for (restart in restarts) {
[16:05:10.899]                             name <- restart$name
[16:05:10.899]                             if (is.null(name)) 
[16:05:10.899]                               next
[16:05:10.899]                             if (!grepl(pattern, name)) 
[16:05:10.899]                               next
[16:05:10.899]                             invokeRestart(restart)
[16:05:10.899]                             muffled <- TRUE
[16:05:10.899]                             break
[16:05:10.899]                           }
[16:05:10.899]                         }
[16:05:10.899]                       }
[16:05:10.899]                       invisible(muffled)
[16:05:10.899]                     }
[16:05:10.899]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.899]                   }
[16:05:10.899]                 }
[16:05:10.899]                 else {
[16:05:10.899]                   if (TRUE) {
[16:05:10.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:10.899]                     {
[16:05:10.899]                       inherits <- base::inherits
[16:05:10.899]                       invokeRestart <- base::invokeRestart
[16:05:10.899]                       is.null <- base::is.null
[16:05:10.899]                       muffled <- FALSE
[16:05:10.899]                       if (inherits(cond, "message")) {
[16:05:10.899]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:10.899]                         if (muffled) 
[16:05:10.899]                           invokeRestart("muffleMessage")
[16:05:10.899]                       }
[16:05:10.899]                       else if (inherits(cond, "warning")) {
[16:05:10.899]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:10.899]                         if (muffled) 
[16:05:10.899]                           invokeRestart("muffleWarning")
[16:05:10.899]                       }
[16:05:10.899]                       else if (inherits(cond, "condition")) {
[16:05:10.899]                         if (!is.null(pattern)) {
[16:05:10.899]                           computeRestarts <- base::computeRestarts
[16:05:10.899]                           grepl <- base::grepl
[16:05:10.899]                           restarts <- computeRestarts(cond)
[16:05:10.899]                           for (restart in restarts) {
[16:05:10.899]                             name <- restart$name
[16:05:10.899]                             if (is.null(name)) 
[16:05:10.899]                               next
[16:05:10.899]                             if (!grepl(pattern, name)) 
[16:05:10.899]                               next
[16:05:10.899]                             invokeRestart(restart)
[16:05:10.899]                             muffled <- TRUE
[16:05:10.899]                             break
[16:05:10.899]                           }
[16:05:10.899]                         }
[16:05:10.899]                       }
[16:05:10.899]                       invisible(muffled)
[16:05:10.899]                     }
[16:05:10.899]                     muffleCondition(cond, pattern = "^muffle")
[16:05:10.899]                   }
[16:05:10.899]                 }
[16:05:10.899]             }
[16:05:10.899]         }))
[16:05:10.899]     }, error = function(ex) {
[16:05:10.899]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:10.899]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:10.899]                 ...future.rng), started = ...future.startTime, 
[16:05:10.899]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:10.899]             version = "1.8"), class = "FutureResult")
[16:05:10.899]     }, finally = {
[16:05:10.899]         if (!identical(...future.workdir, getwd())) 
[16:05:10.899]             setwd(...future.workdir)
[16:05:10.899]         {
[16:05:10.899]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:10.899]                 ...future.oldOptions$nwarnings <- NULL
[16:05:10.899]             }
[16:05:10.899]             base::options(...future.oldOptions)
[16:05:10.899]             if (.Platform$OS.type == "windows") {
[16:05:10.899]                 old_names <- names(...future.oldEnvVars)
[16:05:10.899]                 envs <- base::Sys.getenv()
[16:05:10.899]                 names <- names(envs)
[16:05:10.899]                 common <- intersect(names, old_names)
[16:05:10.899]                 added <- setdiff(names, old_names)
[16:05:10.899]                 removed <- setdiff(old_names, names)
[16:05:10.899]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:10.899]                   envs[common]]
[16:05:10.899]                 NAMES <- toupper(changed)
[16:05:10.899]                 args <- list()
[16:05:10.899]                 for (kk in seq_along(NAMES)) {
[16:05:10.899]                   name <- changed[[kk]]
[16:05:10.899]                   NAME <- NAMES[[kk]]
[16:05:10.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.899]                     next
[16:05:10.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.899]                 }
[16:05:10.899]                 NAMES <- toupper(added)
[16:05:10.899]                 for (kk in seq_along(NAMES)) {
[16:05:10.899]                   name <- added[[kk]]
[16:05:10.899]                   NAME <- NAMES[[kk]]
[16:05:10.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.899]                     next
[16:05:10.899]                   args[[name]] <- ""
[16:05:10.899]                 }
[16:05:10.899]                 NAMES <- toupper(removed)
[16:05:10.899]                 for (kk in seq_along(NAMES)) {
[16:05:10.899]                   name <- removed[[kk]]
[16:05:10.899]                   NAME <- NAMES[[kk]]
[16:05:10.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:10.899]                     next
[16:05:10.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:10.899]                 }
[16:05:10.899]                 if (length(args) > 0) 
[16:05:10.899]                   base::do.call(base::Sys.setenv, args = args)
[16:05:10.899]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:10.899]             }
[16:05:10.899]             else {
[16:05:10.899]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:10.899]             }
[16:05:10.899]             {
[16:05:10.899]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:10.899]                   0L) {
[16:05:10.899]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:10.899]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:10.899]                   base::options(opts)
[16:05:10.899]                 }
[16:05:10.899]                 {
[16:05:10.899]                   {
[16:05:10.899]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:10.899]                     NULL
[16:05:10.899]                   }
[16:05:10.899]                   options(future.plan = NULL)
[16:05:10.899]                   if (is.na(NA_character_)) 
[16:05:10.899]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:10.899]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:10.899]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:10.899]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:10.899]                     envir = parent.frame()) 
[16:05:10.899]                   {
[16:05:10.899]                     if (is.function(workers)) 
[16:05:10.899]                       workers <- workers()
[16:05:10.899]                     workers <- structure(as.integer(workers), 
[16:05:10.899]                       class = class(workers))
[16:05:10.899]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:10.899]                       workers >= 1)
[16:05:10.899]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:10.899]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:10.899]                     }
[16:05:10.899]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:10.899]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:10.899]                       envir = envir)
[16:05:10.899]                     if (!future$lazy) 
[16:05:10.899]                       future <- run(future)
[16:05:10.899]                     invisible(future)
[16:05:10.899]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:10.899]                 }
[16:05:10.899]             }
[16:05:10.899]         }
[16:05:10.899]     })
[16:05:10.899]     if (TRUE) {
[16:05:10.899]         base::sink(type = "output", split = FALSE)
[16:05:10.899]         if (TRUE) {
[16:05:10.899]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:10.899]         }
[16:05:10.899]         else {
[16:05:10.899]             ...future.result["stdout"] <- base::list(NULL)
[16:05:10.899]         }
[16:05:10.899]         base::close(...future.stdout)
[16:05:10.899]         ...future.stdout <- NULL
[16:05:10.899]     }
[16:05:10.899]     ...future.result$conditions <- ...future.conditions
[16:05:10.899]     ...future.result$finished <- base::Sys.time()
[16:05:10.899]     ...future.result
[16:05:10.899] }
[16:05:10.902] Exporting 1 global objects (1.56 MiB) to cluster node #1 ...
[16:05:10.904] Exporting ‘a’ (1.56 MiB) to cluster node #1 ...
[16:05:10.956] Exporting ‘a’ (1.56 MiB) to cluster node #1 ... DONE
[16:05:10.956] Exporting 1 global objects (1.56 MiB) to cluster node #1 ... DONE
[16:05:10.956] MultisessionFuture started
[16:05:10.957] - Launch lazy future ... done
[16:05:10.957] run() for ‘MultisessionFuture’ ... done
[16:05:10.957] result() for ClusterFuture ...
[16:05:10.957] receiveMessageFromWorker() for ClusterFuture ...
[16:05:10.957] - Validating connection of MultisessionFuture
[16:05:11.008] - received message: FutureResult
[16:05:11.008] - Received FutureResult
[16:05:11.008] - Erased future from FutureRegistry
[16:05:11.009] result() for ClusterFuture ...
[16:05:11.009] - result already collected: FutureResult
[16:05:11.009] result() for ClusterFuture ... done
[16:05:11.009] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:11.009] result() for ClusterFuture ... done
[16:05:11.009] result() for ClusterFuture ...
[16:05:11.009] - result already collected: FutureResult
[16:05:11.009] result() for ClusterFuture ... done
value(b) = 2
[16:05:11.010] result() for ClusterFuture ...
[16:05:11.010] - result already collected: FutureResult
[16:05:11.010] result() for ClusterFuture ... done
[16:05:11.010] result() for ClusterFuture ...
[16:05:11.010] - result already collected: FutureResult
[16:05:11.010] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:11.010] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:11.011] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:11.011] 
[16:05:11.011] Searching for globals ... DONE
[16:05:11.011] - globals: [0] <none>
[16:05:11.011] getGlobalsAndPackages() ... DONE
[16:05:11.012] run() for ‘Future’ ...
[16:05:11.012] - state: ‘created’
[16:05:11.012] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:11.026] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:11.026] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:11.026]   - Field: ‘node’
[16:05:11.026]   - Field: ‘label’
[16:05:11.026]   - Field: ‘local’
[16:05:11.026]   - Field: ‘owner’
[16:05:11.027]   - Field: ‘envir’
[16:05:11.027]   - Field: ‘workers’
[16:05:11.027]   - Field: ‘packages’
[16:05:11.027]   - Field: ‘gc’
[16:05:11.027]   - Field: ‘conditions’
[16:05:11.027]   - Field: ‘persistent’
[16:05:11.027]   - Field: ‘expr’
[16:05:11.027]   - Field: ‘uuid’
[16:05:11.027]   - Field: ‘seed’
[16:05:11.027]   - Field: ‘version’
[16:05:11.028]   - Field: ‘result’
[16:05:11.028]   - Field: ‘asynchronous’
[16:05:11.028]   - Field: ‘calls’
[16:05:11.028]   - Field: ‘globals’
[16:05:11.028]   - Field: ‘stdout’
[16:05:11.028]   - Field: ‘earlySignal’
[16:05:11.028]   - Field: ‘lazy’
[16:05:11.028]   - Field: ‘state’
[16:05:11.028] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:11.028] - Launch lazy future ...
[16:05:11.029] Packages needed by the future expression (n = 0): <none>
[16:05:11.029] Packages needed by future strategies (n = 0): <none>
[16:05:11.029] {
[16:05:11.029]     {
[16:05:11.029]         {
[16:05:11.029]             ...future.startTime <- base::Sys.time()
[16:05:11.029]             {
[16:05:11.029]                 {
[16:05:11.029]                   {
[16:05:11.029]                     {
[16:05:11.029]                       base::local({
[16:05:11.029]                         has_future <- base::requireNamespace("future", 
[16:05:11.029]                           quietly = TRUE)
[16:05:11.029]                         if (has_future) {
[16:05:11.029]                           ns <- base::getNamespace("future")
[16:05:11.029]                           version <- ns[[".package"]][["version"]]
[16:05:11.029]                           if (is.null(version)) 
[16:05:11.029]                             version <- utils::packageVersion("future")
[16:05:11.029]                         }
[16:05:11.029]                         else {
[16:05:11.029]                           version <- NULL
[16:05:11.029]                         }
[16:05:11.029]                         if (!has_future || version < "1.8.0") {
[16:05:11.029]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:11.029]                             "", base::R.version$version.string), 
[16:05:11.029]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:11.029]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:11.029]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:11.029]                               "release", "version")], collapse = " "), 
[16:05:11.029]                             hostname = base::Sys.info()[["nodename"]])
[16:05:11.029]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:11.029]                             info)
[16:05:11.029]                           info <- base::paste(info, collapse = "; ")
[16:05:11.029]                           if (!has_future) {
[16:05:11.029]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:11.029]                               info)
[16:05:11.029]                           }
[16:05:11.029]                           else {
[16:05:11.029]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:11.029]                               info, version)
[16:05:11.029]                           }
[16:05:11.029]                           base::stop(msg)
[16:05:11.029]                         }
[16:05:11.029]                       })
[16:05:11.029]                     }
[16:05:11.029]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:11.029]                     base::options(mc.cores = 1L)
[16:05:11.029]                   }
[16:05:11.029]                   options(future.plan = NULL)
[16:05:11.029]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:11.029]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:11.029]                 }
[16:05:11.029]                 ...future.workdir <- getwd()
[16:05:11.029]             }
[16:05:11.029]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:11.029]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:11.029]         }
[16:05:11.029]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:11.029]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:11.029]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:11.029]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:11.029]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:11.029]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:11.029]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:11.029]             base::names(...future.oldOptions))
[16:05:11.029]     }
[16:05:11.029]     if (FALSE) {
[16:05:11.029]     }
[16:05:11.029]     else {
[16:05:11.029]         if (TRUE) {
[16:05:11.029]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:11.029]                 open = "w")
[16:05:11.029]         }
[16:05:11.029]         else {
[16:05:11.029]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:11.029]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:11.029]         }
[16:05:11.029]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:11.029]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:11.029]             base::sink(type = "output", split = FALSE)
[16:05:11.029]             base::close(...future.stdout)
[16:05:11.029]         }, add = TRUE)
[16:05:11.029]     }
[16:05:11.029]     ...future.frame <- base::sys.nframe()
[16:05:11.029]     ...future.conditions <- base::list()
[16:05:11.029]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:11.029]     if (FALSE) {
[16:05:11.029]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:11.029]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:11.029]     }
[16:05:11.029]     ...future.result <- base::tryCatch({
[16:05:11.029]         base::withCallingHandlers({
[16:05:11.029]             ...future.value <- base::withVisible(base::local({
[16:05:11.029]                 ...future.makeSendCondition <- base::local({
[16:05:11.029]                   sendCondition <- NULL
[16:05:11.029]                   function(frame = 1L) {
[16:05:11.029]                     if (is.function(sendCondition)) 
[16:05:11.029]                       return(sendCondition)
[16:05:11.029]                     ns <- getNamespace("parallel")
[16:05:11.029]                     if (exists("sendData", mode = "function", 
[16:05:11.029]                       envir = ns)) {
[16:05:11.029]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:11.029]                         envir = ns)
[16:05:11.029]                       envir <- sys.frame(frame)
[16:05:11.029]                       master <- NULL
[16:05:11.029]                       while (!identical(envir, .GlobalEnv) && 
[16:05:11.029]                         !identical(envir, emptyenv())) {
[16:05:11.029]                         if (exists("master", mode = "list", envir = envir, 
[16:05:11.029]                           inherits = FALSE)) {
[16:05:11.029]                           master <- get("master", mode = "list", 
[16:05:11.029]                             envir = envir, inherits = FALSE)
[16:05:11.029]                           if (inherits(master, c("SOCKnode", 
[16:05:11.029]                             "SOCK0node"))) {
[16:05:11.029]                             sendCondition <<- function(cond) {
[16:05:11.029]                               data <- list(type = "VALUE", value = cond, 
[16:05:11.029]                                 success = TRUE)
[16:05:11.029]                               parallel_sendData(master, data)
[16:05:11.029]                             }
[16:05:11.029]                             return(sendCondition)
[16:05:11.029]                           }
[16:05:11.029]                         }
[16:05:11.029]                         frame <- frame + 1L
[16:05:11.029]                         envir <- sys.frame(frame)
[16:05:11.029]                       }
[16:05:11.029]                     }
[16:05:11.029]                     sendCondition <<- function(cond) NULL
[16:05:11.029]                   }
[16:05:11.029]                 })
[16:05:11.029]                 withCallingHandlers({
[16:05:11.029]                   1
[16:05:11.029]                 }, immediateCondition = function(cond) {
[16:05:11.029]                   sendCondition <- ...future.makeSendCondition()
[16:05:11.029]                   sendCondition(cond)
[16:05:11.029]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.029]                   {
[16:05:11.029]                     inherits <- base::inherits
[16:05:11.029]                     invokeRestart <- base::invokeRestart
[16:05:11.029]                     is.null <- base::is.null
[16:05:11.029]                     muffled <- FALSE
[16:05:11.029]                     if (inherits(cond, "message")) {
[16:05:11.029]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:11.029]                       if (muffled) 
[16:05:11.029]                         invokeRestart("muffleMessage")
[16:05:11.029]                     }
[16:05:11.029]                     else if (inherits(cond, "warning")) {
[16:05:11.029]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:11.029]                       if (muffled) 
[16:05:11.029]                         invokeRestart("muffleWarning")
[16:05:11.029]                     }
[16:05:11.029]                     else if (inherits(cond, "condition")) {
[16:05:11.029]                       if (!is.null(pattern)) {
[16:05:11.029]                         computeRestarts <- base::computeRestarts
[16:05:11.029]                         grepl <- base::grepl
[16:05:11.029]                         restarts <- computeRestarts(cond)
[16:05:11.029]                         for (restart in restarts) {
[16:05:11.029]                           name <- restart$name
[16:05:11.029]                           if (is.null(name)) 
[16:05:11.029]                             next
[16:05:11.029]                           if (!grepl(pattern, name)) 
[16:05:11.029]                             next
[16:05:11.029]                           invokeRestart(restart)
[16:05:11.029]                           muffled <- TRUE
[16:05:11.029]                           break
[16:05:11.029]                         }
[16:05:11.029]                       }
[16:05:11.029]                     }
[16:05:11.029]                     invisible(muffled)
[16:05:11.029]                   }
[16:05:11.029]                   muffleCondition(cond)
[16:05:11.029]                 })
[16:05:11.029]             }))
[16:05:11.029]             future::FutureResult(value = ...future.value$value, 
[16:05:11.029]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:11.029]                   ...future.rng), globalenv = if (FALSE) 
[16:05:11.029]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:11.029]                     ...future.globalenv.names))
[16:05:11.029]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:11.029]         }, condition = base::local({
[16:05:11.029]             c <- base::c
[16:05:11.029]             inherits <- base::inherits
[16:05:11.029]             invokeRestart <- base::invokeRestart
[16:05:11.029]             length <- base::length
[16:05:11.029]             list <- base::list
[16:05:11.029]             seq.int <- base::seq.int
[16:05:11.029]             signalCondition <- base::signalCondition
[16:05:11.029]             sys.calls <- base::sys.calls
[16:05:11.029]             `[[` <- base::`[[`
[16:05:11.029]             `+` <- base::`+`
[16:05:11.029]             `<<-` <- base::`<<-`
[16:05:11.029]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:11.029]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:11.029]                   3L)]
[16:05:11.029]             }
[16:05:11.029]             function(cond) {
[16:05:11.029]                 is_error <- inherits(cond, "error")
[16:05:11.029]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:11.029]                   NULL)
[16:05:11.029]                 if (is_error) {
[16:05:11.029]                   sessionInformation <- function() {
[16:05:11.029]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:11.029]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:11.029]                       search = base::search(), system = base::Sys.info())
[16:05:11.029]                   }
[16:05:11.029]                   ...future.conditions[[length(...future.conditions) + 
[16:05:11.029]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:11.029]                     cond$call), session = sessionInformation(), 
[16:05:11.029]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:11.029]                   signalCondition(cond)
[16:05:11.029]                 }
[16:05:11.029]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:11.029]                 "immediateCondition"))) {
[16:05:11.029]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:11.029]                   ...future.conditions[[length(...future.conditions) + 
[16:05:11.029]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:11.029]                   if (TRUE && !signal) {
[16:05:11.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.029]                     {
[16:05:11.029]                       inherits <- base::inherits
[16:05:11.029]                       invokeRestart <- base::invokeRestart
[16:05:11.029]                       is.null <- base::is.null
[16:05:11.029]                       muffled <- FALSE
[16:05:11.029]                       if (inherits(cond, "message")) {
[16:05:11.029]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:11.029]                         if (muffled) 
[16:05:11.029]                           invokeRestart("muffleMessage")
[16:05:11.029]                       }
[16:05:11.029]                       else if (inherits(cond, "warning")) {
[16:05:11.029]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:11.029]                         if (muffled) 
[16:05:11.029]                           invokeRestart("muffleWarning")
[16:05:11.029]                       }
[16:05:11.029]                       else if (inherits(cond, "condition")) {
[16:05:11.029]                         if (!is.null(pattern)) {
[16:05:11.029]                           computeRestarts <- base::computeRestarts
[16:05:11.029]                           grepl <- base::grepl
[16:05:11.029]                           restarts <- computeRestarts(cond)
[16:05:11.029]                           for (restart in restarts) {
[16:05:11.029]                             name <- restart$name
[16:05:11.029]                             if (is.null(name)) 
[16:05:11.029]                               next
[16:05:11.029]                             if (!grepl(pattern, name)) 
[16:05:11.029]                               next
[16:05:11.029]                             invokeRestart(restart)
[16:05:11.029]                             muffled <- TRUE
[16:05:11.029]                             break
[16:05:11.029]                           }
[16:05:11.029]                         }
[16:05:11.029]                       }
[16:05:11.029]                       invisible(muffled)
[16:05:11.029]                     }
[16:05:11.029]                     muffleCondition(cond, pattern = "^muffle")
[16:05:11.029]                   }
[16:05:11.029]                 }
[16:05:11.029]                 else {
[16:05:11.029]                   if (TRUE) {
[16:05:11.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.029]                     {
[16:05:11.029]                       inherits <- base::inherits
[16:05:11.029]                       invokeRestart <- base::invokeRestart
[16:05:11.029]                       is.null <- base::is.null
[16:05:11.029]                       muffled <- FALSE
[16:05:11.029]                       if (inherits(cond, "message")) {
[16:05:11.029]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:11.029]                         if (muffled) 
[16:05:11.029]                           invokeRestart("muffleMessage")
[16:05:11.029]                       }
[16:05:11.029]                       else if (inherits(cond, "warning")) {
[16:05:11.029]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:11.029]                         if (muffled) 
[16:05:11.029]                           invokeRestart("muffleWarning")
[16:05:11.029]                       }
[16:05:11.029]                       else if (inherits(cond, "condition")) {
[16:05:11.029]                         if (!is.null(pattern)) {
[16:05:11.029]                           computeRestarts <- base::computeRestarts
[16:05:11.029]                           grepl <- base::grepl
[16:05:11.029]                           restarts <- computeRestarts(cond)
[16:05:11.029]                           for (restart in restarts) {
[16:05:11.029]                             name <- restart$name
[16:05:11.029]                             if (is.null(name)) 
[16:05:11.029]                               next
[16:05:11.029]                             if (!grepl(pattern, name)) 
[16:05:11.029]                               next
[16:05:11.029]                             invokeRestart(restart)
[16:05:11.029]                             muffled <- TRUE
[16:05:11.029]                             break
[16:05:11.029]                           }
[16:05:11.029]                         }
[16:05:11.029]                       }
[16:05:11.029]                       invisible(muffled)
[16:05:11.029]                     }
[16:05:11.029]                     muffleCondition(cond, pattern = "^muffle")
[16:05:11.029]                   }
[16:05:11.029]                 }
[16:05:11.029]             }
[16:05:11.029]         }))
[16:05:11.029]     }, error = function(ex) {
[16:05:11.029]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:11.029]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:11.029]                 ...future.rng), started = ...future.startTime, 
[16:05:11.029]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:11.029]             version = "1.8"), class = "FutureResult")
[16:05:11.029]     }, finally = {
[16:05:11.029]         if (!identical(...future.workdir, getwd())) 
[16:05:11.029]             setwd(...future.workdir)
[16:05:11.029]         {
[16:05:11.029]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:11.029]                 ...future.oldOptions$nwarnings <- NULL
[16:05:11.029]             }
[16:05:11.029]             base::options(...future.oldOptions)
[16:05:11.029]             if (.Platform$OS.type == "windows") {
[16:05:11.029]                 old_names <- names(...future.oldEnvVars)
[16:05:11.029]                 envs <- base::Sys.getenv()
[16:05:11.029]                 names <- names(envs)
[16:05:11.029]                 common <- intersect(names, old_names)
[16:05:11.029]                 added <- setdiff(names, old_names)
[16:05:11.029]                 removed <- setdiff(old_names, names)
[16:05:11.029]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:11.029]                   envs[common]]
[16:05:11.029]                 NAMES <- toupper(changed)
[16:05:11.029]                 args <- list()
[16:05:11.029]                 for (kk in seq_along(NAMES)) {
[16:05:11.029]                   name <- changed[[kk]]
[16:05:11.029]                   NAME <- NAMES[[kk]]
[16:05:11.029]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.029]                     next
[16:05:11.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:11.029]                 }
[16:05:11.029]                 NAMES <- toupper(added)
[16:05:11.029]                 for (kk in seq_along(NAMES)) {
[16:05:11.029]                   name <- added[[kk]]
[16:05:11.029]                   NAME <- NAMES[[kk]]
[16:05:11.029]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.029]                     next
[16:05:11.029]                   args[[name]] <- ""
[16:05:11.029]                 }
[16:05:11.029]                 NAMES <- toupper(removed)
[16:05:11.029]                 for (kk in seq_along(NAMES)) {
[16:05:11.029]                   name <- removed[[kk]]
[16:05:11.029]                   NAME <- NAMES[[kk]]
[16:05:11.029]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.029]                     next
[16:05:11.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:11.029]                 }
[16:05:11.029]                 if (length(args) > 0) 
[16:05:11.029]                   base::do.call(base::Sys.setenv, args = args)
[16:05:11.029]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:11.029]             }
[16:05:11.029]             else {
[16:05:11.029]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:11.029]             }
[16:05:11.029]             {
[16:05:11.029]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:11.029]                   0L) {
[16:05:11.029]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:11.029]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:11.029]                   base::options(opts)
[16:05:11.029]                 }
[16:05:11.029]                 {
[16:05:11.029]                   {
[16:05:11.029]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:11.029]                     NULL
[16:05:11.029]                   }
[16:05:11.029]                   options(future.plan = NULL)
[16:05:11.029]                   if (is.na(NA_character_)) 
[16:05:11.029]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:11.029]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:11.029]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:11.029]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:11.029]                     envir = parent.frame()) 
[16:05:11.029]                   {
[16:05:11.029]                     if (is.function(workers)) 
[16:05:11.029]                       workers <- workers()
[16:05:11.029]                     workers <- structure(as.integer(workers), 
[16:05:11.029]                       class = class(workers))
[16:05:11.029]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:11.029]                       workers >= 1)
[16:05:11.029]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:11.029]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:11.029]                     }
[16:05:11.029]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:11.029]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:11.029]                       envir = envir)
[16:05:11.029]                     if (!future$lazy) 
[16:05:11.029]                       future <- run(future)
[16:05:11.029]                     invisible(future)
[16:05:11.029]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:11.029]                 }
[16:05:11.029]             }
[16:05:11.029]         }
[16:05:11.029]     })
[16:05:11.029]     if (TRUE) {
[16:05:11.029]         base::sink(type = "output", split = FALSE)
[16:05:11.029]         if (TRUE) {
[16:05:11.029]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:11.029]         }
[16:05:11.029]         else {
[16:05:11.029]             ...future.result["stdout"] <- base::list(NULL)
[16:05:11.029]         }
[16:05:11.029]         base::close(...future.stdout)
[16:05:11.029]         ...future.stdout <- NULL
[16:05:11.029]     }
[16:05:11.029]     ...future.result$conditions <- ...future.conditions
[16:05:11.029]     ...future.result$finished <- base::Sys.time()
[16:05:11.029]     ...future.result
[16:05:11.029] }
[16:05:11.033] MultisessionFuture started
[16:05:11.033] - Launch lazy future ... done
[16:05:11.033] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:11.033] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:11.033] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:11.034] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:11.034] Searching for globals ... DONE
[16:05:11.034] Resolving globals: TRUE
[16:05:11.034] Resolving any globals that are futures ...
[16:05:11.034] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:11.035] Resolving any globals that are futures ... DONE
[16:05:11.035] Resolving futures part of globals (recursively) ...
[16:05:11.035] resolve() on list ...
[16:05:11.035]  recursive: 99
[16:05:11.035]  length: 1
[16:05:11.035]  elements: ‘a’
[16:05:11.081] receiveMessageFromWorker() for ClusterFuture ...
[16:05:11.081] - Validating connection of MultisessionFuture
[16:05:11.081] - received message: FutureResult
[16:05:11.082] - Received FutureResult
[16:05:11.082] - Erased future from FutureRegistry
[16:05:11.082] result() for ClusterFuture ...
[16:05:11.082] - result already collected: FutureResult
[16:05:11.082] result() for ClusterFuture ... done
[16:05:11.082] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:11.082] Future #1
[16:05:11.082] result() for ClusterFuture ...
[16:05:11.083] - result already collected: FutureResult
[16:05:11.083] result() for ClusterFuture ... done
[16:05:11.083] result() for ClusterFuture ...
[16:05:11.083] - result already collected: FutureResult
[16:05:11.083] result() for ClusterFuture ... done
[16:05:11.083] A MultisessionFuture was resolved
[16:05:11.083]  length: 0 (resolved future 1)
[16:05:11.083] resolve() on list ... DONE
[16:05:11.083] - globals: [1] ‘a’
[16:05:11.084] Resolving futures part of globals (recursively) ... DONE
[16:05:11.088] The total size of the 1 globals is 1.56 MiB (1640840 bytes)
[16:05:11.088] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.56 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.56 MiB of class ‘environment’)
[16:05:11.088] - globals: [1] ‘a’
[16:05:11.089] - packages: [1] ‘future’
[16:05:11.089] getGlobalsAndPackages() ... DONE
[16:05:11.089] run() for ‘Future’ ...
[16:05:11.089] - state: ‘created’
[16:05:11.089] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:11.103] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:11.103] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:11.103]   - Field: ‘node’
[16:05:11.103]   - Field: ‘label’
[16:05:11.103]   - Field: ‘local’
[16:05:11.104]   - Field: ‘owner’
[16:05:11.104]   - Field: ‘envir’
[16:05:11.104]   - Field: ‘workers’
[16:05:11.104]   - Field: ‘packages’
[16:05:11.104]   - Field: ‘gc’
[16:05:11.104]   - Field: ‘conditions’
[16:05:11.104]   - Field: ‘persistent’
[16:05:11.104]   - Field: ‘expr’
[16:05:11.104]   - Field: ‘uuid’
[16:05:11.104]   - Field: ‘seed’
[16:05:11.105]   - Field: ‘version’
[16:05:11.105]   - Field: ‘result’
[16:05:11.105]   - Field: ‘asynchronous’
[16:05:11.105]   - Field: ‘calls’
[16:05:11.105]   - Field: ‘globals’
[16:05:11.105]   - Field: ‘stdout’
[16:05:11.105]   - Field: ‘earlySignal’
[16:05:11.105]   - Field: ‘lazy’
[16:05:11.105]   - Field: ‘state’
[16:05:11.105] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:11.105] - Launch lazy future ...
[16:05:11.106] Packages needed by the future expression (n = 1): ‘future’
[16:05:11.106] Packages needed by future strategies (n = 0): <none>
[16:05:11.106] {
[16:05:11.106]     {
[16:05:11.106]         {
[16:05:11.106]             ...future.startTime <- base::Sys.time()
[16:05:11.106]             {
[16:05:11.106]                 {
[16:05:11.106]                   {
[16:05:11.106]                     {
[16:05:11.106]                       {
[16:05:11.106]                         base::local({
[16:05:11.106]                           has_future <- base::requireNamespace("future", 
[16:05:11.106]                             quietly = TRUE)
[16:05:11.106]                           if (has_future) {
[16:05:11.106]                             ns <- base::getNamespace("future")
[16:05:11.106]                             version <- ns[[".package"]][["version"]]
[16:05:11.106]                             if (is.null(version)) 
[16:05:11.106]                               version <- utils::packageVersion("future")
[16:05:11.106]                           }
[16:05:11.106]                           else {
[16:05:11.106]                             version <- NULL
[16:05:11.106]                           }
[16:05:11.106]                           if (!has_future || version < "1.8.0") {
[16:05:11.106]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:11.106]                               "", base::R.version$version.string), 
[16:05:11.106]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:11.106]                                 base::R.version$platform, 8 * 
[16:05:11.106]                                   base::.Machine$sizeof.pointer), 
[16:05:11.106]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:11.106]                                 "release", "version")], collapse = " "), 
[16:05:11.106]                               hostname = base::Sys.info()[["nodename"]])
[16:05:11.106]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:11.106]                               info)
[16:05:11.106]                             info <- base::paste(info, collapse = "; ")
[16:05:11.106]                             if (!has_future) {
[16:05:11.106]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:11.106]                                 info)
[16:05:11.106]                             }
[16:05:11.106]                             else {
[16:05:11.106]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:11.106]                                 info, version)
[16:05:11.106]                             }
[16:05:11.106]                             base::stop(msg)
[16:05:11.106]                           }
[16:05:11.106]                         })
[16:05:11.106]                       }
[16:05:11.106]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:11.106]                       base::options(mc.cores = 1L)
[16:05:11.106]                     }
[16:05:11.106]                     base::local({
[16:05:11.106]                       for (pkg in "future") {
[16:05:11.106]                         base::loadNamespace(pkg)
[16:05:11.106]                         base::library(pkg, character.only = TRUE)
[16:05:11.106]                       }
[16:05:11.106]                     })
[16:05:11.106]                   }
[16:05:11.106]                   options(future.plan = NULL)
[16:05:11.106]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:11.106]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:11.106]                 }
[16:05:11.106]                 ...future.workdir <- getwd()
[16:05:11.106]             }
[16:05:11.106]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:11.106]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:11.106]         }
[16:05:11.106]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:11.106]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:11.106]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:11.106]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:11.106]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:11.106]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:11.106]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:11.106]             base::names(...future.oldOptions))
[16:05:11.106]     }
[16:05:11.106]     if (FALSE) {
[16:05:11.106]     }
[16:05:11.106]     else {
[16:05:11.106]         if (TRUE) {
[16:05:11.106]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:11.106]                 open = "w")
[16:05:11.106]         }
[16:05:11.106]         else {
[16:05:11.106]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:11.106]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:11.106]         }
[16:05:11.106]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:11.106]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:11.106]             base::sink(type = "output", split = FALSE)
[16:05:11.106]             base::close(...future.stdout)
[16:05:11.106]         }, add = TRUE)
[16:05:11.106]     }
[16:05:11.106]     ...future.frame <- base::sys.nframe()
[16:05:11.106]     ...future.conditions <- base::list()
[16:05:11.106]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:11.106]     if (FALSE) {
[16:05:11.106]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:11.106]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:11.106]     }
[16:05:11.106]     ...future.result <- base::tryCatch({
[16:05:11.106]         base::withCallingHandlers({
[16:05:11.106]             ...future.value <- base::withVisible(base::local({
[16:05:11.106]                 ...future.makeSendCondition <- base::local({
[16:05:11.106]                   sendCondition <- NULL
[16:05:11.106]                   function(frame = 1L) {
[16:05:11.106]                     if (is.function(sendCondition)) 
[16:05:11.106]                       return(sendCondition)
[16:05:11.106]                     ns <- getNamespace("parallel")
[16:05:11.106]                     if (exists("sendData", mode = "function", 
[16:05:11.106]                       envir = ns)) {
[16:05:11.106]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:11.106]                         envir = ns)
[16:05:11.106]                       envir <- sys.frame(frame)
[16:05:11.106]                       master <- NULL
[16:05:11.106]                       while (!identical(envir, .GlobalEnv) && 
[16:05:11.106]                         !identical(envir, emptyenv())) {
[16:05:11.106]                         if (exists("master", mode = "list", envir = envir, 
[16:05:11.106]                           inherits = FALSE)) {
[16:05:11.106]                           master <- get("master", mode = "list", 
[16:05:11.106]                             envir = envir, inherits = FALSE)
[16:05:11.106]                           if (inherits(master, c("SOCKnode", 
[16:05:11.106]                             "SOCK0node"))) {
[16:05:11.106]                             sendCondition <<- function(cond) {
[16:05:11.106]                               data <- list(type = "VALUE", value = cond, 
[16:05:11.106]                                 success = TRUE)
[16:05:11.106]                               parallel_sendData(master, data)
[16:05:11.106]                             }
[16:05:11.106]                             return(sendCondition)
[16:05:11.106]                           }
[16:05:11.106]                         }
[16:05:11.106]                         frame <- frame + 1L
[16:05:11.106]                         envir <- sys.frame(frame)
[16:05:11.106]                       }
[16:05:11.106]                     }
[16:05:11.106]                     sendCondition <<- function(cond) NULL
[16:05:11.106]                   }
[16:05:11.106]                 })
[16:05:11.106]                 withCallingHandlers({
[16:05:11.106]                   value(a) + 1
[16:05:11.106]                 }, immediateCondition = function(cond) {
[16:05:11.106]                   sendCondition <- ...future.makeSendCondition()
[16:05:11.106]                   sendCondition(cond)
[16:05:11.106]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.106]                   {
[16:05:11.106]                     inherits <- base::inherits
[16:05:11.106]                     invokeRestart <- base::invokeRestart
[16:05:11.106]                     is.null <- base::is.null
[16:05:11.106]                     muffled <- FALSE
[16:05:11.106]                     if (inherits(cond, "message")) {
[16:05:11.106]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:11.106]                       if (muffled) 
[16:05:11.106]                         invokeRestart("muffleMessage")
[16:05:11.106]                     }
[16:05:11.106]                     else if (inherits(cond, "warning")) {
[16:05:11.106]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:11.106]                       if (muffled) 
[16:05:11.106]                         invokeRestart("muffleWarning")
[16:05:11.106]                     }
[16:05:11.106]                     else if (inherits(cond, "condition")) {
[16:05:11.106]                       if (!is.null(pattern)) {
[16:05:11.106]                         computeRestarts <- base::computeRestarts
[16:05:11.106]                         grepl <- base::grepl
[16:05:11.106]                         restarts <- computeRestarts(cond)
[16:05:11.106]                         for (restart in restarts) {
[16:05:11.106]                           name <- restart$name
[16:05:11.106]                           if (is.null(name)) 
[16:05:11.106]                             next
[16:05:11.106]                           if (!grepl(pattern, name)) 
[16:05:11.106]                             next
[16:05:11.106]                           invokeRestart(restart)
[16:05:11.106]                           muffled <- TRUE
[16:05:11.106]                           break
[16:05:11.106]                         }
[16:05:11.106]                       }
[16:05:11.106]                     }
[16:05:11.106]                     invisible(muffled)
[16:05:11.106]                   }
[16:05:11.106]                   muffleCondition(cond)
[16:05:11.106]                 })
[16:05:11.106]             }))
[16:05:11.106]             future::FutureResult(value = ...future.value$value, 
[16:05:11.106]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:11.106]                   ...future.rng), globalenv = if (FALSE) 
[16:05:11.106]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:11.106]                     ...future.globalenv.names))
[16:05:11.106]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:11.106]         }, condition = base::local({
[16:05:11.106]             c <- base::c
[16:05:11.106]             inherits <- base::inherits
[16:05:11.106]             invokeRestart <- base::invokeRestart
[16:05:11.106]             length <- base::length
[16:05:11.106]             list <- base::list
[16:05:11.106]             seq.int <- base::seq.int
[16:05:11.106]             signalCondition <- base::signalCondition
[16:05:11.106]             sys.calls <- base::sys.calls
[16:05:11.106]             `[[` <- base::`[[`
[16:05:11.106]             `+` <- base::`+`
[16:05:11.106]             `<<-` <- base::`<<-`
[16:05:11.106]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:11.106]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:11.106]                   3L)]
[16:05:11.106]             }
[16:05:11.106]             function(cond) {
[16:05:11.106]                 is_error <- inherits(cond, "error")
[16:05:11.106]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:11.106]                   NULL)
[16:05:11.106]                 if (is_error) {
[16:05:11.106]                   sessionInformation <- function() {
[16:05:11.106]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:11.106]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:11.106]                       search = base::search(), system = base::Sys.info())
[16:05:11.106]                   }
[16:05:11.106]                   ...future.conditions[[length(...future.conditions) + 
[16:05:11.106]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:11.106]                     cond$call), session = sessionInformation(), 
[16:05:11.106]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:11.106]                   signalCondition(cond)
[16:05:11.106]                 }
[16:05:11.106]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:11.106]                 "immediateCondition"))) {
[16:05:11.106]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:11.106]                   ...future.conditions[[length(...future.conditions) + 
[16:05:11.106]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:11.106]                   if (TRUE && !signal) {
[16:05:11.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.106]                     {
[16:05:11.106]                       inherits <- base::inherits
[16:05:11.106]                       invokeRestart <- base::invokeRestart
[16:05:11.106]                       is.null <- base::is.null
[16:05:11.106]                       muffled <- FALSE
[16:05:11.106]                       if (inherits(cond, "message")) {
[16:05:11.106]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:11.106]                         if (muffled) 
[16:05:11.106]                           invokeRestart("muffleMessage")
[16:05:11.106]                       }
[16:05:11.106]                       else if (inherits(cond, "warning")) {
[16:05:11.106]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:11.106]                         if (muffled) 
[16:05:11.106]                           invokeRestart("muffleWarning")
[16:05:11.106]                       }
[16:05:11.106]                       else if (inherits(cond, "condition")) {
[16:05:11.106]                         if (!is.null(pattern)) {
[16:05:11.106]                           computeRestarts <- base::computeRestarts
[16:05:11.106]                           grepl <- base::grepl
[16:05:11.106]                           restarts <- computeRestarts(cond)
[16:05:11.106]                           for (restart in restarts) {
[16:05:11.106]                             name <- restart$name
[16:05:11.106]                             if (is.null(name)) 
[16:05:11.106]                               next
[16:05:11.106]                             if (!grepl(pattern, name)) 
[16:05:11.106]                               next
[16:05:11.106]                             invokeRestart(restart)
[16:05:11.106]                             muffled <- TRUE
[16:05:11.106]                             break
[16:05:11.106]                           }
[16:05:11.106]                         }
[16:05:11.106]                       }
[16:05:11.106]                       invisible(muffled)
[16:05:11.106]                     }
[16:05:11.106]                     muffleCondition(cond, pattern = "^muffle")
[16:05:11.106]                   }
[16:05:11.106]                 }
[16:05:11.106]                 else {
[16:05:11.106]                   if (TRUE) {
[16:05:11.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.106]                     {
[16:05:11.106]                       inherits <- base::inherits
[16:05:11.106]                       invokeRestart <- base::invokeRestart
[16:05:11.106]                       is.null <- base::is.null
[16:05:11.106]                       muffled <- FALSE
[16:05:11.106]                       if (inherits(cond, "message")) {
[16:05:11.106]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:11.106]                         if (muffled) 
[16:05:11.106]                           invokeRestart("muffleMessage")
[16:05:11.106]                       }
[16:05:11.106]                       else if (inherits(cond, "warning")) {
[16:05:11.106]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:11.106]                         if (muffled) 
[16:05:11.106]                           invokeRestart("muffleWarning")
[16:05:11.106]                       }
[16:05:11.106]                       else if (inherits(cond, "condition")) {
[16:05:11.106]                         if (!is.null(pattern)) {
[16:05:11.106]                           computeRestarts <- base::computeRestarts
[16:05:11.106]                           grepl <- base::grepl
[16:05:11.106]                           restarts <- computeRestarts(cond)
[16:05:11.106]                           for (restart in restarts) {
[16:05:11.106]                             name <- restart$name
[16:05:11.106]                             if (is.null(name)) 
[16:05:11.106]                               next
[16:05:11.106]                             if (!grepl(pattern, name)) 
[16:05:11.106]                               next
[16:05:11.106]                             invokeRestart(restart)
[16:05:11.106]                             muffled <- TRUE
[16:05:11.106]                             break
[16:05:11.106]                           }
[16:05:11.106]                         }
[16:05:11.106]                       }
[16:05:11.106]                       invisible(muffled)
[16:05:11.106]                     }
[16:05:11.106]                     muffleCondition(cond, pattern = "^muffle")
[16:05:11.106]                   }
[16:05:11.106]                 }
[16:05:11.106]             }
[16:05:11.106]         }))
[16:05:11.106]     }, error = function(ex) {
[16:05:11.106]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:11.106]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:11.106]                 ...future.rng), started = ...future.startTime, 
[16:05:11.106]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:11.106]             version = "1.8"), class = "FutureResult")
[16:05:11.106]     }, finally = {
[16:05:11.106]         if (!identical(...future.workdir, getwd())) 
[16:05:11.106]             setwd(...future.workdir)
[16:05:11.106]         {
[16:05:11.106]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:11.106]                 ...future.oldOptions$nwarnings <- NULL
[16:05:11.106]             }
[16:05:11.106]             base::options(...future.oldOptions)
[16:05:11.106]             if (.Platform$OS.type == "windows") {
[16:05:11.106]                 old_names <- names(...future.oldEnvVars)
[16:05:11.106]                 envs <- base::Sys.getenv()
[16:05:11.106]                 names <- names(envs)
[16:05:11.106]                 common <- intersect(names, old_names)
[16:05:11.106]                 added <- setdiff(names, old_names)
[16:05:11.106]                 removed <- setdiff(old_names, names)
[16:05:11.106]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:11.106]                   envs[common]]
[16:05:11.106]                 NAMES <- toupper(changed)
[16:05:11.106]                 args <- list()
[16:05:11.106]                 for (kk in seq_along(NAMES)) {
[16:05:11.106]                   name <- changed[[kk]]
[16:05:11.106]                   NAME <- NAMES[[kk]]
[16:05:11.106]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.106]                     next
[16:05:11.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:11.106]                 }
[16:05:11.106]                 NAMES <- toupper(added)
[16:05:11.106]                 for (kk in seq_along(NAMES)) {
[16:05:11.106]                   name <- added[[kk]]
[16:05:11.106]                   NAME <- NAMES[[kk]]
[16:05:11.106]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.106]                     next
[16:05:11.106]                   args[[name]] <- ""
[16:05:11.106]                 }
[16:05:11.106]                 NAMES <- toupper(removed)
[16:05:11.106]                 for (kk in seq_along(NAMES)) {
[16:05:11.106]                   name <- removed[[kk]]
[16:05:11.106]                   NAME <- NAMES[[kk]]
[16:05:11.106]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.106]                     next
[16:05:11.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:11.106]                 }
[16:05:11.106]                 if (length(args) > 0) 
[16:05:11.106]                   base::do.call(base::Sys.setenv, args = args)
[16:05:11.106]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:11.106]             }
[16:05:11.106]             else {
[16:05:11.106]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:11.106]             }
[16:05:11.106]             {
[16:05:11.106]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:11.106]                   0L) {
[16:05:11.106]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:11.106]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:11.106]                   base::options(opts)
[16:05:11.106]                 }
[16:05:11.106]                 {
[16:05:11.106]                   {
[16:05:11.106]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:11.106]                     NULL
[16:05:11.106]                   }
[16:05:11.106]                   options(future.plan = NULL)
[16:05:11.106]                   if (is.na(NA_character_)) 
[16:05:11.106]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:11.106]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:11.106]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:11.106]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:11.106]                     envir = parent.frame()) 
[16:05:11.106]                   {
[16:05:11.106]                     if (is.function(workers)) 
[16:05:11.106]                       workers <- workers()
[16:05:11.106]                     workers <- structure(as.integer(workers), 
[16:05:11.106]                       class = class(workers))
[16:05:11.106]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:11.106]                       workers >= 1)
[16:05:11.106]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:11.106]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:11.106]                     }
[16:05:11.106]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:11.106]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:11.106]                       envir = envir)
[16:05:11.106]                     if (!future$lazy) 
[16:05:11.106]                       future <- run(future)
[16:05:11.106]                     invisible(future)
[16:05:11.106]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:11.106]                 }
[16:05:11.106]             }
[16:05:11.106]         }
[16:05:11.106]     })
[16:05:11.106]     if (TRUE) {
[16:05:11.106]         base::sink(type = "output", split = FALSE)
[16:05:11.106]         if (TRUE) {
[16:05:11.106]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:11.106]         }
[16:05:11.106]         else {
[16:05:11.106]             ...future.result["stdout"] <- base::list(NULL)
[16:05:11.106]         }
[16:05:11.106]         base::close(...future.stdout)
[16:05:11.106]         ...future.stdout <- NULL
[16:05:11.106]     }
[16:05:11.106]     ...future.result$conditions <- ...future.conditions
[16:05:11.106]     ...future.result$finished <- base::Sys.time()
[16:05:11.106]     ...future.result
[16:05:11.106] }
[16:05:11.109] Exporting 1 global objects (1.56 MiB) to cluster node #1 ...
[16:05:11.111] Exporting ‘a’ (1.56 MiB) to cluster node #1 ...
[16:05:11.163] Exporting ‘a’ (1.56 MiB) to cluster node #1 ... DONE
[16:05:11.164] Exporting 1 global objects (1.56 MiB) to cluster node #1 ... DONE
[16:05:11.164] MultisessionFuture started
[16:05:11.164] - Launch lazy future ... done
[16:05:11.165] run() for ‘MultisessionFuture’ ... done
[16:05:11.165] result() for ClusterFuture ...
[16:05:11.165] receiveMessageFromWorker() for ClusterFuture ...
[16:05:11.165] - Validating connection of MultisessionFuture
[16:05:11.212] - received message: FutureResult
[16:05:11.213] - Received FutureResult
[16:05:11.213] - Erased future from FutureRegistry
[16:05:11.213] result() for ClusterFuture ...
[16:05:11.213] - result already collected: FutureResult
[16:05:11.213] result() for ClusterFuture ... done
[16:05:11.213] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:11.213] result() for ClusterFuture ... done
[16:05:11.213] result() for ClusterFuture ...
[16:05:11.214] - result already collected: FutureResult
[16:05:11.214] result() for ClusterFuture ... done
value(b) = 2
[16:05:11.214] result() for ClusterFuture ...
[16:05:11.214] - result already collected: FutureResult
[16:05:11.214] result() for ClusterFuture ... done
[16:05:11.214] result() for ClusterFuture ...
[16:05:11.214] - result already collected: FutureResult
[16:05:11.214] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:11.215] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:11.215] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:11.215] 
[16:05:11.215] Searching for globals ... DONE
[16:05:11.215] - globals: [0] <none>
[16:05:11.215] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:11.216] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:11.216] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:11.217] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:11.217] Searching for globals ... DONE
[16:05:11.217] Resolving globals: TRUE
[16:05:11.217] Resolving any globals that are futures ...
[16:05:11.217] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:11.217] Resolving any globals that are futures ... DONE
[16:05:11.218] Resolving futures part of globals (recursively) ...
[16:05:11.218] resolve() on list ...
[16:05:11.218]  recursive: 99
[16:05:11.218]  length: 1
[16:05:11.218]  elements: ‘a’
[16:05:11.218] run() for ‘Future’ ...
[16:05:11.218] - state: ‘created’
[16:05:11.218] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:11.234] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:11.234] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:11.234]   - Field: ‘node’
[16:05:11.234]   - Field: ‘label’
[16:05:11.234]   - Field: ‘local’
[16:05:11.234]   - Field: ‘owner’
[16:05:11.234]   - Field: ‘envir’
[16:05:11.234]   - Field: ‘workers’
[16:05:11.234]   - Field: ‘packages’
[16:05:11.234]   - Field: ‘gc’
[16:05:11.235]   - Field: ‘conditions’
[16:05:11.235]   - Field: ‘persistent’
[16:05:11.235]   - Field: ‘expr’
[16:05:11.235]   - Field: ‘uuid’
[16:05:11.235]   - Field: ‘seed’
[16:05:11.235]   - Field: ‘version’
[16:05:11.235]   - Field: ‘result’
[16:05:11.235]   - Field: ‘asynchronous’
[16:05:11.235]   - Field: ‘calls’
[16:05:11.235]   - Field: ‘globals’
[16:05:11.236]   - Field: ‘stdout’
[16:05:11.236]   - Field: ‘earlySignal’
[16:05:11.236]   - Field: ‘lazy’
[16:05:11.236]   - Field: ‘state’
[16:05:11.236] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:11.236] - Launch lazy future ...
[16:05:11.236] Packages needed by the future expression (n = 0): <none>
[16:05:11.236] Packages needed by future strategies (n = 0): <none>
[16:05:11.237] {
[16:05:11.237]     {
[16:05:11.237]         {
[16:05:11.237]             ...future.startTime <- base::Sys.time()
[16:05:11.237]             {
[16:05:11.237]                 {
[16:05:11.237]                   {
[16:05:11.237]                     {
[16:05:11.237]                       base::local({
[16:05:11.237]                         has_future <- base::requireNamespace("future", 
[16:05:11.237]                           quietly = TRUE)
[16:05:11.237]                         if (has_future) {
[16:05:11.237]                           ns <- base::getNamespace("future")
[16:05:11.237]                           version <- ns[[".package"]][["version"]]
[16:05:11.237]                           if (is.null(version)) 
[16:05:11.237]                             version <- utils::packageVersion("future")
[16:05:11.237]                         }
[16:05:11.237]                         else {
[16:05:11.237]                           version <- NULL
[16:05:11.237]                         }
[16:05:11.237]                         if (!has_future || version < "1.8.0") {
[16:05:11.237]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:11.237]                             "", base::R.version$version.string), 
[16:05:11.237]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:11.237]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:11.237]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:11.237]                               "release", "version")], collapse = " "), 
[16:05:11.237]                             hostname = base::Sys.info()[["nodename"]])
[16:05:11.237]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:11.237]                             info)
[16:05:11.237]                           info <- base::paste(info, collapse = "; ")
[16:05:11.237]                           if (!has_future) {
[16:05:11.237]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:11.237]                               info)
[16:05:11.237]                           }
[16:05:11.237]                           else {
[16:05:11.237]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:11.237]                               info, version)
[16:05:11.237]                           }
[16:05:11.237]                           base::stop(msg)
[16:05:11.237]                         }
[16:05:11.237]                       })
[16:05:11.237]                     }
[16:05:11.237]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:11.237]                     base::options(mc.cores = 1L)
[16:05:11.237]                   }
[16:05:11.237]                   options(future.plan = NULL)
[16:05:11.237]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:11.237]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:11.237]                 }
[16:05:11.237]                 ...future.workdir <- getwd()
[16:05:11.237]             }
[16:05:11.237]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:11.237]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:11.237]         }
[16:05:11.237]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:11.237]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:11.237]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:11.237]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:11.237]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:11.237]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:11.237]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:11.237]             base::names(...future.oldOptions))
[16:05:11.237]     }
[16:05:11.237]     if (FALSE) {
[16:05:11.237]     }
[16:05:11.237]     else {
[16:05:11.237]         if (TRUE) {
[16:05:11.237]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:11.237]                 open = "w")
[16:05:11.237]         }
[16:05:11.237]         else {
[16:05:11.237]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:11.237]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:11.237]         }
[16:05:11.237]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:11.237]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:11.237]             base::sink(type = "output", split = FALSE)
[16:05:11.237]             base::close(...future.stdout)
[16:05:11.237]         }, add = TRUE)
[16:05:11.237]     }
[16:05:11.237]     ...future.frame <- base::sys.nframe()
[16:05:11.237]     ...future.conditions <- base::list()
[16:05:11.237]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:11.237]     if (FALSE) {
[16:05:11.237]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:11.237]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:11.237]     }
[16:05:11.237]     ...future.result <- base::tryCatch({
[16:05:11.237]         base::withCallingHandlers({
[16:05:11.237]             ...future.value <- base::withVisible(base::local({
[16:05:11.237]                 ...future.makeSendCondition <- base::local({
[16:05:11.237]                   sendCondition <- NULL
[16:05:11.237]                   function(frame = 1L) {
[16:05:11.237]                     if (is.function(sendCondition)) 
[16:05:11.237]                       return(sendCondition)
[16:05:11.237]                     ns <- getNamespace("parallel")
[16:05:11.237]                     if (exists("sendData", mode = "function", 
[16:05:11.237]                       envir = ns)) {
[16:05:11.237]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:11.237]                         envir = ns)
[16:05:11.237]                       envir <- sys.frame(frame)
[16:05:11.237]                       master <- NULL
[16:05:11.237]                       while (!identical(envir, .GlobalEnv) && 
[16:05:11.237]                         !identical(envir, emptyenv())) {
[16:05:11.237]                         if (exists("master", mode = "list", envir = envir, 
[16:05:11.237]                           inherits = FALSE)) {
[16:05:11.237]                           master <- get("master", mode = "list", 
[16:05:11.237]                             envir = envir, inherits = FALSE)
[16:05:11.237]                           if (inherits(master, c("SOCKnode", 
[16:05:11.237]                             "SOCK0node"))) {
[16:05:11.237]                             sendCondition <<- function(cond) {
[16:05:11.237]                               data <- list(type = "VALUE", value = cond, 
[16:05:11.237]                                 success = TRUE)
[16:05:11.237]                               parallel_sendData(master, data)
[16:05:11.237]                             }
[16:05:11.237]                             return(sendCondition)
[16:05:11.237]                           }
[16:05:11.237]                         }
[16:05:11.237]                         frame <- frame + 1L
[16:05:11.237]                         envir <- sys.frame(frame)
[16:05:11.237]                       }
[16:05:11.237]                     }
[16:05:11.237]                     sendCondition <<- function(cond) NULL
[16:05:11.237]                   }
[16:05:11.237]                 })
[16:05:11.237]                 withCallingHandlers({
[16:05:11.237]                   1
[16:05:11.237]                 }, immediateCondition = function(cond) {
[16:05:11.237]                   sendCondition <- ...future.makeSendCondition()
[16:05:11.237]                   sendCondition(cond)
[16:05:11.237]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.237]                   {
[16:05:11.237]                     inherits <- base::inherits
[16:05:11.237]                     invokeRestart <- base::invokeRestart
[16:05:11.237]                     is.null <- base::is.null
[16:05:11.237]                     muffled <- FALSE
[16:05:11.237]                     if (inherits(cond, "message")) {
[16:05:11.237]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:11.237]                       if (muffled) 
[16:05:11.237]                         invokeRestart("muffleMessage")
[16:05:11.237]                     }
[16:05:11.237]                     else if (inherits(cond, "warning")) {
[16:05:11.237]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:11.237]                       if (muffled) 
[16:05:11.237]                         invokeRestart("muffleWarning")
[16:05:11.237]                     }
[16:05:11.237]                     else if (inherits(cond, "condition")) {
[16:05:11.237]                       if (!is.null(pattern)) {
[16:05:11.237]                         computeRestarts <- base::computeRestarts
[16:05:11.237]                         grepl <- base::grepl
[16:05:11.237]                         restarts <- computeRestarts(cond)
[16:05:11.237]                         for (restart in restarts) {
[16:05:11.237]                           name <- restart$name
[16:05:11.237]                           if (is.null(name)) 
[16:05:11.237]                             next
[16:05:11.237]                           if (!grepl(pattern, name)) 
[16:05:11.237]                             next
[16:05:11.237]                           invokeRestart(restart)
[16:05:11.237]                           muffled <- TRUE
[16:05:11.237]                           break
[16:05:11.237]                         }
[16:05:11.237]                       }
[16:05:11.237]                     }
[16:05:11.237]                     invisible(muffled)
[16:05:11.237]                   }
[16:05:11.237]                   muffleCondition(cond)
[16:05:11.237]                 })
[16:05:11.237]             }))
[16:05:11.237]             future::FutureResult(value = ...future.value$value, 
[16:05:11.237]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:11.237]                   ...future.rng), globalenv = if (FALSE) 
[16:05:11.237]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:11.237]                     ...future.globalenv.names))
[16:05:11.237]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:11.237]         }, condition = base::local({
[16:05:11.237]             c <- base::c
[16:05:11.237]             inherits <- base::inherits
[16:05:11.237]             invokeRestart <- base::invokeRestart
[16:05:11.237]             length <- base::length
[16:05:11.237]             list <- base::list
[16:05:11.237]             seq.int <- base::seq.int
[16:05:11.237]             signalCondition <- base::signalCondition
[16:05:11.237]             sys.calls <- base::sys.calls
[16:05:11.237]             `[[` <- base::`[[`
[16:05:11.237]             `+` <- base::`+`
[16:05:11.237]             `<<-` <- base::`<<-`
[16:05:11.237]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:11.237]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:11.237]                   3L)]
[16:05:11.237]             }
[16:05:11.237]             function(cond) {
[16:05:11.237]                 is_error <- inherits(cond, "error")
[16:05:11.237]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:11.237]                   NULL)
[16:05:11.237]                 if (is_error) {
[16:05:11.237]                   sessionInformation <- function() {
[16:05:11.237]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:11.237]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:11.237]                       search = base::search(), system = base::Sys.info())
[16:05:11.237]                   }
[16:05:11.237]                   ...future.conditions[[length(...future.conditions) + 
[16:05:11.237]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:11.237]                     cond$call), session = sessionInformation(), 
[16:05:11.237]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:11.237]                   signalCondition(cond)
[16:05:11.237]                 }
[16:05:11.237]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:11.237]                 "immediateCondition"))) {
[16:05:11.237]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:11.237]                   ...future.conditions[[length(...future.conditions) + 
[16:05:11.237]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:11.237]                   if (TRUE && !signal) {
[16:05:11.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.237]                     {
[16:05:11.237]                       inherits <- base::inherits
[16:05:11.237]                       invokeRestart <- base::invokeRestart
[16:05:11.237]                       is.null <- base::is.null
[16:05:11.237]                       muffled <- FALSE
[16:05:11.237]                       if (inherits(cond, "message")) {
[16:05:11.237]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:11.237]                         if (muffled) 
[16:05:11.237]                           invokeRestart("muffleMessage")
[16:05:11.237]                       }
[16:05:11.237]                       else if (inherits(cond, "warning")) {
[16:05:11.237]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:11.237]                         if (muffled) 
[16:05:11.237]                           invokeRestart("muffleWarning")
[16:05:11.237]                       }
[16:05:11.237]                       else if (inherits(cond, "condition")) {
[16:05:11.237]                         if (!is.null(pattern)) {
[16:05:11.237]                           computeRestarts <- base::computeRestarts
[16:05:11.237]                           grepl <- base::grepl
[16:05:11.237]                           restarts <- computeRestarts(cond)
[16:05:11.237]                           for (restart in restarts) {
[16:05:11.237]                             name <- restart$name
[16:05:11.237]                             if (is.null(name)) 
[16:05:11.237]                               next
[16:05:11.237]                             if (!grepl(pattern, name)) 
[16:05:11.237]                               next
[16:05:11.237]                             invokeRestart(restart)
[16:05:11.237]                             muffled <- TRUE
[16:05:11.237]                             break
[16:05:11.237]                           }
[16:05:11.237]                         }
[16:05:11.237]                       }
[16:05:11.237]                       invisible(muffled)
[16:05:11.237]                     }
[16:05:11.237]                     muffleCondition(cond, pattern = "^muffle")
[16:05:11.237]                   }
[16:05:11.237]                 }
[16:05:11.237]                 else {
[16:05:11.237]                   if (TRUE) {
[16:05:11.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.237]                     {
[16:05:11.237]                       inherits <- base::inherits
[16:05:11.237]                       invokeRestart <- base::invokeRestart
[16:05:11.237]                       is.null <- base::is.null
[16:05:11.237]                       muffled <- FALSE
[16:05:11.237]                       if (inherits(cond, "message")) {
[16:05:11.237]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:11.237]                         if (muffled) 
[16:05:11.237]                           invokeRestart("muffleMessage")
[16:05:11.237]                       }
[16:05:11.237]                       else if (inherits(cond, "warning")) {
[16:05:11.237]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:11.237]                         if (muffled) 
[16:05:11.237]                           invokeRestart("muffleWarning")
[16:05:11.237]                       }
[16:05:11.237]                       else if (inherits(cond, "condition")) {
[16:05:11.237]                         if (!is.null(pattern)) {
[16:05:11.237]                           computeRestarts <- base::computeRestarts
[16:05:11.237]                           grepl <- base::grepl
[16:05:11.237]                           restarts <- computeRestarts(cond)
[16:05:11.237]                           for (restart in restarts) {
[16:05:11.237]                             name <- restart$name
[16:05:11.237]                             if (is.null(name)) 
[16:05:11.237]                               next
[16:05:11.237]                             if (!grepl(pattern, name)) 
[16:05:11.237]                               next
[16:05:11.237]                             invokeRestart(restart)
[16:05:11.237]                             muffled <- TRUE
[16:05:11.237]                             break
[16:05:11.237]                           }
[16:05:11.237]                         }
[16:05:11.237]                       }
[16:05:11.237]                       invisible(muffled)
[16:05:11.237]                     }
[16:05:11.237]                     muffleCondition(cond, pattern = "^muffle")
[16:05:11.237]                   }
[16:05:11.237]                 }
[16:05:11.237]             }
[16:05:11.237]         }))
[16:05:11.237]     }, error = function(ex) {
[16:05:11.237]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:11.237]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:11.237]                 ...future.rng), started = ...future.startTime, 
[16:05:11.237]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:11.237]             version = "1.8"), class = "FutureResult")
[16:05:11.237]     }, finally = {
[16:05:11.237]         if (!identical(...future.workdir, getwd())) 
[16:05:11.237]             setwd(...future.workdir)
[16:05:11.237]         {
[16:05:11.237]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:11.237]                 ...future.oldOptions$nwarnings <- NULL
[16:05:11.237]             }
[16:05:11.237]             base::options(...future.oldOptions)
[16:05:11.237]             if (.Platform$OS.type == "windows") {
[16:05:11.237]                 old_names <- names(...future.oldEnvVars)
[16:05:11.237]                 envs <- base::Sys.getenv()
[16:05:11.237]                 names <- names(envs)
[16:05:11.237]                 common <- intersect(names, old_names)
[16:05:11.237]                 added <- setdiff(names, old_names)
[16:05:11.237]                 removed <- setdiff(old_names, names)
[16:05:11.237]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:11.237]                   envs[common]]
[16:05:11.237]                 NAMES <- toupper(changed)
[16:05:11.237]                 args <- list()
[16:05:11.237]                 for (kk in seq_along(NAMES)) {
[16:05:11.237]                   name <- changed[[kk]]
[16:05:11.237]                   NAME <- NAMES[[kk]]
[16:05:11.237]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.237]                     next
[16:05:11.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:11.237]                 }
[16:05:11.237]                 NAMES <- toupper(added)
[16:05:11.237]                 for (kk in seq_along(NAMES)) {
[16:05:11.237]                   name <- added[[kk]]
[16:05:11.237]                   NAME <- NAMES[[kk]]
[16:05:11.237]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.237]                     next
[16:05:11.237]                   args[[name]] <- ""
[16:05:11.237]                 }
[16:05:11.237]                 NAMES <- toupper(removed)
[16:05:11.237]                 for (kk in seq_along(NAMES)) {
[16:05:11.237]                   name <- removed[[kk]]
[16:05:11.237]                   NAME <- NAMES[[kk]]
[16:05:11.237]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.237]                     next
[16:05:11.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:11.237]                 }
[16:05:11.237]                 if (length(args) > 0) 
[16:05:11.237]                   base::do.call(base::Sys.setenv, args = args)
[16:05:11.237]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:11.237]             }
[16:05:11.237]             else {
[16:05:11.237]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:11.237]             }
[16:05:11.237]             {
[16:05:11.237]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:11.237]                   0L) {
[16:05:11.237]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:11.237]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:11.237]                   base::options(opts)
[16:05:11.237]                 }
[16:05:11.237]                 {
[16:05:11.237]                   {
[16:05:11.237]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:11.237]                     NULL
[16:05:11.237]                   }
[16:05:11.237]                   options(future.plan = NULL)
[16:05:11.237]                   if (is.na(NA_character_)) 
[16:05:11.237]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:11.237]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:11.237]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:11.237]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:11.237]                     envir = parent.frame()) 
[16:05:11.237]                   {
[16:05:11.237]                     if (is.function(workers)) 
[16:05:11.237]                       workers <- workers()
[16:05:11.237]                     workers <- structure(as.integer(workers), 
[16:05:11.237]                       class = class(workers))
[16:05:11.237]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:11.237]                       workers >= 1)
[16:05:11.237]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:11.237]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:11.237]                     }
[16:05:11.237]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:11.237]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:11.237]                       envir = envir)
[16:05:11.237]                     if (!future$lazy) 
[16:05:11.237]                       future <- run(future)
[16:05:11.237]                     invisible(future)
[16:05:11.237]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:11.237]                 }
[16:05:11.237]             }
[16:05:11.237]         }
[16:05:11.237]     })
[16:05:11.237]     if (TRUE) {
[16:05:11.237]         base::sink(type = "output", split = FALSE)
[16:05:11.237]         if (TRUE) {
[16:05:11.237]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:11.237]         }
[16:05:11.237]         else {
[16:05:11.237]             ...future.result["stdout"] <- base::list(NULL)
[16:05:11.237]         }
[16:05:11.237]         base::close(...future.stdout)
[16:05:11.237]         ...future.stdout <- NULL
[16:05:11.237]     }
[16:05:11.237]     ...future.result$conditions <- ...future.conditions
[16:05:11.237]     ...future.result$finished <- base::Sys.time()
[16:05:11.237]     ...future.result
[16:05:11.237] }
[16:05:11.240] MultisessionFuture started
[16:05:11.240] - Launch lazy future ... done
[16:05:11.240] run() for ‘MultisessionFuture’ ... done
[16:05:11.290] receiveMessageFromWorker() for ClusterFuture ...
[16:05:11.290] - Validating connection of MultisessionFuture
[16:05:11.290] - received message: FutureResult
[16:05:11.291] - Received FutureResult
[16:05:11.291] - Erased future from FutureRegistry
[16:05:11.291] result() for ClusterFuture ...
[16:05:11.291] - result already collected: FutureResult
[16:05:11.291] result() for ClusterFuture ... done
[16:05:11.291] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:11.291] Future #1
[16:05:11.291] result() for ClusterFuture ...
[16:05:11.292] - result already collected: FutureResult
[16:05:11.292] result() for ClusterFuture ... done
[16:05:11.292] result() for ClusterFuture ...
[16:05:11.292] - result already collected: FutureResult
[16:05:11.292] result() for ClusterFuture ... done
[16:05:11.292] A MultisessionFuture was resolved
[16:05:11.292]  length: 0 (resolved future 1)
[16:05:11.292] resolve() on list ... DONE
[16:05:11.292] - globals: [1] ‘a’
[16:05:11.292] Resolving futures part of globals (recursively) ... DONE
[16:05:11.295] The total size of the 1 globals is 1.56 MiB (1641008 bytes)
[16:05:11.295] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.56 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.56 MiB of class ‘environment’)
[16:05:11.295] - globals: [1] ‘a’
[16:05:11.295] - packages: [1] ‘future’
[16:05:11.295] getGlobalsAndPackages() ... DONE
[16:05:11.296] run() for ‘Future’ ...
[16:05:11.296] - state: ‘created’
[16:05:11.296] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:11.309] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:11.309] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:11.309]   - Field: ‘node’
[16:05:11.310]   - Field: ‘label’
[16:05:11.310]   - Field: ‘local’
[16:05:11.310]   - Field: ‘owner’
[16:05:11.310]   - Field: ‘envir’
[16:05:11.310]   - Field: ‘workers’
[16:05:11.310]   - Field: ‘packages’
[16:05:11.310]   - Field: ‘gc’
[16:05:11.310]   - Field: ‘conditions’
[16:05:11.310]   - Field: ‘persistent’
[16:05:11.310]   - Field: ‘expr’
[16:05:11.311]   - Field: ‘uuid’
[16:05:11.311]   - Field: ‘seed’
[16:05:11.311]   - Field: ‘version’
[16:05:11.311]   - Field: ‘result’
[16:05:11.311]   - Field: ‘asynchronous’
[16:05:11.311]   - Field: ‘calls’
[16:05:11.311]   - Field: ‘globals’
[16:05:11.311]   - Field: ‘stdout’
[16:05:11.311]   - Field: ‘earlySignal’
[16:05:11.311]   - Field: ‘lazy’
[16:05:11.312]   - Field: ‘state’
[16:05:11.312] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:11.312] - Launch lazy future ...
[16:05:11.312] Packages needed by the future expression (n = 1): ‘future’
[16:05:11.312] Packages needed by future strategies (n = 0): <none>
[16:05:11.313] {
[16:05:11.313]     {
[16:05:11.313]         {
[16:05:11.313]             ...future.startTime <- base::Sys.time()
[16:05:11.313]             {
[16:05:11.313]                 {
[16:05:11.313]                   {
[16:05:11.313]                     {
[16:05:11.313]                       {
[16:05:11.313]                         base::local({
[16:05:11.313]                           has_future <- base::requireNamespace("future", 
[16:05:11.313]                             quietly = TRUE)
[16:05:11.313]                           if (has_future) {
[16:05:11.313]                             ns <- base::getNamespace("future")
[16:05:11.313]                             version <- ns[[".package"]][["version"]]
[16:05:11.313]                             if (is.null(version)) 
[16:05:11.313]                               version <- utils::packageVersion("future")
[16:05:11.313]                           }
[16:05:11.313]                           else {
[16:05:11.313]                             version <- NULL
[16:05:11.313]                           }
[16:05:11.313]                           if (!has_future || version < "1.8.0") {
[16:05:11.313]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:11.313]                               "", base::R.version$version.string), 
[16:05:11.313]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:11.313]                                 base::R.version$platform, 8 * 
[16:05:11.313]                                   base::.Machine$sizeof.pointer), 
[16:05:11.313]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:11.313]                                 "release", "version")], collapse = " "), 
[16:05:11.313]                               hostname = base::Sys.info()[["nodename"]])
[16:05:11.313]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:11.313]                               info)
[16:05:11.313]                             info <- base::paste(info, collapse = "; ")
[16:05:11.313]                             if (!has_future) {
[16:05:11.313]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:11.313]                                 info)
[16:05:11.313]                             }
[16:05:11.313]                             else {
[16:05:11.313]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:11.313]                                 info, version)
[16:05:11.313]                             }
[16:05:11.313]                             base::stop(msg)
[16:05:11.313]                           }
[16:05:11.313]                         })
[16:05:11.313]                       }
[16:05:11.313]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:11.313]                       base::options(mc.cores = 1L)
[16:05:11.313]                     }
[16:05:11.313]                     base::local({
[16:05:11.313]                       for (pkg in "future") {
[16:05:11.313]                         base::loadNamespace(pkg)
[16:05:11.313]                         base::library(pkg, character.only = TRUE)
[16:05:11.313]                       }
[16:05:11.313]                     })
[16:05:11.313]                   }
[16:05:11.313]                   options(future.plan = NULL)
[16:05:11.313]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:11.313]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:11.313]                 }
[16:05:11.313]                 ...future.workdir <- getwd()
[16:05:11.313]             }
[16:05:11.313]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:11.313]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:11.313]         }
[16:05:11.313]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:11.313]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:11.313]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:11.313]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:11.313]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:11.313]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:11.313]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:11.313]             base::names(...future.oldOptions))
[16:05:11.313]     }
[16:05:11.313]     if (FALSE) {
[16:05:11.313]     }
[16:05:11.313]     else {
[16:05:11.313]         if (TRUE) {
[16:05:11.313]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:11.313]                 open = "w")
[16:05:11.313]         }
[16:05:11.313]         else {
[16:05:11.313]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:11.313]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:11.313]         }
[16:05:11.313]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:11.313]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:11.313]             base::sink(type = "output", split = FALSE)
[16:05:11.313]             base::close(...future.stdout)
[16:05:11.313]         }, add = TRUE)
[16:05:11.313]     }
[16:05:11.313]     ...future.frame <- base::sys.nframe()
[16:05:11.313]     ...future.conditions <- base::list()
[16:05:11.313]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:11.313]     if (FALSE) {
[16:05:11.313]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:11.313]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:11.313]     }
[16:05:11.313]     ...future.result <- base::tryCatch({
[16:05:11.313]         base::withCallingHandlers({
[16:05:11.313]             ...future.value <- base::withVisible(base::local({
[16:05:11.313]                 ...future.makeSendCondition <- base::local({
[16:05:11.313]                   sendCondition <- NULL
[16:05:11.313]                   function(frame = 1L) {
[16:05:11.313]                     if (is.function(sendCondition)) 
[16:05:11.313]                       return(sendCondition)
[16:05:11.313]                     ns <- getNamespace("parallel")
[16:05:11.313]                     if (exists("sendData", mode = "function", 
[16:05:11.313]                       envir = ns)) {
[16:05:11.313]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:11.313]                         envir = ns)
[16:05:11.313]                       envir <- sys.frame(frame)
[16:05:11.313]                       master <- NULL
[16:05:11.313]                       while (!identical(envir, .GlobalEnv) && 
[16:05:11.313]                         !identical(envir, emptyenv())) {
[16:05:11.313]                         if (exists("master", mode = "list", envir = envir, 
[16:05:11.313]                           inherits = FALSE)) {
[16:05:11.313]                           master <- get("master", mode = "list", 
[16:05:11.313]                             envir = envir, inherits = FALSE)
[16:05:11.313]                           if (inherits(master, c("SOCKnode", 
[16:05:11.313]                             "SOCK0node"))) {
[16:05:11.313]                             sendCondition <<- function(cond) {
[16:05:11.313]                               data <- list(type = "VALUE", value = cond, 
[16:05:11.313]                                 success = TRUE)
[16:05:11.313]                               parallel_sendData(master, data)
[16:05:11.313]                             }
[16:05:11.313]                             return(sendCondition)
[16:05:11.313]                           }
[16:05:11.313]                         }
[16:05:11.313]                         frame <- frame + 1L
[16:05:11.313]                         envir <- sys.frame(frame)
[16:05:11.313]                       }
[16:05:11.313]                     }
[16:05:11.313]                     sendCondition <<- function(cond) NULL
[16:05:11.313]                   }
[16:05:11.313]                 })
[16:05:11.313]                 withCallingHandlers({
[16:05:11.313]                   value(a) + 1
[16:05:11.313]                 }, immediateCondition = function(cond) {
[16:05:11.313]                   sendCondition <- ...future.makeSendCondition()
[16:05:11.313]                   sendCondition(cond)
[16:05:11.313]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.313]                   {
[16:05:11.313]                     inherits <- base::inherits
[16:05:11.313]                     invokeRestart <- base::invokeRestart
[16:05:11.313]                     is.null <- base::is.null
[16:05:11.313]                     muffled <- FALSE
[16:05:11.313]                     if (inherits(cond, "message")) {
[16:05:11.313]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:11.313]                       if (muffled) 
[16:05:11.313]                         invokeRestart("muffleMessage")
[16:05:11.313]                     }
[16:05:11.313]                     else if (inherits(cond, "warning")) {
[16:05:11.313]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:11.313]                       if (muffled) 
[16:05:11.313]                         invokeRestart("muffleWarning")
[16:05:11.313]                     }
[16:05:11.313]                     else if (inherits(cond, "condition")) {
[16:05:11.313]                       if (!is.null(pattern)) {
[16:05:11.313]                         computeRestarts <- base::computeRestarts
[16:05:11.313]                         grepl <- base::grepl
[16:05:11.313]                         restarts <- computeRestarts(cond)
[16:05:11.313]                         for (restart in restarts) {
[16:05:11.313]                           name <- restart$name
[16:05:11.313]                           if (is.null(name)) 
[16:05:11.313]                             next
[16:05:11.313]                           if (!grepl(pattern, name)) 
[16:05:11.313]                             next
[16:05:11.313]                           invokeRestart(restart)
[16:05:11.313]                           muffled <- TRUE
[16:05:11.313]                           break
[16:05:11.313]                         }
[16:05:11.313]                       }
[16:05:11.313]                     }
[16:05:11.313]                     invisible(muffled)
[16:05:11.313]                   }
[16:05:11.313]                   muffleCondition(cond)
[16:05:11.313]                 })
[16:05:11.313]             }))
[16:05:11.313]             future::FutureResult(value = ...future.value$value, 
[16:05:11.313]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:11.313]                   ...future.rng), globalenv = if (FALSE) 
[16:05:11.313]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:11.313]                     ...future.globalenv.names))
[16:05:11.313]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:11.313]         }, condition = base::local({
[16:05:11.313]             c <- base::c
[16:05:11.313]             inherits <- base::inherits
[16:05:11.313]             invokeRestart <- base::invokeRestart
[16:05:11.313]             length <- base::length
[16:05:11.313]             list <- base::list
[16:05:11.313]             seq.int <- base::seq.int
[16:05:11.313]             signalCondition <- base::signalCondition
[16:05:11.313]             sys.calls <- base::sys.calls
[16:05:11.313]             `[[` <- base::`[[`
[16:05:11.313]             `+` <- base::`+`
[16:05:11.313]             `<<-` <- base::`<<-`
[16:05:11.313]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:11.313]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:11.313]                   3L)]
[16:05:11.313]             }
[16:05:11.313]             function(cond) {
[16:05:11.313]                 is_error <- inherits(cond, "error")
[16:05:11.313]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:11.313]                   NULL)
[16:05:11.313]                 if (is_error) {
[16:05:11.313]                   sessionInformation <- function() {
[16:05:11.313]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:11.313]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:11.313]                       search = base::search(), system = base::Sys.info())
[16:05:11.313]                   }
[16:05:11.313]                   ...future.conditions[[length(...future.conditions) + 
[16:05:11.313]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:11.313]                     cond$call), session = sessionInformation(), 
[16:05:11.313]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:11.313]                   signalCondition(cond)
[16:05:11.313]                 }
[16:05:11.313]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:11.313]                 "immediateCondition"))) {
[16:05:11.313]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:11.313]                   ...future.conditions[[length(...future.conditions) + 
[16:05:11.313]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:11.313]                   if (TRUE && !signal) {
[16:05:11.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.313]                     {
[16:05:11.313]                       inherits <- base::inherits
[16:05:11.313]                       invokeRestart <- base::invokeRestart
[16:05:11.313]                       is.null <- base::is.null
[16:05:11.313]                       muffled <- FALSE
[16:05:11.313]                       if (inherits(cond, "message")) {
[16:05:11.313]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:11.313]                         if (muffled) 
[16:05:11.313]                           invokeRestart("muffleMessage")
[16:05:11.313]                       }
[16:05:11.313]                       else if (inherits(cond, "warning")) {
[16:05:11.313]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:11.313]                         if (muffled) 
[16:05:11.313]                           invokeRestart("muffleWarning")
[16:05:11.313]                       }
[16:05:11.313]                       else if (inherits(cond, "condition")) {
[16:05:11.313]                         if (!is.null(pattern)) {
[16:05:11.313]                           computeRestarts <- base::computeRestarts
[16:05:11.313]                           grepl <- base::grepl
[16:05:11.313]                           restarts <- computeRestarts(cond)
[16:05:11.313]                           for (restart in restarts) {
[16:05:11.313]                             name <- restart$name
[16:05:11.313]                             if (is.null(name)) 
[16:05:11.313]                               next
[16:05:11.313]                             if (!grepl(pattern, name)) 
[16:05:11.313]                               next
[16:05:11.313]                             invokeRestart(restart)
[16:05:11.313]                             muffled <- TRUE
[16:05:11.313]                             break
[16:05:11.313]                           }
[16:05:11.313]                         }
[16:05:11.313]                       }
[16:05:11.313]                       invisible(muffled)
[16:05:11.313]                     }
[16:05:11.313]                     muffleCondition(cond, pattern = "^muffle")
[16:05:11.313]                   }
[16:05:11.313]                 }
[16:05:11.313]                 else {
[16:05:11.313]                   if (TRUE) {
[16:05:11.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.313]                     {
[16:05:11.313]                       inherits <- base::inherits
[16:05:11.313]                       invokeRestart <- base::invokeRestart
[16:05:11.313]                       is.null <- base::is.null
[16:05:11.313]                       muffled <- FALSE
[16:05:11.313]                       if (inherits(cond, "message")) {
[16:05:11.313]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:11.313]                         if (muffled) 
[16:05:11.313]                           invokeRestart("muffleMessage")
[16:05:11.313]                       }
[16:05:11.313]                       else if (inherits(cond, "warning")) {
[16:05:11.313]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:11.313]                         if (muffled) 
[16:05:11.313]                           invokeRestart("muffleWarning")
[16:05:11.313]                       }
[16:05:11.313]                       else if (inherits(cond, "condition")) {
[16:05:11.313]                         if (!is.null(pattern)) {
[16:05:11.313]                           computeRestarts <- base::computeRestarts
[16:05:11.313]                           grepl <- base::grepl
[16:05:11.313]                           restarts <- computeRestarts(cond)
[16:05:11.313]                           for (restart in restarts) {
[16:05:11.313]                             name <- restart$name
[16:05:11.313]                             if (is.null(name)) 
[16:05:11.313]                               next
[16:05:11.313]                             if (!grepl(pattern, name)) 
[16:05:11.313]                               next
[16:05:11.313]                             invokeRestart(restart)
[16:05:11.313]                             muffled <- TRUE
[16:05:11.313]                             break
[16:05:11.313]                           }
[16:05:11.313]                         }
[16:05:11.313]                       }
[16:05:11.313]                       invisible(muffled)
[16:05:11.313]                     }
[16:05:11.313]                     muffleCondition(cond, pattern = "^muffle")
[16:05:11.313]                   }
[16:05:11.313]                 }
[16:05:11.313]             }
[16:05:11.313]         }))
[16:05:11.313]     }, error = function(ex) {
[16:05:11.313]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:11.313]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:11.313]                 ...future.rng), started = ...future.startTime, 
[16:05:11.313]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:11.313]             version = "1.8"), class = "FutureResult")
[16:05:11.313]     }, finally = {
[16:05:11.313]         if (!identical(...future.workdir, getwd())) 
[16:05:11.313]             setwd(...future.workdir)
[16:05:11.313]         {
[16:05:11.313]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:11.313]                 ...future.oldOptions$nwarnings <- NULL
[16:05:11.313]             }
[16:05:11.313]             base::options(...future.oldOptions)
[16:05:11.313]             if (.Platform$OS.type == "windows") {
[16:05:11.313]                 old_names <- names(...future.oldEnvVars)
[16:05:11.313]                 envs <- base::Sys.getenv()
[16:05:11.313]                 names <- names(envs)
[16:05:11.313]                 common <- intersect(names, old_names)
[16:05:11.313]                 added <- setdiff(names, old_names)
[16:05:11.313]                 removed <- setdiff(old_names, names)
[16:05:11.313]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:11.313]                   envs[common]]
[16:05:11.313]                 NAMES <- toupper(changed)
[16:05:11.313]                 args <- list()
[16:05:11.313]                 for (kk in seq_along(NAMES)) {
[16:05:11.313]                   name <- changed[[kk]]
[16:05:11.313]                   NAME <- NAMES[[kk]]
[16:05:11.313]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.313]                     next
[16:05:11.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:11.313]                 }
[16:05:11.313]                 NAMES <- toupper(added)
[16:05:11.313]                 for (kk in seq_along(NAMES)) {
[16:05:11.313]                   name <- added[[kk]]
[16:05:11.313]                   NAME <- NAMES[[kk]]
[16:05:11.313]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.313]                     next
[16:05:11.313]                   args[[name]] <- ""
[16:05:11.313]                 }
[16:05:11.313]                 NAMES <- toupper(removed)
[16:05:11.313]                 for (kk in seq_along(NAMES)) {
[16:05:11.313]                   name <- removed[[kk]]
[16:05:11.313]                   NAME <- NAMES[[kk]]
[16:05:11.313]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.313]                     next
[16:05:11.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:11.313]                 }
[16:05:11.313]                 if (length(args) > 0) 
[16:05:11.313]                   base::do.call(base::Sys.setenv, args = args)
[16:05:11.313]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:11.313]             }
[16:05:11.313]             else {
[16:05:11.313]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:11.313]             }
[16:05:11.313]             {
[16:05:11.313]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:11.313]                   0L) {
[16:05:11.313]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:11.313]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:11.313]                   base::options(opts)
[16:05:11.313]                 }
[16:05:11.313]                 {
[16:05:11.313]                   {
[16:05:11.313]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:11.313]                     NULL
[16:05:11.313]                   }
[16:05:11.313]                   options(future.plan = NULL)
[16:05:11.313]                   if (is.na(NA_character_)) 
[16:05:11.313]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:11.313]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:11.313]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:11.313]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:11.313]                     envir = parent.frame()) 
[16:05:11.313]                   {
[16:05:11.313]                     if (is.function(workers)) 
[16:05:11.313]                       workers <- workers()
[16:05:11.313]                     workers <- structure(as.integer(workers), 
[16:05:11.313]                       class = class(workers))
[16:05:11.313]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:11.313]                       workers >= 1)
[16:05:11.313]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:11.313]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:11.313]                     }
[16:05:11.313]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:11.313]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:11.313]                       envir = envir)
[16:05:11.313]                     if (!future$lazy) 
[16:05:11.313]                       future <- run(future)
[16:05:11.313]                     invisible(future)
[16:05:11.313]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:11.313]                 }
[16:05:11.313]             }
[16:05:11.313]         }
[16:05:11.313]     })
[16:05:11.313]     if (TRUE) {
[16:05:11.313]         base::sink(type = "output", split = FALSE)
[16:05:11.313]         if (TRUE) {
[16:05:11.313]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:11.313]         }
[16:05:11.313]         else {
[16:05:11.313]             ...future.result["stdout"] <- base::list(NULL)
[16:05:11.313]         }
[16:05:11.313]         base::close(...future.stdout)
[16:05:11.313]         ...future.stdout <- NULL
[16:05:11.313]     }
[16:05:11.313]     ...future.result$conditions <- ...future.conditions
[16:05:11.313]     ...future.result$finished <- base::Sys.time()
[16:05:11.313]     ...future.result
[16:05:11.313] }
[16:05:11.315] Exporting 1 global objects (1.56 MiB) to cluster node #1 ...
[16:05:11.317] Exporting ‘a’ (1.56 MiB) to cluster node #1 ...
[16:05:11.371] Exporting ‘a’ (1.56 MiB) to cluster node #1 ... DONE
[16:05:11.371] Exporting 1 global objects (1.56 MiB) to cluster node #1 ... DONE
[16:05:11.372] MultisessionFuture started
[16:05:11.372] - Launch lazy future ... done
[16:05:11.372] run() for ‘MultisessionFuture’ ... done
[16:05:11.372] result() for ClusterFuture ...
[16:05:11.372] receiveMessageFromWorker() for ClusterFuture ...
[16:05:11.373] - Validating connection of MultisessionFuture
[16:05:11.420] - received message: FutureResult
[16:05:11.421] - Received FutureResult
[16:05:11.421] - Erased future from FutureRegistry
[16:05:11.421] result() for ClusterFuture ...
[16:05:11.421] - result already collected: FutureResult
[16:05:11.421] result() for ClusterFuture ... done
[16:05:11.421] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:11.421] result() for ClusterFuture ... done
[16:05:11.421] result() for ClusterFuture ...
[16:05:11.422] - result already collected: FutureResult
[16:05:11.422] result() for ClusterFuture ... done
value(b) = 2
[16:05:11.422] result() for ClusterFuture ...
[16:05:11.422] - result already collected: FutureResult
[16:05:11.422] result() for ClusterFuture ... done
[16:05:11.422] result() for ClusterFuture ...
[16:05:11.422] - result already collected: FutureResult
[16:05:11.422] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:11.423] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:11.423] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:11.423] 
[16:05:11.423] Searching for globals ... DONE
[16:05:11.424] - globals: [0] <none>
[16:05:11.424] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:11.424] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:11.424] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:11.425] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:05:11.425] Searching for globals ... DONE
[16:05:11.425] Resolving globals: TRUE
[16:05:11.425] Resolving any globals that are futures ...
[16:05:11.425] - globals: [3] ‘+’, ‘value’, ‘a’
[16:05:11.425] Resolving any globals that are futures ... DONE
[16:05:11.426] Resolving futures part of globals (recursively) ...
[16:05:11.426] resolve() on list ...
[16:05:11.426]  recursive: 99
[16:05:11.426]  length: 1
[16:05:11.426]  elements: ‘a’
[16:05:11.426] run() for ‘Future’ ...
[16:05:11.426] - state: ‘created’
[16:05:11.427] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:11.440] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:11.440] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:11.440]   - Field: ‘node’
[16:05:11.441]   - Field: ‘label’
[16:05:11.441]   - Field: ‘local’
[16:05:11.441]   - Field: ‘owner’
[16:05:11.441]   - Field: ‘envir’
[16:05:11.441]   - Field: ‘workers’
[16:05:11.441]   - Field: ‘packages’
[16:05:11.441]   - Field: ‘gc’
[16:05:11.441]   - Field: ‘conditions’
[16:05:11.441]   - Field: ‘persistent’
[16:05:11.441]   - Field: ‘expr’
[16:05:11.441]   - Field: ‘uuid’
[16:05:11.442]   - Field: ‘seed’
[16:05:11.442]   - Field: ‘version’
[16:05:11.442]   - Field: ‘result’
[16:05:11.442]   - Field: ‘asynchronous’
[16:05:11.442]   - Field: ‘calls’
[16:05:11.442]   - Field: ‘globals’
[16:05:11.442]   - Field: ‘stdout’
[16:05:11.442]   - Field: ‘earlySignal’
[16:05:11.442]   - Field: ‘lazy’
[16:05:11.442]   - Field: ‘state’
[16:05:11.442] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:11.443] - Launch lazy future ...
[16:05:11.443] Packages needed by the future expression (n = 0): <none>
[16:05:11.443] Packages needed by future strategies (n = 0): <none>
[16:05:11.443] {
[16:05:11.443]     {
[16:05:11.443]         {
[16:05:11.443]             ...future.startTime <- base::Sys.time()
[16:05:11.443]             {
[16:05:11.443]                 {
[16:05:11.443]                   {
[16:05:11.443]                     {
[16:05:11.443]                       base::local({
[16:05:11.443]                         has_future <- base::requireNamespace("future", 
[16:05:11.443]                           quietly = TRUE)
[16:05:11.443]                         if (has_future) {
[16:05:11.443]                           ns <- base::getNamespace("future")
[16:05:11.443]                           version <- ns[[".package"]][["version"]]
[16:05:11.443]                           if (is.null(version)) 
[16:05:11.443]                             version <- utils::packageVersion("future")
[16:05:11.443]                         }
[16:05:11.443]                         else {
[16:05:11.443]                           version <- NULL
[16:05:11.443]                         }
[16:05:11.443]                         if (!has_future || version < "1.8.0") {
[16:05:11.443]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:11.443]                             "", base::R.version$version.string), 
[16:05:11.443]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:11.443]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:11.443]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:11.443]                               "release", "version")], collapse = " "), 
[16:05:11.443]                             hostname = base::Sys.info()[["nodename"]])
[16:05:11.443]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:11.443]                             info)
[16:05:11.443]                           info <- base::paste(info, collapse = "; ")
[16:05:11.443]                           if (!has_future) {
[16:05:11.443]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:11.443]                               info)
[16:05:11.443]                           }
[16:05:11.443]                           else {
[16:05:11.443]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:11.443]                               info, version)
[16:05:11.443]                           }
[16:05:11.443]                           base::stop(msg)
[16:05:11.443]                         }
[16:05:11.443]                       })
[16:05:11.443]                     }
[16:05:11.443]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:11.443]                     base::options(mc.cores = 1L)
[16:05:11.443]                   }
[16:05:11.443]                   options(future.plan = NULL)
[16:05:11.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:11.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:11.443]                 }
[16:05:11.443]                 ...future.workdir <- getwd()
[16:05:11.443]             }
[16:05:11.443]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:11.443]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:11.443]         }
[16:05:11.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:11.443]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:11.443]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:11.443]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:11.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:11.443]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:11.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:11.443]             base::names(...future.oldOptions))
[16:05:11.443]     }
[16:05:11.443]     if (FALSE) {
[16:05:11.443]     }
[16:05:11.443]     else {
[16:05:11.443]         if (TRUE) {
[16:05:11.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:11.443]                 open = "w")
[16:05:11.443]         }
[16:05:11.443]         else {
[16:05:11.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:11.443]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:11.443]         }
[16:05:11.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:11.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:11.443]             base::sink(type = "output", split = FALSE)
[16:05:11.443]             base::close(...future.stdout)
[16:05:11.443]         }, add = TRUE)
[16:05:11.443]     }
[16:05:11.443]     ...future.frame <- base::sys.nframe()
[16:05:11.443]     ...future.conditions <- base::list()
[16:05:11.443]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:11.443]     if (FALSE) {
[16:05:11.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:11.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:11.443]     }
[16:05:11.443]     ...future.result <- base::tryCatch({
[16:05:11.443]         base::withCallingHandlers({
[16:05:11.443]             ...future.value <- base::withVisible(base::local({
[16:05:11.443]                 ...future.makeSendCondition <- base::local({
[16:05:11.443]                   sendCondition <- NULL
[16:05:11.443]                   function(frame = 1L) {
[16:05:11.443]                     if (is.function(sendCondition)) 
[16:05:11.443]                       return(sendCondition)
[16:05:11.443]                     ns <- getNamespace("parallel")
[16:05:11.443]                     if (exists("sendData", mode = "function", 
[16:05:11.443]                       envir = ns)) {
[16:05:11.443]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:11.443]                         envir = ns)
[16:05:11.443]                       envir <- sys.frame(frame)
[16:05:11.443]                       master <- NULL
[16:05:11.443]                       while (!identical(envir, .GlobalEnv) && 
[16:05:11.443]                         !identical(envir, emptyenv())) {
[16:05:11.443]                         if (exists("master", mode = "list", envir = envir, 
[16:05:11.443]                           inherits = FALSE)) {
[16:05:11.443]                           master <- get("master", mode = "list", 
[16:05:11.443]                             envir = envir, inherits = FALSE)
[16:05:11.443]                           if (inherits(master, c("SOCKnode", 
[16:05:11.443]                             "SOCK0node"))) {
[16:05:11.443]                             sendCondition <<- function(cond) {
[16:05:11.443]                               data <- list(type = "VALUE", value = cond, 
[16:05:11.443]                                 success = TRUE)
[16:05:11.443]                               parallel_sendData(master, data)
[16:05:11.443]                             }
[16:05:11.443]                             return(sendCondition)
[16:05:11.443]                           }
[16:05:11.443]                         }
[16:05:11.443]                         frame <- frame + 1L
[16:05:11.443]                         envir <- sys.frame(frame)
[16:05:11.443]                       }
[16:05:11.443]                     }
[16:05:11.443]                     sendCondition <<- function(cond) NULL
[16:05:11.443]                   }
[16:05:11.443]                 })
[16:05:11.443]                 withCallingHandlers({
[16:05:11.443]                   1
[16:05:11.443]                 }, immediateCondition = function(cond) {
[16:05:11.443]                   sendCondition <- ...future.makeSendCondition()
[16:05:11.443]                   sendCondition(cond)
[16:05:11.443]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.443]                   {
[16:05:11.443]                     inherits <- base::inherits
[16:05:11.443]                     invokeRestart <- base::invokeRestart
[16:05:11.443]                     is.null <- base::is.null
[16:05:11.443]                     muffled <- FALSE
[16:05:11.443]                     if (inherits(cond, "message")) {
[16:05:11.443]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:11.443]                       if (muffled) 
[16:05:11.443]                         invokeRestart("muffleMessage")
[16:05:11.443]                     }
[16:05:11.443]                     else if (inherits(cond, "warning")) {
[16:05:11.443]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:11.443]                       if (muffled) 
[16:05:11.443]                         invokeRestart("muffleWarning")
[16:05:11.443]                     }
[16:05:11.443]                     else if (inherits(cond, "condition")) {
[16:05:11.443]                       if (!is.null(pattern)) {
[16:05:11.443]                         computeRestarts <- base::computeRestarts
[16:05:11.443]                         grepl <- base::grepl
[16:05:11.443]                         restarts <- computeRestarts(cond)
[16:05:11.443]                         for (restart in restarts) {
[16:05:11.443]                           name <- restart$name
[16:05:11.443]                           if (is.null(name)) 
[16:05:11.443]                             next
[16:05:11.443]                           if (!grepl(pattern, name)) 
[16:05:11.443]                             next
[16:05:11.443]                           invokeRestart(restart)
[16:05:11.443]                           muffled <- TRUE
[16:05:11.443]                           break
[16:05:11.443]                         }
[16:05:11.443]                       }
[16:05:11.443]                     }
[16:05:11.443]                     invisible(muffled)
[16:05:11.443]                   }
[16:05:11.443]                   muffleCondition(cond)
[16:05:11.443]                 })
[16:05:11.443]             }))
[16:05:11.443]             future::FutureResult(value = ...future.value$value, 
[16:05:11.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:11.443]                   ...future.rng), globalenv = if (FALSE) 
[16:05:11.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:11.443]                     ...future.globalenv.names))
[16:05:11.443]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:11.443]         }, condition = base::local({
[16:05:11.443]             c <- base::c
[16:05:11.443]             inherits <- base::inherits
[16:05:11.443]             invokeRestart <- base::invokeRestart
[16:05:11.443]             length <- base::length
[16:05:11.443]             list <- base::list
[16:05:11.443]             seq.int <- base::seq.int
[16:05:11.443]             signalCondition <- base::signalCondition
[16:05:11.443]             sys.calls <- base::sys.calls
[16:05:11.443]             `[[` <- base::`[[`
[16:05:11.443]             `+` <- base::`+`
[16:05:11.443]             `<<-` <- base::`<<-`
[16:05:11.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:11.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:11.443]                   3L)]
[16:05:11.443]             }
[16:05:11.443]             function(cond) {
[16:05:11.443]                 is_error <- inherits(cond, "error")
[16:05:11.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:11.443]                   NULL)
[16:05:11.443]                 if (is_error) {
[16:05:11.443]                   sessionInformation <- function() {
[16:05:11.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:11.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:11.443]                       search = base::search(), system = base::Sys.info())
[16:05:11.443]                   }
[16:05:11.443]                   ...future.conditions[[length(...future.conditions) + 
[16:05:11.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:11.443]                     cond$call), session = sessionInformation(), 
[16:05:11.443]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:11.443]                   signalCondition(cond)
[16:05:11.443]                 }
[16:05:11.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:11.443]                 "immediateCondition"))) {
[16:05:11.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:11.443]                   ...future.conditions[[length(...future.conditions) + 
[16:05:11.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:11.443]                   if (TRUE && !signal) {
[16:05:11.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.443]                     {
[16:05:11.443]                       inherits <- base::inherits
[16:05:11.443]                       invokeRestart <- base::invokeRestart
[16:05:11.443]                       is.null <- base::is.null
[16:05:11.443]                       muffled <- FALSE
[16:05:11.443]                       if (inherits(cond, "message")) {
[16:05:11.443]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:11.443]                         if (muffled) 
[16:05:11.443]                           invokeRestart("muffleMessage")
[16:05:11.443]                       }
[16:05:11.443]                       else if (inherits(cond, "warning")) {
[16:05:11.443]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:11.443]                         if (muffled) 
[16:05:11.443]                           invokeRestart("muffleWarning")
[16:05:11.443]                       }
[16:05:11.443]                       else if (inherits(cond, "condition")) {
[16:05:11.443]                         if (!is.null(pattern)) {
[16:05:11.443]                           computeRestarts <- base::computeRestarts
[16:05:11.443]                           grepl <- base::grepl
[16:05:11.443]                           restarts <- computeRestarts(cond)
[16:05:11.443]                           for (restart in restarts) {
[16:05:11.443]                             name <- restart$name
[16:05:11.443]                             if (is.null(name)) 
[16:05:11.443]                               next
[16:05:11.443]                             if (!grepl(pattern, name)) 
[16:05:11.443]                               next
[16:05:11.443]                             invokeRestart(restart)
[16:05:11.443]                             muffled <- TRUE
[16:05:11.443]                             break
[16:05:11.443]                           }
[16:05:11.443]                         }
[16:05:11.443]                       }
[16:05:11.443]                       invisible(muffled)
[16:05:11.443]                     }
[16:05:11.443]                     muffleCondition(cond, pattern = "^muffle")
[16:05:11.443]                   }
[16:05:11.443]                 }
[16:05:11.443]                 else {
[16:05:11.443]                   if (TRUE) {
[16:05:11.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.443]                     {
[16:05:11.443]                       inherits <- base::inherits
[16:05:11.443]                       invokeRestart <- base::invokeRestart
[16:05:11.443]                       is.null <- base::is.null
[16:05:11.443]                       muffled <- FALSE
[16:05:11.443]                       if (inherits(cond, "message")) {
[16:05:11.443]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:11.443]                         if (muffled) 
[16:05:11.443]                           invokeRestart("muffleMessage")
[16:05:11.443]                       }
[16:05:11.443]                       else if (inherits(cond, "warning")) {
[16:05:11.443]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:11.443]                         if (muffled) 
[16:05:11.443]                           invokeRestart("muffleWarning")
[16:05:11.443]                       }
[16:05:11.443]                       else if (inherits(cond, "condition")) {
[16:05:11.443]                         if (!is.null(pattern)) {
[16:05:11.443]                           computeRestarts <- base::computeRestarts
[16:05:11.443]                           grepl <- base::grepl
[16:05:11.443]                           restarts <- computeRestarts(cond)
[16:05:11.443]                           for (restart in restarts) {
[16:05:11.443]                             name <- restart$name
[16:05:11.443]                             if (is.null(name)) 
[16:05:11.443]                               next
[16:05:11.443]                             if (!grepl(pattern, name)) 
[16:05:11.443]                               next
[16:05:11.443]                             invokeRestart(restart)
[16:05:11.443]                             muffled <- TRUE
[16:05:11.443]                             break
[16:05:11.443]                           }
[16:05:11.443]                         }
[16:05:11.443]                       }
[16:05:11.443]                       invisible(muffled)
[16:05:11.443]                     }
[16:05:11.443]                     muffleCondition(cond, pattern = "^muffle")
[16:05:11.443]                   }
[16:05:11.443]                 }
[16:05:11.443]             }
[16:05:11.443]         }))
[16:05:11.443]     }, error = function(ex) {
[16:05:11.443]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:11.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:11.443]                 ...future.rng), started = ...future.startTime, 
[16:05:11.443]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:11.443]             version = "1.8"), class = "FutureResult")
[16:05:11.443]     }, finally = {
[16:05:11.443]         if (!identical(...future.workdir, getwd())) 
[16:05:11.443]             setwd(...future.workdir)
[16:05:11.443]         {
[16:05:11.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:11.443]                 ...future.oldOptions$nwarnings <- NULL
[16:05:11.443]             }
[16:05:11.443]             base::options(...future.oldOptions)
[16:05:11.443]             if (.Platform$OS.type == "windows") {
[16:05:11.443]                 old_names <- names(...future.oldEnvVars)
[16:05:11.443]                 envs <- base::Sys.getenv()
[16:05:11.443]                 names <- names(envs)
[16:05:11.443]                 common <- intersect(names, old_names)
[16:05:11.443]                 added <- setdiff(names, old_names)
[16:05:11.443]                 removed <- setdiff(old_names, names)
[16:05:11.443]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:11.443]                   envs[common]]
[16:05:11.443]                 NAMES <- toupper(changed)
[16:05:11.443]                 args <- list()
[16:05:11.443]                 for (kk in seq_along(NAMES)) {
[16:05:11.443]                   name <- changed[[kk]]
[16:05:11.443]                   NAME <- NAMES[[kk]]
[16:05:11.443]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.443]                     next
[16:05:11.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:11.443]                 }
[16:05:11.443]                 NAMES <- toupper(added)
[16:05:11.443]                 for (kk in seq_along(NAMES)) {
[16:05:11.443]                   name <- added[[kk]]
[16:05:11.443]                   NAME <- NAMES[[kk]]
[16:05:11.443]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.443]                     next
[16:05:11.443]                   args[[name]] <- ""
[16:05:11.443]                 }
[16:05:11.443]                 NAMES <- toupper(removed)
[16:05:11.443]                 for (kk in seq_along(NAMES)) {
[16:05:11.443]                   name <- removed[[kk]]
[16:05:11.443]                   NAME <- NAMES[[kk]]
[16:05:11.443]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.443]                     next
[16:05:11.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:11.443]                 }
[16:05:11.443]                 if (length(args) > 0) 
[16:05:11.443]                   base::do.call(base::Sys.setenv, args = args)
[16:05:11.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:11.443]             }
[16:05:11.443]             else {
[16:05:11.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:11.443]             }
[16:05:11.443]             {
[16:05:11.443]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:11.443]                   0L) {
[16:05:11.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:11.443]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:11.443]                   base::options(opts)
[16:05:11.443]                 }
[16:05:11.443]                 {
[16:05:11.443]                   {
[16:05:11.443]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:11.443]                     NULL
[16:05:11.443]                   }
[16:05:11.443]                   options(future.plan = NULL)
[16:05:11.443]                   if (is.na(NA_character_)) 
[16:05:11.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:11.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:11.443]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:11.443]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:11.443]                     envir = parent.frame()) 
[16:05:11.443]                   {
[16:05:11.443]                     if (is.function(workers)) 
[16:05:11.443]                       workers <- workers()
[16:05:11.443]                     workers <- structure(as.integer(workers), 
[16:05:11.443]                       class = class(workers))
[16:05:11.443]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:11.443]                       workers >= 1)
[16:05:11.443]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:11.443]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:11.443]                     }
[16:05:11.443]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:11.443]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:11.443]                       envir = envir)
[16:05:11.443]                     if (!future$lazy) 
[16:05:11.443]                       future <- run(future)
[16:05:11.443]                     invisible(future)
[16:05:11.443]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:11.443]                 }
[16:05:11.443]             }
[16:05:11.443]         }
[16:05:11.443]     })
[16:05:11.443]     if (TRUE) {
[16:05:11.443]         base::sink(type = "output", split = FALSE)
[16:05:11.443]         if (TRUE) {
[16:05:11.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:11.443]         }
[16:05:11.443]         else {
[16:05:11.443]             ...future.result["stdout"] <- base::list(NULL)
[16:05:11.443]         }
[16:05:11.443]         base::close(...future.stdout)
[16:05:11.443]         ...future.stdout <- NULL
[16:05:11.443]     }
[16:05:11.443]     ...future.result$conditions <- ...future.conditions
[16:05:11.443]     ...future.result$finished <- base::Sys.time()
[16:05:11.443]     ...future.result
[16:05:11.443] }
[16:05:11.446] MultisessionFuture started
[16:05:11.446] - Launch lazy future ... done
[16:05:11.447] run() for ‘MultisessionFuture’ ... done
[16:05:11.492] receiveMessageFromWorker() for ClusterFuture ...
[16:05:11.492] - Validating connection of MultisessionFuture
[16:05:11.492] - received message: FutureResult
[16:05:11.492] - Received FutureResult
[16:05:11.493] - Erased future from FutureRegistry
[16:05:11.493] result() for ClusterFuture ...
[16:05:11.493] - result already collected: FutureResult
[16:05:11.493] result() for ClusterFuture ... done
[16:05:11.493] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:11.493] Future #1
[16:05:11.493] result() for ClusterFuture ...
[16:05:11.493] - result already collected: FutureResult
[16:05:11.493] result() for ClusterFuture ... done
[16:05:11.493] result() for ClusterFuture ...
[16:05:11.493] - result already collected: FutureResult
[16:05:11.494] result() for ClusterFuture ... done
[16:05:11.494] A MultisessionFuture was resolved
[16:05:11.494]  length: 0 (resolved future 1)
[16:05:11.494] resolve() on list ... DONE
[16:05:11.494] - globals: [1] ‘a’
[16:05:11.494] Resolving futures part of globals (recursively) ... DONE
[16:05:11.496] The total size of the 1 globals is 1.56 MiB (1641008 bytes)
[16:05:11.497] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.56 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.56 MiB of class ‘environment’)
[16:05:11.497] - globals: [1] ‘a’
[16:05:11.497] - packages: [1] ‘future’
[16:05:11.497] getGlobalsAndPackages() ... DONE
[16:05:11.497] run() for ‘Future’ ...
[16:05:11.497] - state: ‘created’
[16:05:11.497] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:11.517] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:11.517] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:11.518]   - Field: ‘node’
[16:05:11.518]   - Field: ‘label’
[16:05:11.518]   - Field: ‘local’
[16:05:11.518]   - Field: ‘owner’
[16:05:11.518]   - Field: ‘envir’
[16:05:11.518]   - Field: ‘workers’
[16:05:11.518]   - Field: ‘packages’
[16:05:11.518]   - Field: ‘gc’
[16:05:11.518]   - Field: ‘conditions’
[16:05:11.518]   - Field: ‘persistent’
[16:05:11.519]   - Field: ‘expr’
[16:05:11.519]   - Field: ‘uuid’
[16:05:11.519]   - Field: ‘seed’
[16:05:11.519]   - Field: ‘version’
[16:05:11.519]   - Field: ‘result’
[16:05:11.519]   - Field: ‘asynchronous’
[16:05:11.519]   - Field: ‘calls’
[16:05:11.519]   - Field: ‘globals’
[16:05:11.519]   - Field: ‘stdout’
[16:05:11.519]   - Field: ‘earlySignal’
[16:05:11.519]   - Field: ‘lazy’
[16:05:11.520]   - Field: ‘state’
[16:05:11.520] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:11.520] - Launch lazy future ...
[16:05:11.520] Packages needed by the future expression (n = 1): ‘future’
[16:05:11.520] Packages needed by future strategies (n = 0): <none>
[16:05:11.521] {
[16:05:11.521]     {
[16:05:11.521]         {
[16:05:11.521]             ...future.startTime <- base::Sys.time()
[16:05:11.521]             {
[16:05:11.521]                 {
[16:05:11.521]                   {
[16:05:11.521]                     {
[16:05:11.521]                       {
[16:05:11.521]                         base::local({
[16:05:11.521]                           has_future <- base::requireNamespace("future", 
[16:05:11.521]                             quietly = TRUE)
[16:05:11.521]                           if (has_future) {
[16:05:11.521]                             ns <- base::getNamespace("future")
[16:05:11.521]                             version <- ns[[".package"]][["version"]]
[16:05:11.521]                             if (is.null(version)) 
[16:05:11.521]                               version <- utils::packageVersion("future")
[16:05:11.521]                           }
[16:05:11.521]                           else {
[16:05:11.521]                             version <- NULL
[16:05:11.521]                           }
[16:05:11.521]                           if (!has_future || version < "1.8.0") {
[16:05:11.521]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:11.521]                               "", base::R.version$version.string), 
[16:05:11.521]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:11.521]                                 base::R.version$platform, 8 * 
[16:05:11.521]                                   base::.Machine$sizeof.pointer), 
[16:05:11.521]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:11.521]                                 "release", "version")], collapse = " "), 
[16:05:11.521]                               hostname = base::Sys.info()[["nodename"]])
[16:05:11.521]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:11.521]                               info)
[16:05:11.521]                             info <- base::paste(info, collapse = "; ")
[16:05:11.521]                             if (!has_future) {
[16:05:11.521]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:11.521]                                 info)
[16:05:11.521]                             }
[16:05:11.521]                             else {
[16:05:11.521]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:11.521]                                 info, version)
[16:05:11.521]                             }
[16:05:11.521]                             base::stop(msg)
[16:05:11.521]                           }
[16:05:11.521]                         })
[16:05:11.521]                       }
[16:05:11.521]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:11.521]                       base::options(mc.cores = 1L)
[16:05:11.521]                     }
[16:05:11.521]                     base::local({
[16:05:11.521]                       for (pkg in "future") {
[16:05:11.521]                         base::loadNamespace(pkg)
[16:05:11.521]                         base::library(pkg, character.only = TRUE)
[16:05:11.521]                       }
[16:05:11.521]                     })
[16:05:11.521]                   }
[16:05:11.521]                   options(future.plan = NULL)
[16:05:11.521]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:11.521]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:11.521]                 }
[16:05:11.521]                 ...future.workdir <- getwd()
[16:05:11.521]             }
[16:05:11.521]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:11.521]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:11.521]         }
[16:05:11.521]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:11.521]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:11.521]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:11.521]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:11.521]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:11.521]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:11.521]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:11.521]             base::names(...future.oldOptions))
[16:05:11.521]     }
[16:05:11.521]     if (FALSE) {
[16:05:11.521]     }
[16:05:11.521]     else {
[16:05:11.521]         if (TRUE) {
[16:05:11.521]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:11.521]                 open = "w")
[16:05:11.521]         }
[16:05:11.521]         else {
[16:05:11.521]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:11.521]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:11.521]         }
[16:05:11.521]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:11.521]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:11.521]             base::sink(type = "output", split = FALSE)
[16:05:11.521]             base::close(...future.stdout)
[16:05:11.521]         }, add = TRUE)
[16:05:11.521]     }
[16:05:11.521]     ...future.frame <- base::sys.nframe()
[16:05:11.521]     ...future.conditions <- base::list()
[16:05:11.521]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:11.521]     if (FALSE) {
[16:05:11.521]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:11.521]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:11.521]     }
[16:05:11.521]     ...future.result <- base::tryCatch({
[16:05:11.521]         base::withCallingHandlers({
[16:05:11.521]             ...future.value <- base::withVisible(base::local({
[16:05:11.521]                 ...future.makeSendCondition <- base::local({
[16:05:11.521]                   sendCondition <- NULL
[16:05:11.521]                   function(frame = 1L) {
[16:05:11.521]                     if (is.function(sendCondition)) 
[16:05:11.521]                       return(sendCondition)
[16:05:11.521]                     ns <- getNamespace("parallel")
[16:05:11.521]                     if (exists("sendData", mode = "function", 
[16:05:11.521]                       envir = ns)) {
[16:05:11.521]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:11.521]                         envir = ns)
[16:05:11.521]                       envir <- sys.frame(frame)
[16:05:11.521]                       master <- NULL
[16:05:11.521]                       while (!identical(envir, .GlobalEnv) && 
[16:05:11.521]                         !identical(envir, emptyenv())) {
[16:05:11.521]                         if (exists("master", mode = "list", envir = envir, 
[16:05:11.521]                           inherits = FALSE)) {
[16:05:11.521]                           master <- get("master", mode = "list", 
[16:05:11.521]                             envir = envir, inherits = FALSE)
[16:05:11.521]                           if (inherits(master, c("SOCKnode", 
[16:05:11.521]                             "SOCK0node"))) {
[16:05:11.521]                             sendCondition <<- function(cond) {
[16:05:11.521]                               data <- list(type = "VALUE", value = cond, 
[16:05:11.521]                                 success = TRUE)
[16:05:11.521]                               parallel_sendData(master, data)
[16:05:11.521]                             }
[16:05:11.521]                             return(sendCondition)
[16:05:11.521]                           }
[16:05:11.521]                         }
[16:05:11.521]                         frame <- frame + 1L
[16:05:11.521]                         envir <- sys.frame(frame)
[16:05:11.521]                       }
[16:05:11.521]                     }
[16:05:11.521]                     sendCondition <<- function(cond) NULL
[16:05:11.521]                   }
[16:05:11.521]                 })
[16:05:11.521]                 withCallingHandlers({
[16:05:11.521]                   value(a) + 1
[16:05:11.521]                 }, immediateCondition = function(cond) {
[16:05:11.521]                   sendCondition <- ...future.makeSendCondition()
[16:05:11.521]                   sendCondition(cond)
[16:05:11.521]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.521]                   {
[16:05:11.521]                     inherits <- base::inherits
[16:05:11.521]                     invokeRestart <- base::invokeRestart
[16:05:11.521]                     is.null <- base::is.null
[16:05:11.521]                     muffled <- FALSE
[16:05:11.521]                     if (inherits(cond, "message")) {
[16:05:11.521]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:11.521]                       if (muffled) 
[16:05:11.521]                         invokeRestart("muffleMessage")
[16:05:11.521]                     }
[16:05:11.521]                     else if (inherits(cond, "warning")) {
[16:05:11.521]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:11.521]                       if (muffled) 
[16:05:11.521]                         invokeRestart("muffleWarning")
[16:05:11.521]                     }
[16:05:11.521]                     else if (inherits(cond, "condition")) {
[16:05:11.521]                       if (!is.null(pattern)) {
[16:05:11.521]                         computeRestarts <- base::computeRestarts
[16:05:11.521]                         grepl <- base::grepl
[16:05:11.521]                         restarts <- computeRestarts(cond)
[16:05:11.521]                         for (restart in restarts) {
[16:05:11.521]                           name <- restart$name
[16:05:11.521]                           if (is.null(name)) 
[16:05:11.521]                             next
[16:05:11.521]                           if (!grepl(pattern, name)) 
[16:05:11.521]                             next
[16:05:11.521]                           invokeRestart(restart)
[16:05:11.521]                           muffled <- TRUE
[16:05:11.521]                           break
[16:05:11.521]                         }
[16:05:11.521]                       }
[16:05:11.521]                     }
[16:05:11.521]                     invisible(muffled)
[16:05:11.521]                   }
[16:05:11.521]                   muffleCondition(cond)
[16:05:11.521]                 })
[16:05:11.521]             }))
[16:05:11.521]             future::FutureResult(value = ...future.value$value, 
[16:05:11.521]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:11.521]                   ...future.rng), globalenv = if (FALSE) 
[16:05:11.521]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:11.521]                     ...future.globalenv.names))
[16:05:11.521]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:11.521]         }, condition = base::local({
[16:05:11.521]             c <- base::c
[16:05:11.521]             inherits <- base::inherits
[16:05:11.521]             invokeRestart <- base::invokeRestart
[16:05:11.521]             length <- base::length
[16:05:11.521]             list <- base::list
[16:05:11.521]             seq.int <- base::seq.int
[16:05:11.521]             signalCondition <- base::signalCondition
[16:05:11.521]             sys.calls <- base::sys.calls
[16:05:11.521]             `[[` <- base::`[[`
[16:05:11.521]             `+` <- base::`+`
[16:05:11.521]             `<<-` <- base::`<<-`
[16:05:11.521]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:11.521]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:11.521]                   3L)]
[16:05:11.521]             }
[16:05:11.521]             function(cond) {
[16:05:11.521]                 is_error <- inherits(cond, "error")
[16:05:11.521]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:11.521]                   NULL)
[16:05:11.521]                 if (is_error) {
[16:05:11.521]                   sessionInformation <- function() {
[16:05:11.521]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:11.521]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:11.521]                       search = base::search(), system = base::Sys.info())
[16:05:11.521]                   }
[16:05:11.521]                   ...future.conditions[[length(...future.conditions) + 
[16:05:11.521]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:11.521]                     cond$call), session = sessionInformation(), 
[16:05:11.521]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:11.521]                   signalCondition(cond)
[16:05:11.521]                 }
[16:05:11.521]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:11.521]                 "immediateCondition"))) {
[16:05:11.521]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:11.521]                   ...future.conditions[[length(...future.conditions) + 
[16:05:11.521]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:11.521]                   if (TRUE && !signal) {
[16:05:11.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.521]                     {
[16:05:11.521]                       inherits <- base::inherits
[16:05:11.521]                       invokeRestart <- base::invokeRestart
[16:05:11.521]                       is.null <- base::is.null
[16:05:11.521]                       muffled <- FALSE
[16:05:11.521]                       if (inherits(cond, "message")) {
[16:05:11.521]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:11.521]                         if (muffled) 
[16:05:11.521]                           invokeRestart("muffleMessage")
[16:05:11.521]                       }
[16:05:11.521]                       else if (inherits(cond, "warning")) {
[16:05:11.521]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:11.521]                         if (muffled) 
[16:05:11.521]                           invokeRestart("muffleWarning")
[16:05:11.521]                       }
[16:05:11.521]                       else if (inherits(cond, "condition")) {
[16:05:11.521]                         if (!is.null(pattern)) {
[16:05:11.521]                           computeRestarts <- base::computeRestarts
[16:05:11.521]                           grepl <- base::grepl
[16:05:11.521]                           restarts <- computeRestarts(cond)
[16:05:11.521]                           for (restart in restarts) {
[16:05:11.521]                             name <- restart$name
[16:05:11.521]                             if (is.null(name)) 
[16:05:11.521]                               next
[16:05:11.521]                             if (!grepl(pattern, name)) 
[16:05:11.521]                               next
[16:05:11.521]                             invokeRestart(restart)
[16:05:11.521]                             muffled <- TRUE
[16:05:11.521]                             break
[16:05:11.521]                           }
[16:05:11.521]                         }
[16:05:11.521]                       }
[16:05:11.521]                       invisible(muffled)
[16:05:11.521]                     }
[16:05:11.521]                     muffleCondition(cond, pattern = "^muffle")
[16:05:11.521]                   }
[16:05:11.521]                 }
[16:05:11.521]                 else {
[16:05:11.521]                   if (TRUE) {
[16:05:11.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.521]                     {
[16:05:11.521]                       inherits <- base::inherits
[16:05:11.521]                       invokeRestart <- base::invokeRestart
[16:05:11.521]                       is.null <- base::is.null
[16:05:11.521]                       muffled <- FALSE
[16:05:11.521]                       if (inherits(cond, "message")) {
[16:05:11.521]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:11.521]                         if (muffled) 
[16:05:11.521]                           invokeRestart("muffleMessage")
[16:05:11.521]                       }
[16:05:11.521]                       else if (inherits(cond, "warning")) {
[16:05:11.521]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:11.521]                         if (muffled) 
[16:05:11.521]                           invokeRestart("muffleWarning")
[16:05:11.521]                       }
[16:05:11.521]                       else if (inherits(cond, "condition")) {
[16:05:11.521]                         if (!is.null(pattern)) {
[16:05:11.521]                           computeRestarts <- base::computeRestarts
[16:05:11.521]                           grepl <- base::grepl
[16:05:11.521]                           restarts <- computeRestarts(cond)
[16:05:11.521]                           for (restart in restarts) {
[16:05:11.521]                             name <- restart$name
[16:05:11.521]                             if (is.null(name)) 
[16:05:11.521]                               next
[16:05:11.521]                             if (!grepl(pattern, name)) 
[16:05:11.521]                               next
[16:05:11.521]                             invokeRestart(restart)
[16:05:11.521]                             muffled <- TRUE
[16:05:11.521]                             break
[16:05:11.521]                           }
[16:05:11.521]                         }
[16:05:11.521]                       }
[16:05:11.521]                       invisible(muffled)
[16:05:11.521]                     }
[16:05:11.521]                     muffleCondition(cond, pattern = "^muffle")
[16:05:11.521]                   }
[16:05:11.521]                 }
[16:05:11.521]             }
[16:05:11.521]         }))
[16:05:11.521]     }, error = function(ex) {
[16:05:11.521]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:11.521]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:11.521]                 ...future.rng), started = ...future.startTime, 
[16:05:11.521]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:11.521]             version = "1.8"), class = "FutureResult")
[16:05:11.521]     }, finally = {
[16:05:11.521]         if (!identical(...future.workdir, getwd())) 
[16:05:11.521]             setwd(...future.workdir)
[16:05:11.521]         {
[16:05:11.521]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:11.521]                 ...future.oldOptions$nwarnings <- NULL
[16:05:11.521]             }
[16:05:11.521]             base::options(...future.oldOptions)
[16:05:11.521]             if (.Platform$OS.type == "windows") {
[16:05:11.521]                 old_names <- names(...future.oldEnvVars)
[16:05:11.521]                 envs <- base::Sys.getenv()
[16:05:11.521]                 names <- names(envs)
[16:05:11.521]                 common <- intersect(names, old_names)
[16:05:11.521]                 added <- setdiff(names, old_names)
[16:05:11.521]                 removed <- setdiff(old_names, names)
[16:05:11.521]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:11.521]                   envs[common]]
[16:05:11.521]                 NAMES <- toupper(changed)
[16:05:11.521]                 args <- list()
[16:05:11.521]                 for (kk in seq_along(NAMES)) {
[16:05:11.521]                   name <- changed[[kk]]
[16:05:11.521]                   NAME <- NAMES[[kk]]
[16:05:11.521]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.521]                     next
[16:05:11.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:11.521]                 }
[16:05:11.521]                 NAMES <- toupper(added)
[16:05:11.521]                 for (kk in seq_along(NAMES)) {
[16:05:11.521]                   name <- added[[kk]]
[16:05:11.521]                   NAME <- NAMES[[kk]]
[16:05:11.521]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.521]                     next
[16:05:11.521]                   args[[name]] <- ""
[16:05:11.521]                 }
[16:05:11.521]                 NAMES <- toupper(removed)
[16:05:11.521]                 for (kk in seq_along(NAMES)) {
[16:05:11.521]                   name <- removed[[kk]]
[16:05:11.521]                   NAME <- NAMES[[kk]]
[16:05:11.521]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.521]                     next
[16:05:11.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:11.521]                 }
[16:05:11.521]                 if (length(args) > 0) 
[16:05:11.521]                   base::do.call(base::Sys.setenv, args = args)
[16:05:11.521]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:11.521]             }
[16:05:11.521]             else {
[16:05:11.521]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:11.521]             }
[16:05:11.521]             {
[16:05:11.521]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:11.521]                   0L) {
[16:05:11.521]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:11.521]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:11.521]                   base::options(opts)
[16:05:11.521]                 }
[16:05:11.521]                 {
[16:05:11.521]                   {
[16:05:11.521]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:11.521]                     NULL
[16:05:11.521]                   }
[16:05:11.521]                   options(future.plan = NULL)
[16:05:11.521]                   if (is.na(NA_character_)) 
[16:05:11.521]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:11.521]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:11.521]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:11.521]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:11.521]                     envir = parent.frame()) 
[16:05:11.521]                   {
[16:05:11.521]                     if (is.function(workers)) 
[16:05:11.521]                       workers <- workers()
[16:05:11.521]                     workers <- structure(as.integer(workers), 
[16:05:11.521]                       class = class(workers))
[16:05:11.521]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:11.521]                       workers >= 1)
[16:05:11.521]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:11.521]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:11.521]                     }
[16:05:11.521]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:11.521]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:11.521]                       envir = envir)
[16:05:11.521]                     if (!future$lazy) 
[16:05:11.521]                       future <- run(future)
[16:05:11.521]                     invisible(future)
[16:05:11.521]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:11.521]                 }
[16:05:11.521]             }
[16:05:11.521]         }
[16:05:11.521]     })
[16:05:11.521]     if (TRUE) {
[16:05:11.521]         base::sink(type = "output", split = FALSE)
[16:05:11.521]         if (TRUE) {
[16:05:11.521]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:11.521]         }
[16:05:11.521]         else {
[16:05:11.521]             ...future.result["stdout"] <- base::list(NULL)
[16:05:11.521]         }
[16:05:11.521]         base::close(...future.stdout)
[16:05:11.521]         ...future.stdout <- NULL
[16:05:11.521]     }
[16:05:11.521]     ...future.result$conditions <- ...future.conditions
[16:05:11.521]     ...future.result$finished <- base::Sys.time()
[16:05:11.521]     ...future.result
[16:05:11.521] }
[16:05:11.523] Exporting 1 global objects (1.56 MiB) to cluster node #1 ...
[16:05:11.525] Exporting ‘a’ (1.56 MiB) to cluster node #1 ...
[16:05:11.579] Exporting ‘a’ (1.56 MiB) to cluster node #1 ... DONE
[16:05:11.579] Exporting 1 global objects (1.56 MiB) to cluster node #1 ... DONE
[16:05:11.580] MultisessionFuture started
[16:05:11.580] - Launch lazy future ... done
[16:05:11.580] run() for ‘MultisessionFuture’ ... done
[16:05:11.580] result() for ClusterFuture ...
[16:05:11.580] receiveMessageFromWorker() for ClusterFuture ...
[16:05:11.580] - Validating connection of MultisessionFuture
[16:05:11.628] - received message: FutureResult
[16:05:11.629] - Received FutureResult
[16:05:11.629] - Erased future from FutureRegistry
[16:05:11.629] result() for ClusterFuture ...
[16:05:11.629] - result already collected: FutureResult
[16:05:11.629] result() for ClusterFuture ... done
[16:05:11.629] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:11.629] result() for ClusterFuture ... done
[16:05:11.629] result() for ClusterFuture ...
[16:05:11.630] - result already collected: FutureResult
[16:05:11.630] result() for ClusterFuture ... done
value(b) = 2
[16:05:11.630] result() for ClusterFuture ...
[16:05:11.630] - result already collected: FutureResult
[16:05:11.630] result() for ClusterFuture ... done
[16:05:11.630] result() for ClusterFuture ...
[16:05:11.630] - result already collected: FutureResult
[16:05:11.630] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:11.631] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:11.631] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:11.632] - globals found: [2] ‘{’, ‘pkg’
[16:05:11.632] Searching for globals ... DONE
[16:05:11.632] Resolving globals: TRUE
[16:05:11.632] Resolving any globals that are futures ...
[16:05:11.632] - globals: [2] ‘{’, ‘pkg’
[16:05:11.632] Resolving any globals that are futures ... DONE
[16:05:11.633] Resolving futures part of globals (recursively) ...
[16:05:11.633] resolve() on list ...
[16:05:11.633]  recursive: 99
[16:05:11.633]  length: 1
[16:05:11.633]  elements: ‘pkg’
[16:05:11.633]  length: 0 (resolved future 1)
[16:05:11.633] resolve() on list ... DONE
[16:05:11.633] - globals: [1] ‘pkg’
[16:05:11.634] Resolving futures part of globals (recursively) ... DONE
[16:05:11.634] The total size of the 1 globals is 112 bytes (112 bytes)
[16:05:11.634] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[16:05:11.634] - globals: [1] ‘pkg’
[16:05:11.634] 
[16:05:11.634] getGlobalsAndPackages() ... DONE
[16:05:11.635] Packages needed by the future expression (n = 0): <none>
[16:05:11.635] Packages needed by future strategies (n = 0): <none>
[16:05:11.635] {
[16:05:11.635]     {
[16:05:11.635]         {
[16:05:11.635]             ...future.startTime <- base::Sys.time()
[16:05:11.635]             {
[16:05:11.635]                 {
[16:05:11.635]                   {
[16:05:11.635]                     base::local({
[16:05:11.635]                       has_future <- base::requireNamespace("future", 
[16:05:11.635]                         quietly = TRUE)
[16:05:11.635]                       if (has_future) {
[16:05:11.635]                         ns <- base::getNamespace("future")
[16:05:11.635]                         version <- ns[[".package"]][["version"]]
[16:05:11.635]                         if (is.null(version)) 
[16:05:11.635]                           version <- utils::packageVersion("future")
[16:05:11.635]                       }
[16:05:11.635]                       else {
[16:05:11.635]                         version <- NULL
[16:05:11.635]                       }
[16:05:11.635]                       if (!has_future || version < "1.8.0") {
[16:05:11.635]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:11.635]                           "", base::R.version$version.string), 
[16:05:11.635]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:11.635]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:11.635]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:11.635]                             "release", "version")], collapse = " "), 
[16:05:11.635]                           hostname = base::Sys.info()[["nodename"]])
[16:05:11.635]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:11.635]                           info)
[16:05:11.635]                         info <- base::paste(info, collapse = "; ")
[16:05:11.635]                         if (!has_future) {
[16:05:11.635]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:11.635]                             info)
[16:05:11.635]                         }
[16:05:11.635]                         else {
[16:05:11.635]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:11.635]                             info, version)
[16:05:11.635]                         }
[16:05:11.635]                         base::stop(msg)
[16:05:11.635]                       }
[16:05:11.635]                     })
[16:05:11.635]                   }
[16:05:11.635]                   options(future.plan = NULL)
[16:05:11.635]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:11.635]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:11.635]                 }
[16:05:11.635]                 ...future.workdir <- getwd()
[16:05:11.635]             }
[16:05:11.635]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:11.635]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:11.635]         }
[16:05:11.635]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:11.635]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:11.635]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:11.635]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:11.635]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:11.635]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:11.635]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:11.635]             base::names(...future.oldOptions))
[16:05:11.635]     }
[16:05:11.635]     if (FALSE) {
[16:05:11.635]     }
[16:05:11.635]     else {
[16:05:11.635]         if (TRUE) {
[16:05:11.635]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:11.635]                 open = "w")
[16:05:11.635]         }
[16:05:11.635]         else {
[16:05:11.635]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:11.635]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:11.635]         }
[16:05:11.635]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:11.635]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:11.635]             base::sink(type = "output", split = FALSE)
[16:05:11.635]             base::close(...future.stdout)
[16:05:11.635]         }, add = TRUE)
[16:05:11.635]     }
[16:05:11.635]     ...future.frame <- base::sys.nframe()
[16:05:11.635]     ...future.conditions <- base::list()
[16:05:11.635]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:11.635]     if (FALSE) {
[16:05:11.635]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:11.635]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:11.635]     }
[16:05:11.635]     ...future.result <- base::tryCatch({
[16:05:11.635]         base::withCallingHandlers({
[16:05:11.635]             ...future.value <- base::withVisible(base::local({
[16:05:11.635]                 pkg
[16:05:11.635]             }))
[16:05:11.635]             future::FutureResult(value = ...future.value$value, 
[16:05:11.635]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:11.635]                   ...future.rng), globalenv = if (FALSE) 
[16:05:11.635]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:11.635]                     ...future.globalenv.names))
[16:05:11.635]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:11.635]         }, condition = base::local({
[16:05:11.635]             c <- base::c
[16:05:11.635]             inherits <- base::inherits
[16:05:11.635]             invokeRestart <- base::invokeRestart
[16:05:11.635]             length <- base::length
[16:05:11.635]             list <- base::list
[16:05:11.635]             seq.int <- base::seq.int
[16:05:11.635]             signalCondition <- base::signalCondition
[16:05:11.635]             sys.calls <- base::sys.calls
[16:05:11.635]             `[[` <- base::`[[`
[16:05:11.635]             `+` <- base::`+`
[16:05:11.635]             `<<-` <- base::`<<-`
[16:05:11.635]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:11.635]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:11.635]                   3L)]
[16:05:11.635]             }
[16:05:11.635]             function(cond) {
[16:05:11.635]                 is_error <- inherits(cond, "error")
[16:05:11.635]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:11.635]                   NULL)
[16:05:11.635]                 if (is_error) {
[16:05:11.635]                   sessionInformation <- function() {
[16:05:11.635]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:11.635]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:11.635]                       search = base::search(), system = base::Sys.info())
[16:05:11.635]                   }
[16:05:11.635]                   ...future.conditions[[length(...future.conditions) + 
[16:05:11.635]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:11.635]                     cond$call), session = sessionInformation(), 
[16:05:11.635]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:11.635]                   signalCondition(cond)
[16:05:11.635]                 }
[16:05:11.635]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:11.635]                 "immediateCondition"))) {
[16:05:11.635]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:11.635]                   ...future.conditions[[length(...future.conditions) + 
[16:05:11.635]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:11.635]                   if (TRUE && !signal) {
[16:05:11.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.635]                     {
[16:05:11.635]                       inherits <- base::inherits
[16:05:11.635]                       invokeRestart <- base::invokeRestart
[16:05:11.635]                       is.null <- base::is.null
[16:05:11.635]                       muffled <- FALSE
[16:05:11.635]                       if (inherits(cond, "message")) {
[16:05:11.635]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:11.635]                         if (muffled) 
[16:05:11.635]                           invokeRestart("muffleMessage")
[16:05:11.635]                       }
[16:05:11.635]                       else if (inherits(cond, "warning")) {
[16:05:11.635]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:11.635]                         if (muffled) 
[16:05:11.635]                           invokeRestart("muffleWarning")
[16:05:11.635]                       }
[16:05:11.635]                       else if (inherits(cond, "condition")) {
[16:05:11.635]                         if (!is.null(pattern)) {
[16:05:11.635]                           computeRestarts <- base::computeRestarts
[16:05:11.635]                           grepl <- base::grepl
[16:05:11.635]                           restarts <- computeRestarts(cond)
[16:05:11.635]                           for (restart in restarts) {
[16:05:11.635]                             name <- restart$name
[16:05:11.635]                             if (is.null(name)) 
[16:05:11.635]                               next
[16:05:11.635]                             if (!grepl(pattern, name)) 
[16:05:11.635]                               next
[16:05:11.635]                             invokeRestart(restart)
[16:05:11.635]                             muffled <- TRUE
[16:05:11.635]                             break
[16:05:11.635]                           }
[16:05:11.635]                         }
[16:05:11.635]                       }
[16:05:11.635]                       invisible(muffled)
[16:05:11.635]                     }
[16:05:11.635]                     muffleCondition(cond, pattern = "^muffle")
[16:05:11.635]                   }
[16:05:11.635]                 }
[16:05:11.635]                 else {
[16:05:11.635]                   if (TRUE) {
[16:05:11.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.635]                     {
[16:05:11.635]                       inherits <- base::inherits
[16:05:11.635]                       invokeRestart <- base::invokeRestart
[16:05:11.635]                       is.null <- base::is.null
[16:05:11.635]                       muffled <- FALSE
[16:05:11.635]                       if (inherits(cond, "message")) {
[16:05:11.635]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:11.635]                         if (muffled) 
[16:05:11.635]                           invokeRestart("muffleMessage")
[16:05:11.635]                       }
[16:05:11.635]                       else if (inherits(cond, "warning")) {
[16:05:11.635]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:11.635]                         if (muffled) 
[16:05:11.635]                           invokeRestart("muffleWarning")
[16:05:11.635]                       }
[16:05:11.635]                       else if (inherits(cond, "condition")) {
[16:05:11.635]                         if (!is.null(pattern)) {
[16:05:11.635]                           computeRestarts <- base::computeRestarts
[16:05:11.635]                           grepl <- base::grepl
[16:05:11.635]                           restarts <- computeRestarts(cond)
[16:05:11.635]                           for (restart in restarts) {
[16:05:11.635]                             name <- restart$name
[16:05:11.635]                             if (is.null(name)) 
[16:05:11.635]                               next
[16:05:11.635]                             if (!grepl(pattern, name)) 
[16:05:11.635]                               next
[16:05:11.635]                             invokeRestart(restart)
[16:05:11.635]                             muffled <- TRUE
[16:05:11.635]                             break
[16:05:11.635]                           }
[16:05:11.635]                         }
[16:05:11.635]                       }
[16:05:11.635]                       invisible(muffled)
[16:05:11.635]                     }
[16:05:11.635]                     muffleCondition(cond, pattern = "^muffle")
[16:05:11.635]                   }
[16:05:11.635]                 }
[16:05:11.635]             }
[16:05:11.635]         }))
[16:05:11.635]     }, error = function(ex) {
[16:05:11.635]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:11.635]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:11.635]                 ...future.rng), started = ...future.startTime, 
[16:05:11.635]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:11.635]             version = "1.8"), class = "FutureResult")
[16:05:11.635]     }, finally = {
[16:05:11.635]         if (!identical(...future.workdir, getwd())) 
[16:05:11.635]             setwd(...future.workdir)
[16:05:11.635]         {
[16:05:11.635]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:11.635]                 ...future.oldOptions$nwarnings <- NULL
[16:05:11.635]             }
[16:05:11.635]             base::options(...future.oldOptions)
[16:05:11.635]             if (.Platform$OS.type == "windows") {
[16:05:11.635]                 old_names <- names(...future.oldEnvVars)
[16:05:11.635]                 envs <- base::Sys.getenv()
[16:05:11.635]                 names <- names(envs)
[16:05:11.635]                 common <- intersect(names, old_names)
[16:05:11.635]                 added <- setdiff(names, old_names)
[16:05:11.635]                 removed <- setdiff(old_names, names)
[16:05:11.635]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:11.635]                   envs[common]]
[16:05:11.635]                 NAMES <- toupper(changed)
[16:05:11.635]                 args <- list()
[16:05:11.635]                 for (kk in seq_along(NAMES)) {
[16:05:11.635]                   name <- changed[[kk]]
[16:05:11.635]                   NAME <- NAMES[[kk]]
[16:05:11.635]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.635]                     next
[16:05:11.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:11.635]                 }
[16:05:11.635]                 NAMES <- toupper(added)
[16:05:11.635]                 for (kk in seq_along(NAMES)) {
[16:05:11.635]                   name <- added[[kk]]
[16:05:11.635]                   NAME <- NAMES[[kk]]
[16:05:11.635]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.635]                     next
[16:05:11.635]                   args[[name]] <- ""
[16:05:11.635]                 }
[16:05:11.635]                 NAMES <- toupper(removed)
[16:05:11.635]                 for (kk in seq_along(NAMES)) {
[16:05:11.635]                   name <- removed[[kk]]
[16:05:11.635]                   NAME <- NAMES[[kk]]
[16:05:11.635]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.635]                     next
[16:05:11.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:11.635]                 }
[16:05:11.635]                 if (length(args) > 0) 
[16:05:11.635]                   base::do.call(base::Sys.setenv, args = args)
[16:05:11.635]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:11.635]             }
[16:05:11.635]             else {
[16:05:11.635]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:11.635]             }
[16:05:11.635]             {
[16:05:11.635]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:11.635]                   0L) {
[16:05:11.635]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:11.635]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:11.635]                   base::options(opts)
[16:05:11.635]                 }
[16:05:11.635]                 {
[16:05:11.635]                   {
[16:05:11.635]                     NULL
[16:05:11.635]                     RNGkind("Mersenne-Twister")
[16:05:11.635]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:11.635]                       inherits = FALSE)
[16:05:11.635]                   }
[16:05:11.635]                   options(future.plan = NULL)
[16:05:11.635]                   if (is.na(NA_character_)) 
[16:05:11.635]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:11.635]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:11.635]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:11.635]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:11.635]                     envir = parent.frame()) 
[16:05:11.635]                   {
[16:05:11.635]                     if (is.function(workers)) 
[16:05:11.635]                       workers <- workers()
[16:05:11.635]                     workers <- structure(as.integer(workers), 
[16:05:11.635]                       class = class(workers))
[16:05:11.635]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:11.635]                       workers >= 1)
[16:05:11.635]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:11.635]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:11.635]                     }
[16:05:11.635]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:11.635]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:11.635]                       envir = envir)
[16:05:11.635]                     if (!future$lazy) 
[16:05:11.635]                       future <- run(future)
[16:05:11.635]                     invisible(future)
[16:05:11.635]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:11.635]                 }
[16:05:11.635]             }
[16:05:11.635]         }
[16:05:11.635]     })
[16:05:11.635]     if (TRUE) {
[16:05:11.635]         base::sink(type = "output", split = FALSE)
[16:05:11.635]         if (TRUE) {
[16:05:11.635]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:11.635]         }
[16:05:11.635]         else {
[16:05:11.635]             ...future.result["stdout"] <- base::list(NULL)
[16:05:11.635]         }
[16:05:11.635]         base::close(...future.stdout)
[16:05:11.635]         ...future.stdout <- NULL
[16:05:11.635]     }
[16:05:11.635]     ...future.result$conditions <- ...future.conditions
[16:05:11.635]     ...future.result$finished <- base::Sys.time()
[16:05:11.635]     ...future.result
[16:05:11.635] }
[16:05:11.637] assign_globals() ...
[16:05:11.637] List of 1
[16:05:11.637]  $ pkg: chr "foo"
[16:05:11.637]  - attr(*, "where")=List of 1
[16:05:11.637]   ..$ pkg:<environment: R_EmptyEnv> 
[16:05:11.637]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:11.637]  - attr(*, "resolved")= logi TRUE
[16:05:11.637]  - attr(*, "total_size")= num 112
[16:05:11.639] - copied ‘pkg’ to environment
[16:05:11.639] assign_globals() ... done
[16:05:11.640] plan(): Setting new future strategy stack:
[16:05:11.640] List of future strategies:
[16:05:11.640] 1. sequential:
[16:05:11.640]    - args: function (..., envir = parent.frame())
[16:05:11.640]    - tweaked: FALSE
[16:05:11.640]    - call: NULL
[16:05:11.640] plan(): nbrOfWorkers() = 1
[16:05:11.641] plan(): Setting new future strategy stack:
[16:05:11.641] List of future strategies:
[16:05:11.641] 1. multisession:
[16:05:11.641]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:11.641]    - tweaked: FALSE
[16:05:11.641]    - call: plan(strategy)
[16:05:11.644] plan(): nbrOfWorkers() = 2
[16:05:11.645] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:11.645] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:11.645] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:11.647] - globals found: [3] ‘{’, ‘<-’, ‘+’
[16:05:11.647] Searching for globals ... DONE
[16:05:11.647] Resolving globals: TRUE
[16:05:11.647] Resolving any globals that are futures ...
[16:05:11.647] - globals: [3] ‘{’, ‘<-’, ‘+’
[16:05:11.648] Resolving any globals that are futures ... DONE
[16:05:11.648] 
[16:05:11.648] 
[16:05:11.648] getGlobalsAndPackages() ... DONE
[16:05:11.648] run() for ‘Future’ ...
[16:05:11.648] - state: ‘created’
[16:05:11.649] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:11.663] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:11.663] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:11.663]   - Field: ‘node’
[16:05:11.663]   - Field: ‘label’
[16:05:11.663]   - Field: ‘local’
[16:05:11.663]   - Field: ‘owner’
[16:05:11.664]   - Field: ‘envir’
[16:05:11.664]   - Field: ‘workers’
[16:05:11.664]   - Field: ‘packages’
[16:05:11.664]   - Field: ‘gc’
[16:05:11.664]   - Field: ‘conditions’
[16:05:11.664]   - Field: ‘persistent’
[16:05:11.664]   - Field: ‘expr’
[16:05:11.664]   - Field: ‘uuid’
[16:05:11.664]   - Field: ‘seed’
[16:05:11.664]   - Field: ‘version’
[16:05:11.664]   - Field: ‘result’
[16:05:11.665]   - Field: ‘asynchronous’
[16:05:11.665]   - Field: ‘calls’
[16:05:11.665]   - Field: ‘globals’
[16:05:11.665]   - Field: ‘stdout’
[16:05:11.665]   - Field: ‘earlySignal’
[16:05:11.665]   - Field: ‘lazy’
[16:05:11.665]   - Field: ‘state’
[16:05:11.665] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:11.665] - Launch lazy future ...
[16:05:11.666] Packages needed by the future expression (n = 0): <none>
[16:05:11.666] Packages needed by future strategies (n = 0): <none>
[16:05:11.666] {
[16:05:11.666]     {
[16:05:11.666]         {
[16:05:11.666]             ...future.startTime <- base::Sys.time()
[16:05:11.666]             {
[16:05:11.666]                 {
[16:05:11.666]                   {
[16:05:11.666]                     {
[16:05:11.666]                       base::local({
[16:05:11.666]                         has_future <- base::requireNamespace("future", 
[16:05:11.666]                           quietly = TRUE)
[16:05:11.666]                         if (has_future) {
[16:05:11.666]                           ns <- base::getNamespace("future")
[16:05:11.666]                           version <- ns[[".package"]][["version"]]
[16:05:11.666]                           if (is.null(version)) 
[16:05:11.666]                             version <- utils::packageVersion("future")
[16:05:11.666]                         }
[16:05:11.666]                         else {
[16:05:11.666]                           version <- NULL
[16:05:11.666]                         }
[16:05:11.666]                         if (!has_future || version < "1.8.0") {
[16:05:11.666]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:11.666]                             "", base::R.version$version.string), 
[16:05:11.666]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:11.666]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:11.666]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:11.666]                               "release", "version")], collapse = " "), 
[16:05:11.666]                             hostname = base::Sys.info()[["nodename"]])
[16:05:11.666]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:11.666]                             info)
[16:05:11.666]                           info <- base::paste(info, collapse = "; ")
[16:05:11.666]                           if (!has_future) {
[16:05:11.666]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:11.666]                               info)
[16:05:11.666]                           }
[16:05:11.666]                           else {
[16:05:11.666]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:11.666]                               info, version)
[16:05:11.666]                           }
[16:05:11.666]                           base::stop(msg)
[16:05:11.666]                         }
[16:05:11.666]                       })
[16:05:11.666]                     }
[16:05:11.666]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:11.666]                     base::options(mc.cores = 1L)
[16:05:11.666]                   }
[16:05:11.666]                   options(future.plan = NULL)
[16:05:11.666]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:11.666]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:11.666]                 }
[16:05:11.666]                 ...future.workdir <- getwd()
[16:05:11.666]             }
[16:05:11.666]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:11.666]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:11.666]         }
[16:05:11.666]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:11.666]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:11.666]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:11.666]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:11.666]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:11.666]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:11.666]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:11.666]             base::names(...future.oldOptions))
[16:05:11.666]     }
[16:05:11.666]     if (FALSE) {
[16:05:11.666]     }
[16:05:11.666]     else {
[16:05:11.666]         if (TRUE) {
[16:05:11.666]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:11.666]                 open = "w")
[16:05:11.666]         }
[16:05:11.666]         else {
[16:05:11.666]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:11.666]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:11.666]         }
[16:05:11.666]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:11.666]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:11.666]             base::sink(type = "output", split = FALSE)
[16:05:11.666]             base::close(...future.stdout)
[16:05:11.666]         }, add = TRUE)
[16:05:11.666]     }
[16:05:11.666]     ...future.frame <- base::sys.nframe()
[16:05:11.666]     ...future.conditions <- base::list()
[16:05:11.666]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:11.666]     if (FALSE) {
[16:05:11.666]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:11.666]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:11.666]     }
[16:05:11.666]     ...future.result <- base::tryCatch({
[16:05:11.666]         base::withCallingHandlers({
[16:05:11.666]             ...future.value <- base::withVisible(base::local({
[16:05:11.666]                 ...future.makeSendCondition <- base::local({
[16:05:11.666]                   sendCondition <- NULL
[16:05:11.666]                   function(frame = 1L) {
[16:05:11.666]                     if (is.function(sendCondition)) 
[16:05:11.666]                       return(sendCondition)
[16:05:11.666]                     ns <- getNamespace("parallel")
[16:05:11.666]                     if (exists("sendData", mode = "function", 
[16:05:11.666]                       envir = ns)) {
[16:05:11.666]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:11.666]                         envir = ns)
[16:05:11.666]                       envir <- sys.frame(frame)
[16:05:11.666]                       master <- NULL
[16:05:11.666]                       while (!identical(envir, .GlobalEnv) && 
[16:05:11.666]                         !identical(envir, emptyenv())) {
[16:05:11.666]                         if (exists("master", mode = "list", envir = envir, 
[16:05:11.666]                           inherits = FALSE)) {
[16:05:11.666]                           master <- get("master", mode = "list", 
[16:05:11.666]                             envir = envir, inherits = FALSE)
[16:05:11.666]                           if (inherits(master, c("SOCKnode", 
[16:05:11.666]                             "SOCK0node"))) {
[16:05:11.666]                             sendCondition <<- function(cond) {
[16:05:11.666]                               data <- list(type = "VALUE", value = cond, 
[16:05:11.666]                                 success = TRUE)
[16:05:11.666]                               parallel_sendData(master, data)
[16:05:11.666]                             }
[16:05:11.666]                             return(sendCondition)
[16:05:11.666]                           }
[16:05:11.666]                         }
[16:05:11.666]                         frame <- frame + 1L
[16:05:11.666]                         envir <- sys.frame(frame)
[16:05:11.666]                       }
[16:05:11.666]                     }
[16:05:11.666]                     sendCondition <<- function(cond) NULL
[16:05:11.666]                   }
[16:05:11.666]                 })
[16:05:11.666]                 withCallingHandlers({
[16:05:11.666]                   {
[16:05:11.666]                     x <- 0
[16:05:11.666]                     x <- x + 1
[16:05:11.666]                     x
[16:05:11.666]                   }
[16:05:11.666]                 }, immediateCondition = function(cond) {
[16:05:11.666]                   sendCondition <- ...future.makeSendCondition()
[16:05:11.666]                   sendCondition(cond)
[16:05:11.666]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.666]                   {
[16:05:11.666]                     inherits <- base::inherits
[16:05:11.666]                     invokeRestart <- base::invokeRestart
[16:05:11.666]                     is.null <- base::is.null
[16:05:11.666]                     muffled <- FALSE
[16:05:11.666]                     if (inherits(cond, "message")) {
[16:05:11.666]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:11.666]                       if (muffled) 
[16:05:11.666]                         invokeRestart("muffleMessage")
[16:05:11.666]                     }
[16:05:11.666]                     else if (inherits(cond, "warning")) {
[16:05:11.666]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:11.666]                       if (muffled) 
[16:05:11.666]                         invokeRestart("muffleWarning")
[16:05:11.666]                     }
[16:05:11.666]                     else if (inherits(cond, "condition")) {
[16:05:11.666]                       if (!is.null(pattern)) {
[16:05:11.666]                         computeRestarts <- base::computeRestarts
[16:05:11.666]                         grepl <- base::grepl
[16:05:11.666]                         restarts <- computeRestarts(cond)
[16:05:11.666]                         for (restart in restarts) {
[16:05:11.666]                           name <- restart$name
[16:05:11.666]                           if (is.null(name)) 
[16:05:11.666]                             next
[16:05:11.666]                           if (!grepl(pattern, name)) 
[16:05:11.666]                             next
[16:05:11.666]                           invokeRestart(restart)
[16:05:11.666]                           muffled <- TRUE
[16:05:11.666]                           break
[16:05:11.666]                         }
[16:05:11.666]                       }
[16:05:11.666]                     }
[16:05:11.666]                     invisible(muffled)
[16:05:11.666]                   }
[16:05:11.666]                   muffleCondition(cond)
[16:05:11.666]                 })
[16:05:11.666]             }))
[16:05:11.666]             future::FutureResult(value = ...future.value$value, 
[16:05:11.666]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:11.666]                   ...future.rng), globalenv = if (FALSE) 
[16:05:11.666]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:11.666]                     ...future.globalenv.names))
[16:05:11.666]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:11.666]         }, condition = base::local({
[16:05:11.666]             c <- base::c
[16:05:11.666]             inherits <- base::inherits
[16:05:11.666]             invokeRestart <- base::invokeRestart
[16:05:11.666]             length <- base::length
[16:05:11.666]             list <- base::list
[16:05:11.666]             seq.int <- base::seq.int
[16:05:11.666]             signalCondition <- base::signalCondition
[16:05:11.666]             sys.calls <- base::sys.calls
[16:05:11.666]             `[[` <- base::`[[`
[16:05:11.666]             `+` <- base::`+`
[16:05:11.666]             `<<-` <- base::`<<-`
[16:05:11.666]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:11.666]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:11.666]                   3L)]
[16:05:11.666]             }
[16:05:11.666]             function(cond) {
[16:05:11.666]                 is_error <- inherits(cond, "error")
[16:05:11.666]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:11.666]                   NULL)
[16:05:11.666]                 if (is_error) {
[16:05:11.666]                   sessionInformation <- function() {
[16:05:11.666]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:11.666]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:11.666]                       search = base::search(), system = base::Sys.info())
[16:05:11.666]                   }
[16:05:11.666]                   ...future.conditions[[length(...future.conditions) + 
[16:05:11.666]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:11.666]                     cond$call), session = sessionInformation(), 
[16:05:11.666]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:11.666]                   signalCondition(cond)
[16:05:11.666]                 }
[16:05:11.666]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:11.666]                 "immediateCondition"))) {
[16:05:11.666]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:11.666]                   ...future.conditions[[length(...future.conditions) + 
[16:05:11.666]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:11.666]                   if (TRUE && !signal) {
[16:05:11.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.666]                     {
[16:05:11.666]                       inherits <- base::inherits
[16:05:11.666]                       invokeRestart <- base::invokeRestart
[16:05:11.666]                       is.null <- base::is.null
[16:05:11.666]                       muffled <- FALSE
[16:05:11.666]                       if (inherits(cond, "message")) {
[16:05:11.666]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:11.666]                         if (muffled) 
[16:05:11.666]                           invokeRestart("muffleMessage")
[16:05:11.666]                       }
[16:05:11.666]                       else if (inherits(cond, "warning")) {
[16:05:11.666]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:11.666]                         if (muffled) 
[16:05:11.666]                           invokeRestart("muffleWarning")
[16:05:11.666]                       }
[16:05:11.666]                       else if (inherits(cond, "condition")) {
[16:05:11.666]                         if (!is.null(pattern)) {
[16:05:11.666]                           computeRestarts <- base::computeRestarts
[16:05:11.666]                           grepl <- base::grepl
[16:05:11.666]                           restarts <- computeRestarts(cond)
[16:05:11.666]                           for (restart in restarts) {
[16:05:11.666]                             name <- restart$name
[16:05:11.666]                             if (is.null(name)) 
[16:05:11.666]                               next
[16:05:11.666]                             if (!grepl(pattern, name)) 
[16:05:11.666]                               next
[16:05:11.666]                             invokeRestart(restart)
[16:05:11.666]                             muffled <- TRUE
[16:05:11.666]                             break
[16:05:11.666]                           }
[16:05:11.666]                         }
[16:05:11.666]                       }
[16:05:11.666]                       invisible(muffled)
[16:05:11.666]                     }
[16:05:11.666]                     muffleCondition(cond, pattern = "^muffle")
[16:05:11.666]                   }
[16:05:11.666]                 }
[16:05:11.666]                 else {
[16:05:11.666]                   if (TRUE) {
[16:05:11.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.666]                     {
[16:05:11.666]                       inherits <- base::inherits
[16:05:11.666]                       invokeRestart <- base::invokeRestart
[16:05:11.666]                       is.null <- base::is.null
[16:05:11.666]                       muffled <- FALSE
[16:05:11.666]                       if (inherits(cond, "message")) {
[16:05:11.666]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:11.666]                         if (muffled) 
[16:05:11.666]                           invokeRestart("muffleMessage")
[16:05:11.666]                       }
[16:05:11.666]                       else if (inherits(cond, "warning")) {
[16:05:11.666]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:11.666]                         if (muffled) 
[16:05:11.666]                           invokeRestart("muffleWarning")
[16:05:11.666]                       }
[16:05:11.666]                       else if (inherits(cond, "condition")) {
[16:05:11.666]                         if (!is.null(pattern)) {
[16:05:11.666]                           computeRestarts <- base::computeRestarts
[16:05:11.666]                           grepl <- base::grepl
[16:05:11.666]                           restarts <- computeRestarts(cond)
[16:05:11.666]                           for (restart in restarts) {
[16:05:11.666]                             name <- restart$name
[16:05:11.666]                             if (is.null(name)) 
[16:05:11.666]                               next
[16:05:11.666]                             if (!grepl(pattern, name)) 
[16:05:11.666]                               next
[16:05:11.666]                             invokeRestart(restart)
[16:05:11.666]                             muffled <- TRUE
[16:05:11.666]                             break
[16:05:11.666]                           }
[16:05:11.666]                         }
[16:05:11.666]                       }
[16:05:11.666]                       invisible(muffled)
[16:05:11.666]                     }
[16:05:11.666]                     muffleCondition(cond, pattern = "^muffle")
[16:05:11.666]                   }
[16:05:11.666]                 }
[16:05:11.666]             }
[16:05:11.666]         }))
[16:05:11.666]     }, error = function(ex) {
[16:05:11.666]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:11.666]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:11.666]                 ...future.rng), started = ...future.startTime, 
[16:05:11.666]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:11.666]             version = "1.8"), class = "FutureResult")
[16:05:11.666]     }, finally = {
[16:05:11.666]         if (!identical(...future.workdir, getwd())) 
[16:05:11.666]             setwd(...future.workdir)
[16:05:11.666]         {
[16:05:11.666]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:11.666]                 ...future.oldOptions$nwarnings <- NULL
[16:05:11.666]             }
[16:05:11.666]             base::options(...future.oldOptions)
[16:05:11.666]             if (.Platform$OS.type == "windows") {
[16:05:11.666]                 old_names <- names(...future.oldEnvVars)
[16:05:11.666]                 envs <- base::Sys.getenv()
[16:05:11.666]                 names <- names(envs)
[16:05:11.666]                 common <- intersect(names, old_names)
[16:05:11.666]                 added <- setdiff(names, old_names)
[16:05:11.666]                 removed <- setdiff(old_names, names)
[16:05:11.666]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:11.666]                   envs[common]]
[16:05:11.666]                 NAMES <- toupper(changed)
[16:05:11.666]                 args <- list()
[16:05:11.666]                 for (kk in seq_along(NAMES)) {
[16:05:11.666]                   name <- changed[[kk]]
[16:05:11.666]                   NAME <- NAMES[[kk]]
[16:05:11.666]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.666]                     next
[16:05:11.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:11.666]                 }
[16:05:11.666]                 NAMES <- toupper(added)
[16:05:11.666]                 for (kk in seq_along(NAMES)) {
[16:05:11.666]                   name <- added[[kk]]
[16:05:11.666]                   NAME <- NAMES[[kk]]
[16:05:11.666]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.666]                     next
[16:05:11.666]                   args[[name]] <- ""
[16:05:11.666]                 }
[16:05:11.666]                 NAMES <- toupper(removed)
[16:05:11.666]                 for (kk in seq_along(NAMES)) {
[16:05:11.666]                   name <- removed[[kk]]
[16:05:11.666]                   NAME <- NAMES[[kk]]
[16:05:11.666]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.666]                     next
[16:05:11.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:11.666]                 }
[16:05:11.666]                 if (length(args) > 0) 
[16:05:11.666]                   base::do.call(base::Sys.setenv, args = args)
[16:05:11.666]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:11.666]             }
[16:05:11.666]             else {
[16:05:11.666]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:11.666]             }
[16:05:11.666]             {
[16:05:11.666]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:11.666]                   0L) {
[16:05:11.666]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:11.666]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:11.666]                   base::options(opts)
[16:05:11.666]                 }
[16:05:11.666]                 {
[16:05:11.666]                   {
[16:05:11.666]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:11.666]                     NULL
[16:05:11.666]                   }
[16:05:11.666]                   options(future.plan = NULL)
[16:05:11.666]                   if (is.na(NA_character_)) 
[16:05:11.666]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:11.666]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:11.666]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:11.666]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:11.666]                     envir = parent.frame()) 
[16:05:11.666]                   {
[16:05:11.666]                     if (is.function(workers)) 
[16:05:11.666]                       workers <- workers()
[16:05:11.666]                     workers <- structure(as.integer(workers), 
[16:05:11.666]                       class = class(workers))
[16:05:11.666]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:11.666]                       workers >= 1)
[16:05:11.666]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:11.666]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:11.666]                     }
[16:05:11.666]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:11.666]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:11.666]                       envir = envir)
[16:05:11.666]                     if (!future$lazy) 
[16:05:11.666]                       future <- run(future)
[16:05:11.666]                     invisible(future)
[16:05:11.666]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:11.666]                 }
[16:05:11.666]             }
[16:05:11.666]         }
[16:05:11.666]     })
[16:05:11.666]     if (TRUE) {
[16:05:11.666]         base::sink(type = "output", split = FALSE)
[16:05:11.666]         if (TRUE) {
[16:05:11.666]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:11.666]         }
[16:05:11.666]         else {
[16:05:11.666]             ...future.result["stdout"] <- base::list(NULL)
[16:05:11.666]         }
[16:05:11.666]         base::close(...future.stdout)
[16:05:11.666]         ...future.stdout <- NULL
[16:05:11.666]     }
[16:05:11.666]     ...future.result$conditions <- ...future.conditions
[16:05:11.666]     ...future.result$finished <- base::Sys.time()
[16:05:11.666]     ...future.result
[16:05:11.666] }
[16:05:11.669] MultisessionFuture started
[16:05:11.669] - Launch lazy future ... done
[16:05:11.669] run() for ‘MultisessionFuture’ ... done
[16:05:11.669] result() for ClusterFuture ...
[16:05:11.670] receiveMessageFromWorker() for ClusterFuture ...
[16:05:11.670] - Validating connection of MultisessionFuture
[16:05:11.716] - received message: FutureResult
[16:05:11.716] - Received FutureResult
[16:05:11.716] - Erased future from FutureRegistry
[16:05:11.716] result() for ClusterFuture ...
[16:05:11.716] - result already collected: FutureResult
[16:05:11.717] result() for ClusterFuture ... done
[16:05:11.717] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:11.717] result() for ClusterFuture ... done
[16:05:11.717] result() for ClusterFuture ...
[16:05:11.717] - result already collected: FutureResult
[16:05:11.717] result() for ClusterFuture ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:11.717] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:11.717] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:11.719] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[16:05:11.719] Searching for globals ... DONE
[16:05:11.719] Resolving globals: TRUE
[16:05:11.719] Resolving any globals that are futures ...
[16:05:11.719] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[16:05:11.719] Resolving any globals that are futures ... DONE
[16:05:11.720] Resolving futures part of globals (recursively) ...
[16:05:11.720] resolve() on list ...
[16:05:11.720]  recursive: 99
[16:05:11.720]  length: 1
[16:05:11.720]  elements: ‘x’
[16:05:11.720]  length: 0 (resolved future 1)
[16:05:11.721] resolve() on list ... DONE
[16:05:11.721] - globals: [1] ‘x’
[16:05:11.721] Resolving futures part of globals (recursively) ... DONE
[16:05:11.721] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:11.721] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[16:05:11.721] - globals: [1] ‘x’
[16:05:11.721] 
[16:05:11.722] getGlobalsAndPackages() ... DONE
[16:05:11.722] run() for ‘Future’ ...
[16:05:11.722] - state: ‘created’
[16:05:11.722] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:11.736] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:11.736] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:11.736]   - Field: ‘node’
[16:05:11.736]   - Field: ‘label’
[16:05:11.736]   - Field: ‘local’
[16:05:11.736]   - Field: ‘owner’
[16:05:11.737]   - Field: ‘envir’
[16:05:11.737]   - Field: ‘workers’
[16:05:11.737]   - Field: ‘packages’
[16:05:11.737]   - Field: ‘gc’
[16:05:11.737]   - Field: ‘conditions’
[16:05:11.737]   - Field: ‘persistent’
[16:05:11.737]   - Field: ‘expr’
[16:05:11.737]   - Field: ‘uuid’
[16:05:11.737]   - Field: ‘seed’
[16:05:11.737]   - Field: ‘version’
[16:05:11.737]   - Field: ‘result’
[16:05:11.738]   - Field: ‘asynchronous’
[16:05:11.738]   - Field: ‘calls’
[16:05:11.738]   - Field: ‘globals’
[16:05:11.738]   - Field: ‘stdout’
[16:05:11.738]   - Field: ‘earlySignal’
[16:05:11.738]   - Field: ‘lazy’
[16:05:11.738]   - Field: ‘state’
[16:05:11.738] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:11.738] - Launch lazy future ...
[16:05:11.739] Packages needed by the future expression (n = 0): <none>
[16:05:11.739] Packages needed by future strategies (n = 0): <none>
[16:05:11.739] {
[16:05:11.739]     {
[16:05:11.739]         {
[16:05:11.739]             ...future.startTime <- base::Sys.time()
[16:05:11.739]             {
[16:05:11.739]                 {
[16:05:11.739]                   {
[16:05:11.739]                     {
[16:05:11.739]                       base::local({
[16:05:11.739]                         has_future <- base::requireNamespace("future", 
[16:05:11.739]                           quietly = TRUE)
[16:05:11.739]                         if (has_future) {
[16:05:11.739]                           ns <- base::getNamespace("future")
[16:05:11.739]                           version <- ns[[".package"]][["version"]]
[16:05:11.739]                           if (is.null(version)) 
[16:05:11.739]                             version <- utils::packageVersion("future")
[16:05:11.739]                         }
[16:05:11.739]                         else {
[16:05:11.739]                           version <- NULL
[16:05:11.739]                         }
[16:05:11.739]                         if (!has_future || version < "1.8.0") {
[16:05:11.739]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:11.739]                             "", base::R.version$version.string), 
[16:05:11.739]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:11.739]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:11.739]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:11.739]                               "release", "version")], collapse = " "), 
[16:05:11.739]                             hostname = base::Sys.info()[["nodename"]])
[16:05:11.739]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:11.739]                             info)
[16:05:11.739]                           info <- base::paste(info, collapse = "; ")
[16:05:11.739]                           if (!has_future) {
[16:05:11.739]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:11.739]                               info)
[16:05:11.739]                           }
[16:05:11.739]                           else {
[16:05:11.739]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:11.739]                               info, version)
[16:05:11.739]                           }
[16:05:11.739]                           base::stop(msg)
[16:05:11.739]                         }
[16:05:11.739]                       })
[16:05:11.739]                     }
[16:05:11.739]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:11.739]                     base::options(mc.cores = 1L)
[16:05:11.739]                   }
[16:05:11.739]                   options(future.plan = NULL)
[16:05:11.739]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:11.739]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:11.739]                 }
[16:05:11.739]                 ...future.workdir <- getwd()
[16:05:11.739]             }
[16:05:11.739]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:11.739]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:11.739]         }
[16:05:11.739]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:11.739]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:11.739]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:11.739]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:11.739]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:11.739]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:11.739]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:11.739]             base::names(...future.oldOptions))
[16:05:11.739]     }
[16:05:11.739]     if (FALSE) {
[16:05:11.739]     }
[16:05:11.739]     else {
[16:05:11.739]         if (TRUE) {
[16:05:11.739]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:11.739]                 open = "w")
[16:05:11.739]         }
[16:05:11.739]         else {
[16:05:11.739]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:11.739]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:11.739]         }
[16:05:11.739]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:11.739]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:11.739]             base::sink(type = "output", split = FALSE)
[16:05:11.739]             base::close(...future.stdout)
[16:05:11.739]         }, add = TRUE)
[16:05:11.739]     }
[16:05:11.739]     ...future.frame <- base::sys.nframe()
[16:05:11.739]     ...future.conditions <- base::list()
[16:05:11.739]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:11.739]     if (FALSE) {
[16:05:11.739]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:11.739]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:11.739]     }
[16:05:11.739]     ...future.result <- base::tryCatch({
[16:05:11.739]         base::withCallingHandlers({
[16:05:11.739]             ...future.value <- base::withVisible(base::local({
[16:05:11.739]                 ...future.makeSendCondition <- base::local({
[16:05:11.739]                   sendCondition <- NULL
[16:05:11.739]                   function(frame = 1L) {
[16:05:11.739]                     if (is.function(sendCondition)) 
[16:05:11.739]                       return(sendCondition)
[16:05:11.739]                     ns <- getNamespace("parallel")
[16:05:11.739]                     if (exists("sendData", mode = "function", 
[16:05:11.739]                       envir = ns)) {
[16:05:11.739]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:11.739]                         envir = ns)
[16:05:11.739]                       envir <- sys.frame(frame)
[16:05:11.739]                       master <- NULL
[16:05:11.739]                       while (!identical(envir, .GlobalEnv) && 
[16:05:11.739]                         !identical(envir, emptyenv())) {
[16:05:11.739]                         if (exists("master", mode = "list", envir = envir, 
[16:05:11.739]                           inherits = FALSE)) {
[16:05:11.739]                           master <- get("master", mode = "list", 
[16:05:11.739]                             envir = envir, inherits = FALSE)
[16:05:11.739]                           if (inherits(master, c("SOCKnode", 
[16:05:11.739]                             "SOCK0node"))) {
[16:05:11.739]                             sendCondition <<- function(cond) {
[16:05:11.739]                               data <- list(type = "VALUE", value = cond, 
[16:05:11.739]                                 success = TRUE)
[16:05:11.739]                               parallel_sendData(master, data)
[16:05:11.739]                             }
[16:05:11.739]                             return(sendCondition)
[16:05:11.739]                           }
[16:05:11.739]                         }
[16:05:11.739]                         frame <- frame + 1L
[16:05:11.739]                         envir <- sys.frame(frame)
[16:05:11.739]                       }
[16:05:11.739]                     }
[16:05:11.739]                     sendCondition <<- function(cond) NULL
[16:05:11.739]                   }
[16:05:11.739]                 })
[16:05:11.739]                 withCallingHandlers({
[16:05:11.739]                   {
[16:05:11.739]                     x <- x + 1
[16:05:11.739]                     x
[16:05:11.739]                   }
[16:05:11.739]                 }, immediateCondition = function(cond) {
[16:05:11.739]                   sendCondition <- ...future.makeSendCondition()
[16:05:11.739]                   sendCondition(cond)
[16:05:11.739]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.739]                   {
[16:05:11.739]                     inherits <- base::inherits
[16:05:11.739]                     invokeRestart <- base::invokeRestart
[16:05:11.739]                     is.null <- base::is.null
[16:05:11.739]                     muffled <- FALSE
[16:05:11.739]                     if (inherits(cond, "message")) {
[16:05:11.739]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:11.739]                       if (muffled) 
[16:05:11.739]                         invokeRestart("muffleMessage")
[16:05:11.739]                     }
[16:05:11.739]                     else if (inherits(cond, "warning")) {
[16:05:11.739]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:11.739]                       if (muffled) 
[16:05:11.739]                         invokeRestart("muffleWarning")
[16:05:11.739]                     }
[16:05:11.739]                     else if (inherits(cond, "condition")) {
[16:05:11.739]                       if (!is.null(pattern)) {
[16:05:11.739]                         computeRestarts <- base::computeRestarts
[16:05:11.739]                         grepl <- base::grepl
[16:05:11.739]                         restarts <- computeRestarts(cond)
[16:05:11.739]                         for (restart in restarts) {
[16:05:11.739]                           name <- restart$name
[16:05:11.739]                           if (is.null(name)) 
[16:05:11.739]                             next
[16:05:11.739]                           if (!grepl(pattern, name)) 
[16:05:11.739]                             next
[16:05:11.739]                           invokeRestart(restart)
[16:05:11.739]                           muffled <- TRUE
[16:05:11.739]                           break
[16:05:11.739]                         }
[16:05:11.739]                       }
[16:05:11.739]                     }
[16:05:11.739]                     invisible(muffled)
[16:05:11.739]                   }
[16:05:11.739]                   muffleCondition(cond)
[16:05:11.739]                 })
[16:05:11.739]             }))
[16:05:11.739]             future::FutureResult(value = ...future.value$value, 
[16:05:11.739]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:11.739]                   ...future.rng), globalenv = if (FALSE) 
[16:05:11.739]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:11.739]                     ...future.globalenv.names))
[16:05:11.739]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:11.739]         }, condition = base::local({
[16:05:11.739]             c <- base::c
[16:05:11.739]             inherits <- base::inherits
[16:05:11.739]             invokeRestart <- base::invokeRestart
[16:05:11.739]             length <- base::length
[16:05:11.739]             list <- base::list
[16:05:11.739]             seq.int <- base::seq.int
[16:05:11.739]             signalCondition <- base::signalCondition
[16:05:11.739]             sys.calls <- base::sys.calls
[16:05:11.739]             `[[` <- base::`[[`
[16:05:11.739]             `+` <- base::`+`
[16:05:11.739]             `<<-` <- base::`<<-`
[16:05:11.739]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:11.739]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:11.739]                   3L)]
[16:05:11.739]             }
[16:05:11.739]             function(cond) {
[16:05:11.739]                 is_error <- inherits(cond, "error")
[16:05:11.739]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:11.739]                   NULL)
[16:05:11.739]                 if (is_error) {
[16:05:11.739]                   sessionInformation <- function() {
[16:05:11.739]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:11.739]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:11.739]                       search = base::search(), system = base::Sys.info())
[16:05:11.739]                   }
[16:05:11.739]                   ...future.conditions[[length(...future.conditions) + 
[16:05:11.739]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:11.739]                     cond$call), session = sessionInformation(), 
[16:05:11.739]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:11.739]                   signalCondition(cond)
[16:05:11.739]                 }
[16:05:11.739]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:11.739]                 "immediateCondition"))) {
[16:05:11.739]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:11.739]                   ...future.conditions[[length(...future.conditions) + 
[16:05:11.739]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:11.739]                   if (TRUE && !signal) {
[16:05:11.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.739]                     {
[16:05:11.739]                       inherits <- base::inherits
[16:05:11.739]                       invokeRestart <- base::invokeRestart
[16:05:11.739]                       is.null <- base::is.null
[16:05:11.739]                       muffled <- FALSE
[16:05:11.739]                       if (inherits(cond, "message")) {
[16:05:11.739]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:11.739]                         if (muffled) 
[16:05:11.739]                           invokeRestart("muffleMessage")
[16:05:11.739]                       }
[16:05:11.739]                       else if (inherits(cond, "warning")) {
[16:05:11.739]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:11.739]                         if (muffled) 
[16:05:11.739]                           invokeRestart("muffleWarning")
[16:05:11.739]                       }
[16:05:11.739]                       else if (inherits(cond, "condition")) {
[16:05:11.739]                         if (!is.null(pattern)) {
[16:05:11.739]                           computeRestarts <- base::computeRestarts
[16:05:11.739]                           grepl <- base::grepl
[16:05:11.739]                           restarts <- computeRestarts(cond)
[16:05:11.739]                           for (restart in restarts) {
[16:05:11.739]                             name <- restart$name
[16:05:11.739]                             if (is.null(name)) 
[16:05:11.739]                               next
[16:05:11.739]                             if (!grepl(pattern, name)) 
[16:05:11.739]                               next
[16:05:11.739]                             invokeRestart(restart)
[16:05:11.739]                             muffled <- TRUE
[16:05:11.739]                             break
[16:05:11.739]                           }
[16:05:11.739]                         }
[16:05:11.739]                       }
[16:05:11.739]                       invisible(muffled)
[16:05:11.739]                     }
[16:05:11.739]                     muffleCondition(cond, pattern = "^muffle")
[16:05:11.739]                   }
[16:05:11.739]                 }
[16:05:11.739]                 else {
[16:05:11.739]                   if (TRUE) {
[16:05:11.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.739]                     {
[16:05:11.739]                       inherits <- base::inherits
[16:05:11.739]                       invokeRestart <- base::invokeRestart
[16:05:11.739]                       is.null <- base::is.null
[16:05:11.739]                       muffled <- FALSE
[16:05:11.739]                       if (inherits(cond, "message")) {
[16:05:11.739]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:11.739]                         if (muffled) 
[16:05:11.739]                           invokeRestart("muffleMessage")
[16:05:11.739]                       }
[16:05:11.739]                       else if (inherits(cond, "warning")) {
[16:05:11.739]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:11.739]                         if (muffled) 
[16:05:11.739]                           invokeRestart("muffleWarning")
[16:05:11.739]                       }
[16:05:11.739]                       else if (inherits(cond, "condition")) {
[16:05:11.739]                         if (!is.null(pattern)) {
[16:05:11.739]                           computeRestarts <- base::computeRestarts
[16:05:11.739]                           grepl <- base::grepl
[16:05:11.739]                           restarts <- computeRestarts(cond)
[16:05:11.739]                           for (restart in restarts) {
[16:05:11.739]                             name <- restart$name
[16:05:11.739]                             if (is.null(name)) 
[16:05:11.739]                               next
[16:05:11.739]                             if (!grepl(pattern, name)) 
[16:05:11.739]                               next
[16:05:11.739]                             invokeRestart(restart)
[16:05:11.739]                             muffled <- TRUE
[16:05:11.739]                             break
[16:05:11.739]                           }
[16:05:11.739]                         }
[16:05:11.739]                       }
[16:05:11.739]                       invisible(muffled)
[16:05:11.739]                     }
[16:05:11.739]                     muffleCondition(cond, pattern = "^muffle")
[16:05:11.739]                   }
[16:05:11.739]                 }
[16:05:11.739]             }
[16:05:11.739]         }))
[16:05:11.739]     }, error = function(ex) {
[16:05:11.739]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:11.739]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:11.739]                 ...future.rng), started = ...future.startTime, 
[16:05:11.739]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:11.739]             version = "1.8"), class = "FutureResult")
[16:05:11.739]     }, finally = {
[16:05:11.739]         if (!identical(...future.workdir, getwd())) 
[16:05:11.739]             setwd(...future.workdir)
[16:05:11.739]         {
[16:05:11.739]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:11.739]                 ...future.oldOptions$nwarnings <- NULL
[16:05:11.739]             }
[16:05:11.739]             base::options(...future.oldOptions)
[16:05:11.739]             if (.Platform$OS.type == "windows") {
[16:05:11.739]                 old_names <- names(...future.oldEnvVars)
[16:05:11.739]                 envs <- base::Sys.getenv()
[16:05:11.739]                 names <- names(envs)
[16:05:11.739]                 common <- intersect(names, old_names)
[16:05:11.739]                 added <- setdiff(names, old_names)
[16:05:11.739]                 removed <- setdiff(old_names, names)
[16:05:11.739]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:11.739]                   envs[common]]
[16:05:11.739]                 NAMES <- toupper(changed)
[16:05:11.739]                 args <- list()
[16:05:11.739]                 for (kk in seq_along(NAMES)) {
[16:05:11.739]                   name <- changed[[kk]]
[16:05:11.739]                   NAME <- NAMES[[kk]]
[16:05:11.739]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.739]                     next
[16:05:11.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:11.739]                 }
[16:05:11.739]                 NAMES <- toupper(added)
[16:05:11.739]                 for (kk in seq_along(NAMES)) {
[16:05:11.739]                   name <- added[[kk]]
[16:05:11.739]                   NAME <- NAMES[[kk]]
[16:05:11.739]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.739]                     next
[16:05:11.739]                   args[[name]] <- ""
[16:05:11.739]                 }
[16:05:11.739]                 NAMES <- toupper(removed)
[16:05:11.739]                 for (kk in seq_along(NAMES)) {
[16:05:11.739]                   name <- removed[[kk]]
[16:05:11.739]                   NAME <- NAMES[[kk]]
[16:05:11.739]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.739]                     next
[16:05:11.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:11.739]                 }
[16:05:11.739]                 if (length(args) > 0) 
[16:05:11.739]                   base::do.call(base::Sys.setenv, args = args)
[16:05:11.739]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:11.739]             }
[16:05:11.739]             else {
[16:05:11.739]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:11.739]             }
[16:05:11.739]             {
[16:05:11.739]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:11.739]                   0L) {
[16:05:11.739]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:11.739]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:11.739]                   base::options(opts)
[16:05:11.739]                 }
[16:05:11.739]                 {
[16:05:11.739]                   {
[16:05:11.739]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:11.739]                     NULL
[16:05:11.739]                   }
[16:05:11.739]                   options(future.plan = NULL)
[16:05:11.739]                   if (is.na(NA_character_)) 
[16:05:11.739]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:11.739]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:11.739]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:11.739]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:11.739]                     envir = parent.frame()) 
[16:05:11.739]                   {
[16:05:11.739]                     if (is.function(workers)) 
[16:05:11.739]                       workers <- workers()
[16:05:11.739]                     workers <- structure(as.integer(workers), 
[16:05:11.739]                       class = class(workers))
[16:05:11.739]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:11.739]                       workers >= 1)
[16:05:11.739]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:11.739]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:11.739]                     }
[16:05:11.739]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:11.739]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:11.739]                       envir = envir)
[16:05:11.739]                     if (!future$lazy) 
[16:05:11.739]                       future <- run(future)
[16:05:11.739]                     invisible(future)
[16:05:11.739]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:11.739]                 }
[16:05:11.739]             }
[16:05:11.739]         }
[16:05:11.739]     })
[16:05:11.739]     if (TRUE) {
[16:05:11.739]         base::sink(type = "output", split = FALSE)
[16:05:11.739]         if (TRUE) {
[16:05:11.739]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:11.739]         }
[16:05:11.739]         else {
[16:05:11.739]             ...future.result["stdout"] <- base::list(NULL)
[16:05:11.739]         }
[16:05:11.739]         base::close(...future.stdout)
[16:05:11.739]         ...future.stdout <- NULL
[16:05:11.739]     }
[16:05:11.739]     ...future.result$conditions <- ...future.conditions
[16:05:11.739]     ...future.result$finished <- base::Sys.time()
[16:05:11.739]     ...future.result
[16:05:11.739] }
[16:05:11.742] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:05:11.742] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[16:05:11.742] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[16:05:11.742] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:05:11.743] MultisessionFuture started
[16:05:11.743] - Launch lazy future ... done
[16:05:11.743] run() for ‘MultisessionFuture’ ... done
[16:05:11.743] result() for ClusterFuture ...
[16:05:11.743] receiveMessageFromWorker() for ClusterFuture ...
[16:05:11.743] - Validating connection of MultisessionFuture
[16:05:11.788] - received message: FutureResult
[16:05:11.788] - Received FutureResult
[16:05:11.788] - Erased future from FutureRegistry
[16:05:11.788] result() for ClusterFuture ...
[16:05:11.788] - result already collected: FutureResult
[16:05:11.788] result() for ClusterFuture ... done
[16:05:11.788] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:11.788] result() for ClusterFuture ... done
[16:05:11.788] result() for ClusterFuture ...
[16:05:11.789] - result already collected: FutureResult
[16:05:11.789] result() for ClusterFuture ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:05:11.789] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:05:11.789] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:05:11.791] - globals found: [3] ‘{’, ‘<-’, ‘x’
[16:05:11.791] Searching for globals ... DONE
[16:05:11.791] Resolving globals: TRUE
[16:05:11.791] Resolving any globals that are futures ...
[16:05:11.791] - globals: [3] ‘{’, ‘<-’, ‘x’
[16:05:11.791] Resolving any globals that are futures ... DONE
[16:05:11.792] Resolving futures part of globals (recursively) ...
[16:05:11.792] resolve() on list ...
[16:05:11.792]  recursive: 99
[16:05:11.792]  length: 1
[16:05:11.792]  elements: ‘x’
[16:05:11.792]  length: 0 (resolved future 1)
[16:05:11.792] resolve() on list ... DONE
[16:05:11.792] - globals: [1] ‘x’
[16:05:11.792] Resolving futures part of globals (recursively) ... DONE
[16:05:11.793] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[16:05:11.793] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[16:05:11.793] - globals: [1] ‘x’
[16:05:11.793] 
[16:05:11.793] getGlobalsAndPackages() ... DONE
[16:05:11.793] run() for ‘Future’ ...
[16:05:11.794] - state: ‘created’
[16:05:11.794] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:11.807] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:11.807] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:11.808]   - Field: ‘node’
[16:05:11.808]   - Field: ‘label’
[16:05:11.808]   - Field: ‘local’
[16:05:11.808]   - Field: ‘owner’
[16:05:11.808]   - Field: ‘envir’
[16:05:11.808]   - Field: ‘workers’
[16:05:11.808]   - Field: ‘packages’
[16:05:11.808]   - Field: ‘gc’
[16:05:11.808]   - Field: ‘conditions’
[16:05:11.808]   - Field: ‘persistent’
[16:05:11.808]   - Field: ‘expr’
[16:05:11.809]   - Field: ‘uuid’
[16:05:11.809]   - Field: ‘seed’
[16:05:11.809]   - Field: ‘version’
[16:05:11.809]   - Field: ‘result’
[16:05:11.809]   - Field: ‘asynchronous’
[16:05:11.809]   - Field: ‘calls’
[16:05:11.809]   - Field: ‘globals’
[16:05:11.809]   - Field: ‘stdout’
[16:05:11.809]   - Field: ‘earlySignal’
[16:05:11.809]   - Field: ‘lazy’
[16:05:11.809]   - Field: ‘state’
[16:05:11.810] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:11.810] - Launch lazy future ...
[16:05:11.810] Packages needed by the future expression (n = 0): <none>
[16:05:11.810] Packages needed by future strategies (n = 0): <none>
[16:05:11.810] {
[16:05:11.810]     {
[16:05:11.810]         {
[16:05:11.810]             ...future.startTime <- base::Sys.time()
[16:05:11.810]             {
[16:05:11.810]                 {
[16:05:11.810]                   {
[16:05:11.810]                     {
[16:05:11.810]                       base::local({
[16:05:11.810]                         has_future <- base::requireNamespace("future", 
[16:05:11.810]                           quietly = TRUE)
[16:05:11.810]                         if (has_future) {
[16:05:11.810]                           ns <- base::getNamespace("future")
[16:05:11.810]                           version <- ns[[".package"]][["version"]]
[16:05:11.810]                           if (is.null(version)) 
[16:05:11.810]                             version <- utils::packageVersion("future")
[16:05:11.810]                         }
[16:05:11.810]                         else {
[16:05:11.810]                           version <- NULL
[16:05:11.810]                         }
[16:05:11.810]                         if (!has_future || version < "1.8.0") {
[16:05:11.810]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:11.810]                             "", base::R.version$version.string), 
[16:05:11.810]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:11.810]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:11.810]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:11.810]                               "release", "version")], collapse = " "), 
[16:05:11.810]                             hostname = base::Sys.info()[["nodename"]])
[16:05:11.810]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:11.810]                             info)
[16:05:11.810]                           info <- base::paste(info, collapse = "; ")
[16:05:11.810]                           if (!has_future) {
[16:05:11.810]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:11.810]                               info)
[16:05:11.810]                           }
[16:05:11.810]                           else {
[16:05:11.810]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:11.810]                               info, version)
[16:05:11.810]                           }
[16:05:11.810]                           base::stop(msg)
[16:05:11.810]                         }
[16:05:11.810]                       })
[16:05:11.810]                     }
[16:05:11.810]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:11.810]                     base::options(mc.cores = 1L)
[16:05:11.810]                   }
[16:05:11.810]                   options(future.plan = NULL)
[16:05:11.810]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:11.810]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:11.810]                 }
[16:05:11.810]                 ...future.workdir <- getwd()
[16:05:11.810]             }
[16:05:11.810]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:11.810]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:11.810]         }
[16:05:11.810]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:05:11.810]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:05:11.810]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:05:11.810]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:05:11.810]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:11.810]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:11.810]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:11.810]             base::names(...future.oldOptions))
[16:05:11.810]     }
[16:05:11.810]     if (FALSE) {
[16:05:11.810]     }
[16:05:11.810]     else {
[16:05:11.810]         if (TRUE) {
[16:05:11.810]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:11.810]                 open = "w")
[16:05:11.810]         }
[16:05:11.810]         else {
[16:05:11.810]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:11.810]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:11.810]         }
[16:05:11.810]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:11.810]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:11.810]             base::sink(type = "output", split = FALSE)
[16:05:11.810]             base::close(...future.stdout)
[16:05:11.810]         }, add = TRUE)
[16:05:11.810]     }
[16:05:11.810]     ...future.frame <- base::sys.nframe()
[16:05:11.810]     ...future.conditions <- base::list()
[16:05:11.810]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:11.810]     if (FALSE) {
[16:05:11.810]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:11.810]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:11.810]     }
[16:05:11.810]     ...future.result <- base::tryCatch({
[16:05:11.810]         base::withCallingHandlers({
[16:05:11.810]             ...future.value <- base::withVisible(base::local({
[16:05:11.810]                 ...future.makeSendCondition <- base::local({
[16:05:11.810]                   sendCondition <- NULL
[16:05:11.810]                   function(frame = 1L) {
[16:05:11.810]                     if (is.function(sendCondition)) 
[16:05:11.810]                       return(sendCondition)
[16:05:11.810]                     ns <- getNamespace("parallel")
[16:05:11.810]                     if (exists("sendData", mode = "function", 
[16:05:11.810]                       envir = ns)) {
[16:05:11.810]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:11.810]                         envir = ns)
[16:05:11.810]                       envir <- sys.frame(frame)
[16:05:11.810]                       master <- NULL
[16:05:11.810]                       while (!identical(envir, .GlobalEnv) && 
[16:05:11.810]                         !identical(envir, emptyenv())) {
[16:05:11.810]                         if (exists("master", mode = "list", envir = envir, 
[16:05:11.810]                           inherits = FALSE)) {
[16:05:11.810]                           master <- get("master", mode = "list", 
[16:05:11.810]                             envir = envir, inherits = FALSE)
[16:05:11.810]                           if (inherits(master, c("SOCKnode", 
[16:05:11.810]                             "SOCK0node"))) {
[16:05:11.810]                             sendCondition <<- function(cond) {
[16:05:11.810]                               data <- list(type = "VALUE", value = cond, 
[16:05:11.810]                                 success = TRUE)
[16:05:11.810]                               parallel_sendData(master, data)
[16:05:11.810]                             }
[16:05:11.810]                             return(sendCondition)
[16:05:11.810]                           }
[16:05:11.810]                         }
[16:05:11.810]                         frame <- frame + 1L
[16:05:11.810]                         envir <- sys.frame(frame)
[16:05:11.810]                       }
[16:05:11.810]                     }
[16:05:11.810]                     sendCondition <<- function(cond) NULL
[16:05:11.810]                   }
[16:05:11.810]                 })
[16:05:11.810]                 withCallingHandlers({
[16:05:11.810]                   {
[16:05:11.810]                     x <- x()
[16:05:11.810]                     x
[16:05:11.810]                   }
[16:05:11.810]                 }, immediateCondition = function(cond) {
[16:05:11.810]                   sendCondition <- ...future.makeSendCondition()
[16:05:11.810]                   sendCondition(cond)
[16:05:11.810]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.810]                   {
[16:05:11.810]                     inherits <- base::inherits
[16:05:11.810]                     invokeRestart <- base::invokeRestart
[16:05:11.810]                     is.null <- base::is.null
[16:05:11.810]                     muffled <- FALSE
[16:05:11.810]                     if (inherits(cond, "message")) {
[16:05:11.810]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:11.810]                       if (muffled) 
[16:05:11.810]                         invokeRestart("muffleMessage")
[16:05:11.810]                     }
[16:05:11.810]                     else if (inherits(cond, "warning")) {
[16:05:11.810]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:11.810]                       if (muffled) 
[16:05:11.810]                         invokeRestart("muffleWarning")
[16:05:11.810]                     }
[16:05:11.810]                     else if (inherits(cond, "condition")) {
[16:05:11.810]                       if (!is.null(pattern)) {
[16:05:11.810]                         computeRestarts <- base::computeRestarts
[16:05:11.810]                         grepl <- base::grepl
[16:05:11.810]                         restarts <- computeRestarts(cond)
[16:05:11.810]                         for (restart in restarts) {
[16:05:11.810]                           name <- restart$name
[16:05:11.810]                           if (is.null(name)) 
[16:05:11.810]                             next
[16:05:11.810]                           if (!grepl(pattern, name)) 
[16:05:11.810]                             next
[16:05:11.810]                           invokeRestart(restart)
[16:05:11.810]                           muffled <- TRUE
[16:05:11.810]                           break
[16:05:11.810]                         }
[16:05:11.810]                       }
[16:05:11.810]                     }
[16:05:11.810]                     invisible(muffled)
[16:05:11.810]                   }
[16:05:11.810]                   muffleCondition(cond)
[16:05:11.810]                 })
[16:05:11.810]             }))
[16:05:11.810]             future::FutureResult(value = ...future.value$value, 
[16:05:11.810]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:11.810]                   ...future.rng), globalenv = if (FALSE) 
[16:05:11.810]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:11.810]                     ...future.globalenv.names))
[16:05:11.810]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:11.810]         }, condition = base::local({
[16:05:11.810]             c <- base::c
[16:05:11.810]             inherits <- base::inherits
[16:05:11.810]             invokeRestart <- base::invokeRestart
[16:05:11.810]             length <- base::length
[16:05:11.810]             list <- base::list
[16:05:11.810]             seq.int <- base::seq.int
[16:05:11.810]             signalCondition <- base::signalCondition
[16:05:11.810]             sys.calls <- base::sys.calls
[16:05:11.810]             `[[` <- base::`[[`
[16:05:11.810]             `+` <- base::`+`
[16:05:11.810]             `<<-` <- base::`<<-`
[16:05:11.810]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:11.810]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:11.810]                   3L)]
[16:05:11.810]             }
[16:05:11.810]             function(cond) {
[16:05:11.810]                 is_error <- inherits(cond, "error")
[16:05:11.810]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:11.810]                   NULL)
[16:05:11.810]                 if (is_error) {
[16:05:11.810]                   sessionInformation <- function() {
[16:05:11.810]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:11.810]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:11.810]                       search = base::search(), system = base::Sys.info())
[16:05:11.810]                   }
[16:05:11.810]                   ...future.conditions[[length(...future.conditions) + 
[16:05:11.810]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:11.810]                     cond$call), session = sessionInformation(), 
[16:05:11.810]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:11.810]                   signalCondition(cond)
[16:05:11.810]                 }
[16:05:11.810]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:11.810]                 "immediateCondition"))) {
[16:05:11.810]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:11.810]                   ...future.conditions[[length(...future.conditions) + 
[16:05:11.810]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:11.810]                   if (TRUE && !signal) {
[16:05:11.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.810]                     {
[16:05:11.810]                       inherits <- base::inherits
[16:05:11.810]                       invokeRestart <- base::invokeRestart
[16:05:11.810]                       is.null <- base::is.null
[16:05:11.810]                       muffled <- FALSE
[16:05:11.810]                       if (inherits(cond, "message")) {
[16:05:11.810]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:11.810]                         if (muffled) 
[16:05:11.810]                           invokeRestart("muffleMessage")
[16:05:11.810]                       }
[16:05:11.810]                       else if (inherits(cond, "warning")) {
[16:05:11.810]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:11.810]                         if (muffled) 
[16:05:11.810]                           invokeRestart("muffleWarning")
[16:05:11.810]                       }
[16:05:11.810]                       else if (inherits(cond, "condition")) {
[16:05:11.810]                         if (!is.null(pattern)) {
[16:05:11.810]                           computeRestarts <- base::computeRestarts
[16:05:11.810]                           grepl <- base::grepl
[16:05:11.810]                           restarts <- computeRestarts(cond)
[16:05:11.810]                           for (restart in restarts) {
[16:05:11.810]                             name <- restart$name
[16:05:11.810]                             if (is.null(name)) 
[16:05:11.810]                               next
[16:05:11.810]                             if (!grepl(pattern, name)) 
[16:05:11.810]                               next
[16:05:11.810]                             invokeRestart(restart)
[16:05:11.810]                             muffled <- TRUE
[16:05:11.810]                             break
[16:05:11.810]                           }
[16:05:11.810]                         }
[16:05:11.810]                       }
[16:05:11.810]                       invisible(muffled)
[16:05:11.810]                     }
[16:05:11.810]                     muffleCondition(cond, pattern = "^muffle")
[16:05:11.810]                   }
[16:05:11.810]                 }
[16:05:11.810]                 else {
[16:05:11.810]                   if (TRUE) {
[16:05:11.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:11.810]                     {
[16:05:11.810]                       inherits <- base::inherits
[16:05:11.810]                       invokeRestart <- base::invokeRestart
[16:05:11.810]                       is.null <- base::is.null
[16:05:11.810]                       muffled <- FALSE
[16:05:11.810]                       if (inherits(cond, "message")) {
[16:05:11.810]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:11.810]                         if (muffled) 
[16:05:11.810]                           invokeRestart("muffleMessage")
[16:05:11.810]                       }
[16:05:11.810]                       else if (inherits(cond, "warning")) {
[16:05:11.810]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:11.810]                         if (muffled) 
[16:05:11.810]                           invokeRestart("muffleWarning")
[16:05:11.810]                       }
[16:05:11.810]                       else if (inherits(cond, "condition")) {
[16:05:11.810]                         if (!is.null(pattern)) {
[16:05:11.810]                           computeRestarts <- base::computeRestarts
[16:05:11.810]                           grepl <- base::grepl
[16:05:11.810]                           restarts <- computeRestarts(cond)
[16:05:11.810]                           for (restart in restarts) {
[16:05:11.810]                             name <- restart$name
[16:05:11.810]                             if (is.null(name)) 
[16:05:11.810]                               next
[16:05:11.810]                             if (!grepl(pattern, name)) 
[16:05:11.810]                               next
[16:05:11.810]                             invokeRestart(restart)
[16:05:11.810]                             muffled <- TRUE
[16:05:11.810]                             break
[16:05:11.810]                           }
[16:05:11.810]                         }
[16:05:11.810]                       }
[16:05:11.810]                       invisible(muffled)
[16:05:11.810]                     }
[16:05:11.810]                     muffleCondition(cond, pattern = "^muffle")
[16:05:11.810]                   }
[16:05:11.810]                 }
[16:05:11.810]             }
[16:05:11.810]         }))
[16:05:11.810]     }, error = function(ex) {
[16:05:11.810]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:11.810]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:11.810]                 ...future.rng), started = ...future.startTime, 
[16:05:11.810]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:11.810]             version = "1.8"), class = "FutureResult")
[16:05:11.810]     }, finally = {
[16:05:11.810]         if (!identical(...future.workdir, getwd())) 
[16:05:11.810]             setwd(...future.workdir)
[16:05:11.810]         {
[16:05:11.810]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:11.810]                 ...future.oldOptions$nwarnings <- NULL
[16:05:11.810]             }
[16:05:11.810]             base::options(...future.oldOptions)
[16:05:11.810]             if (.Platform$OS.type == "windows") {
[16:05:11.810]                 old_names <- names(...future.oldEnvVars)
[16:05:11.810]                 envs <- base::Sys.getenv()
[16:05:11.810]                 names <- names(envs)
[16:05:11.810]                 common <- intersect(names, old_names)
[16:05:11.810]                 added <- setdiff(names, old_names)
[16:05:11.810]                 removed <- setdiff(old_names, names)
[16:05:11.810]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:11.810]                   envs[common]]
[16:05:11.810]                 NAMES <- toupper(changed)
[16:05:11.810]                 args <- list()
[16:05:11.810]                 for (kk in seq_along(NAMES)) {
[16:05:11.810]                   name <- changed[[kk]]
[16:05:11.810]                   NAME <- NAMES[[kk]]
[16:05:11.810]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.810]                     next
[16:05:11.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:11.810]                 }
[16:05:11.810]                 NAMES <- toupper(added)
[16:05:11.810]                 for (kk in seq_along(NAMES)) {
[16:05:11.810]                   name <- added[[kk]]
[16:05:11.810]                   NAME <- NAMES[[kk]]
[16:05:11.810]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.810]                     next
[16:05:11.810]                   args[[name]] <- ""
[16:05:11.810]                 }
[16:05:11.810]                 NAMES <- toupper(removed)
[16:05:11.810]                 for (kk in seq_along(NAMES)) {
[16:05:11.810]                   name <- removed[[kk]]
[16:05:11.810]                   NAME <- NAMES[[kk]]
[16:05:11.810]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:11.810]                     next
[16:05:11.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:11.810]                 }
[16:05:11.810]                 if (length(args) > 0) 
[16:05:11.810]                   base::do.call(base::Sys.setenv, args = args)
[16:05:11.810]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:11.810]             }
[16:05:11.810]             else {
[16:05:11.810]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:11.810]             }
[16:05:11.810]             {
[16:05:11.810]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:11.810]                   0L) {
[16:05:11.810]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:11.810]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:11.810]                   base::options(opts)
[16:05:11.810]                 }
[16:05:11.810]                 {
[16:05:11.810]                   {
[16:05:11.810]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:11.810]                     NULL
[16:05:11.810]                   }
[16:05:11.810]                   options(future.plan = NULL)
[16:05:11.810]                   if (is.na(NA_character_)) 
[16:05:11.810]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:11.810]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:11.810]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:11.810]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:11.810]                     envir = parent.frame()) 
[16:05:11.810]                   {
[16:05:11.810]                     if (is.function(workers)) 
[16:05:11.810]                       workers <- workers()
[16:05:11.810]                     workers <- structure(as.integer(workers), 
[16:05:11.810]                       class = class(workers))
[16:05:11.810]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:11.810]                       workers >= 1)
[16:05:11.810]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:11.810]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:11.810]                     }
[16:05:11.810]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:11.810]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:11.810]                       envir = envir)
[16:05:11.810]                     if (!future$lazy) 
[16:05:11.810]                       future <- run(future)
[16:05:11.810]                     invisible(future)
[16:05:11.810]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:11.810]                 }
[16:05:11.810]             }
[16:05:11.810]         }
[16:05:11.810]     })
[16:05:11.810]     if (TRUE) {
[16:05:11.810]         base::sink(type = "output", split = FALSE)
[16:05:11.810]         if (TRUE) {
[16:05:11.810]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:11.810]         }
[16:05:11.810]         else {
[16:05:11.810]             ...future.result["stdout"] <- base::list(NULL)
[16:05:11.810]         }
[16:05:11.810]         base::close(...future.stdout)
[16:05:11.810]         ...future.stdout <- NULL
[16:05:11.810]     }
[16:05:11.810]     ...future.result$conditions <- ...future.conditions
[16:05:11.810]     ...future.result$finished <- base::Sys.time()
[16:05:11.810]     ...future.result
[16:05:11.810] }
[16:05:11.813] Exporting 1 global objects (1.01 KiB) to cluster node #1 ...
[16:05:11.813] Exporting ‘x’ (1.01 KiB) to cluster node #1 ...
[16:05:11.814] Exporting ‘x’ (1.01 KiB) to cluster node #1 ... DONE
[16:05:11.814] Exporting 1 global objects (1.01 KiB) to cluster node #1 ... DONE
[16:05:11.814] MultisessionFuture started
[16:05:11.814] - Launch lazy future ... done
[16:05:11.814] run() for ‘MultisessionFuture’ ... done
[16:05:11.815] result() for ClusterFuture ...
[16:05:11.815] receiveMessageFromWorker() for ClusterFuture ...
[16:05:11.815] - Validating connection of MultisessionFuture
[16:05:11.860] - received message: FutureResult
[16:05:11.860] - Received FutureResult
[16:05:11.860] - Erased future from FutureRegistry
[16:05:11.860] result() for ClusterFuture ...
[16:05:11.860] - result already collected: FutureResult
[16:05:11.860] result() for ClusterFuture ... done
[16:05:11.860] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:11.860] result() for ClusterFuture ... done
[16:05:11.861] result() for ClusterFuture ...
[16:05:11.861] - result already collected: FutureResult
[16:05:11.861] result() for ClusterFuture ... done
value(f) = ‘TRUE’
Testing with 2 cores ... DONE
> 
> message("*** Tricky use cases related to globals ... DONE")
*** Tricky use cases related to globals ... DONE
> 
> source("incl/end.R")
[16:05:11.861] plan(): Setting new future strategy stack:
[16:05:11.862] List of future strategies:
[16:05:11.862] 1. FutureStrategy:
[16:05:11.862]    - args: function (..., envir = parent.frame())
[16:05:11.862]    - tweaked: FALSE
[16:05:11.862]    - call: future::plan(oplan)
[16:05:11.862] plan(): nbrOfWorkers() = 1
> 
