
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:05:31.444] plan(): Setting new future strategy stack:
[16:05:31.444] List of future strategies:
[16:05:31.444] 1. sequential:
[16:05:31.444]    - args: function (..., envir = parent.frame())
[16:05:31.444]    - tweaked: FALSE
[16:05:31.444]    - call: future::plan("sequential")
[16:05:31.457] plan(): nbrOfWorkers() = 1
> 
> strategies <- supportedStrategies()
> 
> message("*** Nested futures ...")
*** Nested futures ...
> 
> for (strategy1 in strategies) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   for (strategy2 in strategies) {
+     message(sprintf("- plan(list('%s', '%s')) ...", strategy1, strategy2))
+     plan(list(a = strategy1, b = strategy2))
+     
+     nested <- plan("list")
+     stopifnot(
+       length(nested) == 2L,
+       all(names(nested) == c("a", "b")),
+       inherits(plan("next"), strategy1)
+     )
+ 
+     x %<-% {
+       a <- 1L
+ 
+       ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+       ## we're exporting the plan() function including its local stack!
+       plan_a <- unclass(future::plan("list"))
+       nested_a <- nested[-1]
+ 
+       stopifnot(
+         length(nested_a) == 1L,
+         length(plan_a) == 1L,
+         inherits(plan_a[[1]], "future"),
+         inherits(future::plan("next"), strategy2)
+       )
+ 
+       ## Attribute 'init' is modified at run time
+       for (kk in seq_along(plan_a)) attr(plan_a[[kk]], "init") <- NULL
+       for (kk in seq_along(nested_a)) attr(nested_a[[kk]], "init") <- NULL
+       stopifnot(all.equal(plan_a, nested_a))
+ 
+       y %<-% {
+         b <- 2L
+         
+         ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+         ## we're exporting the plan() function including its local stack!
+         plan_b <- future::plan("list")
+         nested_b <- nested_a[-1]
+ 
+         stopifnot(
+           length(nested_b) == 0L,
+           length(plan_b) == 1L,
+           inherits(plan_b[[1]], "future"),
+           inherits(future::plan("next"), "sequential")
+         )
+ 
+         list(a = a, nested_a = nested_a, plan_a = plan_a,
+              b = b, nested_b = nested_b, plan_b = plan_b)
+       }
+       y
+     }
+ 
+     str(x)
+ 
+     stopifnot(
+       length(x) == 3 * length(nested),
+       all(names(x) == c("a", "nested_a", "plan_a",
+                         "b", "nested_b", "plan_b")),
+ 
+       x$a == 1L,
+       length(x$nested_a) == 1L,
+       is.list(x$plan_a),
+       length(x$plan_a) == 1L,
+       inherits(x$plan_a[[1]], "future"),
+ 
+       x$b == 2L,
+       length(x$nested_b) == 0L,
+       is.list(x$plan_b),
+       length(x$plan_b) == 1L,
+       inherits(x$plan_b[[1]], "future"),
+       inherits(x$plan_b[[1]], "sequential")
+     )
+ 
+     ## Attribute 'init' is modified at run time
+     for (kk in seq_along(x$plan_a)) attr(x$plan_a[[kk]], "init") <- NULL
+     for (kk in seq_along(nested)) attr(nested[[kk]], "init") <- NULL
+     stopifnot(all.equal(x$plan_a, nested[-1L]))
+ 
+     rm(list = c("nested", "x"))
+ 
+ 
+     ## Nested futures and globals
+     ## In future (<= 1.7.0), the below would produce an error saying
+     ## "Failed to locate global object in the relevant environments: 'a'"
+     ## Related to https://github.com/HenrikBengtsson/globals/issues/35
+     data <- data.frame(a = 1:3, b = 3:1)
+     y_truth <- subset(data, a == 2)
+     f <- future({
+       value(future( subset(data, a == 2) ))
+     })
+     y <- value(f)
+     stopifnot(identical(y, y_truth))
+     
+     message(sprintf("- plan(list('%s', '%s')) ... DONE", strategy1, strategy2))
+   }
+ }
- plan(list('sequential', 'sequential')) ...
[16:05:31.508] plan(): Setting new future strategy stack:
[16:05:31.508] List of future strategies:
[16:05:31.508] 1. sequential:
[16:05:31.508]    - args: function (..., envir = parent.frame())
[16:05:31.508]    - tweaked: FALSE
[16:05:31.508]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:31.508] 2. sequential:
[16:05:31.508]    - args: function (..., envir = parent.frame())
[16:05:31.508]    - tweaked: FALSE
[16:05:31.508]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:31.519] plan(): nbrOfWorkers() = 1
[16:05:31.520] getGlobalsAndPackages() ...
[16:05:31.521] Searching for globals...
[16:05:31.542] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:05:31.542] Searching for globals ... DONE
[16:05:31.543] Resolving globals: FALSE
[16:05:31.544] The total size of the 2 globals is 22.60 KiB (23144 bytes)
[16:05:31.545] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 22.60 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (22.48 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:05:31.545] - globals: [2] ‘nested’, ‘strategy2’
[16:05:31.545] - packages: [1] ‘future’
[16:05:31.545] getGlobalsAndPackages() ... DONE
[16:05:31.546] run() for ‘Future’ ...
[16:05:31.546] - state: ‘created’
[16:05:31.546] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:31.547] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:31.547] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:31.547]   - Field: ‘label’
[16:05:31.547]   - Field: ‘local’
[16:05:31.547]   - Field: ‘owner’
[16:05:31.547]   - Field: ‘envir’
[16:05:31.547]   - Field: ‘packages’
[16:05:31.547]   - Field: ‘gc’
[16:05:31.547]   - Field: ‘conditions’
[16:05:31.547]   - Field: ‘expr’
[16:05:31.548]   - Field: ‘uuid’
[16:05:31.548]   - Field: ‘seed’
[16:05:31.548]   - Field: ‘version’
[16:05:31.548]   - Field: ‘result’
[16:05:31.548]   - Field: ‘asynchronous’
[16:05:31.548]   - Field: ‘calls’
[16:05:31.548]   - Field: ‘globals’
[16:05:31.548]   - Field: ‘stdout’
[16:05:31.548]   - Field: ‘earlySignal’
[16:05:31.548]   - Field: ‘lazy’
[16:05:31.548]   - Field: ‘state’
[16:05:31.548] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:31.549] - Launch lazy future ...
[16:05:31.549] Packages needed by the future expression (n = 1): ‘future’
[16:05:31.550] Packages needed by future strategies (n = 1): ‘future’
[16:05:31.550] {
[16:05:31.550]     {
[16:05:31.550]         {
[16:05:31.550]             ...future.startTime <- base::Sys.time()
[16:05:31.550]             {
[16:05:31.550]                 {
[16:05:31.550]                   {
[16:05:31.550]                     {
[16:05:31.550]                       base::local({
[16:05:31.550]                         has_future <- base::requireNamespace("future", 
[16:05:31.550]                           quietly = TRUE)
[16:05:31.550]                         if (has_future) {
[16:05:31.550]                           ns <- base::getNamespace("future")
[16:05:31.550]                           version <- ns[[".package"]][["version"]]
[16:05:31.550]                           if (is.null(version)) 
[16:05:31.550]                             version <- utils::packageVersion("future")
[16:05:31.550]                         }
[16:05:31.550]                         else {
[16:05:31.550]                           version <- NULL
[16:05:31.550]                         }
[16:05:31.550]                         if (!has_future || version < "1.8.0") {
[16:05:31.550]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:31.550]                             "", base::R.version$version.string), 
[16:05:31.550]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:31.550]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:31.550]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:31.550]                               "release", "version")], collapse = " "), 
[16:05:31.550]                             hostname = base::Sys.info()[["nodename"]])
[16:05:31.550]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:31.550]                             info)
[16:05:31.550]                           info <- base::paste(info, collapse = "; ")
[16:05:31.550]                           if (!has_future) {
[16:05:31.550]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:31.550]                               info)
[16:05:31.550]                           }
[16:05:31.550]                           else {
[16:05:31.550]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:31.550]                               info, version)
[16:05:31.550]                           }
[16:05:31.550]                           base::stop(msg)
[16:05:31.550]                         }
[16:05:31.550]                       })
[16:05:31.550]                     }
[16:05:31.550]                     base::local({
[16:05:31.550]                       for (pkg in "future") {
[16:05:31.550]                         base::loadNamespace(pkg)
[16:05:31.550]                         base::library(pkg, character.only = TRUE)
[16:05:31.550]                       }
[16:05:31.550]                     })
[16:05:31.550]                   }
[16:05:31.550]                   options(future.plan = NULL)
[16:05:31.550]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:31.550]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:05:31.550]                   {
[16:05:31.550]                     future <- SequentialFuture(..., envir = envir)
[16:05:31.550]                     if (!future$lazy) 
[16:05:31.550]                       future <- run(future)
[16:05:31.550]                     invisible(future)
[16:05:31.550]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:31.550]                 }
[16:05:31.550]                 ...future.workdir <- getwd()
[16:05:31.550]             }
[16:05:31.550]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:31.550]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:31.550]         }
[16:05:31.550]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:31.550]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:31.550]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:31.550]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:31.550]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:31.550]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:31.550]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:31.550]             base::names(...future.oldOptions))
[16:05:31.550]     }
[16:05:31.550]     if (FALSE) {
[16:05:31.550]     }
[16:05:31.550]     else {
[16:05:31.550]         if (TRUE) {
[16:05:31.550]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:31.550]                 open = "w")
[16:05:31.550]         }
[16:05:31.550]         else {
[16:05:31.550]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:31.550]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:31.550]         }
[16:05:31.550]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:31.550]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:31.550]             base::sink(type = "output", split = FALSE)
[16:05:31.550]             base::close(...future.stdout)
[16:05:31.550]         }, add = TRUE)
[16:05:31.550]     }
[16:05:31.550]     ...future.frame <- base::sys.nframe()
[16:05:31.550]     ...future.conditions <- base::list()
[16:05:31.550]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:31.550]     if (FALSE) {
[16:05:31.550]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:31.550]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:31.550]     }
[16:05:31.550]     ...future.result <- base::tryCatch({
[16:05:31.550]         base::withCallingHandlers({
[16:05:31.550]             ...future.value <- base::withVisible(base::local({
[16:05:31.550]                 a <- 1L
[16:05:31.550]                 plan_a <- unclass(future::plan("list"))
[16:05:31.550]                 nested_a <- nested[-1]
[16:05:31.550]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:05:31.550]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:05:31.550]                   strategy2))
[16:05:31.550]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:05:31.550]                   "init") <- NULL
[16:05:31.550]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:05:31.550]                   "init") <- NULL
[16:05:31.550]                 stopifnot(all.equal(plan_a, nested_a))
[16:05:31.550]                 y %<-% {
[16:05:31.550]                   b <- 2L
[16:05:31.550]                   plan_b <- future::plan("list")
[16:05:31.550]                   nested_b <- nested_a[-1]
[16:05:31.550]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:05:31.550]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:05:31.550]                     "sequential"))
[16:05:31.550]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:05:31.550]                     b = b, nested_b = nested_b, plan_b = plan_b)
[16:05:31.550]                 }
[16:05:31.550]                 y
[16:05:31.550]             }))
[16:05:31.550]             future::FutureResult(value = ...future.value$value, 
[16:05:31.550]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:31.550]                   ...future.rng), globalenv = if (FALSE) 
[16:05:31.550]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:31.550]                     ...future.globalenv.names))
[16:05:31.550]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:31.550]         }, condition = base::local({
[16:05:31.550]             c <- base::c
[16:05:31.550]             inherits <- base::inherits
[16:05:31.550]             invokeRestart <- base::invokeRestart
[16:05:31.550]             length <- base::length
[16:05:31.550]             list <- base::list
[16:05:31.550]             seq.int <- base::seq.int
[16:05:31.550]             signalCondition <- base::signalCondition
[16:05:31.550]             sys.calls <- base::sys.calls
[16:05:31.550]             `[[` <- base::`[[`
[16:05:31.550]             `+` <- base::`+`
[16:05:31.550]             `<<-` <- base::`<<-`
[16:05:31.550]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:31.550]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:31.550]                   3L)]
[16:05:31.550]             }
[16:05:31.550]             function(cond) {
[16:05:31.550]                 is_error <- inherits(cond, "error")
[16:05:31.550]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:31.550]                   NULL)
[16:05:31.550]                 if (is_error) {
[16:05:31.550]                   sessionInformation <- function() {
[16:05:31.550]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:31.550]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:31.550]                       search = base::search(), system = base::Sys.info())
[16:05:31.550]                   }
[16:05:31.550]                   ...future.conditions[[length(...future.conditions) + 
[16:05:31.550]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:31.550]                     cond$call), session = sessionInformation(), 
[16:05:31.550]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:31.550]                   signalCondition(cond)
[16:05:31.550]                 }
[16:05:31.550]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:31.550]                 "immediateCondition"))) {
[16:05:31.550]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:31.550]                   ...future.conditions[[length(...future.conditions) + 
[16:05:31.550]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:31.550]                   if (TRUE && !signal) {
[16:05:31.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:31.550]                     {
[16:05:31.550]                       inherits <- base::inherits
[16:05:31.550]                       invokeRestart <- base::invokeRestart
[16:05:31.550]                       is.null <- base::is.null
[16:05:31.550]                       muffled <- FALSE
[16:05:31.550]                       if (inherits(cond, "message")) {
[16:05:31.550]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:31.550]                         if (muffled) 
[16:05:31.550]                           invokeRestart("muffleMessage")
[16:05:31.550]                       }
[16:05:31.550]                       else if (inherits(cond, "warning")) {
[16:05:31.550]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:31.550]                         if (muffled) 
[16:05:31.550]                           invokeRestart("muffleWarning")
[16:05:31.550]                       }
[16:05:31.550]                       else if (inherits(cond, "condition")) {
[16:05:31.550]                         if (!is.null(pattern)) {
[16:05:31.550]                           computeRestarts <- base::computeRestarts
[16:05:31.550]                           grepl <- base::grepl
[16:05:31.550]                           restarts <- computeRestarts(cond)
[16:05:31.550]                           for (restart in restarts) {
[16:05:31.550]                             name <- restart$name
[16:05:31.550]                             if (is.null(name)) 
[16:05:31.550]                               next
[16:05:31.550]                             if (!grepl(pattern, name)) 
[16:05:31.550]                               next
[16:05:31.550]                             invokeRestart(restart)
[16:05:31.550]                             muffled <- TRUE
[16:05:31.550]                             break
[16:05:31.550]                           }
[16:05:31.550]                         }
[16:05:31.550]                       }
[16:05:31.550]                       invisible(muffled)
[16:05:31.550]                     }
[16:05:31.550]                     muffleCondition(cond, pattern = "^muffle")
[16:05:31.550]                   }
[16:05:31.550]                 }
[16:05:31.550]                 else {
[16:05:31.550]                   if (TRUE) {
[16:05:31.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:31.550]                     {
[16:05:31.550]                       inherits <- base::inherits
[16:05:31.550]                       invokeRestart <- base::invokeRestart
[16:05:31.550]                       is.null <- base::is.null
[16:05:31.550]                       muffled <- FALSE
[16:05:31.550]                       if (inherits(cond, "message")) {
[16:05:31.550]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:31.550]                         if (muffled) 
[16:05:31.550]                           invokeRestart("muffleMessage")
[16:05:31.550]                       }
[16:05:31.550]                       else if (inherits(cond, "warning")) {
[16:05:31.550]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:31.550]                         if (muffled) 
[16:05:31.550]                           invokeRestart("muffleWarning")
[16:05:31.550]                       }
[16:05:31.550]                       else if (inherits(cond, "condition")) {
[16:05:31.550]                         if (!is.null(pattern)) {
[16:05:31.550]                           computeRestarts <- base::computeRestarts
[16:05:31.550]                           grepl <- base::grepl
[16:05:31.550]                           restarts <- computeRestarts(cond)
[16:05:31.550]                           for (restart in restarts) {
[16:05:31.550]                             name <- restart$name
[16:05:31.550]                             if (is.null(name)) 
[16:05:31.550]                               next
[16:05:31.550]                             if (!grepl(pattern, name)) 
[16:05:31.550]                               next
[16:05:31.550]                             invokeRestart(restart)
[16:05:31.550]                             muffled <- TRUE
[16:05:31.550]                             break
[16:05:31.550]                           }
[16:05:31.550]                         }
[16:05:31.550]                       }
[16:05:31.550]                       invisible(muffled)
[16:05:31.550]                     }
[16:05:31.550]                     muffleCondition(cond, pattern = "^muffle")
[16:05:31.550]                   }
[16:05:31.550]                 }
[16:05:31.550]             }
[16:05:31.550]         }))
[16:05:31.550]     }, error = function(ex) {
[16:05:31.550]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:31.550]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:31.550]                 ...future.rng), started = ...future.startTime, 
[16:05:31.550]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:31.550]             version = "1.8"), class = "FutureResult")
[16:05:31.550]     }, finally = {
[16:05:31.550]         if (!identical(...future.workdir, getwd())) 
[16:05:31.550]             setwd(...future.workdir)
[16:05:31.550]         {
[16:05:31.550]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:31.550]                 ...future.oldOptions$nwarnings <- NULL
[16:05:31.550]             }
[16:05:31.550]             base::options(...future.oldOptions)
[16:05:31.550]             if (.Platform$OS.type == "windows") {
[16:05:31.550]                 old_names <- names(...future.oldEnvVars)
[16:05:31.550]                 envs <- base::Sys.getenv()
[16:05:31.550]                 names <- names(envs)
[16:05:31.550]                 common <- intersect(names, old_names)
[16:05:31.550]                 added <- setdiff(names, old_names)
[16:05:31.550]                 removed <- setdiff(old_names, names)
[16:05:31.550]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:31.550]                   envs[common]]
[16:05:31.550]                 NAMES <- toupper(changed)
[16:05:31.550]                 args <- list()
[16:05:31.550]                 for (kk in seq_along(NAMES)) {
[16:05:31.550]                   name <- changed[[kk]]
[16:05:31.550]                   NAME <- NAMES[[kk]]
[16:05:31.550]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.550]                     next
[16:05:31.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:31.550]                 }
[16:05:31.550]                 NAMES <- toupper(added)
[16:05:31.550]                 for (kk in seq_along(NAMES)) {
[16:05:31.550]                   name <- added[[kk]]
[16:05:31.550]                   NAME <- NAMES[[kk]]
[16:05:31.550]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.550]                     next
[16:05:31.550]                   args[[name]] <- ""
[16:05:31.550]                 }
[16:05:31.550]                 NAMES <- toupper(removed)
[16:05:31.550]                 for (kk in seq_along(NAMES)) {
[16:05:31.550]                   name <- removed[[kk]]
[16:05:31.550]                   NAME <- NAMES[[kk]]
[16:05:31.550]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.550]                     next
[16:05:31.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:31.550]                 }
[16:05:31.550]                 if (length(args) > 0) 
[16:05:31.550]                   base::do.call(base::Sys.setenv, args = args)
[16:05:31.550]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:31.550]             }
[16:05:31.550]             else {
[16:05:31.550]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:31.550]             }
[16:05:31.550]             {
[16:05:31.550]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:31.550]                   0L) {
[16:05:31.550]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:31.550]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:31.550]                   base::options(opts)
[16:05:31.550]                 }
[16:05:31.550]                 {
[16:05:31.550]                   {
[16:05:31.550]                     NULL
[16:05:31.550]                     RNGkind("Mersenne-Twister")
[16:05:31.550]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:31.550]                       inherits = FALSE)
[16:05:31.550]                   }
[16:05:31.550]                   options(future.plan = NULL)
[16:05:31.550]                   if (is.na(NA_character_)) 
[16:05:31.550]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:31.550]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:31.550]                   future::plan(list(a = function (..., envir = parent.frame()) 
[16:05:31.550]                   {
[16:05:31.550]                     future <- SequentialFuture(..., envir = envir)
[16:05:31.550]                     if (!future$lazy) 
[16:05:31.550]                       future <- run(future)
[16:05:31.550]                     invisible(future)
[16:05:31.550]                   }, b = function (..., envir = parent.frame()) 
[16:05:31.550]                   {
[16:05:31.550]                     future <- SequentialFuture(..., envir = envir)
[16:05:31.550]                     if (!future$lazy) 
[16:05:31.550]                       future <- run(future)
[16:05:31.550]                     invisible(future)
[16:05:31.550]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:31.550]                 }
[16:05:31.550]             }
[16:05:31.550]         }
[16:05:31.550]     })
[16:05:31.550]     if (TRUE) {
[16:05:31.550]         base::sink(type = "output", split = FALSE)
[16:05:31.550]         if (TRUE) {
[16:05:31.550]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:31.550]         }
[16:05:31.550]         else {
[16:05:31.550]             ...future.result["stdout"] <- base::list(NULL)
[16:05:31.550]         }
[16:05:31.550]         base::close(...future.stdout)
[16:05:31.550]         ...future.stdout <- NULL
[16:05:31.550]     }
[16:05:31.550]     ...future.result$conditions <- ...future.conditions
[16:05:31.550]     ...future.result$finished <- base::Sys.time()
[16:05:31.550]     ...future.result
[16:05:31.550] }
[16:05:31.552] assign_globals() ...
[16:05:31.553] List of 2
[16:05:31.553]  $ nested   :List of 2
[16:05:31.553]   ..$ a:function (..., envir = parent.frame())  
[16:05:31.553]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:05:31.553]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:05:31.553]   ..$ b:function (..., envir = parent.frame())  
[16:05:31.553]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:05:31.553]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:05:31.553]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:05:31.553]  $ strategy2: chr "sequential"
[16:05:31.553]  - attr(*, "where")=List of 2
[16:05:31.553]   ..$ nested   :<environment: R_EmptyEnv> 
[16:05:31.553]   ..$ strategy2:<environment: R_EmptyEnv> 
[16:05:31.553]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:31.553]  - attr(*, "resolved")= logi FALSE
[16:05:31.553]  - attr(*, "total_size")= num 23144
[16:05:31.553]  - attr(*, "already-done")= logi TRUE
[16:05:31.559] - copied ‘nested’ to environment
[16:05:31.559] - copied ‘strategy2’ to environment
[16:05:31.559] assign_globals() ... done
[16:05:31.560] plan(): Setting new future strategy stack:
[16:05:31.560] List of future strategies:
[16:05:31.560] 1. sequential:
[16:05:31.560]    - args: function (..., envir = parent.frame())
[16:05:31.560]    - tweaked: FALSE
[16:05:31.560]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:31.560] plan(): nbrOfWorkers() = 1
[16:05:31.596] plan(): Setting new future strategy stack:
[16:05:31.596] List of future strategies:
[16:05:31.596] 1. sequential:
[16:05:31.596]    - args: function (..., envir = parent.frame())
[16:05:31.596]    - tweaked: FALSE
[16:05:31.596]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:31.596] 2. sequential:
[16:05:31.596]    - args: function (..., envir = parent.frame())
[16:05:31.596]    - tweaked: FALSE
[16:05:31.596]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:31.597] plan(): nbrOfWorkers() = 1
[16:05:31.597] SequentialFuture started (and completed)
[16:05:31.597] signalConditions() ...
[16:05:31.597]  - include = ‘immediateCondition’
[16:05:31.597]  - exclude = 
[16:05:31.597]  - resignal = FALSE
[16:05:31.597]  - Number of conditions: 54
[16:05:31.597] signalConditions() ... done
[16:05:31.597] - Launch lazy future ... done
[16:05:31.597] run() for ‘SequentialFuture’ ... done
[16:05:31.598] signalConditions() ...
[16:05:31.598]  - include = ‘immediateCondition’
[16:05:31.598]  - exclude = 
[16:05:31.598]  - resignal = FALSE
[16:05:31.598]  - Number of conditions: 54
[16:05:31.598] signalConditions() ... done
[16:05:31.598] Future state: ‘finished’
[16:05:31.598] signalConditions() ...
[16:05:31.598]  - include = ‘condition’
[16:05:31.598]  - exclude = ‘immediateCondition’
[16:05:31.599]  - resignal = TRUE
[16:05:31.599]  - Number of conditions: 54
[16:05:31.599]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.561] getGlobalsAndPackages() ...
[16:05:31.599]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.562] Searching for globals...
[16:05:31.599]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.579] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[16:05:31.599]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.580] Searching for globals ... DONE
[16:05:31.599]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.580] Resolving globals: FALSE
[16:05:31.599]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.580] The total size of the 3 globals is 22.54 KiB (23080 bytes)
[16:05:31.600]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.581] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 22.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (11.24 KiB of class ‘list’), ‘plan_a’ (11.24 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[16:05:31.600]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.581] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[16:05:31.600]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.581] 
[16:05:31.600]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.581] getGlobalsAndPackages() ... DONE
[16:05:31.600]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.581] run() for ‘Future’ ...
[16:05:31.600]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.581] - state: ‘created’
[16:05:31.600]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.582] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:31.600]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.582] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:31.601]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.582] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:31.601]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.582]   - Field: ‘label’
[16:05:31.601]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.582]   - Field: ‘local’
[16:05:31.601]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.582]   - Field: ‘owner’
[16:05:31.601]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.582]   - Field: ‘envir’
[16:05:31.601]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.582]   - Field: ‘packages’
[16:05:31.601]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.583]   - Field: ‘gc’
[16:05:31.601]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.583]   - Field: ‘conditions’
[16:05:31.602]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.583]   - Field: ‘expr’
[16:05:31.602]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.583]   - Field: ‘uuid’
[16:05:31.602]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.583]   - Field: ‘seed’
[16:05:31.602]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.583]   - Field: ‘version’
[16:05:31.602]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.583]   - Field: ‘result’
[16:05:31.602]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.583]   - Field: ‘asynchronous’
[16:05:31.602]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.583]   - Field: ‘calls’
[16:05:31.602]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.583]   - Field: ‘globals’
[16:05:31.603]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.584]   - Field: ‘stdout’
[16:05:31.603]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.584]   - Field: ‘earlySignal’
[16:05:31.603]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.584]   - Field: ‘lazy’
[16:05:31.603]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.584]   - Field: ‘state’
[16:05:31.603]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.584] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:31.603]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.584] - Launch lazy future ...
[16:05:31.603]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.584] Packages needed by the future expression (n = 0): <none>
[16:05:31.603]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.584] Packages needed by future strategies (n = 0): <none>
[16:05:31.604]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.585] {
[16:05:31.585]     {
[16:05:31.585]         {
[16:05:31.585]             ...future.startTime <- base::Sys.time()
[16:05:31.585]             {
[16:05:31.585]                 {
[16:05:31.585]                   {
[16:05:31.585]                     base::local({
[16:05:31.585]                       has_future <- base::requireNamespace("future", 
[16:05:31.585]                         quietly = TRUE)
[16:05:31.585]                       if (has_future) {
[16:05:31.585]                         ns <- base::getNamespace("future")
[16:05:31.585]                         version <- ns[[".package"]][["version"]]
[16:05:31.585]                         if (is.null(version)) 
[16:05:31.585]                           version <- utils::packageVersion("future")
[16:05:31.585]                       }
[16:05:31.585]                       else {
[16:05:31.585]                         version <- NULL
[16:05:31.585]                       }
[16:05:31.585]                       if (!has_future || version < "1.8.0") {
[16:05:31.585]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:31.585]                           "", base::R.version$version.string), 
[16:05:31.585]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:31.585]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:31.585]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:31.585]                             "release", "version")], collapse = " "), 
[16:05:31.585]                           hostname = base::Sys.info()[["nodename"]])
[16:05:31.585]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:31.585]                           info)
[16:05:31.585]                         info <- base::paste(info, collapse = "; ")
[16:05:31.585]                         if (!has_future) {
[16:05:31.585]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:31.585]                             info)
[16:05:31.585]                         }
[16:05:31.585]                         else {
[16:05:31.585]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:31.585]                             info, version)
[16:05:31.585]                         }
[16:05:31.585]                         base::stop(msg)
[16:05:31.585]                       }
[16:05:31.585]                     })
[16:05:31.585]                   }
[16:05:31.585]                   options(future.plan = NULL)
[16:05:31.585]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:31.585]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:31.585]                 }
[16:05:31.585]                 ...future.workdir <- getwd()
[16:05:31.585]             }
[16:05:31.585]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:31.585]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:31.585]         }
[16:05:31.585]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:31.585]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:31.585]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:31.585]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:31.585]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:31.585]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:31.585]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:31.585]             base::names(...future.oldOptions))
[16:05:31.585]     }
[16:05:31.585]     if (FALSE) {
[16:05:31.585]     }
[16:05:31.585]     else {
[16:05:31.585]         if (TRUE) {
[16:05:31.585]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:31.585]                 open = "w")
[16:05:31.585]         }
[16:05:31.585]         else {
[16:05:31.585]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:31.585]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:31.585]         }
[16:05:31.585]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:31.585]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:31.585]             base::sink(type = "output", split = FALSE)
[16:05:31.585]             base::close(...future.stdout)
[16:05:31.585]         }, add = TRUE)
[16:05:31.585]     }
[16:05:31.585]     ...future.frame <- base::sys.nframe()
[16:05:31.585]     ...future.conditions <- base::list()
[16:05:31.585]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:31.585]     if (FALSE) {
[16:05:31.585]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:31.585]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:31.585]     }
[16:05:31.585]     ...future.result <- base::tryCatch({
[16:05:31.585]         base::withCallingHandlers({
[16:05:31.585]             ...future.value <- base::withVisible(base::local({
[16:05:31.585]                 b <- 2L
[16:05:31.585]                 plan_b <- future::plan("list")
[16:05:31.585]                 nested_b <- nested_a[-1]
[16:05:31.585]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:05:31.585]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:05:31.585]                   "sequential"))
[16:05:31.585]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:05:31.585]                   b = b, nested_b = nested_b, plan_b = plan_b)
[16:05:31.585]             }))
[16:05:31.585]             future::FutureResult(value = ...future.value$value, 
[16:05:31.585]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:31.585]                   ...future.rng), globalenv = if (FALSE) 
[16:05:31.585]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:31.585]                     ...future.globalenv.names))
[16:05:31.585]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:31.585]         }, condition = base::local({
[16:05:31.585]             c <- base::c
[16:05:31.585]             inherits <- base::inherits
[16:05:31.585]             invokeRestart <- base::invokeRestart
[16:05:31.585]             length <- base::length
[16:05:31.585]             list <- base::list
[16:05:31.585]             seq.int <- base::seq.int
[16:05:31.585]             signalCondition <- base::signalCondition
[16:05:31.585]             sys.calls <- base::sys.calls
[16:05:31.585]             `[[` <- base::`[[`
[16:05:31.585]             `+` <- base::`+`
[16:05:31.585]             `<<-` <- base::`<<-`
[16:05:31.585]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:31.585]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:31.585]                   3L)]
[16:05:31.585]             }
[16:05:31.585]             function(cond) {
[16:05:31.585]                 is_error <- inherits(cond, "error")
[16:05:31.585]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:31.585]                   NULL)
[16:05:31.585]                 if (is_error) {
[16:05:31.585]                   sessionInformation <- function() {
[16:05:31.585]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:31.585]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:31.585]                       search = base::search(), system = base::Sys.info())
[16:05:31.585]                   }
[16:05:31.585]                   ...future.conditions[[length(...future.conditions) + 
[16:05:31.585]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:31.585]                     cond$call), session = sessionInformation(), 
[16:05:31.585]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:31.585]                   signalCondition(cond)
[16:05:31.585]                 }
[16:05:31.585]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:31.585]                 "immediateCondition"))) {
[16:05:31.585]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:31.585]                   ...future.conditions[[length(...future.conditions) + 
[16:05:31.585]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:31.585]                   if (TRUE && !signal) {
[16:05:31.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:31.585]                     {
[16:05:31.585]                       inherits <- base::inherits
[16:05:31.585]                       invokeRestart <- base::invokeRestart
[16:05:31.585]                       is.null <- base::is.null
[16:05:31.585]                       muffled <- FALSE
[16:05:31.585]                       if (inherits(cond, "message")) {
[16:05:31.585]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:31.585]                         if (muffled) 
[16:05:31.585]                           invokeRestart("muffleMessage")
[16:05:31.585]                       }
[16:05:31.585]                       else if (inherits(cond, "warning")) {
[16:05:31.585]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:31.585]                         if (muffled) 
[16:05:31.585]                           invokeRestart("muffleWarning")
[16:05:31.585]                       }
[16:05:31.585]                       else if (inherits(cond, "condition")) {
[16:05:31.585]                         if (!is.null(pattern)) {
[16:05:31.585]                           computeRestarts <- base::computeRestarts
[16:05:31.585]                           grepl <- base::grepl
[16:05:31.585]                           restarts <- computeRestarts(cond)
[16:05:31.585]                           for (restart in restarts) {
[16:05:31.585]                             name <- restart$name
[16:05:31.585]                             if (is.null(name)) 
[16:05:31.585]                               next
[16:05:31.585]                             if (!grepl(pattern, name)) 
[16:05:31.585]                               next
[16:05:31.585]                             invokeRestart(restart)
[16:05:31.585]                             muffled <- TRUE
[16:05:31.585]                             break
[16:05:31.585]                           }
[16:05:31.585]                         }
[16:05:31.585]                       }
[16:05:31.585]                       invisible(muffled)
[16:05:31.585]                     }
[16:05:31.585]                     muffleCondition(cond, pattern = "^muffle")
[16:05:31.585]                   }
[16:05:31.585]                 }
[16:05:31.585]                 else {
[16:05:31.585]                   if (TRUE) {
[16:05:31.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:31.585]                     {
[16:05:31.585]                       inherits <- base::inherits
[16:05:31.585]                       invokeRestart <- base::invokeRestart
[16:05:31.585]                       is.null <- base::is.null
[16:05:31.585]                       muffled <- FALSE
[16:05:31.585]                       if (inherits(cond, "message")) {
[16:05:31.585]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:31.585]                         if (muffled) 
[16:05:31.585]                           invokeRestart("muffleMessage")
[16:05:31.585]                       }
[16:05:31.585]                       else if (inherits(cond, "warning")) {
[16:05:31.585]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:31.585]                         if (muffled) 
[16:05:31.585]                           invokeRestart("muffleWarning")
[16:05:31.585]                       }
[16:05:31.585]                       else if (inherits(cond, "condition")) {
[16:05:31.585]                         if (!is.null(pattern)) {
[16:05:31.585]                           computeRestarts <- base::computeRestarts
[16:05:31.585]                           grepl <- base::grepl
[16:05:31.585]                           restarts <- computeRestarts(cond)
[16:05:31.585]                           for (restart in restarts) {
[16:05:31.585]                             name <- restart$name
[16:05:31.585]                             if (is.null(name)) 
[16:05:31.585]                               next
[16:05:31.585]                             if (!grepl(pattern, name)) 
[16:05:31.585]                               next
[16:05:31.585]                             invokeRestart(restart)
[16:05:31.585]                             muffled <- TRUE
[16:05:31.585]                             break
[16:05:31.585]                           }
[16:05:31.585]                         }
[16:05:31.585]                       }
[16:05:31.585]                       invisible(muffled)
[16:05:31.585]                     }
[16:05:31.585]                     muffleCondition(cond, pattern = "^muffle")
[16:05:31.585]                   }
[16:05:31.585]                 }
[16:05:31.585]             }
[16:05:31.585]         }))
[16:05:31.585]     }, error = function(ex) {
[16:05:31.585]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:31.585]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:31.585]                 ...future.rng), started = ...future.startTime, 
[16:05:31.585]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:31.585]             version = "1.8"), class = "FutureResult")
[16:05:31.585]     }, finally = {
[16:05:31.585]         if (!identical(...future.workdir, getwd())) 
[16:05:31.585]             setwd(...future.workdir)
[16:05:31.585]         {
[16:05:31.585]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:31.585]                 ...future.oldOptions$nwarnings <- NULL
[16:05:31.585]             }
[16:05:31.585]             base::options(...future.oldOptions)
[16:05:31.585]             if (.Platform$OS.type == "windows") {
[16:05:31.585]                 old_names <- names(...future.oldEnvVars)
[16:05:31.585]                 envs <- base::Sys.getenv()
[16:05:31.585]                 names <- names(envs)
[16:05:31.585]                 common <- intersect(names, old_names)
[16:05:31.585]                 added <- setdiff(names, old_names)
[16:05:31.585]                 removed <- setdiff(old_names, names)
[16:05:31.585]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:31.585]                   envs[common]]
[16:05:31.585]                 NAMES <- toupper(changed)
[16:05:31.585]                 args <- list()
[16:05:31.585]                 for (kk in seq_along(NAMES)) {
[16:05:31.585]                   name <- changed[[kk]]
[16:05:31.585]                   NAME <- NAMES[[kk]]
[16:05:31.585]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.585]                     next
[16:05:31.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:31.585]                 }
[16:05:31.585]                 NAMES <- toupper(added)
[16:05:31.585]                 for (kk in seq_along(NAMES)) {
[16:05:31.585]                   name <- added[[kk]]
[16:05:31.585]                   NAME <- NAMES[[kk]]
[16:05:31.585]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.585]                     next
[16:05:31.585]                   args[[name]] <- ""
[16:05:31.585]                 }
[16:05:31.585]                 NAMES <- toupper(removed)
[16:05:31.585]                 for (kk in seq_along(NAMES)) {
[16:05:31.585]                   name <- removed[[kk]]
[16:05:31.585]                   NAME <- NAMES[[kk]]
[16:05:31.585]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.585]                     next
[16:05:31.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:31.585]                 }
[16:05:31.585]                 if (length(args) > 0) 
[16:05:31.585]                   base::do.call(base::Sys.setenv, args = args)
[16:05:31.585]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:31.585]             }
[16:05:31.585]             else {
[16:05:31.585]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:31.585]             }
[16:05:31.585]             {
[16:05:31.585]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:31.585]                   0L) {
[16:05:31.585]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:31.585]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:31.585]                   base::options(opts)
[16:05:31.585]                 }
[16:05:31.585]                 {
[16:05:31.585]                   {
[16:05:31.585]                     NULL
[16:05:31.585]                     RNGkind("Mersenne-Twister")
[16:05:31.585]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:31.585]                       inherits = FALSE)
[16:05:31.585]                   }
[16:05:31.585]                   options(future.plan = NULL)
[16:05:31.585]                   if (is.na(NA_character_)) 
[16:05:31.585]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:31.585]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:31.585]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:05:31.585]                   {
[16:05:31.585]                     future <- SequentialFuture(..., envir = envir)
[16:05:31.585]                     if (!future$lazy) 
[16:05:31.585]                       future <- run(future)
[16:05:31.585]                     invisible(future)
[16:05:31.585]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:31.585]                 }
[16:05:31.585]             }
[16:05:31.585]         }
[16:05:31.585]     })
[16:05:31.585]     if (TRUE) {
[16:05:31.585]         base::sink(type = "output", split = FALSE)
[16:05:31.585]         if (TRUE) {
[16:05:31.585]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:31.585]         }
[16:05:31.585]         else {
[16:05:31.585]             ...future.result["stdout"] <- base::list(NULL)
[16:05:31.585]         }
[16:05:31.585]         base::close(...future.stdout)
[16:05:31.585]         ...future.stdout <- NULL
[16:05:31.585]     }
[16:05:31.585]     ...future.result$conditions <- ...future.conditions
[16:05:31.585]     ...future.result$finished <- base::Sys.time()
[16:05:31.585]     ...future.result
[16:05:31.585] }
[16:05:31.604]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.586] assign_globals() ...
[16:05:31.604]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.586] List of 3
[16:05:31.586]  $ nested_a:List of 1
[16:05:31.586]   ..$ b:function (..., envir = parent.frame())  
[16:05:31.586]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:05:31.586]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:05:31.586]  $ a       : int 1
[16:05:31.586]  $ plan_a  :List of 1
[16:05:31.586]   ..$ b:function (..., envir = parent.frame())  
[16:05:31.586]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:05:31.586]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:05:31.586]  - attr(*, "where")=List of 3
[16:05:31.586]   ..$ nested_a:<environment: R_EmptyEnv> 
[16:05:31.586]   ..$ a       :<environment: R_EmptyEnv> 
[16:05:31.586]   ..$ plan_a  :<environment: R_EmptyEnv> 
[16:05:31.586]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:31.586]  - attr(*, "resolved")= logi FALSE
[16:05:31.586]  - attr(*, "total_size")= num 23080
[16:05:31.586]  - attr(*, "already-done")= logi TRUE
[16:05:31.604]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.592] - copied ‘nested_a’ to environment
[16:05:31.604]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.592] - copied ‘a’ to environment
[16:05:31.604]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.592] - copied ‘plan_a’ to environment
[16:05:31.604]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.592] assign_globals() ... done
[16:05:31.605]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.592] plan(): Setting new future strategy stack:
[16:05:31.605]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.593] List of future strategies:
[16:05:31.593] 1. sequential:
[16:05:31.593]    - args: function (..., envir = parent.frame())
[16:05:31.593]    - tweaked: FALSE
[16:05:31.593]    - call: NULL
[16:05:31.605]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.593] plan(): nbrOfWorkers() = 1
[16:05:31.605]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.594] plan(): Setting new future strategy stack:
[16:05:31.605]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.594] List of future strategies:
[16:05:31.594] 1. sequential:
[16:05:31.594]    - args: function (..., envir = parent.frame())
[16:05:31.594]    - tweaked: FALSE
[16:05:31.594]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:31.605]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.594] plan(): nbrOfWorkers() = 1
[16:05:31.605]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.595] SequentialFuture started (and completed)
[16:05:31.605]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.595] - Launch lazy future ... done
[16:05:31.606]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.595] run() for ‘SequentialFuture’ ... done
[16:05:31.606] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:05:31.610] getGlobalsAndPackages() ...
[16:05:31.611] Searching for globals...
[16:05:31.613] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:05:31.613] Searching for globals ... DONE
[16:05:31.613] Resolving globals: FALSE
[16:05:31.613] The total size of the 1 globals is 128 bytes (128 bytes)
[16:05:31.614] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:05:31.614] - globals: [1] ‘data’
[16:05:31.614] - packages: [1] ‘future’
[16:05:31.614] getGlobalsAndPackages() ... DONE
[16:05:31.614] run() for ‘Future’ ...
[16:05:31.614] - state: ‘created’
[16:05:31.615] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:31.615] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:31.615] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:31.615]   - Field: ‘label’
[16:05:31.615]   - Field: ‘local’
[16:05:31.615]   - Field: ‘owner’
[16:05:31.615]   - Field: ‘envir’
[16:05:31.615]   - Field: ‘packages’
[16:05:31.615]   - Field: ‘gc’
[16:05:31.616]   - Field: ‘conditions’
[16:05:31.616]   - Field: ‘expr’
[16:05:31.616]   - Field: ‘uuid’
[16:05:31.616]   - Field: ‘seed’
[16:05:31.616]   - Field: ‘version’
[16:05:31.616]   - Field: ‘result’
[16:05:31.616]   - Field: ‘asynchronous’
[16:05:31.616]   - Field: ‘calls’
[16:05:31.616]   - Field: ‘globals’
[16:05:31.616]   - Field: ‘stdout’
[16:05:31.616]   - Field: ‘earlySignal’
[16:05:31.617]   - Field: ‘lazy’
[16:05:31.617]   - Field: ‘state’
[16:05:31.617] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:31.617] - Launch lazy future ...
[16:05:31.617] Packages needed by the future expression (n = 1): ‘future’
[16:05:31.617] Packages needed by future strategies (n = 1): ‘future’
[16:05:31.618] {
[16:05:31.618]     {
[16:05:31.618]         {
[16:05:31.618]             ...future.startTime <- base::Sys.time()
[16:05:31.618]             {
[16:05:31.618]                 {
[16:05:31.618]                   {
[16:05:31.618]                     {
[16:05:31.618]                       base::local({
[16:05:31.618]                         has_future <- base::requireNamespace("future", 
[16:05:31.618]                           quietly = TRUE)
[16:05:31.618]                         if (has_future) {
[16:05:31.618]                           ns <- base::getNamespace("future")
[16:05:31.618]                           version <- ns[[".package"]][["version"]]
[16:05:31.618]                           if (is.null(version)) 
[16:05:31.618]                             version <- utils::packageVersion("future")
[16:05:31.618]                         }
[16:05:31.618]                         else {
[16:05:31.618]                           version <- NULL
[16:05:31.618]                         }
[16:05:31.618]                         if (!has_future || version < "1.8.0") {
[16:05:31.618]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:31.618]                             "", base::R.version$version.string), 
[16:05:31.618]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:31.618]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:31.618]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:31.618]                               "release", "version")], collapse = " "), 
[16:05:31.618]                             hostname = base::Sys.info()[["nodename"]])
[16:05:31.618]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:31.618]                             info)
[16:05:31.618]                           info <- base::paste(info, collapse = "; ")
[16:05:31.618]                           if (!has_future) {
[16:05:31.618]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:31.618]                               info)
[16:05:31.618]                           }
[16:05:31.618]                           else {
[16:05:31.618]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:31.618]                               info, version)
[16:05:31.618]                           }
[16:05:31.618]                           base::stop(msg)
[16:05:31.618]                         }
[16:05:31.618]                       })
[16:05:31.618]                     }
[16:05:31.618]                     base::local({
[16:05:31.618]                       for (pkg in "future") {
[16:05:31.618]                         base::loadNamespace(pkg)
[16:05:31.618]                         base::library(pkg, character.only = TRUE)
[16:05:31.618]                       }
[16:05:31.618]                     })
[16:05:31.618]                   }
[16:05:31.618]                   options(future.plan = NULL)
[16:05:31.618]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:31.618]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:05:31.618]                   {
[16:05:31.618]                     future <- SequentialFuture(..., envir = envir)
[16:05:31.618]                     if (!future$lazy) 
[16:05:31.618]                       future <- run(future)
[16:05:31.618]                     invisible(future)
[16:05:31.618]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:31.618]                 }
[16:05:31.618]                 ...future.workdir <- getwd()
[16:05:31.618]             }
[16:05:31.618]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:31.618]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:31.618]         }
[16:05:31.618]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:31.618]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:31.618]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:31.618]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:31.618]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:31.618]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:31.618]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:31.618]             base::names(...future.oldOptions))
[16:05:31.618]     }
[16:05:31.618]     if (FALSE) {
[16:05:31.618]     }
[16:05:31.618]     else {
[16:05:31.618]         if (TRUE) {
[16:05:31.618]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:31.618]                 open = "w")
[16:05:31.618]         }
[16:05:31.618]         else {
[16:05:31.618]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:31.618]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:31.618]         }
[16:05:31.618]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:31.618]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:31.618]             base::sink(type = "output", split = FALSE)
[16:05:31.618]             base::close(...future.stdout)
[16:05:31.618]         }, add = TRUE)
[16:05:31.618]     }
[16:05:31.618]     ...future.frame <- base::sys.nframe()
[16:05:31.618]     ...future.conditions <- base::list()
[16:05:31.618]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:31.618]     if (FALSE) {
[16:05:31.618]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:31.618]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:31.618]     }
[16:05:31.618]     ...future.result <- base::tryCatch({
[16:05:31.618]         base::withCallingHandlers({
[16:05:31.618]             ...future.value <- base::withVisible(base::local({
[16:05:31.618]                 value(future(subset(data, a == 2)))
[16:05:31.618]             }))
[16:05:31.618]             future::FutureResult(value = ...future.value$value, 
[16:05:31.618]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:31.618]                   ...future.rng), globalenv = if (FALSE) 
[16:05:31.618]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:31.618]                     ...future.globalenv.names))
[16:05:31.618]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:31.618]         }, condition = base::local({
[16:05:31.618]             c <- base::c
[16:05:31.618]             inherits <- base::inherits
[16:05:31.618]             invokeRestart <- base::invokeRestart
[16:05:31.618]             length <- base::length
[16:05:31.618]             list <- base::list
[16:05:31.618]             seq.int <- base::seq.int
[16:05:31.618]             signalCondition <- base::signalCondition
[16:05:31.618]             sys.calls <- base::sys.calls
[16:05:31.618]             `[[` <- base::`[[`
[16:05:31.618]             `+` <- base::`+`
[16:05:31.618]             `<<-` <- base::`<<-`
[16:05:31.618]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:31.618]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:31.618]                   3L)]
[16:05:31.618]             }
[16:05:31.618]             function(cond) {
[16:05:31.618]                 is_error <- inherits(cond, "error")
[16:05:31.618]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:31.618]                   NULL)
[16:05:31.618]                 if (is_error) {
[16:05:31.618]                   sessionInformation <- function() {
[16:05:31.618]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:31.618]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:31.618]                       search = base::search(), system = base::Sys.info())
[16:05:31.618]                   }
[16:05:31.618]                   ...future.conditions[[length(...future.conditions) + 
[16:05:31.618]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:31.618]                     cond$call), session = sessionInformation(), 
[16:05:31.618]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:31.618]                   signalCondition(cond)
[16:05:31.618]                 }
[16:05:31.618]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:31.618]                 "immediateCondition"))) {
[16:05:31.618]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:31.618]                   ...future.conditions[[length(...future.conditions) + 
[16:05:31.618]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:31.618]                   if (TRUE && !signal) {
[16:05:31.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:31.618]                     {
[16:05:31.618]                       inherits <- base::inherits
[16:05:31.618]                       invokeRestart <- base::invokeRestart
[16:05:31.618]                       is.null <- base::is.null
[16:05:31.618]                       muffled <- FALSE
[16:05:31.618]                       if (inherits(cond, "message")) {
[16:05:31.618]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:31.618]                         if (muffled) 
[16:05:31.618]                           invokeRestart("muffleMessage")
[16:05:31.618]                       }
[16:05:31.618]                       else if (inherits(cond, "warning")) {
[16:05:31.618]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:31.618]                         if (muffled) 
[16:05:31.618]                           invokeRestart("muffleWarning")
[16:05:31.618]                       }
[16:05:31.618]                       else if (inherits(cond, "condition")) {
[16:05:31.618]                         if (!is.null(pattern)) {
[16:05:31.618]                           computeRestarts <- base::computeRestarts
[16:05:31.618]                           grepl <- base::grepl
[16:05:31.618]                           restarts <- computeRestarts(cond)
[16:05:31.618]                           for (restart in restarts) {
[16:05:31.618]                             name <- restart$name
[16:05:31.618]                             if (is.null(name)) 
[16:05:31.618]                               next
[16:05:31.618]                             if (!grepl(pattern, name)) 
[16:05:31.618]                               next
[16:05:31.618]                             invokeRestart(restart)
[16:05:31.618]                             muffled <- TRUE
[16:05:31.618]                             break
[16:05:31.618]                           }
[16:05:31.618]                         }
[16:05:31.618]                       }
[16:05:31.618]                       invisible(muffled)
[16:05:31.618]                     }
[16:05:31.618]                     muffleCondition(cond, pattern = "^muffle")
[16:05:31.618]                   }
[16:05:31.618]                 }
[16:05:31.618]                 else {
[16:05:31.618]                   if (TRUE) {
[16:05:31.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:31.618]                     {
[16:05:31.618]                       inherits <- base::inherits
[16:05:31.618]                       invokeRestart <- base::invokeRestart
[16:05:31.618]                       is.null <- base::is.null
[16:05:31.618]                       muffled <- FALSE
[16:05:31.618]                       if (inherits(cond, "message")) {
[16:05:31.618]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:31.618]                         if (muffled) 
[16:05:31.618]                           invokeRestart("muffleMessage")
[16:05:31.618]                       }
[16:05:31.618]                       else if (inherits(cond, "warning")) {
[16:05:31.618]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:31.618]                         if (muffled) 
[16:05:31.618]                           invokeRestart("muffleWarning")
[16:05:31.618]                       }
[16:05:31.618]                       else if (inherits(cond, "condition")) {
[16:05:31.618]                         if (!is.null(pattern)) {
[16:05:31.618]                           computeRestarts <- base::computeRestarts
[16:05:31.618]                           grepl <- base::grepl
[16:05:31.618]                           restarts <- computeRestarts(cond)
[16:05:31.618]                           for (restart in restarts) {
[16:05:31.618]                             name <- restart$name
[16:05:31.618]                             if (is.null(name)) 
[16:05:31.618]                               next
[16:05:31.618]                             if (!grepl(pattern, name)) 
[16:05:31.618]                               next
[16:05:31.618]                             invokeRestart(restart)
[16:05:31.618]                             muffled <- TRUE
[16:05:31.618]                             break
[16:05:31.618]                           }
[16:05:31.618]                         }
[16:05:31.618]                       }
[16:05:31.618]                       invisible(muffled)
[16:05:31.618]                     }
[16:05:31.618]                     muffleCondition(cond, pattern = "^muffle")
[16:05:31.618]                   }
[16:05:31.618]                 }
[16:05:31.618]             }
[16:05:31.618]         }))
[16:05:31.618]     }, error = function(ex) {
[16:05:31.618]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:31.618]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:31.618]                 ...future.rng), started = ...future.startTime, 
[16:05:31.618]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:31.618]             version = "1.8"), class = "FutureResult")
[16:05:31.618]     }, finally = {
[16:05:31.618]         if (!identical(...future.workdir, getwd())) 
[16:05:31.618]             setwd(...future.workdir)
[16:05:31.618]         {
[16:05:31.618]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:31.618]                 ...future.oldOptions$nwarnings <- NULL
[16:05:31.618]             }
[16:05:31.618]             base::options(...future.oldOptions)
[16:05:31.618]             if (.Platform$OS.type == "windows") {
[16:05:31.618]                 old_names <- names(...future.oldEnvVars)
[16:05:31.618]                 envs <- base::Sys.getenv()
[16:05:31.618]                 names <- names(envs)
[16:05:31.618]                 common <- intersect(names, old_names)
[16:05:31.618]                 added <- setdiff(names, old_names)
[16:05:31.618]                 removed <- setdiff(old_names, names)
[16:05:31.618]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:31.618]                   envs[common]]
[16:05:31.618]                 NAMES <- toupper(changed)
[16:05:31.618]                 args <- list()
[16:05:31.618]                 for (kk in seq_along(NAMES)) {
[16:05:31.618]                   name <- changed[[kk]]
[16:05:31.618]                   NAME <- NAMES[[kk]]
[16:05:31.618]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.618]                     next
[16:05:31.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:31.618]                 }
[16:05:31.618]                 NAMES <- toupper(added)
[16:05:31.618]                 for (kk in seq_along(NAMES)) {
[16:05:31.618]                   name <- added[[kk]]
[16:05:31.618]                   NAME <- NAMES[[kk]]
[16:05:31.618]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.618]                     next
[16:05:31.618]                   args[[name]] <- ""
[16:05:31.618]                 }
[16:05:31.618]                 NAMES <- toupper(removed)
[16:05:31.618]                 for (kk in seq_along(NAMES)) {
[16:05:31.618]                   name <- removed[[kk]]
[16:05:31.618]                   NAME <- NAMES[[kk]]
[16:05:31.618]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.618]                     next
[16:05:31.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:31.618]                 }
[16:05:31.618]                 if (length(args) > 0) 
[16:05:31.618]                   base::do.call(base::Sys.setenv, args = args)
[16:05:31.618]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:31.618]             }
[16:05:31.618]             else {
[16:05:31.618]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:31.618]             }
[16:05:31.618]             {
[16:05:31.618]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:31.618]                   0L) {
[16:05:31.618]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:31.618]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:31.618]                   base::options(opts)
[16:05:31.618]                 }
[16:05:31.618]                 {
[16:05:31.618]                   {
[16:05:31.618]                     NULL
[16:05:31.618]                     RNGkind("Mersenne-Twister")
[16:05:31.618]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:31.618]                       inherits = FALSE)
[16:05:31.618]                   }
[16:05:31.618]                   options(future.plan = NULL)
[16:05:31.618]                   if (is.na(NA_character_)) 
[16:05:31.618]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:31.618]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:31.618]                   future::plan(list(a = function (..., envir = parent.frame()) 
[16:05:31.618]                   {
[16:05:31.618]                     future <- SequentialFuture(..., envir = envir)
[16:05:31.618]                     if (!future$lazy) 
[16:05:31.618]                       future <- run(future)
[16:05:31.618]                     invisible(future)
[16:05:31.618]                   }, b = function (..., envir = parent.frame()) 
[16:05:31.618]                   {
[16:05:31.618]                     future <- SequentialFuture(..., envir = envir)
[16:05:31.618]                     if (!future$lazy) 
[16:05:31.618]                       future <- run(future)
[16:05:31.618]                     invisible(future)
[16:05:31.618]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:31.618]                 }
[16:05:31.618]             }
[16:05:31.618]         }
[16:05:31.618]     })
[16:05:31.618]     if (TRUE) {
[16:05:31.618]         base::sink(type = "output", split = FALSE)
[16:05:31.618]         if (TRUE) {
[16:05:31.618]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:31.618]         }
[16:05:31.618]         else {
[16:05:31.618]             ...future.result["stdout"] <- base::list(NULL)
[16:05:31.618]         }
[16:05:31.618]         base::close(...future.stdout)
[16:05:31.618]         ...future.stdout <- NULL
[16:05:31.618]     }
[16:05:31.618]     ...future.result$conditions <- ...future.conditions
[16:05:31.618]     ...future.result$finished <- base::Sys.time()
[16:05:31.618]     ...future.result
[16:05:31.618] }
[16:05:31.619] assign_globals() ...
[16:05:31.619] List of 1
[16:05:31.619]  $ data:'data.frame':	3 obs. of  2 variables:
[16:05:31.619]   ..$ a: int [1:3] 1 2 3
[16:05:31.619]   ..$ b: int [1:3] 3 2 1
[16:05:31.619]  - attr(*, "where")=List of 1
[16:05:31.619]   ..$ data:<environment: R_EmptyEnv> 
[16:05:31.619]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:31.619]  - attr(*, "resolved")= logi FALSE
[16:05:31.619]  - attr(*, "total_size")= num 128
[16:05:31.619]  - attr(*, "already-done")= logi TRUE
[16:05:31.622] - copied ‘data’ to environment
[16:05:31.622] assign_globals() ... done
[16:05:31.623] plan(): Setting new future strategy stack:
[16:05:31.623] List of future strategies:
[16:05:31.623] 1. sequential:
[16:05:31.623]    - args: function (..., envir = parent.frame())
[16:05:31.623]    - tweaked: FALSE
[16:05:31.623]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:31.623] plan(): nbrOfWorkers() = 1
[16:05:31.650] plan(): Setting new future strategy stack:
[16:05:31.650] List of future strategies:
[16:05:31.650] 1. sequential:
[16:05:31.650]    - args: function (..., envir = parent.frame())
[16:05:31.650]    - tweaked: FALSE
[16:05:31.650]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:31.650] 2. sequential:
[16:05:31.650]    - args: function (..., envir = parent.frame())
[16:05:31.650]    - tweaked: FALSE
[16:05:31.650]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:31.650] plan(): nbrOfWorkers() = 1
[16:05:31.651] SequentialFuture started (and completed)
[16:05:31.651] signalConditions() ...
[16:05:31.651]  - include = ‘immediateCondition’
[16:05:31.651]  - exclude = 
[16:05:31.651]  - resignal = FALSE
[16:05:31.651]  - Number of conditions: 52
[16:05:31.651] signalConditions() ... done
[16:05:31.651] - Launch lazy future ... done
[16:05:31.651] run() for ‘SequentialFuture’ ... done
[16:05:31.652] signalConditions() ...
[16:05:31.652]  - include = ‘immediateCondition’
[16:05:31.652]  - exclude = 
[16:05:31.652]  - resignal = FALSE
[16:05:31.652]  - Number of conditions: 52
[16:05:31.652] signalConditions() ... done
[16:05:31.652] Future state: ‘finished’
[16:05:31.652] signalConditions() ...
[16:05:31.652]  - include = ‘condition’
[16:05:31.652]  - exclude = ‘immediateCondition’
[16:05:31.652]  - resignal = TRUE
[16:05:31.653]  - Number of conditions: 52
[16:05:31.653]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.624] getGlobalsAndPackages() ...
[16:05:31.653]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.624] Searching for globals...
[16:05:31.653]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.637] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[16:05:31.653]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.638] Searching for globals ... DONE
[16:05:31.653]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.638] Resolving globals: FALSE
[16:05:31.653]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.638] The total size of the 1 globals is 128 bytes (128 bytes)
[16:05:31.653]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.638] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:05:31.654]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.639] - globals: [1] ‘data’
[16:05:31.654]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.639] 
[16:05:31.655]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.639] getGlobalsAndPackages() ... DONE
[16:05:31.655]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.639] run() for ‘Future’ ...
[16:05:31.655]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.639] - state: ‘created’
[16:05:31.655]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.639] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:31.655]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.640] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:31.655]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.640] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:31.655]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.640]   - Field: ‘label’
[16:05:31.656]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.640]   - Field: ‘local’
[16:05:31.656]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.640]   - Field: ‘owner’
[16:05:31.656]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.640]   - Field: ‘envir’
[16:05:31.656]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.640]   - Field: ‘packages’
[16:05:31.656]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.640]   - Field: ‘gc’
[16:05:31.656]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.640]   - Field: ‘conditions’
[16:05:31.656]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.641]   - Field: ‘expr’
[16:05:31.656]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.641]   - Field: ‘uuid’
[16:05:31.657]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.641]   - Field: ‘seed’
[16:05:31.657]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.641]   - Field: ‘version’
[16:05:31.657]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.641]   - Field: ‘result’
[16:05:31.657]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.641]   - Field: ‘asynchronous’
[16:05:31.657]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.641]   - Field: ‘calls’
[16:05:31.657]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.641]   - Field: ‘globals’
[16:05:31.657]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.641]   - Field: ‘stdout’
[16:05:31.657]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.641]   - Field: ‘earlySignal’
[16:05:31.658]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.642]   - Field: ‘lazy’
[16:05:31.658]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.642]   - Field: ‘state’
[16:05:31.658]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.642] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:31.658]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.642] - Launch lazy future ...
[16:05:31.658]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.642] Packages needed by the future expression (n = 0): <none>
[16:05:31.658]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.642] Packages needed by future strategies (n = 0): <none>
[16:05:31.658]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.643] {
[16:05:31.643]     {
[16:05:31.643]         {
[16:05:31.643]             ...future.startTime <- base::Sys.time()
[16:05:31.643]             {
[16:05:31.643]                 {
[16:05:31.643]                   {
[16:05:31.643]                     base::local({
[16:05:31.643]                       has_future <- base::requireNamespace("future", 
[16:05:31.643]                         quietly = TRUE)
[16:05:31.643]                       if (has_future) {
[16:05:31.643]                         ns <- base::getNamespace("future")
[16:05:31.643]                         version <- ns[[".package"]][["version"]]
[16:05:31.643]                         if (is.null(version)) 
[16:05:31.643]                           version <- utils::packageVersion("future")
[16:05:31.643]                       }
[16:05:31.643]                       else {
[16:05:31.643]                         version <- NULL
[16:05:31.643]                       }
[16:05:31.643]                       if (!has_future || version < "1.8.0") {
[16:05:31.643]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:31.643]                           "", base::R.version$version.string), 
[16:05:31.643]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:31.643]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:31.643]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:31.643]                             "release", "version")], collapse = " "), 
[16:05:31.643]                           hostname = base::Sys.info()[["nodename"]])
[16:05:31.643]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:31.643]                           info)
[16:05:31.643]                         info <- base::paste(info, collapse = "; ")
[16:05:31.643]                         if (!has_future) {
[16:05:31.643]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:31.643]                             info)
[16:05:31.643]                         }
[16:05:31.643]                         else {
[16:05:31.643]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:31.643]                             info, version)
[16:05:31.643]                         }
[16:05:31.643]                         base::stop(msg)
[16:05:31.643]                       }
[16:05:31.643]                     })
[16:05:31.643]                   }
[16:05:31.643]                   options(future.plan = NULL)
[16:05:31.643]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:31.643]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:31.643]                 }
[16:05:31.643]                 ...future.workdir <- getwd()
[16:05:31.643]             }
[16:05:31.643]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:31.643]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:31.643]         }
[16:05:31.643]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:31.643]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:31.643]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:31.643]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:31.643]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:31.643]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:31.643]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:31.643]             base::names(...future.oldOptions))
[16:05:31.643]     }
[16:05:31.643]     if (FALSE) {
[16:05:31.643]     }
[16:05:31.643]     else {
[16:05:31.643]         if (TRUE) {
[16:05:31.643]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:31.643]                 open = "w")
[16:05:31.643]         }
[16:05:31.643]         else {
[16:05:31.643]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:31.643]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:31.643]         }
[16:05:31.643]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:31.643]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:31.643]             base::sink(type = "output", split = FALSE)
[16:05:31.643]             base::close(...future.stdout)
[16:05:31.643]         }, add = TRUE)
[16:05:31.643]     }
[16:05:31.643]     ...future.frame <- base::sys.nframe()
[16:05:31.643]     ...future.conditions <- base::list()
[16:05:31.643]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:31.643]     if (FALSE) {
[16:05:31.643]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:31.643]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:31.643]     }
[16:05:31.643]     ...future.result <- base::tryCatch({
[16:05:31.643]         base::withCallingHandlers({
[16:05:31.643]             ...future.value <- base::withVisible(base::local(subset(data, 
[16:05:31.643]                 a == 2)))
[16:05:31.643]             future::FutureResult(value = ...future.value$value, 
[16:05:31.643]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:31.643]                   ...future.rng), globalenv = if (FALSE) 
[16:05:31.643]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:31.643]                     ...future.globalenv.names))
[16:05:31.643]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:31.643]         }, condition = base::local({
[16:05:31.643]             c <- base::c
[16:05:31.643]             inherits <- base::inherits
[16:05:31.643]             invokeRestart <- base::invokeRestart
[16:05:31.643]             length <- base::length
[16:05:31.643]             list <- base::list
[16:05:31.643]             seq.int <- base::seq.int
[16:05:31.643]             signalCondition <- base::signalCondition
[16:05:31.643]             sys.calls <- base::sys.calls
[16:05:31.643]             `[[` <- base::`[[`
[16:05:31.643]             `+` <- base::`+`
[16:05:31.643]             `<<-` <- base::`<<-`
[16:05:31.643]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:31.643]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:31.643]                   3L)]
[16:05:31.643]             }
[16:05:31.643]             function(cond) {
[16:05:31.643]                 is_error <- inherits(cond, "error")
[16:05:31.643]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:31.643]                   NULL)
[16:05:31.643]                 if (is_error) {
[16:05:31.643]                   sessionInformation <- function() {
[16:05:31.643]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:31.643]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:31.643]                       search = base::search(), system = base::Sys.info())
[16:05:31.643]                   }
[16:05:31.643]                   ...future.conditions[[length(...future.conditions) + 
[16:05:31.643]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:31.643]                     cond$call), session = sessionInformation(), 
[16:05:31.643]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:31.643]                   signalCondition(cond)
[16:05:31.643]                 }
[16:05:31.643]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:31.643]                 "immediateCondition"))) {
[16:05:31.643]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:31.643]                   ...future.conditions[[length(...future.conditions) + 
[16:05:31.643]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:31.643]                   if (TRUE && !signal) {
[16:05:31.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:31.643]                     {
[16:05:31.643]                       inherits <- base::inherits
[16:05:31.643]                       invokeRestart <- base::invokeRestart
[16:05:31.643]                       is.null <- base::is.null
[16:05:31.643]                       muffled <- FALSE
[16:05:31.643]                       if (inherits(cond, "message")) {
[16:05:31.643]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:31.643]                         if (muffled) 
[16:05:31.643]                           invokeRestart("muffleMessage")
[16:05:31.643]                       }
[16:05:31.643]                       else if (inherits(cond, "warning")) {
[16:05:31.643]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:31.643]                         if (muffled) 
[16:05:31.643]                           invokeRestart("muffleWarning")
[16:05:31.643]                       }
[16:05:31.643]                       else if (inherits(cond, "condition")) {
[16:05:31.643]                         if (!is.null(pattern)) {
[16:05:31.643]                           computeRestarts <- base::computeRestarts
[16:05:31.643]                           grepl <- base::grepl
[16:05:31.643]                           restarts <- computeRestarts(cond)
[16:05:31.643]                           for (restart in restarts) {
[16:05:31.643]                             name <- restart$name
[16:05:31.643]                             if (is.null(name)) 
[16:05:31.643]                               next
[16:05:31.643]                             if (!grepl(pattern, name)) 
[16:05:31.643]                               next
[16:05:31.643]                             invokeRestart(restart)
[16:05:31.643]                             muffled <- TRUE
[16:05:31.643]                             break
[16:05:31.643]                           }
[16:05:31.643]                         }
[16:05:31.643]                       }
[16:05:31.643]                       invisible(muffled)
[16:05:31.643]                     }
[16:05:31.643]                     muffleCondition(cond, pattern = "^muffle")
[16:05:31.643]                   }
[16:05:31.643]                 }
[16:05:31.643]                 else {
[16:05:31.643]                   if (TRUE) {
[16:05:31.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:31.643]                     {
[16:05:31.643]                       inherits <- base::inherits
[16:05:31.643]                       invokeRestart <- base::invokeRestart
[16:05:31.643]                       is.null <- base::is.null
[16:05:31.643]                       muffled <- FALSE
[16:05:31.643]                       if (inherits(cond, "message")) {
[16:05:31.643]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:31.643]                         if (muffled) 
[16:05:31.643]                           invokeRestart("muffleMessage")
[16:05:31.643]                       }
[16:05:31.643]                       else if (inherits(cond, "warning")) {
[16:05:31.643]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:31.643]                         if (muffled) 
[16:05:31.643]                           invokeRestart("muffleWarning")
[16:05:31.643]                       }
[16:05:31.643]                       else if (inherits(cond, "condition")) {
[16:05:31.643]                         if (!is.null(pattern)) {
[16:05:31.643]                           computeRestarts <- base::computeRestarts
[16:05:31.643]                           grepl <- base::grepl
[16:05:31.643]                           restarts <- computeRestarts(cond)
[16:05:31.643]                           for (restart in restarts) {
[16:05:31.643]                             name <- restart$name
[16:05:31.643]                             if (is.null(name)) 
[16:05:31.643]                               next
[16:05:31.643]                             if (!grepl(pattern, name)) 
[16:05:31.643]                               next
[16:05:31.643]                             invokeRestart(restart)
[16:05:31.643]                             muffled <- TRUE
[16:05:31.643]                             break
[16:05:31.643]                           }
[16:05:31.643]                         }
[16:05:31.643]                       }
[16:05:31.643]                       invisible(muffled)
[16:05:31.643]                     }
[16:05:31.643]                     muffleCondition(cond, pattern = "^muffle")
[16:05:31.643]                   }
[16:05:31.643]                 }
[16:05:31.643]             }
[16:05:31.643]         }))
[16:05:31.643]     }, error = function(ex) {
[16:05:31.643]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:31.643]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:31.643]                 ...future.rng), started = ...future.startTime, 
[16:05:31.643]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:31.643]             version = "1.8"), class = "FutureResult")
[16:05:31.643]     }, finally = {
[16:05:31.643]         if (!identical(...future.workdir, getwd())) 
[16:05:31.643]             setwd(...future.workdir)
[16:05:31.643]         {
[16:05:31.643]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:31.643]                 ...future.oldOptions$nwarnings <- NULL
[16:05:31.643]             }
[16:05:31.643]             base::options(...future.oldOptions)
[16:05:31.643]             if (.Platform$OS.type == "windows") {
[16:05:31.643]                 old_names <- names(...future.oldEnvVars)
[16:05:31.643]                 envs <- base::Sys.getenv()
[16:05:31.643]                 names <- names(envs)
[16:05:31.643]                 common <- intersect(names, old_names)
[16:05:31.643]                 added <- setdiff(names, old_names)
[16:05:31.643]                 removed <- setdiff(old_names, names)
[16:05:31.643]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:31.643]                   envs[common]]
[16:05:31.643]                 NAMES <- toupper(changed)
[16:05:31.643]                 args <- list()
[16:05:31.643]                 for (kk in seq_along(NAMES)) {
[16:05:31.643]                   name <- changed[[kk]]
[16:05:31.643]                   NAME <- NAMES[[kk]]
[16:05:31.643]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.643]                     next
[16:05:31.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:31.643]                 }
[16:05:31.643]                 NAMES <- toupper(added)
[16:05:31.643]                 for (kk in seq_along(NAMES)) {
[16:05:31.643]                   name <- added[[kk]]
[16:05:31.643]                   NAME <- NAMES[[kk]]
[16:05:31.643]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.643]                     next
[16:05:31.643]                   args[[name]] <- ""
[16:05:31.643]                 }
[16:05:31.643]                 NAMES <- toupper(removed)
[16:05:31.643]                 for (kk in seq_along(NAMES)) {
[16:05:31.643]                   name <- removed[[kk]]
[16:05:31.643]                   NAME <- NAMES[[kk]]
[16:05:31.643]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.643]                     next
[16:05:31.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:31.643]                 }
[16:05:31.643]                 if (length(args) > 0) 
[16:05:31.643]                   base::do.call(base::Sys.setenv, args = args)
[16:05:31.643]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:31.643]             }
[16:05:31.643]             else {
[16:05:31.643]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:31.643]             }
[16:05:31.643]             {
[16:05:31.643]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:31.643]                   0L) {
[16:05:31.643]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:31.643]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:31.643]                   base::options(opts)
[16:05:31.643]                 }
[16:05:31.643]                 {
[16:05:31.643]                   {
[16:05:31.643]                     NULL
[16:05:31.643]                     RNGkind("Mersenne-Twister")
[16:05:31.643]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:31.643]                       inherits = FALSE)
[16:05:31.643]                   }
[16:05:31.643]                   options(future.plan = NULL)
[16:05:31.643]                   if (is.na(NA_character_)) 
[16:05:31.643]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:31.643]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:31.643]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:05:31.643]                   {
[16:05:31.643]                     future <- SequentialFuture(..., envir = envir)
[16:05:31.643]                     if (!future$lazy) 
[16:05:31.643]                       future <- run(future)
[16:05:31.643]                     invisible(future)
[16:05:31.643]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:31.643]                 }
[16:05:31.643]             }
[16:05:31.643]         }
[16:05:31.643]     })
[16:05:31.643]     if (TRUE) {
[16:05:31.643]         base::sink(type = "output", split = FALSE)
[16:05:31.643]         if (TRUE) {
[16:05:31.643]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:31.643]         }
[16:05:31.643]         else {
[16:05:31.643]             ...future.result["stdout"] <- base::list(NULL)
[16:05:31.643]         }
[16:05:31.643]         base::close(...future.stdout)
[16:05:31.643]         ...future.stdout <- NULL
[16:05:31.643]     }
[16:05:31.643]     ...future.result$conditions <- ...future.conditions
[16:05:31.643]     ...future.result$finished <- base::Sys.time()
[16:05:31.643]     ...future.result
[16:05:31.643] }
[16:05:31.659]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.644] assign_globals() ...
[16:05:31.659]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.644] List of 1
[16:05:31.644]  $ data:'data.frame':	3 obs. of  2 variables:
[16:05:31.644]   ..$ a: int [1:3] 1 2 3
[16:05:31.644]   ..$ b: int [1:3] 3 2 1
[16:05:31.644]  - attr(*, "where")=List of 1
[16:05:31.644]   ..$ data:<environment: R_EmptyEnv> 
[16:05:31.644]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:31.644]  - attr(*, "resolved")= logi FALSE
[16:05:31.644]  - attr(*, "total_size")= num 128
[16:05:31.644]  - attr(*, "already-done")= logi TRUE
[16:05:31.659]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.647] - copied ‘data’ to environment
[16:05:31.659]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.647] assign_globals() ... done
[16:05:31.659]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.647] plan(): Setting new future strategy stack:
[16:05:31.659]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.648] List of future strategies:
[16:05:31.648] 1. sequential:
[16:05:31.648]    - args: function (..., envir = parent.frame())
[16:05:31.648]    - tweaked: FALSE
[16:05:31.648]    - call: NULL
[16:05:31.659]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.648] plan(): nbrOfWorkers() = 1
[16:05:31.659]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.649] plan(): Setting new future strategy stack:
[16:05:31.660]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.649] List of future strategies:
[16:05:31.649] 1. sequential:
[16:05:31.649]    - args: function (..., envir = parent.frame())
[16:05:31.649]    - tweaked: FALSE
[16:05:31.649]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:31.660]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.649] plan(): nbrOfWorkers() = 1
[16:05:31.660]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.649] SequentialFuture started (and completed)
[16:05:31.660]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.649] - Launch lazy future ... done
[16:05:31.660]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.650] run() for ‘SequentialFuture’ ... done
[16:05:31.660] signalConditions() ... done
- plan(list('sequential', 'sequential')) ... DONE
- plan(list('sequential', 'multicore')) ...
[16:05:31.661] plan(): Setting new future strategy stack:
[16:05:31.661] List of future strategies:
[16:05:31.661] 1. sequential:
[16:05:31.661]    - args: function (..., envir = parent.frame())
[16:05:31.661]    - tweaked: FALSE
[16:05:31.661]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:31.661] 2. multicore:
[16:05:31.661]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:31.661]    - tweaked: FALSE
[16:05:31.661]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:31.661] plan(): nbrOfWorkers() = 1
[16:05:31.661] getGlobalsAndPackages() ...
[16:05:31.662] Searching for globals...
[16:05:31.677] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:05:31.677] Searching for globals ... DONE
[16:05:31.677] Resolving globals: FALSE
[16:05:31.678] The total size of the 2 globals is 57.84 KiB (59224 bytes)
[16:05:31.679] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 57.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (57.72 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:05:31.679] - globals: [2] ‘nested’, ‘strategy2’
[16:05:31.679] - packages: [1] ‘future’
[16:05:31.679] getGlobalsAndPackages() ... DONE
[16:05:31.679] run() for ‘Future’ ...
[16:05:31.679] - state: ‘created’
[16:05:31.680] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:31.680] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:31.680] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:31.680]   - Field: ‘label’
[16:05:31.680]   - Field: ‘local’
[16:05:31.680]   - Field: ‘owner’
[16:05:31.680]   - Field: ‘envir’
[16:05:31.680]   - Field: ‘packages’
[16:05:31.680]   - Field: ‘gc’
[16:05:31.681]   - Field: ‘conditions’
[16:05:31.681]   - Field: ‘expr’
[16:05:31.681]   - Field: ‘uuid’
[16:05:31.681]   - Field: ‘seed’
[16:05:31.681]   - Field: ‘version’
[16:05:31.681]   - Field: ‘result’
[16:05:31.681]   - Field: ‘asynchronous’
[16:05:31.681]   - Field: ‘calls’
[16:05:31.681]   - Field: ‘globals’
[16:05:31.681]   - Field: ‘stdout’
[16:05:31.681]   - Field: ‘earlySignal’
[16:05:31.681]   - Field: ‘lazy’
[16:05:31.682]   - Field: ‘state’
[16:05:31.682] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:31.682] - Launch lazy future ...
[16:05:31.682] Packages needed by the future expression (n = 1): ‘future’
[16:05:31.682] Packages needed by future strategies (n = 1): ‘future’
[16:05:31.683] {
[16:05:31.683]     {
[16:05:31.683]         {
[16:05:31.683]             ...future.startTime <- base::Sys.time()
[16:05:31.683]             {
[16:05:31.683]                 {
[16:05:31.683]                   {
[16:05:31.683]                     {
[16:05:31.683]                       base::local({
[16:05:31.683]                         has_future <- base::requireNamespace("future", 
[16:05:31.683]                           quietly = TRUE)
[16:05:31.683]                         if (has_future) {
[16:05:31.683]                           ns <- base::getNamespace("future")
[16:05:31.683]                           version <- ns[[".package"]][["version"]]
[16:05:31.683]                           if (is.null(version)) 
[16:05:31.683]                             version <- utils::packageVersion("future")
[16:05:31.683]                         }
[16:05:31.683]                         else {
[16:05:31.683]                           version <- NULL
[16:05:31.683]                         }
[16:05:31.683]                         if (!has_future || version < "1.8.0") {
[16:05:31.683]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:31.683]                             "", base::R.version$version.string), 
[16:05:31.683]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:31.683]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:31.683]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:31.683]                               "release", "version")], collapse = " "), 
[16:05:31.683]                             hostname = base::Sys.info()[["nodename"]])
[16:05:31.683]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:31.683]                             info)
[16:05:31.683]                           info <- base::paste(info, collapse = "; ")
[16:05:31.683]                           if (!has_future) {
[16:05:31.683]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:31.683]                               info)
[16:05:31.683]                           }
[16:05:31.683]                           else {
[16:05:31.683]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:31.683]                               info, version)
[16:05:31.683]                           }
[16:05:31.683]                           base::stop(msg)
[16:05:31.683]                         }
[16:05:31.683]                       })
[16:05:31.683]                     }
[16:05:31.683]                     base::local({
[16:05:31.683]                       for (pkg in "future") {
[16:05:31.683]                         base::loadNamespace(pkg)
[16:05:31.683]                         base::library(pkg, character.only = TRUE)
[16:05:31.683]                       }
[16:05:31.683]                     })
[16:05:31.683]                   }
[16:05:31.683]                   options(future.plan = NULL)
[16:05:31.683]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:31.683]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:31.683]                     envir = parent.frame()) 
[16:05:31.683]                   {
[16:05:31.683]                     default_workers <- missing(workers)
[16:05:31.683]                     if (is.function(workers)) 
[16:05:31.683]                       workers <- workers()
[16:05:31.683]                     workers <- structure(as.integer(workers), 
[16:05:31.683]                       class = class(workers))
[16:05:31.683]                     stop_if_not(is.finite(workers), workers >= 
[16:05:31.683]                       1L)
[16:05:31.683]                     if ((workers == 1L && !inherits(workers, 
[16:05:31.683]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:31.683]                       if (default_workers) 
[16:05:31.683]                         supportsMulticore(warn = TRUE)
[16:05:31.683]                       return(sequential(..., envir = envir))
[16:05:31.683]                     }
[16:05:31.683]                     oopts <- options(mc.cores = workers)
[16:05:31.683]                     on.exit(options(oopts))
[16:05:31.683]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:31.683]                       envir = envir)
[16:05:31.683]                     if (!future$lazy) 
[16:05:31.683]                       future <- run(future)
[16:05:31.683]                     invisible(future)
[16:05:31.683]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:31.683]                 }
[16:05:31.683]                 ...future.workdir <- getwd()
[16:05:31.683]             }
[16:05:31.683]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:31.683]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:31.683]         }
[16:05:31.683]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:31.683]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:31.683]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:31.683]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:31.683]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:31.683]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:31.683]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:31.683]             base::names(...future.oldOptions))
[16:05:31.683]     }
[16:05:31.683]     if (FALSE) {
[16:05:31.683]     }
[16:05:31.683]     else {
[16:05:31.683]         if (TRUE) {
[16:05:31.683]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:31.683]                 open = "w")
[16:05:31.683]         }
[16:05:31.683]         else {
[16:05:31.683]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:31.683]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:31.683]         }
[16:05:31.683]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:31.683]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:31.683]             base::sink(type = "output", split = FALSE)
[16:05:31.683]             base::close(...future.stdout)
[16:05:31.683]         }, add = TRUE)
[16:05:31.683]     }
[16:05:31.683]     ...future.frame <- base::sys.nframe()
[16:05:31.683]     ...future.conditions <- base::list()
[16:05:31.683]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:31.683]     if (FALSE) {
[16:05:31.683]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:31.683]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:31.683]     }
[16:05:31.683]     ...future.result <- base::tryCatch({
[16:05:31.683]         base::withCallingHandlers({
[16:05:31.683]             ...future.value <- base::withVisible(base::local({
[16:05:31.683]                 a <- 1L
[16:05:31.683]                 plan_a <- unclass(future::plan("list"))
[16:05:31.683]                 nested_a <- nested[-1]
[16:05:31.683]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:05:31.683]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:05:31.683]                   strategy2))
[16:05:31.683]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:05:31.683]                   "init") <- NULL
[16:05:31.683]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:05:31.683]                   "init") <- NULL
[16:05:31.683]                 stopifnot(all.equal(plan_a, nested_a))
[16:05:31.683]                 y %<-% {
[16:05:31.683]                   b <- 2L
[16:05:31.683]                   plan_b <- future::plan("list")
[16:05:31.683]                   nested_b <- nested_a[-1]
[16:05:31.683]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:05:31.683]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:05:31.683]                     "sequential"))
[16:05:31.683]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:05:31.683]                     b = b, nested_b = nested_b, plan_b = plan_b)
[16:05:31.683]                 }
[16:05:31.683]                 y
[16:05:31.683]             }))
[16:05:31.683]             future::FutureResult(value = ...future.value$value, 
[16:05:31.683]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:31.683]                   ...future.rng), globalenv = if (FALSE) 
[16:05:31.683]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:31.683]                     ...future.globalenv.names))
[16:05:31.683]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:31.683]         }, condition = base::local({
[16:05:31.683]             c <- base::c
[16:05:31.683]             inherits <- base::inherits
[16:05:31.683]             invokeRestart <- base::invokeRestart
[16:05:31.683]             length <- base::length
[16:05:31.683]             list <- base::list
[16:05:31.683]             seq.int <- base::seq.int
[16:05:31.683]             signalCondition <- base::signalCondition
[16:05:31.683]             sys.calls <- base::sys.calls
[16:05:31.683]             `[[` <- base::`[[`
[16:05:31.683]             `+` <- base::`+`
[16:05:31.683]             `<<-` <- base::`<<-`
[16:05:31.683]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:31.683]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:31.683]                   3L)]
[16:05:31.683]             }
[16:05:31.683]             function(cond) {
[16:05:31.683]                 is_error <- inherits(cond, "error")
[16:05:31.683]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:31.683]                   NULL)
[16:05:31.683]                 if (is_error) {
[16:05:31.683]                   sessionInformation <- function() {
[16:05:31.683]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:31.683]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:31.683]                       search = base::search(), system = base::Sys.info())
[16:05:31.683]                   }
[16:05:31.683]                   ...future.conditions[[length(...future.conditions) + 
[16:05:31.683]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:31.683]                     cond$call), session = sessionInformation(), 
[16:05:31.683]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:31.683]                   signalCondition(cond)
[16:05:31.683]                 }
[16:05:31.683]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:31.683]                 "immediateCondition"))) {
[16:05:31.683]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:31.683]                   ...future.conditions[[length(...future.conditions) + 
[16:05:31.683]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:31.683]                   if (TRUE && !signal) {
[16:05:31.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:31.683]                     {
[16:05:31.683]                       inherits <- base::inherits
[16:05:31.683]                       invokeRestart <- base::invokeRestart
[16:05:31.683]                       is.null <- base::is.null
[16:05:31.683]                       muffled <- FALSE
[16:05:31.683]                       if (inherits(cond, "message")) {
[16:05:31.683]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:31.683]                         if (muffled) 
[16:05:31.683]                           invokeRestart("muffleMessage")
[16:05:31.683]                       }
[16:05:31.683]                       else if (inherits(cond, "warning")) {
[16:05:31.683]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:31.683]                         if (muffled) 
[16:05:31.683]                           invokeRestart("muffleWarning")
[16:05:31.683]                       }
[16:05:31.683]                       else if (inherits(cond, "condition")) {
[16:05:31.683]                         if (!is.null(pattern)) {
[16:05:31.683]                           computeRestarts <- base::computeRestarts
[16:05:31.683]                           grepl <- base::grepl
[16:05:31.683]                           restarts <- computeRestarts(cond)
[16:05:31.683]                           for (restart in restarts) {
[16:05:31.683]                             name <- restart$name
[16:05:31.683]                             if (is.null(name)) 
[16:05:31.683]                               next
[16:05:31.683]                             if (!grepl(pattern, name)) 
[16:05:31.683]                               next
[16:05:31.683]                             invokeRestart(restart)
[16:05:31.683]                             muffled <- TRUE
[16:05:31.683]                             break
[16:05:31.683]                           }
[16:05:31.683]                         }
[16:05:31.683]                       }
[16:05:31.683]                       invisible(muffled)
[16:05:31.683]                     }
[16:05:31.683]                     muffleCondition(cond, pattern = "^muffle")
[16:05:31.683]                   }
[16:05:31.683]                 }
[16:05:31.683]                 else {
[16:05:31.683]                   if (TRUE) {
[16:05:31.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:31.683]                     {
[16:05:31.683]                       inherits <- base::inherits
[16:05:31.683]                       invokeRestart <- base::invokeRestart
[16:05:31.683]                       is.null <- base::is.null
[16:05:31.683]                       muffled <- FALSE
[16:05:31.683]                       if (inherits(cond, "message")) {
[16:05:31.683]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:31.683]                         if (muffled) 
[16:05:31.683]                           invokeRestart("muffleMessage")
[16:05:31.683]                       }
[16:05:31.683]                       else if (inherits(cond, "warning")) {
[16:05:31.683]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:31.683]                         if (muffled) 
[16:05:31.683]                           invokeRestart("muffleWarning")
[16:05:31.683]                       }
[16:05:31.683]                       else if (inherits(cond, "condition")) {
[16:05:31.683]                         if (!is.null(pattern)) {
[16:05:31.683]                           computeRestarts <- base::computeRestarts
[16:05:31.683]                           grepl <- base::grepl
[16:05:31.683]                           restarts <- computeRestarts(cond)
[16:05:31.683]                           for (restart in restarts) {
[16:05:31.683]                             name <- restart$name
[16:05:31.683]                             if (is.null(name)) 
[16:05:31.683]                               next
[16:05:31.683]                             if (!grepl(pattern, name)) 
[16:05:31.683]                               next
[16:05:31.683]                             invokeRestart(restart)
[16:05:31.683]                             muffled <- TRUE
[16:05:31.683]                             break
[16:05:31.683]                           }
[16:05:31.683]                         }
[16:05:31.683]                       }
[16:05:31.683]                       invisible(muffled)
[16:05:31.683]                     }
[16:05:31.683]                     muffleCondition(cond, pattern = "^muffle")
[16:05:31.683]                   }
[16:05:31.683]                 }
[16:05:31.683]             }
[16:05:31.683]         }))
[16:05:31.683]     }, error = function(ex) {
[16:05:31.683]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:31.683]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:31.683]                 ...future.rng), started = ...future.startTime, 
[16:05:31.683]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:31.683]             version = "1.8"), class = "FutureResult")
[16:05:31.683]     }, finally = {
[16:05:31.683]         if (!identical(...future.workdir, getwd())) 
[16:05:31.683]             setwd(...future.workdir)
[16:05:31.683]         {
[16:05:31.683]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:31.683]                 ...future.oldOptions$nwarnings <- NULL
[16:05:31.683]             }
[16:05:31.683]             base::options(...future.oldOptions)
[16:05:31.683]             if (.Platform$OS.type == "windows") {
[16:05:31.683]                 old_names <- names(...future.oldEnvVars)
[16:05:31.683]                 envs <- base::Sys.getenv()
[16:05:31.683]                 names <- names(envs)
[16:05:31.683]                 common <- intersect(names, old_names)
[16:05:31.683]                 added <- setdiff(names, old_names)
[16:05:31.683]                 removed <- setdiff(old_names, names)
[16:05:31.683]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:31.683]                   envs[common]]
[16:05:31.683]                 NAMES <- toupper(changed)
[16:05:31.683]                 args <- list()
[16:05:31.683]                 for (kk in seq_along(NAMES)) {
[16:05:31.683]                   name <- changed[[kk]]
[16:05:31.683]                   NAME <- NAMES[[kk]]
[16:05:31.683]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.683]                     next
[16:05:31.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:31.683]                 }
[16:05:31.683]                 NAMES <- toupper(added)
[16:05:31.683]                 for (kk in seq_along(NAMES)) {
[16:05:31.683]                   name <- added[[kk]]
[16:05:31.683]                   NAME <- NAMES[[kk]]
[16:05:31.683]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.683]                     next
[16:05:31.683]                   args[[name]] <- ""
[16:05:31.683]                 }
[16:05:31.683]                 NAMES <- toupper(removed)
[16:05:31.683]                 for (kk in seq_along(NAMES)) {
[16:05:31.683]                   name <- removed[[kk]]
[16:05:31.683]                   NAME <- NAMES[[kk]]
[16:05:31.683]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.683]                     next
[16:05:31.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:31.683]                 }
[16:05:31.683]                 if (length(args) > 0) 
[16:05:31.683]                   base::do.call(base::Sys.setenv, args = args)
[16:05:31.683]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:31.683]             }
[16:05:31.683]             else {
[16:05:31.683]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:31.683]             }
[16:05:31.683]             {
[16:05:31.683]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:31.683]                   0L) {
[16:05:31.683]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:31.683]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:31.683]                   base::options(opts)
[16:05:31.683]                 }
[16:05:31.683]                 {
[16:05:31.683]                   {
[16:05:31.683]                     NULL
[16:05:31.683]                     RNGkind("Mersenne-Twister")
[16:05:31.683]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:31.683]                       inherits = FALSE)
[16:05:31.683]                   }
[16:05:31.683]                   options(future.plan = NULL)
[16:05:31.683]                   if (is.na(NA_character_)) 
[16:05:31.683]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:31.683]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:31.683]                   future::plan(list(a = function (..., envir = parent.frame()) 
[16:05:31.683]                   {
[16:05:31.683]                     future <- SequentialFuture(..., envir = envir)
[16:05:31.683]                     if (!future$lazy) 
[16:05:31.683]                       future <- run(future)
[16:05:31.683]                     invisible(future)
[16:05:31.683]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:31.683]                     envir = parent.frame()) 
[16:05:31.683]                   {
[16:05:31.683]                     default_workers <- missing(workers)
[16:05:31.683]                     if (is.function(workers)) 
[16:05:31.683]                       workers <- workers()
[16:05:31.683]                     workers <- structure(as.integer(workers), 
[16:05:31.683]                       class = class(workers))
[16:05:31.683]                     stop_if_not(is.finite(workers), workers >= 
[16:05:31.683]                       1L)
[16:05:31.683]                     if ((workers == 1L && !inherits(workers, 
[16:05:31.683]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:31.683]                       if (default_workers) 
[16:05:31.683]                         supportsMulticore(warn = TRUE)
[16:05:31.683]                       return(sequential(..., envir = envir))
[16:05:31.683]                     }
[16:05:31.683]                     oopts <- options(mc.cores = workers)
[16:05:31.683]                     on.exit(options(oopts))
[16:05:31.683]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:31.683]                       envir = envir)
[16:05:31.683]                     if (!future$lazy) 
[16:05:31.683]                       future <- run(future)
[16:05:31.683]                     invisible(future)
[16:05:31.683]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:31.683]                 }
[16:05:31.683]             }
[16:05:31.683]         }
[16:05:31.683]     })
[16:05:31.683]     if (TRUE) {
[16:05:31.683]         base::sink(type = "output", split = FALSE)
[16:05:31.683]         if (TRUE) {
[16:05:31.683]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:31.683]         }
[16:05:31.683]         else {
[16:05:31.683]             ...future.result["stdout"] <- base::list(NULL)
[16:05:31.683]         }
[16:05:31.683]         base::close(...future.stdout)
[16:05:31.683]         ...future.stdout <- NULL
[16:05:31.683]     }
[16:05:31.683]     ...future.result$conditions <- ...future.conditions
[16:05:31.683]     ...future.result$finished <- base::Sys.time()
[16:05:31.683]     ...future.result
[16:05:31.683] }
[16:05:31.685] assign_globals() ...
[16:05:31.685] List of 2
[16:05:31.685]  $ nested   :List of 2
[16:05:31.685]   ..$ a:function (..., envir = parent.frame())  
[16:05:31.685]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:05:31.685]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:05:31.685]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:05:31.685]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:05:31.685]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:05:31.685]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:05:31.685]  $ strategy2: chr "multicore"
[16:05:31.685]  - attr(*, "where")=List of 2
[16:05:31.685]   ..$ nested   :<environment: R_EmptyEnv> 
[16:05:31.685]   ..$ strategy2:<environment: R_EmptyEnv> 
[16:05:31.685]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:31.685]  - attr(*, "resolved")= logi FALSE
[16:05:31.685]  - attr(*, "total_size")= num 59224
[16:05:31.685]  - attr(*, "already-done")= logi TRUE
[16:05:31.689] - copied ‘nested’ to environment
[16:05:31.689] - copied ‘strategy2’ to environment
[16:05:31.689] assign_globals() ... done
[16:05:31.690] plan(): Setting new future strategy stack:
[16:05:31.690] List of future strategies:
[16:05:31.690] 1. multicore:
[16:05:31.690]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:31.690]    - tweaked: FALSE
[16:05:31.690]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:31.694] plan(): nbrOfWorkers() = 2
[16:05:31.750] plan(): Setting new future strategy stack:
[16:05:31.750] List of future strategies:
[16:05:31.750] 1. sequential:
[16:05:31.750]    - args: function (..., envir = parent.frame())
[16:05:31.750]    - tweaked: FALSE
[16:05:31.750]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:31.750] 2. multicore:
[16:05:31.750]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:31.750]    - tweaked: FALSE
[16:05:31.750]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:31.750] plan(): nbrOfWorkers() = 1
[16:05:31.751] SequentialFuture started (and completed)
[16:05:31.751] signalConditions() ...
[16:05:31.751]  - include = ‘immediateCondition’
[16:05:31.751]  - exclude = 
[16:05:31.751]  - resignal = FALSE
[16:05:31.751]  - Number of conditions: 57
[16:05:31.752] signalConditions() ... done
[16:05:31.752] - Launch lazy future ... done
[16:05:31.752] run() for ‘SequentialFuture’ ... done
[16:05:31.752] signalConditions() ...
[16:05:31.752]  - include = ‘immediateCondition’
[16:05:31.752]  - exclude = 
[16:05:31.752]  - resignal = FALSE
[16:05:31.753]  - Number of conditions: 57
[16:05:31.753] signalConditions() ... done
[16:05:31.753] Future state: ‘finished’
[16:05:31.753] signalConditions() ...
[16:05:31.753]  - include = ‘condition’
[16:05:31.753]  - exclude = ‘immediateCondition’
[16:05:31.753]  - resignal = TRUE
[16:05:31.754]  - Number of conditions: 57
[16:05:31.754]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.695] getGlobalsAndPackages() ...
[16:05:31.754]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.695] Searching for globals...
[16:05:31.754]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.712] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[16:05:31.754]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.713] Searching for globals ... DONE
[16:05:31.754]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.713] Resolving globals: FALSE
[16:05:31.754]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.713] The total size of the 3 globals is 93.01 KiB (95240 bytes)
[16:05:31.755]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.714] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 93.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (46.48 KiB of class ‘list’), ‘plan_a’ (46.48 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[16:05:31.755]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.714] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[16:05:31.755]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.714] 
[16:05:31.755]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.714] getGlobalsAndPackages() ... DONE
[16:05:31.755]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.714] run() for ‘Future’ ...
[16:05:31.755]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.714] - state: ‘created’
[16:05:31.756]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.715] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:31.756]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.718] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:31.756]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.718] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:31.756]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.718]   - Field: ‘label’
[16:05:31.756]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.719]   - Field: ‘local’
[16:05:31.756]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.719]   - Field: ‘owner’
[16:05:31.757]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.719]   - Field: ‘envir’
[16:05:31.757]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.719]   - Field: ‘workers’
[16:05:31.757]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.719]   - Field: ‘packages’
[16:05:31.757]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.719]   - Field: ‘gc’
[16:05:31.757]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.719]   - Field: ‘job’
[16:05:31.757]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.719]   - Field: ‘conditions’
[16:05:31.757]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.719]   - Field: ‘expr’
[16:05:31.758]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.719]   - Field: ‘uuid’
[16:05:31.758]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.720]   - Field: ‘seed’
[16:05:31.758]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.720]   - Field: ‘version’
[16:05:31.758]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.720]   - Field: ‘result’
[16:05:31.758]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.720]   - Field: ‘asynchronous’
[16:05:31.758]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.720]   - Field: ‘calls’
[16:05:31.759]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.720]   - Field: ‘globals’
[16:05:31.759]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.720]   - Field: ‘stdout’
[16:05:31.759]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.720]   - Field: ‘earlySignal’
[16:05:31.759]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.720]   - Field: ‘lazy’
[16:05:31.759]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.720]   - Field: ‘state’
[16:05:31.759]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.721] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:31.760]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.721] - Launch lazy future ...
[16:05:31.760]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.722] Packages needed by the future expression (n = 0): <none>
[16:05:31.760]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.722] Packages needed by future strategies (n = 0): <none>
[16:05:31.760]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.722] {
[16:05:31.722]     {
[16:05:31.722]         {
[16:05:31.722]             ...future.startTime <- base::Sys.time()
[16:05:31.722]             {
[16:05:31.722]                 {
[16:05:31.722]                   {
[16:05:31.722]                     {
[16:05:31.722]                       base::local({
[16:05:31.722]                         has_future <- base::requireNamespace("future", 
[16:05:31.722]                           quietly = TRUE)
[16:05:31.722]                         if (has_future) {
[16:05:31.722]                           ns <- base::getNamespace("future")
[16:05:31.722]                           version <- ns[[".package"]][["version"]]
[16:05:31.722]                           if (is.null(version)) 
[16:05:31.722]                             version <- utils::packageVersion("future")
[16:05:31.722]                         }
[16:05:31.722]                         else {
[16:05:31.722]                           version <- NULL
[16:05:31.722]                         }
[16:05:31.722]                         if (!has_future || version < "1.8.0") {
[16:05:31.722]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:31.722]                             "", base::R.version$version.string), 
[16:05:31.722]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:31.722]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:31.722]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:31.722]                               "release", "version")], collapse = " "), 
[16:05:31.722]                             hostname = base::Sys.info()[["nodename"]])
[16:05:31.722]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:31.722]                             info)
[16:05:31.722]                           info <- base::paste(info, collapse = "; ")
[16:05:31.722]                           if (!has_future) {
[16:05:31.722]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:31.722]                               info)
[16:05:31.722]                           }
[16:05:31.722]                           else {
[16:05:31.722]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:31.722]                               info, version)
[16:05:31.722]                           }
[16:05:31.722]                           base::stop(msg)
[16:05:31.722]                         }
[16:05:31.722]                       })
[16:05:31.722]                     }
[16:05:31.722]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:31.722]                     base::options(mc.cores = 1L)
[16:05:31.722]                   }
[16:05:31.722]                   options(future.plan = NULL)
[16:05:31.722]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:31.722]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:31.722]                 }
[16:05:31.722]                 ...future.workdir <- getwd()
[16:05:31.722]             }
[16:05:31.722]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:31.722]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:31.722]         }
[16:05:31.722]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:31.722]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:31.722]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:31.722]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:31.722]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:31.722]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:31.722]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:31.722]             base::names(...future.oldOptions))
[16:05:31.722]     }
[16:05:31.722]     if (FALSE) {
[16:05:31.722]     }
[16:05:31.722]     else {
[16:05:31.722]         if (TRUE) {
[16:05:31.722]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:31.722]                 open = "w")
[16:05:31.722]         }
[16:05:31.722]         else {
[16:05:31.722]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:31.722]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:31.722]         }
[16:05:31.722]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:31.722]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:31.722]             base::sink(type = "output", split = FALSE)
[16:05:31.722]             base::close(...future.stdout)
[16:05:31.722]         }, add = TRUE)
[16:05:31.722]     }
[16:05:31.722]     ...future.frame <- base::sys.nframe()
[16:05:31.722]     ...future.conditions <- base::list()
[16:05:31.722]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:31.722]     if (FALSE) {
[16:05:31.722]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:31.722]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:31.722]     }
[16:05:31.722]     ...future.result <- base::tryCatch({
[16:05:31.722]         base::withCallingHandlers({
[16:05:31.722]             ...future.value <- base::withVisible(base::local({
[16:05:31.722]                 withCallingHandlers({
[16:05:31.722]                   {
[16:05:31.722]                     b <- 2L
[16:05:31.722]                     plan_b <- future::plan("list")
[16:05:31.722]                     nested_b <- nested_a[-1]
[16:05:31.722]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:05:31.722]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:05:31.722]                       "sequential"))
[16:05:31.722]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:05:31.722]                       b = b, nested_b = nested_b, plan_b = plan_b)
[16:05:31.722]                   }
[16:05:31.722]                 }, immediateCondition = function(cond) {
[16:05:31.722]                   save_rds <- function (object, pathname, ...) 
[16:05:31.722]                   {
[16:05:31.722]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:31.722]                     if (file_test("-f", pathname_tmp)) {
[16:05:31.722]                       fi_tmp <- file.info(pathname_tmp)
[16:05:31.722]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:31.722]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:31.722]                         fi_tmp[["mtime"]])
[16:05:31.722]                     }
[16:05:31.722]                     tryCatch({
[16:05:31.722]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:31.722]                     }, error = function(ex) {
[16:05:31.722]                       msg <- conditionMessage(ex)
[16:05:31.722]                       fi_tmp <- file.info(pathname_tmp)
[16:05:31.722]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:31.722]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:31.722]                         fi_tmp[["mtime"]], msg)
[16:05:31.722]                       ex$message <- msg
[16:05:31.722]                       stop(ex)
[16:05:31.722]                     })
[16:05:31.722]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:31.722]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:31.722]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:31.722]                       fi_tmp <- file.info(pathname_tmp)
[16:05:31.722]                       fi <- file.info(pathname)
[16:05:31.722]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:31.722]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:31.722]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:31.722]                         fi[["size"]], fi[["mtime"]])
[16:05:31.722]                       stop(msg)
[16:05:31.722]                     }
[16:05:31.722]                     invisible(pathname)
[16:05:31.722]                   }
[16:05:31.722]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:31.722]                     rootPath = tempdir()) 
[16:05:31.722]                   {
[16:05:31.722]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:31.722]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:31.722]                       tmpdir = path, fileext = ".rds")
[16:05:31.722]                     save_rds(obj, file)
[16:05:31.722]                   }
[16:05:31.722]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0EbAi0/.future/immediateConditions")
[16:05:31.722]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:31.722]                   {
[16:05:31.722]                     inherits <- base::inherits
[16:05:31.722]                     invokeRestart <- base::invokeRestart
[16:05:31.722]                     is.null <- base::is.null
[16:05:31.722]                     muffled <- FALSE
[16:05:31.722]                     if (inherits(cond, "message")) {
[16:05:31.722]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:31.722]                       if (muffled) 
[16:05:31.722]                         invokeRestart("muffleMessage")
[16:05:31.722]                     }
[16:05:31.722]                     else if (inherits(cond, "warning")) {
[16:05:31.722]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:31.722]                       if (muffled) 
[16:05:31.722]                         invokeRestart("muffleWarning")
[16:05:31.722]                     }
[16:05:31.722]                     else if (inherits(cond, "condition")) {
[16:05:31.722]                       if (!is.null(pattern)) {
[16:05:31.722]                         computeRestarts <- base::computeRestarts
[16:05:31.722]                         grepl <- base::grepl
[16:05:31.722]                         restarts <- computeRestarts(cond)
[16:05:31.722]                         for (restart in restarts) {
[16:05:31.722]                           name <- restart$name
[16:05:31.722]                           if (is.null(name)) 
[16:05:31.722]                             next
[16:05:31.722]                           if (!grepl(pattern, name)) 
[16:05:31.722]                             next
[16:05:31.722]                           invokeRestart(restart)
[16:05:31.722]                           muffled <- TRUE
[16:05:31.722]                           break
[16:05:31.722]                         }
[16:05:31.722]                       }
[16:05:31.722]                     }
[16:05:31.722]                     invisible(muffled)
[16:05:31.722]                   }
[16:05:31.722]                   muffleCondition(cond)
[16:05:31.722]                 })
[16:05:31.722]             }))
[16:05:31.722]             future::FutureResult(value = ...future.value$value, 
[16:05:31.722]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:31.722]                   ...future.rng), globalenv = if (FALSE) 
[16:05:31.722]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:31.722]                     ...future.globalenv.names))
[16:05:31.722]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:31.722]         }, condition = base::local({
[16:05:31.722]             c <- base::c
[16:05:31.722]             inherits <- base::inherits
[16:05:31.722]             invokeRestart <- base::invokeRestart
[16:05:31.722]             length <- base::length
[16:05:31.722]             list <- base::list
[16:05:31.722]             seq.int <- base::seq.int
[16:05:31.722]             signalCondition <- base::signalCondition
[16:05:31.722]             sys.calls <- base::sys.calls
[16:05:31.722]             `[[` <- base::`[[`
[16:05:31.722]             `+` <- base::`+`
[16:05:31.722]             `<<-` <- base::`<<-`
[16:05:31.722]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:31.722]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:31.722]                   3L)]
[16:05:31.722]             }
[16:05:31.722]             function(cond) {
[16:05:31.722]                 is_error <- inherits(cond, "error")
[16:05:31.722]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:31.722]                   NULL)
[16:05:31.722]                 if (is_error) {
[16:05:31.722]                   sessionInformation <- function() {
[16:05:31.722]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:31.722]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:31.722]                       search = base::search(), system = base::Sys.info())
[16:05:31.722]                   }
[16:05:31.722]                   ...future.conditions[[length(...future.conditions) + 
[16:05:31.722]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:31.722]                     cond$call), session = sessionInformation(), 
[16:05:31.722]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:31.722]                   signalCondition(cond)
[16:05:31.722]                 }
[16:05:31.722]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:31.722]                 "immediateCondition"))) {
[16:05:31.722]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:31.722]                   ...future.conditions[[length(...future.conditions) + 
[16:05:31.722]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:31.722]                   if (TRUE && !signal) {
[16:05:31.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:31.722]                     {
[16:05:31.722]                       inherits <- base::inherits
[16:05:31.722]                       invokeRestart <- base::invokeRestart
[16:05:31.722]                       is.null <- base::is.null
[16:05:31.722]                       muffled <- FALSE
[16:05:31.722]                       if (inherits(cond, "message")) {
[16:05:31.722]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:31.722]                         if (muffled) 
[16:05:31.722]                           invokeRestart("muffleMessage")
[16:05:31.722]                       }
[16:05:31.722]                       else if (inherits(cond, "warning")) {
[16:05:31.722]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:31.722]                         if (muffled) 
[16:05:31.722]                           invokeRestart("muffleWarning")
[16:05:31.722]                       }
[16:05:31.722]                       else if (inherits(cond, "condition")) {
[16:05:31.722]                         if (!is.null(pattern)) {
[16:05:31.722]                           computeRestarts <- base::computeRestarts
[16:05:31.722]                           grepl <- base::grepl
[16:05:31.722]                           restarts <- computeRestarts(cond)
[16:05:31.722]                           for (restart in restarts) {
[16:05:31.722]                             name <- restart$name
[16:05:31.722]                             if (is.null(name)) 
[16:05:31.722]                               next
[16:05:31.722]                             if (!grepl(pattern, name)) 
[16:05:31.722]                               next
[16:05:31.722]                             invokeRestart(restart)
[16:05:31.722]                             muffled <- TRUE
[16:05:31.722]                             break
[16:05:31.722]                           }
[16:05:31.722]                         }
[16:05:31.722]                       }
[16:05:31.722]                       invisible(muffled)
[16:05:31.722]                     }
[16:05:31.722]                     muffleCondition(cond, pattern = "^muffle")
[16:05:31.722]                   }
[16:05:31.722]                 }
[16:05:31.722]                 else {
[16:05:31.722]                   if (TRUE) {
[16:05:31.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:31.722]                     {
[16:05:31.722]                       inherits <- base::inherits
[16:05:31.722]                       invokeRestart <- base::invokeRestart
[16:05:31.722]                       is.null <- base::is.null
[16:05:31.722]                       muffled <- FALSE
[16:05:31.722]                       if (inherits(cond, "message")) {
[16:05:31.722]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:31.722]                         if (muffled) 
[16:05:31.722]                           invokeRestart("muffleMessage")
[16:05:31.722]                       }
[16:05:31.722]                       else if (inherits(cond, "warning")) {
[16:05:31.722]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:31.722]                         if (muffled) 
[16:05:31.722]                           invokeRestart("muffleWarning")
[16:05:31.722]                       }
[16:05:31.722]                       else if (inherits(cond, "condition")) {
[16:05:31.722]                         if (!is.null(pattern)) {
[16:05:31.722]                           computeRestarts <- base::computeRestarts
[16:05:31.722]                           grepl <- base::grepl
[16:05:31.722]                           restarts <- computeRestarts(cond)
[16:05:31.722]                           for (restart in restarts) {
[16:05:31.722]                             name <- restart$name
[16:05:31.722]                             if (is.null(name)) 
[16:05:31.722]                               next
[16:05:31.722]                             if (!grepl(pattern, name)) 
[16:05:31.722]                               next
[16:05:31.722]                             invokeRestart(restart)
[16:05:31.722]                             muffled <- TRUE
[16:05:31.722]                             break
[16:05:31.722]                           }
[16:05:31.722]                         }
[16:05:31.722]                       }
[16:05:31.722]                       invisible(muffled)
[16:05:31.722]                     }
[16:05:31.722]                     muffleCondition(cond, pattern = "^muffle")
[16:05:31.722]                   }
[16:05:31.722]                 }
[16:05:31.722]             }
[16:05:31.722]         }))
[16:05:31.722]     }, error = function(ex) {
[16:05:31.722]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:31.722]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:31.722]                 ...future.rng), started = ...future.startTime, 
[16:05:31.722]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:31.722]             version = "1.8"), class = "FutureResult")
[16:05:31.722]     }, finally = {
[16:05:31.722]         if (!identical(...future.workdir, getwd())) 
[16:05:31.722]             setwd(...future.workdir)
[16:05:31.722]         {
[16:05:31.722]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:31.722]                 ...future.oldOptions$nwarnings <- NULL
[16:05:31.722]             }
[16:05:31.722]             base::options(...future.oldOptions)
[16:05:31.722]             if (.Platform$OS.type == "windows") {
[16:05:31.722]                 old_names <- names(...future.oldEnvVars)
[16:05:31.722]                 envs <- base::Sys.getenv()
[16:05:31.722]                 names <- names(envs)
[16:05:31.722]                 common <- intersect(names, old_names)
[16:05:31.722]                 added <- setdiff(names, old_names)
[16:05:31.722]                 removed <- setdiff(old_names, names)
[16:05:31.722]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:31.722]                   envs[common]]
[16:05:31.722]                 NAMES <- toupper(changed)
[16:05:31.722]                 args <- list()
[16:05:31.722]                 for (kk in seq_along(NAMES)) {
[16:05:31.722]                   name <- changed[[kk]]
[16:05:31.722]                   NAME <- NAMES[[kk]]
[16:05:31.722]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.722]                     next
[16:05:31.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:31.722]                 }
[16:05:31.722]                 NAMES <- toupper(added)
[16:05:31.722]                 for (kk in seq_along(NAMES)) {
[16:05:31.722]                   name <- added[[kk]]
[16:05:31.722]                   NAME <- NAMES[[kk]]
[16:05:31.722]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.722]                     next
[16:05:31.722]                   args[[name]] <- ""
[16:05:31.722]                 }
[16:05:31.722]                 NAMES <- toupper(removed)
[16:05:31.722]                 for (kk in seq_along(NAMES)) {
[16:05:31.722]                   name <- removed[[kk]]
[16:05:31.722]                   NAME <- NAMES[[kk]]
[16:05:31.722]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.722]                     next
[16:05:31.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:31.722]                 }
[16:05:31.722]                 if (length(args) > 0) 
[16:05:31.722]                   base::do.call(base::Sys.setenv, args = args)
[16:05:31.722]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:31.722]             }
[16:05:31.722]             else {
[16:05:31.722]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:31.722]             }
[16:05:31.722]             {
[16:05:31.722]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:31.722]                   0L) {
[16:05:31.722]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:31.722]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:31.722]                   base::options(opts)
[16:05:31.722]                 }
[16:05:31.722]                 {
[16:05:31.722]                   {
[16:05:31.722]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:31.722]                     NULL
[16:05:31.722]                   }
[16:05:31.722]                   options(future.plan = NULL)
[16:05:31.722]                   if (is.na(NA_character_)) 
[16:05:31.722]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:31.722]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:31.722]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:31.722]                     envir = parent.frame()) 
[16:05:31.722]                   {
[16:05:31.722]                     default_workers <- missing(workers)
[16:05:31.722]                     if (is.function(workers)) 
[16:05:31.722]                       workers <- workers()
[16:05:31.722]                     workers <- structure(as.integer(workers), 
[16:05:31.722]                       class = class(workers))
[16:05:31.722]                     stop_if_not(is.finite(workers), workers >= 
[16:05:31.722]                       1L)
[16:05:31.722]                     if ((workers == 1L && !inherits(workers, 
[16:05:31.722]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:31.722]                       if (default_workers) 
[16:05:31.722]                         supportsMulticore(warn = TRUE)
[16:05:31.722]                       return(sequential(..., envir = envir))
[16:05:31.722]                     }
[16:05:31.722]                     oopts <- options(mc.cores = workers)
[16:05:31.722]                     on.exit(options(oopts))
[16:05:31.722]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:31.722]                       envir = envir)
[16:05:31.722]                     if (!future$lazy) 
[16:05:31.722]                       future <- run(future)
[16:05:31.722]                     invisible(future)
[16:05:31.722]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:31.722]                 }
[16:05:31.722]             }
[16:05:31.722]         }
[16:05:31.722]     })
[16:05:31.722]     if (TRUE) {
[16:05:31.722]         base::sink(type = "output", split = FALSE)
[16:05:31.722]         if (TRUE) {
[16:05:31.722]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:31.722]         }
[16:05:31.722]         else {
[16:05:31.722]             ...future.result["stdout"] <- base::list(NULL)
[16:05:31.722]         }
[16:05:31.722]         base::close(...future.stdout)
[16:05:31.722]         ...future.stdout <- NULL
[16:05:31.722]     }
[16:05:31.722]     ...future.result$conditions <- ...future.conditions
[16:05:31.722]     ...future.result$finished <- base::Sys.time()
[16:05:31.722]     ...future.result
[16:05:31.722] }
[16:05:31.760]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.724] assign_globals() ...
[16:05:31.760]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.725] List of 3
[16:05:31.725]  $ nested_a:List of 1
[16:05:31.725]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:05:31.725]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:05:31.725]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:05:31.725]  $ a       : int 1
[16:05:31.725]  $ plan_a  :List of 1
[16:05:31.725]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:05:31.725]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:05:31.725]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:05:31.725]  - attr(*, "where")=List of 3
[16:05:31.725]   ..$ nested_a:<environment: R_EmptyEnv> 
[16:05:31.725]   ..$ a       :<environment: R_EmptyEnv> 
[16:05:31.725]   ..$ plan_a  :<environment: R_EmptyEnv> 
[16:05:31.725]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:31.725]  - attr(*, "resolved")= logi FALSE
[16:05:31.725]  - attr(*, "total_size")= num 95240
[16:05:31.725]  - attr(*, "already-done")= logi TRUE
[16:05:31.760]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.729] - copied ‘nested_a’ to environment
[16:05:31.761]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.729] - copied ‘a’ to environment
[16:05:31.761]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.729] - copied ‘plan_a’ to environment
[16:05:31.761]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.730] assign_globals() ... done
[16:05:31.761]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.730] requestCore(): workers = 2
[16:05:31.761]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.733] MulticoreFuture started
[16:05:31.761]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.733] - Launch lazy future ... done
[16:05:31.762]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.734] run() for ‘MulticoreFuture’ ... done
[16:05:31.762]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.735] result() for MulticoreFuture ...
[16:05:31.762]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.746] result() for MulticoreFuture ...
[16:05:31.762]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.746] result() for MulticoreFuture ... done
[16:05:31.762]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.746] result() for MulticoreFuture ... done
[16:05:31.762]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.746] result() for MulticoreFuture ...
[16:05:31.762]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.746] result() for MulticoreFuture ... done
[16:05:31.763] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:05:31.768] getGlobalsAndPackages() ...
[16:05:31.768] Searching for globals...
[16:05:31.770] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:05:31.770] Searching for globals ... DONE
[16:05:31.770] Resolving globals: FALSE
[16:05:31.770] The total size of the 1 globals is 128 bytes (128 bytes)
[16:05:31.771] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:05:31.771] - globals: [1] ‘data’
[16:05:31.771] - packages: [1] ‘future’
[16:05:31.771] getGlobalsAndPackages() ... DONE
[16:05:31.771] run() for ‘Future’ ...
[16:05:31.772] - state: ‘created’
[16:05:31.772] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:31.772] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:31.772] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:31.772]   - Field: ‘label’
[16:05:31.772]   - Field: ‘local’
[16:05:31.772]   - Field: ‘owner’
[16:05:31.772]   - Field: ‘envir’
[16:05:31.773]   - Field: ‘packages’
[16:05:31.773]   - Field: ‘gc’
[16:05:31.773]   - Field: ‘conditions’
[16:05:31.774]   - Field: ‘expr’
[16:05:31.774]   - Field: ‘uuid’
[16:05:31.774]   - Field: ‘seed’
[16:05:31.774]   - Field: ‘version’
[16:05:31.774]   - Field: ‘result’
[16:05:31.774]   - Field: ‘asynchronous’
[16:05:31.775]   - Field: ‘calls’
[16:05:31.775]   - Field: ‘globals’
[16:05:31.775]   - Field: ‘stdout’
[16:05:31.775]   - Field: ‘earlySignal’
[16:05:31.775]   - Field: ‘lazy’
[16:05:31.775]   - Field: ‘state’
[16:05:31.775] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:31.775] - Launch lazy future ...
[16:05:31.775] Packages needed by the future expression (n = 1): ‘future’
[16:05:31.776] Packages needed by future strategies (n = 1): ‘future’
[16:05:31.776] {
[16:05:31.776]     {
[16:05:31.776]         {
[16:05:31.776]             ...future.startTime <- base::Sys.time()
[16:05:31.776]             {
[16:05:31.776]                 {
[16:05:31.776]                   {
[16:05:31.776]                     {
[16:05:31.776]                       base::local({
[16:05:31.776]                         has_future <- base::requireNamespace("future", 
[16:05:31.776]                           quietly = TRUE)
[16:05:31.776]                         if (has_future) {
[16:05:31.776]                           ns <- base::getNamespace("future")
[16:05:31.776]                           version <- ns[[".package"]][["version"]]
[16:05:31.776]                           if (is.null(version)) 
[16:05:31.776]                             version <- utils::packageVersion("future")
[16:05:31.776]                         }
[16:05:31.776]                         else {
[16:05:31.776]                           version <- NULL
[16:05:31.776]                         }
[16:05:31.776]                         if (!has_future || version < "1.8.0") {
[16:05:31.776]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:31.776]                             "", base::R.version$version.string), 
[16:05:31.776]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:31.776]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:31.776]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:31.776]                               "release", "version")], collapse = " "), 
[16:05:31.776]                             hostname = base::Sys.info()[["nodename"]])
[16:05:31.776]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:31.776]                             info)
[16:05:31.776]                           info <- base::paste(info, collapse = "; ")
[16:05:31.776]                           if (!has_future) {
[16:05:31.776]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:31.776]                               info)
[16:05:31.776]                           }
[16:05:31.776]                           else {
[16:05:31.776]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:31.776]                               info, version)
[16:05:31.776]                           }
[16:05:31.776]                           base::stop(msg)
[16:05:31.776]                         }
[16:05:31.776]                       })
[16:05:31.776]                     }
[16:05:31.776]                     base::local({
[16:05:31.776]                       for (pkg in "future") {
[16:05:31.776]                         base::loadNamespace(pkg)
[16:05:31.776]                         base::library(pkg, character.only = TRUE)
[16:05:31.776]                       }
[16:05:31.776]                     })
[16:05:31.776]                   }
[16:05:31.776]                   options(future.plan = NULL)
[16:05:31.776]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:31.776]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:31.776]                     envir = parent.frame()) 
[16:05:31.776]                   {
[16:05:31.776]                     default_workers <- missing(workers)
[16:05:31.776]                     if (is.function(workers)) 
[16:05:31.776]                       workers <- workers()
[16:05:31.776]                     workers <- structure(as.integer(workers), 
[16:05:31.776]                       class = class(workers))
[16:05:31.776]                     stop_if_not(is.finite(workers), workers >= 
[16:05:31.776]                       1L)
[16:05:31.776]                     if ((workers == 1L && !inherits(workers, 
[16:05:31.776]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:31.776]                       if (default_workers) 
[16:05:31.776]                         supportsMulticore(warn = TRUE)
[16:05:31.776]                       return(sequential(..., envir = envir))
[16:05:31.776]                     }
[16:05:31.776]                     oopts <- options(mc.cores = workers)
[16:05:31.776]                     on.exit(options(oopts))
[16:05:31.776]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:31.776]                       envir = envir)
[16:05:31.776]                     if (!future$lazy) 
[16:05:31.776]                       future <- run(future)
[16:05:31.776]                     invisible(future)
[16:05:31.776]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:31.776]                 }
[16:05:31.776]                 ...future.workdir <- getwd()
[16:05:31.776]             }
[16:05:31.776]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:31.776]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:31.776]         }
[16:05:31.776]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:31.776]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:31.776]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:31.776]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:31.776]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:31.776]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:31.776]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:31.776]             base::names(...future.oldOptions))
[16:05:31.776]     }
[16:05:31.776]     if (FALSE) {
[16:05:31.776]     }
[16:05:31.776]     else {
[16:05:31.776]         if (TRUE) {
[16:05:31.776]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:31.776]                 open = "w")
[16:05:31.776]         }
[16:05:31.776]         else {
[16:05:31.776]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:31.776]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:31.776]         }
[16:05:31.776]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:31.776]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:31.776]             base::sink(type = "output", split = FALSE)
[16:05:31.776]             base::close(...future.stdout)
[16:05:31.776]         }, add = TRUE)
[16:05:31.776]     }
[16:05:31.776]     ...future.frame <- base::sys.nframe()
[16:05:31.776]     ...future.conditions <- base::list()
[16:05:31.776]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:31.776]     if (FALSE) {
[16:05:31.776]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:31.776]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:31.776]     }
[16:05:31.776]     ...future.result <- base::tryCatch({
[16:05:31.776]         base::withCallingHandlers({
[16:05:31.776]             ...future.value <- base::withVisible(base::local({
[16:05:31.776]                 value(future(subset(data, a == 2)))
[16:05:31.776]             }))
[16:05:31.776]             future::FutureResult(value = ...future.value$value, 
[16:05:31.776]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:31.776]                   ...future.rng), globalenv = if (FALSE) 
[16:05:31.776]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:31.776]                     ...future.globalenv.names))
[16:05:31.776]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:31.776]         }, condition = base::local({
[16:05:31.776]             c <- base::c
[16:05:31.776]             inherits <- base::inherits
[16:05:31.776]             invokeRestart <- base::invokeRestart
[16:05:31.776]             length <- base::length
[16:05:31.776]             list <- base::list
[16:05:31.776]             seq.int <- base::seq.int
[16:05:31.776]             signalCondition <- base::signalCondition
[16:05:31.776]             sys.calls <- base::sys.calls
[16:05:31.776]             `[[` <- base::`[[`
[16:05:31.776]             `+` <- base::`+`
[16:05:31.776]             `<<-` <- base::`<<-`
[16:05:31.776]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:31.776]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:31.776]                   3L)]
[16:05:31.776]             }
[16:05:31.776]             function(cond) {
[16:05:31.776]                 is_error <- inherits(cond, "error")
[16:05:31.776]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:31.776]                   NULL)
[16:05:31.776]                 if (is_error) {
[16:05:31.776]                   sessionInformation <- function() {
[16:05:31.776]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:31.776]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:31.776]                       search = base::search(), system = base::Sys.info())
[16:05:31.776]                   }
[16:05:31.776]                   ...future.conditions[[length(...future.conditions) + 
[16:05:31.776]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:31.776]                     cond$call), session = sessionInformation(), 
[16:05:31.776]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:31.776]                   signalCondition(cond)
[16:05:31.776]                 }
[16:05:31.776]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:31.776]                 "immediateCondition"))) {
[16:05:31.776]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:31.776]                   ...future.conditions[[length(...future.conditions) + 
[16:05:31.776]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:31.776]                   if (TRUE && !signal) {
[16:05:31.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:31.776]                     {
[16:05:31.776]                       inherits <- base::inherits
[16:05:31.776]                       invokeRestart <- base::invokeRestart
[16:05:31.776]                       is.null <- base::is.null
[16:05:31.776]                       muffled <- FALSE
[16:05:31.776]                       if (inherits(cond, "message")) {
[16:05:31.776]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:31.776]                         if (muffled) 
[16:05:31.776]                           invokeRestart("muffleMessage")
[16:05:31.776]                       }
[16:05:31.776]                       else if (inherits(cond, "warning")) {
[16:05:31.776]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:31.776]                         if (muffled) 
[16:05:31.776]                           invokeRestart("muffleWarning")
[16:05:31.776]                       }
[16:05:31.776]                       else if (inherits(cond, "condition")) {
[16:05:31.776]                         if (!is.null(pattern)) {
[16:05:31.776]                           computeRestarts <- base::computeRestarts
[16:05:31.776]                           grepl <- base::grepl
[16:05:31.776]                           restarts <- computeRestarts(cond)
[16:05:31.776]                           for (restart in restarts) {
[16:05:31.776]                             name <- restart$name
[16:05:31.776]                             if (is.null(name)) 
[16:05:31.776]                               next
[16:05:31.776]                             if (!grepl(pattern, name)) 
[16:05:31.776]                               next
[16:05:31.776]                             invokeRestart(restart)
[16:05:31.776]                             muffled <- TRUE
[16:05:31.776]                             break
[16:05:31.776]                           }
[16:05:31.776]                         }
[16:05:31.776]                       }
[16:05:31.776]                       invisible(muffled)
[16:05:31.776]                     }
[16:05:31.776]                     muffleCondition(cond, pattern = "^muffle")
[16:05:31.776]                   }
[16:05:31.776]                 }
[16:05:31.776]                 else {
[16:05:31.776]                   if (TRUE) {
[16:05:31.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:31.776]                     {
[16:05:31.776]                       inherits <- base::inherits
[16:05:31.776]                       invokeRestart <- base::invokeRestart
[16:05:31.776]                       is.null <- base::is.null
[16:05:31.776]                       muffled <- FALSE
[16:05:31.776]                       if (inherits(cond, "message")) {
[16:05:31.776]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:31.776]                         if (muffled) 
[16:05:31.776]                           invokeRestart("muffleMessage")
[16:05:31.776]                       }
[16:05:31.776]                       else if (inherits(cond, "warning")) {
[16:05:31.776]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:31.776]                         if (muffled) 
[16:05:31.776]                           invokeRestart("muffleWarning")
[16:05:31.776]                       }
[16:05:31.776]                       else if (inherits(cond, "condition")) {
[16:05:31.776]                         if (!is.null(pattern)) {
[16:05:31.776]                           computeRestarts <- base::computeRestarts
[16:05:31.776]                           grepl <- base::grepl
[16:05:31.776]                           restarts <- computeRestarts(cond)
[16:05:31.776]                           for (restart in restarts) {
[16:05:31.776]                             name <- restart$name
[16:05:31.776]                             if (is.null(name)) 
[16:05:31.776]                               next
[16:05:31.776]                             if (!grepl(pattern, name)) 
[16:05:31.776]                               next
[16:05:31.776]                             invokeRestart(restart)
[16:05:31.776]                             muffled <- TRUE
[16:05:31.776]                             break
[16:05:31.776]                           }
[16:05:31.776]                         }
[16:05:31.776]                       }
[16:05:31.776]                       invisible(muffled)
[16:05:31.776]                     }
[16:05:31.776]                     muffleCondition(cond, pattern = "^muffle")
[16:05:31.776]                   }
[16:05:31.776]                 }
[16:05:31.776]             }
[16:05:31.776]         }))
[16:05:31.776]     }, error = function(ex) {
[16:05:31.776]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:31.776]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:31.776]                 ...future.rng), started = ...future.startTime, 
[16:05:31.776]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:31.776]             version = "1.8"), class = "FutureResult")
[16:05:31.776]     }, finally = {
[16:05:31.776]         if (!identical(...future.workdir, getwd())) 
[16:05:31.776]             setwd(...future.workdir)
[16:05:31.776]         {
[16:05:31.776]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:31.776]                 ...future.oldOptions$nwarnings <- NULL
[16:05:31.776]             }
[16:05:31.776]             base::options(...future.oldOptions)
[16:05:31.776]             if (.Platform$OS.type == "windows") {
[16:05:31.776]                 old_names <- names(...future.oldEnvVars)
[16:05:31.776]                 envs <- base::Sys.getenv()
[16:05:31.776]                 names <- names(envs)
[16:05:31.776]                 common <- intersect(names, old_names)
[16:05:31.776]                 added <- setdiff(names, old_names)
[16:05:31.776]                 removed <- setdiff(old_names, names)
[16:05:31.776]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:31.776]                   envs[common]]
[16:05:31.776]                 NAMES <- toupper(changed)
[16:05:31.776]                 args <- list()
[16:05:31.776]                 for (kk in seq_along(NAMES)) {
[16:05:31.776]                   name <- changed[[kk]]
[16:05:31.776]                   NAME <- NAMES[[kk]]
[16:05:31.776]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.776]                     next
[16:05:31.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:31.776]                 }
[16:05:31.776]                 NAMES <- toupper(added)
[16:05:31.776]                 for (kk in seq_along(NAMES)) {
[16:05:31.776]                   name <- added[[kk]]
[16:05:31.776]                   NAME <- NAMES[[kk]]
[16:05:31.776]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.776]                     next
[16:05:31.776]                   args[[name]] <- ""
[16:05:31.776]                 }
[16:05:31.776]                 NAMES <- toupper(removed)
[16:05:31.776]                 for (kk in seq_along(NAMES)) {
[16:05:31.776]                   name <- removed[[kk]]
[16:05:31.776]                   NAME <- NAMES[[kk]]
[16:05:31.776]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.776]                     next
[16:05:31.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:31.776]                 }
[16:05:31.776]                 if (length(args) > 0) 
[16:05:31.776]                   base::do.call(base::Sys.setenv, args = args)
[16:05:31.776]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:31.776]             }
[16:05:31.776]             else {
[16:05:31.776]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:31.776]             }
[16:05:31.776]             {
[16:05:31.776]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:31.776]                   0L) {
[16:05:31.776]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:31.776]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:31.776]                   base::options(opts)
[16:05:31.776]                 }
[16:05:31.776]                 {
[16:05:31.776]                   {
[16:05:31.776]                     NULL
[16:05:31.776]                     RNGkind("Mersenne-Twister")
[16:05:31.776]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:31.776]                       inherits = FALSE)
[16:05:31.776]                   }
[16:05:31.776]                   options(future.plan = NULL)
[16:05:31.776]                   if (is.na(NA_character_)) 
[16:05:31.776]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:31.776]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:31.776]                   future::plan(list(a = function (..., envir = parent.frame()) 
[16:05:31.776]                   {
[16:05:31.776]                     future <- SequentialFuture(..., envir = envir)
[16:05:31.776]                     if (!future$lazy) 
[16:05:31.776]                       future <- run(future)
[16:05:31.776]                     invisible(future)
[16:05:31.776]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:31.776]                     envir = parent.frame()) 
[16:05:31.776]                   {
[16:05:31.776]                     default_workers <- missing(workers)
[16:05:31.776]                     if (is.function(workers)) 
[16:05:31.776]                       workers <- workers()
[16:05:31.776]                     workers <- structure(as.integer(workers), 
[16:05:31.776]                       class = class(workers))
[16:05:31.776]                     stop_if_not(is.finite(workers), workers >= 
[16:05:31.776]                       1L)
[16:05:31.776]                     if ((workers == 1L && !inherits(workers, 
[16:05:31.776]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:31.776]                       if (default_workers) 
[16:05:31.776]                         supportsMulticore(warn = TRUE)
[16:05:31.776]                       return(sequential(..., envir = envir))
[16:05:31.776]                     }
[16:05:31.776]                     oopts <- options(mc.cores = workers)
[16:05:31.776]                     on.exit(options(oopts))
[16:05:31.776]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:31.776]                       envir = envir)
[16:05:31.776]                     if (!future$lazy) 
[16:05:31.776]                       future <- run(future)
[16:05:31.776]                     invisible(future)
[16:05:31.776]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:31.776]                 }
[16:05:31.776]             }
[16:05:31.776]         }
[16:05:31.776]     })
[16:05:31.776]     if (TRUE) {
[16:05:31.776]         base::sink(type = "output", split = FALSE)
[16:05:31.776]         if (TRUE) {
[16:05:31.776]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:31.776]         }
[16:05:31.776]         else {
[16:05:31.776]             ...future.result["stdout"] <- base::list(NULL)
[16:05:31.776]         }
[16:05:31.776]         base::close(...future.stdout)
[16:05:31.776]         ...future.stdout <- NULL
[16:05:31.776]     }
[16:05:31.776]     ...future.result$conditions <- ...future.conditions
[16:05:31.776]     ...future.result$finished <- base::Sys.time()
[16:05:31.776]     ...future.result
[16:05:31.776] }
[16:05:31.778] assign_globals() ...
[16:05:31.778] List of 1
[16:05:31.778]  $ data:'data.frame':	3 obs. of  2 variables:
[16:05:31.778]   ..$ a: int [1:3] 1 2 3
[16:05:31.778]   ..$ b: int [1:3] 3 2 1
[16:05:31.778]  - attr(*, "where")=List of 1
[16:05:31.778]   ..$ data:<environment: R_EmptyEnv> 
[16:05:31.778]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:31.778]  - attr(*, "resolved")= logi FALSE
[16:05:31.778]  - attr(*, "total_size")= num 128
[16:05:31.778]  - attr(*, "already-done")= logi TRUE
[16:05:31.781] - copied ‘data’ to environment
[16:05:31.781] assign_globals() ... done
[16:05:31.782] plan(): Setting new future strategy stack:
[16:05:31.782] List of future strategies:
[16:05:31.782] 1. multicore:
[16:05:31.782]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:31.782]    - tweaked: FALSE
[16:05:31.782]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:31.785] plan(): nbrOfWorkers() = 2
[16:05:31.828] plan(): Setting new future strategy stack:
[16:05:31.828] List of future strategies:
[16:05:31.828] 1. sequential:
[16:05:31.828]    - args: function (..., envir = parent.frame())
[16:05:31.828]    - tweaked: FALSE
[16:05:31.828]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:31.828] 2. multicore:
[16:05:31.828]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:31.828]    - tweaked: FALSE
[16:05:31.828]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:31.829] plan(): nbrOfWorkers() = 1
[16:05:31.829] SequentialFuture started (and completed)
[16:05:31.829] signalConditions() ...
[16:05:31.829]  - include = ‘immediateCondition’
[16:05:31.830]  - exclude = 
[16:05:31.830]  - resignal = FALSE
[16:05:31.830]  - Number of conditions: 55
[16:05:31.830] signalConditions() ... done
[16:05:31.830] - Launch lazy future ... done
[16:05:31.830] run() for ‘SequentialFuture’ ... done
[16:05:31.830] signalConditions() ...
[16:05:31.831]  - include = ‘immediateCondition’
[16:05:31.831]  - exclude = 
[16:05:31.831]  - resignal = FALSE
[16:05:31.831]  - Number of conditions: 55
[16:05:31.831] signalConditions() ... done
[16:05:31.833] Future state: ‘finished’
[16:05:31.833] signalConditions() ...
[16:05:31.834]  - include = ‘condition’
[16:05:31.834]  - exclude = ‘immediateCondition’
[16:05:31.834]  - resignal = TRUE
[16:05:31.834]  - Number of conditions: 55
[16:05:31.834]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.786] getGlobalsAndPackages() ...
[16:05:31.834]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.786] Searching for globals...
[16:05:31.835]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.800] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[16:05:31.835]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.800] Searching for globals ... DONE
[16:05:31.835]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.800] Resolving globals: FALSE
[16:05:31.835]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.801] The total size of the 1 globals is 128 bytes (128 bytes)
[16:05:31.835]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.801] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:05:31.836]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.801] - globals: [1] ‘data’
[16:05:31.836]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.801] 
[16:05:31.836]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.801] getGlobalsAndPackages() ... DONE
[16:05:31.836]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.802] run() for ‘Future’ ...
[16:05:31.836]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.802] - state: ‘created’
[16:05:31.836]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.802] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:31.837]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.805] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:31.837]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.806] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:31.837]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.806]   - Field: ‘label’
[16:05:31.837]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.806]   - Field: ‘local’
[16:05:31.837]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.806]   - Field: ‘owner’
[16:05:31.837]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.806]   - Field: ‘envir’
[16:05:31.838]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.806]   - Field: ‘workers’
[16:05:31.838]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.806]   - Field: ‘packages’
[16:05:31.838]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.806]   - Field: ‘gc’
[16:05:31.838]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.806]   - Field: ‘job’
[16:05:31.838]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.807]   - Field: ‘conditions’
[16:05:31.838]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.807]   - Field: ‘expr’
[16:05:31.839]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.807]   - Field: ‘uuid’
[16:05:31.839]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.807]   - Field: ‘seed’
[16:05:31.839]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.807]   - Field: ‘version’
[16:05:31.839]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.807]   - Field: ‘result’
[16:05:31.839]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.807]   - Field: ‘asynchronous’
[16:05:31.840]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.807]   - Field: ‘calls’
[16:05:31.840]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.807]   - Field: ‘globals’
[16:05:31.840]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.808]   - Field: ‘stdout’
[16:05:31.840]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.808]   - Field: ‘earlySignal’
[16:05:31.840]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.808]   - Field: ‘lazy’
[16:05:31.840]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.808]   - Field: ‘state’
[16:05:31.840]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.808] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:31.841]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.808] - Launch lazy future ...
[16:05:31.841]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.808] Packages needed by the future expression (n = 0): <none>
[16:05:31.841]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.808] Packages needed by future strategies (n = 0): <none>
[16:05:31.841]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.809] {
[16:05:31.809]     {
[16:05:31.809]         {
[16:05:31.809]             ...future.startTime <- base::Sys.time()
[16:05:31.809]             {
[16:05:31.809]                 {
[16:05:31.809]                   {
[16:05:31.809]                     {
[16:05:31.809]                       base::local({
[16:05:31.809]                         has_future <- base::requireNamespace("future", 
[16:05:31.809]                           quietly = TRUE)
[16:05:31.809]                         if (has_future) {
[16:05:31.809]                           ns <- base::getNamespace("future")
[16:05:31.809]                           version <- ns[[".package"]][["version"]]
[16:05:31.809]                           if (is.null(version)) 
[16:05:31.809]                             version <- utils::packageVersion("future")
[16:05:31.809]                         }
[16:05:31.809]                         else {
[16:05:31.809]                           version <- NULL
[16:05:31.809]                         }
[16:05:31.809]                         if (!has_future || version < "1.8.0") {
[16:05:31.809]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:31.809]                             "", base::R.version$version.string), 
[16:05:31.809]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:31.809]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:31.809]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:31.809]                               "release", "version")], collapse = " "), 
[16:05:31.809]                             hostname = base::Sys.info()[["nodename"]])
[16:05:31.809]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:31.809]                             info)
[16:05:31.809]                           info <- base::paste(info, collapse = "; ")
[16:05:31.809]                           if (!has_future) {
[16:05:31.809]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:31.809]                               info)
[16:05:31.809]                           }
[16:05:31.809]                           else {
[16:05:31.809]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:31.809]                               info, version)
[16:05:31.809]                           }
[16:05:31.809]                           base::stop(msg)
[16:05:31.809]                         }
[16:05:31.809]                       })
[16:05:31.809]                     }
[16:05:31.809]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:31.809]                     base::options(mc.cores = 1L)
[16:05:31.809]                   }
[16:05:31.809]                   options(future.plan = NULL)
[16:05:31.809]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:31.809]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:31.809]                 }
[16:05:31.809]                 ...future.workdir <- getwd()
[16:05:31.809]             }
[16:05:31.809]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:31.809]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:31.809]         }
[16:05:31.809]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:31.809]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:31.809]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:31.809]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:31.809]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:31.809]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:31.809]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:31.809]             base::names(...future.oldOptions))
[16:05:31.809]     }
[16:05:31.809]     if (FALSE) {
[16:05:31.809]     }
[16:05:31.809]     else {
[16:05:31.809]         if (TRUE) {
[16:05:31.809]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:31.809]                 open = "w")
[16:05:31.809]         }
[16:05:31.809]         else {
[16:05:31.809]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:31.809]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:31.809]         }
[16:05:31.809]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:31.809]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:31.809]             base::sink(type = "output", split = FALSE)
[16:05:31.809]             base::close(...future.stdout)
[16:05:31.809]         }, add = TRUE)
[16:05:31.809]     }
[16:05:31.809]     ...future.frame <- base::sys.nframe()
[16:05:31.809]     ...future.conditions <- base::list()
[16:05:31.809]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:31.809]     if (FALSE) {
[16:05:31.809]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:31.809]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:31.809]     }
[16:05:31.809]     ...future.result <- base::tryCatch({
[16:05:31.809]         base::withCallingHandlers({
[16:05:31.809]             ...future.value <- base::withVisible(base::local({
[16:05:31.809]                 withCallingHandlers({
[16:05:31.809]                   subset(data, a == 2)
[16:05:31.809]                 }, immediateCondition = function(cond) {
[16:05:31.809]                   save_rds <- function (object, pathname, ...) 
[16:05:31.809]                   {
[16:05:31.809]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:31.809]                     if (file_test("-f", pathname_tmp)) {
[16:05:31.809]                       fi_tmp <- file.info(pathname_tmp)
[16:05:31.809]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:31.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:31.809]                         fi_tmp[["mtime"]])
[16:05:31.809]                     }
[16:05:31.809]                     tryCatch({
[16:05:31.809]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:31.809]                     }, error = function(ex) {
[16:05:31.809]                       msg <- conditionMessage(ex)
[16:05:31.809]                       fi_tmp <- file.info(pathname_tmp)
[16:05:31.809]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:31.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:31.809]                         fi_tmp[["mtime"]], msg)
[16:05:31.809]                       ex$message <- msg
[16:05:31.809]                       stop(ex)
[16:05:31.809]                     })
[16:05:31.809]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:31.809]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:31.809]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:31.809]                       fi_tmp <- file.info(pathname_tmp)
[16:05:31.809]                       fi <- file.info(pathname)
[16:05:31.809]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:31.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:31.809]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:31.809]                         fi[["size"]], fi[["mtime"]])
[16:05:31.809]                       stop(msg)
[16:05:31.809]                     }
[16:05:31.809]                     invisible(pathname)
[16:05:31.809]                   }
[16:05:31.809]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:31.809]                     rootPath = tempdir()) 
[16:05:31.809]                   {
[16:05:31.809]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:31.809]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:31.809]                       tmpdir = path, fileext = ".rds")
[16:05:31.809]                     save_rds(obj, file)
[16:05:31.809]                   }
[16:05:31.809]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0EbAi0/.future/immediateConditions")
[16:05:31.809]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:31.809]                   {
[16:05:31.809]                     inherits <- base::inherits
[16:05:31.809]                     invokeRestart <- base::invokeRestart
[16:05:31.809]                     is.null <- base::is.null
[16:05:31.809]                     muffled <- FALSE
[16:05:31.809]                     if (inherits(cond, "message")) {
[16:05:31.809]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:31.809]                       if (muffled) 
[16:05:31.809]                         invokeRestart("muffleMessage")
[16:05:31.809]                     }
[16:05:31.809]                     else if (inherits(cond, "warning")) {
[16:05:31.809]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:31.809]                       if (muffled) 
[16:05:31.809]                         invokeRestart("muffleWarning")
[16:05:31.809]                     }
[16:05:31.809]                     else if (inherits(cond, "condition")) {
[16:05:31.809]                       if (!is.null(pattern)) {
[16:05:31.809]                         computeRestarts <- base::computeRestarts
[16:05:31.809]                         grepl <- base::grepl
[16:05:31.809]                         restarts <- computeRestarts(cond)
[16:05:31.809]                         for (restart in restarts) {
[16:05:31.809]                           name <- restart$name
[16:05:31.809]                           if (is.null(name)) 
[16:05:31.809]                             next
[16:05:31.809]                           if (!grepl(pattern, name)) 
[16:05:31.809]                             next
[16:05:31.809]                           invokeRestart(restart)
[16:05:31.809]                           muffled <- TRUE
[16:05:31.809]                           break
[16:05:31.809]                         }
[16:05:31.809]                       }
[16:05:31.809]                     }
[16:05:31.809]                     invisible(muffled)
[16:05:31.809]                   }
[16:05:31.809]                   muffleCondition(cond)
[16:05:31.809]                 })
[16:05:31.809]             }))
[16:05:31.809]             future::FutureResult(value = ...future.value$value, 
[16:05:31.809]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:31.809]                   ...future.rng), globalenv = if (FALSE) 
[16:05:31.809]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:31.809]                     ...future.globalenv.names))
[16:05:31.809]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:31.809]         }, condition = base::local({
[16:05:31.809]             c <- base::c
[16:05:31.809]             inherits <- base::inherits
[16:05:31.809]             invokeRestart <- base::invokeRestart
[16:05:31.809]             length <- base::length
[16:05:31.809]             list <- base::list
[16:05:31.809]             seq.int <- base::seq.int
[16:05:31.809]             signalCondition <- base::signalCondition
[16:05:31.809]             sys.calls <- base::sys.calls
[16:05:31.809]             `[[` <- base::`[[`
[16:05:31.809]             `+` <- base::`+`
[16:05:31.809]             `<<-` <- base::`<<-`
[16:05:31.809]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:31.809]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:31.809]                   3L)]
[16:05:31.809]             }
[16:05:31.809]             function(cond) {
[16:05:31.809]                 is_error <- inherits(cond, "error")
[16:05:31.809]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:31.809]                   NULL)
[16:05:31.809]                 if (is_error) {
[16:05:31.809]                   sessionInformation <- function() {
[16:05:31.809]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:31.809]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:31.809]                       search = base::search(), system = base::Sys.info())
[16:05:31.809]                   }
[16:05:31.809]                   ...future.conditions[[length(...future.conditions) + 
[16:05:31.809]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:31.809]                     cond$call), session = sessionInformation(), 
[16:05:31.809]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:31.809]                   signalCondition(cond)
[16:05:31.809]                 }
[16:05:31.809]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:31.809]                 "immediateCondition"))) {
[16:05:31.809]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:31.809]                   ...future.conditions[[length(...future.conditions) + 
[16:05:31.809]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:31.809]                   if (TRUE && !signal) {
[16:05:31.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:31.809]                     {
[16:05:31.809]                       inherits <- base::inherits
[16:05:31.809]                       invokeRestart <- base::invokeRestart
[16:05:31.809]                       is.null <- base::is.null
[16:05:31.809]                       muffled <- FALSE
[16:05:31.809]                       if (inherits(cond, "message")) {
[16:05:31.809]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:31.809]                         if (muffled) 
[16:05:31.809]                           invokeRestart("muffleMessage")
[16:05:31.809]                       }
[16:05:31.809]                       else if (inherits(cond, "warning")) {
[16:05:31.809]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:31.809]                         if (muffled) 
[16:05:31.809]                           invokeRestart("muffleWarning")
[16:05:31.809]                       }
[16:05:31.809]                       else if (inherits(cond, "condition")) {
[16:05:31.809]                         if (!is.null(pattern)) {
[16:05:31.809]                           computeRestarts <- base::computeRestarts
[16:05:31.809]                           grepl <- base::grepl
[16:05:31.809]                           restarts <- computeRestarts(cond)
[16:05:31.809]                           for (restart in restarts) {
[16:05:31.809]                             name <- restart$name
[16:05:31.809]                             if (is.null(name)) 
[16:05:31.809]                               next
[16:05:31.809]                             if (!grepl(pattern, name)) 
[16:05:31.809]                               next
[16:05:31.809]                             invokeRestart(restart)
[16:05:31.809]                             muffled <- TRUE
[16:05:31.809]                             break
[16:05:31.809]                           }
[16:05:31.809]                         }
[16:05:31.809]                       }
[16:05:31.809]                       invisible(muffled)
[16:05:31.809]                     }
[16:05:31.809]                     muffleCondition(cond, pattern = "^muffle")
[16:05:31.809]                   }
[16:05:31.809]                 }
[16:05:31.809]                 else {
[16:05:31.809]                   if (TRUE) {
[16:05:31.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:31.809]                     {
[16:05:31.809]                       inherits <- base::inherits
[16:05:31.809]                       invokeRestart <- base::invokeRestart
[16:05:31.809]                       is.null <- base::is.null
[16:05:31.809]                       muffled <- FALSE
[16:05:31.809]                       if (inherits(cond, "message")) {
[16:05:31.809]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:31.809]                         if (muffled) 
[16:05:31.809]                           invokeRestart("muffleMessage")
[16:05:31.809]                       }
[16:05:31.809]                       else if (inherits(cond, "warning")) {
[16:05:31.809]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:31.809]                         if (muffled) 
[16:05:31.809]                           invokeRestart("muffleWarning")
[16:05:31.809]                       }
[16:05:31.809]                       else if (inherits(cond, "condition")) {
[16:05:31.809]                         if (!is.null(pattern)) {
[16:05:31.809]                           computeRestarts <- base::computeRestarts
[16:05:31.809]                           grepl <- base::grepl
[16:05:31.809]                           restarts <- computeRestarts(cond)
[16:05:31.809]                           for (restart in restarts) {
[16:05:31.809]                             name <- restart$name
[16:05:31.809]                             if (is.null(name)) 
[16:05:31.809]                               next
[16:05:31.809]                             if (!grepl(pattern, name)) 
[16:05:31.809]                               next
[16:05:31.809]                             invokeRestart(restart)
[16:05:31.809]                             muffled <- TRUE
[16:05:31.809]                             break
[16:05:31.809]                           }
[16:05:31.809]                         }
[16:05:31.809]                       }
[16:05:31.809]                       invisible(muffled)
[16:05:31.809]                     }
[16:05:31.809]                     muffleCondition(cond, pattern = "^muffle")
[16:05:31.809]                   }
[16:05:31.809]                 }
[16:05:31.809]             }
[16:05:31.809]         }))
[16:05:31.809]     }, error = function(ex) {
[16:05:31.809]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:31.809]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:31.809]                 ...future.rng), started = ...future.startTime, 
[16:05:31.809]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:31.809]             version = "1.8"), class = "FutureResult")
[16:05:31.809]     }, finally = {
[16:05:31.809]         if (!identical(...future.workdir, getwd())) 
[16:05:31.809]             setwd(...future.workdir)
[16:05:31.809]         {
[16:05:31.809]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:31.809]                 ...future.oldOptions$nwarnings <- NULL
[16:05:31.809]             }
[16:05:31.809]             base::options(...future.oldOptions)
[16:05:31.809]             if (.Platform$OS.type == "windows") {
[16:05:31.809]                 old_names <- names(...future.oldEnvVars)
[16:05:31.809]                 envs <- base::Sys.getenv()
[16:05:31.809]                 names <- names(envs)
[16:05:31.809]                 common <- intersect(names, old_names)
[16:05:31.809]                 added <- setdiff(names, old_names)
[16:05:31.809]                 removed <- setdiff(old_names, names)
[16:05:31.809]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:31.809]                   envs[common]]
[16:05:31.809]                 NAMES <- toupper(changed)
[16:05:31.809]                 args <- list()
[16:05:31.809]                 for (kk in seq_along(NAMES)) {
[16:05:31.809]                   name <- changed[[kk]]
[16:05:31.809]                   NAME <- NAMES[[kk]]
[16:05:31.809]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.809]                     next
[16:05:31.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:31.809]                 }
[16:05:31.809]                 NAMES <- toupper(added)
[16:05:31.809]                 for (kk in seq_along(NAMES)) {
[16:05:31.809]                   name <- added[[kk]]
[16:05:31.809]                   NAME <- NAMES[[kk]]
[16:05:31.809]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.809]                     next
[16:05:31.809]                   args[[name]] <- ""
[16:05:31.809]                 }
[16:05:31.809]                 NAMES <- toupper(removed)
[16:05:31.809]                 for (kk in seq_along(NAMES)) {
[16:05:31.809]                   name <- removed[[kk]]
[16:05:31.809]                   NAME <- NAMES[[kk]]
[16:05:31.809]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.809]                     next
[16:05:31.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:31.809]                 }
[16:05:31.809]                 if (length(args) > 0) 
[16:05:31.809]                   base::do.call(base::Sys.setenv, args = args)
[16:05:31.809]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:31.809]             }
[16:05:31.809]             else {
[16:05:31.809]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:31.809]             }
[16:05:31.809]             {
[16:05:31.809]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:31.809]                   0L) {
[16:05:31.809]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:31.809]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:31.809]                   base::options(opts)
[16:05:31.809]                 }
[16:05:31.809]                 {
[16:05:31.809]                   {
[16:05:31.809]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:31.809]                     NULL
[16:05:31.809]                   }
[16:05:31.809]                   options(future.plan = NULL)
[16:05:31.809]                   if (is.na(NA_character_)) 
[16:05:31.809]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:31.809]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:31.809]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:31.809]                     envir = parent.frame()) 
[16:05:31.809]                   {
[16:05:31.809]                     default_workers <- missing(workers)
[16:05:31.809]                     if (is.function(workers)) 
[16:05:31.809]                       workers <- workers()
[16:05:31.809]                     workers <- structure(as.integer(workers), 
[16:05:31.809]                       class = class(workers))
[16:05:31.809]                     stop_if_not(is.finite(workers), workers >= 
[16:05:31.809]                       1L)
[16:05:31.809]                     if ((workers == 1L && !inherits(workers, 
[16:05:31.809]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:31.809]                       if (default_workers) 
[16:05:31.809]                         supportsMulticore(warn = TRUE)
[16:05:31.809]                       return(sequential(..., envir = envir))
[16:05:31.809]                     }
[16:05:31.809]                     oopts <- options(mc.cores = workers)
[16:05:31.809]                     on.exit(options(oopts))
[16:05:31.809]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:31.809]                       envir = envir)
[16:05:31.809]                     if (!future$lazy) 
[16:05:31.809]                       future <- run(future)
[16:05:31.809]                     invisible(future)
[16:05:31.809]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:31.809]                 }
[16:05:31.809]             }
[16:05:31.809]         }
[16:05:31.809]     })
[16:05:31.809]     if (TRUE) {
[16:05:31.809]         base::sink(type = "output", split = FALSE)
[16:05:31.809]         if (TRUE) {
[16:05:31.809]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:31.809]         }
[16:05:31.809]         else {
[16:05:31.809]             ...future.result["stdout"] <- base::list(NULL)
[16:05:31.809]         }
[16:05:31.809]         base::close(...future.stdout)
[16:05:31.809]         ...future.stdout <- NULL
[16:05:31.809]     }
[16:05:31.809]     ...future.result$conditions <- ...future.conditions
[16:05:31.809]     ...future.result$finished <- base::Sys.time()
[16:05:31.809]     ...future.result
[16:05:31.809] }
[16:05:31.841]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.811] assign_globals() ...
[16:05:31.841]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.811] List of 1
[16:05:31.811]  $ data:'data.frame':	3 obs. of  2 variables:
[16:05:31.811]   ..$ a: int [1:3] 1 2 3
[16:05:31.811]   ..$ b: int [1:3] 3 2 1
[16:05:31.811]  - attr(*, "where")=List of 1
[16:05:31.811]   ..$ data:<environment: R_EmptyEnv> 
[16:05:31.811]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:31.811]  - attr(*, "resolved")= logi FALSE
[16:05:31.811]  - attr(*, "total_size")= num 128
[16:05:31.811]  - attr(*, "already-done")= logi TRUE
[16:05:31.842]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.814] - copied ‘data’ to environment
[16:05:31.842]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.814] assign_globals() ... done
[16:05:31.842]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.814] requestCore(): workers = 2
[16:05:31.842]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.816] MulticoreFuture started
[16:05:31.842]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.817] - Launch lazy future ... done
[16:05:31.842]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.817] run() for ‘MulticoreFuture’ ... done
[16:05:31.843]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.817] result() for MulticoreFuture ...
[16:05:31.843]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.826] result() for MulticoreFuture ...
[16:05:31.843]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.826] result() for MulticoreFuture ... done
[16:05:31.843]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.827] result() for MulticoreFuture ... done
[16:05:31.843]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.827] result() for MulticoreFuture ...
[16:05:31.843]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.827] result() for MulticoreFuture ... done
[16:05:31.843] signalConditions() ... done
- plan(list('sequential', 'multicore')) ... DONE
- plan(list('sequential', 'multisession')) ...
[16:05:31.844] plan(): Setting new future strategy stack:
[16:05:31.844] List of future strategies:
[16:05:31.844] 1. sequential:
[16:05:31.844]    - args: function (..., envir = parent.frame())
[16:05:31.844]    - tweaked: FALSE
[16:05:31.844]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:31.844] 2. multisession:
[16:05:31.844]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:31.844]    - tweaked: FALSE
[16:05:31.844]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:31.845] plan(): nbrOfWorkers() = 1
[16:05:31.845] getGlobalsAndPackages() ...
[16:05:31.845] Searching for globals...
[16:05:31.863] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:05:31.863] Searching for globals ... DONE
[16:05:31.863] Resolving globals: FALSE
[16:05:31.864] The total size of the 2 globals is 55.41 KiB (56736 bytes)
[16:05:31.864] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 55.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (55.29 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:05:31.865] - globals: [2] ‘nested’, ‘strategy2’
[16:05:31.865] - packages: [1] ‘future’
[16:05:31.865] getGlobalsAndPackages() ... DONE
[16:05:31.865] run() for ‘Future’ ...
[16:05:31.865] - state: ‘created’
[16:05:31.865] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:31.866] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:31.866] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:31.866]   - Field: ‘label’
[16:05:31.866]   - Field: ‘local’
[16:05:31.866]   - Field: ‘owner’
[16:05:31.866]   - Field: ‘envir’
[16:05:31.866]   - Field: ‘packages’
[16:05:31.866]   - Field: ‘gc’
[16:05:31.866]   - Field: ‘conditions’
[16:05:31.866]   - Field: ‘expr’
[16:05:31.867]   - Field: ‘uuid’
[16:05:31.867]   - Field: ‘seed’
[16:05:31.867]   - Field: ‘version’
[16:05:31.867]   - Field: ‘result’
[16:05:31.867]   - Field: ‘asynchronous’
[16:05:31.867]   - Field: ‘calls’
[16:05:31.867]   - Field: ‘globals’
[16:05:31.867]   - Field: ‘stdout’
[16:05:31.867]   - Field: ‘earlySignal’
[16:05:31.867]   - Field: ‘lazy’
[16:05:31.868]   - Field: ‘state’
[16:05:31.868] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:31.868] - Launch lazy future ...
[16:05:31.868] Packages needed by the future expression (n = 1): ‘future’
[16:05:31.868] Packages needed by future strategies (n = 1): ‘future’
[16:05:31.869] {
[16:05:31.869]     {
[16:05:31.869]         {
[16:05:31.869]             ...future.startTime <- base::Sys.time()
[16:05:31.869]             {
[16:05:31.869]                 {
[16:05:31.869]                   {
[16:05:31.869]                     {
[16:05:31.869]                       base::local({
[16:05:31.869]                         has_future <- base::requireNamespace("future", 
[16:05:31.869]                           quietly = TRUE)
[16:05:31.869]                         if (has_future) {
[16:05:31.869]                           ns <- base::getNamespace("future")
[16:05:31.869]                           version <- ns[[".package"]][["version"]]
[16:05:31.869]                           if (is.null(version)) 
[16:05:31.869]                             version <- utils::packageVersion("future")
[16:05:31.869]                         }
[16:05:31.869]                         else {
[16:05:31.869]                           version <- NULL
[16:05:31.869]                         }
[16:05:31.869]                         if (!has_future || version < "1.8.0") {
[16:05:31.869]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:31.869]                             "", base::R.version$version.string), 
[16:05:31.869]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:31.869]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:31.869]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:31.869]                               "release", "version")], collapse = " "), 
[16:05:31.869]                             hostname = base::Sys.info()[["nodename"]])
[16:05:31.869]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:31.869]                             info)
[16:05:31.869]                           info <- base::paste(info, collapse = "; ")
[16:05:31.869]                           if (!has_future) {
[16:05:31.869]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:31.869]                               info)
[16:05:31.869]                           }
[16:05:31.869]                           else {
[16:05:31.869]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:31.869]                               info, version)
[16:05:31.869]                           }
[16:05:31.869]                           base::stop(msg)
[16:05:31.869]                         }
[16:05:31.869]                       })
[16:05:31.869]                     }
[16:05:31.869]                     base::local({
[16:05:31.869]                       for (pkg in "future") {
[16:05:31.869]                         base::loadNamespace(pkg)
[16:05:31.869]                         base::library(pkg, character.only = TRUE)
[16:05:31.869]                       }
[16:05:31.869]                     })
[16:05:31.869]                   }
[16:05:31.869]                   options(future.plan = NULL)
[16:05:31.869]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:31.869]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:05:31.869]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:31.869]                     envir = parent.frame()) 
[16:05:31.869]                   {
[16:05:31.869]                     if (is.function(workers)) 
[16:05:31.869]                       workers <- workers()
[16:05:31.869]                     workers <- structure(as.integer(workers), 
[16:05:31.869]                       class = class(workers))
[16:05:31.869]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:31.869]                       workers >= 1)
[16:05:31.869]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:31.869]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:31.869]                     }
[16:05:31.869]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:31.869]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:31.869]                       envir = envir)
[16:05:31.869]                     if (!future$lazy) 
[16:05:31.869]                       future <- run(future)
[16:05:31.869]                     invisible(future)
[16:05:31.869]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:31.869]                 }
[16:05:31.869]                 ...future.workdir <- getwd()
[16:05:31.869]             }
[16:05:31.869]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:31.869]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:31.869]         }
[16:05:31.869]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:31.869]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:31.869]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:31.869]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:31.869]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:31.869]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:31.869]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:31.869]             base::names(...future.oldOptions))
[16:05:31.869]     }
[16:05:31.869]     if (FALSE) {
[16:05:31.869]     }
[16:05:31.869]     else {
[16:05:31.869]         if (TRUE) {
[16:05:31.869]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:31.869]                 open = "w")
[16:05:31.869]         }
[16:05:31.869]         else {
[16:05:31.869]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:31.869]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:31.869]         }
[16:05:31.869]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:31.869]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:31.869]             base::sink(type = "output", split = FALSE)
[16:05:31.869]             base::close(...future.stdout)
[16:05:31.869]         }, add = TRUE)
[16:05:31.869]     }
[16:05:31.869]     ...future.frame <- base::sys.nframe()
[16:05:31.869]     ...future.conditions <- base::list()
[16:05:31.869]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:31.869]     if (FALSE) {
[16:05:31.869]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:31.869]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:31.869]     }
[16:05:31.869]     ...future.result <- base::tryCatch({
[16:05:31.869]         base::withCallingHandlers({
[16:05:31.869]             ...future.value <- base::withVisible(base::local({
[16:05:31.869]                 a <- 1L
[16:05:31.869]                 plan_a <- unclass(future::plan("list"))
[16:05:31.869]                 nested_a <- nested[-1]
[16:05:31.869]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:05:31.869]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:05:31.869]                   strategy2))
[16:05:31.869]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:05:31.869]                   "init") <- NULL
[16:05:31.869]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:05:31.869]                   "init") <- NULL
[16:05:31.869]                 stopifnot(all.equal(plan_a, nested_a))
[16:05:31.869]                 y %<-% {
[16:05:31.869]                   b <- 2L
[16:05:31.869]                   plan_b <- future::plan("list")
[16:05:31.869]                   nested_b <- nested_a[-1]
[16:05:31.869]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:05:31.869]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:05:31.869]                     "sequential"))
[16:05:31.869]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:05:31.869]                     b = b, nested_b = nested_b, plan_b = plan_b)
[16:05:31.869]                 }
[16:05:31.869]                 y
[16:05:31.869]             }))
[16:05:31.869]             future::FutureResult(value = ...future.value$value, 
[16:05:31.869]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:31.869]                   ...future.rng), globalenv = if (FALSE) 
[16:05:31.869]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:31.869]                     ...future.globalenv.names))
[16:05:31.869]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:31.869]         }, condition = base::local({
[16:05:31.869]             c <- base::c
[16:05:31.869]             inherits <- base::inherits
[16:05:31.869]             invokeRestart <- base::invokeRestart
[16:05:31.869]             length <- base::length
[16:05:31.869]             list <- base::list
[16:05:31.869]             seq.int <- base::seq.int
[16:05:31.869]             signalCondition <- base::signalCondition
[16:05:31.869]             sys.calls <- base::sys.calls
[16:05:31.869]             `[[` <- base::`[[`
[16:05:31.869]             `+` <- base::`+`
[16:05:31.869]             `<<-` <- base::`<<-`
[16:05:31.869]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:31.869]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:31.869]                   3L)]
[16:05:31.869]             }
[16:05:31.869]             function(cond) {
[16:05:31.869]                 is_error <- inherits(cond, "error")
[16:05:31.869]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:31.869]                   NULL)
[16:05:31.869]                 if (is_error) {
[16:05:31.869]                   sessionInformation <- function() {
[16:05:31.869]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:31.869]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:31.869]                       search = base::search(), system = base::Sys.info())
[16:05:31.869]                   }
[16:05:31.869]                   ...future.conditions[[length(...future.conditions) + 
[16:05:31.869]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:31.869]                     cond$call), session = sessionInformation(), 
[16:05:31.869]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:31.869]                   signalCondition(cond)
[16:05:31.869]                 }
[16:05:31.869]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:31.869]                 "immediateCondition"))) {
[16:05:31.869]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:31.869]                   ...future.conditions[[length(...future.conditions) + 
[16:05:31.869]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:31.869]                   if (TRUE && !signal) {
[16:05:31.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:31.869]                     {
[16:05:31.869]                       inherits <- base::inherits
[16:05:31.869]                       invokeRestart <- base::invokeRestart
[16:05:31.869]                       is.null <- base::is.null
[16:05:31.869]                       muffled <- FALSE
[16:05:31.869]                       if (inherits(cond, "message")) {
[16:05:31.869]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:31.869]                         if (muffled) 
[16:05:31.869]                           invokeRestart("muffleMessage")
[16:05:31.869]                       }
[16:05:31.869]                       else if (inherits(cond, "warning")) {
[16:05:31.869]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:31.869]                         if (muffled) 
[16:05:31.869]                           invokeRestart("muffleWarning")
[16:05:31.869]                       }
[16:05:31.869]                       else if (inherits(cond, "condition")) {
[16:05:31.869]                         if (!is.null(pattern)) {
[16:05:31.869]                           computeRestarts <- base::computeRestarts
[16:05:31.869]                           grepl <- base::grepl
[16:05:31.869]                           restarts <- computeRestarts(cond)
[16:05:31.869]                           for (restart in restarts) {
[16:05:31.869]                             name <- restart$name
[16:05:31.869]                             if (is.null(name)) 
[16:05:31.869]                               next
[16:05:31.869]                             if (!grepl(pattern, name)) 
[16:05:31.869]                               next
[16:05:31.869]                             invokeRestart(restart)
[16:05:31.869]                             muffled <- TRUE
[16:05:31.869]                             break
[16:05:31.869]                           }
[16:05:31.869]                         }
[16:05:31.869]                       }
[16:05:31.869]                       invisible(muffled)
[16:05:31.869]                     }
[16:05:31.869]                     muffleCondition(cond, pattern = "^muffle")
[16:05:31.869]                   }
[16:05:31.869]                 }
[16:05:31.869]                 else {
[16:05:31.869]                   if (TRUE) {
[16:05:31.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:31.869]                     {
[16:05:31.869]                       inherits <- base::inherits
[16:05:31.869]                       invokeRestart <- base::invokeRestart
[16:05:31.869]                       is.null <- base::is.null
[16:05:31.869]                       muffled <- FALSE
[16:05:31.869]                       if (inherits(cond, "message")) {
[16:05:31.869]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:31.869]                         if (muffled) 
[16:05:31.869]                           invokeRestart("muffleMessage")
[16:05:31.869]                       }
[16:05:31.869]                       else if (inherits(cond, "warning")) {
[16:05:31.869]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:31.869]                         if (muffled) 
[16:05:31.869]                           invokeRestart("muffleWarning")
[16:05:31.869]                       }
[16:05:31.869]                       else if (inherits(cond, "condition")) {
[16:05:31.869]                         if (!is.null(pattern)) {
[16:05:31.869]                           computeRestarts <- base::computeRestarts
[16:05:31.869]                           grepl <- base::grepl
[16:05:31.869]                           restarts <- computeRestarts(cond)
[16:05:31.869]                           for (restart in restarts) {
[16:05:31.869]                             name <- restart$name
[16:05:31.869]                             if (is.null(name)) 
[16:05:31.869]                               next
[16:05:31.869]                             if (!grepl(pattern, name)) 
[16:05:31.869]                               next
[16:05:31.869]                             invokeRestart(restart)
[16:05:31.869]                             muffled <- TRUE
[16:05:31.869]                             break
[16:05:31.869]                           }
[16:05:31.869]                         }
[16:05:31.869]                       }
[16:05:31.869]                       invisible(muffled)
[16:05:31.869]                     }
[16:05:31.869]                     muffleCondition(cond, pattern = "^muffle")
[16:05:31.869]                   }
[16:05:31.869]                 }
[16:05:31.869]             }
[16:05:31.869]         }))
[16:05:31.869]     }, error = function(ex) {
[16:05:31.869]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:31.869]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:31.869]                 ...future.rng), started = ...future.startTime, 
[16:05:31.869]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:31.869]             version = "1.8"), class = "FutureResult")
[16:05:31.869]     }, finally = {
[16:05:31.869]         if (!identical(...future.workdir, getwd())) 
[16:05:31.869]             setwd(...future.workdir)
[16:05:31.869]         {
[16:05:31.869]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:31.869]                 ...future.oldOptions$nwarnings <- NULL
[16:05:31.869]             }
[16:05:31.869]             base::options(...future.oldOptions)
[16:05:31.869]             if (.Platform$OS.type == "windows") {
[16:05:31.869]                 old_names <- names(...future.oldEnvVars)
[16:05:31.869]                 envs <- base::Sys.getenv()
[16:05:31.869]                 names <- names(envs)
[16:05:31.869]                 common <- intersect(names, old_names)
[16:05:31.869]                 added <- setdiff(names, old_names)
[16:05:31.869]                 removed <- setdiff(old_names, names)
[16:05:31.869]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:31.869]                   envs[common]]
[16:05:31.869]                 NAMES <- toupper(changed)
[16:05:31.869]                 args <- list()
[16:05:31.869]                 for (kk in seq_along(NAMES)) {
[16:05:31.869]                   name <- changed[[kk]]
[16:05:31.869]                   NAME <- NAMES[[kk]]
[16:05:31.869]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.869]                     next
[16:05:31.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:31.869]                 }
[16:05:31.869]                 NAMES <- toupper(added)
[16:05:31.869]                 for (kk in seq_along(NAMES)) {
[16:05:31.869]                   name <- added[[kk]]
[16:05:31.869]                   NAME <- NAMES[[kk]]
[16:05:31.869]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.869]                     next
[16:05:31.869]                   args[[name]] <- ""
[16:05:31.869]                 }
[16:05:31.869]                 NAMES <- toupper(removed)
[16:05:31.869]                 for (kk in seq_along(NAMES)) {
[16:05:31.869]                   name <- removed[[kk]]
[16:05:31.869]                   NAME <- NAMES[[kk]]
[16:05:31.869]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:31.869]                     next
[16:05:31.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:31.869]                 }
[16:05:31.869]                 if (length(args) > 0) 
[16:05:31.869]                   base::do.call(base::Sys.setenv, args = args)
[16:05:31.869]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:31.869]             }
[16:05:31.869]             else {
[16:05:31.869]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:31.869]             }
[16:05:31.869]             {
[16:05:31.869]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:31.869]                   0L) {
[16:05:31.869]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:31.869]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:31.869]                   base::options(opts)
[16:05:31.869]                 }
[16:05:31.869]                 {
[16:05:31.869]                   {
[16:05:31.869]                     NULL
[16:05:31.869]                     RNGkind("Mersenne-Twister")
[16:05:31.869]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:31.869]                       inherits = FALSE)
[16:05:31.869]                   }
[16:05:31.869]                   options(future.plan = NULL)
[16:05:31.869]                   if (is.na(NA_character_)) 
[16:05:31.869]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:31.869]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:31.869]                   future::plan(list(a = function (..., envir = parent.frame()) 
[16:05:31.869]                   {
[16:05:31.869]                     future <- SequentialFuture(..., envir = envir)
[16:05:31.869]                     if (!future$lazy) 
[16:05:31.869]                       future <- run(future)
[16:05:31.869]                     invisible(future)
[16:05:31.869]                   }, b = function (..., workers = availableCores(), 
[16:05:31.869]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:31.869]                     envir = parent.frame()) 
[16:05:31.869]                   {
[16:05:31.869]                     if (is.function(workers)) 
[16:05:31.869]                       workers <- workers()
[16:05:31.869]                     workers <- structure(as.integer(workers), 
[16:05:31.869]                       class = class(workers))
[16:05:31.869]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:31.869]                       workers >= 1)
[16:05:31.869]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:31.869]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:31.869]                     }
[16:05:31.869]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:31.869]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:31.869]                       envir = envir)
[16:05:31.869]                     if (!future$lazy) 
[16:05:31.869]                       future <- run(future)
[16:05:31.869]                     invisible(future)
[16:05:31.869]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:31.869]                 }
[16:05:31.869]             }
[16:05:31.869]         }
[16:05:31.869]     })
[16:05:31.869]     if (TRUE) {
[16:05:31.869]         base::sink(type = "output", split = FALSE)
[16:05:31.869]         if (TRUE) {
[16:05:31.869]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:31.869]         }
[16:05:31.869]         else {
[16:05:31.869]             ...future.result["stdout"] <- base::list(NULL)
[16:05:31.869]         }
[16:05:31.869]         base::close(...future.stdout)
[16:05:31.869]         ...future.stdout <- NULL
[16:05:31.869]     }
[16:05:31.869]     ...future.result$conditions <- ...future.conditions
[16:05:31.869]     ...future.result$finished <- base::Sys.time()
[16:05:31.869]     ...future.result
[16:05:31.869] }
[16:05:31.871] assign_globals() ...
[16:05:31.871] List of 2
[16:05:31.871]  $ nested   :List of 2
[16:05:31.871]   ..$ a:function (..., envir = parent.frame())  
[16:05:31.871]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:05:31.871]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:05:31.871]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:31.871]     envir = parent.frame())  
[16:05:31.871]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[16:05:31.871]   .. ..- attr(*, "init")= logi TRUE
[16:05:31.871]   .. ..- attr(*, "untweakable")= chr "persistent"
[16:05:31.871]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:05:31.871]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:05:31.871]  $ strategy2: chr "multisession"
[16:05:31.871]  - attr(*, "where")=List of 2
[16:05:31.871]   ..$ nested   :<environment: R_EmptyEnv> 
[16:05:31.871]   ..$ strategy2:<environment: R_EmptyEnv> 
[16:05:31.871]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:31.871]  - attr(*, "resolved")= logi FALSE
[16:05:31.871]  - attr(*, "total_size")= num 56736
[16:05:31.871]  - attr(*, "already-done")= logi TRUE
[16:05:31.877] - copied ‘nested’ to environment
[16:05:31.877] - copied ‘strategy2’ to environment
[16:05:31.877] assign_globals() ... done
[16:05:31.878] plan(): Setting new future strategy stack:
[16:05:31.878] List of future strategies:
[16:05:31.878] 1. multisession:
[16:05:31.878]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:31.878]    - tweaked: FALSE
[16:05:31.878]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:31.881] plan(): nbrOfWorkers() = 2
[16:05:32.620] plan(): Setting new future strategy stack:
[16:05:32.620] List of future strategies:
[16:05:32.620] 1. sequential:
[16:05:32.620]    - args: function (..., envir = parent.frame())
[16:05:32.620]    - tweaked: FALSE
[16:05:32.620]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:32.620] 2. multisession:
[16:05:32.620]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:32.620]    - tweaked: FALSE
[16:05:32.620]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:32.621] plan(): nbrOfWorkers() = 1
[16:05:32.621] SequentialFuture started (and completed)
[16:05:32.621] signalConditions() ...
[16:05:32.621]  - include = ‘immediateCondition’
[16:05:32.622]  - exclude = 
[16:05:32.622]  - resignal = FALSE
[16:05:32.622]  - Number of conditions: 98
[16:05:32.622] signalConditions() ... done
[16:05:32.622] - Launch lazy future ... done
[16:05:32.622] run() for ‘SequentialFuture’ ... done
[16:05:32.623] signalConditions() ...
[16:05:32.623]  - include = ‘immediateCondition’
[16:05:32.623]  - exclude = 
[16:05:32.623]  - resignal = FALSE
[16:05:32.623]  - Number of conditions: 98
[16:05:32.623] signalConditions() ... done
[16:05:32.623] Future state: ‘finished’
[16:05:32.624] signalConditions() ...
[16:05:32.624]  - include = ‘condition’
[16:05:32.624]  - exclude = ‘immediateCondition’
[16:05:32.624]  - resignal = TRUE
[16:05:32.624]  - Number of conditions: 98
[16:05:32.624]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.882] getGlobalsAndPackages() ...
[16:05:32.624]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.882] Searching for globals...
[16:05:32.624]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.900] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[16:05:32.625]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.900] Searching for globals ... DONE
[16:05:32.625]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.900] Resolving globals: FALSE
[16:05:32.625]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.901] The total size of the 3 globals is 87.82 KiB (89928 bytes)
[16:05:32.625]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.901] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 87.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (43.88 KiB of class ‘list’), ‘plan_a’ (43.88 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[16:05:32.625]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.901] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[16:05:32.625]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.902] 
[16:05:32.626]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.902] getGlobalsAndPackages() ... DONE
[16:05:32.626]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.902] run() for ‘Future’ ...
[16:05:32.626]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.902] - state: ‘created’
[16:05:32.626]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.902] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:32.626]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.908] [local output] makeClusterPSOCK() ...
[16:05:32.626]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.961] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:05:32.627]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.962] [local output] Base port: 11128
[16:05:32.627]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.962] [local output] Getting setup options for 2 cluster nodes ...
[16:05:32.627]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.962] [local output]  - Node 1 of 2 ...
[16:05:32.627]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.963] [local output] localMachine=TRUE => revtunnel=FALSE

[16:05:32.627]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:31.964] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp0EbAi0/worker.rank=1.parallelly.parent=88964.15b844c45e5c0.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp0EbAi0/worker.rank=1.parallelly.parent=88964.15b844c45e5c0.pid")'’
[16:05:32.628]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.148] - Possible to infer worker's PID: TRUE
[16:05:32.628]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.149] [local output] Rscript port: 11128

[16:05:32.628]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.149] [local output]  - Node 2 of 2 ...
[16:05:32.628]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.150] [local output] localMachine=TRUE => revtunnel=FALSE

[16:05:32.628]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.150] [local output] Rscript port: 11128

[16:05:32.628]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.150] [local output] Getting setup options for 2 cluster nodes ... done
[16:05:32.629]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.151] [local output]  - Parallel setup requested for some PSOCK nodes
[16:05:32.629]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.151] [local output] Setting up PSOCK nodes in parallel
[16:05:32.629]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.151] List of 36
[16:05:32.151]  $ worker          : chr "localhost"
[16:05:32.151]   ..- attr(*, "localhost")= logi TRUE
[16:05:32.151]  $ master          : chr "localhost"
[16:05:32.151]  $ port            : int 11128
[16:05:32.151]  $ connectTimeout  : num 120
[16:05:32.151]  $ timeout         : num 2592000
[16:05:32.151]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:05:32.151]  $ homogeneous     : logi TRUE
[16:05:32.151]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:05:32.151]  $ rscript_envs    : NULL
[16:05:32.151]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:05:32.151]  $ rscript_startup : NULL
[16:05:32.151]  $ rscript_sh      : chr "sh"
[16:05:32.151]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:05:32.151]  $ methods         : logi TRUE
[16:05:32.151]  $ socketOptions   : chr "no-delay"
[16:05:32.151]  $ useXDR          : logi FALSE
[16:05:32.151]  $ outfile         : chr "/dev/null"
[16:05:32.151]  $ renice          : int NA
[16:05:32.151]  $ rshcmd          : NULL
[16:05:32.151]  $ user            : chr(0) 
[16:05:32.151]  $ revtunnel       : logi FALSE
[16:05:32.151]  $ rshlogfile      : NULL
[16:05:32.151]  $ rshopts         : chr(0) 
[16:05:32.151]  $ rank            : int 1
[16:05:32.151]  $ manual          : logi FALSE
[16:05:32.151]  $ dryrun          : logi FALSE
[16:05:32.151]  $ quiet           : logi FALSE
[16:05:32.151]  $ setup_strategy  : chr "parallel"
[16:05:32.151]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:05:32.151]  $ pidfile         : chr "/tmp/Rtmp0EbAi0/worker.rank=1.parallelly.parent=88964.15b844c45e5c0.pid"
[16:05:32.151]  $ rshcmd_label    : NULL
[16:05:32.151]  $ rsh_call        : NULL
[16:05:32.151]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:05:32.151]  $ localMachine    : logi TRUE
[16:05:32.151]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:05:32.151]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:05:32.151]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:05:32.151]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:05:32.151]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:05:32.151]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:05:32.151]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:05:32.151]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:05:32.151]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:05:32.151]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:05:32.151]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:05:32.151]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:05:32.151]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:05:32.151]  $ arguments       :List of 28
[16:05:32.151]   ..$ worker          : chr "localhost"
[16:05:32.151]   ..$ master          : NULL
[16:05:32.151]   ..$ port            : int 11128
[16:05:32.151]   ..$ connectTimeout  : num 120
[16:05:32.151]   ..$ timeout         : num 2592000
[16:05:32.151]   ..$ rscript         : NULL
[16:05:32.151]   ..$ homogeneous     : NULL
[16:05:32.151]   ..$ rscript_args    : NULL
[16:05:32.151]   ..$ rscript_envs    : NULL
[16:05:32.151]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:05:32.151]   ..$ rscript_startup : NULL
[16:05:32.151]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:05:32.151]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:05:32.151]   ..$ methods         : logi TRUE
[16:05:32.151]   ..$ socketOptions   : chr "no-delay"
[16:05:32.151]   ..$ useXDR          : logi FALSE
[16:05:32.151]   ..$ outfile         : chr "/dev/null"
[16:05:32.151]   ..$ renice          : int NA
[16:05:32.151]   ..$ rshcmd          : NULL
[16:05:32.151]   ..$ user            : NULL
[16:05:32.151]   ..$ revtunnel       : logi NA
[16:05:32.151]   ..$ rshlogfile      : NULL
[16:05:32.151]   ..$ rshopts         : NULL
[16:05:32.151]   ..$ rank            : int 1
[16:05:32.151]   ..$ manual          : logi FALSE
[16:05:32.151]   ..$ dryrun          : logi FALSE
[16:05:32.151]   ..$ quiet           : logi FALSE
[16:05:32.151]   ..$ setup_strategy  : chr "parallel"
[16:05:32.151]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:05:32.629]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.168] [local output] System call to launch all workers:
[16:05:32.629]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.169] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp0EbAi0/worker.rank=1.parallelly.parent=88964.15b844c45e5c0.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11128 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:05:32.629]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.169] [local output] Starting PSOCK main server
[16:05:32.630]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.174] [local output] Workers launched
[16:05:32.630]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.174] [local output] Waiting for workers to connect back
[16:05:32.630]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.174]  - [local output] 0 workers out of 2 ready
[16:05:32.630]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.415]  - [local output] 0 workers out of 2 ready
[16:05:32.630]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.415]  - [local output] 1 workers out of 2 ready
[16:05:32.630]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.419]  - [local output] 1 workers out of 2 ready
[16:05:32.631]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.419]  - [local output] 2 workers out of 2 ready
[16:05:32.631]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.419] [local output] Launching of workers completed
[16:05:32.631]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.419] [local output] Collecting session information from workers
[16:05:32.631]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.420] [local output]  - Worker #1 of 2
[16:05:32.631]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.421] [local output]  - Worker #2 of 2
[16:05:32.631]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.421] [local output] makeClusterPSOCK() ... done
[16:05:32.632]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.432] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:32.632]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.432] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:32.632]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.432]   - Field: ‘node’
[16:05:32.632]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.432]   - Field: ‘label’
[16:05:32.632]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.432]   - Field: ‘local’
[16:05:32.632]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.432]   - Field: ‘owner’
[16:05:32.633]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.432]   - Field: ‘envir’
[16:05:32.633]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.432]   - Field: ‘workers’
[16:05:32.633]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.433]   - Field: ‘packages’
[16:05:32.633]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.433]   - Field: ‘gc’
[16:05:32.633]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.433]   - Field: ‘conditions’
[16:05:32.634]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.433]   - Field: ‘persistent’
[16:05:32.634]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.433]   - Field: ‘expr’
[16:05:32.634]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.433]   - Field: ‘uuid’
[16:05:32.634]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.433]   - Field: ‘seed’
[16:05:32.634]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.434]   - Field: ‘version’
[16:05:32.634]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.434]   - Field: ‘result’
[16:05:32.635]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.434]   - Field: ‘asynchronous’
[16:05:32.635]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.434]   - Field: ‘calls’
[16:05:32.635]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.434]   - Field: ‘globals’
[16:05:32.635]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.434]   - Field: ‘stdout’
[16:05:32.635]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.434]   - Field: ‘earlySignal’
[16:05:32.636]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.434]   - Field: ‘lazy’
[16:05:32.636]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.435]   - Field: ‘state’
[16:05:32.636]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.435] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:32.636]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.435] - Launch lazy future ...
[16:05:32.636]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.436] Packages needed by the future expression (n = 0): <none>
[16:05:32.636]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.436] Packages needed by future strategies (n = 0): <none>
[16:05:32.637]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.437] {
[16:05:32.437]     {
[16:05:32.437]         {
[16:05:32.437]             ...future.startTime <- base::Sys.time()
[16:05:32.437]             {
[16:05:32.437]                 {
[16:05:32.437]                   {
[16:05:32.437]                     {
[16:05:32.437]                       base::local({
[16:05:32.437]                         has_future <- base::requireNamespace("future", 
[16:05:32.437]                           quietly = TRUE)
[16:05:32.437]                         if (has_future) {
[16:05:32.437]                           ns <- base::getNamespace("future")
[16:05:32.437]                           version <- ns[[".package"]][["version"]]
[16:05:32.437]                           if (is.null(version)) 
[16:05:32.437]                             version <- utils::packageVersion("future")
[16:05:32.437]                         }
[16:05:32.437]                         else {
[16:05:32.437]                           version <- NULL
[16:05:32.437]                         }
[16:05:32.437]                         if (!has_future || version < "1.8.0") {
[16:05:32.437]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:32.437]                             "", base::R.version$version.string), 
[16:05:32.437]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:32.437]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:32.437]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:32.437]                               "release", "version")], collapse = " "), 
[16:05:32.437]                             hostname = base::Sys.info()[["nodename"]])
[16:05:32.437]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:32.437]                             info)
[16:05:32.437]                           info <- base::paste(info, collapse = "; ")
[16:05:32.437]                           if (!has_future) {
[16:05:32.437]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:32.437]                               info)
[16:05:32.437]                           }
[16:05:32.437]                           else {
[16:05:32.437]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:32.437]                               info, version)
[16:05:32.437]                           }
[16:05:32.437]                           base::stop(msg)
[16:05:32.437]                         }
[16:05:32.437]                       })
[16:05:32.437]                     }
[16:05:32.437]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:32.437]                     base::options(mc.cores = 1L)
[16:05:32.437]                   }
[16:05:32.437]                   options(future.plan = NULL)
[16:05:32.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:32.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:32.437]                 }
[16:05:32.437]                 ...future.workdir <- getwd()
[16:05:32.437]             }
[16:05:32.437]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:32.437]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:32.437]         }
[16:05:32.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:32.437]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:32.437]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:32.437]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:32.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:32.437]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:32.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:32.437]             base::names(...future.oldOptions))
[16:05:32.437]     }
[16:05:32.437]     if (FALSE) {
[16:05:32.437]     }
[16:05:32.437]     else {
[16:05:32.437]         if (TRUE) {
[16:05:32.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:32.437]                 open = "w")
[16:05:32.437]         }
[16:05:32.437]         else {
[16:05:32.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:32.437]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:32.437]         }
[16:05:32.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:32.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:32.437]             base::sink(type = "output", split = FALSE)
[16:05:32.437]             base::close(...future.stdout)
[16:05:32.437]         }, add = TRUE)
[16:05:32.437]     }
[16:05:32.437]     ...future.frame <- base::sys.nframe()
[16:05:32.437]     ...future.conditions <- base::list()
[16:05:32.437]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:32.437]     if (FALSE) {
[16:05:32.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:32.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:32.437]     }
[16:05:32.437]     ...future.result <- base::tryCatch({
[16:05:32.437]         base::withCallingHandlers({
[16:05:32.437]             ...future.value <- base::withVisible(base::local({
[16:05:32.437]                 ...future.makeSendCondition <- base::local({
[16:05:32.437]                   sendCondition <- NULL
[16:05:32.437]                   function(frame = 1L) {
[16:05:32.437]                     if (is.function(sendCondition)) 
[16:05:32.437]                       return(sendCondition)
[16:05:32.437]                     ns <- getNamespace("parallel")
[16:05:32.437]                     if (exists("sendData", mode = "function", 
[16:05:32.437]                       envir = ns)) {
[16:05:32.437]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:32.437]                         envir = ns)
[16:05:32.437]                       envir <- sys.frame(frame)
[16:05:32.437]                       master <- NULL
[16:05:32.437]                       while (!identical(envir, .GlobalEnv) && 
[16:05:32.437]                         !identical(envir, emptyenv())) {
[16:05:32.437]                         if (exists("master", mode = "list", envir = envir, 
[16:05:32.437]                           inherits = FALSE)) {
[16:05:32.437]                           master <- get("master", mode = "list", 
[16:05:32.437]                             envir = envir, inherits = FALSE)
[16:05:32.437]                           if (inherits(master, c("SOCKnode", 
[16:05:32.437]                             "SOCK0node"))) {
[16:05:32.437]                             sendCondition <<- function(cond) {
[16:05:32.437]                               data <- list(type = "VALUE", value = cond, 
[16:05:32.437]                                 success = TRUE)
[16:05:32.437]                               parallel_sendData(master, data)
[16:05:32.437]                             }
[16:05:32.437]                             return(sendCondition)
[16:05:32.437]                           }
[16:05:32.437]                         }
[16:05:32.437]                         frame <- frame + 1L
[16:05:32.437]                         envir <- sys.frame(frame)
[16:05:32.437]                       }
[16:05:32.437]                     }
[16:05:32.437]                     sendCondition <<- function(cond) NULL
[16:05:32.437]                   }
[16:05:32.437]                 })
[16:05:32.437]                 withCallingHandlers({
[16:05:32.437]                   {
[16:05:32.437]                     b <- 2L
[16:05:32.437]                     plan_b <- future::plan("list")
[16:05:32.437]                     nested_b <- nested_a[-1]
[16:05:32.437]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:05:32.437]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:05:32.437]                       "sequential"))
[16:05:32.437]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:05:32.437]                       b = b, nested_b = nested_b, plan_b = plan_b)
[16:05:32.437]                   }
[16:05:32.437]                 }, immediateCondition = function(cond) {
[16:05:32.437]                   sendCondition <- ...future.makeSendCondition()
[16:05:32.437]                   sendCondition(cond)
[16:05:32.437]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:32.437]                   {
[16:05:32.437]                     inherits <- base::inherits
[16:05:32.437]                     invokeRestart <- base::invokeRestart
[16:05:32.437]                     is.null <- base::is.null
[16:05:32.437]                     muffled <- FALSE
[16:05:32.437]                     if (inherits(cond, "message")) {
[16:05:32.437]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:32.437]                       if (muffled) 
[16:05:32.437]                         invokeRestart("muffleMessage")
[16:05:32.437]                     }
[16:05:32.437]                     else if (inherits(cond, "warning")) {
[16:05:32.437]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:32.437]                       if (muffled) 
[16:05:32.437]                         invokeRestart("muffleWarning")
[16:05:32.437]                     }
[16:05:32.437]                     else if (inherits(cond, "condition")) {
[16:05:32.437]                       if (!is.null(pattern)) {
[16:05:32.437]                         computeRestarts <- base::computeRestarts
[16:05:32.437]                         grepl <- base::grepl
[16:05:32.437]                         restarts <- computeRestarts(cond)
[16:05:32.437]                         for (restart in restarts) {
[16:05:32.437]                           name <- restart$name
[16:05:32.437]                           if (is.null(name)) 
[16:05:32.437]                             next
[16:05:32.437]                           if (!grepl(pattern, name)) 
[16:05:32.437]                             next
[16:05:32.437]                           invokeRestart(restart)
[16:05:32.437]                           muffled <- TRUE
[16:05:32.437]                           break
[16:05:32.437]                         }
[16:05:32.437]                       }
[16:05:32.437]                     }
[16:05:32.437]                     invisible(muffled)
[16:05:32.437]                   }
[16:05:32.437]                   muffleCondition(cond)
[16:05:32.437]                 })
[16:05:32.437]             }))
[16:05:32.437]             future::FutureResult(value = ...future.value$value, 
[16:05:32.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:32.437]                   ...future.rng), globalenv = if (FALSE) 
[16:05:32.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:32.437]                     ...future.globalenv.names))
[16:05:32.437]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:32.437]         }, condition = base::local({
[16:05:32.437]             c <- base::c
[16:05:32.437]             inherits <- base::inherits
[16:05:32.437]             invokeRestart <- base::invokeRestart
[16:05:32.437]             length <- base::length
[16:05:32.437]             list <- base::list
[16:05:32.437]             seq.int <- base::seq.int
[16:05:32.437]             signalCondition <- base::signalCondition
[16:05:32.437]             sys.calls <- base::sys.calls
[16:05:32.437]             `[[` <- base::`[[`
[16:05:32.437]             `+` <- base::`+`
[16:05:32.437]             `<<-` <- base::`<<-`
[16:05:32.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:32.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:32.437]                   3L)]
[16:05:32.437]             }
[16:05:32.437]             function(cond) {
[16:05:32.437]                 is_error <- inherits(cond, "error")
[16:05:32.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:32.437]                   NULL)
[16:05:32.437]                 if (is_error) {
[16:05:32.437]                   sessionInformation <- function() {
[16:05:32.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:32.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:32.437]                       search = base::search(), system = base::Sys.info())
[16:05:32.437]                   }
[16:05:32.437]                   ...future.conditions[[length(...future.conditions) + 
[16:05:32.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:32.437]                     cond$call), session = sessionInformation(), 
[16:05:32.437]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:32.437]                   signalCondition(cond)
[16:05:32.437]                 }
[16:05:32.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:32.437]                 "immediateCondition"))) {
[16:05:32.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:32.437]                   ...future.conditions[[length(...future.conditions) + 
[16:05:32.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:32.437]                   if (TRUE && !signal) {
[16:05:32.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:32.437]                     {
[16:05:32.437]                       inherits <- base::inherits
[16:05:32.437]                       invokeRestart <- base::invokeRestart
[16:05:32.437]                       is.null <- base::is.null
[16:05:32.437]                       muffled <- FALSE
[16:05:32.437]                       if (inherits(cond, "message")) {
[16:05:32.437]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:32.437]                         if (muffled) 
[16:05:32.437]                           invokeRestart("muffleMessage")
[16:05:32.437]                       }
[16:05:32.437]                       else if (inherits(cond, "warning")) {
[16:05:32.437]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:32.437]                         if (muffled) 
[16:05:32.437]                           invokeRestart("muffleWarning")
[16:05:32.437]                       }
[16:05:32.437]                       else if (inherits(cond, "condition")) {
[16:05:32.437]                         if (!is.null(pattern)) {
[16:05:32.437]                           computeRestarts <- base::computeRestarts
[16:05:32.437]                           grepl <- base::grepl
[16:05:32.437]                           restarts <- computeRestarts(cond)
[16:05:32.437]                           for (restart in restarts) {
[16:05:32.437]                             name <- restart$name
[16:05:32.437]                             if (is.null(name)) 
[16:05:32.437]                               next
[16:05:32.437]                             if (!grepl(pattern, name)) 
[16:05:32.437]                               next
[16:05:32.437]                             invokeRestart(restart)
[16:05:32.437]                             muffled <- TRUE
[16:05:32.437]                             break
[16:05:32.437]                           }
[16:05:32.437]                         }
[16:05:32.437]                       }
[16:05:32.437]                       invisible(muffled)
[16:05:32.437]                     }
[16:05:32.437]                     muffleCondition(cond, pattern = "^muffle")
[16:05:32.437]                   }
[16:05:32.437]                 }
[16:05:32.437]                 else {
[16:05:32.437]                   if (TRUE) {
[16:05:32.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:32.437]                     {
[16:05:32.437]                       inherits <- base::inherits
[16:05:32.437]                       invokeRestart <- base::invokeRestart
[16:05:32.437]                       is.null <- base::is.null
[16:05:32.437]                       muffled <- FALSE
[16:05:32.437]                       if (inherits(cond, "message")) {
[16:05:32.437]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:32.437]                         if (muffled) 
[16:05:32.437]                           invokeRestart("muffleMessage")
[16:05:32.437]                       }
[16:05:32.437]                       else if (inherits(cond, "warning")) {
[16:05:32.437]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:32.437]                         if (muffled) 
[16:05:32.437]                           invokeRestart("muffleWarning")
[16:05:32.437]                       }
[16:05:32.437]                       else if (inherits(cond, "condition")) {
[16:05:32.437]                         if (!is.null(pattern)) {
[16:05:32.437]                           computeRestarts <- base::computeRestarts
[16:05:32.437]                           grepl <- base::grepl
[16:05:32.437]                           restarts <- computeRestarts(cond)
[16:05:32.437]                           for (restart in restarts) {
[16:05:32.437]                             name <- restart$name
[16:05:32.437]                             if (is.null(name)) 
[16:05:32.437]                               next
[16:05:32.437]                             if (!grepl(pattern, name)) 
[16:05:32.437]                               next
[16:05:32.437]                             invokeRestart(restart)
[16:05:32.437]                             muffled <- TRUE
[16:05:32.437]                             break
[16:05:32.437]                           }
[16:05:32.437]                         }
[16:05:32.437]                       }
[16:05:32.437]                       invisible(muffled)
[16:05:32.437]                     }
[16:05:32.437]                     muffleCondition(cond, pattern = "^muffle")
[16:05:32.437]                   }
[16:05:32.437]                 }
[16:05:32.437]             }
[16:05:32.437]         }))
[16:05:32.437]     }, error = function(ex) {
[16:05:32.437]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:32.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:32.437]                 ...future.rng), started = ...future.startTime, 
[16:05:32.437]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:32.437]             version = "1.8"), class = "FutureResult")
[16:05:32.437]     }, finally = {
[16:05:32.437]         if (!identical(...future.workdir, getwd())) 
[16:05:32.437]             setwd(...future.workdir)
[16:05:32.437]         {
[16:05:32.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:32.437]                 ...future.oldOptions$nwarnings <- NULL
[16:05:32.437]             }
[16:05:32.437]             base::options(...future.oldOptions)
[16:05:32.437]             if (.Platform$OS.type == "windows") {
[16:05:32.437]                 old_names <- names(...future.oldEnvVars)
[16:05:32.437]                 envs <- base::Sys.getenv()
[16:05:32.437]                 names <- names(envs)
[16:05:32.437]                 common <- intersect(names, old_names)
[16:05:32.437]                 added <- setdiff(names, old_names)
[16:05:32.437]                 removed <- setdiff(old_names, names)
[16:05:32.437]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:32.437]                   envs[common]]
[16:05:32.437]                 NAMES <- toupper(changed)
[16:05:32.437]                 args <- list()
[16:05:32.437]                 for (kk in seq_along(NAMES)) {
[16:05:32.437]                   name <- changed[[kk]]
[16:05:32.437]                   NAME <- NAMES[[kk]]
[16:05:32.437]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.437]                     next
[16:05:32.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:32.437]                 }
[16:05:32.437]                 NAMES <- toupper(added)
[16:05:32.437]                 for (kk in seq_along(NAMES)) {
[16:05:32.437]                   name <- added[[kk]]
[16:05:32.437]                   NAME <- NAMES[[kk]]
[16:05:32.437]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.437]                     next
[16:05:32.437]                   args[[name]] <- ""
[16:05:32.437]                 }
[16:05:32.437]                 NAMES <- toupper(removed)
[16:05:32.437]                 for (kk in seq_along(NAMES)) {
[16:05:32.437]                   name <- removed[[kk]]
[16:05:32.437]                   NAME <- NAMES[[kk]]
[16:05:32.437]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.437]                     next
[16:05:32.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:32.437]                 }
[16:05:32.437]                 if (length(args) > 0) 
[16:05:32.437]                   base::do.call(base::Sys.setenv, args = args)
[16:05:32.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:32.437]             }
[16:05:32.437]             else {
[16:05:32.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:32.437]             }
[16:05:32.437]             {
[16:05:32.437]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:32.437]                   0L) {
[16:05:32.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:32.437]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:32.437]                   base::options(opts)
[16:05:32.437]                 }
[16:05:32.437]                 {
[16:05:32.437]                   {
[16:05:32.437]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:32.437]                     NULL
[16:05:32.437]                   }
[16:05:32.437]                   options(future.plan = NULL)
[16:05:32.437]                   if (is.na(NA_character_)) 
[16:05:32.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:32.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:32.437]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:05:32.437]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:32.437]                     envir = parent.frame()) 
[16:05:32.437]                   {
[16:05:32.437]                     if (is.function(workers)) 
[16:05:32.437]                       workers <- workers()
[16:05:32.437]                     workers <- structure(as.integer(workers), 
[16:05:32.437]                       class = class(workers))
[16:05:32.437]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:32.437]                       workers >= 1)
[16:05:32.437]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:32.437]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:32.437]                     }
[16:05:32.437]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:32.437]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:32.437]                       envir = envir)
[16:05:32.437]                     if (!future$lazy) 
[16:05:32.437]                       future <- run(future)
[16:05:32.437]                     invisible(future)
[16:05:32.437]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:32.437]                 }
[16:05:32.437]             }
[16:05:32.437]         }
[16:05:32.437]     })
[16:05:32.437]     if (TRUE) {
[16:05:32.437]         base::sink(type = "output", split = FALSE)
[16:05:32.437]         if (TRUE) {
[16:05:32.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:32.437]         }
[16:05:32.437]         else {
[16:05:32.437]             ...future.result["stdout"] <- base::list(NULL)
[16:05:32.437]         }
[16:05:32.437]         base::close(...future.stdout)
[16:05:32.437]         ...future.stdout <- NULL
[16:05:32.437]     }
[16:05:32.437]     ...future.result$conditions <- ...future.conditions
[16:05:32.437]     ...future.result$finished <- base::Sys.time()
[16:05:32.437]     ...future.result
[16:05:32.437] }
[16:05:32.637]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.488] Exporting 3 global objects (87.82 KiB) to cluster node #1 ...
[16:05:32.637]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.489] Exporting ‘nested_a’ (43.88 KiB) to cluster node #1 ...
[16:05:32.637]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.489] Exporting ‘nested_a’ (43.88 KiB) to cluster node #1 ... DONE
[16:05:32.637]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.489] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:05:32.638]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.490] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:05:32.638]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.490] Exporting ‘plan_a’ (43.88 KiB) to cluster node #1 ...
[16:05:32.638]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.531] Exporting ‘plan_a’ (43.88 KiB) to cluster node #1 ... DONE
[16:05:32.638]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.531] Exporting 3 global objects (87.82 KiB) to cluster node #1 ... DONE
[16:05:32.638]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.532] MultisessionFuture started
[16:05:32.638]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.532] - Launch lazy future ... done
[16:05:32.639]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.532] run() for ‘MultisessionFuture’ ... done
[16:05:32.639]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.533] result() for ClusterFuture ...
[16:05:32.639]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.533] receiveMessageFromWorker() for ClusterFuture ...
[16:05:32.639]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.533] - Validating connection of MultisessionFuture
[16:05:32.639]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.618] - received message: FutureResult
[16:05:32.639]  - Condition #89: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.618] - Received FutureResult
[16:05:32.640]  - Condition #90: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.618] - Erased future from FutureRegistry
[16:05:32.640]  - Condition #91: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.619] result() for ClusterFuture ...
[16:05:32.640]  - Condition #92: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.619] - result already collected: FutureResult
[16:05:32.640]  - Condition #93: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.619] result() for ClusterFuture ... done
[16:05:32.640]  - Condition #94: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.619] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:32.640]  - Condition #95: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.619] result() for ClusterFuture ... done
[16:05:32.641]  - Condition #96: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.619] result() for ClusterFuture ...
[16:05:32.641]  - Condition #97: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.619] - result already collected: FutureResult
[16:05:32.641]  - Condition #98: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.620] result() for ClusterFuture ... done
[16:05:32.641] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:05:32.648] getGlobalsAndPackages() ...
[16:05:32.648] Searching for globals...
[16:05:32.650] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:05:32.650] Searching for globals ... DONE
[16:05:32.650] Resolving globals: FALSE
[16:05:32.651] The total size of the 1 globals is 128 bytes (128 bytes)
[16:05:32.651] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:05:32.651] - globals: [1] ‘data’
[16:05:32.652] - packages: [1] ‘future’
[16:05:32.652] getGlobalsAndPackages() ... DONE
[16:05:32.652] run() for ‘Future’ ...
[16:05:32.652] - state: ‘created’
[16:05:32.652] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:32.653] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:32.653] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:32.653]   - Field: ‘label’
[16:05:32.653]   - Field: ‘local’
[16:05:32.653]   - Field: ‘owner’
[16:05:32.653]   - Field: ‘envir’
[16:05:32.653]   - Field: ‘packages’
[16:05:32.654]   - Field: ‘gc’
[16:05:32.654]   - Field: ‘conditions’
[16:05:32.654]   - Field: ‘expr’
[16:05:32.654]   - Field: ‘uuid’
[16:05:32.654]   - Field: ‘seed’
[16:05:32.654]   - Field: ‘version’
[16:05:32.654]   - Field: ‘result’
[16:05:32.654]   - Field: ‘asynchronous’
[16:05:32.655]   - Field: ‘calls’
[16:05:32.655]   - Field: ‘globals’
[16:05:32.655]   - Field: ‘stdout’
[16:05:32.655]   - Field: ‘earlySignal’
[16:05:32.655]   - Field: ‘lazy’
[16:05:32.655]   - Field: ‘state’
[16:05:32.655] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:32.655] - Launch lazy future ...
[16:05:32.656] Packages needed by the future expression (n = 1): ‘future’
[16:05:32.656] Packages needed by future strategies (n = 1): ‘future’
[16:05:32.656] {
[16:05:32.656]     {
[16:05:32.656]         {
[16:05:32.656]             ...future.startTime <- base::Sys.time()
[16:05:32.656]             {
[16:05:32.656]                 {
[16:05:32.656]                   {
[16:05:32.656]                     {
[16:05:32.656]                       base::local({
[16:05:32.656]                         has_future <- base::requireNamespace("future", 
[16:05:32.656]                           quietly = TRUE)
[16:05:32.656]                         if (has_future) {
[16:05:32.656]                           ns <- base::getNamespace("future")
[16:05:32.656]                           version <- ns[[".package"]][["version"]]
[16:05:32.656]                           if (is.null(version)) 
[16:05:32.656]                             version <- utils::packageVersion("future")
[16:05:32.656]                         }
[16:05:32.656]                         else {
[16:05:32.656]                           version <- NULL
[16:05:32.656]                         }
[16:05:32.656]                         if (!has_future || version < "1.8.0") {
[16:05:32.656]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:32.656]                             "", base::R.version$version.string), 
[16:05:32.656]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:32.656]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:32.656]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:32.656]                               "release", "version")], collapse = " "), 
[16:05:32.656]                             hostname = base::Sys.info()[["nodename"]])
[16:05:32.656]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:32.656]                             info)
[16:05:32.656]                           info <- base::paste(info, collapse = "; ")
[16:05:32.656]                           if (!has_future) {
[16:05:32.656]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:32.656]                               info)
[16:05:32.656]                           }
[16:05:32.656]                           else {
[16:05:32.656]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:32.656]                               info, version)
[16:05:32.656]                           }
[16:05:32.656]                           base::stop(msg)
[16:05:32.656]                         }
[16:05:32.656]                       })
[16:05:32.656]                     }
[16:05:32.656]                     base::local({
[16:05:32.656]                       for (pkg in "future") {
[16:05:32.656]                         base::loadNamespace(pkg)
[16:05:32.656]                         base::library(pkg, character.only = TRUE)
[16:05:32.656]                       }
[16:05:32.656]                     })
[16:05:32.656]                   }
[16:05:32.656]                   options(future.plan = NULL)
[16:05:32.656]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:32.656]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:05:32.656]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:32.656]                     envir = parent.frame()) 
[16:05:32.656]                   {
[16:05:32.656]                     if (is.function(workers)) 
[16:05:32.656]                       workers <- workers()
[16:05:32.656]                     workers <- structure(as.integer(workers), 
[16:05:32.656]                       class = class(workers))
[16:05:32.656]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:32.656]                       workers >= 1)
[16:05:32.656]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:32.656]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:32.656]                     }
[16:05:32.656]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:32.656]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:32.656]                       envir = envir)
[16:05:32.656]                     if (!future$lazy) 
[16:05:32.656]                       future <- run(future)
[16:05:32.656]                     invisible(future)
[16:05:32.656]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:32.656]                 }
[16:05:32.656]                 ...future.workdir <- getwd()
[16:05:32.656]             }
[16:05:32.656]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:32.656]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:32.656]         }
[16:05:32.656]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:32.656]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:32.656]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:32.656]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:32.656]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:32.656]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:32.656]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:32.656]             base::names(...future.oldOptions))
[16:05:32.656]     }
[16:05:32.656]     if (FALSE) {
[16:05:32.656]     }
[16:05:32.656]     else {
[16:05:32.656]         if (TRUE) {
[16:05:32.656]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:32.656]                 open = "w")
[16:05:32.656]         }
[16:05:32.656]         else {
[16:05:32.656]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:32.656]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:32.656]         }
[16:05:32.656]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:32.656]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:32.656]             base::sink(type = "output", split = FALSE)
[16:05:32.656]             base::close(...future.stdout)
[16:05:32.656]         }, add = TRUE)
[16:05:32.656]     }
[16:05:32.656]     ...future.frame <- base::sys.nframe()
[16:05:32.656]     ...future.conditions <- base::list()
[16:05:32.656]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:32.656]     if (FALSE) {
[16:05:32.656]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:32.656]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:32.656]     }
[16:05:32.656]     ...future.result <- base::tryCatch({
[16:05:32.656]         base::withCallingHandlers({
[16:05:32.656]             ...future.value <- base::withVisible(base::local({
[16:05:32.656]                 value(future(subset(data, a == 2)))
[16:05:32.656]             }))
[16:05:32.656]             future::FutureResult(value = ...future.value$value, 
[16:05:32.656]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:32.656]                   ...future.rng), globalenv = if (FALSE) 
[16:05:32.656]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:32.656]                     ...future.globalenv.names))
[16:05:32.656]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:32.656]         }, condition = base::local({
[16:05:32.656]             c <- base::c
[16:05:32.656]             inherits <- base::inherits
[16:05:32.656]             invokeRestart <- base::invokeRestart
[16:05:32.656]             length <- base::length
[16:05:32.656]             list <- base::list
[16:05:32.656]             seq.int <- base::seq.int
[16:05:32.656]             signalCondition <- base::signalCondition
[16:05:32.656]             sys.calls <- base::sys.calls
[16:05:32.656]             `[[` <- base::`[[`
[16:05:32.656]             `+` <- base::`+`
[16:05:32.656]             `<<-` <- base::`<<-`
[16:05:32.656]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:32.656]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:32.656]                   3L)]
[16:05:32.656]             }
[16:05:32.656]             function(cond) {
[16:05:32.656]                 is_error <- inherits(cond, "error")
[16:05:32.656]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:32.656]                   NULL)
[16:05:32.656]                 if (is_error) {
[16:05:32.656]                   sessionInformation <- function() {
[16:05:32.656]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:32.656]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:32.656]                       search = base::search(), system = base::Sys.info())
[16:05:32.656]                   }
[16:05:32.656]                   ...future.conditions[[length(...future.conditions) + 
[16:05:32.656]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:32.656]                     cond$call), session = sessionInformation(), 
[16:05:32.656]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:32.656]                   signalCondition(cond)
[16:05:32.656]                 }
[16:05:32.656]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:32.656]                 "immediateCondition"))) {
[16:05:32.656]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:32.656]                   ...future.conditions[[length(...future.conditions) + 
[16:05:32.656]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:32.656]                   if (TRUE && !signal) {
[16:05:32.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:32.656]                     {
[16:05:32.656]                       inherits <- base::inherits
[16:05:32.656]                       invokeRestart <- base::invokeRestart
[16:05:32.656]                       is.null <- base::is.null
[16:05:32.656]                       muffled <- FALSE
[16:05:32.656]                       if (inherits(cond, "message")) {
[16:05:32.656]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:32.656]                         if (muffled) 
[16:05:32.656]                           invokeRestart("muffleMessage")
[16:05:32.656]                       }
[16:05:32.656]                       else if (inherits(cond, "warning")) {
[16:05:32.656]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:32.656]                         if (muffled) 
[16:05:32.656]                           invokeRestart("muffleWarning")
[16:05:32.656]                       }
[16:05:32.656]                       else if (inherits(cond, "condition")) {
[16:05:32.656]                         if (!is.null(pattern)) {
[16:05:32.656]                           computeRestarts <- base::computeRestarts
[16:05:32.656]                           grepl <- base::grepl
[16:05:32.656]                           restarts <- computeRestarts(cond)
[16:05:32.656]                           for (restart in restarts) {
[16:05:32.656]                             name <- restart$name
[16:05:32.656]                             if (is.null(name)) 
[16:05:32.656]                               next
[16:05:32.656]                             if (!grepl(pattern, name)) 
[16:05:32.656]                               next
[16:05:32.656]                             invokeRestart(restart)
[16:05:32.656]                             muffled <- TRUE
[16:05:32.656]                             break
[16:05:32.656]                           }
[16:05:32.656]                         }
[16:05:32.656]                       }
[16:05:32.656]                       invisible(muffled)
[16:05:32.656]                     }
[16:05:32.656]                     muffleCondition(cond, pattern = "^muffle")
[16:05:32.656]                   }
[16:05:32.656]                 }
[16:05:32.656]                 else {
[16:05:32.656]                   if (TRUE) {
[16:05:32.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:32.656]                     {
[16:05:32.656]                       inherits <- base::inherits
[16:05:32.656]                       invokeRestart <- base::invokeRestart
[16:05:32.656]                       is.null <- base::is.null
[16:05:32.656]                       muffled <- FALSE
[16:05:32.656]                       if (inherits(cond, "message")) {
[16:05:32.656]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:32.656]                         if (muffled) 
[16:05:32.656]                           invokeRestart("muffleMessage")
[16:05:32.656]                       }
[16:05:32.656]                       else if (inherits(cond, "warning")) {
[16:05:32.656]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:32.656]                         if (muffled) 
[16:05:32.656]                           invokeRestart("muffleWarning")
[16:05:32.656]                       }
[16:05:32.656]                       else if (inherits(cond, "condition")) {
[16:05:32.656]                         if (!is.null(pattern)) {
[16:05:32.656]                           computeRestarts <- base::computeRestarts
[16:05:32.656]                           grepl <- base::grepl
[16:05:32.656]                           restarts <- computeRestarts(cond)
[16:05:32.656]                           for (restart in restarts) {
[16:05:32.656]                             name <- restart$name
[16:05:32.656]                             if (is.null(name)) 
[16:05:32.656]                               next
[16:05:32.656]                             if (!grepl(pattern, name)) 
[16:05:32.656]                               next
[16:05:32.656]                             invokeRestart(restart)
[16:05:32.656]                             muffled <- TRUE
[16:05:32.656]                             break
[16:05:32.656]                           }
[16:05:32.656]                         }
[16:05:32.656]                       }
[16:05:32.656]                       invisible(muffled)
[16:05:32.656]                     }
[16:05:32.656]                     muffleCondition(cond, pattern = "^muffle")
[16:05:32.656]                   }
[16:05:32.656]                 }
[16:05:32.656]             }
[16:05:32.656]         }))
[16:05:32.656]     }, error = function(ex) {
[16:05:32.656]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:32.656]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:32.656]                 ...future.rng), started = ...future.startTime, 
[16:05:32.656]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:32.656]             version = "1.8"), class = "FutureResult")
[16:05:32.656]     }, finally = {
[16:05:32.656]         if (!identical(...future.workdir, getwd())) 
[16:05:32.656]             setwd(...future.workdir)
[16:05:32.656]         {
[16:05:32.656]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:32.656]                 ...future.oldOptions$nwarnings <- NULL
[16:05:32.656]             }
[16:05:32.656]             base::options(...future.oldOptions)
[16:05:32.656]             if (.Platform$OS.type == "windows") {
[16:05:32.656]                 old_names <- names(...future.oldEnvVars)
[16:05:32.656]                 envs <- base::Sys.getenv()
[16:05:32.656]                 names <- names(envs)
[16:05:32.656]                 common <- intersect(names, old_names)
[16:05:32.656]                 added <- setdiff(names, old_names)
[16:05:32.656]                 removed <- setdiff(old_names, names)
[16:05:32.656]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:32.656]                   envs[common]]
[16:05:32.656]                 NAMES <- toupper(changed)
[16:05:32.656]                 args <- list()
[16:05:32.656]                 for (kk in seq_along(NAMES)) {
[16:05:32.656]                   name <- changed[[kk]]
[16:05:32.656]                   NAME <- NAMES[[kk]]
[16:05:32.656]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.656]                     next
[16:05:32.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:32.656]                 }
[16:05:32.656]                 NAMES <- toupper(added)
[16:05:32.656]                 for (kk in seq_along(NAMES)) {
[16:05:32.656]                   name <- added[[kk]]
[16:05:32.656]                   NAME <- NAMES[[kk]]
[16:05:32.656]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.656]                     next
[16:05:32.656]                   args[[name]] <- ""
[16:05:32.656]                 }
[16:05:32.656]                 NAMES <- toupper(removed)
[16:05:32.656]                 for (kk in seq_along(NAMES)) {
[16:05:32.656]                   name <- removed[[kk]]
[16:05:32.656]                   NAME <- NAMES[[kk]]
[16:05:32.656]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.656]                     next
[16:05:32.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:32.656]                 }
[16:05:32.656]                 if (length(args) > 0) 
[16:05:32.656]                   base::do.call(base::Sys.setenv, args = args)
[16:05:32.656]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:32.656]             }
[16:05:32.656]             else {
[16:05:32.656]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:32.656]             }
[16:05:32.656]             {
[16:05:32.656]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:32.656]                   0L) {
[16:05:32.656]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:32.656]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:32.656]                   base::options(opts)
[16:05:32.656]                 }
[16:05:32.656]                 {
[16:05:32.656]                   {
[16:05:32.656]                     NULL
[16:05:32.656]                     RNGkind("Mersenne-Twister")
[16:05:32.656]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:32.656]                       inherits = FALSE)
[16:05:32.656]                   }
[16:05:32.656]                   options(future.plan = NULL)
[16:05:32.656]                   if (is.na(NA_character_)) 
[16:05:32.656]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:32.656]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:32.656]                   future::plan(list(a = function (..., envir = parent.frame()) 
[16:05:32.656]                   {
[16:05:32.656]                     future <- SequentialFuture(..., envir = envir)
[16:05:32.656]                     if (!future$lazy) 
[16:05:32.656]                       future <- run(future)
[16:05:32.656]                     invisible(future)
[16:05:32.656]                   }, b = function (..., workers = availableCores(), 
[16:05:32.656]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:32.656]                     envir = parent.frame()) 
[16:05:32.656]                   {
[16:05:32.656]                     if (is.function(workers)) 
[16:05:32.656]                       workers <- workers()
[16:05:32.656]                     workers <- structure(as.integer(workers), 
[16:05:32.656]                       class = class(workers))
[16:05:32.656]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:32.656]                       workers >= 1)
[16:05:32.656]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:32.656]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:32.656]                     }
[16:05:32.656]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:32.656]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:32.656]                       envir = envir)
[16:05:32.656]                     if (!future$lazy) 
[16:05:32.656]                       future <- run(future)
[16:05:32.656]                     invisible(future)
[16:05:32.656]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:32.656]                 }
[16:05:32.656]             }
[16:05:32.656]         }
[16:05:32.656]     })
[16:05:32.656]     if (TRUE) {
[16:05:32.656]         base::sink(type = "output", split = FALSE)
[16:05:32.656]         if (TRUE) {
[16:05:32.656]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:32.656]         }
[16:05:32.656]         else {
[16:05:32.656]             ...future.result["stdout"] <- base::list(NULL)
[16:05:32.656]         }
[16:05:32.656]         base::close(...future.stdout)
[16:05:32.656]         ...future.stdout <- NULL
[16:05:32.656]     }
[16:05:32.656]     ...future.result$conditions <- ...future.conditions
[16:05:32.656]     ...future.result$finished <- base::Sys.time()
[16:05:32.656]     ...future.result
[16:05:32.656] }
[16:05:32.659] assign_globals() ...
[16:05:32.659] List of 1
[16:05:32.659]  $ data:'data.frame':	3 obs. of  2 variables:
[16:05:32.659]   ..$ a: int [1:3] 1 2 3
[16:05:32.659]   ..$ b: int [1:3] 3 2 1
[16:05:32.659]  - attr(*, "where")=List of 1
[16:05:32.659]   ..$ data:<environment: R_EmptyEnv> 
[16:05:32.659]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:32.659]  - attr(*, "resolved")= logi FALSE
[16:05:32.659]  - attr(*, "total_size")= num 128
[16:05:32.659]  - attr(*, "already-done")= logi TRUE
[16:05:32.665] - copied ‘data’ to environment
[16:05:32.665] assign_globals() ... done
[16:05:32.665] plan(): Setting new future strategy stack:
[16:05:32.665] List of future strategies:
[16:05:32.665] 1. multisession:
[16:05:32.665]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:32.665]    - tweaked: FALSE
[16:05:32.665]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:32.669] plan(): nbrOfWorkers() = 2
[16:05:32.757] plan(): Setting new future strategy stack:
[16:05:32.758] List of future strategies:
[16:05:32.758] 1. sequential:
[16:05:32.758]    - args: function (..., envir = parent.frame())
[16:05:32.758]    - tweaked: FALSE
[16:05:32.758]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:32.758] 2. multisession:
[16:05:32.758]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:32.758]    - tweaked: FALSE
[16:05:32.758]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:32.758] plan(): nbrOfWorkers() = 1
[16:05:32.758] SequentialFuture started (and completed)
[16:05:32.759] signalConditions() ...
[16:05:32.759]  - include = ‘immediateCondition’
[16:05:32.759]  - exclude = 
[16:05:32.759]  - resignal = FALSE
[16:05:32.759]  - Number of conditions: 63
[16:05:32.759] signalConditions() ... done
[16:05:32.759] - Launch lazy future ... done
[16:05:32.759] run() for ‘SequentialFuture’ ... done
[16:05:32.760] signalConditions() ...
[16:05:32.760]  - include = ‘immediateCondition’
[16:05:32.760]  - exclude = 
[16:05:32.760]  - resignal = FALSE
[16:05:32.760]  - Number of conditions: 63
[16:05:32.760] signalConditions() ... done
[16:05:32.760] Future state: ‘finished’
[16:05:32.761] signalConditions() ...
[16:05:32.761]  - include = ‘condition’
[16:05:32.761]  - exclude = ‘immediateCondition’
[16:05:32.761]  - resignal = TRUE
[16:05:32.761]  - Number of conditions: 63
[16:05:32.761]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.669] getGlobalsAndPackages() ...
[16:05:32.761]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.669] Searching for globals...
[16:05:32.761]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.684] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[16:05:32.762]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.684] Searching for globals ... DONE
[16:05:32.762]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.684] Resolving globals: FALSE
[16:05:32.762]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.684] The total size of the 1 globals is 128 bytes (128 bytes)
[16:05:32.762]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.685] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:05:32.762]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.685] - globals: [1] ‘data’
[16:05:32.762]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.685] 
[16:05:32.763]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.685] getGlobalsAndPackages() ... DONE
[16:05:32.763]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.685] run() for ‘Future’ ...
[16:05:32.763]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.685] - state: ‘created’
[16:05:32.763]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.686] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:32.763]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.700] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:32.763]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.700] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:32.763]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.700]   - Field: ‘node’
[16:05:32.763]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.700]   - Field: ‘label’
[16:05:32.764]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.700]   - Field: ‘local’
[16:05:32.764]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.700]   - Field: ‘owner’
[16:05:32.764]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.700]   - Field: ‘envir’
[16:05:32.764]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.701]   - Field: ‘workers’
[16:05:32.764]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.701]   - Field: ‘packages’
[16:05:32.764]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.701]   - Field: ‘gc’
[16:05:32.764]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.701]   - Field: ‘conditions’
[16:05:32.765]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.701]   - Field: ‘persistent’
[16:05:32.765]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.701]   - Field: ‘expr’
[16:05:32.765]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.701]   - Field: ‘uuid’
[16:05:32.765]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.701]   - Field: ‘seed’
[16:05:32.765]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.701]   - Field: ‘version’
[16:05:32.765]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.701]   - Field: ‘result’
[16:05:32.766]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.702]   - Field: ‘asynchronous’
[16:05:32.766]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.702]   - Field: ‘calls’
[16:05:32.766]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.702]   - Field: ‘globals’
[16:05:32.766]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.702]   - Field: ‘stdout’
[16:05:32.766]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.702]   - Field: ‘earlySignal’
[16:05:32.767]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.702]   - Field: ‘lazy’
[16:05:32.767]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.702]   - Field: ‘state’
[16:05:32.767]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.702] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:32.767]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.702] - Launch lazy future ...
[16:05:32.767]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.703] Packages needed by the future expression (n = 0): <none>
[16:05:32.768]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.703] Packages needed by future strategies (n = 0): <none>
[16:05:32.768]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.703] {
[16:05:32.703]     {
[16:05:32.703]         {
[16:05:32.703]             ...future.startTime <- base::Sys.time()
[16:05:32.703]             {
[16:05:32.703]                 {
[16:05:32.703]                   {
[16:05:32.703]                     {
[16:05:32.703]                       base::local({
[16:05:32.703]                         has_future <- base::requireNamespace("future", 
[16:05:32.703]                           quietly = TRUE)
[16:05:32.703]                         if (has_future) {
[16:05:32.703]                           ns <- base::getNamespace("future")
[16:05:32.703]                           version <- ns[[".package"]][["version"]]
[16:05:32.703]                           if (is.null(version)) 
[16:05:32.703]                             version <- utils::packageVersion("future")
[16:05:32.703]                         }
[16:05:32.703]                         else {
[16:05:32.703]                           version <- NULL
[16:05:32.703]                         }
[16:05:32.703]                         if (!has_future || version < "1.8.0") {
[16:05:32.703]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:32.703]                             "", base::R.version$version.string), 
[16:05:32.703]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:32.703]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:32.703]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:32.703]                               "release", "version")], collapse = " "), 
[16:05:32.703]                             hostname = base::Sys.info()[["nodename"]])
[16:05:32.703]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:32.703]                             info)
[16:05:32.703]                           info <- base::paste(info, collapse = "; ")
[16:05:32.703]                           if (!has_future) {
[16:05:32.703]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:32.703]                               info)
[16:05:32.703]                           }
[16:05:32.703]                           else {
[16:05:32.703]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:32.703]                               info, version)
[16:05:32.703]                           }
[16:05:32.703]                           base::stop(msg)
[16:05:32.703]                         }
[16:05:32.703]                       })
[16:05:32.703]                     }
[16:05:32.703]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:32.703]                     base::options(mc.cores = 1L)
[16:05:32.703]                   }
[16:05:32.703]                   options(future.plan = NULL)
[16:05:32.703]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:32.703]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:32.703]                 }
[16:05:32.703]                 ...future.workdir <- getwd()
[16:05:32.703]             }
[16:05:32.703]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:32.703]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:32.703]         }
[16:05:32.703]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:32.703]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:32.703]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:32.703]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:32.703]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:32.703]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:32.703]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:32.703]             base::names(...future.oldOptions))
[16:05:32.703]     }
[16:05:32.703]     if (FALSE) {
[16:05:32.703]     }
[16:05:32.703]     else {
[16:05:32.703]         if (TRUE) {
[16:05:32.703]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:32.703]                 open = "w")
[16:05:32.703]         }
[16:05:32.703]         else {
[16:05:32.703]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:32.703]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:32.703]         }
[16:05:32.703]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:32.703]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:32.703]             base::sink(type = "output", split = FALSE)
[16:05:32.703]             base::close(...future.stdout)
[16:05:32.703]         }, add = TRUE)
[16:05:32.703]     }
[16:05:32.703]     ...future.frame <- base::sys.nframe()
[16:05:32.703]     ...future.conditions <- base::list()
[16:05:32.703]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:32.703]     if (FALSE) {
[16:05:32.703]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:32.703]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:32.703]     }
[16:05:32.703]     ...future.result <- base::tryCatch({
[16:05:32.703]         base::withCallingHandlers({
[16:05:32.703]             ...future.value <- base::withVisible(base::local({
[16:05:32.703]                 ...future.makeSendCondition <- base::local({
[16:05:32.703]                   sendCondition <- NULL
[16:05:32.703]                   function(frame = 1L) {
[16:05:32.703]                     if (is.function(sendCondition)) 
[16:05:32.703]                       return(sendCondition)
[16:05:32.703]                     ns <- getNamespace("parallel")
[16:05:32.703]                     if (exists("sendData", mode = "function", 
[16:05:32.703]                       envir = ns)) {
[16:05:32.703]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:32.703]                         envir = ns)
[16:05:32.703]                       envir <- sys.frame(frame)
[16:05:32.703]                       master <- NULL
[16:05:32.703]                       while (!identical(envir, .GlobalEnv) && 
[16:05:32.703]                         !identical(envir, emptyenv())) {
[16:05:32.703]                         if (exists("master", mode = "list", envir = envir, 
[16:05:32.703]                           inherits = FALSE)) {
[16:05:32.703]                           master <- get("master", mode = "list", 
[16:05:32.703]                             envir = envir, inherits = FALSE)
[16:05:32.703]                           if (inherits(master, c("SOCKnode", 
[16:05:32.703]                             "SOCK0node"))) {
[16:05:32.703]                             sendCondition <<- function(cond) {
[16:05:32.703]                               data <- list(type = "VALUE", value = cond, 
[16:05:32.703]                                 success = TRUE)
[16:05:32.703]                               parallel_sendData(master, data)
[16:05:32.703]                             }
[16:05:32.703]                             return(sendCondition)
[16:05:32.703]                           }
[16:05:32.703]                         }
[16:05:32.703]                         frame <- frame + 1L
[16:05:32.703]                         envir <- sys.frame(frame)
[16:05:32.703]                       }
[16:05:32.703]                     }
[16:05:32.703]                     sendCondition <<- function(cond) NULL
[16:05:32.703]                   }
[16:05:32.703]                 })
[16:05:32.703]                 withCallingHandlers({
[16:05:32.703]                   subset(data, a == 2)
[16:05:32.703]                 }, immediateCondition = function(cond) {
[16:05:32.703]                   sendCondition <- ...future.makeSendCondition()
[16:05:32.703]                   sendCondition(cond)
[16:05:32.703]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:32.703]                   {
[16:05:32.703]                     inherits <- base::inherits
[16:05:32.703]                     invokeRestart <- base::invokeRestart
[16:05:32.703]                     is.null <- base::is.null
[16:05:32.703]                     muffled <- FALSE
[16:05:32.703]                     if (inherits(cond, "message")) {
[16:05:32.703]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:32.703]                       if (muffled) 
[16:05:32.703]                         invokeRestart("muffleMessage")
[16:05:32.703]                     }
[16:05:32.703]                     else if (inherits(cond, "warning")) {
[16:05:32.703]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:32.703]                       if (muffled) 
[16:05:32.703]                         invokeRestart("muffleWarning")
[16:05:32.703]                     }
[16:05:32.703]                     else if (inherits(cond, "condition")) {
[16:05:32.703]                       if (!is.null(pattern)) {
[16:05:32.703]                         computeRestarts <- base::computeRestarts
[16:05:32.703]                         grepl <- base::grepl
[16:05:32.703]                         restarts <- computeRestarts(cond)
[16:05:32.703]                         for (restart in restarts) {
[16:05:32.703]                           name <- restart$name
[16:05:32.703]                           if (is.null(name)) 
[16:05:32.703]                             next
[16:05:32.703]                           if (!grepl(pattern, name)) 
[16:05:32.703]                             next
[16:05:32.703]                           invokeRestart(restart)
[16:05:32.703]                           muffled <- TRUE
[16:05:32.703]                           break
[16:05:32.703]                         }
[16:05:32.703]                       }
[16:05:32.703]                     }
[16:05:32.703]                     invisible(muffled)
[16:05:32.703]                   }
[16:05:32.703]                   muffleCondition(cond)
[16:05:32.703]                 })
[16:05:32.703]             }))
[16:05:32.703]             future::FutureResult(value = ...future.value$value, 
[16:05:32.703]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:32.703]                   ...future.rng), globalenv = if (FALSE) 
[16:05:32.703]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:32.703]                     ...future.globalenv.names))
[16:05:32.703]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:32.703]         }, condition = base::local({
[16:05:32.703]             c <- base::c
[16:05:32.703]             inherits <- base::inherits
[16:05:32.703]             invokeRestart <- base::invokeRestart
[16:05:32.703]             length <- base::length
[16:05:32.703]             list <- base::list
[16:05:32.703]             seq.int <- base::seq.int
[16:05:32.703]             signalCondition <- base::signalCondition
[16:05:32.703]             sys.calls <- base::sys.calls
[16:05:32.703]             `[[` <- base::`[[`
[16:05:32.703]             `+` <- base::`+`
[16:05:32.703]             `<<-` <- base::`<<-`
[16:05:32.703]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:32.703]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:32.703]                   3L)]
[16:05:32.703]             }
[16:05:32.703]             function(cond) {
[16:05:32.703]                 is_error <- inherits(cond, "error")
[16:05:32.703]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:32.703]                   NULL)
[16:05:32.703]                 if (is_error) {
[16:05:32.703]                   sessionInformation <- function() {
[16:05:32.703]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:32.703]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:32.703]                       search = base::search(), system = base::Sys.info())
[16:05:32.703]                   }
[16:05:32.703]                   ...future.conditions[[length(...future.conditions) + 
[16:05:32.703]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:32.703]                     cond$call), session = sessionInformation(), 
[16:05:32.703]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:32.703]                   signalCondition(cond)
[16:05:32.703]                 }
[16:05:32.703]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:32.703]                 "immediateCondition"))) {
[16:05:32.703]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:32.703]                   ...future.conditions[[length(...future.conditions) + 
[16:05:32.703]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:32.703]                   if (TRUE && !signal) {
[16:05:32.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:32.703]                     {
[16:05:32.703]                       inherits <- base::inherits
[16:05:32.703]                       invokeRestart <- base::invokeRestart
[16:05:32.703]                       is.null <- base::is.null
[16:05:32.703]                       muffled <- FALSE
[16:05:32.703]                       if (inherits(cond, "message")) {
[16:05:32.703]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:32.703]                         if (muffled) 
[16:05:32.703]                           invokeRestart("muffleMessage")
[16:05:32.703]                       }
[16:05:32.703]                       else if (inherits(cond, "warning")) {
[16:05:32.703]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:32.703]                         if (muffled) 
[16:05:32.703]                           invokeRestart("muffleWarning")
[16:05:32.703]                       }
[16:05:32.703]                       else if (inherits(cond, "condition")) {
[16:05:32.703]                         if (!is.null(pattern)) {
[16:05:32.703]                           computeRestarts <- base::computeRestarts
[16:05:32.703]                           grepl <- base::grepl
[16:05:32.703]                           restarts <- computeRestarts(cond)
[16:05:32.703]                           for (restart in restarts) {
[16:05:32.703]                             name <- restart$name
[16:05:32.703]                             if (is.null(name)) 
[16:05:32.703]                               next
[16:05:32.703]                             if (!grepl(pattern, name)) 
[16:05:32.703]                               next
[16:05:32.703]                             invokeRestart(restart)
[16:05:32.703]                             muffled <- TRUE
[16:05:32.703]                             break
[16:05:32.703]                           }
[16:05:32.703]                         }
[16:05:32.703]                       }
[16:05:32.703]                       invisible(muffled)
[16:05:32.703]                     }
[16:05:32.703]                     muffleCondition(cond, pattern = "^muffle")
[16:05:32.703]                   }
[16:05:32.703]                 }
[16:05:32.703]                 else {
[16:05:32.703]                   if (TRUE) {
[16:05:32.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:32.703]                     {
[16:05:32.703]                       inherits <- base::inherits
[16:05:32.703]                       invokeRestart <- base::invokeRestart
[16:05:32.703]                       is.null <- base::is.null
[16:05:32.703]                       muffled <- FALSE
[16:05:32.703]                       if (inherits(cond, "message")) {
[16:05:32.703]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:32.703]                         if (muffled) 
[16:05:32.703]                           invokeRestart("muffleMessage")
[16:05:32.703]                       }
[16:05:32.703]                       else if (inherits(cond, "warning")) {
[16:05:32.703]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:32.703]                         if (muffled) 
[16:05:32.703]                           invokeRestart("muffleWarning")
[16:05:32.703]                       }
[16:05:32.703]                       else if (inherits(cond, "condition")) {
[16:05:32.703]                         if (!is.null(pattern)) {
[16:05:32.703]                           computeRestarts <- base::computeRestarts
[16:05:32.703]                           grepl <- base::grepl
[16:05:32.703]                           restarts <- computeRestarts(cond)
[16:05:32.703]                           for (restart in restarts) {
[16:05:32.703]                             name <- restart$name
[16:05:32.703]                             if (is.null(name)) 
[16:05:32.703]                               next
[16:05:32.703]                             if (!grepl(pattern, name)) 
[16:05:32.703]                               next
[16:05:32.703]                             invokeRestart(restart)
[16:05:32.703]                             muffled <- TRUE
[16:05:32.703]                             break
[16:05:32.703]                           }
[16:05:32.703]                         }
[16:05:32.703]                       }
[16:05:32.703]                       invisible(muffled)
[16:05:32.703]                     }
[16:05:32.703]                     muffleCondition(cond, pattern = "^muffle")
[16:05:32.703]                   }
[16:05:32.703]                 }
[16:05:32.703]             }
[16:05:32.703]         }))
[16:05:32.703]     }, error = function(ex) {
[16:05:32.703]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:32.703]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:32.703]                 ...future.rng), started = ...future.startTime, 
[16:05:32.703]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:32.703]             version = "1.8"), class = "FutureResult")
[16:05:32.703]     }, finally = {
[16:05:32.703]         if (!identical(...future.workdir, getwd())) 
[16:05:32.703]             setwd(...future.workdir)
[16:05:32.703]         {
[16:05:32.703]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:32.703]                 ...future.oldOptions$nwarnings <- NULL
[16:05:32.703]             }
[16:05:32.703]             base::options(...future.oldOptions)
[16:05:32.703]             if (.Platform$OS.type == "windows") {
[16:05:32.703]                 old_names <- names(...future.oldEnvVars)
[16:05:32.703]                 envs <- base::Sys.getenv()
[16:05:32.703]                 names <- names(envs)
[16:05:32.703]                 common <- intersect(names, old_names)
[16:05:32.703]                 added <- setdiff(names, old_names)
[16:05:32.703]                 removed <- setdiff(old_names, names)
[16:05:32.703]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:32.703]                   envs[common]]
[16:05:32.703]                 NAMES <- toupper(changed)
[16:05:32.703]                 args <- list()
[16:05:32.703]                 for (kk in seq_along(NAMES)) {
[16:05:32.703]                   name <- changed[[kk]]
[16:05:32.703]                   NAME <- NAMES[[kk]]
[16:05:32.703]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.703]                     next
[16:05:32.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:32.703]                 }
[16:05:32.703]                 NAMES <- toupper(added)
[16:05:32.703]                 for (kk in seq_along(NAMES)) {
[16:05:32.703]                   name <- added[[kk]]
[16:05:32.703]                   NAME <- NAMES[[kk]]
[16:05:32.703]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.703]                     next
[16:05:32.703]                   args[[name]] <- ""
[16:05:32.703]                 }
[16:05:32.703]                 NAMES <- toupper(removed)
[16:05:32.703]                 for (kk in seq_along(NAMES)) {
[16:05:32.703]                   name <- removed[[kk]]
[16:05:32.703]                   NAME <- NAMES[[kk]]
[16:05:32.703]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.703]                     next
[16:05:32.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:32.703]                 }
[16:05:32.703]                 if (length(args) > 0) 
[16:05:32.703]                   base::do.call(base::Sys.setenv, args = args)
[16:05:32.703]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:32.703]             }
[16:05:32.703]             else {
[16:05:32.703]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:32.703]             }
[16:05:32.703]             {
[16:05:32.703]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:32.703]                   0L) {
[16:05:32.703]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:32.703]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:32.703]                   base::options(opts)
[16:05:32.703]                 }
[16:05:32.703]                 {
[16:05:32.703]                   {
[16:05:32.703]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:32.703]                     NULL
[16:05:32.703]                   }
[16:05:32.703]                   options(future.plan = NULL)
[16:05:32.703]                   if (is.na(NA_character_)) 
[16:05:32.703]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:32.703]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:32.703]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:05:32.703]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:32.703]                     envir = parent.frame()) 
[16:05:32.703]                   {
[16:05:32.703]                     if (is.function(workers)) 
[16:05:32.703]                       workers <- workers()
[16:05:32.703]                     workers <- structure(as.integer(workers), 
[16:05:32.703]                       class = class(workers))
[16:05:32.703]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:32.703]                       workers >= 1)
[16:05:32.703]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:32.703]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:32.703]                     }
[16:05:32.703]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:32.703]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:32.703]                       envir = envir)
[16:05:32.703]                     if (!future$lazy) 
[16:05:32.703]                       future <- run(future)
[16:05:32.703]                     invisible(future)
[16:05:32.703]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:32.703]                 }
[16:05:32.703]             }
[16:05:32.703]         }
[16:05:32.703]     })
[16:05:32.703]     if (TRUE) {
[16:05:32.703]         base::sink(type = "output", split = FALSE)
[16:05:32.703]         if (TRUE) {
[16:05:32.703]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:32.703]         }
[16:05:32.703]         else {
[16:05:32.703]             ...future.result["stdout"] <- base::list(NULL)
[16:05:32.703]         }
[16:05:32.703]         base::close(...future.stdout)
[16:05:32.703]         ...future.stdout <- NULL
[16:05:32.703]     }
[16:05:32.703]     ...future.result$conditions <- ...future.conditions
[16:05:32.703]     ...future.result$finished <- base::Sys.time()
[16:05:32.703]     ...future.result
[16:05:32.703] }
[16:05:32.768]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.706] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[16:05:32.768]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.706] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[16:05:32.768]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.707] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[16:05:32.769]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.707] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[16:05:32.769]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.707] MultisessionFuture started
[16:05:32.769]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.707] - Launch lazy future ... done
[16:05:32.769]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.708] run() for ‘MultisessionFuture’ ... done
[16:05:32.769]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.708] result() for ClusterFuture ...
[16:05:32.770]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.708] receiveMessageFromWorker() for ClusterFuture ...
[16:05:32.770]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.708] - Validating connection of MultisessionFuture
[16:05:32.770]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.756] - received message: FutureResult
[16:05:32.770]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.756] - Received FutureResult
[16:05:32.770]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.756] - Erased future from FutureRegistry
[16:05:32.771]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.756] result() for ClusterFuture ...
[16:05:32.771]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.756] - result already collected: FutureResult
[16:05:32.771]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.756] result() for ClusterFuture ... done
[16:05:32.771]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.757] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:32.771]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.757] result() for ClusterFuture ... done
[16:05:32.772]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.757] result() for ClusterFuture ...
[16:05:32.772]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.757] - result already collected: FutureResult
[16:05:32.772]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.757] result() for ClusterFuture ... done
[16:05:32.772] signalConditions() ... done
- plan(list('sequential', 'multisession')) ... DONE
- plan(list('multicore', 'sequential')) ...
[16:05:32.773] plan(): Setting new future strategy stack:
[16:05:32.773] List of future strategies:
[16:05:32.773] 1. multicore:
[16:05:32.773]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:32.773]    - tweaked: FALSE
[16:05:32.773]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:32.773] 2. sequential:
[16:05:32.773]    - args: function (..., envir = parent.frame())
[16:05:32.773]    - tweaked: FALSE
[16:05:32.773]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:32.778] plan(): nbrOfWorkers() = 2
[16:05:32.778] getGlobalsAndPackages() ...
[16:05:32.778] Searching for globals...
[16:05:32.800] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:05:32.800] Searching for globals ... DONE
[16:05:32.801] Resolving globals: FALSE
[16:05:32.801] The total size of the 2 globals is 57.84 KiB (59224 bytes)
[16:05:32.802] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 57.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (57.72 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:05:32.802] - globals: [2] ‘nested’, ‘strategy2’
[16:05:32.802] - packages: [1] ‘future’
[16:05:32.802] getGlobalsAndPackages() ... DONE
[16:05:32.803] run() for ‘Future’ ...
[16:05:32.803] - state: ‘created’
[16:05:32.803] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:32.806] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:32.807] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:32.807]   - Field: ‘label’
[16:05:32.807]   - Field: ‘local’
[16:05:32.807]   - Field: ‘owner’
[16:05:32.807]   - Field: ‘envir’
[16:05:32.807]   - Field: ‘workers’
[16:05:32.807]   - Field: ‘packages’
[16:05:32.807]   - Field: ‘gc’
[16:05:32.807]   - Field: ‘job’
[16:05:32.808]   - Field: ‘conditions’
[16:05:32.808]   - Field: ‘expr’
[16:05:32.808]   - Field: ‘uuid’
[16:05:32.808]   - Field: ‘seed’
[16:05:32.808]   - Field: ‘version’
[16:05:32.808]   - Field: ‘result’
[16:05:32.808]   - Field: ‘asynchronous’
[16:05:32.808]   - Field: ‘calls’
[16:05:32.808]   - Field: ‘globals’
[16:05:32.808]   - Field: ‘stdout’
[16:05:32.808]   - Field: ‘earlySignal’
[16:05:32.809]   - Field: ‘lazy’
[16:05:32.809]   - Field: ‘state’
[16:05:32.809] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:32.809] - Launch lazy future ...
[16:05:32.809] Packages needed by the future expression (n = 1): ‘future’
[16:05:32.809] Packages needed by future strategies (n = 1): ‘future’
[16:05:32.810] {
[16:05:32.810]     {
[16:05:32.810]         {
[16:05:32.810]             ...future.startTime <- base::Sys.time()
[16:05:32.810]             {
[16:05:32.810]                 {
[16:05:32.810]                   {
[16:05:32.810]                     {
[16:05:32.810]                       {
[16:05:32.810]                         base::local({
[16:05:32.810]                           has_future <- base::requireNamespace("future", 
[16:05:32.810]                             quietly = TRUE)
[16:05:32.810]                           if (has_future) {
[16:05:32.810]                             ns <- base::getNamespace("future")
[16:05:32.810]                             version <- ns[[".package"]][["version"]]
[16:05:32.810]                             if (is.null(version)) 
[16:05:32.810]                               version <- utils::packageVersion("future")
[16:05:32.810]                           }
[16:05:32.810]                           else {
[16:05:32.810]                             version <- NULL
[16:05:32.810]                           }
[16:05:32.810]                           if (!has_future || version < "1.8.0") {
[16:05:32.810]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:32.810]                               "", base::R.version$version.string), 
[16:05:32.810]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:32.810]                                 base::R.version$platform, 8 * 
[16:05:32.810]                                   base::.Machine$sizeof.pointer), 
[16:05:32.810]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:32.810]                                 "release", "version")], collapse = " "), 
[16:05:32.810]                               hostname = base::Sys.info()[["nodename"]])
[16:05:32.810]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:32.810]                               info)
[16:05:32.810]                             info <- base::paste(info, collapse = "; ")
[16:05:32.810]                             if (!has_future) {
[16:05:32.810]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:32.810]                                 info)
[16:05:32.810]                             }
[16:05:32.810]                             else {
[16:05:32.810]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:32.810]                                 info, version)
[16:05:32.810]                             }
[16:05:32.810]                             base::stop(msg)
[16:05:32.810]                           }
[16:05:32.810]                         })
[16:05:32.810]                       }
[16:05:32.810]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:32.810]                       base::options(mc.cores = 1L)
[16:05:32.810]                     }
[16:05:32.810]                     base::local({
[16:05:32.810]                       for (pkg in "future") {
[16:05:32.810]                         base::loadNamespace(pkg)
[16:05:32.810]                         base::library(pkg, character.only = TRUE)
[16:05:32.810]                       }
[16:05:32.810]                     })
[16:05:32.810]                   }
[16:05:32.810]                   options(future.plan = NULL)
[16:05:32.810]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:32.810]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:05:32.810]                   {
[16:05:32.810]                     future <- SequentialFuture(..., envir = envir)
[16:05:32.810]                     if (!future$lazy) 
[16:05:32.810]                       future <- run(future)
[16:05:32.810]                     invisible(future)
[16:05:32.810]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:32.810]                 }
[16:05:32.810]                 ...future.workdir <- getwd()
[16:05:32.810]             }
[16:05:32.810]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:32.810]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:32.810]         }
[16:05:32.810]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:32.810]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:32.810]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:32.810]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:32.810]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:32.810]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:32.810]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:32.810]             base::names(...future.oldOptions))
[16:05:32.810]     }
[16:05:32.810]     if (FALSE) {
[16:05:32.810]     }
[16:05:32.810]     else {
[16:05:32.810]         if (TRUE) {
[16:05:32.810]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:32.810]                 open = "w")
[16:05:32.810]         }
[16:05:32.810]         else {
[16:05:32.810]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:32.810]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:32.810]         }
[16:05:32.810]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:32.810]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:32.810]             base::sink(type = "output", split = FALSE)
[16:05:32.810]             base::close(...future.stdout)
[16:05:32.810]         }, add = TRUE)
[16:05:32.810]     }
[16:05:32.810]     ...future.frame <- base::sys.nframe()
[16:05:32.810]     ...future.conditions <- base::list()
[16:05:32.810]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:32.810]     if (FALSE) {
[16:05:32.810]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:32.810]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:32.810]     }
[16:05:32.810]     ...future.result <- base::tryCatch({
[16:05:32.810]         base::withCallingHandlers({
[16:05:32.810]             ...future.value <- base::withVisible(base::local({
[16:05:32.810]                 withCallingHandlers({
[16:05:32.810]                   {
[16:05:32.810]                     a <- 1L
[16:05:32.810]                     plan_a <- unclass(future::plan("list"))
[16:05:32.810]                     nested_a <- nested[-1]
[16:05:32.810]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:05:32.810]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:05:32.810]                       strategy2))
[16:05:32.810]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:05:32.810]                       "init") <- NULL
[16:05:32.810]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:05:32.810]                       "init") <- NULL
[16:05:32.810]                     stopifnot(all.equal(plan_a, nested_a))
[16:05:32.810]                     y %<-% {
[16:05:32.810]                       b <- 2L
[16:05:32.810]                       plan_b <- future::plan("list")
[16:05:32.810]                       nested_b <- nested_a[-1]
[16:05:32.810]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:05:32.810]                         1L, inherits(plan_b[[1]], "future"), 
[16:05:32.810]                         inherits(future::plan("next"), "sequential"))
[16:05:32.810]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:05:32.810]                         b = b, nested_b = nested_b, plan_b = plan_b)
[16:05:32.810]                     }
[16:05:32.810]                     y
[16:05:32.810]                   }
[16:05:32.810]                 }, immediateCondition = function(cond) {
[16:05:32.810]                   save_rds <- function (object, pathname, ...) 
[16:05:32.810]                   {
[16:05:32.810]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:32.810]                     if (file_test("-f", pathname_tmp)) {
[16:05:32.810]                       fi_tmp <- file.info(pathname_tmp)
[16:05:32.810]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:32.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:32.810]                         fi_tmp[["mtime"]])
[16:05:32.810]                     }
[16:05:32.810]                     tryCatch({
[16:05:32.810]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:32.810]                     }, error = function(ex) {
[16:05:32.810]                       msg <- conditionMessage(ex)
[16:05:32.810]                       fi_tmp <- file.info(pathname_tmp)
[16:05:32.810]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:32.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:32.810]                         fi_tmp[["mtime"]], msg)
[16:05:32.810]                       ex$message <- msg
[16:05:32.810]                       stop(ex)
[16:05:32.810]                     })
[16:05:32.810]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:32.810]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:32.810]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:32.810]                       fi_tmp <- file.info(pathname_tmp)
[16:05:32.810]                       fi <- file.info(pathname)
[16:05:32.810]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:32.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:32.810]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:32.810]                         fi[["size"]], fi[["mtime"]])
[16:05:32.810]                       stop(msg)
[16:05:32.810]                     }
[16:05:32.810]                     invisible(pathname)
[16:05:32.810]                   }
[16:05:32.810]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:32.810]                     rootPath = tempdir()) 
[16:05:32.810]                   {
[16:05:32.810]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:32.810]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:32.810]                       tmpdir = path, fileext = ".rds")
[16:05:32.810]                     save_rds(obj, file)
[16:05:32.810]                   }
[16:05:32.810]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0EbAi0/.future/immediateConditions")
[16:05:32.810]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:32.810]                   {
[16:05:32.810]                     inherits <- base::inherits
[16:05:32.810]                     invokeRestart <- base::invokeRestart
[16:05:32.810]                     is.null <- base::is.null
[16:05:32.810]                     muffled <- FALSE
[16:05:32.810]                     if (inherits(cond, "message")) {
[16:05:32.810]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:32.810]                       if (muffled) 
[16:05:32.810]                         invokeRestart("muffleMessage")
[16:05:32.810]                     }
[16:05:32.810]                     else if (inherits(cond, "warning")) {
[16:05:32.810]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:32.810]                       if (muffled) 
[16:05:32.810]                         invokeRestart("muffleWarning")
[16:05:32.810]                     }
[16:05:32.810]                     else if (inherits(cond, "condition")) {
[16:05:32.810]                       if (!is.null(pattern)) {
[16:05:32.810]                         computeRestarts <- base::computeRestarts
[16:05:32.810]                         grepl <- base::grepl
[16:05:32.810]                         restarts <- computeRestarts(cond)
[16:05:32.810]                         for (restart in restarts) {
[16:05:32.810]                           name <- restart$name
[16:05:32.810]                           if (is.null(name)) 
[16:05:32.810]                             next
[16:05:32.810]                           if (!grepl(pattern, name)) 
[16:05:32.810]                             next
[16:05:32.810]                           invokeRestart(restart)
[16:05:32.810]                           muffled <- TRUE
[16:05:32.810]                           break
[16:05:32.810]                         }
[16:05:32.810]                       }
[16:05:32.810]                     }
[16:05:32.810]                     invisible(muffled)
[16:05:32.810]                   }
[16:05:32.810]                   muffleCondition(cond)
[16:05:32.810]                 })
[16:05:32.810]             }))
[16:05:32.810]             future::FutureResult(value = ...future.value$value, 
[16:05:32.810]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:32.810]                   ...future.rng), globalenv = if (FALSE) 
[16:05:32.810]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:32.810]                     ...future.globalenv.names))
[16:05:32.810]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:32.810]         }, condition = base::local({
[16:05:32.810]             c <- base::c
[16:05:32.810]             inherits <- base::inherits
[16:05:32.810]             invokeRestart <- base::invokeRestart
[16:05:32.810]             length <- base::length
[16:05:32.810]             list <- base::list
[16:05:32.810]             seq.int <- base::seq.int
[16:05:32.810]             signalCondition <- base::signalCondition
[16:05:32.810]             sys.calls <- base::sys.calls
[16:05:32.810]             `[[` <- base::`[[`
[16:05:32.810]             `+` <- base::`+`
[16:05:32.810]             `<<-` <- base::`<<-`
[16:05:32.810]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:32.810]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:32.810]                   3L)]
[16:05:32.810]             }
[16:05:32.810]             function(cond) {
[16:05:32.810]                 is_error <- inherits(cond, "error")
[16:05:32.810]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:32.810]                   NULL)
[16:05:32.810]                 if (is_error) {
[16:05:32.810]                   sessionInformation <- function() {
[16:05:32.810]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:32.810]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:32.810]                       search = base::search(), system = base::Sys.info())
[16:05:32.810]                   }
[16:05:32.810]                   ...future.conditions[[length(...future.conditions) + 
[16:05:32.810]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:32.810]                     cond$call), session = sessionInformation(), 
[16:05:32.810]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:32.810]                   signalCondition(cond)
[16:05:32.810]                 }
[16:05:32.810]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:32.810]                 "immediateCondition"))) {
[16:05:32.810]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:32.810]                   ...future.conditions[[length(...future.conditions) + 
[16:05:32.810]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:32.810]                   if (TRUE && !signal) {
[16:05:32.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:32.810]                     {
[16:05:32.810]                       inherits <- base::inherits
[16:05:32.810]                       invokeRestart <- base::invokeRestart
[16:05:32.810]                       is.null <- base::is.null
[16:05:32.810]                       muffled <- FALSE
[16:05:32.810]                       if (inherits(cond, "message")) {
[16:05:32.810]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:32.810]                         if (muffled) 
[16:05:32.810]                           invokeRestart("muffleMessage")
[16:05:32.810]                       }
[16:05:32.810]                       else if (inherits(cond, "warning")) {
[16:05:32.810]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:32.810]                         if (muffled) 
[16:05:32.810]                           invokeRestart("muffleWarning")
[16:05:32.810]                       }
[16:05:32.810]                       else if (inherits(cond, "condition")) {
[16:05:32.810]                         if (!is.null(pattern)) {
[16:05:32.810]                           computeRestarts <- base::computeRestarts
[16:05:32.810]                           grepl <- base::grepl
[16:05:32.810]                           restarts <- computeRestarts(cond)
[16:05:32.810]                           for (restart in restarts) {
[16:05:32.810]                             name <- restart$name
[16:05:32.810]                             if (is.null(name)) 
[16:05:32.810]                               next
[16:05:32.810]                             if (!grepl(pattern, name)) 
[16:05:32.810]                               next
[16:05:32.810]                             invokeRestart(restart)
[16:05:32.810]                             muffled <- TRUE
[16:05:32.810]                             break
[16:05:32.810]                           }
[16:05:32.810]                         }
[16:05:32.810]                       }
[16:05:32.810]                       invisible(muffled)
[16:05:32.810]                     }
[16:05:32.810]                     muffleCondition(cond, pattern = "^muffle")
[16:05:32.810]                   }
[16:05:32.810]                 }
[16:05:32.810]                 else {
[16:05:32.810]                   if (TRUE) {
[16:05:32.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:32.810]                     {
[16:05:32.810]                       inherits <- base::inherits
[16:05:32.810]                       invokeRestart <- base::invokeRestart
[16:05:32.810]                       is.null <- base::is.null
[16:05:32.810]                       muffled <- FALSE
[16:05:32.810]                       if (inherits(cond, "message")) {
[16:05:32.810]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:32.810]                         if (muffled) 
[16:05:32.810]                           invokeRestart("muffleMessage")
[16:05:32.810]                       }
[16:05:32.810]                       else if (inherits(cond, "warning")) {
[16:05:32.810]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:32.810]                         if (muffled) 
[16:05:32.810]                           invokeRestart("muffleWarning")
[16:05:32.810]                       }
[16:05:32.810]                       else if (inherits(cond, "condition")) {
[16:05:32.810]                         if (!is.null(pattern)) {
[16:05:32.810]                           computeRestarts <- base::computeRestarts
[16:05:32.810]                           grepl <- base::grepl
[16:05:32.810]                           restarts <- computeRestarts(cond)
[16:05:32.810]                           for (restart in restarts) {
[16:05:32.810]                             name <- restart$name
[16:05:32.810]                             if (is.null(name)) 
[16:05:32.810]                               next
[16:05:32.810]                             if (!grepl(pattern, name)) 
[16:05:32.810]                               next
[16:05:32.810]                             invokeRestart(restart)
[16:05:32.810]                             muffled <- TRUE
[16:05:32.810]                             break
[16:05:32.810]                           }
[16:05:32.810]                         }
[16:05:32.810]                       }
[16:05:32.810]                       invisible(muffled)
[16:05:32.810]                     }
[16:05:32.810]                     muffleCondition(cond, pattern = "^muffle")
[16:05:32.810]                   }
[16:05:32.810]                 }
[16:05:32.810]             }
[16:05:32.810]         }))
[16:05:32.810]     }, error = function(ex) {
[16:05:32.810]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:32.810]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:32.810]                 ...future.rng), started = ...future.startTime, 
[16:05:32.810]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:32.810]             version = "1.8"), class = "FutureResult")
[16:05:32.810]     }, finally = {
[16:05:32.810]         if (!identical(...future.workdir, getwd())) 
[16:05:32.810]             setwd(...future.workdir)
[16:05:32.810]         {
[16:05:32.810]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:32.810]                 ...future.oldOptions$nwarnings <- NULL
[16:05:32.810]             }
[16:05:32.810]             base::options(...future.oldOptions)
[16:05:32.810]             if (.Platform$OS.type == "windows") {
[16:05:32.810]                 old_names <- names(...future.oldEnvVars)
[16:05:32.810]                 envs <- base::Sys.getenv()
[16:05:32.810]                 names <- names(envs)
[16:05:32.810]                 common <- intersect(names, old_names)
[16:05:32.810]                 added <- setdiff(names, old_names)
[16:05:32.810]                 removed <- setdiff(old_names, names)
[16:05:32.810]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:32.810]                   envs[common]]
[16:05:32.810]                 NAMES <- toupper(changed)
[16:05:32.810]                 args <- list()
[16:05:32.810]                 for (kk in seq_along(NAMES)) {
[16:05:32.810]                   name <- changed[[kk]]
[16:05:32.810]                   NAME <- NAMES[[kk]]
[16:05:32.810]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.810]                     next
[16:05:32.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:32.810]                 }
[16:05:32.810]                 NAMES <- toupper(added)
[16:05:32.810]                 for (kk in seq_along(NAMES)) {
[16:05:32.810]                   name <- added[[kk]]
[16:05:32.810]                   NAME <- NAMES[[kk]]
[16:05:32.810]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.810]                     next
[16:05:32.810]                   args[[name]] <- ""
[16:05:32.810]                 }
[16:05:32.810]                 NAMES <- toupper(removed)
[16:05:32.810]                 for (kk in seq_along(NAMES)) {
[16:05:32.810]                   name <- removed[[kk]]
[16:05:32.810]                   NAME <- NAMES[[kk]]
[16:05:32.810]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.810]                     next
[16:05:32.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:32.810]                 }
[16:05:32.810]                 if (length(args) > 0) 
[16:05:32.810]                   base::do.call(base::Sys.setenv, args = args)
[16:05:32.810]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:32.810]             }
[16:05:32.810]             else {
[16:05:32.810]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:32.810]             }
[16:05:32.810]             {
[16:05:32.810]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:32.810]                   0L) {
[16:05:32.810]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:32.810]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:32.810]                   base::options(opts)
[16:05:32.810]                 }
[16:05:32.810]                 {
[16:05:32.810]                   {
[16:05:32.810]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:32.810]                     NULL
[16:05:32.810]                   }
[16:05:32.810]                   options(future.plan = NULL)
[16:05:32.810]                   if (is.na(NA_character_)) 
[16:05:32.810]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:32.810]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:32.810]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:32.810]                     envir = parent.frame()) 
[16:05:32.810]                   {
[16:05:32.810]                     default_workers <- missing(workers)
[16:05:32.810]                     if (is.function(workers)) 
[16:05:32.810]                       workers <- workers()
[16:05:32.810]                     workers <- structure(as.integer(workers), 
[16:05:32.810]                       class = class(workers))
[16:05:32.810]                     stop_if_not(is.finite(workers), workers >= 
[16:05:32.810]                       1L)
[16:05:32.810]                     if ((workers == 1L && !inherits(workers, 
[16:05:32.810]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:32.810]                       if (default_workers) 
[16:05:32.810]                         supportsMulticore(warn = TRUE)
[16:05:32.810]                       return(sequential(..., envir = envir))
[16:05:32.810]                     }
[16:05:32.810]                     oopts <- options(mc.cores = workers)
[16:05:32.810]                     on.exit(options(oopts))
[16:05:32.810]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:32.810]                       envir = envir)
[16:05:32.810]                     if (!future$lazy) 
[16:05:32.810]                       future <- run(future)
[16:05:32.810]                     invisible(future)
[16:05:32.810]                   }, b = function (..., envir = parent.frame()) 
[16:05:32.810]                   {
[16:05:32.810]                     future <- SequentialFuture(..., envir = envir)
[16:05:32.810]                     if (!future$lazy) 
[16:05:32.810]                       future <- run(future)
[16:05:32.810]                     invisible(future)
[16:05:32.810]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:32.810]                 }
[16:05:32.810]             }
[16:05:32.810]         }
[16:05:32.810]     })
[16:05:32.810]     if (TRUE) {
[16:05:32.810]         base::sink(type = "output", split = FALSE)
[16:05:32.810]         if (TRUE) {
[16:05:32.810]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:32.810]         }
[16:05:32.810]         else {
[16:05:32.810]             ...future.result["stdout"] <- base::list(NULL)
[16:05:32.810]         }
[16:05:32.810]         base::close(...future.stdout)
[16:05:32.810]         ...future.stdout <- NULL
[16:05:32.810]     }
[16:05:32.810]     ...future.result$conditions <- ...future.conditions
[16:05:32.810]     ...future.result$finished <- base::Sys.time()
[16:05:32.810]     ...future.result
[16:05:32.810] }
[16:05:32.812] assign_globals() ...
[16:05:32.812] List of 2
[16:05:32.812]  $ nested   :List of 2
[16:05:32.812]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:05:32.812]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:05:32.812]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:05:32.812]   ..$ b:function (..., envir = parent.frame())  
[16:05:32.812]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:05:32.812]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:05:32.812]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:05:32.812]  $ strategy2: chr "sequential"
[16:05:32.812]  - attr(*, "where")=List of 2
[16:05:32.812]   ..$ nested   :<environment: R_EmptyEnv> 
[16:05:32.812]   ..$ strategy2:<environment: R_EmptyEnv> 
[16:05:32.812]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:32.812]  - attr(*, "resolved")= logi FALSE
[16:05:32.812]  - attr(*, "total_size")= num 59224
[16:05:32.812]  - attr(*, "already-done")= logi TRUE
[16:05:32.817] - copied ‘nested’ to environment
[16:05:32.817] - copied ‘strategy2’ to environment
[16:05:32.817] assign_globals() ... done
[16:05:32.817] requestCore(): workers = 2
[16:05:32.820] MulticoreFuture started
[16:05:32.820] - Launch lazy future ... done
[16:05:32.820] run() for ‘MulticoreFuture’ ... done
[16:05:32.821] result() for MulticoreFuture ...
[16:05:32.821] plan(): Setting new future strategy stack:
[16:05:32.821] List of future strategies:
[16:05:32.821] 1. sequential:
[16:05:32.821]    - args: function (..., envir = parent.frame())
[16:05:32.821]    - tweaked: FALSE
[16:05:32.821]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:32.822] plan(): nbrOfWorkers() = 1
[16:05:32.858] plan(): Setting new future strategy stack:
[16:05:32.858] List of future strategies:
[16:05:32.858] 1. multicore:
[16:05:32.858]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:32.858]    - tweaked: FALSE
[16:05:32.858]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:32.858] 2. sequential:
[16:05:32.858]    - args: function (..., envir = parent.frame())
[16:05:32.858]    - tweaked: FALSE
[16:05:32.858]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:32.862] plan(): nbrOfWorkers() = 2
[16:05:32.864] result() for MulticoreFuture ...
[16:05:32.864] result() for MulticoreFuture ... done
[16:05:32.864] signalConditions() ...
[16:05:32.864]  - include = ‘immediateCondition’
[16:05:32.864]  - exclude = 
[16:05:32.864]  - resignal = FALSE
[16:05:32.864]  - Number of conditions: 54
[16:05:32.865] signalConditions() ... done
[16:05:32.865] result() for MulticoreFuture ... done
[16:05:32.865] result() for MulticoreFuture ...
[16:05:32.865] result() for MulticoreFuture ... done
[16:05:32.865] signalConditions() ...
[16:05:32.865]  - include = ‘immediateCondition’
[16:05:32.865]  - exclude = 
[16:05:32.865]  - resignal = FALSE
[16:05:32.865]  - Number of conditions: 54
[16:05:32.866] signalConditions() ... done
[16:05:32.866] Future state: ‘finished’
[16:05:32.866] result() for MulticoreFuture ...
[16:05:32.866] result() for MulticoreFuture ... done
[16:05:32.866] signalConditions() ...
[16:05:32.866]  - include = ‘condition’
[16:05:32.866]  - exclude = ‘immediateCondition’
[16:05:32.867]  - resignal = TRUE
[16:05:32.867]  - Number of conditions: 54
[16:05:32.867]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.824] getGlobalsAndPackages() ...
[16:05:32.867]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.824] Searching for globals...
[16:05:32.867]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.834] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[16:05:32.867]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.834] Searching for globals ... DONE
[16:05:32.868]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.834] Resolving globals: FALSE
[16:05:32.868]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.835] The total size of the 3 globals is 22.54 KiB (23080 bytes)
[16:05:32.868]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.836] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 22.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (11.24 KiB of class ‘list’), ‘plan_a’ (11.24 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[16:05:32.868]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.836] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[16:05:32.868]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.837] 
[16:05:32.869]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.837] getGlobalsAndPackages() ... DONE
[16:05:32.869]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.838] run() for ‘Future’ ...
[16:05:32.869]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.838] - state: ‘created’
[16:05:32.869]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.838] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:32.869]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.839] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:32.869]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.839] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:32.870]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.839]   - Field: ‘label’
[16:05:32.870]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.839]   - Field: ‘local’
[16:05:32.870]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.839]   - Field: ‘owner’
[16:05:32.870]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.839]   - Field: ‘envir’
[16:05:32.870]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.840]   - Field: ‘packages’
[16:05:32.871]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.840]   - Field: ‘gc’
[16:05:32.871]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.840]   - Field: ‘conditions’
[16:05:32.871]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.840]   - Field: ‘expr’
[16:05:32.871]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.840]   - Field: ‘uuid’
[16:05:32.871]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.840]   - Field: ‘seed’
[16:05:32.872]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.841]   - Field: ‘version’
[16:05:32.872]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.841]   - Field: ‘result’
[16:05:32.872]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.841]   - Field: ‘asynchronous’
[16:05:32.872]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.841]   - Field: ‘calls’
[16:05:32.872]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.841]   - Field: ‘globals’
[16:05:32.873]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.841]   - Field: ‘stdout’
[16:05:32.873]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.842]   - Field: ‘earlySignal’
[16:05:32.873]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.842]   - Field: ‘lazy’
[16:05:32.873]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.842]   - Field: ‘state’
[16:05:32.873]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.842] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:32.873]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.842] - Launch lazy future ...
[16:05:32.874]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.843] Packages needed by the future expression (n = 0): <none>
[16:05:32.874]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.843] Packages needed by future strategies (n = 0): <none>
[16:05:32.874]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.843] {
[16:05:32.843]     {
[16:05:32.843]         {
[16:05:32.843]             ...future.startTime <- base::Sys.time()
[16:05:32.843]             {
[16:05:32.843]                 {
[16:05:32.843]                   {
[16:05:32.843]                     base::local({
[16:05:32.843]                       has_future <- base::requireNamespace("future", 
[16:05:32.843]                         quietly = TRUE)
[16:05:32.843]                       if (has_future) {
[16:05:32.843]                         ns <- base::getNamespace("future")
[16:05:32.843]                         version <- ns[[".package"]][["version"]]
[16:05:32.843]                         if (is.null(version)) 
[16:05:32.843]                           version <- utils::packageVersion("future")
[16:05:32.843]                       }
[16:05:32.843]                       else {
[16:05:32.843]                         version <- NULL
[16:05:32.843]                       }
[16:05:32.843]                       if (!has_future || version < "1.8.0") {
[16:05:32.843]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:32.843]                           "", base::R.version$version.string), 
[16:05:32.843]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:32.843]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:32.843]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:32.843]                             "release", "version")], collapse = " "), 
[16:05:32.843]                           hostname = base::Sys.info()[["nodename"]])
[16:05:32.843]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:32.843]                           info)
[16:05:32.843]                         info <- base::paste(info, collapse = "; ")
[16:05:32.843]                         if (!has_future) {
[16:05:32.843]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:32.843]                             info)
[16:05:32.843]                         }
[16:05:32.843]                         else {
[16:05:32.843]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:32.843]                             info, version)
[16:05:32.843]                         }
[16:05:32.843]                         base::stop(msg)
[16:05:32.843]                       }
[16:05:32.843]                     })
[16:05:32.843]                   }
[16:05:32.843]                   options(future.plan = NULL)
[16:05:32.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:32.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:32.843]                 }
[16:05:32.843]                 ...future.workdir <- getwd()
[16:05:32.843]             }
[16:05:32.843]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:32.843]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:32.843]         }
[16:05:32.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:32.843]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:32.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:32.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:32.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:32.843]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:32.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:32.843]             base::names(...future.oldOptions))
[16:05:32.843]     }
[16:05:32.843]     if (FALSE) {
[16:05:32.843]     }
[16:05:32.843]     else {
[16:05:32.843]         if (TRUE) {
[16:05:32.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:32.843]                 open = "w")
[16:05:32.843]         }
[16:05:32.843]         else {
[16:05:32.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:32.843]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:32.843]         }
[16:05:32.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:32.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:32.843]             base::sink(type = "output", split = FALSE)
[16:05:32.843]             base::close(...future.stdout)
[16:05:32.843]         }, add = TRUE)
[16:05:32.843]     }
[16:05:32.843]     ...future.frame <- base::sys.nframe()
[16:05:32.843]     ...future.conditions <- base::list()
[16:05:32.843]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:32.843]     if (FALSE) {
[16:05:32.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:32.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:32.843]     }
[16:05:32.843]     ...future.result <- base::tryCatch({
[16:05:32.843]         base::withCallingHandlers({
[16:05:32.843]             ...future.value <- base::withVisible(base::local({
[16:05:32.843]                 b <- 2L
[16:05:32.843]                 plan_b <- future::plan("list")
[16:05:32.843]                 nested_b <- nested_a[-1]
[16:05:32.843]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:05:32.843]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:05:32.843]                   "sequential"))
[16:05:32.843]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:05:32.843]                   b = b, nested_b = nested_b, plan_b = plan_b)
[16:05:32.843]             }))
[16:05:32.843]             future::FutureResult(value = ...future.value$value, 
[16:05:32.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:32.843]                   ...future.rng), globalenv = if (FALSE) 
[16:05:32.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:32.843]                     ...future.globalenv.names))
[16:05:32.843]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:32.843]         }, condition = base::local({
[16:05:32.843]             c <- base::c
[16:05:32.843]             inherits <- base::inherits
[16:05:32.843]             invokeRestart <- base::invokeRestart
[16:05:32.843]             length <- base::length
[16:05:32.843]             list <- base::list
[16:05:32.843]             seq.int <- base::seq.int
[16:05:32.843]             signalCondition <- base::signalCondition
[16:05:32.843]             sys.calls <- base::sys.calls
[16:05:32.843]             `[[` <- base::`[[`
[16:05:32.843]             `+` <- base::`+`
[16:05:32.843]             `<<-` <- base::`<<-`
[16:05:32.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:32.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:32.843]                   3L)]
[16:05:32.843]             }
[16:05:32.843]             function(cond) {
[16:05:32.843]                 is_error <- inherits(cond, "error")
[16:05:32.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:32.843]                   NULL)
[16:05:32.843]                 if (is_error) {
[16:05:32.843]                   sessionInformation <- function() {
[16:05:32.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:32.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:32.843]                       search = base::search(), system = base::Sys.info())
[16:05:32.843]                   }
[16:05:32.843]                   ...future.conditions[[length(...future.conditions) + 
[16:05:32.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:32.843]                     cond$call), session = sessionInformation(), 
[16:05:32.843]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:32.843]                   signalCondition(cond)
[16:05:32.843]                 }
[16:05:32.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:32.843]                 "immediateCondition"))) {
[16:05:32.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:32.843]                   ...future.conditions[[length(...future.conditions) + 
[16:05:32.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:32.843]                   if (TRUE && !signal) {
[16:05:32.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:32.843]                     {
[16:05:32.843]                       inherits <- base::inherits
[16:05:32.843]                       invokeRestart <- base::invokeRestart
[16:05:32.843]                       is.null <- base::is.null
[16:05:32.843]                       muffled <- FALSE
[16:05:32.843]                       if (inherits(cond, "message")) {
[16:05:32.843]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:32.843]                         if (muffled) 
[16:05:32.843]                           invokeRestart("muffleMessage")
[16:05:32.843]                       }
[16:05:32.843]                       else if (inherits(cond, "warning")) {
[16:05:32.843]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:32.843]                         if (muffled) 
[16:05:32.843]                           invokeRestart("muffleWarning")
[16:05:32.843]                       }
[16:05:32.843]                       else if (inherits(cond, "condition")) {
[16:05:32.843]                         if (!is.null(pattern)) {
[16:05:32.843]                           computeRestarts <- base::computeRestarts
[16:05:32.843]                           grepl <- base::grepl
[16:05:32.843]                           restarts <- computeRestarts(cond)
[16:05:32.843]                           for (restart in restarts) {
[16:05:32.843]                             name <- restart$name
[16:05:32.843]                             if (is.null(name)) 
[16:05:32.843]                               next
[16:05:32.843]                             if (!grepl(pattern, name)) 
[16:05:32.843]                               next
[16:05:32.843]                             invokeRestart(restart)
[16:05:32.843]                             muffled <- TRUE
[16:05:32.843]                             break
[16:05:32.843]                           }
[16:05:32.843]                         }
[16:05:32.843]                       }
[16:05:32.843]                       invisible(muffled)
[16:05:32.843]                     }
[16:05:32.843]                     muffleCondition(cond, pattern = "^muffle")
[16:05:32.843]                   }
[16:05:32.843]                 }
[16:05:32.843]                 else {
[16:05:32.843]                   if (TRUE) {
[16:05:32.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:32.843]                     {
[16:05:32.843]                       inherits <- base::inherits
[16:05:32.843]                       invokeRestart <- base::invokeRestart
[16:05:32.843]                       is.null <- base::is.null
[16:05:32.843]                       muffled <- FALSE
[16:05:32.843]                       if (inherits(cond, "message")) {
[16:05:32.843]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:32.843]                         if (muffled) 
[16:05:32.843]                           invokeRestart("muffleMessage")
[16:05:32.843]                       }
[16:05:32.843]                       else if (inherits(cond, "warning")) {
[16:05:32.843]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:32.843]                         if (muffled) 
[16:05:32.843]                           invokeRestart("muffleWarning")
[16:05:32.843]                       }
[16:05:32.843]                       else if (inherits(cond, "condition")) {
[16:05:32.843]                         if (!is.null(pattern)) {
[16:05:32.843]                           computeRestarts <- base::computeRestarts
[16:05:32.843]                           grepl <- base::grepl
[16:05:32.843]                           restarts <- computeRestarts(cond)
[16:05:32.843]                           for (restart in restarts) {
[16:05:32.843]                             name <- restart$name
[16:05:32.843]                             if (is.null(name)) 
[16:05:32.843]                               next
[16:05:32.843]                             if (!grepl(pattern, name)) 
[16:05:32.843]                               next
[16:05:32.843]                             invokeRestart(restart)
[16:05:32.843]                             muffled <- TRUE
[16:05:32.843]                             break
[16:05:32.843]                           }
[16:05:32.843]                         }
[16:05:32.843]                       }
[16:05:32.843]                       invisible(muffled)
[16:05:32.843]                     }
[16:05:32.843]                     muffleCondition(cond, pattern = "^muffle")
[16:05:32.843]                   }
[16:05:32.843]                 }
[16:05:32.843]             }
[16:05:32.843]         }))
[16:05:32.843]     }, error = function(ex) {
[16:05:32.843]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:32.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:32.843]                 ...future.rng), started = ...future.startTime, 
[16:05:32.843]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:32.843]             version = "1.8"), class = "FutureResult")
[16:05:32.843]     }, finally = {
[16:05:32.843]         if (!identical(...future.workdir, getwd())) 
[16:05:32.843]             setwd(...future.workdir)
[16:05:32.843]         {
[16:05:32.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:32.843]                 ...future.oldOptions$nwarnings <- NULL
[16:05:32.843]             }
[16:05:32.843]             base::options(...future.oldOptions)
[16:05:32.843]             if (.Platform$OS.type == "windows") {
[16:05:32.843]                 old_names <- names(...future.oldEnvVars)
[16:05:32.843]                 envs <- base::Sys.getenv()
[16:05:32.843]                 names <- names(envs)
[16:05:32.843]                 common <- intersect(names, old_names)
[16:05:32.843]                 added <- setdiff(names, old_names)
[16:05:32.843]                 removed <- setdiff(old_names, names)
[16:05:32.843]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:32.843]                   envs[common]]
[16:05:32.843]                 NAMES <- toupper(changed)
[16:05:32.843]                 args <- list()
[16:05:32.843]                 for (kk in seq_along(NAMES)) {
[16:05:32.843]                   name <- changed[[kk]]
[16:05:32.843]                   NAME <- NAMES[[kk]]
[16:05:32.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.843]                     next
[16:05:32.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:32.843]                 }
[16:05:32.843]                 NAMES <- toupper(added)
[16:05:32.843]                 for (kk in seq_along(NAMES)) {
[16:05:32.843]                   name <- added[[kk]]
[16:05:32.843]                   NAME <- NAMES[[kk]]
[16:05:32.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.843]                     next
[16:05:32.843]                   args[[name]] <- ""
[16:05:32.843]                 }
[16:05:32.843]                 NAMES <- toupper(removed)
[16:05:32.843]                 for (kk in seq_along(NAMES)) {
[16:05:32.843]                   name <- removed[[kk]]
[16:05:32.843]                   NAME <- NAMES[[kk]]
[16:05:32.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.843]                     next
[16:05:32.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:32.843]                 }
[16:05:32.843]                 if (length(args) > 0) 
[16:05:32.843]                   base::do.call(base::Sys.setenv, args = args)
[16:05:32.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:32.843]             }
[16:05:32.843]             else {
[16:05:32.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:32.843]             }
[16:05:32.843]             {
[16:05:32.843]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:32.843]                   0L) {
[16:05:32.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:32.843]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:32.843]                   base::options(opts)
[16:05:32.843]                 }
[16:05:32.843]                 {
[16:05:32.843]                   {
[16:05:32.843]                     NULL
[16:05:32.843]                     RNGkind("Mersenne-Twister")
[16:05:32.843]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:32.843]                       inherits = FALSE)
[16:05:32.843]                   }
[16:05:32.843]                   options(future.plan = NULL)
[16:05:32.843]                   if (is.na(NA_character_)) 
[16:05:32.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:32.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:32.843]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:05:32.843]                   {
[16:05:32.843]                     future <- SequentialFuture(..., envir = envir)
[16:05:32.843]                     if (!future$lazy) 
[16:05:32.843]                       future <- run(future)
[16:05:32.843]                     invisible(future)
[16:05:32.843]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:32.843]                 }
[16:05:32.843]             }
[16:05:32.843]         }
[16:05:32.843]     })
[16:05:32.843]     if (TRUE) {
[16:05:32.843]         base::sink(type = "output", split = FALSE)
[16:05:32.843]         if (TRUE) {
[16:05:32.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:32.843]         }
[16:05:32.843]         else {
[16:05:32.843]             ...future.result["stdout"] <- base::list(NULL)
[16:05:32.843]         }
[16:05:32.843]         base::close(...future.stdout)
[16:05:32.843]         ...future.stdout <- NULL
[16:05:32.843]     }
[16:05:32.843]     ...future.result$conditions <- ...future.conditions
[16:05:32.843]     ...future.result$finished <- base::Sys.time()
[16:05:32.843]     ...future.result
[16:05:32.843] }
[16:05:32.874]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.846] assign_globals() ...
[16:05:32.874]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.846] List of 3
[16:05:32.846]  $ nested_a:List of 1
[16:05:32.846]   ..$ b:function (..., envir = parent.frame())  
[16:05:32.846]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:05:32.846]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:05:32.846]  $ a       : int 1
[16:05:32.846]  $ plan_a  :List of 1
[16:05:32.846]   ..$ b:function (..., envir = parent.frame())  
[16:05:32.846]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:05:32.846]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:05:32.846]  - attr(*, "where")=List of 3
[16:05:32.846]   ..$ nested_a:<environment: R_EmptyEnv> 
[16:05:32.846]   ..$ a       :<environment: R_EmptyEnv> 
[16:05:32.846]   ..$ plan_a  :<environment: R_EmptyEnv> 
[16:05:32.846]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:32.846]  - attr(*, "resolved")= logi FALSE
[16:05:32.846]  - attr(*, "total_size")= num 23080
[16:05:32.846]  - attr(*, "already-done")= logi TRUE
[16:05:32.874]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.853] - copied ‘nested_a’ to environment
[16:05:32.875]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.854] - copied ‘a’ to environment
[16:05:32.875]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.854] - copied ‘plan_a’ to environment
[16:05:32.875]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.854] assign_globals() ... done
[16:05:32.875]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.854] plan(): Setting new future strategy stack:
[16:05:32.875]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.854] List of future strategies:
[16:05:32.854] 1. sequential:
[16:05:32.854]    - args: function (..., envir = parent.frame())
[16:05:32.854]    - tweaked: FALSE
[16:05:32.854]    - call: NULL
[16:05:32.876]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.855] plan(): nbrOfWorkers() = 1
[16:05:32.876]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.856] plan(): Setting new future strategy stack:
[16:05:32.876]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.856] List of future strategies:
[16:05:32.856] 1. sequential:
[16:05:32.856]    - args: function (..., envir = parent.frame())
[16:05:32.856]    - tweaked: FALSE
[16:05:32.856]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:32.876]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.857] plan(): nbrOfWorkers() = 1
[16:05:32.876]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.857] SequentialFuture started (and completed)
[16:05:32.876]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.857] - Launch lazy future ... done
[16:05:32.877]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.857] run() for ‘SequentialFuture’ ... done
[16:05:32.877] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:05:32.883] getGlobalsAndPackages() ...
[16:05:32.883] Searching for globals...
[16:05:32.884] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:05:32.885] Searching for globals ... DONE
[16:05:32.885] Resolving globals: FALSE
[16:05:32.885] The total size of the 1 globals is 128 bytes (128 bytes)
[16:05:32.886] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:05:32.886] - globals: [1] ‘data’
[16:05:32.886] - packages: [1] ‘future’
[16:05:32.886] getGlobalsAndPackages() ... DONE
[16:05:32.887] run() for ‘Future’ ...
[16:05:32.887] - state: ‘created’
[16:05:32.887] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:32.891] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:32.891] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:32.891]   - Field: ‘label’
[16:05:32.891]   - Field: ‘local’
[16:05:32.891]   - Field: ‘owner’
[16:05:32.891]   - Field: ‘envir’
[16:05:32.892]   - Field: ‘workers’
[16:05:32.892]   - Field: ‘packages’
[16:05:32.892]   - Field: ‘gc’
[16:05:32.892]   - Field: ‘job’
[16:05:32.892]   - Field: ‘conditions’
[16:05:32.892]   - Field: ‘expr’
[16:05:32.892]   - Field: ‘uuid’
[16:05:32.892]   - Field: ‘seed’
[16:05:32.892]   - Field: ‘version’
[16:05:32.893]   - Field: ‘result’
[16:05:32.893]   - Field: ‘asynchronous’
[16:05:32.893]   - Field: ‘calls’
[16:05:32.893]   - Field: ‘globals’
[16:05:32.893]   - Field: ‘stdout’
[16:05:32.893]   - Field: ‘earlySignal’
[16:05:32.893]   - Field: ‘lazy’
[16:05:32.893]   - Field: ‘state’
[16:05:32.893] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:32.894] - Launch lazy future ...
[16:05:32.894] Packages needed by the future expression (n = 1): ‘future’
[16:05:32.894] Packages needed by future strategies (n = 1): ‘future’
[16:05:32.895] {
[16:05:32.895]     {
[16:05:32.895]         {
[16:05:32.895]             ...future.startTime <- base::Sys.time()
[16:05:32.895]             {
[16:05:32.895]                 {
[16:05:32.895]                   {
[16:05:32.895]                     {
[16:05:32.895]                       {
[16:05:32.895]                         base::local({
[16:05:32.895]                           has_future <- base::requireNamespace("future", 
[16:05:32.895]                             quietly = TRUE)
[16:05:32.895]                           if (has_future) {
[16:05:32.895]                             ns <- base::getNamespace("future")
[16:05:32.895]                             version <- ns[[".package"]][["version"]]
[16:05:32.895]                             if (is.null(version)) 
[16:05:32.895]                               version <- utils::packageVersion("future")
[16:05:32.895]                           }
[16:05:32.895]                           else {
[16:05:32.895]                             version <- NULL
[16:05:32.895]                           }
[16:05:32.895]                           if (!has_future || version < "1.8.0") {
[16:05:32.895]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:32.895]                               "", base::R.version$version.string), 
[16:05:32.895]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:32.895]                                 base::R.version$platform, 8 * 
[16:05:32.895]                                   base::.Machine$sizeof.pointer), 
[16:05:32.895]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:32.895]                                 "release", "version")], collapse = " "), 
[16:05:32.895]                               hostname = base::Sys.info()[["nodename"]])
[16:05:32.895]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:32.895]                               info)
[16:05:32.895]                             info <- base::paste(info, collapse = "; ")
[16:05:32.895]                             if (!has_future) {
[16:05:32.895]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:32.895]                                 info)
[16:05:32.895]                             }
[16:05:32.895]                             else {
[16:05:32.895]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:32.895]                                 info, version)
[16:05:32.895]                             }
[16:05:32.895]                             base::stop(msg)
[16:05:32.895]                           }
[16:05:32.895]                         })
[16:05:32.895]                       }
[16:05:32.895]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:32.895]                       base::options(mc.cores = 1L)
[16:05:32.895]                     }
[16:05:32.895]                     base::local({
[16:05:32.895]                       for (pkg in "future") {
[16:05:32.895]                         base::loadNamespace(pkg)
[16:05:32.895]                         base::library(pkg, character.only = TRUE)
[16:05:32.895]                       }
[16:05:32.895]                     })
[16:05:32.895]                   }
[16:05:32.895]                   options(future.plan = NULL)
[16:05:32.895]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:32.895]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:05:32.895]                   {
[16:05:32.895]                     future <- SequentialFuture(..., envir = envir)
[16:05:32.895]                     if (!future$lazy) 
[16:05:32.895]                       future <- run(future)
[16:05:32.895]                     invisible(future)
[16:05:32.895]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:32.895]                 }
[16:05:32.895]                 ...future.workdir <- getwd()
[16:05:32.895]             }
[16:05:32.895]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:32.895]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:32.895]         }
[16:05:32.895]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:32.895]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:32.895]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:32.895]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:32.895]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:32.895]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:32.895]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:32.895]             base::names(...future.oldOptions))
[16:05:32.895]     }
[16:05:32.895]     if (FALSE) {
[16:05:32.895]     }
[16:05:32.895]     else {
[16:05:32.895]         if (TRUE) {
[16:05:32.895]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:32.895]                 open = "w")
[16:05:32.895]         }
[16:05:32.895]         else {
[16:05:32.895]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:32.895]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:32.895]         }
[16:05:32.895]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:32.895]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:32.895]             base::sink(type = "output", split = FALSE)
[16:05:32.895]             base::close(...future.stdout)
[16:05:32.895]         }, add = TRUE)
[16:05:32.895]     }
[16:05:32.895]     ...future.frame <- base::sys.nframe()
[16:05:32.895]     ...future.conditions <- base::list()
[16:05:32.895]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:32.895]     if (FALSE) {
[16:05:32.895]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:32.895]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:32.895]     }
[16:05:32.895]     ...future.result <- base::tryCatch({
[16:05:32.895]         base::withCallingHandlers({
[16:05:32.895]             ...future.value <- base::withVisible(base::local({
[16:05:32.895]                 withCallingHandlers({
[16:05:32.895]                   {
[16:05:32.895]                     value(future(subset(data, a == 2)))
[16:05:32.895]                   }
[16:05:32.895]                 }, immediateCondition = function(cond) {
[16:05:32.895]                   save_rds <- function (object, pathname, ...) 
[16:05:32.895]                   {
[16:05:32.895]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:32.895]                     if (file_test("-f", pathname_tmp)) {
[16:05:32.895]                       fi_tmp <- file.info(pathname_tmp)
[16:05:32.895]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:32.895]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:32.895]                         fi_tmp[["mtime"]])
[16:05:32.895]                     }
[16:05:32.895]                     tryCatch({
[16:05:32.895]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:32.895]                     }, error = function(ex) {
[16:05:32.895]                       msg <- conditionMessage(ex)
[16:05:32.895]                       fi_tmp <- file.info(pathname_tmp)
[16:05:32.895]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:32.895]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:32.895]                         fi_tmp[["mtime"]], msg)
[16:05:32.895]                       ex$message <- msg
[16:05:32.895]                       stop(ex)
[16:05:32.895]                     })
[16:05:32.895]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:32.895]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:32.895]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:32.895]                       fi_tmp <- file.info(pathname_tmp)
[16:05:32.895]                       fi <- file.info(pathname)
[16:05:32.895]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:32.895]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:32.895]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:32.895]                         fi[["size"]], fi[["mtime"]])
[16:05:32.895]                       stop(msg)
[16:05:32.895]                     }
[16:05:32.895]                     invisible(pathname)
[16:05:32.895]                   }
[16:05:32.895]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:32.895]                     rootPath = tempdir()) 
[16:05:32.895]                   {
[16:05:32.895]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:32.895]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:32.895]                       tmpdir = path, fileext = ".rds")
[16:05:32.895]                     save_rds(obj, file)
[16:05:32.895]                   }
[16:05:32.895]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0EbAi0/.future/immediateConditions")
[16:05:32.895]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:32.895]                   {
[16:05:32.895]                     inherits <- base::inherits
[16:05:32.895]                     invokeRestart <- base::invokeRestart
[16:05:32.895]                     is.null <- base::is.null
[16:05:32.895]                     muffled <- FALSE
[16:05:32.895]                     if (inherits(cond, "message")) {
[16:05:32.895]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:32.895]                       if (muffled) 
[16:05:32.895]                         invokeRestart("muffleMessage")
[16:05:32.895]                     }
[16:05:32.895]                     else if (inherits(cond, "warning")) {
[16:05:32.895]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:32.895]                       if (muffled) 
[16:05:32.895]                         invokeRestart("muffleWarning")
[16:05:32.895]                     }
[16:05:32.895]                     else if (inherits(cond, "condition")) {
[16:05:32.895]                       if (!is.null(pattern)) {
[16:05:32.895]                         computeRestarts <- base::computeRestarts
[16:05:32.895]                         grepl <- base::grepl
[16:05:32.895]                         restarts <- computeRestarts(cond)
[16:05:32.895]                         for (restart in restarts) {
[16:05:32.895]                           name <- restart$name
[16:05:32.895]                           if (is.null(name)) 
[16:05:32.895]                             next
[16:05:32.895]                           if (!grepl(pattern, name)) 
[16:05:32.895]                             next
[16:05:32.895]                           invokeRestart(restart)
[16:05:32.895]                           muffled <- TRUE
[16:05:32.895]                           break
[16:05:32.895]                         }
[16:05:32.895]                       }
[16:05:32.895]                     }
[16:05:32.895]                     invisible(muffled)
[16:05:32.895]                   }
[16:05:32.895]                   muffleCondition(cond)
[16:05:32.895]                 })
[16:05:32.895]             }))
[16:05:32.895]             future::FutureResult(value = ...future.value$value, 
[16:05:32.895]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:32.895]                   ...future.rng), globalenv = if (FALSE) 
[16:05:32.895]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:32.895]                     ...future.globalenv.names))
[16:05:32.895]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:32.895]         }, condition = base::local({
[16:05:32.895]             c <- base::c
[16:05:32.895]             inherits <- base::inherits
[16:05:32.895]             invokeRestart <- base::invokeRestart
[16:05:32.895]             length <- base::length
[16:05:32.895]             list <- base::list
[16:05:32.895]             seq.int <- base::seq.int
[16:05:32.895]             signalCondition <- base::signalCondition
[16:05:32.895]             sys.calls <- base::sys.calls
[16:05:32.895]             `[[` <- base::`[[`
[16:05:32.895]             `+` <- base::`+`
[16:05:32.895]             `<<-` <- base::`<<-`
[16:05:32.895]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:32.895]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:32.895]                   3L)]
[16:05:32.895]             }
[16:05:32.895]             function(cond) {
[16:05:32.895]                 is_error <- inherits(cond, "error")
[16:05:32.895]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:32.895]                   NULL)
[16:05:32.895]                 if (is_error) {
[16:05:32.895]                   sessionInformation <- function() {
[16:05:32.895]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:32.895]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:32.895]                       search = base::search(), system = base::Sys.info())
[16:05:32.895]                   }
[16:05:32.895]                   ...future.conditions[[length(...future.conditions) + 
[16:05:32.895]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:32.895]                     cond$call), session = sessionInformation(), 
[16:05:32.895]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:32.895]                   signalCondition(cond)
[16:05:32.895]                 }
[16:05:32.895]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:32.895]                 "immediateCondition"))) {
[16:05:32.895]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:32.895]                   ...future.conditions[[length(...future.conditions) + 
[16:05:32.895]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:32.895]                   if (TRUE && !signal) {
[16:05:32.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:32.895]                     {
[16:05:32.895]                       inherits <- base::inherits
[16:05:32.895]                       invokeRestart <- base::invokeRestart
[16:05:32.895]                       is.null <- base::is.null
[16:05:32.895]                       muffled <- FALSE
[16:05:32.895]                       if (inherits(cond, "message")) {
[16:05:32.895]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:32.895]                         if (muffled) 
[16:05:32.895]                           invokeRestart("muffleMessage")
[16:05:32.895]                       }
[16:05:32.895]                       else if (inherits(cond, "warning")) {
[16:05:32.895]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:32.895]                         if (muffled) 
[16:05:32.895]                           invokeRestart("muffleWarning")
[16:05:32.895]                       }
[16:05:32.895]                       else if (inherits(cond, "condition")) {
[16:05:32.895]                         if (!is.null(pattern)) {
[16:05:32.895]                           computeRestarts <- base::computeRestarts
[16:05:32.895]                           grepl <- base::grepl
[16:05:32.895]                           restarts <- computeRestarts(cond)
[16:05:32.895]                           for (restart in restarts) {
[16:05:32.895]                             name <- restart$name
[16:05:32.895]                             if (is.null(name)) 
[16:05:32.895]                               next
[16:05:32.895]                             if (!grepl(pattern, name)) 
[16:05:32.895]                               next
[16:05:32.895]                             invokeRestart(restart)
[16:05:32.895]                             muffled <- TRUE
[16:05:32.895]                             break
[16:05:32.895]                           }
[16:05:32.895]                         }
[16:05:32.895]                       }
[16:05:32.895]                       invisible(muffled)
[16:05:32.895]                     }
[16:05:32.895]                     muffleCondition(cond, pattern = "^muffle")
[16:05:32.895]                   }
[16:05:32.895]                 }
[16:05:32.895]                 else {
[16:05:32.895]                   if (TRUE) {
[16:05:32.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:32.895]                     {
[16:05:32.895]                       inherits <- base::inherits
[16:05:32.895]                       invokeRestart <- base::invokeRestart
[16:05:32.895]                       is.null <- base::is.null
[16:05:32.895]                       muffled <- FALSE
[16:05:32.895]                       if (inherits(cond, "message")) {
[16:05:32.895]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:32.895]                         if (muffled) 
[16:05:32.895]                           invokeRestart("muffleMessage")
[16:05:32.895]                       }
[16:05:32.895]                       else if (inherits(cond, "warning")) {
[16:05:32.895]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:32.895]                         if (muffled) 
[16:05:32.895]                           invokeRestart("muffleWarning")
[16:05:32.895]                       }
[16:05:32.895]                       else if (inherits(cond, "condition")) {
[16:05:32.895]                         if (!is.null(pattern)) {
[16:05:32.895]                           computeRestarts <- base::computeRestarts
[16:05:32.895]                           grepl <- base::grepl
[16:05:32.895]                           restarts <- computeRestarts(cond)
[16:05:32.895]                           for (restart in restarts) {
[16:05:32.895]                             name <- restart$name
[16:05:32.895]                             if (is.null(name)) 
[16:05:32.895]                               next
[16:05:32.895]                             if (!grepl(pattern, name)) 
[16:05:32.895]                               next
[16:05:32.895]                             invokeRestart(restart)
[16:05:32.895]                             muffled <- TRUE
[16:05:32.895]                             break
[16:05:32.895]                           }
[16:05:32.895]                         }
[16:05:32.895]                       }
[16:05:32.895]                       invisible(muffled)
[16:05:32.895]                     }
[16:05:32.895]                     muffleCondition(cond, pattern = "^muffle")
[16:05:32.895]                   }
[16:05:32.895]                 }
[16:05:32.895]             }
[16:05:32.895]         }))
[16:05:32.895]     }, error = function(ex) {
[16:05:32.895]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:32.895]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:32.895]                 ...future.rng), started = ...future.startTime, 
[16:05:32.895]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:32.895]             version = "1.8"), class = "FutureResult")
[16:05:32.895]     }, finally = {
[16:05:32.895]         if (!identical(...future.workdir, getwd())) 
[16:05:32.895]             setwd(...future.workdir)
[16:05:32.895]         {
[16:05:32.895]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:32.895]                 ...future.oldOptions$nwarnings <- NULL
[16:05:32.895]             }
[16:05:32.895]             base::options(...future.oldOptions)
[16:05:32.895]             if (.Platform$OS.type == "windows") {
[16:05:32.895]                 old_names <- names(...future.oldEnvVars)
[16:05:32.895]                 envs <- base::Sys.getenv()
[16:05:32.895]                 names <- names(envs)
[16:05:32.895]                 common <- intersect(names, old_names)
[16:05:32.895]                 added <- setdiff(names, old_names)
[16:05:32.895]                 removed <- setdiff(old_names, names)
[16:05:32.895]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:32.895]                   envs[common]]
[16:05:32.895]                 NAMES <- toupper(changed)
[16:05:32.895]                 args <- list()
[16:05:32.895]                 for (kk in seq_along(NAMES)) {
[16:05:32.895]                   name <- changed[[kk]]
[16:05:32.895]                   NAME <- NAMES[[kk]]
[16:05:32.895]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.895]                     next
[16:05:32.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:32.895]                 }
[16:05:32.895]                 NAMES <- toupper(added)
[16:05:32.895]                 for (kk in seq_along(NAMES)) {
[16:05:32.895]                   name <- added[[kk]]
[16:05:32.895]                   NAME <- NAMES[[kk]]
[16:05:32.895]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.895]                     next
[16:05:32.895]                   args[[name]] <- ""
[16:05:32.895]                 }
[16:05:32.895]                 NAMES <- toupper(removed)
[16:05:32.895]                 for (kk in seq_along(NAMES)) {
[16:05:32.895]                   name <- removed[[kk]]
[16:05:32.895]                   NAME <- NAMES[[kk]]
[16:05:32.895]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.895]                     next
[16:05:32.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:32.895]                 }
[16:05:32.895]                 if (length(args) > 0) 
[16:05:32.895]                   base::do.call(base::Sys.setenv, args = args)
[16:05:32.895]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:32.895]             }
[16:05:32.895]             else {
[16:05:32.895]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:32.895]             }
[16:05:32.895]             {
[16:05:32.895]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:32.895]                   0L) {
[16:05:32.895]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:32.895]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:32.895]                   base::options(opts)
[16:05:32.895]                 }
[16:05:32.895]                 {
[16:05:32.895]                   {
[16:05:32.895]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:32.895]                     NULL
[16:05:32.895]                   }
[16:05:32.895]                   options(future.plan = NULL)
[16:05:32.895]                   if (is.na(NA_character_)) 
[16:05:32.895]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:32.895]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:32.895]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:32.895]                     envir = parent.frame()) 
[16:05:32.895]                   {
[16:05:32.895]                     default_workers <- missing(workers)
[16:05:32.895]                     if (is.function(workers)) 
[16:05:32.895]                       workers <- workers()
[16:05:32.895]                     workers <- structure(as.integer(workers), 
[16:05:32.895]                       class = class(workers))
[16:05:32.895]                     stop_if_not(is.finite(workers), workers >= 
[16:05:32.895]                       1L)
[16:05:32.895]                     if ((workers == 1L && !inherits(workers, 
[16:05:32.895]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:32.895]                       if (default_workers) 
[16:05:32.895]                         supportsMulticore(warn = TRUE)
[16:05:32.895]                       return(sequential(..., envir = envir))
[16:05:32.895]                     }
[16:05:32.895]                     oopts <- options(mc.cores = workers)
[16:05:32.895]                     on.exit(options(oopts))
[16:05:32.895]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:32.895]                       envir = envir)
[16:05:32.895]                     if (!future$lazy) 
[16:05:32.895]                       future <- run(future)
[16:05:32.895]                     invisible(future)
[16:05:32.895]                   }, b = function (..., envir = parent.frame()) 
[16:05:32.895]                   {
[16:05:32.895]                     future <- SequentialFuture(..., envir = envir)
[16:05:32.895]                     if (!future$lazy) 
[16:05:32.895]                       future <- run(future)
[16:05:32.895]                     invisible(future)
[16:05:32.895]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:32.895]                 }
[16:05:32.895]             }
[16:05:32.895]         }
[16:05:32.895]     })
[16:05:32.895]     if (TRUE) {
[16:05:32.895]         base::sink(type = "output", split = FALSE)
[16:05:32.895]         if (TRUE) {
[16:05:32.895]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:32.895]         }
[16:05:32.895]         else {
[16:05:32.895]             ...future.result["stdout"] <- base::list(NULL)
[16:05:32.895]         }
[16:05:32.895]         base::close(...future.stdout)
[16:05:32.895]         ...future.stdout <- NULL
[16:05:32.895]     }
[16:05:32.895]     ...future.result$conditions <- ...future.conditions
[16:05:32.895]     ...future.result$finished <- base::Sys.time()
[16:05:32.895]     ...future.result
[16:05:32.895] }
[16:05:32.897] assign_globals() ...
[16:05:32.897] List of 1
[16:05:32.897]  $ data:'data.frame':	3 obs. of  2 variables:
[16:05:32.897]   ..$ a: int [1:3] 1 2 3
[16:05:32.897]   ..$ b: int [1:3] 3 2 1
[16:05:32.897]  - attr(*, "where")=List of 1
[16:05:32.897]   ..$ data:<environment: R_EmptyEnv> 
[16:05:32.897]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:32.897]  - attr(*, "resolved")= logi FALSE
[16:05:32.897]  - attr(*, "total_size")= num 128
[16:05:32.897]  - attr(*, "already-done")= logi TRUE
[16:05:32.901] - copied ‘data’ to environment
[16:05:32.901] assign_globals() ... done
[16:05:32.901] requestCore(): workers = 2
[16:05:32.903] MulticoreFuture started
[16:05:32.904] - Launch lazy future ... done
[16:05:32.904] run() for ‘MulticoreFuture’ ... done
[16:05:32.904] result() for MulticoreFuture ...
[16:05:32.905] plan(): Setting new future strategy stack:
[16:05:32.905] List of future strategies:
[16:05:32.905] 1. sequential:
[16:05:32.905]    - args: function (..., envir = parent.frame())
[16:05:32.905]    - tweaked: FALSE
[16:05:32.905]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:32.906] plan(): nbrOfWorkers() = 1
[16:05:32.929] plan(): Setting new future strategy stack:
[16:05:32.930] List of future strategies:
[16:05:32.930] 1. multicore:
[16:05:32.930]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:32.930]    - tweaked: FALSE
[16:05:32.930]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:32.930] 2. sequential:
[16:05:32.930]    - args: function (..., envir = parent.frame())
[16:05:32.930]    - tweaked: FALSE
[16:05:32.930]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:32.934] plan(): nbrOfWorkers() = 2
[16:05:32.935] result() for MulticoreFuture ...
[16:05:32.935] result() for MulticoreFuture ... done
[16:05:32.935] signalConditions() ...
[16:05:32.936]  - include = ‘immediateCondition’
[16:05:32.936]  - exclude = 
[16:05:32.936]  - resignal = FALSE
[16:05:32.936]  - Number of conditions: 52
[16:05:32.936] signalConditions() ... done
[16:05:32.936] result() for MulticoreFuture ... done
[16:05:32.936] result() for MulticoreFuture ...
[16:05:32.936] result() for MulticoreFuture ... done
[16:05:32.937] signalConditions() ...
[16:05:32.937]  - include = ‘immediateCondition’
[16:05:32.937]  - exclude = 
[16:05:32.937]  - resignal = FALSE
[16:05:32.937]  - Number of conditions: 52
[16:05:32.937] signalConditions() ... done
[16:05:32.937] Future state: ‘finished’
[16:05:32.937] result() for MulticoreFuture ...
[16:05:32.937] result() for MulticoreFuture ... done
[16:05:32.938] signalConditions() ...
[16:05:32.938]  - include = ‘condition’
[16:05:32.938]  - exclude = ‘immediateCondition’
[16:05:32.938]  - resignal = TRUE
[16:05:32.938]  - Number of conditions: 52
[16:05:32.938]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.907] getGlobalsAndPackages() ...
[16:05:32.938]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.907] Searching for globals...
[16:05:32.938]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.909] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[16:05:32.939]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.909] Searching for globals ... DONE
[16:05:32.939]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.910] Resolving globals: FALSE
[16:05:32.939]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.911] The total size of the 1 globals is 128 bytes (128 bytes)
[16:05:32.939]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.911] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:05:32.939]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.911] - globals: [1] ‘data’
[16:05:32.939]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.912] 
[16:05:32.940]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.912] getGlobalsAndPackages() ... DONE
[16:05:32.940]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.912] run() for ‘Future’ ...
[16:05:32.940]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.913] - state: ‘created’
[16:05:32.940]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.913] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:32.940]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.913] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:32.940]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.913] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:32.940]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.914]   - Field: ‘label’
[16:05:32.941]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.914]   - Field: ‘local’
[16:05:32.941]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.914]   - Field: ‘owner’
[16:05:32.941]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.914]   - Field: ‘envir’
[16:05:32.941]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.914]   - Field: ‘packages’
[16:05:32.941]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.914]   - Field: ‘gc’
[16:05:32.941]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.915]   - Field: ‘conditions’
[16:05:32.942]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.915]   - Field: ‘expr’
[16:05:32.942]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.915]   - Field: ‘uuid’
[16:05:32.942]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.915]   - Field: ‘seed’
[16:05:32.942]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.915]   - Field: ‘version’
[16:05:32.942]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.915]   - Field: ‘result’
[16:05:32.942]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.916]   - Field: ‘asynchronous’
[16:05:32.942]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.916]   - Field: ‘calls’
[16:05:32.943]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.916]   - Field: ‘globals’
[16:05:32.943]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.916]   - Field: ‘stdout’
[16:05:32.943]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.916]   - Field: ‘earlySignal’
[16:05:32.943]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.916]   - Field: ‘lazy’
[16:05:32.943]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.917]   - Field: ‘state’
[16:05:32.943]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.917] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:32.944]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.917] - Launch lazy future ...
[16:05:32.944]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.917] Packages needed by the future expression (n = 0): <none>
[16:05:32.944]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.917] Packages needed by future strategies (n = 0): <none>
[16:05:32.944]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.918] {
[16:05:32.918]     {
[16:05:32.918]         {
[16:05:32.918]             ...future.startTime <- base::Sys.time()
[16:05:32.918]             {
[16:05:32.918]                 {
[16:05:32.918]                   {
[16:05:32.918]                     base::local({
[16:05:32.918]                       has_future <- base::requireNamespace("future", 
[16:05:32.918]                         quietly = TRUE)
[16:05:32.918]                       if (has_future) {
[16:05:32.918]                         ns <- base::getNamespace("future")
[16:05:32.918]                         version <- ns[[".package"]][["version"]]
[16:05:32.918]                         if (is.null(version)) 
[16:05:32.918]                           version <- utils::packageVersion("future")
[16:05:32.918]                       }
[16:05:32.918]                       else {
[16:05:32.918]                         version <- NULL
[16:05:32.918]                       }
[16:05:32.918]                       if (!has_future || version < "1.8.0") {
[16:05:32.918]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:32.918]                           "", base::R.version$version.string), 
[16:05:32.918]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:32.918]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:32.918]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:32.918]                             "release", "version")], collapse = " "), 
[16:05:32.918]                           hostname = base::Sys.info()[["nodename"]])
[16:05:32.918]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:32.918]                           info)
[16:05:32.918]                         info <- base::paste(info, collapse = "; ")
[16:05:32.918]                         if (!has_future) {
[16:05:32.918]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:32.918]                             info)
[16:05:32.918]                         }
[16:05:32.918]                         else {
[16:05:32.918]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:32.918]                             info, version)
[16:05:32.918]                         }
[16:05:32.918]                         base::stop(msg)
[16:05:32.918]                       }
[16:05:32.918]                     })
[16:05:32.918]                   }
[16:05:32.918]                   options(future.plan = NULL)
[16:05:32.918]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:32.918]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:32.918]                 }
[16:05:32.918]                 ...future.workdir <- getwd()
[16:05:32.918]             }
[16:05:32.918]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:32.918]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:32.918]         }
[16:05:32.918]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:32.918]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:32.918]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:32.918]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:32.918]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:32.918]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:32.918]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:32.918]             base::names(...future.oldOptions))
[16:05:32.918]     }
[16:05:32.918]     if (FALSE) {
[16:05:32.918]     }
[16:05:32.918]     else {
[16:05:32.918]         if (TRUE) {
[16:05:32.918]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:32.918]                 open = "w")
[16:05:32.918]         }
[16:05:32.918]         else {
[16:05:32.918]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:32.918]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:32.918]         }
[16:05:32.918]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:32.918]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:32.918]             base::sink(type = "output", split = FALSE)
[16:05:32.918]             base::close(...future.stdout)
[16:05:32.918]         }, add = TRUE)
[16:05:32.918]     }
[16:05:32.918]     ...future.frame <- base::sys.nframe()
[16:05:32.918]     ...future.conditions <- base::list()
[16:05:32.918]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:32.918]     if (FALSE) {
[16:05:32.918]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:32.918]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:32.918]     }
[16:05:32.918]     ...future.result <- base::tryCatch({
[16:05:32.918]         base::withCallingHandlers({
[16:05:32.918]             ...future.value <- base::withVisible(base::local(subset(data, 
[16:05:32.918]                 a == 2)))
[16:05:32.918]             future::FutureResult(value = ...future.value$value, 
[16:05:32.918]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:32.918]                   ...future.rng), globalenv = if (FALSE) 
[16:05:32.918]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:32.918]                     ...future.globalenv.names))
[16:05:32.918]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:32.918]         }, condition = base::local({
[16:05:32.918]             c <- base::c
[16:05:32.918]             inherits <- base::inherits
[16:05:32.918]             invokeRestart <- base::invokeRestart
[16:05:32.918]             length <- base::length
[16:05:32.918]             list <- base::list
[16:05:32.918]             seq.int <- base::seq.int
[16:05:32.918]             signalCondition <- base::signalCondition
[16:05:32.918]             sys.calls <- base::sys.calls
[16:05:32.918]             `[[` <- base::`[[`
[16:05:32.918]             `+` <- base::`+`
[16:05:32.918]             `<<-` <- base::`<<-`
[16:05:32.918]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:32.918]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:32.918]                   3L)]
[16:05:32.918]             }
[16:05:32.918]             function(cond) {
[16:05:32.918]                 is_error <- inherits(cond, "error")
[16:05:32.918]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:32.918]                   NULL)
[16:05:32.918]                 if (is_error) {
[16:05:32.918]                   sessionInformation <- function() {
[16:05:32.918]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:32.918]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:32.918]                       search = base::search(), system = base::Sys.info())
[16:05:32.918]                   }
[16:05:32.918]                   ...future.conditions[[length(...future.conditions) + 
[16:05:32.918]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:32.918]                     cond$call), session = sessionInformation(), 
[16:05:32.918]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:32.918]                   signalCondition(cond)
[16:05:32.918]                 }
[16:05:32.918]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:32.918]                 "immediateCondition"))) {
[16:05:32.918]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:32.918]                   ...future.conditions[[length(...future.conditions) + 
[16:05:32.918]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:32.918]                   if (TRUE && !signal) {
[16:05:32.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:32.918]                     {
[16:05:32.918]                       inherits <- base::inherits
[16:05:32.918]                       invokeRestart <- base::invokeRestart
[16:05:32.918]                       is.null <- base::is.null
[16:05:32.918]                       muffled <- FALSE
[16:05:32.918]                       if (inherits(cond, "message")) {
[16:05:32.918]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:32.918]                         if (muffled) 
[16:05:32.918]                           invokeRestart("muffleMessage")
[16:05:32.918]                       }
[16:05:32.918]                       else if (inherits(cond, "warning")) {
[16:05:32.918]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:32.918]                         if (muffled) 
[16:05:32.918]                           invokeRestart("muffleWarning")
[16:05:32.918]                       }
[16:05:32.918]                       else if (inherits(cond, "condition")) {
[16:05:32.918]                         if (!is.null(pattern)) {
[16:05:32.918]                           computeRestarts <- base::computeRestarts
[16:05:32.918]                           grepl <- base::grepl
[16:05:32.918]                           restarts <- computeRestarts(cond)
[16:05:32.918]                           for (restart in restarts) {
[16:05:32.918]                             name <- restart$name
[16:05:32.918]                             if (is.null(name)) 
[16:05:32.918]                               next
[16:05:32.918]                             if (!grepl(pattern, name)) 
[16:05:32.918]                               next
[16:05:32.918]                             invokeRestart(restart)
[16:05:32.918]                             muffled <- TRUE
[16:05:32.918]                             break
[16:05:32.918]                           }
[16:05:32.918]                         }
[16:05:32.918]                       }
[16:05:32.918]                       invisible(muffled)
[16:05:32.918]                     }
[16:05:32.918]                     muffleCondition(cond, pattern = "^muffle")
[16:05:32.918]                   }
[16:05:32.918]                 }
[16:05:32.918]                 else {
[16:05:32.918]                   if (TRUE) {
[16:05:32.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:32.918]                     {
[16:05:32.918]                       inherits <- base::inherits
[16:05:32.918]                       invokeRestart <- base::invokeRestart
[16:05:32.918]                       is.null <- base::is.null
[16:05:32.918]                       muffled <- FALSE
[16:05:32.918]                       if (inherits(cond, "message")) {
[16:05:32.918]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:32.918]                         if (muffled) 
[16:05:32.918]                           invokeRestart("muffleMessage")
[16:05:32.918]                       }
[16:05:32.918]                       else if (inherits(cond, "warning")) {
[16:05:32.918]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:32.918]                         if (muffled) 
[16:05:32.918]                           invokeRestart("muffleWarning")
[16:05:32.918]                       }
[16:05:32.918]                       else if (inherits(cond, "condition")) {
[16:05:32.918]                         if (!is.null(pattern)) {
[16:05:32.918]                           computeRestarts <- base::computeRestarts
[16:05:32.918]                           grepl <- base::grepl
[16:05:32.918]                           restarts <- computeRestarts(cond)
[16:05:32.918]                           for (restart in restarts) {
[16:05:32.918]                             name <- restart$name
[16:05:32.918]                             if (is.null(name)) 
[16:05:32.918]                               next
[16:05:32.918]                             if (!grepl(pattern, name)) 
[16:05:32.918]                               next
[16:05:32.918]                             invokeRestart(restart)
[16:05:32.918]                             muffled <- TRUE
[16:05:32.918]                             break
[16:05:32.918]                           }
[16:05:32.918]                         }
[16:05:32.918]                       }
[16:05:32.918]                       invisible(muffled)
[16:05:32.918]                     }
[16:05:32.918]                     muffleCondition(cond, pattern = "^muffle")
[16:05:32.918]                   }
[16:05:32.918]                 }
[16:05:32.918]             }
[16:05:32.918]         }))
[16:05:32.918]     }, error = function(ex) {
[16:05:32.918]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:32.918]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:32.918]                 ...future.rng), started = ...future.startTime, 
[16:05:32.918]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:32.918]             version = "1.8"), class = "FutureResult")
[16:05:32.918]     }, finally = {
[16:05:32.918]         if (!identical(...future.workdir, getwd())) 
[16:05:32.918]             setwd(...future.workdir)
[16:05:32.918]         {
[16:05:32.918]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:32.918]                 ...future.oldOptions$nwarnings <- NULL
[16:05:32.918]             }
[16:05:32.918]             base::options(...future.oldOptions)
[16:05:32.918]             if (.Platform$OS.type == "windows") {
[16:05:32.918]                 old_names <- names(...future.oldEnvVars)
[16:05:32.918]                 envs <- base::Sys.getenv()
[16:05:32.918]                 names <- names(envs)
[16:05:32.918]                 common <- intersect(names, old_names)
[16:05:32.918]                 added <- setdiff(names, old_names)
[16:05:32.918]                 removed <- setdiff(old_names, names)
[16:05:32.918]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:32.918]                   envs[common]]
[16:05:32.918]                 NAMES <- toupper(changed)
[16:05:32.918]                 args <- list()
[16:05:32.918]                 for (kk in seq_along(NAMES)) {
[16:05:32.918]                   name <- changed[[kk]]
[16:05:32.918]                   NAME <- NAMES[[kk]]
[16:05:32.918]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.918]                     next
[16:05:32.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:32.918]                 }
[16:05:32.918]                 NAMES <- toupper(added)
[16:05:32.918]                 for (kk in seq_along(NAMES)) {
[16:05:32.918]                   name <- added[[kk]]
[16:05:32.918]                   NAME <- NAMES[[kk]]
[16:05:32.918]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.918]                     next
[16:05:32.918]                   args[[name]] <- ""
[16:05:32.918]                 }
[16:05:32.918]                 NAMES <- toupper(removed)
[16:05:32.918]                 for (kk in seq_along(NAMES)) {
[16:05:32.918]                   name <- removed[[kk]]
[16:05:32.918]                   NAME <- NAMES[[kk]]
[16:05:32.918]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.918]                     next
[16:05:32.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:32.918]                 }
[16:05:32.918]                 if (length(args) > 0) 
[16:05:32.918]                   base::do.call(base::Sys.setenv, args = args)
[16:05:32.918]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:32.918]             }
[16:05:32.918]             else {
[16:05:32.918]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:32.918]             }
[16:05:32.918]             {
[16:05:32.918]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:32.918]                   0L) {
[16:05:32.918]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:32.918]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:32.918]                   base::options(opts)
[16:05:32.918]                 }
[16:05:32.918]                 {
[16:05:32.918]                   {
[16:05:32.918]                     NULL
[16:05:32.918]                     RNGkind("Mersenne-Twister")
[16:05:32.918]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:32.918]                       inherits = FALSE)
[16:05:32.918]                   }
[16:05:32.918]                   options(future.plan = NULL)
[16:05:32.918]                   if (is.na(NA_character_)) 
[16:05:32.918]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:32.918]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:32.918]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:05:32.918]                   {
[16:05:32.918]                     future <- SequentialFuture(..., envir = envir)
[16:05:32.918]                     if (!future$lazy) 
[16:05:32.918]                       future <- run(future)
[16:05:32.918]                     invisible(future)
[16:05:32.918]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:32.918]                 }
[16:05:32.918]             }
[16:05:32.918]         }
[16:05:32.918]     })
[16:05:32.918]     if (TRUE) {
[16:05:32.918]         base::sink(type = "output", split = FALSE)
[16:05:32.918]         if (TRUE) {
[16:05:32.918]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:32.918]         }
[16:05:32.918]         else {
[16:05:32.918]             ...future.result["stdout"] <- base::list(NULL)
[16:05:32.918]         }
[16:05:32.918]         base::close(...future.stdout)
[16:05:32.918]         ...future.stdout <- NULL
[16:05:32.918]     }
[16:05:32.918]     ...future.result$conditions <- ...future.conditions
[16:05:32.918]     ...future.result$finished <- base::Sys.time()
[16:05:32.918]     ...future.result
[16:05:32.918] }
[16:05:32.944]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.920] assign_globals() ...
[16:05:32.944]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.920] List of 1
[16:05:32.920]  $ data:'data.frame':	3 obs. of  2 variables:
[16:05:32.920]   ..$ a: int [1:3] 1 2 3
[16:05:32.920]   ..$ b: int [1:3] 3 2 1
[16:05:32.920]  - attr(*, "where")=List of 1
[16:05:32.920]   ..$ data:<environment: R_EmptyEnv> 
[16:05:32.920]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:32.920]  - attr(*, "resolved")= logi FALSE
[16:05:32.920]  - attr(*, "total_size")= num 128
[16:05:32.920]  - attr(*, "already-done")= logi TRUE
[16:05:32.945]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.925] - copied ‘data’ to environment
[16:05:32.945]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.925] assign_globals() ... done
[16:05:32.945]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.926] plan(): Setting new future strategy stack:
[16:05:32.945]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.926] List of future strategies:
[16:05:32.926] 1. sequential:
[16:05:32.926]    - args: function (..., envir = parent.frame())
[16:05:32.926]    - tweaked: FALSE
[16:05:32.926]    - call: NULL
[16:05:32.945]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.926] plan(): nbrOfWorkers() = 1
[16:05:32.945]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.928] plan(): Setting new future strategy stack:
[16:05:32.945]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.928] List of future strategies:
[16:05:32.928] 1. sequential:
[16:05:32.928]    - args: function (..., envir = parent.frame())
[16:05:32.928]    - tweaked: FALSE
[16:05:32.928]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:32.946]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.928] plan(): nbrOfWorkers() = 1
[16:05:32.946]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.928] SequentialFuture started (and completed)
[16:05:32.946]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.929] - Launch lazy future ... done
[16:05:32.946]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:32.929] run() for ‘SequentialFuture’ ... done
[16:05:32.946] signalConditions() ... done
- plan(list('multicore', 'sequential')) ... DONE
- plan(list('multicore', 'multicore')) ...
[16:05:32.947] plan(): Setting new future strategy stack:
[16:05:32.947] List of future strategies:
[16:05:32.947] 1. multicore:
[16:05:32.947]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:32.947]    - tweaked: FALSE
[16:05:32.947]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:32.947] 2. multicore:
[16:05:32.947]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:32.947]    - tweaked: FALSE
[16:05:32.947]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:32.951] plan(): nbrOfWorkers() = 2
[16:05:32.951] getGlobalsAndPackages() ...
[16:05:32.951] Searching for globals...
[16:05:32.974] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:05:32.974] Searching for globals ... DONE
[16:05:32.974] Resolving globals: FALSE
[16:05:32.975] The total size of the 2 globals is 93.07 KiB (95304 bytes)
[16:05:32.976] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 93.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (92.95 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:05:32.976] - globals: [2] ‘nested’, ‘strategy2’
[16:05:32.976] - packages: [1] ‘future’
[16:05:32.976] getGlobalsAndPackages() ... DONE
[16:05:32.976] run() for ‘Future’ ...
[16:05:32.976] - state: ‘created’
[16:05:32.977] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:32.981] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:32.981] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:32.981]   - Field: ‘label’
[16:05:32.981]   - Field: ‘local’
[16:05:32.981]   - Field: ‘owner’
[16:05:32.981]   - Field: ‘envir’
[16:05:32.982]   - Field: ‘workers’
[16:05:32.982]   - Field: ‘packages’
[16:05:32.982]   - Field: ‘gc’
[16:05:32.982]   - Field: ‘job’
[16:05:32.982]   - Field: ‘conditions’
[16:05:32.982]   - Field: ‘expr’
[16:05:32.982]   - Field: ‘uuid’
[16:05:32.982]   - Field: ‘seed’
[16:05:32.983]   - Field: ‘version’
[16:05:32.983]   - Field: ‘result’
[16:05:32.983]   - Field: ‘asynchronous’
[16:05:32.983]   - Field: ‘calls’
[16:05:32.983]   - Field: ‘globals’
[16:05:32.983]   - Field: ‘stdout’
[16:05:32.983]   - Field: ‘earlySignal’
[16:05:32.983]   - Field: ‘lazy’
[16:05:32.984]   - Field: ‘state’
[16:05:32.984] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:32.984] - Launch lazy future ...
[16:05:32.984] Packages needed by the future expression (n = 1): ‘future’
[16:05:32.984] Packages needed by future strategies (n = 1): ‘future’
[16:05:32.985] {
[16:05:32.985]     {
[16:05:32.985]         {
[16:05:32.985]             ...future.startTime <- base::Sys.time()
[16:05:32.985]             {
[16:05:32.985]                 {
[16:05:32.985]                   {
[16:05:32.985]                     {
[16:05:32.985]                       {
[16:05:32.985]                         base::local({
[16:05:32.985]                           has_future <- base::requireNamespace("future", 
[16:05:32.985]                             quietly = TRUE)
[16:05:32.985]                           if (has_future) {
[16:05:32.985]                             ns <- base::getNamespace("future")
[16:05:32.985]                             version <- ns[[".package"]][["version"]]
[16:05:32.985]                             if (is.null(version)) 
[16:05:32.985]                               version <- utils::packageVersion("future")
[16:05:32.985]                           }
[16:05:32.985]                           else {
[16:05:32.985]                             version <- NULL
[16:05:32.985]                           }
[16:05:32.985]                           if (!has_future || version < "1.8.0") {
[16:05:32.985]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:32.985]                               "", base::R.version$version.string), 
[16:05:32.985]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:32.985]                                 base::R.version$platform, 8 * 
[16:05:32.985]                                   base::.Machine$sizeof.pointer), 
[16:05:32.985]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:32.985]                                 "release", "version")], collapse = " "), 
[16:05:32.985]                               hostname = base::Sys.info()[["nodename"]])
[16:05:32.985]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:32.985]                               info)
[16:05:32.985]                             info <- base::paste(info, collapse = "; ")
[16:05:32.985]                             if (!has_future) {
[16:05:32.985]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:32.985]                                 info)
[16:05:32.985]                             }
[16:05:32.985]                             else {
[16:05:32.985]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:32.985]                                 info, version)
[16:05:32.985]                             }
[16:05:32.985]                             base::stop(msg)
[16:05:32.985]                           }
[16:05:32.985]                         })
[16:05:32.985]                       }
[16:05:32.985]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:32.985]                       base::options(mc.cores = 1L)
[16:05:32.985]                     }
[16:05:32.985]                     base::local({
[16:05:32.985]                       for (pkg in "future") {
[16:05:32.985]                         base::loadNamespace(pkg)
[16:05:32.985]                         base::library(pkg, character.only = TRUE)
[16:05:32.985]                       }
[16:05:32.985]                     })
[16:05:32.985]                   }
[16:05:32.985]                   options(future.plan = NULL)
[16:05:32.985]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:32.985]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:32.985]                     envir = parent.frame()) 
[16:05:32.985]                   {
[16:05:32.985]                     default_workers <- missing(workers)
[16:05:32.985]                     if (is.function(workers)) 
[16:05:32.985]                       workers <- workers()
[16:05:32.985]                     workers <- structure(as.integer(workers), 
[16:05:32.985]                       class = class(workers))
[16:05:32.985]                     stop_if_not(is.finite(workers), workers >= 
[16:05:32.985]                       1L)
[16:05:32.985]                     if ((workers == 1L && !inherits(workers, 
[16:05:32.985]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:32.985]                       if (default_workers) 
[16:05:32.985]                         supportsMulticore(warn = TRUE)
[16:05:32.985]                       return(sequential(..., envir = envir))
[16:05:32.985]                     }
[16:05:32.985]                     oopts <- options(mc.cores = workers)
[16:05:32.985]                     on.exit(options(oopts))
[16:05:32.985]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:32.985]                       envir = envir)
[16:05:32.985]                     if (!future$lazy) 
[16:05:32.985]                       future <- run(future)
[16:05:32.985]                     invisible(future)
[16:05:32.985]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:32.985]                 }
[16:05:32.985]                 ...future.workdir <- getwd()
[16:05:32.985]             }
[16:05:32.985]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:32.985]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:32.985]         }
[16:05:32.985]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:32.985]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:32.985]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:32.985]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:32.985]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:32.985]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:32.985]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:32.985]             base::names(...future.oldOptions))
[16:05:32.985]     }
[16:05:32.985]     if (FALSE) {
[16:05:32.985]     }
[16:05:32.985]     else {
[16:05:32.985]         if (TRUE) {
[16:05:32.985]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:32.985]                 open = "w")
[16:05:32.985]         }
[16:05:32.985]         else {
[16:05:32.985]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:32.985]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:32.985]         }
[16:05:32.985]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:32.985]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:32.985]             base::sink(type = "output", split = FALSE)
[16:05:32.985]             base::close(...future.stdout)
[16:05:32.985]         }, add = TRUE)
[16:05:32.985]     }
[16:05:32.985]     ...future.frame <- base::sys.nframe()
[16:05:32.985]     ...future.conditions <- base::list()
[16:05:32.985]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:32.985]     if (FALSE) {
[16:05:32.985]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:32.985]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:32.985]     }
[16:05:32.985]     ...future.result <- base::tryCatch({
[16:05:32.985]         base::withCallingHandlers({
[16:05:32.985]             ...future.value <- base::withVisible(base::local({
[16:05:32.985]                 withCallingHandlers({
[16:05:32.985]                   {
[16:05:32.985]                     a <- 1L
[16:05:32.985]                     plan_a <- unclass(future::plan("list"))
[16:05:32.985]                     nested_a <- nested[-1]
[16:05:32.985]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:05:32.985]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:05:32.985]                       strategy2))
[16:05:32.985]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:05:32.985]                       "init") <- NULL
[16:05:32.985]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:05:32.985]                       "init") <- NULL
[16:05:32.985]                     stopifnot(all.equal(plan_a, nested_a))
[16:05:32.985]                     y %<-% {
[16:05:32.985]                       b <- 2L
[16:05:32.985]                       plan_b <- future::plan("list")
[16:05:32.985]                       nested_b <- nested_a[-1]
[16:05:32.985]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:05:32.985]                         1L, inherits(plan_b[[1]], "future"), 
[16:05:32.985]                         inherits(future::plan("next"), "sequential"))
[16:05:32.985]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:05:32.985]                         b = b, nested_b = nested_b, plan_b = plan_b)
[16:05:32.985]                     }
[16:05:32.985]                     y
[16:05:32.985]                   }
[16:05:32.985]                 }, immediateCondition = function(cond) {
[16:05:32.985]                   save_rds <- function (object, pathname, ...) 
[16:05:32.985]                   {
[16:05:32.985]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:32.985]                     if (file_test("-f", pathname_tmp)) {
[16:05:32.985]                       fi_tmp <- file.info(pathname_tmp)
[16:05:32.985]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:32.985]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:32.985]                         fi_tmp[["mtime"]])
[16:05:32.985]                     }
[16:05:32.985]                     tryCatch({
[16:05:32.985]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:32.985]                     }, error = function(ex) {
[16:05:32.985]                       msg <- conditionMessage(ex)
[16:05:32.985]                       fi_tmp <- file.info(pathname_tmp)
[16:05:32.985]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:32.985]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:32.985]                         fi_tmp[["mtime"]], msg)
[16:05:32.985]                       ex$message <- msg
[16:05:32.985]                       stop(ex)
[16:05:32.985]                     })
[16:05:32.985]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:32.985]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:32.985]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:32.985]                       fi_tmp <- file.info(pathname_tmp)
[16:05:32.985]                       fi <- file.info(pathname)
[16:05:32.985]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:32.985]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:32.985]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:32.985]                         fi[["size"]], fi[["mtime"]])
[16:05:32.985]                       stop(msg)
[16:05:32.985]                     }
[16:05:32.985]                     invisible(pathname)
[16:05:32.985]                   }
[16:05:32.985]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:32.985]                     rootPath = tempdir()) 
[16:05:32.985]                   {
[16:05:32.985]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:32.985]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:32.985]                       tmpdir = path, fileext = ".rds")
[16:05:32.985]                     save_rds(obj, file)
[16:05:32.985]                   }
[16:05:32.985]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0EbAi0/.future/immediateConditions")
[16:05:32.985]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:32.985]                   {
[16:05:32.985]                     inherits <- base::inherits
[16:05:32.985]                     invokeRestart <- base::invokeRestart
[16:05:32.985]                     is.null <- base::is.null
[16:05:32.985]                     muffled <- FALSE
[16:05:32.985]                     if (inherits(cond, "message")) {
[16:05:32.985]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:32.985]                       if (muffled) 
[16:05:32.985]                         invokeRestart("muffleMessage")
[16:05:32.985]                     }
[16:05:32.985]                     else if (inherits(cond, "warning")) {
[16:05:32.985]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:32.985]                       if (muffled) 
[16:05:32.985]                         invokeRestart("muffleWarning")
[16:05:32.985]                     }
[16:05:32.985]                     else if (inherits(cond, "condition")) {
[16:05:32.985]                       if (!is.null(pattern)) {
[16:05:32.985]                         computeRestarts <- base::computeRestarts
[16:05:32.985]                         grepl <- base::grepl
[16:05:32.985]                         restarts <- computeRestarts(cond)
[16:05:32.985]                         for (restart in restarts) {
[16:05:32.985]                           name <- restart$name
[16:05:32.985]                           if (is.null(name)) 
[16:05:32.985]                             next
[16:05:32.985]                           if (!grepl(pattern, name)) 
[16:05:32.985]                             next
[16:05:32.985]                           invokeRestart(restart)
[16:05:32.985]                           muffled <- TRUE
[16:05:32.985]                           break
[16:05:32.985]                         }
[16:05:32.985]                       }
[16:05:32.985]                     }
[16:05:32.985]                     invisible(muffled)
[16:05:32.985]                   }
[16:05:32.985]                   muffleCondition(cond)
[16:05:32.985]                 })
[16:05:32.985]             }))
[16:05:32.985]             future::FutureResult(value = ...future.value$value, 
[16:05:32.985]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:32.985]                   ...future.rng), globalenv = if (FALSE) 
[16:05:32.985]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:32.985]                     ...future.globalenv.names))
[16:05:32.985]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:32.985]         }, condition = base::local({
[16:05:32.985]             c <- base::c
[16:05:32.985]             inherits <- base::inherits
[16:05:32.985]             invokeRestart <- base::invokeRestart
[16:05:32.985]             length <- base::length
[16:05:32.985]             list <- base::list
[16:05:32.985]             seq.int <- base::seq.int
[16:05:32.985]             signalCondition <- base::signalCondition
[16:05:32.985]             sys.calls <- base::sys.calls
[16:05:32.985]             `[[` <- base::`[[`
[16:05:32.985]             `+` <- base::`+`
[16:05:32.985]             `<<-` <- base::`<<-`
[16:05:32.985]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:32.985]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:32.985]                   3L)]
[16:05:32.985]             }
[16:05:32.985]             function(cond) {
[16:05:32.985]                 is_error <- inherits(cond, "error")
[16:05:32.985]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:32.985]                   NULL)
[16:05:32.985]                 if (is_error) {
[16:05:32.985]                   sessionInformation <- function() {
[16:05:32.985]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:32.985]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:32.985]                       search = base::search(), system = base::Sys.info())
[16:05:32.985]                   }
[16:05:32.985]                   ...future.conditions[[length(...future.conditions) + 
[16:05:32.985]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:32.985]                     cond$call), session = sessionInformation(), 
[16:05:32.985]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:32.985]                   signalCondition(cond)
[16:05:32.985]                 }
[16:05:32.985]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:32.985]                 "immediateCondition"))) {
[16:05:32.985]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:32.985]                   ...future.conditions[[length(...future.conditions) + 
[16:05:32.985]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:32.985]                   if (TRUE && !signal) {
[16:05:32.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:32.985]                     {
[16:05:32.985]                       inherits <- base::inherits
[16:05:32.985]                       invokeRestart <- base::invokeRestart
[16:05:32.985]                       is.null <- base::is.null
[16:05:32.985]                       muffled <- FALSE
[16:05:32.985]                       if (inherits(cond, "message")) {
[16:05:32.985]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:32.985]                         if (muffled) 
[16:05:32.985]                           invokeRestart("muffleMessage")
[16:05:32.985]                       }
[16:05:32.985]                       else if (inherits(cond, "warning")) {
[16:05:32.985]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:32.985]                         if (muffled) 
[16:05:32.985]                           invokeRestart("muffleWarning")
[16:05:32.985]                       }
[16:05:32.985]                       else if (inherits(cond, "condition")) {
[16:05:32.985]                         if (!is.null(pattern)) {
[16:05:32.985]                           computeRestarts <- base::computeRestarts
[16:05:32.985]                           grepl <- base::grepl
[16:05:32.985]                           restarts <- computeRestarts(cond)
[16:05:32.985]                           for (restart in restarts) {
[16:05:32.985]                             name <- restart$name
[16:05:32.985]                             if (is.null(name)) 
[16:05:32.985]                               next
[16:05:32.985]                             if (!grepl(pattern, name)) 
[16:05:32.985]                               next
[16:05:32.985]                             invokeRestart(restart)
[16:05:32.985]                             muffled <- TRUE
[16:05:32.985]                             break
[16:05:32.985]                           }
[16:05:32.985]                         }
[16:05:32.985]                       }
[16:05:32.985]                       invisible(muffled)
[16:05:32.985]                     }
[16:05:32.985]                     muffleCondition(cond, pattern = "^muffle")
[16:05:32.985]                   }
[16:05:32.985]                 }
[16:05:32.985]                 else {
[16:05:32.985]                   if (TRUE) {
[16:05:32.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:32.985]                     {
[16:05:32.985]                       inherits <- base::inherits
[16:05:32.985]                       invokeRestart <- base::invokeRestart
[16:05:32.985]                       is.null <- base::is.null
[16:05:32.985]                       muffled <- FALSE
[16:05:32.985]                       if (inherits(cond, "message")) {
[16:05:32.985]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:32.985]                         if (muffled) 
[16:05:32.985]                           invokeRestart("muffleMessage")
[16:05:32.985]                       }
[16:05:32.985]                       else if (inherits(cond, "warning")) {
[16:05:32.985]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:32.985]                         if (muffled) 
[16:05:32.985]                           invokeRestart("muffleWarning")
[16:05:32.985]                       }
[16:05:32.985]                       else if (inherits(cond, "condition")) {
[16:05:32.985]                         if (!is.null(pattern)) {
[16:05:32.985]                           computeRestarts <- base::computeRestarts
[16:05:32.985]                           grepl <- base::grepl
[16:05:32.985]                           restarts <- computeRestarts(cond)
[16:05:32.985]                           for (restart in restarts) {
[16:05:32.985]                             name <- restart$name
[16:05:32.985]                             if (is.null(name)) 
[16:05:32.985]                               next
[16:05:32.985]                             if (!grepl(pattern, name)) 
[16:05:32.985]                               next
[16:05:32.985]                             invokeRestart(restart)
[16:05:32.985]                             muffled <- TRUE
[16:05:32.985]                             break
[16:05:32.985]                           }
[16:05:32.985]                         }
[16:05:32.985]                       }
[16:05:32.985]                       invisible(muffled)
[16:05:32.985]                     }
[16:05:32.985]                     muffleCondition(cond, pattern = "^muffle")
[16:05:32.985]                   }
[16:05:32.985]                 }
[16:05:32.985]             }
[16:05:32.985]         }))
[16:05:32.985]     }, error = function(ex) {
[16:05:32.985]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:32.985]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:32.985]                 ...future.rng), started = ...future.startTime, 
[16:05:32.985]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:32.985]             version = "1.8"), class = "FutureResult")
[16:05:32.985]     }, finally = {
[16:05:32.985]         if (!identical(...future.workdir, getwd())) 
[16:05:32.985]             setwd(...future.workdir)
[16:05:32.985]         {
[16:05:32.985]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:32.985]                 ...future.oldOptions$nwarnings <- NULL
[16:05:32.985]             }
[16:05:32.985]             base::options(...future.oldOptions)
[16:05:32.985]             if (.Platform$OS.type == "windows") {
[16:05:32.985]                 old_names <- names(...future.oldEnvVars)
[16:05:32.985]                 envs <- base::Sys.getenv()
[16:05:32.985]                 names <- names(envs)
[16:05:32.985]                 common <- intersect(names, old_names)
[16:05:32.985]                 added <- setdiff(names, old_names)
[16:05:32.985]                 removed <- setdiff(old_names, names)
[16:05:32.985]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:32.985]                   envs[common]]
[16:05:32.985]                 NAMES <- toupper(changed)
[16:05:32.985]                 args <- list()
[16:05:32.985]                 for (kk in seq_along(NAMES)) {
[16:05:32.985]                   name <- changed[[kk]]
[16:05:32.985]                   NAME <- NAMES[[kk]]
[16:05:32.985]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.985]                     next
[16:05:32.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:32.985]                 }
[16:05:32.985]                 NAMES <- toupper(added)
[16:05:32.985]                 for (kk in seq_along(NAMES)) {
[16:05:32.985]                   name <- added[[kk]]
[16:05:32.985]                   NAME <- NAMES[[kk]]
[16:05:32.985]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.985]                     next
[16:05:32.985]                   args[[name]] <- ""
[16:05:32.985]                 }
[16:05:32.985]                 NAMES <- toupper(removed)
[16:05:32.985]                 for (kk in seq_along(NAMES)) {
[16:05:32.985]                   name <- removed[[kk]]
[16:05:32.985]                   NAME <- NAMES[[kk]]
[16:05:32.985]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:32.985]                     next
[16:05:32.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:32.985]                 }
[16:05:32.985]                 if (length(args) > 0) 
[16:05:32.985]                   base::do.call(base::Sys.setenv, args = args)
[16:05:32.985]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:32.985]             }
[16:05:32.985]             else {
[16:05:32.985]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:32.985]             }
[16:05:32.985]             {
[16:05:32.985]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:32.985]                   0L) {
[16:05:32.985]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:32.985]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:32.985]                   base::options(opts)
[16:05:32.985]                 }
[16:05:32.985]                 {
[16:05:32.985]                   {
[16:05:32.985]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:32.985]                     NULL
[16:05:32.985]                   }
[16:05:32.985]                   options(future.plan = NULL)
[16:05:32.985]                   if (is.na(NA_character_)) 
[16:05:32.985]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:32.985]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:32.985]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:32.985]                     envir = parent.frame()) 
[16:05:32.985]                   {
[16:05:32.985]                     default_workers <- missing(workers)
[16:05:32.985]                     if (is.function(workers)) 
[16:05:32.985]                       workers <- workers()
[16:05:32.985]                     workers <- structure(as.integer(workers), 
[16:05:32.985]                       class = class(workers))
[16:05:32.985]                     stop_if_not(is.finite(workers), workers >= 
[16:05:32.985]                       1L)
[16:05:32.985]                     if ((workers == 1L && !inherits(workers, 
[16:05:32.985]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:32.985]                       if (default_workers) 
[16:05:32.985]                         supportsMulticore(warn = TRUE)
[16:05:32.985]                       return(sequential(..., envir = envir))
[16:05:32.985]                     }
[16:05:32.985]                     oopts <- options(mc.cores = workers)
[16:05:32.985]                     on.exit(options(oopts))
[16:05:32.985]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:32.985]                       envir = envir)
[16:05:32.985]                     if (!future$lazy) 
[16:05:32.985]                       future <- run(future)
[16:05:32.985]                     invisible(future)
[16:05:32.985]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:32.985]                     envir = parent.frame()) 
[16:05:32.985]                   {
[16:05:32.985]                     default_workers <- missing(workers)
[16:05:32.985]                     if (is.function(workers)) 
[16:05:32.985]                       workers <- workers()
[16:05:32.985]                     workers <- structure(as.integer(workers), 
[16:05:32.985]                       class = class(workers))
[16:05:32.985]                     stop_if_not(is.finite(workers), workers >= 
[16:05:32.985]                       1L)
[16:05:32.985]                     if ((workers == 1L && !inherits(workers, 
[16:05:32.985]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:32.985]                       if (default_workers) 
[16:05:32.985]                         supportsMulticore(warn = TRUE)
[16:05:32.985]                       return(sequential(..., envir = envir))
[16:05:32.985]                     }
[16:05:32.985]                     oopts <- options(mc.cores = workers)
[16:05:32.985]                     on.exit(options(oopts))
[16:05:32.985]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:32.985]                       envir = envir)
[16:05:32.985]                     if (!future$lazy) 
[16:05:32.985]                       future <- run(future)
[16:05:32.985]                     invisible(future)
[16:05:32.985]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:32.985]                 }
[16:05:32.985]             }
[16:05:32.985]         }
[16:05:32.985]     })
[16:05:32.985]     if (TRUE) {
[16:05:32.985]         base::sink(type = "output", split = FALSE)
[16:05:32.985]         if (TRUE) {
[16:05:32.985]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:32.985]         }
[16:05:32.985]         else {
[16:05:32.985]             ...future.result["stdout"] <- base::list(NULL)
[16:05:32.985]         }
[16:05:32.985]         base::close(...future.stdout)
[16:05:32.985]         ...future.stdout <- NULL
[16:05:32.985]     }
[16:05:32.985]     ...future.result$conditions <- ...future.conditions
[16:05:32.985]     ...future.result$finished <- base::Sys.time()
[16:05:32.985]     ...future.result
[16:05:32.985] }
[16:05:32.988] assign_globals() ...
[16:05:32.988] List of 2
[16:05:32.988]  $ nested   :List of 2
[16:05:32.988]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:05:32.988]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:05:32.988]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:05:32.988]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:05:32.988]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:05:32.988]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:05:32.988]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:05:32.988]  $ strategy2: chr "multicore"
[16:05:32.988]  - attr(*, "where")=List of 2
[16:05:32.988]   ..$ nested   :<environment: R_EmptyEnv> 
[16:05:32.988]   ..$ strategy2:<environment: R_EmptyEnv> 
[16:05:32.988]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:32.988]  - attr(*, "resolved")= logi FALSE
[16:05:32.988]  - attr(*, "total_size")= num 95304
[16:05:32.988]  - attr(*, "already-done")= logi TRUE
[16:05:32.994] - copied ‘nested’ to environment
[16:05:32.994] - copied ‘strategy2’ to environment
[16:05:32.994] assign_globals() ... done
[16:05:32.994] requestCore(): workers = 2
[16:05:32.996] MulticoreFuture started
[16:05:32.996] - Launch lazy future ... done
[16:05:32.997] run() for ‘MulticoreFuture’ ... done
[16:05:32.997] result() for MulticoreFuture ...
[16:05:32.997] plan(): Setting new future strategy stack:
[16:05:32.998] List of future strategies:
[16:05:32.998] 1. multicore:
[16:05:32.998]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:32.998]    - tweaked: FALSE
[16:05:32.998]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.004] plan(): nbrOfWorkers() = 1
[16:05:33.044] plan(): Setting new future strategy stack:
[16:05:33.044] List of future strategies:
[16:05:33.044] 1. multicore:
[16:05:33.044]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:33.044]    - tweaked: FALSE
[16:05:33.044]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.044] 2. multicore:
[16:05:33.044]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:33.044]    - tweaked: FALSE
[16:05:33.044]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.048] plan(): nbrOfWorkers() = 2
[16:05:33.050] result() for MulticoreFuture ...
[16:05:33.050] result() for MulticoreFuture ... done
[16:05:33.050] signalConditions() ...
[16:05:33.050]  - include = ‘immediateCondition’
[16:05:33.050]  - exclude = 
[16:05:33.050]  - resignal = FALSE
[16:05:33.051]  - Number of conditions: 54
[16:05:33.051] signalConditions() ... done
[16:05:33.051] result() for MulticoreFuture ... done
[16:05:33.051] result() for MulticoreFuture ...
[16:05:33.051] result() for MulticoreFuture ... done
[16:05:33.051] signalConditions() ...
[16:05:33.051]  - include = ‘immediateCondition’
[16:05:33.051]  - exclude = 
[16:05:33.052]  - resignal = FALSE
[16:05:33.052]  - Number of conditions: 54
[16:05:33.052] signalConditions() ... done
[16:05:33.052] Future state: ‘finished’
[16:05:33.052] result() for MulticoreFuture ...
[16:05:33.052] result() for MulticoreFuture ... done
[16:05:33.052] signalConditions() ...
[16:05:33.052]  - include = ‘condition’
[16:05:33.053]  - exclude = ‘immediateCondition’
[16:05:33.053]  - resignal = TRUE
[16:05:33.053]  - Number of conditions: 54
[16:05:33.053]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.005] getGlobalsAndPackages() ...
[16:05:33.053]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.006] Searching for globals...
[16:05:33.053]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.013] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[16:05:33.053]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.014] Searching for globals ... DONE
[16:05:33.054]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.014] Resolving globals: FALSE
[16:05:33.054]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.015] The total size of the 3 globals is 93.01 KiB (95240 bytes)
[16:05:33.054]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.016] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 93.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (46.48 KiB of class ‘list’), ‘plan_a’ (46.48 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[16:05:33.054]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.016] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[16:05:33.054]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.016] 
[16:05:33.054]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.016] getGlobalsAndPackages() ... DONE
[16:05:33.055]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.017] run() for ‘Future’ ...
[16:05:33.055]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.017] - state: ‘created’
[16:05:33.055]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.017] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:33.055]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.021] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:33.055]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.022] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:33.055]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.022]   - Field: ‘label’
[16:05:33.056]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.022]   - Field: ‘local’
[16:05:33.056]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.022]   - Field: ‘owner’
[16:05:33.056]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.022]   - Field: ‘envir’
[16:05:33.056]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.023]   - Field: ‘packages’
[16:05:33.056]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.023]   - Field: ‘gc’
[16:05:33.056]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.023]   - Field: ‘conditions’
[16:05:33.056]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.023]   - Field: ‘expr’
[16:05:33.057]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.023]   - Field: ‘uuid’
[16:05:33.057]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.023]   - Field: ‘seed’
[16:05:33.057]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.024]   - Field: ‘version’
[16:05:33.057]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.024]   - Field: ‘result’
[16:05:33.057]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.024]   - Field: ‘asynchronous’
[16:05:33.057]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.024]   - Field: ‘calls’
[16:05:33.058]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.024]   - Field: ‘globals’
[16:05:33.058]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.024]   - Field: ‘stdout’
[16:05:33.058]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.024]   - Field: ‘earlySignal’
[16:05:33.058]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.025]   - Field: ‘lazy’
[16:05:33.058]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.025]   - Field: ‘state’
[16:05:33.058]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.025] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:33.059]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.025] - Launch lazy future ...
[16:05:33.059]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.025] Packages needed by the future expression (n = 0): <none>
[16:05:33.059]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.026] Packages needed by future strategies (n = 0): <none>
[16:05:33.059]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.026] {
[16:05:33.026]     {
[16:05:33.026]         {
[16:05:33.026]             ...future.startTime <- base::Sys.time()
[16:05:33.026]             {
[16:05:33.026]                 {
[16:05:33.026]                   {
[16:05:33.026]                     base::local({
[16:05:33.026]                       has_future <- base::requireNamespace("future", 
[16:05:33.026]                         quietly = TRUE)
[16:05:33.026]                       if (has_future) {
[16:05:33.026]                         ns <- base::getNamespace("future")
[16:05:33.026]                         version <- ns[[".package"]][["version"]]
[16:05:33.026]                         if (is.null(version)) 
[16:05:33.026]                           version <- utils::packageVersion("future")
[16:05:33.026]                       }
[16:05:33.026]                       else {
[16:05:33.026]                         version <- NULL
[16:05:33.026]                       }
[16:05:33.026]                       if (!has_future || version < "1.8.0") {
[16:05:33.026]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:33.026]                           "", base::R.version$version.string), 
[16:05:33.026]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:33.026]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:33.026]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:33.026]                             "release", "version")], collapse = " "), 
[16:05:33.026]                           hostname = base::Sys.info()[["nodename"]])
[16:05:33.026]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:33.026]                           info)
[16:05:33.026]                         info <- base::paste(info, collapse = "; ")
[16:05:33.026]                         if (!has_future) {
[16:05:33.026]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:33.026]                             info)
[16:05:33.026]                         }
[16:05:33.026]                         else {
[16:05:33.026]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:33.026]                             info, version)
[16:05:33.026]                         }
[16:05:33.026]                         base::stop(msg)
[16:05:33.026]                       }
[16:05:33.026]                     })
[16:05:33.026]                   }
[16:05:33.026]                   options(future.plan = NULL)
[16:05:33.026]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:33.026]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:33.026]                 }
[16:05:33.026]                 ...future.workdir <- getwd()
[16:05:33.026]             }
[16:05:33.026]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:33.026]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:33.026]         }
[16:05:33.026]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:33.026]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:33.026]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:33.026]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:33.026]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:33.026]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:33.026]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:33.026]             base::names(...future.oldOptions))
[16:05:33.026]     }
[16:05:33.026]     if (FALSE) {
[16:05:33.026]     }
[16:05:33.026]     else {
[16:05:33.026]         if (TRUE) {
[16:05:33.026]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:33.026]                 open = "w")
[16:05:33.026]         }
[16:05:33.026]         else {
[16:05:33.026]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:33.026]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:33.026]         }
[16:05:33.026]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:33.026]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:33.026]             base::sink(type = "output", split = FALSE)
[16:05:33.026]             base::close(...future.stdout)
[16:05:33.026]         }, add = TRUE)
[16:05:33.026]     }
[16:05:33.026]     ...future.frame <- base::sys.nframe()
[16:05:33.026]     ...future.conditions <- base::list()
[16:05:33.026]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:33.026]     if (FALSE) {
[16:05:33.026]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:33.026]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:33.026]     }
[16:05:33.026]     ...future.result <- base::tryCatch({
[16:05:33.026]         base::withCallingHandlers({
[16:05:33.026]             ...future.value <- base::withVisible(base::local({
[16:05:33.026]                 b <- 2L
[16:05:33.026]                 plan_b <- future::plan("list")
[16:05:33.026]                 nested_b <- nested_a[-1]
[16:05:33.026]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:05:33.026]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:05:33.026]                   "sequential"))
[16:05:33.026]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:05:33.026]                   b = b, nested_b = nested_b, plan_b = plan_b)
[16:05:33.026]             }))
[16:05:33.026]             future::FutureResult(value = ...future.value$value, 
[16:05:33.026]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:33.026]                   ...future.rng), globalenv = if (FALSE) 
[16:05:33.026]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:33.026]                     ...future.globalenv.names))
[16:05:33.026]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:33.026]         }, condition = base::local({
[16:05:33.026]             c <- base::c
[16:05:33.026]             inherits <- base::inherits
[16:05:33.026]             invokeRestart <- base::invokeRestart
[16:05:33.026]             length <- base::length
[16:05:33.026]             list <- base::list
[16:05:33.026]             seq.int <- base::seq.int
[16:05:33.026]             signalCondition <- base::signalCondition
[16:05:33.026]             sys.calls <- base::sys.calls
[16:05:33.026]             `[[` <- base::`[[`
[16:05:33.026]             `+` <- base::`+`
[16:05:33.026]             `<<-` <- base::`<<-`
[16:05:33.026]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:33.026]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:33.026]                   3L)]
[16:05:33.026]             }
[16:05:33.026]             function(cond) {
[16:05:33.026]                 is_error <- inherits(cond, "error")
[16:05:33.026]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:33.026]                   NULL)
[16:05:33.026]                 if (is_error) {
[16:05:33.026]                   sessionInformation <- function() {
[16:05:33.026]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:33.026]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:33.026]                       search = base::search(), system = base::Sys.info())
[16:05:33.026]                   }
[16:05:33.026]                   ...future.conditions[[length(...future.conditions) + 
[16:05:33.026]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:33.026]                     cond$call), session = sessionInformation(), 
[16:05:33.026]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:33.026]                   signalCondition(cond)
[16:05:33.026]                 }
[16:05:33.026]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:33.026]                 "immediateCondition"))) {
[16:05:33.026]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:33.026]                   ...future.conditions[[length(...future.conditions) + 
[16:05:33.026]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:33.026]                   if (TRUE && !signal) {
[16:05:33.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.026]                     {
[16:05:33.026]                       inherits <- base::inherits
[16:05:33.026]                       invokeRestart <- base::invokeRestart
[16:05:33.026]                       is.null <- base::is.null
[16:05:33.026]                       muffled <- FALSE
[16:05:33.026]                       if (inherits(cond, "message")) {
[16:05:33.026]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:33.026]                         if (muffled) 
[16:05:33.026]                           invokeRestart("muffleMessage")
[16:05:33.026]                       }
[16:05:33.026]                       else if (inherits(cond, "warning")) {
[16:05:33.026]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:33.026]                         if (muffled) 
[16:05:33.026]                           invokeRestart("muffleWarning")
[16:05:33.026]                       }
[16:05:33.026]                       else if (inherits(cond, "condition")) {
[16:05:33.026]                         if (!is.null(pattern)) {
[16:05:33.026]                           computeRestarts <- base::computeRestarts
[16:05:33.026]                           grepl <- base::grepl
[16:05:33.026]                           restarts <- computeRestarts(cond)
[16:05:33.026]                           for (restart in restarts) {
[16:05:33.026]                             name <- restart$name
[16:05:33.026]                             if (is.null(name)) 
[16:05:33.026]                               next
[16:05:33.026]                             if (!grepl(pattern, name)) 
[16:05:33.026]                               next
[16:05:33.026]                             invokeRestart(restart)
[16:05:33.026]                             muffled <- TRUE
[16:05:33.026]                             break
[16:05:33.026]                           }
[16:05:33.026]                         }
[16:05:33.026]                       }
[16:05:33.026]                       invisible(muffled)
[16:05:33.026]                     }
[16:05:33.026]                     muffleCondition(cond, pattern = "^muffle")
[16:05:33.026]                   }
[16:05:33.026]                 }
[16:05:33.026]                 else {
[16:05:33.026]                   if (TRUE) {
[16:05:33.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.026]                     {
[16:05:33.026]                       inherits <- base::inherits
[16:05:33.026]                       invokeRestart <- base::invokeRestart
[16:05:33.026]                       is.null <- base::is.null
[16:05:33.026]                       muffled <- FALSE
[16:05:33.026]                       if (inherits(cond, "message")) {
[16:05:33.026]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:33.026]                         if (muffled) 
[16:05:33.026]                           invokeRestart("muffleMessage")
[16:05:33.026]                       }
[16:05:33.026]                       else if (inherits(cond, "warning")) {
[16:05:33.026]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:33.026]                         if (muffled) 
[16:05:33.026]                           invokeRestart("muffleWarning")
[16:05:33.026]                       }
[16:05:33.026]                       else if (inherits(cond, "condition")) {
[16:05:33.026]                         if (!is.null(pattern)) {
[16:05:33.026]                           computeRestarts <- base::computeRestarts
[16:05:33.026]                           grepl <- base::grepl
[16:05:33.026]                           restarts <- computeRestarts(cond)
[16:05:33.026]                           for (restart in restarts) {
[16:05:33.026]                             name <- restart$name
[16:05:33.026]                             if (is.null(name)) 
[16:05:33.026]                               next
[16:05:33.026]                             if (!grepl(pattern, name)) 
[16:05:33.026]                               next
[16:05:33.026]                             invokeRestart(restart)
[16:05:33.026]                             muffled <- TRUE
[16:05:33.026]                             break
[16:05:33.026]                           }
[16:05:33.026]                         }
[16:05:33.026]                       }
[16:05:33.026]                       invisible(muffled)
[16:05:33.026]                     }
[16:05:33.026]                     muffleCondition(cond, pattern = "^muffle")
[16:05:33.026]                   }
[16:05:33.026]                 }
[16:05:33.026]             }
[16:05:33.026]         }))
[16:05:33.026]     }, error = function(ex) {
[16:05:33.026]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:33.026]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:33.026]                 ...future.rng), started = ...future.startTime, 
[16:05:33.026]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:33.026]             version = "1.8"), class = "FutureResult")
[16:05:33.026]     }, finally = {
[16:05:33.026]         if (!identical(...future.workdir, getwd())) 
[16:05:33.026]             setwd(...future.workdir)
[16:05:33.026]         {
[16:05:33.026]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:33.026]                 ...future.oldOptions$nwarnings <- NULL
[16:05:33.026]             }
[16:05:33.026]             base::options(...future.oldOptions)
[16:05:33.026]             if (.Platform$OS.type == "windows") {
[16:05:33.026]                 old_names <- names(...future.oldEnvVars)
[16:05:33.026]                 envs <- base::Sys.getenv()
[16:05:33.026]                 names <- names(envs)
[16:05:33.026]                 common <- intersect(names, old_names)
[16:05:33.026]                 added <- setdiff(names, old_names)
[16:05:33.026]                 removed <- setdiff(old_names, names)
[16:05:33.026]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:33.026]                   envs[common]]
[16:05:33.026]                 NAMES <- toupper(changed)
[16:05:33.026]                 args <- list()
[16:05:33.026]                 for (kk in seq_along(NAMES)) {
[16:05:33.026]                   name <- changed[[kk]]
[16:05:33.026]                   NAME <- NAMES[[kk]]
[16:05:33.026]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.026]                     next
[16:05:33.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:33.026]                 }
[16:05:33.026]                 NAMES <- toupper(added)
[16:05:33.026]                 for (kk in seq_along(NAMES)) {
[16:05:33.026]                   name <- added[[kk]]
[16:05:33.026]                   NAME <- NAMES[[kk]]
[16:05:33.026]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.026]                     next
[16:05:33.026]                   args[[name]] <- ""
[16:05:33.026]                 }
[16:05:33.026]                 NAMES <- toupper(removed)
[16:05:33.026]                 for (kk in seq_along(NAMES)) {
[16:05:33.026]                   name <- removed[[kk]]
[16:05:33.026]                   NAME <- NAMES[[kk]]
[16:05:33.026]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.026]                     next
[16:05:33.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:33.026]                 }
[16:05:33.026]                 if (length(args) > 0) 
[16:05:33.026]                   base::do.call(base::Sys.setenv, args = args)
[16:05:33.026]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:33.026]             }
[16:05:33.026]             else {
[16:05:33.026]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:33.026]             }
[16:05:33.026]             {
[16:05:33.026]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:33.026]                   0L) {
[16:05:33.026]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:33.026]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:33.026]                   base::options(opts)
[16:05:33.026]                 }
[16:05:33.026]                 {
[16:05:33.026]                   {
[16:05:33.026]                     NULL
[16:05:33.026]                     RNGkind("Mersenne-Twister")
[16:05:33.026]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:33.026]                       inherits = FALSE)
[16:05:33.026]                   }
[16:05:33.026]                   options(future.plan = NULL)
[16:05:33.026]                   if (is.na(NA_character_)) 
[16:05:33.026]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:33.026]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:33.026]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:33.026]                     envir = parent.frame()) 
[16:05:33.026]                   {
[16:05:33.026]                     default_workers <- missing(workers)
[16:05:33.026]                     if (is.function(workers)) 
[16:05:33.026]                       workers <- workers()
[16:05:33.026]                     workers <- structure(as.integer(workers), 
[16:05:33.026]                       class = class(workers))
[16:05:33.026]                     stop_if_not(is.finite(workers), workers >= 
[16:05:33.026]                       1L)
[16:05:33.026]                     if ((workers == 1L && !inherits(workers, 
[16:05:33.026]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:33.026]                       if (default_workers) 
[16:05:33.026]                         supportsMulticore(warn = TRUE)
[16:05:33.026]                       return(sequential(..., envir = envir))
[16:05:33.026]                     }
[16:05:33.026]                     oopts <- options(mc.cores = workers)
[16:05:33.026]                     on.exit(options(oopts))
[16:05:33.026]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:33.026]                       envir = envir)
[16:05:33.026]                     if (!future$lazy) 
[16:05:33.026]                       future <- run(future)
[16:05:33.026]                     invisible(future)
[16:05:33.026]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:33.026]                 }
[16:05:33.026]             }
[16:05:33.026]         }
[16:05:33.026]     })
[16:05:33.026]     if (TRUE) {
[16:05:33.026]         base::sink(type = "output", split = FALSE)
[16:05:33.026]         if (TRUE) {
[16:05:33.026]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:33.026]         }
[16:05:33.026]         else {
[16:05:33.026]             ...future.result["stdout"] <- base::list(NULL)
[16:05:33.026]         }
[16:05:33.026]         base::close(...future.stdout)
[16:05:33.026]         ...future.stdout <- NULL
[16:05:33.026]     }
[16:05:33.026]     ...future.result$conditions <- ...future.conditions
[16:05:33.026]     ...future.result$finished <- base::Sys.time()
[16:05:33.026]     ...future.result
[16:05:33.026] }
[16:05:33.059]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.029] assign_globals() ...
[16:05:33.059]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.029] List of 3
[16:05:33.029]  $ nested_a:List of 1
[16:05:33.029]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:05:33.029]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:05:33.029]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:05:33.029]  $ a       : int 1
[16:05:33.029]  $ plan_a  :List of 1
[16:05:33.029]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:05:33.029]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:05:33.029]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:05:33.029]  - attr(*, "where")=List of 3
[16:05:33.029]   ..$ nested_a:<environment: R_EmptyEnv> 
[16:05:33.029]   ..$ a       :<environment: R_EmptyEnv> 
[16:05:33.029]   ..$ plan_a  :<environment: R_EmptyEnv> 
[16:05:33.029]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:33.029]  - attr(*, "resolved")= logi FALSE
[16:05:33.029]  - attr(*, "total_size")= num 95240
[16:05:33.029]  - attr(*, "already-done")= logi TRUE
[16:05:33.060]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.036] - copied ‘nested_a’ to environment
[16:05:33.060]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.036] - copied ‘a’ to environment
[16:05:33.060]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.037] - copied ‘plan_a’ to environment
[16:05:33.060]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.037] assign_globals() ... done
[16:05:33.060]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.037] plan(): Setting new future strategy stack:
[16:05:33.060]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.037] List of future strategies:
[16:05:33.037] 1. sequential:
[16:05:33.037]    - args: function (..., envir = parent.frame())
[16:05:33.037]    - tweaked: FALSE
[16:05:33.037]    - call: NULL
[16:05:33.061]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.038] plan(): nbrOfWorkers() = 1
[16:05:33.061]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.039] plan(): Setting new future strategy stack:
[16:05:33.061]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.039] List of future strategies:
[16:05:33.039] 1. multicore:
[16:05:33.039]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:33.039]    - tweaked: FALSE
[16:05:33.039]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.061]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.043] plan(): nbrOfWorkers() = 1
[16:05:33.061]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.043] SequentialFuture started (and completed)
[16:05:33.061]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.043] - Launch lazy future ... done
[16:05:33.061]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.043] run() for ‘SequentialFuture’ ... done
[16:05:33.062] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:05:33.068] getGlobalsAndPackages() ...
[16:05:33.068] Searching for globals...
[16:05:33.069] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:05:33.070] Searching for globals ... DONE
[16:05:33.070] Resolving globals: FALSE
[16:05:33.070] The total size of the 1 globals is 128 bytes (128 bytes)
[16:05:33.071] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:05:33.071] - globals: [1] ‘data’
[16:05:33.071] - packages: [1] ‘future’
[16:05:33.071] getGlobalsAndPackages() ... DONE
[16:05:33.072] run() for ‘Future’ ...
[16:05:33.072] - state: ‘created’
[16:05:33.072] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:33.076] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:33.076] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:33.077]   - Field: ‘label’
[16:05:33.077]   - Field: ‘local’
[16:05:33.077]   - Field: ‘owner’
[16:05:33.077]   - Field: ‘envir’
[16:05:33.077]   - Field: ‘workers’
[16:05:33.077]   - Field: ‘packages’
[16:05:33.077]   - Field: ‘gc’
[16:05:33.077]   - Field: ‘job’
[16:05:33.078]   - Field: ‘conditions’
[16:05:33.078]   - Field: ‘expr’
[16:05:33.078]   - Field: ‘uuid’
[16:05:33.078]   - Field: ‘seed’
[16:05:33.078]   - Field: ‘version’
[16:05:33.078]   - Field: ‘result’
[16:05:33.078]   - Field: ‘asynchronous’
[16:05:33.078]   - Field: ‘calls’
[16:05:33.078]   - Field: ‘globals’
[16:05:33.079]   - Field: ‘stdout’
[16:05:33.079]   - Field: ‘earlySignal’
[16:05:33.079]   - Field: ‘lazy’
[16:05:33.079]   - Field: ‘state’
[16:05:33.079] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:33.079] - Launch lazy future ...
[16:05:33.079] Packages needed by the future expression (n = 1): ‘future’
[16:05:33.080] Packages needed by future strategies (n = 1): ‘future’
[16:05:33.080] {
[16:05:33.080]     {
[16:05:33.080]         {
[16:05:33.080]             ...future.startTime <- base::Sys.time()
[16:05:33.080]             {
[16:05:33.080]                 {
[16:05:33.080]                   {
[16:05:33.080]                     {
[16:05:33.080]                       {
[16:05:33.080]                         base::local({
[16:05:33.080]                           has_future <- base::requireNamespace("future", 
[16:05:33.080]                             quietly = TRUE)
[16:05:33.080]                           if (has_future) {
[16:05:33.080]                             ns <- base::getNamespace("future")
[16:05:33.080]                             version <- ns[[".package"]][["version"]]
[16:05:33.080]                             if (is.null(version)) 
[16:05:33.080]                               version <- utils::packageVersion("future")
[16:05:33.080]                           }
[16:05:33.080]                           else {
[16:05:33.080]                             version <- NULL
[16:05:33.080]                           }
[16:05:33.080]                           if (!has_future || version < "1.8.0") {
[16:05:33.080]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:33.080]                               "", base::R.version$version.string), 
[16:05:33.080]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:33.080]                                 base::R.version$platform, 8 * 
[16:05:33.080]                                   base::.Machine$sizeof.pointer), 
[16:05:33.080]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:33.080]                                 "release", "version")], collapse = " "), 
[16:05:33.080]                               hostname = base::Sys.info()[["nodename"]])
[16:05:33.080]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:33.080]                               info)
[16:05:33.080]                             info <- base::paste(info, collapse = "; ")
[16:05:33.080]                             if (!has_future) {
[16:05:33.080]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:33.080]                                 info)
[16:05:33.080]                             }
[16:05:33.080]                             else {
[16:05:33.080]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:33.080]                                 info, version)
[16:05:33.080]                             }
[16:05:33.080]                             base::stop(msg)
[16:05:33.080]                           }
[16:05:33.080]                         })
[16:05:33.080]                       }
[16:05:33.080]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:33.080]                       base::options(mc.cores = 1L)
[16:05:33.080]                     }
[16:05:33.080]                     base::local({
[16:05:33.080]                       for (pkg in "future") {
[16:05:33.080]                         base::loadNamespace(pkg)
[16:05:33.080]                         base::library(pkg, character.only = TRUE)
[16:05:33.080]                       }
[16:05:33.080]                     })
[16:05:33.080]                   }
[16:05:33.080]                   options(future.plan = NULL)
[16:05:33.080]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:33.080]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:33.080]                     envir = parent.frame()) 
[16:05:33.080]                   {
[16:05:33.080]                     default_workers <- missing(workers)
[16:05:33.080]                     if (is.function(workers)) 
[16:05:33.080]                       workers <- workers()
[16:05:33.080]                     workers <- structure(as.integer(workers), 
[16:05:33.080]                       class = class(workers))
[16:05:33.080]                     stop_if_not(is.finite(workers), workers >= 
[16:05:33.080]                       1L)
[16:05:33.080]                     if ((workers == 1L && !inherits(workers, 
[16:05:33.080]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:33.080]                       if (default_workers) 
[16:05:33.080]                         supportsMulticore(warn = TRUE)
[16:05:33.080]                       return(sequential(..., envir = envir))
[16:05:33.080]                     }
[16:05:33.080]                     oopts <- options(mc.cores = workers)
[16:05:33.080]                     on.exit(options(oopts))
[16:05:33.080]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:33.080]                       envir = envir)
[16:05:33.080]                     if (!future$lazy) 
[16:05:33.080]                       future <- run(future)
[16:05:33.080]                     invisible(future)
[16:05:33.080]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:33.080]                 }
[16:05:33.080]                 ...future.workdir <- getwd()
[16:05:33.080]             }
[16:05:33.080]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:33.080]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:33.080]         }
[16:05:33.080]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:33.080]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:33.080]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:33.080]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:33.080]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:33.080]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:33.080]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:33.080]             base::names(...future.oldOptions))
[16:05:33.080]     }
[16:05:33.080]     if (FALSE) {
[16:05:33.080]     }
[16:05:33.080]     else {
[16:05:33.080]         if (TRUE) {
[16:05:33.080]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:33.080]                 open = "w")
[16:05:33.080]         }
[16:05:33.080]         else {
[16:05:33.080]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:33.080]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:33.080]         }
[16:05:33.080]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:33.080]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:33.080]             base::sink(type = "output", split = FALSE)
[16:05:33.080]             base::close(...future.stdout)
[16:05:33.080]         }, add = TRUE)
[16:05:33.080]     }
[16:05:33.080]     ...future.frame <- base::sys.nframe()
[16:05:33.080]     ...future.conditions <- base::list()
[16:05:33.080]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:33.080]     if (FALSE) {
[16:05:33.080]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:33.080]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:33.080]     }
[16:05:33.080]     ...future.result <- base::tryCatch({
[16:05:33.080]         base::withCallingHandlers({
[16:05:33.080]             ...future.value <- base::withVisible(base::local({
[16:05:33.080]                 withCallingHandlers({
[16:05:33.080]                   {
[16:05:33.080]                     value(future(subset(data, a == 2)))
[16:05:33.080]                   }
[16:05:33.080]                 }, immediateCondition = function(cond) {
[16:05:33.080]                   save_rds <- function (object, pathname, ...) 
[16:05:33.080]                   {
[16:05:33.080]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:33.080]                     if (file_test("-f", pathname_tmp)) {
[16:05:33.080]                       fi_tmp <- file.info(pathname_tmp)
[16:05:33.080]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:33.080]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:33.080]                         fi_tmp[["mtime"]])
[16:05:33.080]                     }
[16:05:33.080]                     tryCatch({
[16:05:33.080]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:33.080]                     }, error = function(ex) {
[16:05:33.080]                       msg <- conditionMessage(ex)
[16:05:33.080]                       fi_tmp <- file.info(pathname_tmp)
[16:05:33.080]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:33.080]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:33.080]                         fi_tmp[["mtime"]], msg)
[16:05:33.080]                       ex$message <- msg
[16:05:33.080]                       stop(ex)
[16:05:33.080]                     })
[16:05:33.080]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:33.080]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:33.080]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:33.080]                       fi_tmp <- file.info(pathname_tmp)
[16:05:33.080]                       fi <- file.info(pathname)
[16:05:33.080]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:33.080]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:33.080]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:33.080]                         fi[["size"]], fi[["mtime"]])
[16:05:33.080]                       stop(msg)
[16:05:33.080]                     }
[16:05:33.080]                     invisible(pathname)
[16:05:33.080]                   }
[16:05:33.080]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:33.080]                     rootPath = tempdir()) 
[16:05:33.080]                   {
[16:05:33.080]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:33.080]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:33.080]                       tmpdir = path, fileext = ".rds")
[16:05:33.080]                     save_rds(obj, file)
[16:05:33.080]                   }
[16:05:33.080]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0EbAi0/.future/immediateConditions")
[16:05:33.080]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.080]                   {
[16:05:33.080]                     inherits <- base::inherits
[16:05:33.080]                     invokeRestart <- base::invokeRestart
[16:05:33.080]                     is.null <- base::is.null
[16:05:33.080]                     muffled <- FALSE
[16:05:33.080]                     if (inherits(cond, "message")) {
[16:05:33.080]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:33.080]                       if (muffled) 
[16:05:33.080]                         invokeRestart("muffleMessage")
[16:05:33.080]                     }
[16:05:33.080]                     else if (inherits(cond, "warning")) {
[16:05:33.080]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:33.080]                       if (muffled) 
[16:05:33.080]                         invokeRestart("muffleWarning")
[16:05:33.080]                     }
[16:05:33.080]                     else if (inherits(cond, "condition")) {
[16:05:33.080]                       if (!is.null(pattern)) {
[16:05:33.080]                         computeRestarts <- base::computeRestarts
[16:05:33.080]                         grepl <- base::grepl
[16:05:33.080]                         restarts <- computeRestarts(cond)
[16:05:33.080]                         for (restart in restarts) {
[16:05:33.080]                           name <- restart$name
[16:05:33.080]                           if (is.null(name)) 
[16:05:33.080]                             next
[16:05:33.080]                           if (!grepl(pattern, name)) 
[16:05:33.080]                             next
[16:05:33.080]                           invokeRestart(restart)
[16:05:33.080]                           muffled <- TRUE
[16:05:33.080]                           break
[16:05:33.080]                         }
[16:05:33.080]                       }
[16:05:33.080]                     }
[16:05:33.080]                     invisible(muffled)
[16:05:33.080]                   }
[16:05:33.080]                   muffleCondition(cond)
[16:05:33.080]                 })
[16:05:33.080]             }))
[16:05:33.080]             future::FutureResult(value = ...future.value$value, 
[16:05:33.080]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:33.080]                   ...future.rng), globalenv = if (FALSE) 
[16:05:33.080]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:33.080]                     ...future.globalenv.names))
[16:05:33.080]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:33.080]         }, condition = base::local({
[16:05:33.080]             c <- base::c
[16:05:33.080]             inherits <- base::inherits
[16:05:33.080]             invokeRestart <- base::invokeRestart
[16:05:33.080]             length <- base::length
[16:05:33.080]             list <- base::list
[16:05:33.080]             seq.int <- base::seq.int
[16:05:33.080]             signalCondition <- base::signalCondition
[16:05:33.080]             sys.calls <- base::sys.calls
[16:05:33.080]             `[[` <- base::`[[`
[16:05:33.080]             `+` <- base::`+`
[16:05:33.080]             `<<-` <- base::`<<-`
[16:05:33.080]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:33.080]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:33.080]                   3L)]
[16:05:33.080]             }
[16:05:33.080]             function(cond) {
[16:05:33.080]                 is_error <- inherits(cond, "error")
[16:05:33.080]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:33.080]                   NULL)
[16:05:33.080]                 if (is_error) {
[16:05:33.080]                   sessionInformation <- function() {
[16:05:33.080]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:33.080]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:33.080]                       search = base::search(), system = base::Sys.info())
[16:05:33.080]                   }
[16:05:33.080]                   ...future.conditions[[length(...future.conditions) + 
[16:05:33.080]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:33.080]                     cond$call), session = sessionInformation(), 
[16:05:33.080]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:33.080]                   signalCondition(cond)
[16:05:33.080]                 }
[16:05:33.080]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:33.080]                 "immediateCondition"))) {
[16:05:33.080]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:33.080]                   ...future.conditions[[length(...future.conditions) + 
[16:05:33.080]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:33.080]                   if (TRUE && !signal) {
[16:05:33.080]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.080]                     {
[16:05:33.080]                       inherits <- base::inherits
[16:05:33.080]                       invokeRestart <- base::invokeRestart
[16:05:33.080]                       is.null <- base::is.null
[16:05:33.080]                       muffled <- FALSE
[16:05:33.080]                       if (inherits(cond, "message")) {
[16:05:33.080]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:33.080]                         if (muffled) 
[16:05:33.080]                           invokeRestart("muffleMessage")
[16:05:33.080]                       }
[16:05:33.080]                       else if (inherits(cond, "warning")) {
[16:05:33.080]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:33.080]                         if (muffled) 
[16:05:33.080]                           invokeRestart("muffleWarning")
[16:05:33.080]                       }
[16:05:33.080]                       else if (inherits(cond, "condition")) {
[16:05:33.080]                         if (!is.null(pattern)) {
[16:05:33.080]                           computeRestarts <- base::computeRestarts
[16:05:33.080]                           grepl <- base::grepl
[16:05:33.080]                           restarts <- computeRestarts(cond)
[16:05:33.080]                           for (restart in restarts) {
[16:05:33.080]                             name <- restart$name
[16:05:33.080]                             if (is.null(name)) 
[16:05:33.080]                               next
[16:05:33.080]                             if (!grepl(pattern, name)) 
[16:05:33.080]                               next
[16:05:33.080]                             invokeRestart(restart)
[16:05:33.080]                             muffled <- TRUE
[16:05:33.080]                             break
[16:05:33.080]                           }
[16:05:33.080]                         }
[16:05:33.080]                       }
[16:05:33.080]                       invisible(muffled)
[16:05:33.080]                     }
[16:05:33.080]                     muffleCondition(cond, pattern = "^muffle")
[16:05:33.080]                   }
[16:05:33.080]                 }
[16:05:33.080]                 else {
[16:05:33.080]                   if (TRUE) {
[16:05:33.080]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.080]                     {
[16:05:33.080]                       inherits <- base::inherits
[16:05:33.080]                       invokeRestart <- base::invokeRestart
[16:05:33.080]                       is.null <- base::is.null
[16:05:33.080]                       muffled <- FALSE
[16:05:33.080]                       if (inherits(cond, "message")) {
[16:05:33.080]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:33.080]                         if (muffled) 
[16:05:33.080]                           invokeRestart("muffleMessage")
[16:05:33.080]                       }
[16:05:33.080]                       else if (inherits(cond, "warning")) {
[16:05:33.080]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:33.080]                         if (muffled) 
[16:05:33.080]                           invokeRestart("muffleWarning")
[16:05:33.080]                       }
[16:05:33.080]                       else if (inherits(cond, "condition")) {
[16:05:33.080]                         if (!is.null(pattern)) {
[16:05:33.080]                           computeRestarts <- base::computeRestarts
[16:05:33.080]                           grepl <- base::grepl
[16:05:33.080]                           restarts <- computeRestarts(cond)
[16:05:33.080]                           for (restart in restarts) {
[16:05:33.080]                             name <- restart$name
[16:05:33.080]                             if (is.null(name)) 
[16:05:33.080]                               next
[16:05:33.080]                             if (!grepl(pattern, name)) 
[16:05:33.080]                               next
[16:05:33.080]                             invokeRestart(restart)
[16:05:33.080]                             muffled <- TRUE
[16:05:33.080]                             break
[16:05:33.080]                           }
[16:05:33.080]                         }
[16:05:33.080]                       }
[16:05:33.080]                       invisible(muffled)
[16:05:33.080]                     }
[16:05:33.080]                     muffleCondition(cond, pattern = "^muffle")
[16:05:33.080]                   }
[16:05:33.080]                 }
[16:05:33.080]             }
[16:05:33.080]         }))
[16:05:33.080]     }, error = function(ex) {
[16:05:33.080]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:33.080]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:33.080]                 ...future.rng), started = ...future.startTime, 
[16:05:33.080]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:33.080]             version = "1.8"), class = "FutureResult")
[16:05:33.080]     }, finally = {
[16:05:33.080]         if (!identical(...future.workdir, getwd())) 
[16:05:33.080]             setwd(...future.workdir)
[16:05:33.080]         {
[16:05:33.080]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:33.080]                 ...future.oldOptions$nwarnings <- NULL
[16:05:33.080]             }
[16:05:33.080]             base::options(...future.oldOptions)
[16:05:33.080]             if (.Platform$OS.type == "windows") {
[16:05:33.080]                 old_names <- names(...future.oldEnvVars)
[16:05:33.080]                 envs <- base::Sys.getenv()
[16:05:33.080]                 names <- names(envs)
[16:05:33.080]                 common <- intersect(names, old_names)
[16:05:33.080]                 added <- setdiff(names, old_names)
[16:05:33.080]                 removed <- setdiff(old_names, names)
[16:05:33.080]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:33.080]                   envs[common]]
[16:05:33.080]                 NAMES <- toupper(changed)
[16:05:33.080]                 args <- list()
[16:05:33.080]                 for (kk in seq_along(NAMES)) {
[16:05:33.080]                   name <- changed[[kk]]
[16:05:33.080]                   NAME <- NAMES[[kk]]
[16:05:33.080]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.080]                     next
[16:05:33.080]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:33.080]                 }
[16:05:33.080]                 NAMES <- toupper(added)
[16:05:33.080]                 for (kk in seq_along(NAMES)) {
[16:05:33.080]                   name <- added[[kk]]
[16:05:33.080]                   NAME <- NAMES[[kk]]
[16:05:33.080]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.080]                     next
[16:05:33.080]                   args[[name]] <- ""
[16:05:33.080]                 }
[16:05:33.080]                 NAMES <- toupper(removed)
[16:05:33.080]                 for (kk in seq_along(NAMES)) {
[16:05:33.080]                   name <- removed[[kk]]
[16:05:33.080]                   NAME <- NAMES[[kk]]
[16:05:33.080]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.080]                     next
[16:05:33.080]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:33.080]                 }
[16:05:33.080]                 if (length(args) > 0) 
[16:05:33.080]                   base::do.call(base::Sys.setenv, args = args)
[16:05:33.080]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:33.080]             }
[16:05:33.080]             else {
[16:05:33.080]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:33.080]             }
[16:05:33.080]             {
[16:05:33.080]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:33.080]                   0L) {
[16:05:33.080]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:33.080]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:33.080]                   base::options(opts)
[16:05:33.080]                 }
[16:05:33.080]                 {
[16:05:33.080]                   {
[16:05:33.080]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:33.080]                     NULL
[16:05:33.080]                   }
[16:05:33.080]                   options(future.plan = NULL)
[16:05:33.080]                   if (is.na(NA_character_)) 
[16:05:33.080]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:33.080]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:33.080]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:33.080]                     envir = parent.frame()) 
[16:05:33.080]                   {
[16:05:33.080]                     default_workers <- missing(workers)
[16:05:33.080]                     if (is.function(workers)) 
[16:05:33.080]                       workers <- workers()
[16:05:33.080]                     workers <- structure(as.integer(workers), 
[16:05:33.080]                       class = class(workers))
[16:05:33.080]                     stop_if_not(is.finite(workers), workers >= 
[16:05:33.080]                       1L)
[16:05:33.080]                     if ((workers == 1L && !inherits(workers, 
[16:05:33.080]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:33.080]                       if (default_workers) 
[16:05:33.080]                         supportsMulticore(warn = TRUE)
[16:05:33.080]                       return(sequential(..., envir = envir))
[16:05:33.080]                     }
[16:05:33.080]                     oopts <- options(mc.cores = workers)
[16:05:33.080]                     on.exit(options(oopts))
[16:05:33.080]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:33.080]                       envir = envir)
[16:05:33.080]                     if (!future$lazy) 
[16:05:33.080]                       future <- run(future)
[16:05:33.080]                     invisible(future)
[16:05:33.080]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:33.080]                     envir = parent.frame()) 
[16:05:33.080]                   {
[16:05:33.080]                     default_workers <- missing(workers)
[16:05:33.080]                     if (is.function(workers)) 
[16:05:33.080]                       workers <- workers()
[16:05:33.080]                     workers <- structure(as.integer(workers), 
[16:05:33.080]                       class = class(workers))
[16:05:33.080]                     stop_if_not(is.finite(workers), workers >= 
[16:05:33.080]                       1L)
[16:05:33.080]                     if ((workers == 1L && !inherits(workers, 
[16:05:33.080]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:33.080]                       if (default_workers) 
[16:05:33.080]                         supportsMulticore(warn = TRUE)
[16:05:33.080]                       return(sequential(..., envir = envir))
[16:05:33.080]                     }
[16:05:33.080]                     oopts <- options(mc.cores = workers)
[16:05:33.080]                     on.exit(options(oopts))
[16:05:33.080]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:33.080]                       envir = envir)
[16:05:33.080]                     if (!future$lazy) 
[16:05:33.080]                       future <- run(future)
[16:05:33.080]                     invisible(future)
[16:05:33.080]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:33.080]                 }
[16:05:33.080]             }
[16:05:33.080]         }
[16:05:33.080]     })
[16:05:33.080]     if (TRUE) {
[16:05:33.080]         base::sink(type = "output", split = FALSE)
[16:05:33.080]         if (TRUE) {
[16:05:33.080]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:33.080]         }
[16:05:33.080]         else {
[16:05:33.080]             ...future.result["stdout"] <- base::list(NULL)
[16:05:33.080]         }
[16:05:33.080]         base::close(...future.stdout)
[16:05:33.080]         ...future.stdout <- NULL
[16:05:33.080]     }
[16:05:33.080]     ...future.result$conditions <- ...future.conditions
[16:05:33.080]     ...future.result$finished <- base::Sys.time()
[16:05:33.080]     ...future.result
[16:05:33.080] }
[16:05:33.083] assign_globals() ...
[16:05:33.083] List of 1
[16:05:33.083]  $ data:'data.frame':	3 obs. of  2 variables:
[16:05:33.083]   ..$ a: int [1:3] 1 2 3
[16:05:33.083]   ..$ b: int [1:3] 3 2 1
[16:05:33.083]  - attr(*, "where")=List of 1
[16:05:33.083]   ..$ data:<environment: R_EmptyEnv> 
[16:05:33.083]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:33.083]  - attr(*, "resolved")= logi FALSE
[16:05:33.083]  - attr(*, "total_size")= num 128
[16:05:33.083]  - attr(*, "already-done")= logi TRUE
[16:05:33.087] - copied ‘data’ to environment
[16:05:33.087] assign_globals() ... done
[16:05:33.087] requestCore(): workers = 2
[16:05:33.089] MulticoreFuture started
[16:05:33.090] - Launch lazy future ... done
[16:05:33.090] run() for ‘MulticoreFuture’ ... done
[16:05:33.090] result() for MulticoreFuture ...
[16:05:33.091] plan(): Setting new future strategy stack:
[16:05:33.091] List of future strategies:
[16:05:33.091] 1. multicore:
[16:05:33.091]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:33.091]    - tweaked: FALSE
[16:05:33.091]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.097] plan(): nbrOfWorkers() = 1
[16:05:33.132] plan(): Setting new future strategy stack:
[16:05:33.132] List of future strategies:
[16:05:33.132] 1. multicore:
[16:05:33.132]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:33.132]    - tweaked: FALSE
[16:05:33.132]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.132] 2. multicore:
[16:05:33.132]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:33.132]    - tweaked: FALSE
[16:05:33.132]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.136] plan(): nbrOfWorkers() = 2
[16:05:33.137] result() for MulticoreFuture ...
[16:05:33.137] result() for MulticoreFuture ... done
[16:05:33.137] signalConditions() ...
[16:05:33.137]  - include = ‘immediateCondition’
[16:05:33.137]  - exclude = 
[16:05:33.137]  - resignal = FALSE
[16:05:33.137]  - Number of conditions: 52
[16:05:33.138] signalConditions() ... done
[16:05:33.138] result() for MulticoreFuture ... done
[16:05:33.138] result() for MulticoreFuture ...
[16:05:33.138] result() for MulticoreFuture ... done
[16:05:33.138] signalConditions() ...
[16:05:33.138]  - include = ‘immediateCondition’
[16:05:33.138]  - exclude = 
[16:05:33.138]  - resignal = FALSE
[16:05:33.138]  - Number of conditions: 52
[16:05:33.139] signalConditions() ... done
[16:05:33.139] Future state: ‘finished’
[16:05:33.139] result() for MulticoreFuture ...
[16:05:33.139] result() for MulticoreFuture ... done
[16:05:33.139] signalConditions() ...
[16:05:33.139]  - include = ‘condition’
[16:05:33.139]  - exclude = ‘immediateCondition’
[16:05:33.139]  - resignal = TRUE
[16:05:33.140]  - Number of conditions: 52
[16:05:33.140]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.098] getGlobalsAndPackages() ...
[16:05:33.140]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.098] Searching for globals...
[16:05:33.140]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.099] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[16:05:33.140]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.100] Searching for globals ... DONE
[16:05:33.140]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.100] Resolving globals: FALSE
[16:05:33.141]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.101] The total size of the 1 globals is 128 bytes (128 bytes)
[16:05:33.141]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.101] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:05:33.141]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.101] - globals: [1] ‘data’
[16:05:33.141]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.102] 
[16:05:33.141]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.102] getGlobalsAndPackages() ... DONE
[16:05:33.141]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.103] run() for ‘Future’ ...
[16:05:33.142]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.103] - state: ‘created’
[16:05:33.142]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.103] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:33.142]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.107] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:33.142]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.107] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:33.142]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.107]   - Field: ‘label’
[16:05:33.142]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.107]   - Field: ‘local’
[16:05:33.142]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.108]   - Field: ‘owner’
[16:05:33.143]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.108]   - Field: ‘envir’
[16:05:33.143]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.108]   - Field: ‘packages’
[16:05:33.143]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.108]   - Field: ‘gc’
[16:05:33.143]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.108]   - Field: ‘conditions’
[16:05:33.143]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.108]   - Field: ‘expr’
[16:05:33.143]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.109]   - Field: ‘uuid’
[16:05:33.144]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.109]   - Field: ‘seed’
[16:05:33.144]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.109]   - Field: ‘version’
[16:05:33.144]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.109]   - Field: ‘result’
[16:05:33.144]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.109]   - Field: ‘asynchronous’
[16:05:33.144]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.109]   - Field: ‘calls’
[16:05:33.144]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.109]   - Field: ‘globals’
[16:05:33.145]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.110]   - Field: ‘stdout’
[16:05:33.145]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.110]   - Field: ‘earlySignal’
[16:05:33.145]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.110]   - Field: ‘lazy’
[16:05:33.145]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.110]   - Field: ‘state’
[16:05:33.145]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.110] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:33.145]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.110] - Launch lazy future ...
[16:05:33.145]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.111] Packages needed by the future expression (n = 0): <none>
[16:05:33.146]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.111] Packages needed by future strategies (n = 0): <none>
[16:05:33.146]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.112] {
[16:05:33.112]     {
[16:05:33.112]         {
[16:05:33.112]             ...future.startTime <- base::Sys.time()
[16:05:33.112]             {
[16:05:33.112]                 {
[16:05:33.112]                   {
[16:05:33.112]                     base::local({
[16:05:33.112]                       has_future <- base::requireNamespace("future", 
[16:05:33.112]                         quietly = TRUE)
[16:05:33.112]                       if (has_future) {
[16:05:33.112]                         ns <- base::getNamespace("future")
[16:05:33.112]                         version <- ns[[".package"]][["version"]]
[16:05:33.112]                         if (is.null(version)) 
[16:05:33.112]                           version <- utils::packageVersion("future")
[16:05:33.112]                       }
[16:05:33.112]                       else {
[16:05:33.112]                         version <- NULL
[16:05:33.112]                       }
[16:05:33.112]                       if (!has_future || version < "1.8.0") {
[16:05:33.112]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:33.112]                           "", base::R.version$version.string), 
[16:05:33.112]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:33.112]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:33.112]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:33.112]                             "release", "version")], collapse = " "), 
[16:05:33.112]                           hostname = base::Sys.info()[["nodename"]])
[16:05:33.112]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:33.112]                           info)
[16:05:33.112]                         info <- base::paste(info, collapse = "; ")
[16:05:33.112]                         if (!has_future) {
[16:05:33.112]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:33.112]                             info)
[16:05:33.112]                         }
[16:05:33.112]                         else {
[16:05:33.112]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:33.112]                             info, version)
[16:05:33.112]                         }
[16:05:33.112]                         base::stop(msg)
[16:05:33.112]                       }
[16:05:33.112]                     })
[16:05:33.112]                   }
[16:05:33.112]                   options(future.plan = NULL)
[16:05:33.112]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:33.112]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:33.112]                 }
[16:05:33.112]                 ...future.workdir <- getwd()
[16:05:33.112]             }
[16:05:33.112]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:33.112]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:33.112]         }
[16:05:33.112]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:33.112]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:33.112]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:33.112]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:33.112]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:33.112]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:33.112]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:33.112]             base::names(...future.oldOptions))
[16:05:33.112]     }
[16:05:33.112]     if (FALSE) {
[16:05:33.112]     }
[16:05:33.112]     else {
[16:05:33.112]         if (TRUE) {
[16:05:33.112]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:33.112]                 open = "w")
[16:05:33.112]         }
[16:05:33.112]         else {
[16:05:33.112]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:33.112]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:33.112]         }
[16:05:33.112]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:33.112]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:33.112]             base::sink(type = "output", split = FALSE)
[16:05:33.112]             base::close(...future.stdout)
[16:05:33.112]         }, add = TRUE)
[16:05:33.112]     }
[16:05:33.112]     ...future.frame <- base::sys.nframe()
[16:05:33.112]     ...future.conditions <- base::list()
[16:05:33.112]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:33.112]     if (FALSE) {
[16:05:33.112]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:33.112]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:33.112]     }
[16:05:33.112]     ...future.result <- base::tryCatch({
[16:05:33.112]         base::withCallingHandlers({
[16:05:33.112]             ...future.value <- base::withVisible(base::local(subset(data, 
[16:05:33.112]                 a == 2)))
[16:05:33.112]             future::FutureResult(value = ...future.value$value, 
[16:05:33.112]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:33.112]                   ...future.rng), globalenv = if (FALSE) 
[16:05:33.112]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:33.112]                     ...future.globalenv.names))
[16:05:33.112]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:33.112]         }, condition = base::local({
[16:05:33.112]             c <- base::c
[16:05:33.112]             inherits <- base::inherits
[16:05:33.112]             invokeRestart <- base::invokeRestart
[16:05:33.112]             length <- base::length
[16:05:33.112]             list <- base::list
[16:05:33.112]             seq.int <- base::seq.int
[16:05:33.112]             signalCondition <- base::signalCondition
[16:05:33.112]             sys.calls <- base::sys.calls
[16:05:33.112]             `[[` <- base::`[[`
[16:05:33.112]             `+` <- base::`+`
[16:05:33.112]             `<<-` <- base::`<<-`
[16:05:33.112]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:33.112]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:33.112]                   3L)]
[16:05:33.112]             }
[16:05:33.112]             function(cond) {
[16:05:33.112]                 is_error <- inherits(cond, "error")
[16:05:33.112]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:33.112]                   NULL)
[16:05:33.112]                 if (is_error) {
[16:05:33.112]                   sessionInformation <- function() {
[16:05:33.112]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:33.112]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:33.112]                       search = base::search(), system = base::Sys.info())
[16:05:33.112]                   }
[16:05:33.112]                   ...future.conditions[[length(...future.conditions) + 
[16:05:33.112]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:33.112]                     cond$call), session = sessionInformation(), 
[16:05:33.112]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:33.112]                   signalCondition(cond)
[16:05:33.112]                 }
[16:05:33.112]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:33.112]                 "immediateCondition"))) {
[16:05:33.112]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:33.112]                   ...future.conditions[[length(...future.conditions) + 
[16:05:33.112]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:33.112]                   if (TRUE && !signal) {
[16:05:33.112]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.112]                     {
[16:05:33.112]                       inherits <- base::inherits
[16:05:33.112]                       invokeRestart <- base::invokeRestart
[16:05:33.112]                       is.null <- base::is.null
[16:05:33.112]                       muffled <- FALSE
[16:05:33.112]                       if (inherits(cond, "message")) {
[16:05:33.112]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:33.112]                         if (muffled) 
[16:05:33.112]                           invokeRestart("muffleMessage")
[16:05:33.112]                       }
[16:05:33.112]                       else if (inherits(cond, "warning")) {
[16:05:33.112]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:33.112]                         if (muffled) 
[16:05:33.112]                           invokeRestart("muffleWarning")
[16:05:33.112]                       }
[16:05:33.112]                       else if (inherits(cond, "condition")) {
[16:05:33.112]                         if (!is.null(pattern)) {
[16:05:33.112]                           computeRestarts <- base::computeRestarts
[16:05:33.112]                           grepl <- base::grepl
[16:05:33.112]                           restarts <- computeRestarts(cond)
[16:05:33.112]                           for (restart in restarts) {
[16:05:33.112]                             name <- restart$name
[16:05:33.112]                             if (is.null(name)) 
[16:05:33.112]                               next
[16:05:33.112]                             if (!grepl(pattern, name)) 
[16:05:33.112]                               next
[16:05:33.112]                             invokeRestart(restart)
[16:05:33.112]                             muffled <- TRUE
[16:05:33.112]                             break
[16:05:33.112]                           }
[16:05:33.112]                         }
[16:05:33.112]                       }
[16:05:33.112]                       invisible(muffled)
[16:05:33.112]                     }
[16:05:33.112]                     muffleCondition(cond, pattern = "^muffle")
[16:05:33.112]                   }
[16:05:33.112]                 }
[16:05:33.112]                 else {
[16:05:33.112]                   if (TRUE) {
[16:05:33.112]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.112]                     {
[16:05:33.112]                       inherits <- base::inherits
[16:05:33.112]                       invokeRestart <- base::invokeRestart
[16:05:33.112]                       is.null <- base::is.null
[16:05:33.112]                       muffled <- FALSE
[16:05:33.112]                       if (inherits(cond, "message")) {
[16:05:33.112]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:33.112]                         if (muffled) 
[16:05:33.112]                           invokeRestart("muffleMessage")
[16:05:33.112]                       }
[16:05:33.112]                       else if (inherits(cond, "warning")) {
[16:05:33.112]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:33.112]                         if (muffled) 
[16:05:33.112]                           invokeRestart("muffleWarning")
[16:05:33.112]                       }
[16:05:33.112]                       else if (inherits(cond, "condition")) {
[16:05:33.112]                         if (!is.null(pattern)) {
[16:05:33.112]                           computeRestarts <- base::computeRestarts
[16:05:33.112]                           grepl <- base::grepl
[16:05:33.112]                           restarts <- computeRestarts(cond)
[16:05:33.112]                           for (restart in restarts) {
[16:05:33.112]                             name <- restart$name
[16:05:33.112]                             if (is.null(name)) 
[16:05:33.112]                               next
[16:05:33.112]                             if (!grepl(pattern, name)) 
[16:05:33.112]                               next
[16:05:33.112]                             invokeRestart(restart)
[16:05:33.112]                             muffled <- TRUE
[16:05:33.112]                             break
[16:05:33.112]                           }
[16:05:33.112]                         }
[16:05:33.112]                       }
[16:05:33.112]                       invisible(muffled)
[16:05:33.112]                     }
[16:05:33.112]                     muffleCondition(cond, pattern = "^muffle")
[16:05:33.112]                   }
[16:05:33.112]                 }
[16:05:33.112]             }
[16:05:33.112]         }))
[16:05:33.112]     }, error = function(ex) {
[16:05:33.112]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:33.112]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:33.112]                 ...future.rng), started = ...future.startTime, 
[16:05:33.112]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:33.112]             version = "1.8"), class = "FutureResult")
[16:05:33.112]     }, finally = {
[16:05:33.112]         if (!identical(...future.workdir, getwd())) 
[16:05:33.112]             setwd(...future.workdir)
[16:05:33.112]         {
[16:05:33.112]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:33.112]                 ...future.oldOptions$nwarnings <- NULL
[16:05:33.112]             }
[16:05:33.112]             base::options(...future.oldOptions)
[16:05:33.112]             if (.Platform$OS.type == "windows") {
[16:05:33.112]                 old_names <- names(...future.oldEnvVars)
[16:05:33.112]                 envs <- base::Sys.getenv()
[16:05:33.112]                 names <- names(envs)
[16:05:33.112]                 common <- intersect(names, old_names)
[16:05:33.112]                 added <- setdiff(names, old_names)
[16:05:33.112]                 removed <- setdiff(old_names, names)
[16:05:33.112]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:33.112]                   envs[common]]
[16:05:33.112]                 NAMES <- toupper(changed)
[16:05:33.112]                 args <- list()
[16:05:33.112]                 for (kk in seq_along(NAMES)) {
[16:05:33.112]                   name <- changed[[kk]]
[16:05:33.112]                   NAME <- NAMES[[kk]]
[16:05:33.112]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.112]                     next
[16:05:33.112]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:33.112]                 }
[16:05:33.112]                 NAMES <- toupper(added)
[16:05:33.112]                 for (kk in seq_along(NAMES)) {
[16:05:33.112]                   name <- added[[kk]]
[16:05:33.112]                   NAME <- NAMES[[kk]]
[16:05:33.112]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.112]                     next
[16:05:33.112]                   args[[name]] <- ""
[16:05:33.112]                 }
[16:05:33.112]                 NAMES <- toupper(removed)
[16:05:33.112]                 for (kk in seq_along(NAMES)) {
[16:05:33.112]                   name <- removed[[kk]]
[16:05:33.112]                   NAME <- NAMES[[kk]]
[16:05:33.112]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.112]                     next
[16:05:33.112]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:33.112]                 }
[16:05:33.112]                 if (length(args) > 0) 
[16:05:33.112]                   base::do.call(base::Sys.setenv, args = args)
[16:05:33.112]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:33.112]             }
[16:05:33.112]             else {
[16:05:33.112]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:33.112]             }
[16:05:33.112]             {
[16:05:33.112]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:33.112]                   0L) {
[16:05:33.112]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:33.112]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:33.112]                   base::options(opts)
[16:05:33.112]                 }
[16:05:33.112]                 {
[16:05:33.112]                   {
[16:05:33.112]                     NULL
[16:05:33.112]                     RNGkind("Mersenne-Twister")
[16:05:33.112]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:33.112]                       inherits = FALSE)
[16:05:33.112]                   }
[16:05:33.112]                   options(future.plan = NULL)
[16:05:33.112]                   if (is.na(NA_character_)) 
[16:05:33.112]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:33.112]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:33.112]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:33.112]                     envir = parent.frame()) 
[16:05:33.112]                   {
[16:05:33.112]                     default_workers <- missing(workers)
[16:05:33.112]                     if (is.function(workers)) 
[16:05:33.112]                       workers <- workers()
[16:05:33.112]                     workers <- structure(as.integer(workers), 
[16:05:33.112]                       class = class(workers))
[16:05:33.112]                     stop_if_not(is.finite(workers), workers >= 
[16:05:33.112]                       1L)
[16:05:33.112]                     if ((workers == 1L && !inherits(workers, 
[16:05:33.112]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:33.112]                       if (default_workers) 
[16:05:33.112]                         supportsMulticore(warn = TRUE)
[16:05:33.112]                       return(sequential(..., envir = envir))
[16:05:33.112]                     }
[16:05:33.112]                     oopts <- options(mc.cores = workers)
[16:05:33.112]                     on.exit(options(oopts))
[16:05:33.112]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:33.112]                       envir = envir)
[16:05:33.112]                     if (!future$lazy) 
[16:05:33.112]                       future <- run(future)
[16:05:33.112]                     invisible(future)
[16:05:33.112]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:33.112]                 }
[16:05:33.112]             }
[16:05:33.112]         }
[16:05:33.112]     })
[16:05:33.112]     if (TRUE) {
[16:05:33.112]         base::sink(type = "output", split = FALSE)
[16:05:33.112]         if (TRUE) {
[16:05:33.112]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:33.112]         }
[16:05:33.112]         else {
[16:05:33.112]             ...future.result["stdout"] <- base::list(NULL)
[16:05:33.112]         }
[16:05:33.112]         base::close(...future.stdout)
[16:05:33.112]         ...future.stdout <- NULL
[16:05:33.112]     }
[16:05:33.112]     ...future.result$conditions <- ...future.conditions
[16:05:33.112]     ...future.result$finished <- base::Sys.time()
[16:05:33.112]     ...future.result
[16:05:33.112] }
[16:05:33.146]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.114] assign_globals() ...
[16:05:33.146]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.114] List of 1
[16:05:33.114]  $ data:'data.frame':	3 obs. of  2 variables:
[16:05:33.114]   ..$ a: int [1:3] 1 2 3
[16:05:33.114]   ..$ b: int [1:3] 3 2 1
[16:05:33.114]  - attr(*, "where")=List of 1
[16:05:33.114]   ..$ data:<environment: R_EmptyEnv> 
[16:05:33.114]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:33.114]  - attr(*, "resolved")= logi FALSE
[16:05:33.114]  - attr(*, "total_size")= num 128
[16:05:33.114]  - attr(*, "already-done")= logi TRUE
[16:05:33.146]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.124] - copied ‘data’ to environment
[16:05:33.146]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.124] assign_globals() ... done
[16:05:33.147]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.124] plan(): Setting new future strategy stack:
[16:05:33.147]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.124] List of future strategies:
[16:05:33.124] 1. sequential:
[16:05:33.124]    - args: function (..., envir = parent.frame())
[16:05:33.124]    - tweaked: FALSE
[16:05:33.124]    - call: NULL
[16:05:33.147]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.125] plan(): nbrOfWorkers() = 1
[16:05:33.147]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.126] plan(): Setting new future strategy stack:
[16:05:33.147]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.126] List of future strategies:
[16:05:33.126] 1. multicore:
[16:05:33.126]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:33.126]    - tweaked: FALSE
[16:05:33.126]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.147]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.130] plan(): nbrOfWorkers() = 1
[16:05:33.148]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.130] SequentialFuture started (and completed)
[16:05:33.148]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.131] - Launch lazy future ... done
[16:05:33.148]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.131] run() for ‘SequentialFuture’ ... done
[16:05:33.148] signalConditions() ... done
- plan(list('multicore', 'multicore')) ... DONE
- plan(list('multicore', 'multisession')) ...
[16:05:33.149] plan(): Setting new future strategy stack:
[16:05:33.149] List of future strategies:
[16:05:33.149] 1. multicore:
[16:05:33.149]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:33.149]    - tweaked: FALSE
[16:05:33.149]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.149] 2. multisession:
[16:05:33.149]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:33.149]    - tweaked: FALSE
[16:05:33.149]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.153] plan(): nbrOfWorkers() = 2
[16:05:33.156] getGlobalsAndPackages() ...
[16:05:33.157] Searching for globals...
[16:05:33.177] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:05:33.177] Searching for globals ... DONE
[16:05:33.177] Resolving globals: FALSE
[16:05:33.178] The total size of the 2 globals is 90.64 KiB (92816 bytes)
[16:05:33.179] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 90.64 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (90.52 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:05:33.179] - globals: [2] ‘nested’, ‘strategy2’
[16:05:33.179] - packages: [1] ‘future’
[16:05:33.179] getGlobalsAndPackages() ... DONE
[16:05:33.180] run() for ‘Future’ ...
[16:05:33.180] - state: ‘created’
[16:05:33.180] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:33.184] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:33.184] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:33.184]   - Field: ‘label’
[16:05:33.184]   - Field: ‘local’
[16:05:33.184]   - Field: ‘owner’
[16:05:33.184]   - Field: ‘envir’
[16:05:33.184]   - Field: ‘workers’
[16:05:33.185]   - Field: ‘packages’
[16:05:33.185]   - Field: ‘gc’
[16:05:33.185]   - Field: ‘job’
[16:05:33.185]   - Field: ‘conditions’
[16:05:33.185]   - Field: ‘expr’
[16:05:33.185]   - Field: ‘uuid’
[16:05:33.185]   - Field: ‘seed’
[16:05:33.185]   - Field: ‘version’
[16:05:33.185]   - Field: ‘result’
[16:05:33.186]   - Field: ‘asynchronous’
[16:05:33.186]   - Field: ‘calls’
[16:05:33.186]   - Field: ‘globals’
[16:05:33.186]   - Field: ‘stdout’
[16:05:33.186]   - Field: ‘earlySignal’
[16:05:33.186]   - Field: ‘lazy’
[16:05:33.186]   - Field: ‘state’
[16:05:33.186] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:33.186] - Launch lazy future ...
[16:05:33.187] Packages needed by the future expression (n = 1): ‘future’
[16:05:33.187] Packages needed by future strategies (n = 1): ‘future’
[16:05:33.188] {
[16:05:33.188]     {
[16:05:33.188]         {
[16:05:33.188]             ...future.startTime <- base::Sys.time()
[16:05:33.188]             {
[16:05:33.188]                 {
[16:05:33.188]                   {
[16:05:33.188]                     {
[16:05:33.188]                       {
[16:05:33.188]                         base::local({
[16:05:33.188]                           has_future <- base::requireNamespace("future", 
[16:05:33.188]                             quietly = TRUE)
[16:05:33.188]                           if (has_future) {
[16:05:33.188]                             ns <- base::getNamespace("future")
[16:05:33.188]                             version <- ns[[".package"]][["version"]]
[16:05:33.188]                             if (is.null(version)) 
[16:05:33.188]                               version <- utils::packageVersion("future")
[16:05:33.188]                           }
[16:05:33.188]                           else {
[16:05:33.188]                             version <- NULL
[16:05:33.188]                           }
[16:05:33.188]                           if (!has_future || version < "1.8.0") {
[16:05:33.188]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:33.188]                               "", base::R.version$version.string), 
[16:05:33.188]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:33.188]                                 base::R.version$platform, 8 * 
[16:05:33.188]                                   base::.Machine$sizeof.pointer), 
[16:05:33.188]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:33.188]                                 "release", "version")], collapse = " "), 
[16:05:33.188]                               hostname = base::Sys.info()[["nodename"]])
[16:05:33.188]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:33.188]                               info)
[16:05:33.188]                             info <- base::paste(info, collapse = "; ")
[16:05:33.188]                             if (!has_future) {
[16:05:33.188]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:33.188]                                 info)
[16:05:33.188]                             }
[16:05:33.188]                             else {
[16:05:33.188]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:33.188]                                 info, version)
[16:05:33.188]                             }
[16:05:33.188]                             base::stop(msg)
[16:05:33.188]                           }
[16:05:33.188]                         })
[16:05:33.188]                       }
[16:05:33.188]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:33.188]                       base::options(mc.cores = 1L)
[16:05:33.188]                     }
[16:05:33.188]                     base::local({
[16:05:33.188]                       for (pkg in "future") {
[16:05:33.188]                         base::loadNamespace(pkg)
[16:05:33.188]                         base::library(pkg, character.only = TRUE)
[16:05:33.188]                       }
[16:05:33.188]                     })
[16:05:33.188]                   }
[16:05:33.188]                   options(future.plan = NULL)
[16:05:33.188]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:33.188]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:05:33.188]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:33.188]                     envir = parent.frame()) 
[16:05:33.188]                   {
[16:05:33.188]                     if (is.function(workers)) 
[16:05:33.188]                       workers <- workers()
[16:05:33.188]                     workers <- structure(as.integer(workers), 
[16:05:33.188]                       class = class(workers))
[16:05:33.188]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:33.188]                       workers >= 1)
[16:05:33.188]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:33.188]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:33.188]                     }
[16:05:33.188]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:33.188]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:33.188]                       envir = envir)
[16:05:33.188]                     if (!future$lazy) 
[16:05:33.188]                       future <- run(future)
[16:05:33.188]                     invisible(future)
[16:05:33.188]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:33.188]                 }
[16:05:33.188]                 ...future.workdir <- getwd()
[16:05:33.188]             }
[16:05:33.188]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:33.188]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:33.188]         }
[16:05:33.188]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:33.188]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:33.188]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:33.188]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:33.188]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:33.188]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:33.188]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:33.188]             base::names(...future.oldOptions))
[16:05:33.188]     }
[16:05:33.188]     if (FALSE) {
[16:05:33.188]     }
[16:05:33.188]     else {
[16:05:33.188]         if (TRUE) {
[16:05:33.188]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:33.188]                 open = "w")
[16:05:33.188]         }
[16:05:33.188]         else {
[16:05:33.188]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:33.188]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:33.188]         }
[16:05:33.188]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:33.188]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:33.188]             base::sink(type = "output", split = FALSE)
[16:05:33.188]             base::close(...future.stdout)
[16:05:33.188]         }, add = TRUE)
[16:05:33.188]     }
[16:05:33.188]     ...future.frame <- base::sys.nframe()
[16:05:33.188]     ...future.conditions <- base::list()
[16:05:33.188]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:33.188]     if (FALSE) {
[16:05:33.188]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:33.188]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:33.188]     }
[16:05:33.188]     ...future.result <- base::tryCatch({
[16:05:33.188]         base::withCallingHandlers({
[16:05:33.188]             ...future.value <- base::withVisible(base::local({
[16:05:33.188]                 withCallingHandlers({
[16:05:33.188]                   {
[16:05:33.188]                     a <- 1L
[16:05:33.188]                     plan_a <- unclass(future::plan("list"))
[16:05:33.188]                     nested_a <- nested[-1]
[16:05:33.188]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:05:33.188]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:05:33.188]                       strategy2))
[16:05:33.188]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:05:33.188]                       "init") <- NULL
[16:05:33.188]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:05:33.188]                       "init") <- NULL
[16:05:33.188]                     stopifnot(all.equal(plan_a, nested_a))
[16:05:33.188]                     y %<-% {
[16:05:33.188]                       b <- 2L
[16:05:33.188]                       plan_b <- future::plan("list")
[16:05:33.188]                       nested_b <- nested_a[-1]
[16:05:33.188]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:05:33.188]                         1L, inherits(plan_b[[1]], "future"), 
[16:05:33.188]                         inherits(future::plan("next"), "sequential"))
[16:05:33.188]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:05:33.188]                         b = b, nested_b = nested_b, plan_b = plan_b)
[16:05:33.188]                     }
[16:05:33.188]                     y
[16:05:33.188]                   }
[16:05:33.188]                 }, immediateCondition = function(cond) {
[16:05:33.188]                   save_rds <- function (object, pathname, ...) 
[16:05:33.188]                   {
[16:05:33.188]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:33.188]                     if (file_test("-f", pathname_tmp)) {
[16:05:33.188]                       fi_tmp <- file.info(pathname_tmp)
[16:05:33.188]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:33.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:33.188]                         fi_tmp[["mtime"]])
[16:05:33.188]                     }
[16:05:33.188]                     tryCatch({
[16:05:33.188]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:33.188]                     }, error = function(ex) {
[16:05:33.188]                       msg <- conditionMessage(ex)
[16:05:33.188]                       fi_tmp <- file.info(pathname_tmp)
[16:05:33.188]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:33.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:33.188]                         fi_tmp[["mtime"]], msg)
[16:05:33.188]                       ex$message <- msg
[16:05:33.188]                       stop(ex)
[16:05:33.188]                     })
[16:05:33.188]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:33.188]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:33.188]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:33.188]                       fi_tmp <- file.info(pathname_tmp)
[16:05:33.188]                       fi <- file.info(pathname)
[16:05:33.188]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:33.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:33.188]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:33.188]                         fi[["size"]], fi[["mtime"]])
[16:05:33.188]                       stop(msg)
[16:05:33.188]                     }
[16:05:33.188]                     invisible(pathname)
[16:05:33.188]                   }
[16:05:33.188]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:33.188]                     rootPath = tempdir()) 
[16:05:33.188]                   {
[16:05:33.188]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:33.188]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:33.188]                       tmpdir = path, fileext = ".rds")
[16:05:33.188]                     save_rds(obj, file)
[16:05:33.188]                   }
[16:05:33.188]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0EbAi0/.future/immediateConditions")
[16:05:33.188]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.188]                   {
[16:05:33.188]                     inherits <- base::inherits
[16:05:33.188]                     invokeRestart <- base::invokeRestart
[16:05:33.188]                     is.null <- base::is.null
[16:05:33.188]                     muffled <- FALSE
[16:05:33.188]                     if (inherits(cond, "message")) {
[16:05:33.188]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:33.188]                       if (muffled) 
[16:05:33.188]                         invokeRestart("muffleMessage")
[16:05:33.188]                     }
[16:05:33.188]                     else if (inherits(cond, "warning")) {
[16:05:33.188]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:33.188]                       if (muffled) 
[16:05:33.188]                         invokeRestart("muffleWarning")
[16:05:33.188]                     }
[16:05:33.188]                     else if (inherits(cond, "condition")) {
[16:05:33.188]                       if (!is.null(pattern)) {
[16:05:33.188]                         computeRestarts <- base::computeRestarts
[16:05:33.188]                         grepl <- base::grepl
[16:05:33.188]                         restarts <- computeRestarts(cond)
[16:05:33.188]                         for (restart in restarts) {
[16:05:33.188]                           name <- restart$name
[16:05:33.188]                           if (is.null(name)) 
[16:05:33.188]                             next
[16:05:33.188]                           if (!grepl(pattern, name)) 
[16:05:33.188]                             next
[16:05:33.188]                           invokeRestart(restart)
[16:05:33.188]                           muffled <- TRUE
[16:05:33.188]                           break
[16:05:33.188]                         }
[16:05:33.188]                       }
[16:05:33.188]                     }
[16:05:33.188]                     invisible(muffled)
[16:05:33.188]                   }
[16:05:33.188]                   muffleCondition(cond)
[16:05:33.188]                 })
[16:05:33.188]             }))
[16:05:33.188]             future::FutureResult(value = ...future.value$value, 
[16:05:33.188]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:33.188]                   ...future.rng), globalenv = if (FALSE) 
[16:05:33.188]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:33.188]                     ...future.globalenv.names))
[16:05:33.188]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:33.188]         }, condition = base::local({
[16:05:33.188]             c <- base::c
[16:05:33.188]             inherits <- base::inherits
[16:05:33.188]             invokeRestart <- base::invokeRestart
[16:05:33.188]             length <- base::length
[16:05:33.188]             list <- base::list
[16:05:33.188]             seq.int <- base::seq.int
[16:05:33.188]             signalCondition <- base::signalCondition
[16:05:33.188]             sys.calls <- base::sys.calls
[16:05:33.188]             `[[` <- base::`[[`
[16:05:33.188]             `+` <- base::`+`
[16:05:33.188]             `<<-` <- base::`<<-`
[16:05:33.188]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:33.188]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:33.188]                   3L)]
[16:05:33.188]             }
[16:05:33.188]             function(cond) {
[16:05:33.188]                 is_error <- inherits(cond, "error")
[16:05:33.188]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:33.188]                   NULL)
[16:05:33.188]                 if (is_error) {
[16:05:33.188]                   sessionInformation <- function() {
[16:05:33.188]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:33.188]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:33.188]                       search = base::search(), system = base::Sys.info())
[16:05:33.188]                   }
[16:05:33.188]                   ...future.conditions[[length(...future.conditions) + 
[16:05:33.188]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:33.188]                     cond$call), session = sessionInformation(), 
[16:05:33.188]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:33.188]                   signalCondition(cond)
[16:05:33.188]                 }
[16:05:33.188]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:33.188]                 "immediateCondition"))) {
[16:05:33.188]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:33.188]                   ...future.conditions[[length(...future.conditions) + 
[16:05:33.188]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:33.188]                   if (TRUE && !signal) {
[16:05:33.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.188]                     {
[16:05:33.188]                       inherits <- base::inherits
[16:05:33.188]                       invokeRestart <- base::invokeRestart
[16:05:33.188]                       is.null <- base::is.null
[16:05:33.188]                       muffled <- FALSE
[16:05:33.188]                       if (inherits(cond, "message")) {
[16:05:33.188]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:33.188]                         if (muffled) 
[16:05:33.188]                           invokeRestart("muffleMessage")
[16:05:33.188]                       }
[16:05:33.188]                       else if (inherits(cond, "warning")) {
[16:05:33.188]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:33.188]                         if (muffled) 
[16:05:33.188]                           invokeRestart("muffleWarning")
[16:05:33.188]                       }
[16:05:33.188]                       else if (inherits(cond, "condition")) {
[16:05:33.188]                         if (!is.null(pattern)) {
[16:05:33.188]                           computeRestarts <- base::computeRestarts
[16:05:33.188]                           grepl <- base::grepl
[16:05:33.188]                           restarts <- computeRestarts(cond)
[16:05:33.188]                           for (restart in restarts) {
[16:05:33.188]                             name <- restart$name
[16:05:33.188]                             if (is.null(name)) 
[16:05:33.188]                               next
[16:05:33.188]                             if (!grepl(pattern, name)) 
[16:05:33.188]                               next
[16:05:33.188]                             invokeRestart(restart)
[16:05:33.188]                             muffled <- TRUE
[16:05:33.188]                             break
[16:05:33.188]                           }
[16:05:33.188]                         }
[16:05:33.188]                       }
[16:05:33.188]                       invisible(muffled)
[16:05:33.188]                     }
[16:05:33.188]                     muffleCondition(cond, pattern = "^muffle")
[16:05:33.188]                   }
[16:05:33.188]                 }
[16:05:33.188]                 else {
[16:05:33.188]                   if (TRUE) {
[16:05:33.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.188]                     {
[16:05:33.188]                       inherits <- base::inherits
[16:05:33.188]                       invokeRestart <- base::invokeRestart
[16:05:33.188]                       is.null <- base::is.null
[16:05:33.188]                       muffled <- FALSE
[16:05:33.188]                       if (inherits(cond, "message")) {
[16:05:33.188]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:33.188]                         if (muffled) 
[16:05:33.188]                           invokeRestart("muffleMessage")
[16:05:33.188]                       }
[16:05:33.188]                       else if (inherits(cond, "warning")) {
[16:05:33.188]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:33.188]                         if (muffled) 
[16:05:33.188]                           invokeRestart("muffleWarning")
[16:05:33.188]                       }
[16:05:33.188]                       else if (inherits(cond, "condition")) {
[16:05:33.188]                         if (!is.null(pattern)) {
[16:05:33.188]                           computeRestarts <- base::computeRestarts
[16:05:33.188]                           grepl <- base::grepl
[16:05:33.188]                           restarts <- computeRestarts(cond)
[16:05:33.188]                           for (restart in restarts) {
[16:05:33.188]                             name <- restart$name
[16:05:33.188]                             if (is.null(name)) 
[16:05:33.188]                               next
[16:05:33.188]                             if (!grepl(pattern, name)) 
[16:05:33.188]                               next
[16:05:33.188]                             invokeRestart(restart)
[16:05:33.188]                             muffled <- TRUE
[16:05:33.188]                             break
[16:05:33.188]                           }
[16:05:33.188]                         }
[16:05:33.188]                       }
[16:05:33.188]                       invisible(muffled)
[16:05:33.188]                     }
[16:05:33.188]                     muffleCondition(cond, pattern = "^muffle")
[16:05:33.188]                   }
[16:05:33.188]                 }
[16:05:33.188]             }
[16:05:33.188]         }))
[16:05:33.188]     }, error = function(ex) {
[16:05:33.188]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:33.188]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:33.188]                 ...future.rng), started = ...future.startTime, 
[16:05:33.188]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:33.188]             version = "1.8"), class = "FutureResult")
[16:05:33.188]     }, finally = {
[16:05:33.188]         if (!identical(...future.workdir, getwd())) 
[16:05:33.188]             setwd(...future.workdir)
[16:05:33.188]         {
[16:05:33.188]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:33.188]                 ...future.oldOptions$nwarnings <- NULL
[16:05:33.188]             }
[16:05:33.188]             base::options(...future.oldOptions)
[16:05:33.188]             if (.Platform$OS.type == "windows") {
[16:05:33.188]                 old_names <- names(...future.oldEnvVars)
[16:05:33.188]                 envs <- base::Sys.getenv()
[16:05:33.188]                 names <- names(envs)
[16:05:33.188]                 common <- intersect(names, old_names)
[16:05:33.188]                 added <- setdiff(names, old_names)
[16:05:33.188]                 removed <- setdiff(old_names, names)
[16:05:33.188]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:33.188]                   envs[common]]
[16:05:33.188]                 NAMES <- toupper(changed)
[16:05:33.188]                 args <- list()
[16:05:33.188]                 for (kk in seq_along(NAMES)) {
[16:05:33.188]                   name <- changed[[kk]]
[16:05:33.188]                   NAME <- NAMES[[kk]]
[16:05:33.188]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.188]                     next
[16:05:33.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:33.188]                 }
[16:05:33.188]                 NAMES <- toupper(added)
[16:05:33.188]                 for (kk in seq_along(NAMES)) {
[16:05:33.188]                   name <- added[[kk]]
[16:05:33.188]                   NAME <- NAMES[[kk]]
[16:05:33.188]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.188]                     next
[16:05:33.188]                   args[[name]] <- ""
[16:05:33.188]                 }
[16:05:33.188]                 NAMES <- toupper(removed)
[16:05:33.188]                 for (kk in seq_along(NAMES)) {
[16:05:33.188]                   name <- removed[[kk]]
[16:05:33.188]                   NAME <- NAMES[[kk]]
[16:05:33.188]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.188]                     next
[16:05:33.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:33.188]                 }
[16:05:33.188]                 if (length(args) > 0) 
[16:05:33.188]                   base::do.call(base::Sys.setenv, args = args)
[16:05:33.188]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:33.188]             }
[16:05:33.188]             else {
[16:05:33.188]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:33.188]             }
[16:05:33.188]             {
[16:05:33.188]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:33.188]                   0L) {
[16:05:33.188]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:33.188]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:33.188]                   base::options(opts)
[16:05:33.188]                 }
[16:05:33.188]                 {
[16:05:33.188]                   {
[16:05:33.188]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:33.188]                     NULL
[16:05:33.188]                   }
[16:05:33.188]                   options(future.plan = NULL)
[16:05:33.188]                   if (is.na(NA_character_)) 
[16:05:33.188]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:33.188]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:33.188]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:33.188]                     envir = parent.frame()) 
[16:05:33.188]                   {
[16:05:33.188]                     default_workers <- missing(workers)
[16:05:33.188]                     if (is.function(workers)) 
[16:05:33.188]                       workers <- workers()
[16:05:33.188]                     workers <- structure(as.integer(workers), 
[16:05:33.188]                       class = class(workers))
[16:05:33.188]                     stop_if_not(is.finite(workers), workers >= 
[16:05:33.188]                       1L)
[16:05:33.188]                     if ((workers == 1L && !inherits(workers, 
[16:05:33.188]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:33.188]                       if (default_workers) 
[16:05:33.188]                         supportsMulticore(warn = TRUE)
[16:05:33.188]                       return(sequential(..., envir = envir))
[16:05:33.188]                     }
[16:05:33.188]                     oopts <- options(mc.cores = workers)
[16:05:33.188]                     on.exit(options(oopts))
[16:05:33.188]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:33.188]                       envir = envir)
[16:05:33.188]                     if (!future$lazy) 
[16:05:33.188]                       future <- run(future)
[16:05:33.188]                     invisible(future)
[16:05:33.188]                   }, b = function (..., workers = availableCores(), 
[16:05:33.188]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:33.188]                     envir = parent.frame()) 
[16:05:33.188]                   {
[16:05:33.188]                     if (is.function(workers)) 
[16:05:33.188]                       workers <- workers()
[16:05:33.188]                     workers <- structure(as.integer(workers), 
[16:05:33.188]                       class = class(workers))
[16:05:33.188]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:33.188]                       workers >= 1)
[16:05:33.188]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:33.188]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:33.188]                     }
[16:05:33.188]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:33.188]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:33.188]                       envir = envir)
[16:05:33.188]                     if (!future$lazy) 
[16:05:33.188]                       future <- run(future)
[16:05:33.188]                     invisible(future)
[16:05:33.188]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:33.188]                 }
[16:05:33.188]             }
[16:05:33.188]         }
[16:05:33.188]     })
[16:05:33.188]     if (TRUE) {
[16:05:33.188]         base::sink(type = "output", split = FALSE)
[16:05:33.188]         if (TRUE) {
[16:05:33.188]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:33.188]         }
[16:05:33.188]         else {
[16:05:33.188]             ...future.result["stdout"] <- base::list(NULL)
[16:05:33.188]         }
[16:05:33.188]         base::close(...future.stdout)
[16:05:33.188]         ...future.stdout <- NULL
[16:05:33.188]     }
[16:05:33.188]     ...future.result$conditions <- ...future.conditions
[16:05:33.188]     ...future.result$finished <- base::Sys.time()
[16:05:33.188]     ...future.result
[16:05:33.188] }
[16:05:33.190] assign_globals() ...
[16:05:33.190] List of 2
[16:05:33.190]  $ nested   :List of 2
[16:05:33.190]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:05:33.190]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:05:33.190]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:05:33.190]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:33.190]     envir = parent.frame())  
[16:05:33.190]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[16:05:33.190]   .. ..- attr(*, "init")= logi TRUE
[16:05:33.190]   .. ..- attr(*, "untweakable")= chr "persistent"
[16:05:33.190]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:05:33.190]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:05:33.190]  $ strategy2: chr "multisession"
[16:05:33.190]  - attr(*, "where")=List of 2
[16:05:33.190]   ..$ nested   :<environment: R_EmptyEnv> 
[16:05:33.190]   ..$ strategy2:<environment: R_EmptyEnv> 
[16:05:33.190]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:33.190]  - attr(*, "resolved")= logi FALSE
[16:05:33.190]  - attr(*, "total_size")= num 92816
[16:05:33.190]  - attr(*, "already-done")= logi TRUE
[16:05:33.197] - copied ‘nested’ to environment
[16:05:33.197] - copied ‘strategy2’ to environment
[16:05:33.197] assign_globals() ... done
[16:05:33.197] requestCore(): workers = 2
[16:05:33.199] MulticoreFuture started
[16:05:33.199] - Launch lazy future ... done
[16:05:33.200] run() for ‘MulticoreFuture’ ... done
[16:05:33.200] result() for MulticoreFuture ...
[16:05:33.201] plan(): Setting new future strategy stack:
[16:05:33.201] List of future strategies:
[16:05:33.201] 1. multisession:
[16:05:33.201]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:33.201]    - tweaked: FALSE
[16:05:33.201]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.206] plan(): nbrOfWorkers() = 1
[16:05:33.247] plan(): Setting new future strategy stack:
[16:05:33.247] List of future strategies:
[16:05:33.247] 1. multicore:
[16:05:33.247]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:33.247]    - tweaked: FALSE
[16:05:33.247]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.247] 2. multisession:
[16:05:33.247]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:33.247]    - tweaked: FALSE
[16:05:33.247]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.251] plan(): nbrOfWorkers() = 2
[16:05:33.252] result() for MulticoreFuture ...
[16:05:33.252] result() for MulticoreFuture ... done
[16:05:33.252] signalConditions() ...
[16:05:33.252]  - include = ‘immediateCondition’
[16:05:33.252]  - exclude = 
[16:05:33.253]  - resignal = FALSE
[16:05:33.253]  - Number of conditions: 54
[16:05:33.253] signalConditions() ... done
[16:05:33.253] result() for MulticoreFuture ... done
[16:05:33.253] result() for MulticoreFuture ...
[16:05:33.253] result() for MulticoreFuture ... done
[16:05:33.253] signalConditions() ...
[16:05:33.253]  - include = ‘immediateCondition’
[16:05:33.253]  - exclude = 
[16:05:33.254]  - resignal = FALSE
[16:05:33.254]  - Number of conditions: 54
[16:05:33.254] signalConditions() ... done
[16:05:33.254] Future state: ‘finished’
[16:05:33.254] result() for MulticoreFuture ...
[16:05:33.254] result() for MulticoreFuture ... done
[16:05:33.254] signalConditions() ...
[16:05:33.254]  - include = ‘condition’
[16:05:33.255]  - exclude = ‘immediateCondition’
[16:05:33.255]  - resignal = TRUE
[16:05:33.255]  - Number of conditions: 54
[16:05:33.255]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.208] getGlobalsAndPackages() ...
[16:05:33.255]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.208] Searching for globals...
[16:05:33.255]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.216] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[16:05:33.255]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.216] Searching for globals ... DONE
[16:05:33.256]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.216] Resolving globals: FALSE
[16:05:33.256]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.217] The total size of the 3 globals is 87.82 KiB (89928 bytes)
[16:05:33.256]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.218] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 87.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (43.88 KiB of class ‘list’), ‘plan_a’ (43.88 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[16:05:33.256]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.218] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[16:05:33.256]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.218] 
[16:05:33.256]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.218] getGlobalsAndPackages() ... DONE
[16:05:33.257]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.219] run() for ‘Future’ ...
[16:05:33.257]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.219] - state: ‘created’
[16:05:33.257]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.220] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:33.257]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.223] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:33.257]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.224] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:33.257]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.224]   - Field: ‘label’
[16:05:33.257]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.224]   - Field: ‘local’
[16:05:33.258]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.224]   - Field: ‘owner’
[16:05:33.258]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.224]   - Field: ‘envir’
[16:05:33.258]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.224]   - Field: ‘packages’
[16:05:33.258]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.225]   - Field: ‘gc’
[16:05:33.258]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.225]   - Field: ‘conditions’
[16:05:33.258]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.225]   - Field: ‘expr’
[16:05:33.259]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.225]   - Field: ‘uuid’
[16:05:33.259]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.225]   - Field: ‘seed’
[16:05:33.259]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.225]   - Field: ‘version’
[16:05:33.259]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.226]   - Field: ‘result’
[16:05:33.259]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.226]   - Field: ‘asynchronous’
[16:05:33.259]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.226]   - Field: ‘calls’
[16:05:33.260]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.226]   - Field: ‘globals’
[16:05:33.260]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.226]   - Field: ‘stdout’
[16:05:33.260]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.226]   - Field: ‘earlySignal’
[16:05:33.260]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.226]   - Field: ‘lazy’
[16:05:33.260]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.227]   - Field: ‘state’
[16:05:33.260]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.227] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:33.260]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.227] - Launch lazy future ...
[16:05:33.261]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.227] Packages needed by the future expression (n = 0): <none>
[16:05:33.261]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.227] Packages needed by future strategies (n = 0): <none>
[16:05:33.261]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.228] {
[16:05:33.228]     {
[16:05:33.228]         {
[16:05:33.228]             ...future.startTime <- base::Sys.time()
[16:05:33.228]             {
[16:05:33.228]                 {
[16:05:33.228]                   {
[16:05:33.228]                     base::local({
[16:05:33.228]                       has_future <- base::requireNamespace("future", 
[16:05:33.228]                         quietly = TRUE)
[16:05:33.228]                       if (has_future) {
[16:05:33.228]                         ns <- base::getNamespace("future")
[16:05:33.228]                         version <- ns[[".package"]][["version"]]
[16:05:33.228]                         if (is.null(version)) 
[16:05:33.228]                           version <- utils::packageVersion("future")
[16:05:33.228]                       }
[16:05:33.228]                       else {
[16:05:33.228]                         version <- NULL
[16:05:33.228]                       }
[16:05:33.228]                       if (!has_future || version < "1.8.0") {
[16:05:33.228]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:33.228]                           "", base::R.version$version.string), 
[16:05:33.228]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:33.228]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:33.228]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:33.228]                             "release", "version")], collapse = " "), 
[16:05:33.228]                           hostname = base::Sys.info()[["nodename"]])
[16:05:33.228]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:33.228]                           info)
[16:05:33.228]                         info <- base::paste(info, collapse = "; ")
[16:05:33.228]                         if (!has_future) {
[16:05:33.228]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:33.228]                             info)
[16:05:33.228]                         }
[16:05:33.228]                         else {
[16:05:33.228]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:33.228]                             info, version)
[16:05:33.228]                         }
[16:05:33.228]                         base::stop(msg)
[16:05:33.228]                       }
[16:05:33.228]                     })
[16:05:33.228]                   }
[16:05:33.228]                   options(future.plan = NULL)
[16:05:33.228]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:33.228]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:33.228]                 }
[16:05:33.228]                 ...future.workdir <- getwd()
[16:05:33.228]             }
[16:05:33.228]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:33.228]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:33.228]         }
[16:05:33.228]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:33.228]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:33.228]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:33.228]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:33.228]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:33.228]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:33.228]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:33.228]             base::names(...future.oldOptions))
[16:05:33.228]     }
[16:05:33.228]     if (FALSE) {
[16:05:33.228]     }
[16:05:33.228]     else {
[16:05:33.228]         if (TRUE) {
[16:05:33.228]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:33.228]                 open = "w")
[16:05:33.228]         }
[16:05:33.228]         else {
[16:05:33.228]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:33.228]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:33.228]         }
[16:05:33.228]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:33.228]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:33.228]             base::sink(type = "output", split = FALSE)
[16:05:33.228]             base::close(...future.stdout)
[16:05:33.228]         }, add = TRUE)
[16:05:33.228]     }
[16:05:33.228]     ...future.frame <- base::sys.nframe()
[16:05:33.228]     ...future.conditions <- base::list()
[16:05:33.228]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:33.228]     if (FALSE) {
[16:05:33.228]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:33.228]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:33.228]     }
[16:05:33.228]     ...future.result <- base::tryCatch({
[16:05:33.228]         base::withCallingHandlers({
[16:05:33.228]             ...future.value <- base::withVisible(base::local({
[16:05:33.228]                 b <- 2L
[16:05:33.228]                 plan_b <- future::plan("list")
[16:05:33.228]                 nested_b <- nested_a[-1]
[16:05:33.228]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:05:33.228]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:05:33.228]                   "sequential"))
[16:05:33.228]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:05:33.228]                   b = b, nested_b = nested_b, plan_b = plan_b)
[16:05:33.228]             }))
[16:05:33.228]             future::FutureResult(value = ...future.value$value, 
[16:05:33.228]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:33.228]                   ...future.rng), globalenv = if (FALSE) 
[16:05:33.228]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:33.228]                     ...future.globalenv.names))
[16:05:33.228]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:33.228]         }, condition = base::local({
[16:05:33.228]             c <- base::c
[16:05:33.228]             inherits <- base::inherits
[16:05:33.228]             invokeRestart <- base::invokeRestart
[16:05:33.228]             length <- base::length
[16:05:33.228]             list <- base::list
[16:05:33.228]             seq.int <- base::seq.int
[16:05:33.228]             signalCondition <- base::signalCondition
[16:05:33.228]             sys.calls <- base::sys.calls
[16:05:33.228]             `[[` <- base::`[[`
[16:05:33.228]             `+` <- base::`+`
[16:05:33.228]             `<<-` <- base::`<<-`
[16:05:33.228]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:33.228]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:33.228]                   3L)]
[16:05:33.228]             }
[16:05:33.228]             function(cond) {
[16:05:33.228]                 is_error <- inherits(cond, "error")
[16:05:33.228]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:33.228]                   NULL)
[16:05:33.228]                 if (is_error) {
[16:05:33.228]                   sessionInformation <- function() {
[16:05:33.228]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:33.228]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:33.228]                       search = base::search(), system = base::Sys.info())
[16:05:33.228]                   }
[16:05:33.228]                   ...future.conditions[[length(...future.conditions) + 
[16:05:33.228]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:33.228]                     cond$call), session = sessionInformation(), 
[16:05:33.228]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:33.228]                   signalCondition(cond)
[16:05:33.228]                 }
[16:05:33.228]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:33.228]                 "immediateCondition"))) {
[16:05:33.228]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:33.228]                   ...future.conditions[[length(...future.conditions) + 
[16:05:33.228]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:33.228]                   if (TRUE && !signal) {
[16:05:33.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.228]                     {
[16:05:33.228]                       inherits <- base::inherits
[16:05:33.228]                       invokeRestart <- base::invokeRestart
[16:05:33.228]                       is.null <- base::is.null
[16:05:33.228]                       muffled <- FALSE
[16:05:33.228]                       if (inherits(cond, "message")) {
[16:05:33.228]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:33.228]                         if (muffled) 
[16:05:33.228]                           invokeRestart("muffleMessage")
[16:05:33.228]                       }
[16:05:33.228]                       else if (inherits(cond, "warning")) {
[16:05:33.228]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:33.228]                         if (muffled) 
[16:05:33.228]                           invokeRestart("muffleWarning")
[16:05:33.228]                       }
[16:05:33.228]                       else if (inherits(cond, "condition")) {
[16:05:33.228]                         if (!is.null(pattern)) {
[16:05:33.228]                           computeRestarts <- base::computeRestarts
[16:05:33.228]                           grepl <- base::grepl
[16:05:33.228]                           restarts <- computeRestarts(cond)
[16:05:33.228]                           for (restart in restarts) {
[16:05:33.228]                             name <- restart$name
[16:05:33.228]                             if (is.null(name)) 
[16:05:33.228]                               next
[16:05:33.228]                             if (!grepl(pattern, name)) 
[16:05:33.228]                               next
[16:05:33.228]                             invokeRestart(restart)
[16:05:33.228]                             muffled <- TRUE
[16:05:33.228]                             break
[16:05:33.228]                           }
[16:05:33.228]                         }
[16:05:33.228]                       }
[16:05:33.228]                       invisible(muffled)
[16:05:33.228]                     }
[16:05:33.228]                     muffleCondition(cond, pattern = "^muffle")
[16:05:33.228]                   }
[16:05:33.228]                 }
[16:05:33.228]                 else {
[16:05:33.228]                   if (TRUE) {
[16:05:33.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.228]                     {
[16:05:33.228]                       inherits <- base::inherits
[16:05:33.228]                       invokeRestart <- base::invokeRestart
[16:05:33.228]                       is.null <- base::is.null
[16:05:33.228]                       muffled <- FALSE
[16:05:33.228]                       if (inherits(cond, "message")) {
[16:05:33.228]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:33.228]                         if (muffled) 
[16:05:33.228]                           invokeRestart("muffleMessage")
[16:05:33.228]                       }
[16:05:33.228]                       else if (inherits(cond, "warning")) {
[16:05:33.228]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:33.228]                         if (muffled) 
[16:05:33.228]                           invokeRestart("muffleWarning")
[16:05:33.228]                       }
[16:05:33.228]                       else if (inherits(cond, "condition")) {
[16:05:33.228]                         if (!is.null(pattern)) {
[16:05:33.228]                           computeRestarts <- base::computeRestarts
[16:05:33.228]                           grepl <- base::grepl
[16:05:33.228]                           restarts <- computeRestarts(cond)
[16:05:33.228]                           for (restart in restarts) {
[16:05:33.228]                             name <- restart$name
[16:05:33.228]                             if (is.null(name)) 
[16:05:33.228]                               next
[16:05:33.228]                             if (!grepl(pattern, name)) 
[16:05:33.228]                               next
[16:05:33.228]                             invokeRestart(restart)
[16:05:33.228]                             muffled <- TRUE
[16:05:33.228]                             break
[16:05:33.228]                           }
[16:05:33.228]                         }
[16:05:33.228]                       }
[16:05:33.228]                       invisible(muffled)
[16:05:33.228]                     }
[16:05:33.228]                     muffleCondition(cond, pattern = "^muffle")
[16:05:33.228]                   }
[16:05:33.228]                 }
[16:05:33.228]             }
[16:05:33.228]         }))
[16:05:33.228]     }, error = function(ex) {
[16:05:33.228]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:33.228]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:33.228]                 ...future.rng), started = ...future.startTime, 
[16:05:33.228]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:33.228]             version = "1.8"), class = "FutureResult")
[16:05:33.228]     }, finally = {
[16:05:33.228]         if (!identical(...future.workdir, getwd())) 
[16:05:33.228]             setwd(...future.workdir)
[16:05:33.228]         {
[16:05:33.228]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:33.228]                 ...future.oldOptions$nwarnings <- NULL
[16:05:33.228]             }
[16:05:33.228]             base::options(...future.oldOptions)
[16:05:33.228]             if (.Platform$OS.type == "windows") {
[16:05:33.228]                 old_names <- names(...future.oldEnvVars)
[16:05:33.228]                 envs <- base::Sys.getenv()
[16:05:33.228]                 names <- names(envs)
[16:05:33.228]                 common <- intersect(names, old_names)
[16:05:33.228]                 added <- setdiff(names, old_names)
[16:05:33.228]                 removed <- setdiff(old_names, names)
[16:05:33.228]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:33.228]                   envs[common]]
[16:05:33.228]                 NAMES <- toupper(changed)
[16:05:33.228]                 args <- list()
[16:05:33.228]                 for (kk in seq_along(NAMES)) {
[16:05:33.228]                   name <- changed[[kk]]
[16:05:33.228]                   NAME <- NAMES[[kk]]
[16:05:33.228]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.228]                     next
[16:05:33.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:33.228]                 }
[16:05:33.228]                 NAMES <- toupper(added)
[16:05:33.228]                 for (kk in seq_along(NAMES)) {
[16:05:33.228]                   name <- added[[kk]]
[16:05:33.228]                   NAME <- NAMES[[kk]]
[16:05:33.228]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.228]                     next
[16:05:33.228]                   args[[name]] <- ""
[16:05:33.228]                 }
[16:05:33.228]                 NAMES <- toupper(removed)
[16:05:33.228]                 for (kk in seq_along(NAMES)) {
[16:05:33.228]                   name <- removed[[kk]]
[16:05:33.228]                   NAME <- NAMES[[kk]]
[16:05:33.228]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.228]                     next
[16:05:33.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:33.228]                 }
[16:05:33.228]                 if (length(args) > 0) 
[16:05:33.228]                   base::do.call(base::Sys.setenv, args = args)
[16:05:33.228]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:33.228]             }
[16:05:33.228]             else {
[16:05:33.228]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:33.228]             }
[16:05:33.228]             {
[16:05:33.228]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:33.228]                   0L) {
[16:05:33.228]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:33.228]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:33.228]                   base::options(opts)
[16:05:33.228]                 }
[16:05:33.228]                 {
[16:05:33.228]                   {
[16:05:33.228]                     NULL
[16:05:33.228]                     RNGkind("Mersenne-Twister")
[16:05:33.228]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:33.228]                       inherits = FALSE)
[16:05:33.228]                   }
[16:05:33.228]                   options(future.plan = NULL)
[16:05:33.228]                   if (is.na(NA_character_)) 
[16:05:33.228]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:33.228]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:33.228]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:05:33.228]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:33.228]                     envir = parent.frame()) 
[16:05:33.228]                   {
[16:05:33.228]                     if (is.function(workers)) 
[16:05:33.228]                       workers <- workers()
[16:05:33.228]                     workers <- structure(as.integer(workers), 
[16:05:33.228]                       class = class(workers))
[16:05:33.228]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:33.228]                       workers >= 1)
[16:05:33.228]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:33.228]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:33.228]                     }
[16:05:33.228]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:33.228]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:33.228]                       envir = envir)
[16:05:33.228]                     if (!future$lazy) 
[16:05:33.228]                       future <- run(future)
[16:05:33.228]                     invisible(future)
[16:05:33.228]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:33.228]                 }
[16:05:33.228]             }
[16:05:33.228]         }
[16:05:33.228]     })
[16:05:33.228]     if (TRUE) {
[16:05:33.228]         base::sink(type = "output", split = FALSE)
[16:05:33.228]         if (TRUE) {
[16:05:33.228]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:33.228]         }
[16:05:33.228]         else {
[16:05:33.228]             ...future.result["stdout"] <- base::list(NULL)
[16:05:33.228]         }
[16:05:33.228]         base::close(...future.stdout)
[16:05:33.228]         ...future.stdout <- NULL
[16:05:33.228]     }
[16:05:33.228]     ...future.result$conditions <- ...future.conditions
[16:05:33.228]     ...future.result$finished <- base::Sys.time()
[16:05:33.228]     ...future.result
[16:05:33.228] }
[16:05:33.261]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.231] assign_globals() ...
[16:05:33.261]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.231] List of 3
[16:05:33.231]  $ nested_a:List of 1
[16:05:33.231]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:33.231]     envir = parent.frame())  
[16:05:33.231]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[16:05:33.231]   .. ..- attr(*, "untweakable")= chr "persistent"
[16:05:33.231]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:05:33.231]  $ a       : int 1
[16:05:33.231]  $ plan_a  :List of 1
[16:05:33.231]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:33.231]     envir = parent.frame())  
[16:05:33.231]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[16:05:33.231]   .. ..- attr(*, "untweakable")= chr "persistent"
[16:05:33.231]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:05:33.231]  - attr(*, "where")=List of 3
[16:05:33.231]   ..$ nested_a:<environment: R_EmptyEnv> 
[16:05:33.231]   ..$ a       :<environment: R_EmptyEnv> 
[16:05:33.231]   ..$ plan_a  :<environment: R_EmptyEnv> 
[16:05:33.231]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:33.231]  - attr(*, "resolved")= logi FALSE
[16:05:33.231]  - attr(*, "total_size")= num 89928
[16:05:33.231]  - attr(*, "already-done")= logi TRUE
[16:05:33.261]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.239] - copied ‘nested_a’ to environment
[16:05:33.262]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.239] - copied ‘a’ to environment
[16:05:33.262]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.239] - copied ‘plan_a’ to environment
[16:05:33.262]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.239] assign_globals() ... done
[16:05:33.262]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.239] plan(): Setting new future strategy stack:
[16:05:33.262]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.240] List of future strategies:
[16:05:33.240] 1. sequential:
[16:05:33.240]    - args: function (..., envir = parent.frame())
[16:05:33.240]    - tweaked: FALSE
[16:05:33.240]    - call: NULL
[16:05:33.262]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.240] plan(): nbrOfWorkers() = 1
[16:05:33.263]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.241] plan(): Setting new future strategy stack:
[16:05:33.263]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.241] List of future strategies:
[16:05:33.241] 1. multisession:
[16:05:33.241]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:33.241]    - tweaked: FALSE
[16:05:33.241]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.263]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.245] plan(): nbrOfWorkers() = 1
[16:05:33.263]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.245] SequentialFuture started (and completed)
[16:05:33.263]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.246] - Launch lazy future ... done
[16:05:33.263]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.246] run() for ‘SequentialFuture’ ... done
[16:05:33.264] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:05:33.270] getGlobalsAndPackages() ...
[16:05:33.270] Searching for globals...
[16:05:33.272] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:05:33.272] Searching for globals ... DONE
[16:05:33.272] Resolving globals: FALSE
[16:05:33.273] The total size of the 1 globals is 128 bytes (128 bytes)
[16:05:33.273] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:05:33.274] - globals: [1] ‘data’
[16:05:33.274] - packages: [1] ‘future’
[16:05:33.274] getGlobalsAndPackages() ... DONE
[16:05:33.274] run() for ‘Future’ ...
[16:05:33.274] - state: ‘created’
[16:05:33.274] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:33.278] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:33.279] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:33.279]   - Field: ‘label’
[16:05:33.279]   - Field: ‘local’
[16:05:33.279]   - Field: ‘owner’
[16:05:33.279]   - Field: ‘envir’
[16:05:33.279]   - Field: ‘workers’
[16:05:33.279]   - Field: ‘packages’
[16:05:33.279]   - Field: ‘gc’
[16:05:33.280]   - Field: ‘job’
[16:05:33.280]   - Field: ‘conditions’
[16:05:33.280]   - Field: ‘expr’
[16:05:33.280]   - Field: ‘uuid’
[16:05:33.280]   - Field: ‘seed’
[16:05:33.280]   - Field: ‘version’
[16:05:33.280]   - Field: ‘result’
[16:05:33.280]   - Field: ‘asynchronous’
[16:05:33.280]   - Field: ‘calls’
[16:05:33.281]   - Field: ‘globals’
[16:05:33.281]   - Field: ‘stdout’
[16:05:33.281]   - Field: ‘earlySignal’
[16:05:33.281]   - Field: ‘lazy’
[16:05:33.281]   - Field: ‘state’
[16:05:33.281] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:33.281] - Launch lazy future ...
[16:05:33.282] Packages needed by the future expression (n = 1): ‘future’
[16:05:33.282] Packages needed by future strategies (n = 1): ‘future’
[16:05:33.283] {
[16:05:33.283]     {
[16:05:33.283]         {
[16:05:33.283]             ...future.startTime <- base::Sys.time()
[16:05:33.283]             {
[16:05:33.283]                 {
[16:05:33.283]                   {
[16:05:33.283]                     {
[16:05:33.283]                       {
[16:05:33.283]                         base::local({
[16:05:33.283]                           has_future <- base::requireNamespace("future", 
[16:05:33.283]                             quietly = TRUE)
[16:05:33.283]                           if (has_future) {
[16:05:33.283]                             ns <- base::getNamespace("future")
[16:05:33.283]                             version <- ns[[".package"]][["version"]]
[16:05:33.283]                             if (is.null(version)) 
[16:05:33.283]                               version <- utils::packageVersion("future")
[16:05:33.283]                           }
[16:05:33.283]                           else {
[16:05:33.283]                             version <- NULL
[16:05:33.283]                           }
[16:05:33.283]                           if (!has_future || version < "1.8.0") {
[16:05:33.283]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:33.283]                               "", base::R.version$version.string), 
[16:05:33.283]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:33.283]                                 base::R.version$platform, 8 * 
[16:05:33.283]                                   base::.Machine$sizeof.pointer), 
[16:05:33.283]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:33.283]                                 "release", "version")], collapse = " "), 
[16:05:33.283]                               hostname = base::Sys.info()[["nodename"]])
[16:05:33.283]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:33.283]                               info)
[16:05:33.283]                             info <- base::paste(info, collapse = "; ")
[16:05:33.283]                             if (!has_future) {
[16:05:33.283]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:33.283]                                 info)
[16:05:33.283]                             }
[16:05:33.283]                             else {
[16:05:33.283]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:33.283]                                 info, version)
[16:05:33.283]                             }
[16:05:33.283]                             base::stop(msg)
[16:05:33.283]                           }
[16:05:33.283]                         })
[16:05:33.283]                       }
[16:05:33.283]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:33.283]                       base::options(mc.cores = 1L)
[16:05:33.283]                     }
[16:05:33.283]                     base::local({
[16:05:33.283]                       for (pkg in "future") {
[16:05:33.283]                         base::loadNamespace(pkg)
[16:05:33.283]                         base::library(pkg, character.only = TRUE)
[16:05:33.283]                       }
[16:05:33.283]                     })
[16:05:33.283]                   }
[16:05:33.283]                   options(future.plan = NULL)
[16:05:33.283]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:33.283]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:05:33.283]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:33.283]                     envir = parent.frame()) 
[16:05:33.283]                   {
[16:05:33.283]                     if (is.function(workers)) 
[16:05:33.283]                       workers <- workers()
[16:05:33.283]                     workers <- structure(as.integer(workers), 
[16:05:33.283]                       class = class(workers))
[16:05:33.283]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:33.283]                       workers >= 1)
[16:05:33.283]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:33.283]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:33.283]                     }
[16:05:33.283]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:33.283]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:33.283]                       envir = envir)
[16:05:33.283]                     if (!future$lazy) 
[16:05:33.283]                       future <- run(future)
[16:05:33.283]                     invisible(future)
[16:05:33.283]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:33.283]                 }
[16:05:33.283]                 ...future.workdir <- getwd()
[16:05:33.283]             }
[16:05:33.283]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:33.283]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:33.283]         }
[16:05:33.283]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:33.283]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:33.283]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:33.283]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:33.283]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:33.283]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:33.283]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:33.283]             base::names(...future.oldOptions))
[16:05:33.283]     }
[16:05:33.283]     if (FALSE) {
[16:05:33.283]     }
[16:05:33.283]     else {
[16:05:33.283]         if (TRUE) {
[16:05:33.283]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:33.283]                 open = "w")
[16:05:33.283]         }
[16:05:33.283]         else {
[16:05:33.283]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:33.283]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:33.283]         }
[16:05:33.283]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:33.283]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:33.283]             base::sink(type = "output", split = FALSE)
[16:05:33.283]             base::close(...future.stdout)
[16:05:33.283]         }, add = TRUE)
[16:05:33.283]     }
[16:05:33.283]     ...future.frame <- base::sys.nframe()
[16:05:33.283]     ...future.conditions <- base::list()
[16:05:33.283]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:33.283]     if (FALSE) {
[16:05:33.283]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:33.283]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:33.283]     }
[16:05:33.283]     ...future.result <- base::tryCatch({
[16:05:33.283]         base::withCallingHandlers({
[16:05:33.283]             ...future.value <- base::withVisible(base::local({
[16:05:33.283]                 withCallingHandlers({
[16:05:33.283]                   {
[16:05:33.283]                     value(future(subset(data, a == 2)))
[16:05:33.283]                   }
[16:05:33.283]                 }, immediateCondition = function(cond) {
[16:05:33.283]                   save_rds <- function (object, pathname, ...) 
[16:05:33.283]                   {
[16:05:33.283]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:33.283]                     if (file_test("-f", pathname_tmp)) {
[16:05:33.283]                       fi_tmp <- file.info(pathname_tmp)
[16:05:33.283]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:33.283]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:33.283]                         fi_tmp[["mtime"]])
[16:05:33.283]                     }
[16:05:33.283]                     tryCatch({
[16:05:33.283]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:33.283]                     }, error = function(ex) {
[16:05:33.283]                       msg <- conditionMessage(ex)
[16:05:33.283]                       fi_tmp <- file.info(pathname_tmp)
[16:05:33.283]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:33.283]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:33.283]                         fi_tmp[["mtime"]], msg)
[16:05:33.283]                       ex$message <- msg
[16:05:33.283]                       stop(ex)
[16:05:33.283]                     })
[16:05:33.283]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:33.283]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:33.283]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:33.283]                       fi_tmp <- file.info(pathname_tmp)
[16:05:33.283]                       fi <- file.info(pathname)
[16:05:33.283]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:33.283]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:33.283]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:33.283]                         fi[["size"]], fi[["mtime"]])
[16:05:33.283]                       stop(msg)
[16:05:33.283]                     }
[16:05:33.283]                     invisible(pathname)
[16:05:33.283]                   }
[16:05:33.283]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:33.283]                     rootPath = tempdir()) 
[16:05:33.283]                   {
[16:05:33.283]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:33.283]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:33.283]                       tmpdir = path, fileext = ".rds")
[16:05:33.283]                     save_rds(obj, file)
[16:05:33.283]                   }
[16:05:33.283]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0EbAi0/.future/immediateConditions")
[16:05:33.283]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.283]                   {
[16:05:33.283]                     inherits <- base::inherits
[16:05:33.283]                     invokeRestart <- base::invokeRestart
[16:05:33.283]                     is.null <- base::is.null
[16:05:33.283]                     muffled <- FALSE
[16:05:33.283]                     if (inherits(cond, "message")) {
[16:05:33.283]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:33.283]                       if (muffled) 
[16:05:33.283]                         invokeRestart("muffleMessage")
[16:05:33.283]                     }
[16:05:33.283]                     else if (inherits(cond, "warning")) {
[16:05:33.283]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:33.283]                       if (muffled) 
[16:05:33.283]                         invokeRestart("muffleWarning")
[16:05:33.283]                     }
[16:05:33.283]                     else if (inherits(cond, "condition")) {
[16:05:33.283]                       if (!is.null(pattern)) {
[16:05:33.283]                         computeRestarts <- base::computeRestarts
[16:05:33.283]                         grepl <- base::grepl
[16:05:33.283]                         restarts <- computeRestarts(cond)
[16:05:33.283]                         for (restart in restarts) {
[16:05:33.283]                           name <- restart$name
[16:05:33.283]                           if (is.null(name)) 
[16:05:33.283]                             next
[16:05:33.283]                           if (!grepl(pattern, name)) 
[16:05:33.283]                             next
[16:05:33.283]                           invokeRestart(restart)
[16:05:33.283]                           muffled <- TRUE
[16:05:33.283]                           break
[16:05:33.283]                         }
[16:05:33.283]                       }
[16:05:33.283]                     }
[16:05:33.283]                     invisible(muffled)
[16:05:33.283]                   }
[16:05:33.283]                   muffleCondition(cond)
[16:05:33.283]                 })
[16:05:33.283]             }))
[16:05:33.283]             future::FutureResult(value = ...future.value$value, 
[16:05:33.283]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:33.283]                   ...future.rng), globalenv = if (FALSE) 
[16:05:33.283]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:33.283]                     ...future.globalenv.names))
[16:05:33.283]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:33.283]         }, condition = base::local({
[16:05:33.283]             c <- base::c
[16:05:33.283]             inherits <- base::inherits
[16:05:33.283]             invokeRestart <- base::invokeRestart
[16:05:33.283]             length <- base::length
[16:05:33.283]             list <- base::list
[16:05:33.283]             seq.int <- base::seq.int
[16:05:33.283]             signalCondition <- base::signalCondition
[16:05:33.283]             sys.calls <- base::sys.calls
[16:05:33.283]             `[[` <- base::`[[`
[16:05:33.283]             `+` <- base::`+`
[16:05:33.283]             `<<-` <- base::`<<-`
[16:05:33.283]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:33.283]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:33.283]                   3L)]
[16:05:33.283]             }
[16:05:33.283]             function(cond) {
[16:05:33.283]                 is_error <- inherits(cond, "error")
[16:05:33.283]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:33.283]                   NULL)
[16:05:33.283]                 if (is_error) {
[16:05:33.283]                   sessionInformation <- function() {
[16:05:33.283]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:33.283]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:33.283]                       search = base::search(), system = base::Sys.info())
[16:05:33.283]                   }
[16:05:33.283]                   ...future.conditions[[length(...future.conditions) + 
[16:05:33.283]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:33.283]                     cond$call), session = sessionInformation(), 
[16:05:33.283]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:33.283]                   signalCondition(cond)
[16:05:33.283]                 }
[16:05:33.283]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:33.283]                 "immediateCondition"))) {
[16:05:33.283]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:33.283]                   ...future.conditions[[length(...future.conditions) + 
[16:05:33.283]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:33.283]                   if (TRUE && !signal) {
[16:05:33.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.283]                     {
[16:05:33.283]                       inherits <- base::inherits
[16:05:33.283]                       invokeRestart <- base::invokeRestart
[16:05:33.283]                       is.null <- base::is.null
[16:05:33.283]                       muffled <- FALSE
[16:05:33.283]                       if (inherits(cond, "message")) {
[16:05:33.283]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:33.283]                         if (muffled) 
[16:05:33.283]                           invokeRestart("muffleMessage")
[16:05:33.283]                       }
[16:05:33.283]                       else if (inherits(cond, "warning")) {
[16:05:33.283]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:33.283]                         if (muffled) 
[16:05:33.283]                           invokeRestart("muffleWarning")
[16:05:33.283]                       }
[16:05:33.283]                       else if (inherits(cond, "condition")) {
[16:05:33.283]                         if (!is.null(pattern)) {
[16:05:33.283]                           computeRestarts <- base::computeRestarts
[16:05:33.283]                           grepl <- base::grepl
[16:05:33.283]                           restarts <- computeRestarts(cond)
[16:05:33.283]                           for (restart in restarts) {
[16:05:33.283]                             name <- restart$name
[16:05:33.283]                             if (is.null(name)) 
[16:05:33.283]                               next
[16:05:33.283]                             if (!grepl(pattern, name)) 
[16:05:33.283]                               next
[16:05:33.283]                             invokeRestart(restart)
[16:05:33.283]                             muffled <- TRUE
[16:05:33.283]                             break
[16:05:33.283]                           }
[16:05:33.283]                         }
[16:05:33.283]                       }
[16:05:33.283]                       invisible(muffled)
[16:05:33.283]                     }
[16:05:33.283]                     muffleCondition(cond, pattern = "^muffle")
[16:05:33.283]                   }
[16:05:33.283]                 }
[16:05:33.283]                 else {
[16:05:33.283]                   if (TRUE) {
[16:05:33.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.283]                     {
[16:05:33.283]                       inherits <- base::inherits
[16:05:33.283]                       invokeRestart <- base::invokeRestart
[16:05:33.283]                       is.null <- base::is.null
[16:05:33.283]                       muffled <- FALSE
[16:05:33.283]                       if (inherits(cond, "message")) {
[16:05:33.283]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:33.283]                         if (muffled) 
[16:05:33.283]                           invokeRestart("muffleMessage")
[16:05:33.283]                       }
[16:05:33.283]                       else if (inherits(cond, "warning")) {
[16:05:33.283]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:33.283]                         if (muffled) 
[16:05:33.283]                           invokeRestart("muffleWarning")
[16:05:33.283]                       }
[16:05:33.283]                       else if (inherits(cond, "condition")) {
[16:05:33.283]                         if (!is.null(pattern)) {
[16:05:33.283]                           computeRestarts <- base::computeRestarts
[16:05:33.283]                           grepl <- base::grepl
[16:05:33.283]                           restarts <- computeRestarts(cond)
[16:05:33.283]                           for (restart in restarts) {
[16:05:33.283]                             name <- restart$name
[16:05:33.283]                             if (is.null(name)) 
[16:05:33.283]                               next
[16:05:33.283]                             if (!grepl(pattern, name)) 
[16:05:33.283]                               next
[16:05:33.283]                             invokeRestart(restart)
[16:05:33.283]                             muffled <- TRUE
[16:05:33.283]                             break
[16:05:33.283]                           }
[16:05:33.283]                         }
[16:05:33.283]                       }
[16:05:33.283]                       invisible(muffled)
[16:05:33.283]                     }
[16:05:33.283]                     muffleCondition(cond, pattern = "^muffle")
[16:05:33.283]                   }
[16:05:33.283]                 }
[16:05:33.283]             }
[16:05:33.283]         }))
[16:05:33.283]     }, error = function(ex) {
[16:05:33.283]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:33.283]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:33.283]                 ...future.rng), started = ...future.startTime, 
[16:05:33.283]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:33.283]             version = "1.8"), class = "FutureResult")
[16:05:33.283]     }, finally = {
[16:05:33.283]         if (!identical(...future.workdir, getwd())) 
[16:05:33.283]             setwd(...future.workdir)
[16:05:33.283]         {
[16:05:33.283]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:33.283]                 ...future.oldOptions$nwarnings <- NULL
[16:05:33.283]             }
[16:05:33.283]             base::options(...future.oldOptions)
[16:05:33.283]             if (.Platform$OS.type == "windows") {
[16:05:33.283]                 old_names <- names(...future.oldEnvVars)
[16:05:33.283]                 envs <- base::Sys.getenv()
[16:05:33.283]                 names <- names(envs)
[16:05:33.283]                 common <- intersect(names, old_names)
[16:05:33.283]                 added <- setdiff(names, old_names)
[16:05:33.283]                 removed <- setdiff(old_names, names)
[16:05:33.283]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:33.283]                   envs[common]]
[16:05:33.283]                 NAMES <- toupper(changed)
[16:05:33.283]                 args <- list()
[16:05:33.283]                 for (kk in seq_along(NAMES)) {
[16:05:33.283]                   name <- changed[[kk]]
[16:05:33.283]                   NAME <- NAMES[[kk]]
[16:05:33.283]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.283]                     next
[16:05:33.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:33.283]                 }
[16:05:33.283]                 NAMES <- toupper(added)
[16:05:33.283]                 for (kk in seq_along(NAMES)) {
[16:05:33.283]                   name <- added[[kk]]
[16:05:33.283]                   NAME <- NAMES[[kk]]
[16:05:33.283]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.283]                     next
[16:05:33.283]                   args[[name]] <- ""
[16:05:33.283]                 }
[16:05:33.283]                 NAMES <- toupper(removed)
[16:05:33.283]                 for (kk in seq_along(NAMES)) {
[16:05:33.283]                   name <- removed[[kk]]
[16:05:33.283]                   NAME <- NAMES[[kk]]
[16:05:33.283]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.283]                     next
[16:05:33.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:33.283]                 }
[16:05:33.283]                 if (length(args) > 0) 
[16:05:33.283]                   base::do.call(base::Sys.setenv, args = args)
[16:05:33.283]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:33.283]             }
[16:05:33.283]             else {
[16:05:33.283]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:33.283]             }
[16:05:33.283]             {
[16:05:33.283]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:33.283]                   0L) {
[16:05:33.283]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:33.283]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:33.283]                   base::options(opts)
[16:05:33.283]                 }
[16:05:33.283]                 {
[16:05:33.283]                   {
[16:05:33.283]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:33.283]                     NULL
[16:05:33.283]                   }
[16:05:33.283]                   options(future.plan = NULL)
[16:05:33.283]                   if (is.na(NA_character_)) 
[16:05:33.283]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:33.283]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:33.283]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:33.283]                     envir = parent.frame()) 
[16:05:33.283]                   {
[16:05:33.283]                     default_workers <- missing(workers)
[16:05:33.283]                     if (is.function(workers)) 
[16:05:33.283]                       workers <- workers()
[16:05:33.283]                     workers <- structure(as.integer(workers), 
[16:05:33.283]                       class = class(workers))
[16:05:33.283]                     stop_if_not(is.finite(workers), workers >= 
[16:05:33.283]                       1L)
[16:05:33.283]                     if ((workers == 1L && !inherits(workers, 
[16:05:33.283]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:33.283]                       if (default_workers) 
[16:05:33.283]                         supportsMulticore(warn = TRUE)
[16:05:33.283]                       return(sequential(..., envir = envir))
[16:05:33.283]                     }
[16:05:33.283]                     oopts <- options(mc.cores = workers)
[16:05:33.283]                     on.exit(options(oopts))
[16:05:33.283]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:33.283]                       envir = envir)
[16:05:33.283]                     if (!future$lazy) 
[16:05:33.283]                       future <- run(future)
[16:05:33.283]                     invisible(future)
[16:05:33.283]                   }, b = function (..., workers = availableCores(), 
[16:05:33.283]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:33.283]                     envir = parent.frame()) 
[16:05:33.283]                   {
[16:05:33.283]                     if (is.function(workers)) 
[16:05:33.283]                       workers <- workers()
[16:05:33.283]                     workers <- structure(as.integer(workers), 
[16:05:33.283]                       class = class(workers))
[16:05:33.283]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:33.283]                       workers >= 1)
[16:05:33.283]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:33.283]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:33.283]                     }
[16:05:33.283]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:33.283]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:33.283]                       envir = envir)
[16:05:33.283]                     if (!future$lazy) 
[16:05:33.283]                       future <- run(future)
[16:05:33.283]                     invisible(future)
[16:05:33.283]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:33.283]                 }
[16:05:33.283]             }
[16:05:33.283]         }
[16:05:33.283]     })
[16:05:33.283]     if (TRUE) {
[16:05:33.283]         base::sink(type = "output", split = FALSE)
[16:05:33.283]         if (TRUE) {
[16:05:33.283]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:33.283]         }
[16:05:33.283]         else {
[16:05:33.283]             ...future.result["stdout"] <- base::list(NULL)
[16:05:33.283]         }
[16:05:33.283]         base::close(...future.stdout)
[16:05:33.283]         ...future.stdout <- NULL
[16:05:33.283]     }
[16:05:33.283]     ...future.result$conditions <- ...future.conditions
[16:05:33.283]     ...future.result$finished <- base::Sys.time()
[16:05:33.283]     ...future.result
[16:05:33.283] }
[16:05:33.286] assign_globals() ...
[16:05:33.286] List of 1
[16:05:33.286]  $ data:'data.frame':	3 obs. of  2 variables:
[16:05:33.286]   ..$ a: int [1:3] 1 2 3
[16:05:33.286]   ..$ b: int [1:3] 3 2 1
[16:05:33.286]  - attr(*, "where")=List of 1
[16:05:33.286]   ..$ data:<environment: R_EmptyEnv> 
[16:05:33.286]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:33.286]  - attr(*, "resolved")= logi FALSE
[16:05:33.286]  - attr(*, "total_size")= num 128
[16:05:33.286]  - attr(*, "already-done")= logi TRUE
[16:05:33.290] - copied ‘data’ to environment
[16:05:33.290] assign_globals() ... done
[16:05:33.290] requestCore(): workers = 2
[16:05:33.292] MulticoreFuture started
[16:05:33.293] - Launch lazy future ... done
[16:05:33.293] run() for ‘MulticoreFuture’ ... done
[16:05:33.293] result() for MulticoreFuture ...
[16:05:33.294] plan(): Setting new future strategy stack:
[16:05:33.294] List of future strategies:
[16:05:33.294] 1. multisession:
[16:05:33.294]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:33.294]    - tweaked: FALSE
[16:05:33.294]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.303] plan(): nbrOfWorkers() = 1
[16:05:33.334] plan(): Setting new future strategy stack:
[16:05:33.334] List of future strategies:
[16:05:33.334] 1. multicore:
[16:05:33.334]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:33.334]    - tweaked: FALSE
[16:05:33.334]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.334] 2. multisession:
[16:05:33.334]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:33.334]    - tweaked: FALSE
[16:05:33.334]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.338] plan(): nbrOfWorkers() = 2
[16:05:33.339] result() for MulticoreFuture ...
[16:05:33.339] result() for MulticoreFuture ... done
[16:05:33.339] signalConditions() ...
[16:05:33.339]  - include = ‘immediateCondition’
[16:05:33.340]  - exclude = 
[16:05:33.340]  - resignal = FALSE
[16:05:33.340]  - Number of conditions: 52
[16:05:33.340] signalConditions() ... done
[16:05:33.340] result() for MulticoreFuture ... done
[16:05:33.340] result() for MulticoreFuture ...
[16:05:33.341] result() for MulticoreFuture ... done
[16:05:33.341] signalConditions() ...
[16:05:33.341]  - include = ‘immediateCondition’
[16:05:33.341]  - exclude = 
[16:05:33.341]  - resignal = FALSE
[16:05:33.341]  - Number of conditions: 52
[16:05:33.342] signalConditions() ... done
[16:05:33.342] Future state: ‘finished’
[16:05:33.342] result() for MulticoreFuture ...
[16:05:33.342] result() for MulticoreFuture ... done
[16:05:33.342] signalConditions() ...
[16:05:33.342]  - include = ‘condition’
[16:05:33.343]  - exclude = ‘immediateCondition’
[16:05:33.343]  - resignal = TRUE
[16:05:33.343]  - Number of conditions: 52
[16:05:33.343]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.304] getGlobalsAndPackages() ...
[16:05:33.343]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.304] Searching for globals...
[16:05:33.343]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.306] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[16:05:33.344]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.306] Searching for globals ... DONE
[16:05:33.344]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.306] Resolving globals: FALSE
[16:05:33.344]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.307] The total size of the 1 globals is 128 bytes (128 bytes)
[16:05:33.344]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.308] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:05:33.344]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.308] - globals: [1] ‘data’
[16:05:33.344]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.308] 
[16:05:33.345]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.308] getGlobalsAndPackages() ... DONE
[16:05:33.345]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.309] run() for ‘Future’ ...
[16:05:33.345]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.309] - state: ‘created’
[16:05:33.345]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.309] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:33.345]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.313] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:33.345]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.314] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:33.346]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.314]   - Field: ‘label’
[16:05:33.346]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.314]   - Field: ‘local’
[16:05:33.346]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.314]   - Field: ‘owner’
[16:05:33.346]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.314]   - Field: ‘envir’
[16:05:33.346]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.314]   - Field: ‘packages’
[16:05:33.346]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.315]   - Field: ‘gc’
[16:05:33.346]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.315]   - Field: ‘conditions’
[16:05:33.347]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.315]   - Field: ‘expr’
[16:05:33.347]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.315]   - Field: ‘uuid’
[16:05:33.347]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.315]   - Field: ‘seed’
[16:05:33.347]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.316]   - Field: ‘version’
[16:05:33.347]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.316]   - Field: ‘result’
[16:05:33.347]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.316]   - Field: ‘asynchronous’
[16:05:33.348]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.316]   - Field: ‘calls’
[16:05:33.348]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.316]   - Field: ‘globals’
[16:05:33.348]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.317]   - Field: ‘stdout’
[16:05:33.348]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.317]   - Field: ‘earlySignal’
[16:05:33.348]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.317]   - Field: ‘lazy’
[16:05:33.348]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.317]   - Field: ‘state’
[16:05:33.349]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.317] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:33.349]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.317] - Launch lazy future ...
[16:05:33.349]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.318] Packages needed by the future expression (n = 0): <none>
[16:05:33.349]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.318] Packages needed by future strategies (n = 0): <none>
[16:05:33.349]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.319] {
[16:05:33.319]     {
[16:05:33.319]         {
[16:05:33.319]             ...future.startTime <- base::Sys.time()
[16:05:33.319]             {
[16:05:33.319]                 {
[16:05:33.319]                   {
[16:05:33.319]                     base::local({
[16:05:33.319]                       has_future <- base::requireNamespace("future", 
[16:05:33.319]                         quietly = TRUE)
[16:05:33.319]                       if (has_future) {
[16:05:33.319]                         ns <- base::getNamespace("future")
[16:05:33.319]                         version <- ns[[".package"]][["version"]]
[16:05:33.319]                         if (is.null(version)) 
[16:05:33.319]                           version <- utils::packageVersion("future")
[16:05:33.319]                       }
[16:05:33.319]                       else {
[16:05:33.319]                         version <- NULL
[16:05:33.319]                       }
[16:05:33.319]                       if (!has_future || version < "1.8.0") {
[16:05:33.319]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:33.319]                           "", base::R.version$version.string), 
[16:05:33.319]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:33.319]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:33.319]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:33.319]                             "release", "version")], collapse = " "), 
[16:05:33.319]                           hostname = base::Sys.info()[["nodename"]])
[16:05:33.319]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:33.319]                           info)
[16:05:33.319]                         info <- base::paste(info, collapse = "; ")
[16:05:33.319]                         if (!has_future) {
[16:05:33.319]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:33.319]                             info)
[16:05:33.319]                         }
[16:05:33.319]                         else {
[16:05:33.319]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:33.319]                             info, version)
[16:05:33.319]                         }
[16:05:33.319]                         base::stop(msg)
[16:05:33.319]                       }
[16:05:33.319]                     })
[16:05:33.319]                   }
[16:05:33.319]                   options(future.plan = NULL)
[16:05:33.319]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:33.319]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:33.319]                 }
[16:05:33.319]                 ...future.workdir <- getwd()
[16:05:33.319]             }
[16:05:33.319]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:33.319]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:33.319]         }
[16:05:33.319]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:33.319]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:33.319]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:33.319]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:33.319]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:33.319]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:33.319]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:33.319]             base::names(...future.oldOptions))
[16:05:33.319]     }
[16:05:33.319]     if (FALSE) {
[16:05:33.319]     }
[16:05:33.319]     else {
[16:05:33.319]         if (TRUE) {
[16:05:33.319]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:33.319]                 open = "w")
[16:05:33.319]         }
[16:05:33.319]         else {
[16:05:33.319]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:33.319]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:33.319]         }
[16:05:33.319]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:33.319]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:33.319]             base::sink(type = "output", split = FALSE)
[16:05:33.319]             base::close(...future.stdout)
[16:05:33.319]         }, add = TRUE)
[16:05:33.319]     }
[16:05:33.319]     ...future.frame <- base::sys.nframe()
[16:05:33.319]     ...future.conditions <- base::list()
[16:05:33.319]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:33.319]     if (FALSE) {
[16:05:33.319]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:33.319]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:33.319]     }
[16:05:33.319]     ...future.result <- base::tryCatch({
[16:05:33.319]         base::withCallingHandlers({
[16:05:33.319]             ...future.value <- base::withVisible(base::local(subset(data, 
[16:05:33.319]                 a == 2)))
[16:05:33.319]             future::FutureResult(value = ...future.value$value, 
[16:05:33.319]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:33.319]                   ...future.rng), globalenv = if (FALSE) 
[16:05:33.319]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:33.319]                     ...future.globalenv.names))
[16:05:33.319]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:33.319]         }, condition = base::local({
[16:05:33.319]             c <- base::c
[16:05:33.319]             inherits <- base::inherits
[16:05:33.319]             invokeRestart <- base::invokeRestart
[16:05:33.319]             length <- base::length
[16:05:33.319]             list <- base::list
[16:05:33.319]             seq.int <- base::seq.int
[16:05:33.319]             signalCondition <- base::signalCondition
[16:05:33.319]             sys.calls <- base::sys.calls
[16:05:33.319]             `[[` <- base::`[[`
[16:05:33.319]             `+` <- base::`+`
[16:05:33.319]             `<<-` <- base::`<<-`
[16:05:33.319]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:33.319]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:33.319]                   3L)]
[16:05:33.319]             }
[16:05:33.319]             function(cond) {
[16:05:33.319]                 is_error <- inherits(cond, "error")
[16:05:33.319]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:33.319]                   NULL)
[16:05:33.319]                 if (is_error) {
[16:05:33.319]                   sessionInformation <- function() {
[16:05:33.319]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:33.319]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:33.319]                       search = base::search(), system = base::Sys.info())
[16:05:33.319]                   }
[16:05:33.319]                   ...future.conditions[[length(...future.conditions) + 
[16:05:33.319]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:33.319]                     cond$call), session = sessionInformation(), 
[16:05:33.319]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:33.319]                   signalCondition(cond)
[16:05:33.319]                 }
[16:05:33.319]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:33.319]                 "immediateCondition"))) {
[16:05:33.319]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:33.319]                   ...future.conditions[[length(...future.conditions) + 
[16:05:33.319]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:33.319]                   if (TRUE && !signal) {
[16:05:33.319]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.319]                     {
[16:05:33.319]                       inherits <- base::inherits
[16:05:33.319]                       invokeRestart <- base::invokeRestart
[16:05:33.319]                       is.null <- base::is.null
[16:05:33.319]                       muffled <- FALSE
[16:05:33.319]                       if (inherits(cond, "message")) {
[16:05:33.319]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:33.319]                         if (muffled) 
[16:05:33.319]                           invokeRestart("muffleMessage")
[16:05:33.319]                       }
[16:05:33.319]                       else if (inherits(cond, "warning")) {
[16:05:33.319]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:33.319]                         if (muffled) 
[16:05:33.319]                           invokeRestart("muffleWarning")
[16:05:33.319]                       }
[16:05:33.319]                       else if (inherits(cond, "condition")) {
[16:05:33.319]                         if (!is.null(pattern)) {
[16:05:33.319]                           computeRestarts <- base::computeRestarts
[16:05:33.319]                           grepl <- base::grepl
[16:05:33.319]                           restarts <- computeRestarts(cond)
[16:05:33.319]                           for (restart in restarts) {
[16:05:33.319]                             name <- restart$name
[16:05:33.319]                             if (is.null(name)) 
[16:05:33.319]                               next
[16:05:33.319]                             if (!grepl(pattern, name)) 
[16:05:33.319]                               next
[16:05:33.319]                             invokeRestart(restart)
[16:05:33.319]                             muffled <- TRUE
[16:05:33.319]                             break
[16:05:33.319]                           }
[16:05:33.319]                         }
[16:05:33.319]                       }
[16:05:33.319]                       invisible(muffled)
[16:05:33.319]                     }
[16:05:33.319]                     muffleCondition(cond, pattern = "^muffle")
[16:05:33.319]                   }
[16:05:33.319]                 }
[16:05:33.319]                 else {
[16:05:33.319]                   if (TRUE) {
[16:05:33.319]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.319]                     {
[16:05:33.319]                       inherits <- base::inherits
[16:05:33.319]                       invokeRestart <- base::invokeRestart
[16:05:33.319]                       is.null <- base::is.null
[16:05:33.319]                       muffled <- FALSE
[16:05:33.319]                       if (inherits(cond, "message")) {
[16:05:33.319]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:33.319]                         if (muffled) 
[16:05:33.319]                           invokeRestart("muffleMessage")
[16:05:33.319]                       }
[16:05:33.319]                       else if (inherits(cond, "warning")) {
[16:05:33.319]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:33.319]                         if (muffled) 
[16:05:33.319]                           invokeRestart("muffleWarning")
[16:05:33.319]                       }
[16:05:33.319]                       else if (inherits(cond, "condition")) {
[16:05:33.319]                         if (!is.null(pattern)) {
[16:05:33.319]                           computeRestarts <- base::computeRestarts
[16:05:33.319]                           grepl <- base::grepl
[16:05:33.319]                           restarts <- computeRestarts(cond)
[16:05:33.319]                           for (restart in restarts) {
[16:05:33.319]                             name <- restart$name
[16:05:33.319]                             if (is.null(name)) 
[16:05:33.319]                               next
[16:05:33.319]                             if (!grepl(pattern, name)) 
[16:05:33.319]                               next
[16:05:33.319]                             invokeRestart(restart)
[16:05:33.319]                             muffled <- TRUE
[16:05:33.319]                             break
[16:05:33.319]                           }
[16:05:33.319]                         }
[16:05:33.319]                       }
[16:05:33.319]                       invisible(muffled)
[16:05:33.319]                     }
[16:05:33.319]                     muffleCondition(cond, pattern = "^muffle")
[16:05:33.319]                   }
[16:05:33.319]                 }
[16:05:33.319]             }
[16:05:33.319]         }))
[16:05:33.319]     }, error = function(ex) {
[16:05:33.319]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:33.319]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:33.319]                 ...future.rng), started = ...future.startTime, 
[16:05:33.319]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:33.319]             version = "1.8"), class = "FutureResult")
[16:05:33.319]     }, finally = {
[16:05:33.319]         if (!identical(...future.workdir, getwd())) 
[16:05:33.319]             setwd(...future.workdir)
[16:05:33.319]         {
[16:05:33.319]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:33.319]                 ...future.oldOptions$nwarnings <- NULL
[16:05:33.319]             }
[16:05:33.319]             base::options(...future.oldOptions)
[16:05:33.319]             if (.Platform$OS.type == "windows") {
[16:05:33.319]                 old_names <- names(...future.oldEnvVars)
[16:05:33.319]                 envs <- base::Sys.getenv()
[16:05:33.319]                 names <- names(envs)
[16:05:33.319]                 common <- intersect(names, old_names)
[16:05:33.319]                 added <- setdiff(names, old_names)
[16:05:33.319]                 removed <- setdiff(old_names, names)
[16:05:33.319]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:33.319]                   envs[common]]
[16:05:33.319]                 NAMES <- toupper(changed)
[16:05:33.319]                 args <- list()
[16:05:33.319]                 for (kk in seq_along(NAMES)) {
[16:05:33.319]                   name <- changed[[kk]]
[16:05:33.319]                   NAME <- NAMES[[kk]]
[16:05:33.319]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.319]                     next
[16:05:33.319]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:33.319]                 }
[16:05:33.319]                 NAMES <- toupper(added)
[16:05:33.319]                 for (kk in seq_along(NAMES)) {
[16:05:33.319]                   name <- added[[kk]]
[16:05:33.319]                   NAME <- NAMES[[kk]]
[16:05:33.319]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.319]                     next
[16:05:33.319]                   args[[name]] <- ""
[16:05:33.319]                 }
[16:05:33.319]                 NAMES <- toupper(removed)
[16:05:33.319]                 for (kk in seq_along(NAMES)) {
[16:05:33.319]                   name <- removed[[kk]]
[16:05:33.319]                   NAME <- NAMES[[kk]]
[16:05:33.319]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.319]                     next
[16:05:33.319]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:33.319]                 }
[16:05:33.319]                 if (length(args) > 0) 
[16:05:33.319]                   base::do.call(base::Sys.setenv, args = args)
[16:05:33.319]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:33.319]             }
[16:05:33.319]             else {
[16:05:33.319]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:33.319]             }
[16:05:33.319]             {
[16:05:33.319]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:33.319]                   0L) {
[16:05:33.319]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:33.319]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:33.319]                   base::options(opts)
[16:05:33.319]                 }
[16:05:33.319]                 {
[16:05:33.319]                   {
[16:05:33.319]                     NULL
[16:05:33.319]                     RNGkind("Mersenne-Twister")
[16:05:33.319]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:33.319]                       inherits = FALSE)
[16:05:33.319]                   }
[16:05:33.319]                   options(future.plan = NULL)
[16:05:33.319]                   if (is.na(NA_character_)) 
[16:05:33.319]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:33.319]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:33.319]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:05:33.319]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:33.319]                     envir = parent.frame()) 
[16:05:33.319]                   {
[16:05:33.319]                     if (is.function(workers)) 
[16:05:33.319]                       workers <- workers()
[16:05:33.319]                     workers <- structure(as.integer(workers), 
[16:05:33.319]                       class = class(workers))
[16:05:33.319]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:33.319]                       workers >= 1)
[16:05:33.319]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:33.319]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:33.319]                     }
[16:05:33.319]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:33.319]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:33.319]                       envir = envir)
[16:05:33.319]                     if (!future$lazy) 
[16:05:33.319]                       future <- run(future)
[16:05:33.319]                     invisible(future)
[16:05:33.319]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:33.319]                 }
[16:05:33.319]             }
[16:05:33.319]         }
[16:05:33.319]     })
[16:05:33.319]     if (TRUE) {
[16:05:33.319]         base::sink(type = "output", split = FALSE)
[16:05:33.319]         if (TRUE) {
[16:05:33.319]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:33.319]         }
[16:05:33.319]         else {
[16:05:33.319]             ...future.result["stdout"] <- base::list(NULL)
[16:05:33.319]         }
[16:05:33.319]         base::close(...future.stdout)
[16:05:33.319]         ...future.stdout <- NULL
[16:05:33.319]     }
[16:05:33.319]     ...future.result$conditions <- ...future.conditions
[16:05:33.319]     ...future.result$finished <- base::Sys.time()
[16:05:33.319]     ...future.result
[16:05:33.319] }
[16:05:33.349]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.321] assign_globals() ...
[16:05:33.350]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.321] List of 1
[16:05:33.321]  $ data:'data.frame':	3 obs. of  2 variables:
[16:05:33.321]   ..$ a: int [1:3] 1 2 3
[16:05:33.321]   ..$ b: int [1:3] 3 2 1
[16:05:33.321]  - attr(*, "where")=List of 1
[16:05:33.321]   ..$ data:<environment: R_EmptyEnv> 
[16:05:33.321]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:33.321]  - attr(*, "resolved")= logi FALSE
[16:05:33.321]  - attr(*, "total_size")= num 128
[16:05:33.321]  - attr(*, "already-done")= logi TRUE
[16:05:33.350]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.326] - copied ‘data’ to environment
[16:05:33.350]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.326] assign_globals() ... done
[16:05:33.350]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.326] plan(): Setting new future strategy stack:
[16:05:33.350]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.326] List of future strategies:
[16:05:33.326] 1. sequential:
[16:05:33.326]    - args: function (..., envir = parent.frame())
[16:05:33.326]    - tweaked: FALSE
[16:05:33.326]    - call: NULL
[16:05:33.350]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.327] plan(): nbrOfWorkers() = 1
[16:05:33.351]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.328] plan(): Setting new future strategy stack:
[16:05:33.351]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.328] List of future strategies:
[16:05:33.328] 1. multisession:
[16:05:33.328]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:33.328]    - tweaked: FALSE
[16:05:33.328]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.351]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.332] plan(): nbrOfWorkers() = 1
[16:05:33.351]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.332] SequentialFuture started (and completed)
[16:05:33.351]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.333] - Launch lazy future ... done
[16:05:33.351]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:05:33.333] run() for ‘SequentialFuture’ ... done
[16:05:33.351] signalConditions() ... done
- plan(list('multicore', 'multisession')) ... DONE
- plan(list('multisession', 'sequential')) ...
[16:05:33.352] plan(): Setting new future strategy stack:
[16:05:33.352] List of future strategies:
[16:05:33.352] 1. multisession:
[16:05:33.352]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:33.352]    - tweaked: FALSE
[16:05:33.352]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.352] 2. sequential:
[16:05:33.352]    - args: function (..., envir = parent.frame())
[16:05:33.352]    - tweaked: FALSE
[16:05:33.352]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.353] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:05:33.353] multisession:
[16:05:33.353] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:33.353] - tweaked: FALSE
[16:05:33.353] - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.357] getGlobalsAndPackages() ...
[16:05:33.357] Not searching for globals
[16:05:33.357] - globals: [0] <none>
[16:05:33.357] getGlobalsAndPackages() ... DONE
[16:05:33.358] [local output] makeClusterPSOCK() ...
[16:05:33.361] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:05:33.362] [local output] Base port: 11653
[16:05:33.362] [local output] Getting setup options for 2 cluster nodes ...
[16:05:33.362] [local output]  - Node 1 of 2 ...
[16:05:33.363] [local output] localMachine=TRUE => revtunnel=FALSE

[16:05:33.363] [local output] Rscript port: 11653

[16:05:33.364] [local output]  - Node 2 of 2 ...
[16:05:33.364] [local output] localMachine=TRUE => revtunnel=FALSE

[16:05:33.365] [local output] Rscript port: 11653

[16:05:33.365] [local output] Getting setup options for 2 cluster nodes ... done
[16:05:33.365] [local output]  - Parallel setup requested for some PSOCK nodes
[16:05:33.366] [local output] Setting up PSOCK nodes in parallel
[16:05:33.366] List of 36
[16:05:33.366]  $ worker          : chr "localhost"
[16:05:33.366]   ..- attr(*, "localhost")= logi TRUE
[16:05:33.366]  $ master          : chr "localhost"
[16:05:33.366]  $ port            : int 11653
[16:05:33.366]  $ connectTimeout  : num 120
[16:05:33.366]  $ timeout         : num 2592000
[16:05:33.366]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:05:33.366]  $ homogeneous     : logi TRUE
[16:05:33.366]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:05:33.366]  $ rscript_envs    : NULL
[16:05:33.366]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:05:33.366]  $ rscript_startup : NULL
[16:05:33.366]  $ rscript_sh      : chr "sh"
[16:05:33.366]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:05:33.366]  $ methods         : logi TRUE
[16:05:33.366]  $ socketOptions   : chr "no-delay"
[16:05:33.366]  $ useXDR          : logi FALSE
[16:05:33.366]  $ outfile         : chr "/dev/null"
[16:05:33.366]  $ renice          : int NA
[16:05:33.366]  $ rshcmd          : NULL
[16:05:33.366]  $ user            : chr(0) 
[16:05:33.366]  $ revtunnel       : logi FALSE
[16:05:33.366]  $ rshlogfile      : NULL
[16:05:33.366]  $ rshopts         : chr(0) 
[16:05:33.366]  $ rank            : int 1
[16:05:33.366]  $ manual          : logi FALSE
[16:05:33.366]  $ dryrun          : logi FALSE
[16:05:33.366]  $ quiet           : logi FALSE
[16:05:33.366]  $ setup_strategy  : chr "parallel"
[16:05:33.366]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:05:33.366]  $ pidfile         : chr "/tmp/Rtmp0EbAi0/worker.rank=1.parallelly.parent=88964.15b8434ca30e3.pid"
[16:05:33.366]  $ rshcmd_label    : NULL
[16:05:33.366]  $ rsh_call        : NULL
[16:05:33.366]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:05:33.366]  $ localMachine    : logi TRUE
[16:05:33.366]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:05:33.366]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:05:33.366]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:05:33.366]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:05:33.366]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:05:33.366]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:05:33.366]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:05:33.366]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:05:33.366]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:05:33.366]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:05:33.366]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:05:33.366]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:05:33.366]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:05:33.366]  $ arguments       :List of 28
[16:05:33.366]   ..$ worker          : chr "localhost"
[16:05:33.366]   ..$ master          : NULL
[16:05:33.366]   ..$ port            : int 11653
[16:05:33.366]   ..$ connectTimeout  : num 120
[16:05:33.366]   ..$ timeout         : num 2592000
[16:05:33.366]   ..$ rscript         : NULL
[16:05:33.366]   ..$ homogeneous     : NULL
[16:05:33.366]   ..$ rscript_args    : NULL
[16:05:33.366]   ..$ rscript_envs    : NULL
[16:05:33.366]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:05:33.366]   ..$ rscript_startup : NULL
[16:05:33.366]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:05:33.366]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:05:33.366]   ..$ methods         : logi TRUE
[16:05:33.366]   ..$ socketOptions   : chr "no-delay"
[16:05:33.366]   ..$ useXDR          : logi FALSE
[16:05:33.366]   ..$ outfile         : chr "/dev/null"
[16:05:33.366]   ..$ renice          : int NA
[16:05:33.366]   ..$ rshcmd          : NULL
[16:05:33.366]   ..$ user            : NULL
[16:05:33.366]   ..$ revtunnel       : logi NA
[16:05:33.366]   ..$ rshlogfile      : NULL
[16:05:33.366]   ..$ rshopts         : NULL
[16:05:33.366]   ..$ rank            : int 1
[16:05:33.366]   ..$ manual          : logi FALSE
[16:05:33.366]   ..$ dryrun          : logi FALSE
[16:05:33.366]   ..$ quiet           : logi FALSE
[16:05:33.366]   ..$ setup_strategy  : chr "parallel"
[16:05:33.366]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:05:33.386] [local output] System call to launch all workers:
[16:05:33.387] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp0EbAi0/worker.rank=1.parallelly.parent=88964.15b8434ca30e3.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11653 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:05:33.387] [local output] Starting PSOCK main server
[16:05:33.388] [local output] Workers launched
[16:05:33.388] [local output] Waiting for workers to connect back
[16:05:33.388]  - [local output] 0 workers out of 2 ready
[16:05:33.634]  - [local output] 0 workers out of 2 ready
[16:05:33.635]  - [local output] 1 workers out of 2 ready
[16:05:33.635]  - [local output] 2 workers out of 2 ready
[16:05:33.635] [local output] Launching of workers completed
[16:05:33.635] [local output] Collecting session information from workers
[16:05:33.636] [local output]  - Worker #1 of 2
[16:05:33.637] [local output]  - Worker #2 of 2
[16:05:33.637] [local output] makeClusterPSOCK() ... done
[16:05:33.647] Packages needed by the future expression (n = 0): <none>
[16:05:33.648] Packages needed by future strategies (n = 1): ‘future’
[16:05:33.648] {
[16:05:33.648]     {
[16:05:33.648]         {
[16:05:33.648]             ...future.startTime <- base::Sys.time()
[16:05:33.648]             {
[16:05:33.648]                 {
[16:05:33.648]                   {
[16:05:33.648]                     {
[16:05:33.648]                       {
[16:05:33.648]                         base::local({
[16:05:33.648]                           has_future <- base::requireNamespace("future", 
[16:05:33.648]                             quietly = TRUE)
[16:05:33.648]                           if (has_future) {
[16:05:33.648]                             ns <- base::getNamespace("future")
[16:05:33.648]                             version <- ns[[".package"]][["version"]]
[16:05:33.648]                             if (is.null(version)) 
[16:05:33.648]                               version <- utils::packageVersion("future")
[16:05:33.648]                           }
[16:05:33.648]                           else {
[16:05:33.648]                             version <- NULL
[16:05:33.648]                           }
[16:05:33.648]                           if (!has_future || version < "1.8.0") {
[16:05:33.648]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:33.648]                               "", base::R.version$version.string), 
[16:05:33.648]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:33.648]                                 base::R.version$platform, 8 * 
[16:05:33.648]                                   base::.Machine$sizeof.pointer), 
[16:05:33.648]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:33.648]                                 "release", "version")], collapse = " "), 
[16:05:33.648]                               hostname = base::Sys.info()[["nodename"]])
[16:05:33.648]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:33.648]                               info)
[16:05:33.648]                             info <- base::paste(info, collapse = "; ")
[16:05:33.648]                             if (!has_future) {
[16:05:33.648]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:33.648]                                 info)
[16:05:33.648]                             }
[16:05:33.648]                             else {
[16:05:33.648]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:33.648]                                 info, version)
[16:05:33.648]                             }
[16:05:33.648]                             base::stop(msg)
[16:05:33.648]                           }
[16:05:33.648]                         })
[16:05:33.648]                       }
[16:05:33.648]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:33.648]                       base::options(mc.cores = 1L)
[16:05:33.648]                     }
[16:05:33.648]                     base::local({
[16:05:33.648]                       for (pkg in "future") {
[16:05:33.648]                         base::loadNamespace(pkg)
[16:05:33.648]                         base::library(pkg, character.only = TRUE)
[16:05:33.648]                       }
[16:05:33.648]                     })
[16:05:33.648]                   }
[16:05:33.648]                   options(future.plan = NULL)
[16:05:33.648]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:33.648]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:05:33.648]                   {
[16:05:33.648]                     future <- SequentialFuture(..., envir = envir)
[16:05:33.648]                     if (!future$lazy) 
[16:05:33.648]                       future <- run(future)
[16:05:33.648]                     invisible(future)
[16:05:33.648]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:33.648]                 }
[16:05:33.648]                 ...future.workdir <- getwd()
[16:05:33.648]             }
[16:05:33.648]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:33.648]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:33.648]         }
[16:05:33.648]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:33.648]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:33.648]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:33.648]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:33.648]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:33.648]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:33.648]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:33.648]             base::names(...future.oldOptions))
[16:05:33.648]     }
[16:05:33.648]     if (FALSE) {
[16:05:33.648]     }
[16:05:33.648]     else {
[16:05:33.648]         if (TRUE) {
[16:05:33.648]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:33.648]                 open = "w")
[16:05:33.648]         }
[16:05:33.648]         else {
[16:05:33.648]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:33.648]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:33.648]         }
[16:05:33.648]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:33.648]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:33.648]             base::sink(type = "output", split = FALSE)
[16:05:33.648]             base::close(...future.stdout)
[16:05:33.648]         }, add = TRUE)
[16:05:33.648]     }
[16:05:33.648]     ...future.frame <- base::sys.nframe()
[16:05:33.648]     ...future.conditions <- base::list()
[16:05:33.648]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:33.648]     if (FALSE) {
[16:05:33.648]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:33.648]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:33.648]     }
[16:05:33.648]     ...future.result <- base::tryCatch({
[16:05:33.648]         base::withCallingHandlers({
[16:05:33.648]             ...future.value <- base::withVisible(base::local({
[16:05:33.648]                 ...future.makeSendCondition <- base::local({
[16:05:33.648]                   sendCondition <- NULL
[16:05:33.648]                   function(frame = 1L) {
[16:05:33.648]                     if (is.function(sendCondition)) 
[16:05:33.648]                       return(sendCondition)
[16:05:33.648]                     ns <- getNamespace("parallel")
[16:05:33.648]                     if (exists("sendData", mode = "function", 
[16:05:33.648]                       envir = ns)) {
[16:05:33.648]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:33.648]                         envir = ns)
[16:05:33.648]                       envir <- sys.frame(frame)
[16:05:33.648]                       master <- NULL
[16:05:33.648]                       while (!identical(envir, .GlobalEnv) && 
[16:05:33.648]                         !identical(envir, emptyenv())) {
[16:05:33.648]                         if (exists("master", mode = "list", envir = envir, 
[16:05:33.648]                           inherits = FALSE)) {
[16:05:33.648]                           master <- get("master", mode = "list", 
[16:05:33.648]                             envir = envir, inherits = FALSE)
[16:05:33.648]                           if (inherits(master, c("SOCKnode", 
[16:05:33.648]                             "SOCK0node"))) {
[16:05:33.648]                             sendCondition <<- function(cond) {
[16:05:33.648]                               data <- list(type = "VALUE", value = cond, 
[16:05:33.648]                                 success = TRUE)
[16:05:33.648]                               parallel_sendData(master, data)
[16:05:33.648]                             }
[16:05:33.648]                             return(sendCondition)
[16:05:33.648]                           }
[16:05:33.648]                         }
[16:05:33.648]                         frame <- frame + 1L
[16:05:33.648]                         envir <- sys.frame(frame)
[16:05:33.648]                       }
[16:05:33.648]                     }
[16:05:33.648]                     sendCondition <<- function(cond) NULL
[16:05:33.648]                   }
[16:05:33.648]                 })
[16:05:33.648]                 withCallingHandlers({
[16:05:33.648]                   NA
[16:05:33.648]                 }, immediateCondition = function(cond) {
[16:05:33.648]                   sendCondition <- ...future.makeSendCondition()
[16:05:33.648]                   sendCondition(cond)
[16:05:33.648]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.648]                   {
[16:05:33.648]                     inherits <- base::inherits
[16:05:33.648]                     invokeRestart <- base::invokeRestart
[16:05:33.648]                     is.null <- base::is.null
[16:05:33.648]                     muffled <- FALSE
[16:05:33.648]                     if (inherits(cond, "message")) {
[16:05:33.648]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:33.648]                       if (muffled) 
[16:05:33.648]                         invokeRestart("muffleMessage")
[16:05:33.648]                     }
[16:05:33.648]                     else if (inherits(cond, "warning")) {
[16:05:33.648]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:33.648]                       if (muffled) 
[16:05:33.648]                         invokeRestart("muffleWarning")
[16:05:33.648]                     }
[16:05:33.648]                     else if (inherits(cond, "condition")) {
[16:05:33.648]                       if (!is.null(pattern)) {
[16:05:33.648]                         computeRestarts <- base::computeRestarts
[16:05:33.648]                         grepl <- base::grepl
[16:05:33.648]                         restarts <- computeRestarts(cond)
[16:05:33.648]                         for (restart in restarts) {
[16:05:33.648]                           name <- restart$name
[16:05:33.648]                           if (is.null(name)) 
[16:05:33.648]                             next
[16:05:33.648]                           if (!grepl(pattern, name)) 
[16:05:33.648]                             next
[16:05:33.648]                           invokeRestart(restart)
[16:05:33.648]                           muffled <- TRUE
[16:05:33.648]                           break
[16:05:33.648]                         }
[16:05:33.648]                       }
[16:05:33.648]                     }
[16:05:33.648]                     invisible(muffled)
[16:05:33.648]                   }
[16:05:33.648]                   muffleCondition(cond)
[16:05:33.648]                 })
[16:05:33.648]             }))
[16:05:33.648]             future::FutureResult(value = ...future.value$value, 
[16:05:33.648]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:33.648]                   ...future.rng), globalenv = if (FALSE) 
[16:05:33.648]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:33.648]                     ...future.globalenv.names))
[16:05:33.648]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:33.648]         }, condition = base::local({
[16:05:33.648]             c <- base::c
[16:05:33.648]             inherits <- base::inherits
[16:05:33.648]             invokeRestart <- base::invokeRestart
[16:05:33.648]             length <- base::length
[16:05:33.648]             list <- base::list
[16:05:33.648]             seq.int <- base::seq.int
[16:05:33.648]             signalCondition <- base::signalCondition
[16:05:33.648]             sys.calls <- base::sys.calls
[16:05:33.648]             `[[` <- base::`[[`
[16:05:33.648]             `+` <- base::`+`
[16:05:33.648]             `<<-` <- base::`<<-`
[16:05:33.648]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:33.648]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:33.648]                   3L)]
[16:05:33.648]             }
[16:05:33.648]             function(cond) {
[16:05:33.648]                 is_error <- inherits(cond, "error")
[16:05:33.648]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:33.648]                   NULL)
[16:05:33.648]                 if (is_error) {
[16:05:33.648]                   sessionInformation <- function() {
[16:05:33.648]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:33.648]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:33.648]                       search = base::search(), system = base::Sys.info())
[16:05:33.648]                   }
[16:05:33.648]                   ...future.conditions[[length(...future.conditions) + 
[16:05:33.648]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:33.648]                     cond$call), session = sessionInformation(), 
[16:05:33.648]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:33.648]                   signalCondition(cond)
[16:05:33.648]                 }
[16:05:33.648]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:33.648]                 "immediateCondition"))) {
[16:05:33.648]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:33.648]                   ...future.conditions[[length(...future.conditions) + 
[16:05:33.648]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:33.648]                   if (TRUE && !signal) {
[16:05:33.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.648]                     {
[16:05:33.648]                       inherits <- base::inherits
[16:05:33.648]                       invokeRestart <- base::invokeRestart
[16:05:33.648]                       is.null <- base::is.null
[16:05:33.648]                       muffled <- FALSE
[16:05:33.648]                       if (inherits(cond, "message")) {
[16:05:33.648]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:33.648]                         if (muffled) 
[16:05:33.648]                           invokeRestart("muffleMessage")
[16:05:33.648]                       }
[16:05:33.648]                       else if (inherits(cond, "warning")) {
[16:05:33.648]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:33.648]                         if (muffled) 
[16:05:33.648]                           invokeRestart("muffleWarning")
[16:05:33.648]                       }
[16:05:33.648]                       else if (inherits(cond, "condition")) {
[16:05:33.648]                         if (!is.null(pattern)) {
[16:05:33.648]                           computeRestarts <- base::computeRestarts
[16:05:33.648]                           grepl <- base::grepl
[16:05:33.648]                           restarts <- computeRestarts(cond)
[16:05:33.648]                           for (restart in restarts) {
[16:05:33.648]                             name <- restart$name
[16:05:33.648]                             if (is.null(name)) 
[16:05:33.648]                               next
[16:05:33.648]                             if (!grepl(pattern, name)) 
[16:05:33.648]                               next
[16:05:33.648]                             invokeRestart(restart)
[16:05:33.648]                             muffled <- TRUE
[16:05:33.648]                             break
[16:05:33.648]                           }
[16:05:33.648]                         }
[16:05:33.648]                       }
[16:05:33.648]                       invisible(muffled)
[16:05:33.648]                     }
[16:05:33.648]                     muffleCondition(cond, pattern = "^muffle")
[16:05:33.648]                   }
[16:05:33.648]                 }
[16:05:33.648]                 else {
[16:05:33.648]                   if (TRUE) {
[16:05:33.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.648]                     {
[16:05:33.648]                       inherits <- base::inherits
[16:05:33.648]                       invokeRestart <- base::invokeRestart
[16:05:33.648]                       is.null <- base::is.null
[16:05:33.648]                       muffled <- FALSE
[16:05:33.648]                       if (inherits(cond, "message")) {
[16:05:33.648]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:33.648]                         if (muffled) 
[16:05:33.648]                           invokeRestart("muffleMessage")
[16:05:33.648]                       }
[16:05:33.648]                       else if (inherits(cond, "warning")) {
[16:05:33.648]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:33.648]                         if (muffled) 
[16:05:33.648]                           invokeRestart("muffleWarning")
[16:05:33.648]                       }
[16:05:33.648]                       else if (inherits(cond, "condition")) {
[16:05:33.648]                         if (!is.null(pattern)) {
[16:05:33.648]                           computeRestarts <- base::computeRestarts
[16:05:33.648]                           grepl <- base::grepl
[16:05:33.648]                           restarts <- computeRestarts(cond)
[16:05:33.648]                           for (restart in restarts) {
[16:05:33.648]                             name <- restart$name
[16:05:33.648]                             if (is.null(name)) 
[16:05:33.648]                               next
[16:05:33.648]                             if (!grepl(pattern, name)) 
[16:05:33.648]                               next
[16:05:33.648]                             invokeRestart(restart)
[16:05:33.648]                             muffled <- TRUE
[16:05:33.648]                             break
[16:05:33.648]                           }
[16:05:33.648]                         }
[16:05:33.648]                       }
[16:05:33.648]                       invisible(muffled)
[16:05:33.648]                     }
[16:05:33.648]                     muffleCondition(cond, pattern = "^muffle")
[16:05:33.648]                   }
[16:05:33.648]                 }
[16:05:33.648]             }
[16:05:33.648]         }))
[16:05:33.648]     }, error = function(ex) {
[16:05:33.648]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:33.648]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:33.648]                 ...future.rng), started = ...future.startTime, 
[16:05:33.648]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:33.648]             version = "1.8"), class = "FutureResult")
[16:05:33.648]     }, finally = {
[16:05:33.648]         if (!identical(...future.workdir, getwd())) 
[16:05:33.648]             setwd(...future.workdir)
[16:05:33.648]         {
[16:05:33.648]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:33.648]                 ...future.oldOptions$nwarnings <- NULL
[16:05:33.648]             }
[16:05:33.648]             base::options(...future.oldOptions)
[16:05:33.648]             if (.Platform$OS.type == "windows") {
[16:05:33.648]                 old_names <- names(...future.oldEnvVars)
[16:05:33.648]                 envs <- base::Sys.getenv()
[16:05:33.648]                 names <- names(envs)
[16:05:33.648]                 common <- intersect(names, old_names)
[16:05:33.648]                 added <- setdiff(names, old_names)
[16:05:33.648]                 removed <- setdiff(old_names, names)
[16:05:33.648]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:33.648]                   envs[common]]
[16:05:33.648]                 NAMES <- toupper(changed)
[16:05:33.648]                 args <- list()
[16:05:33.648]                 for (kk in seq_along(NAMES)) {
[16:05:33.648]                   name <- changed[[kk]]
[16:05:33.648]                   NAME <- NAMES[[kk]]
[16:05:33.648]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.648]                     next
[16:05:33.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:33.648]                 }
[16:05:33.648]                 NAMES <- toupper(added)
[16:05:33.648]                 for (kk in seq_along(NAMES)) {
[16:05:33.648]                   name <- added[[kk]]
[16:05:33.648]                   NAME <- NAMES[[kk]]
[16:05:33.648]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.648]                     next
[16:05:33.648]                   args[[name]] <- ""
[16:05:33.648]                 }
[16:05:33.648]                 NAMES <- toupper(removed)
[16:05:33.648]                 for (kk in seq_along(NAMES)) {
[16:05:33.648]                   name <- removed[[kk]]
[16:05:33.648]                   NAME <- NAMES[[kk]]
[16:05:33.648]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.648]                     next
[16:05:33.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:33.648]                 }
[16:05:33.648]                 if (length(args) > 0) 
[16:05:33.648]                   base::do.call(base::Sys.setenv, args = args)
[16:05:33.648]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:33.648]             }
[16:05:33.648]             else {
[16:05:33.648]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:33.648]             }
[16:05:33.648]             {
[16:05:33.648]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:33.648]                   0L) {
[16:05:33.648]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:33.648]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:33.648]                   base::options(opts)
[16:05:33.648]                 }
[16:05:33.648]                 {
[16:05:33.648]                   {
[16:05:33.648]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:33.648]                     NULL
[16:05:33.648]                   }
[16:05:33.648]                   options(future.plan = NULL)
[16:05:33.648]                   if (is.na(NA_character_)) 
[16:05:33.648]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:33.648]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:33.648]                   future::plan(list(a = function (..., workers = availableCores(), 
[16:05:33.648]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:33.648]                     envir = parent.frame()) 
[16:05:33.648]                   {
[16:05:33.648]                     if (is.function(workers)) 
[16:05:33.648]                       workers <- workers()
[16:05:33.648]                     workers <- structure(as.integer(workers), 
[16:05:33.648]                       class = class(workers))
[16:05:33.648]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:33.648]                       workers >= 1)
[16:05:33.648]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:33.648]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:33.648]                     }
[16:05:33.648]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:33.648]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:33.648]                       envir = envir)
[16:05:33.648]                     if (!future$lazy) 
[16:05:33.648]                       future <- run(future)
[16:05:33.648]                     invisible(future)
[16:05:33.648]                   }, b = function (..., envir = parent.frame()) 
[16:05:33.648]                   {
[16:05:33.648]                     future <- SequentialFuture(..., envir = envir)
[16:05:33.648]                     if (!future$lazy) 
[16:05:33.648]                       future <- run(future)
[16:05:33.648]                     invisible(future)
[16:05:33.648]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:33.648]                 }
[16:05:33.648]             }
[16:05:33.648]         }
[16:05:33.648]     })
[16:05:33.648]     if (TRUE) {
[16:05:33.648]         base::sink(type = "output", split = FALSE)
[16:05:33.648]         if (TRUE) {
[16:05:33.648]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:33.648]         }
[16:05:33.648]         else {
[16:05:33.648]             ...future.result["stdout"] <- base::list(NULL)
[16:05:33.648]         }
[16:05:33.648]         base::close(...future.stdout)
[16:05:33.648]         ...future.stdout <- NULL
[16:05:33.648]     }
[16:05:33.648]     ...future.result$conditions <- ...future.conditions
[16:05:33.648]     ...future.result$finished <- base::Sys.time()
[16:05:33.648]     ...future.result
[16:05:33.648] }
[16:05:33.700] MultisessionFuture started
[16:05:33.700] result() for ClusterFuture ...
[16:05:33.701] receiveMessageFromWorker() for ClusterFuture ...
[16:05:33.701] - Validating connection of MultisessionFuture
[16:05:33.746] - received message: FutureResult
[16:05:33.746] - Received FutureResult
[16:05:33.746] - Erased future from FutureRegistry
[16:05:33.746] result() for ClusterFuture ...
[16:05:33.746] - result already collected: FutureResult
[16:05:33.746] result() for ClusterFuture ... done
[16:05:33.746] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:33.747] result() for ClusterFuture ... done
[16:05:33.747] result() for ClusterFuture ...
[16:05:33.747] - result already collected: FutureResult
[16:05:33.747] result() for ClusterFuture ... done
[16:05:33.747] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:05:33.751] plan(): nbrOfWorkers() = 2
[16:05:33.751] getGlobalsAndPackages() ...
[16:05:33.751] Searching for globals...
[16:05:33.772] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:05:33.772] Searching for globals ... DONE
[16:05:33.772] Resolving globals: FALSE
[16:05:33.773] The total size of the 2 globals is 55.46 KiB (56792 bytes)
[16:05:33.774] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 55.46 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (55.34 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:05:33.774] - globals: [2] ‘nested’, ‘strategy2’
[16:05:33.774] - packages: [1] ‘future’
[16:05:33.774] getGlobalsAndPackages() ... DONE
[16:05:33.774] run() for ‘Future’ ...
[16:05:33.774] - state: ‘created’
[16:05:33.774] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:33.788] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:33.788] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:33.788]   - Field: ‘node’
[16:05:33.788]   - Field: ‘label’
[16:05:33.788]   - Field: ‘local’
[16:05:33.789]   - Field: ‘owner’
[16:05:33.789]   - Field: ‘envir’
[16:05:33.789]   - Field: ‘workers’
[16:05:33.789]   - Field: ‘packages’
[16:05:33.789]   - Field: ‘gc’
[16:05:33.789]   - Field: ‘conditions’
[16:05:33.789]   - Field: ‘persistent’
[16:05:33.789]   - Field: ‘expr’
[16:05:33.789]   - Field: ‘uuid’
[16:05:33.789]   - Field: ‘seed’
[16:05:33.790]   - Field: ‘version’
[16:05:33.790]   - Field: ‘result’
[16:05:33.790]   - Field: ‘asynchronous’
[16:05:33.790]   - Field: ‘calls’
[16:05:33.790]   - Field: ‘globals’
[16:05:33.790]   - Field: ‘stdout’
[16:05:33.790]   - Field: ‘earlySignal’
[16:05:33.790]   - Field: ‘lazy’
[16:05:33.790]   - Field: ‘state’
[16:05:33.790] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:33.790] - Launch lazy future ...
[16:05:33.791] Packages needed by the future expression (n = 1): ‘future’
[16:05:33.791] Packages needed by future strategies (n = 1): ‘future’
[16:05:33.791] {
[16:05:33.791]     {
[16:05:33.791]         {
[16:05:33.791]             ...future.startTime <- base::Sys.time()
[16:05:33.791]             {
[16:05:33.791]                 {
[16:05:33.791]                   {
[16:05:33.791]                     {
[16:05:33.791]                       {
[16:05:33.791]                         base::local({
[16:05:33.791]                           has_future <- base::requireNamespace("future", 
[16:05:33.791]                             quietly = TRUE)
[16:05:33.791]                           if (has_future) {
[16:05:33.791]                             ns <- base::getNamespace("future")
[16:05:33.791]                             version <- ns[[".package"]][["version"]]
[16:05:33.791]                             if (is.null(version)) 
[16:05:33.791]                               version <- utils::packageVersion("future")
[16:05:33.791]                           }
[16:05:33.791]                           else {
[16:05:33.791]                             version <- NULL
[16:05:33.791]                           }
[16:05:33.791]                           if (!has_future || version < "1.8.0") {
[16:05:33.791]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:33.791]                               "", base::R.version$version.string), 
[16:05:33.791]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:33.791]                                 base::R.version$platform, 8 * 
[16:05:33.791]                                   base::.Machine$sizeof.pointer), 
[16:05:33.791]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:33.791]                                 "release", "version")], collapse = " "), 
[16:05:33.791]                               hostname = base::Sys.info()[["nodename"]])
[16:05:33.791]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:33.791]                               info)
[16:05:33.791]                             info <- base::paste(info, collapse = "; ")
[16:05:33.791]                             if (!has_future) {
[16:05:33.791]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:33.791]                                 info)
[16:05:33.791]                             }
[16:05:33.791]                             else {
[16:05:33.791]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:33.791]                                 info, version)
[16:05:33.791]                             }
[16:05:33.791]                             base::stop(msg)
[16:05:33.791]                           }
[16:05:33.791]                         })
[16:05:33.791]                       }
[16:05:33.791]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:33.791]                       base::options(mc.cores = 1L)
[16:05:33.791]                     }
[16:05:33.791]                     base::local({
[16:05:33.791]                       for (pkg in "future") {
[16:05:33.791]                         base::loadNamespace(pkg)
[16:05:33.791]                         base::library(pkg, character.only = TRUE)
[16:05:33.791]                       }
[16:05:33.791]                     })
[16:05:33.791]                   }
[16:05:33.791]                   options(future.plan = NULL)
[16:05:33.791]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:33.791]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:05:33.791]                   {
[16:05:33.791]                     future <- SequentialFuture(..., envir = envir)
[16:05:33.791]                     if (!future$lazy) 
[16:05:33.791]                       future <- run(future)
[16:05:33.791]                     invisible(future)
[16:05:33.791]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:33.791]                 }
[16:05:33.791]                 ...future.workdir <- getwd()
[16:05:33.791]             }
[16:05:33.791]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:33.791]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:33.791]         }
[16:05:33.791]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:33.791]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:33.791]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:33.791]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:33.791]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:33.791]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:33.791]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:33.791]             base::names(...future.oldOptions))
[16:05:33.791]     }
[16:05:33.791]     if (FALSE) {
[16:05:33.791]     }
[16:05:33.791]     else {
[16:05:33.791]         if (TRUE) {
[16:05:33.791]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:33.791]                 open = "w")
[16:05:33.791]         }
[16:05:33.791]         else {
[16:05:33.791]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:33.791]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:33.791]         }
[16:05:33.791]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:33.791]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:33.791]             base::sink(type = "output", split = FALSE)
[16:05:33.791]             base::close(...future.stdout)
[16:05:33.791]         }, add = TRUE)
[16:05:33.791]     }
[16:05:33.791]     ...future.frame <- base::sys.nframe()
[16:05:33.791]     ...future.conditions <- base::list()
[16:05:33.791]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:33.791]     if (FALSE) {
[16:05:33.791]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:33.791]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:33.791]     }
[16:05:33.791]     ...future.result <- base::tryCatch({
[16:05:33.791]         base::withCallingHandlers({
[16:05:33.791]             ...future.value <- base::withVisible(base::local({
[16:05:33.791]                 ...future.makeSendCondition <- base::local({
[16:05:33.791]                   sendCondition <- NULL
[16:05:33.791]                   function(frame = 1L) {
[16:05:33.791]                     if (is.function(sendCondition)) 
[16:05:33.791]                       return(sendCondition)
[16:05:33.791]                     ns <- getNamespace("parallel")
[16:05:33.791]                     if (exists("sendData", mode = "function", 
[16:05:33.791]                       envir = ns)) {
[16:05:33.791]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:33.791]                         envir = ns)
[16:05:33.791]                       envir <- sys.frame(frame)
[16:05:33.791]                       master <- NULL
[16:05:33.791]                       while (!identical(envir, .GlobalEnv) && 
[16:05:33.791]                         !identical(envir, emptyenv())) {
[16:05:33.791]                         if (exists("master", mode = "list", envir = envir, 
[16:05:33.791]                           inherits = FALSE)) {
[16:05:33.791]                           master <- get("master", mode = "list", 
[16:05:33.791]                             envir = envir, inherits = FALSE)
[16:05:33.791]                           if (inherits(master, c("SOCKnode", 
[16:05:33.791]                             "SOCK0node"))) {
[16:05:33.791]                             sendCondition <<- function(cond) {
[16:05:33.791]                               data <- list(type = "VALUE", value = cond, 
[16:05:33.791]                                 success = TRUE)
[16:05:33.791]                               parallel_sendData(master, data)
[16:05:33.791]                             }
[16:05:33.791]                             return(sendCondition)
[16:05:33.791]                           }
[16:05:33.791]                         }
[16:05:33.791]                         frame <- frame + 1L
[16:05:33.791]                         envir <- sys.frame(frame)
[16:05:33.791]                       }
[16:05:33.791]                     }
[16:05:33.791]                     sendCondition <<- function(cond) NULL
[16:05:33.791]                   }
[16:05:33.791]                 })
[16:05:33.791]                 withCallingHandlers({
[16:05:33.791]                   {
[16:05:33.791]                     a <- 1L
[16:05:33.791]                     plan_a <- unclass(future::plan("list"))
[16:05:33.791]                     nested_a <- nested[-1]
[16:05:33.791]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:05:33.791]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:05:33.791]                       strategy2))
[16:05:33.791]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:05:33.791]                       "init") <- NULL
[16:05:33.791]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:05:33.791]                       "init") <- NULL
[16:05:33.791]                     stopifnot(all.equal(plan_a, nested_a))
[16:05:33.791]                     y %<-% {
[16:05:33.791]                       b <- 2L
[16:05:33.791]                       plan_b <- future::plan("list")
[16:05:33.791]                       nested_b <- nested_a[-1]
[16:05:33.791]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:05:33.791]                         1L, inherits(plan_b[[1]], "future"), 
[16:05:33.791]                         inherits(future::plan("next"), "sequential"))
[16:05:33.791]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:05:33.791]                         b = b, nested_b = nested_b, plan_b = plan_b)
[16:05:33.791]                     }
[16:05:33.791]                     y
[16:05:33.791]                   }
[16:05:33.791]                 }, immediateCondition = function(cond) {
[16:05:33.791]                   sendCondition <- ...future.makeSendCondition()
[16:05:33.791]                   sendCondition(cond)
[16:05:33.791]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.791]                   {
[16:05:33.791]                     inherits <- base::inherits
[16:05:33.791]                     invokeRestart <- base::invokeRestart
[16:05:33.791]                     is.null <- base::is.null
[16:05:33.791]                     muffled <- FALSE
[16:05:33.791]                     if (inherits(cond, "message")) {
[16:05:33.791]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:33.791]                       if (muffled) 
[16:05:33.791]                         invokeRestart("muffleMessage")
[16:05:33.791]                     }
[16:05:33.791]                     else if (inherits(cond, "warning")) {
[16:05:33.791]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:33.791]                       if (muffled) 
[16:05:33.791]                         invokeRestart("muffleWarning")
[16:05:33.791]                     }
[16:05:33.791]                     else if (inherits(cond, "condition")) {
[16:05:33.791]                       if (!is.null(pattern)) {
[16:05:33.791]                         computeRestarts <- base::computeRestarts
[16:05:33.791]                         grepl <- base::grepl
[16:05:33.791]                         restarts <- computeRestarts(cond)
[16:05:33.791]                         for (restart in restarts) {
[16:05:33.791]                           name <- restart$name
[16:05:33.791]                           if (is.null(name)) 
[16:05:33.791]                             next
[16:05:33.791]                           if (!grepl(pattern, name)) 
[16:05:33.791]                             next
[16:05:33.791]                           invokeRestart(restart)
[16:05:33.791]                           muffled <- TRUE
[16:05:33.791]                           break
[16:05:33.791]                         }
[16:05:33.791]                       }
[16:05:33.791]                     }
[16:05:33.791]                     invisible(muffled)
[16:05:33.791]                   }
[16:05:33.791]                   muffleCondition(cond)
[16:05:33.791]                 })
[16:05:33.791]             }))
[16:05:33.791]             future::FutureResult(value = ...future.value$value, 
[16:05:33.791]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:33.791]                   ...future.rng), globalenv = if (FALSE) 
[16:05:33.791]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:33.791]                     ...future.globalenv.names))
[16:05:33.791]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:33.791]         }, condition = base::local({
[16:05:33.791]             c <- base::c
[16:05:33.791]             inherits <- base::inherits
[16:05:33.791]             invokeRestart <- base::invokeRestart
[16:05:33.791]             length <- base::length
[16:05:33.791]             list <- base::list
[16:05:33.791]             seq.int <- base::seq.int
[16:05:33.791]             signalCondition <- base::signalCondition
[16:05:33.791]             sys.calls <- base::sys.calls
[16:05:33.791]             `[[` <- base::`[[`
[16:05:33.791]             `+` <- base::`+`
[16:05:33.791]             `<<-` <- base::`<<-`
[16:05:33.791]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:33.791]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:33.791]                   3L)]
[16:05:33.791]             }
[16:05:33.791]             function(cond) {
[16:05:33.791]                 is_error <- inherits(cond, "error")
[16:05:33.791]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:33.791]                   NULL)
[16:05:33.791]                 if (is_error) {
[16:05:33.791]                   sessionInformation <- function() {
[16:05:33.791]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:33.791]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:33.791]                       search = base::search(), system = base::Sys.info())
[16:05:33.791]                   }
[16:05:33.791]                   ...future.conditions[[length(...future.conditions) + 
[16:05:33.791]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:33.791]                     cond$call), session = sessionInformation(), 
[16:05:33.791]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:33.791]                   signalCondition(cond)
[16:05:33.791]                 }
[16:05:33.791]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:33.791]                 "immediateCondition"))) {
[16:05:33.791]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:33.791]                   ...future.conditions[[length(...future.conditions) + 
[16:05:33.791]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:33.791]                   if (TRUE && !signal) {
[16:05:33.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.791]                     {
[16:05:33.791]                       inherits <- base::inherits
[16:05:33.791]                       invokeRestart <- base::invokeRestart
[16:05:33.791]                       is.null <- base::is.null
[16:05:33.791]                       muffled <- FALSE
[16:05:33.791]                       if (inherits(cond, "message")) {
[16:05:33.791]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:33.791]                         if (muffled) 
[16:05:33.791]                           invokeRestart("muffleMessage")
[16:05:33.791]                       }
[16:05:33.791]                       else if (inherits(cond, "warning")) {
[16:05:33.791]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:33.791]                         if (muffled) 
[16:05:33.791]                           invokeRestart("muffleWarning")
[16:05:33.791]                       }
[16:05:33.791]                       else if (inherits(cond, "condition")) {
[16:05:33.791]                         if (!is.null(pattern)) {
[16:05:33.791]                           computeRestarts <- base::computeRestarts
[16:05:33.791]                           grepl <- base::grepl
[16:05:33.791]                           restarts <- computeRestarts(cond)
[16:05:33.791]                           for (restart in restarts) {
[16:05:33.791]                             name <- restart$name
[16:05:33.791]                             if (is.null(name)) 
[16:05:33.791]                               next
[16:05:33.791]                             if (!grepl(pattern, name)) 
[16:05:33.791]                               next
[16:05:33.791]                             invokeRestart(restart)
[16:05:33.791]                             muffled <- TRUE
[16:05:33.791]                             break
[16:05:33.791]                           }
[16:05:33.791]                         }
[16:05:33.791]                       }
[16:05:33.791]                       invisible(muffled)
[16:05:33.791]                     }
[16:05:33.791]                     muffleCondition(cond, pattern = "^muffle")
[16:05:33.791]                   }
[16:05:33.791]                 }
[16:05:33.791]                 else {
[16:05:33.791]                   if (TRUE) {
[16:05:33.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.791]                     {
[16:05:33.791]                       inherits <- base::inherits
[16:05:33.791]                       invokeRestart <- base::invokeRestart
[16:05:33.791]                       is.null <- base::is.null
[16:05:33.791]                       muffled <- FALSE
[16:05:33.791]                       if (inherits(cond, "message")) {
[16:05:33.791]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:33.791]                         if (muffled) 
[16:05:33.791]                           invokeRestart("muffleMessage")
[16:05:33.791]                       }
[16:05:33.791]                       else if (inherits(cond, "warning")) {
[16:05:33.791]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:33.791]                         if (muffled) 
[16:05:33.791]                           invokeRestart("muffleWarning")
[16:05:33.791]                       }
[16:05:33.791]                       else if (inherits(cond, "condition")) {
[16:05:33.791]                         if (!is.null(pattern)) {
[16:05:33.791]                           computeRestarts <- base::computeRestarts
[16:05:33.791]                           grepl <- base::grepl
[16:05:33.791]                           restarts <- computeRestarts(cond)
[16:05:33.791]                           for (restart in restarts) {
[16:05:33.791]                             name <- restart$name
[16:05:33.791]                             if (is.null(name)) 
[16:05:33.791]                               next
[16:05:33.791]                             if (!grepl(pattern, name)) 
[16:05:33.791]                               next
[16:05:33.791]                             invokeRestart(restart)
[16:05:33.791]                             muffled <- TRUE
[16:05:33.791]                             break
[16:05:33.791]                           }
[16:05:33.791]                         }
[16:05:33.791]                       }
[16:05:33.791]                       invisible(muffled)
[16:05:33.791]                     }
[16:05:33.791]                     muffleCondition(cond, pattern = "^muffle")
[16:05:33.791]                   }
[16:05:33.791]                 }
[16:05:33.791]             }
[16:05:33.791]         }))
[16:05:33.791]     }, error = function(ex) {
[16:05:33.791]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:33.791]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:33.791]                 ...future.rng), started = ...future.startTime, 
[16:05:33.791]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:33.791]             version = "1.8"), class = "FutureResult")
[16:05:33.791]     }, finally = {
[16:05:33.791]         if (!identical(...future.workdir, getwd())) 
[16:05:33.791]             setwd(...future.workdir)
[16:05:33.791]         {
[16:05:33.791]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:33.791]                 ...future.oldOptions$nwarnings <- NULL
[16:05:33.791]             }
[16:05:33.791]             base::options(...future.oldOptions)
[16:05:33.791]             if (.Platform$OS.type == "windows") {
[16:05:33.791]                 old_names <- names(...future.oldEnvVars)
[16:05:33.791]                 envs <- base::Sys.getenv()
[16:05:33.791]                 names <- names(envs)
[16:05:33.791]                 common <- intersect(names, old_names)
[16:05:33.791]                 added <- setdiff(names, old_names)
[16:05:33.791]                 removed <- setdiff(old_names, names)
[16:05:33.791]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:33.791]                   envs[common]]
[16:05:33.791]                 NAMES <- toupper(changed)
[16:05:33.791]                 args <- list()
[16:05:33.791]                 for (kk in seq_along(NAMES)) {
[16:05:33.791]                   name <- changed[[kk]]
[16:05:33.791]                   NAME <- NAMES[[kk]]
[16:05:33.791]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.791]                     next
[16:05:33.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:33.791]                 }
[16:05:33.791]                 NAMES <- toupper(added)
[16:05:33.791]                 for (kk in seq_along(NAMES)) {
[16:05:33.791]                   name <- added[[kk]]
[16:05:33.791]                   NAME <- NAMES[[kk]]
[16:05:33.791]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.791]                     next
[16:05:33.791]                   args[[name]] <- ""
[16:05:33.791]                 }
[16:05:33.791]                 NAMES <- toupper(removed)
[16:05:33.791]                 for (kk in seq_along(NAMES)) {
[16:05:33.791]                   name <- removed[[kk]]
[16:05:33.791]                   NAME <- NAMES[[kk]]
[16:05:33.791]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.791]                     next
[16:05:33.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:33.791]                 }
[16:05:33.791]                 if (length(args) > 0) 
[16:05:33.791]                   base::do.call(base::Sys.setenv, args = args)
[16:05:33.791]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:33.791]             }
[16:05:33.791]             else {
[16:05:33.791]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:33.791]             }
[16:05:33.791]             {
[16:05:33.791]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:33.791]                   0L) {
[16:05:33.791]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:33.791]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:33.791]                   base::options(opts)
[16:05:33.791]                 }
[16:05:33.791]                 {
[16:05:33.791]                   {
[16:05:33.791]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:33.791]                     NULL
[16:05:33.791]                   }
[16:05:33.791]                   options(future.plan = NULL)
[16:05:33.791]                   if (is.na(NA_character_)) 
[16:05:33.791]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:33.791]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:33.791]                   future::plan(list(a = function (..., workers = availableCores(), 
[16:05:33.791]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:33.791]                     envir = parent.frame()) 
[16:05:33.791]                   {
[16:05:33.791]                     if (is.function(workers)) 
[16:05:33.791]                       workers <- workers()
[16:05:33.791]                     workers <- structure(as.integer(workers), 
[16:05:33.791]                       class = class(workers))
[16:05:33.791]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:33.791]                       workers >= 1)
[16:05:33.791]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:33.791]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:33.791]                     }
[16:05:33.791]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:33.791]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:33.791]                       envir = envir)
[16:05:33.791]                     if (!future$lazy) 
[16:05:33.791]                       future <- run(future)
[16:05:33.791]                     invisible(future)
[16:05:33.791]                   }, b = function (..., envir = parent.frame()) 
[16:05:33.791]                   {
[16:05:33.791]                     future <- SequentialFuture(..., envir = envir)
[16:05:33.791]                     if (!future$lazy) 
[16:05:33.791]                       future <- run(future)
[16:05:33.791]                     invisible(future)
[16:05:33.791]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:33.791]                 }
[16:05:33.791]             }
[16:05:33.791]         }
[16:05:33.791]     })
[16:05:33.791]     if (TRUE) {
[16:05:33.791]         base::sink(type = "output", split = FALSE)
[16:05:33.791]         if (TRUE) {
[16:05:33.791]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:33.791]         }
[16:05:33.791]         else {
[16:05:33.791]             ...future.result["stdout"] <- base::list(NULL)
[16:05:33.791]         }
[16:05:33.791]         base::close(...future.stdout)
[16:05:33.791]         ...future.stdout <- NULL
[16:05:33.791]     }
[16:05:33.791]     ...future.result$conditions <- ...future.conditions
[16:05:33.791]     ...future.result$finished <- base::Sys.time()
[16:05:33.791]     ...future.result
[16:05:33.791] }
[16:05:33.794] Exporting 2 global objects (55.46 KiB) to cluster node #1 ...
[16:05:33.795] Exporting ‘nested’ (55.34 KiB) to cluster node #1 ...
[16:05:33.835] Exporting ‘nested’ (55.34 KiB) to cluster node #1 ... DONE
[16:05:33.835] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[16:05:33.836] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[16:05:33.836] Exporting 2 global objects (55.46 KiB) to cluster node #1 ... DONE
[16:05:33.836] MultisessionFuture started
[16:05:33.836] - Launch lazy future ... done
[16:05:33.836] run() for ‘MultisessionFuture’ ... done
[16:05:33.837] result() for ClusterFuture ...
[16:05:33.837] receiveMessageFromWorker() for ClusterFuture ...
[16:05:33.837] - Validating connection of MultisessionFuture
[16:05:33.903] - received message: FutureResult
[16:05:33.903] - Received FutureResult
[16:05:33.903] - Erased future from FutureRegistry
[16:05:33.903] result() for ClusterFuture ...
[16:05:33.903] - result already collected: FutureResult
[16:05:33.903] result() for ClusterFuture ... done
[16:05:33.904] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:33.904] result() for ClusterFuture ... done
[16:05:33.904] result() for ClusterFuture ...
[16:05:33.904] - result already collected: FutureResult
[16:05:33.904] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:05:33.909] getGlobalsAndPackages() ...
[16:05:33.909] Searching for globals...
[16:05:33.911] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:05:33.911] Searching for globals ... DONE
[16:05:33.911] Resolving globals: FALSE
[16:05:33.911] The total size of the 1 globals is 128 bytes (128 bytes)
[16:05:33.912] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:05:33.912] - globals: [1] ‘data’
[16:05:33.912] - packages: [1] ‘future’
[16:05:33.912] getGlobalsAndPackages() ... DONE
[16:05:33.912] run() for ‘Future’ ...
[16:05:33.913] - state: ‘created’
[16:05:33.913] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:33.928] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:33.928] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:33.928]   - Field: ‘node’
[16:05:33.929]   - Field: ‘label’
[16:05:33.929]   - Field: ‘local’
[16:05:33.929]   - Field: ‘owner’
[16:05:33.929]   - Field: ‘envir’
[16:05:33.929]   - Field: ‘workers’
[16:05:33.929]   - Field: ‘packages’
[16:05:33.929]   - Field: ‘gc’
[16:05:33.929]   - Field: ‘conditions’
[16:05:33.929]   - Field: ‘persistent’
[16:05:33.929]   - Field: ‘expr’
[16:05:33.930]   - Field: ‘uuid’
[16:05:33.930]   - Field: ‘seed’
[16:05:33.930]   - Field: ‘version’
[16:05:33.930]   - Field: ‘result’
[16:05:33.930]   - Field: ‘asynchronous’
[16:05:33.930]   - Field: ‘calls’
[16:05:33.930]   - Field: ‘globals’
[16:05:33.930]   - Field: ‘stdout’
[16:05:33.930]   - Field: ‘earlySignal’
[16:05:33.930]   - Field: ‘lazy’
[16:05:33.930]   - Field: ‘state’
[16:05:33.931] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:33.931] - Launch lazy future ...
[16:05:33.931] Packages needed by the future expression (n = 1): ‘future’
[16:05:33.931] Packages needed by future strategies (n = 1): ‘future’
[16:05:33.932] {
[16:05:33.932]     {
[16:05:33.932]         {
[16:05:33.932]             ...future.startTime <- base::Sys.time()
[16:05:33.932]             {
[16:05:33.932]                 {
[16:05:33.932]                   {
[16:05:33.932]                     {
[16:05:33.932]                       {
[16:05:33.932]                         base::local({
[16:05:33.932]                           has_future <- base::requireNamespace("future", 
[16:05:33.932]                             quietly = TRUE)
[16:05:33.932]                           if (has_future) {
[16:05:33.932]                             ns <- base::getNamespace("future")
[16:05:33.932]                             version <- ns[[".package"]][["version"]]
[16:05:33.932]                             if (is.null(version)) 
[16:05:33.932]                               version <- utils::packageVersion("future")
[16:05:33.932]                           }
[16:05:33.932]                           else {
[16:05:33.932]                             version <- NULL
[16:05:33.932]                           }
[16:05:33.932]                           if (!has_future || version < "1.8.0") {
[16:05:33.932]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:33.932]                               "", base::R.version$version.string), 
[16:05:33.932]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:33.932]                                 base::R.version$platform, 8 * 
[16:05:33.932]                                   base::.Machine$sizeof.pointer), 
[16:05:33.932]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:33.932]                                 "release", "version")], collapse = " "), 
[16:05:33.932]                               hostname = base::Sys.info()[["nodename"]])
[16:05:33.932]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:33.932]                               info)
[16:05:33.932]                             info <- base::paste(info, collapse = "; ")
[16:05:33.932]                             if (!has_future) {
[16:05:33.932]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:33.932]                                 info)
[16:05:33.932]                             }
[16:05:33.932]                             else {
[16:05:33.932]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:33.932]                                 info, version)
[16:05:33.932]                             }
[16:05:33.932]                             base::stop(msg)
[16:05:33.932]                           }
[16:05:33.932]                         })
[16:05:33.932]                       }
[16:05:33.932]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:33.932]                       base::options(mc.cores = 1L)
[16:05:33.932]                     }
[16:05:33.932]                     base::local({
[16:05:33.932]                       for (pkg in "future") {
[16:05:33.932]                         base::loadNamespace(pkg)
[16:05:33.932]                         base::library(pkg, character.only = TRUE)
[16:05:33.932]                       }
[16:05:33.932]                     })
[16:05:33.932]                   }
[16:05:33.932]                   options(future.plan = NULL)
[16:05:33.932]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:33.932]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:05:33.932]                   {
[16:05:33.932]                     future <- SequentialFuture(..., envir = envir)
[16:05:33.932]                     if (!future$lazy) 
[16:05:33.932]                       future <- run(future)
[16:05:33.932]                     invisible(future)
[16:05:33.932]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:33.932]                 }
[16:05:33.932]                 ...future.workdir <- getwd()
[16:05:33.932]             }
[16:05:33.932]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:33.932]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:33.932]         }
[16:05:33.932]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:33.932]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:33.932]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:33.932]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:33.932]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:33.932]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:33.932]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:33.932]             base::names(...future.oldOptions))
[16:05:33.932]     }
[16:05:33.932]     if (FALSE) {
[16:05:33.932]     }
[16:05:33.932]     else {
[16:05:33.932]         if (TRUE) {
[16:05:33.932]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:33.932]                 open = "w")
[16:05:33.932]         }
[16:05:33.932]         else {
[16:05:33.932]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:33.932]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:33.932]         }
[16:05:33.932]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:33.932]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:33.932]             base::sink(type = "output", split = FALSE)
[16:05:33.932]             base::close(...future.stdout)
[16:05:33.932]         }, add = TRUE)
[16:05:33.932]     }
[16:05:33.932]     ...future.frame <- base::sys.nframe()
[16:05:33.932]     ...future.conditions <- base::list()
[16:05:33.932]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:33.932]     if (FALSE) {
[16:05:33.932]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:33.932]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:33.932]     }
[16:05:33.932]     ...future.result <- base::tryCatch({
[16:05:33.932]         base::withCallingHandlers({
[16:05:33.932]             ...future.value <- base::withVisible(base::local({
[16:05:33.932]                 ...future.makeSendCondition <- base::local({
[16:05:33.932]                   sendCondition <- NULL
[16:05:33.932]                   function(frame = 1L) {
[16:05:33.932]                     if (is.function(sendCondition)) 
[16:05:33.932]                       return(sendCondition)
[16:05:33.932]                     ns <- getNamespace("parallel")
[16:05:33.932]                     if (exists("sendData", mode = "function", 
[16:05:33.932]                       envir = ns)) {
[16:05:33.932]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:33.932]                         envir = ns)
[16:05:33.932]                       envir <- sys.frame(frame)
[16:05:33.932]                       master <- NULL
[16:05:33.932]                       while (!identical(envir, .GlobalEnv) && 
[16:05:33.932]                         !identical(envir, emptyenv())) {
[16:05:33.932]                         if (exists("master", mode = "list", envir = envir, 
[16:05:33.932]                           inherits = FALSE)) {
[16:05:33.932]                           master <- get("master", mode = "list", 
[16:05:33.932]                             envir = envir, inherits = FALSE)
[16:05:33.932]                           if (inherits(master, c("SOCKnode", 
[16:05:33.932]                             "SOCK0node"))) {
[16:05:33.932]                             sendCondition <<- function(cond) {
[16:05:33.932]                               data <- list(type = "VALUE", value = cond, 
[16:05:33.932]                                 success = TRUE)
[16:05:33.932]                               parallel_sendData(master, data)
[16:05:33.932]                             }
[16:05:33.932]                             return(sendCondition)
[16:05:33.932]                           }
[16:05:33.932]                         }
[16:05:33.932]                         frame <- frame + 1L
[16:05:33.932]                         envir <- sys.frame(frame)
[16:05:33.932]                       }
[16:05:33.932]                     }
[16:05:33.932]                     sendCondition <<- function(cond) NULL
[16:05:33.932]                   }
[16:05:33.932]                 })
[16:05:33.932]                 withCallingHandlers({
[16:05:33.932]                   {
[16:05:33.932]                     value(future(subset(data, a == 2)))
[16:05:33.932]                   }
[16:05:33.932]                 }, immediateCondition = function(cond) {
[16:05:33.932]                   sendCondition <- ...future.makeSendCondition()
[16:05:33.932]                   sendCondition(cond)
[16:05:33.932]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.932]                   {
[16:05:33.932]                     inherits <- base::inherits
[16:05:33.932]                     invokeRestart <- base::invokeRestart
[16:05:33.932]                     is.null <- base::is.null
[16:05:33.932]                     muffled <- FALSE
[16:05:33.932]                     if (inherits(cond, "message")) {
[16:05:33.932]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:33.932]                       if (muffled) 
[16:05:33.932]                         invokeRestart("muffleMessage")
[16:05:33.932]                     }
[16:05:33.932]                     else if (inherits(cond, "warning")) {
[16:05:33.932]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:33.932]                       if (muffled) 
[16:05:33.932]                         invokeRestart("muffleWarning")
[16:05:33.932]                     }
[16:05:33.932]                     else if (inherits(cond, "condition")) {
[16:05:33.932]                       if (!is.null(pattern)) {
[16:05:33.932]                         computeRestarts <- base::computeRestarts
[16:05:33.932]                         grepl <- base::grepl
[16:05:33.932]                         restarts <- computeRestarts(cond)
[16:05:33.932]                         for (restart in restarts) {
[16:05:33.932]                           name <- restart$name
[16:05:33.932]                           if (is.null(name)) 
[16:05:33.932]                             next
[16:05:33.932]                           if (!grepl(pattern, name)) 
[16:05:33.932]                             next
[16:05:33.932]                           invokeRestart(restart)
[16:05:33.932]                           muffled <- TRUE
[16:05:33.932]                           break
[16:05:33.932]                         }
[16:05:33.932]                       }
[16:05:33.932]                     }
[16:05:33.932]                     invisible(muffled)
[16:05:33.932]                   }
[16:05:33.932]                   muffleCondition(cond)
[16:05:33.932]                 })
[16:05:33.932]             }))
[16:05:33.932]             future::FutureResult(value = ...future.value$value, 
[16:05:33.932]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:33.932]                   ...future.rng), globalenv = if (FALSE) 
[16:05:33.932]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:33.932]                     ...future.globalenv.names))
[16:05:33.932]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:33.932]         }, condition = base::local({
[16:05:33.932]             c <- base::c
[16:05:33.932]             inherits <- base::inherits
[16:05:33.932]             invokeRestart <- base::invokeRestart
[16:05:33.932]             length <- base::length
[16:05:33.932]             list <- base::list
[16:05:33.932]             seq.int <- base::seq.int
[16:05:33.932]             signalCondition <- base::signalCondition
[16:05:33.932]             sys.calls <- base::sys.calls
[16:05:33.932]             `[[` <- base::`[[`
[16:05:33.932]             `+` <- base::`+`
[16:05:33.932]             `<<-` <- base::`<<-`
[16:05:33.932]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:33.932]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:33.932]                   3L)]
[16:05:33.932]             }
[16:05:33.932]             function(cond) {
[16:05:33.932]                 is_error <- inherits(cond, "error")
[16:05:33.932]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:33.932]                   NULL)
[16:05:33.932]                 if (is_error) {
[16:05:33.932]                   sessionInformation <- function() {
[16:05:33.932]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:33.932]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:33.932]                       search = base::search(), system = base::Sys.info())
[16:05:33.932]                   }
[16:05:33.932]                   ...future.conditions[[length(...future.conditions) + 
[16:05:33.932]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:33.932]                     cond$call), session = sessionInformation(), 
[16:05:33.932]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:33.932]                   signalCondition(cond)
[16:05:33.932]                 }
[16:05:33.932]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:33.932]                 "immediateCondition"))) {
[16:05:33.932]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:33.932]                   ...future.conditions[[length(...future.conditions) + 
[16:05:33.932]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:33.932]                   if (TRUE && !signal) {
[16:05:33.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.932]                     {
[16:05:33.932]                       inherits <- base::inherits
[16:05:33.932]                       invokeRestart <- base::invokeRestart
[16:05:33.932]                       is.null <- base::is.null
[16:05:33.932]                       muffled <- FALSE
[16:05:33.932]                       if (inherits(cond, "message")) {
[16:05:33.932]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:33.932]                         if (muffled) 
[16:05:33.932]                           invokeRestart("muffleMessage")
[16:05:33.932]                       }
[16:05:33.932]                       else if (inherits(cond, "warning")) {
[16:05:33.932]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:33.932]                         if (muffled) 
[16:05:33.932]                           invokeRestart("muffleWarning")
[16:05:33.932]                       }
[16:05:33.932]                       else if (inherits(cond, "condition")) {
[16:05:33.932]                         if (!is.null(pattern)) {
[16:05:33.932]                           computeRestarts <- base::computeRestarts
[16:05:33.932]                           grepl <- base::grepl
[16:05:33.932]                           restarts <- computeRestarts(cond)
[16:05:33.932]                           for (restart in restarts) {
[16:05:33.932]                             name <- restart$name
[16:05:33.932]                             if (is.null(name)) 
[16:05:33.932]                               next
[16:05:33.932]                             if (!grepl(pattern, name)) 
[16:05:33.932]                               next
[16:05:33.932]                             invokeRestart(restart)
[16:05:33.932]                             muffled <- TRUE
[16:05:33.932]                             break
[16:05:33.932]                           }
[16:05:33.932]                         }
[16:05:33.932]                       }
[16:05:33.932]                       invisible(muffled)
[16:05:33.932]                     }
[16:05:33.932]                     muffleCondition(cond, pattern = "^muffle")
[16:05:33.932]                   }
[16:05:33.932]                 }
[16:05:33.932]                 else {
[16:05:33.932]                   if (TRUE) {
[16:05:33.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:33.932]                     {
[16:05:33.932]                       inherits <- base::inherits
[16:05:33.932]                       invokeRestart <- base::invokeRestart
[16:05:33.932]                       is.null <- base::is.null
[16:05:33.932]                       muffled <- FALSE
[16:05:33.932]                       if (inherits(cond, "message")) {
[16:05:33.932]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:33.932]                         if (muffled) 
[16:05:33.932]                           invokeRestart("muffleMessage")
[16:05:33.932]                       }
[16:05:33.932]                       else if (inherits(cond, "warning")) {
[16:05:33.932]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:33.932]                         if (muffled) 
[16:05:33.932]                           invokeRestart("muffleWarning")
[16:05:33.932]                       }
[16:05:33.932]                       else if (inherits(cond, "condition")) {
[16:05:33.932]                         if (!is.null(pattern)) {
[16:05:33.932]                           computeRestarts <- base::computeRestarts
[16:05:33.932]                           grepl <- base::grepl
[16:05:33.932]                           restarts <- computeRestarts(cond)
[16:05:33.932]                           for (restart in restarts) {
[16:05:33.932]                             name <- restart$name
[16:05:33.932]                             if (is.null(name)) 
[16:05:33.932]                               next
[16:05:33.932]                             if (!grepl(pattern, name)) 
[16:05:33.932]                               next
[16:05:33.932]                             invokeRestart(restart)
[16:05:33.932]                             muffled <- TRUE
[16:05:33.932]                             break
[16:05:33.932]                           }
[16:05:33.932]                         }
[16:05:33.932]                       }
[16:05:33.932]                       invisible(muffled)
[16:05:33.932]                     }
[16:05:33.932]                     muffleCondition(cond, pattern = "^muffle")
[16:05:33.932]                   }
[16:05:33.932]                 }
[16:05:33.932]             }
[16:05:33.932]         }))
[16:05:33.932]     }, error = function(ex) {
[16:05:33.932]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:33.932]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:33.932]                 ...future.rng), started = ...future.startTime, 
[16:05:33.932]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:33.932]             version = "1.8"), class = "FutureResult")
[16:05:33.932]     }, finally = {
[16:05:33.932]         if (!identical(...future.workdir, getwd())) 
[16:05:33.932]             setwd(...future.workdir)
[16:05:33.932]         {
[16:05:33.932]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:33.932]                 ...future.oldOptions$nwarnings <- NULL
[16:05:33.932]             }
[16:05:33.932]             base::options(...future.oldOptions)
[16:05:33.932]             if (.Platform$OS.type == "windows") {
[16:05:33.932]                 old_names <- names(...future.oldEnvVars)
[16:05:33.932]                 envs <- base::Sys.getenv()
[16:05:33.932]                 names <- names(envs)
[16:05:33.932]                 common <- intersect(names, old_names)
[16:05:33.932]                 added <- setdiff(names, old_names)
[16:05:33.932]                 removed <- setdiff(old_names, names)
[16:05:33.932]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:33.932]                   envs[common]]
[16:05:33.932]                 NAMES <- toupper(changed)
[16:05:33.932]                 args <- list()
[16:05:33.932]                 for (kk in seq_along(NAMES)) {
[16:05:33.932]                   name <- changed[[kk]]
[16:05:33.932]                   NAME <- NAMES[[kk]]
[16:05:33.932]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.932]                     next
[16:05:33.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:33.932]                 }
[16:05:33.932]                 NAMES <- toupper(added)
[16:05:33.932]                 for (kk in seq_along(NAMES)) {
[16:05:33.932]                   name <- added[[kk]]
[16:05:33.932]                   NAME <- NAMES[[kk]]
[16:05:33.932]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.932]                     next
[16:05:33.932]                   args[[name]] <- ""
[16:05:33.932]                 }
[16:05:33.932]                 NAMES <- toupper(removed)
[16:05:33.932]                 for (kk in seq_along(NAMES)) {
[16:05:33.932]                   name <- removed[[kk]]
[16:05:33.932]                   NAME <- NAMES[[kk]]
[16:05:33.932]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:33.932]                     next
[16:05:33.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:33.932]                 }
[16:05:33.932]                 if (length(args) > 0) 
[16:05:33.932]                   base::do.call(base::Sys.setenv, args = args)
[16:05:33.932]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:33.932]             }
[16:05:33.932]             else {
[16:05:33.932]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:33.932]             }
[16:05:33.932]             {
[16:05:33.932]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:33.932]                   0L) {
[16:05:33.932]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:33.932]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:33.932]                   base::options(opts)
[16:05:33.932]                 }
[16:05:33.932]                 {
[16:05:33.932]                   {
[16:05:33.932]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:33.932]                     NULL
[16:05:33.932]                   }
[16:05:33.932]                   options(future.plan = NULL)
[16:05:33.932]                   if (is.na(NA_character_)) 
[16:05:33.932]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:33.932]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:33.932]                   future::plan(list(a = function (..., workers = availableCores(), 
[16:05:33.932]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:33.932]                     envir = parent.frame()) 
[16:05:33.932]                   {
[16:05:33.932]                     if (is.function(workers)) 
[16:05:33.932]                       workers <- workers()
[16:05:33.932]                     workers <- structure(as.integer(workers), 
[16:05:33.932]                       class = class(workers))
[16:05:33.932]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:33.932]                       workers >= 1)
[16:05:33.932]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:33.932]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:33.932]                     }
[16:05:33.932]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:33.932]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:33.932]                       envir = envir)
[16:05:33.932]                     if (!future$lazy) 
[16:05:33.932]                       future <- run(future)
[16:05:33.932]                     invisible(future)
[16:05:33.932]                   }, b = function (..., envir = parent.frame()) 
[16:05:33.932]                   {
[16:05:33.932]                     future <- SequentialFuture(..., envir = envir)
[16:05:33.932]                     if (!future$lazy) 
[16:05:33.932]                       future <- run(future)
[16:05:33.932]                     invisible(future)
[16:05:33.932]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:33.932]                 }
[16:05:33.932]             }
[16:05:33.932]         }
[16:05:33.932]     })
[16:05:33.932]     if (TRUE) {
[16:05:33.932]         base::sink(type = "output", split = FALSE)
[16:05:33.932]         if (TRUE) {
[16:05:33.932]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:33.932]         }
[16:05:33.932]         else {
[16:05:33.932]             ...future.result["stdout"] <- base::list(NULL)
[16:05:33.932]         }
[16:05:33.932]         base::close(...future.stdout)
[16:05:33.932]         ...future.stdout <- NULL
[16:05:33.932]     }
[16:05:33.932]     ...future.result$conditions <- ...future.conditions
[16:05:33.932]     ...future.result$finished <- base::Sys.time()
[16:05:33.932]     ...future.result
[16:05:33.932] }
[16:05:33.934] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[16:05:33.935] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[16:05:33.935] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[16:05:33.935] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[16:05:33.936] MultisessionFuture started
[16:05:33.936] - Launch lazy future ... done
[16:05:33.936] run() for ‘MultisessionFuture’ ... done
[16:05:33.936] result() for ClusterFuture ...
[16:05:33.936] receiveMessageFromWorker() for ClusterFuture ...
[16:05:33.937] - Validating connection of MultisessionFuture
[16:05:33.987] - received message: FutureResult
[16:05:33.987] - Received FutureResult
[16:05:33.987] - Erased future from FutureRegistry
[16:05:33.987] result() for ClusterFuture ...
[16:05:33.987] - result already collected: FutureResult
[16:05:33.987] result() for ClusterFuture ... done
[16:05:33.987] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:33.988] result() for ClusterFuture ... done
[16:05:33.988] result() for ClusterFuture ...
[16:05:33.988] - result already collected: FutureResult
[16:05:33.988] result() for ClusterFuture ... done
- plan(list('multisession', 'sequential')) ... DONE
- plan(list('multisession', 'multicore')) ...
[16:05:33.988] plan(): Setting new future strategy stack:
[16:05:33.988] List of future strategies:
[16:05:33.988] 1. multisession:
[16:05:33.988]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:33.988]    - tweaked: FALSE
[16:05:33.988]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.988] 2. multicore:
[16:05:33.988]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:33.988]    - tweaked: FALSE
[16:05:33.988]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.989] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:05:33.989] multisession:
[16:05:33.989] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:33.989] - tweaked: FALSE
[16:05:33.989] - call: plan(list(a = strategy1, b = strategy2))
[16:05:33.994] getGlobalsAndPackages() ...
[16:05:33.994] Not searching for globals
[16:05:33.994] - globals: [0] <none>
[16:05:33.994] getGlobalsAndPackages() ... DONE
[16:05:33.994] [local output] makeClusterPSOCK() ...
[16:05:33.999] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:05:34.000] [local output] Base port: 11097
[16:05:34.000] [local output] Getting setup options for 2 cluster nodes ...
[16:05:34.000] [local output]  - Node 1 of 2 ...
[16:05:34.001] [local output] localMachine=TRUE => revtunnel=FALSE

[16:05:34.002] [local output] Rscript port: 11097

[16:05:34.002] [local output]  - Node 2 of 2 ...
[16:05:34.003] [local output] localMachine=TRUE => revtunnel=FALSE

[16:05:34.004] [local output] Rscript port: 11097

[16:05:34.004] [local output] Getting setup options for 2 cluster nodes ... done
[16:05:34.004] [local output]  - Parallel setup requested for some PSOCK nodes
[16:05:34.005] [local output] Setting up PSOCK nodes in parallel
[16:05:34.005] List of 36
[16:05:34.005]  $ worker          : chr "localhost"
[16:05:34.005]   ..- attr(*, "localhost")= logi TRUE
[16:05:34.005]  $ master          : chr "localhost"
[16:05:34.005]  $ port            : int 11097
[16:05:34.005]  $ connectTimeout  : num 120
[16:05:34.005]  $ timeout         : num 2592000
[16:05:34.005]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:05:34.005]  $ homogeneous     : logi TRUE
[16:05:34.005]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:05:34.005]  $ rscript_envs    : NULL
[16:05:34.005]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:05:34.005]  $ rscript_startup : NULL
[16:05:34.005]  $ rscript_sh      : chr "sh"
[16:05:34.005]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:05:34.005]  $ methods         : logi TRUE
[16:05:34.005]  $ socketOptions   : chr "no-delay"
[16:05:34.005]  $ useXDR          : logi FALSE
[16:05:34.005]  $ outfile         : chr "/dev/null"
[16:05:34.005]  $ renice          : int NA
[16:05:34.005]  $ rshcmd          : NULL
[16:05:34.005]  $ user            : chr(0) 
[16:05:34.005]  $ revtunnel       : logi FALSE
[16:05:34.005]  $ rshlogfile      : NULL
[16:05:34.005]  $ rshopts         : chr(0) 
[16:05:34.005]  $ rank            : int 1
[16:05:34.005]  $ manual          : logi FALSE
[16:05:34.005]  $ dryrun          : logi FALSE
[16:05:34.005]  $ quiet           : logi FALSE
[16:05:34.005]  $ setup_strategy  : chr "parallel"
[16:05:34.005]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:05:34.005]  $ pidfile         : chr "/tmp/Rtmp0EbAi0/worker.rank=1.parallelly.parent=88964.15b845cc20ff9.pid"
[16:05:34.005]  $ rshcmd_label    : NULL
[16:05:34.005]  $ rsh_call        : NULL
[16:05:34.005]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:05:34.005]  $ localMachine    : logi TRUE
[16:05:34.005]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:05:34.005]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:05:34.005]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:05:34.005]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:05:34.005]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:05:34.005]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:05:34.005]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:05:34.005]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:05:34.005]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:05:34.005]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:05:34.005]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:05:34.005]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:05:34.005]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:05:34.005]  $ arguments       :List of 28
[16:05:34.005]   ..$ worker          : chr "localhost"
[16:05:34.005]   ..$ master          : NULL
[16:05:34.005]   ..$ port            : int 11097
[16:05:34.005]   ..$ connectTimeout  : num 120
[16:05:34.005]   ..$ timeout         : num 2592000
[16:05:34.005]   ..$ rscript         : NULL
[16:05:34.005]   ..$ homogeneous     : NULL
[16:05:34.005]   ..$ rscript_args    : NULL
[16:05:34.005]   ..$ rscript_envs    : NULL
[16:05:34.005]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:05:34.005]   ..$ rscript_startup : NULL
[16:05:34.005]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:05:34.005]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:05:34.005]   ..$ methods         : logi TRUE
[16:05:34.005]   ..$ socketOptions   : chr "no-delay"
[16:05:34.005]   ..$ useXDR          : logi FALSE
[16:05:34.005]   ..$ outfile         : chr "/dev/null"
[16:05:34.005]   ..$ renice          : int NA
[16:05:34.005]   ..$ rshcmd          : NULL
[16:05:34.005]   ..$ user            : NULL
[16:05:34.005]   ..$ revtunnel       : logi NA
[16:05:34.005]   ..$ rshlogfile      : NULL
[16:05:34.005]   ..$ rshopts         : NULL
[16:05:34.005]   ..$ rank            : int 1
[16:05:34.005]   ..$ manual          : logi FALSE
[16:05:34.005]   ..$ dryrun          : logi FALSE
[16:05:34.005]   ..$ quiet           : logi FALSE
[16:05:34.005]   ..$ setup_strategy  : chr "parallel"
[16:05:34.005]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:05:34.023] [local output] System call to launch all workers:
[16:05:34.023] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp0EbAi0/worker.rank=1.parallelly.parent=88964.15b845cc20ff9.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11097 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:05:34.023] [local output] Starting PSOCK main server
[16:05:34.024] [local output] Workers launched
[16:05:34.024] [local output] Waiting for workers to connect back
[16:05:34.024]  - [local output] 0 workers out of 2 ready
[16:05:34.268]  - [local output] 0 workers out of 2 ready
[16:05:34.268]  - [local output] 1 workers out of 2 ready
[16:05:34.271]  - [local output] 1 workers out of 2 ready
[16:05:34.272]  - [local output] 2 workers out of 2 ready
[16:05:34.272] [local output] Launching of workers completed
[16:05:34.272] [local output] Collecting session information from workers
[16:05:34.273] [local output]  - Worker #1 of 2
[16:05:34.273] [local output]  - Worker #2 of 2
[16:05:34.273] [local output] makeClusterPSOCK() ... done
[16:05:34.284] Packages needed by the future expression (n = 0): <none>
[16:05:34.284] Packages needed by future strategies (n = 1): ‘future’
[16:05:34.285] {
[16:05:34.285]     {
[16:05:34.285]         {
[16:05:34.285]             ...future.startTime <- base::Sys.time()
[16:05:34.285]             {
[16:05:34.285]                 {
[16:05:34.285]                   {
[16:05:34.285]                     {
[16:05:34.285]                       {
[16:05:34.285]                         base::local({
[16:05:34.285]                           has_future <- base::requireNamespace("future", 
[16:05:34.285]                             quietly = TRUE)
[16:05:34.285]                           if (has_future) {
[16:05:34.285]                             ns <- base::getNamespace("future")
[16:05:34.285]                             version <- ns[[".package"]][["version"]]
[16:05:34.285]                             if (is.null(version)) 
[16:05:34.285]                               version <- utils::packageVersion("future")
[16:05:34.285]                           }
[16:05:34.285]                           else {
[16:05:34.285]                             version <- NULL
[16:05:34.285]                           }
[16:05:34.285]                           if (!has_future || version < "1.8.0") {
[16:05:34.285]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:34.285]                               "", base::R.version$version.string), 
[16:05:34.285]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:34.285]                                 base::R.version$platform, 8 * 
[16:05:34.285]                                   base::.Machine$sizeof.pointer), 
[16:05:34.285]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:34.285]                                 "release", "version")], collapse = " "), 
[16:05:34.285]                               hostname = base::Sys.info()[["nodename"]])
[16:05:34.285]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:34.285]                               info)
[16:05:34.285]                             info <- base::paste(info, collapse = "; ")
[16:05:34.285]                             if (!has_future) {
[16:05:34.285]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:34.285]                                 info)
[16:05:34.285]                             }
[16:05:34.285]                             else {
[16:05:34.285]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:34.285]                                 info, version)
[16:05:34.285]                             }
[16:05:34.285]                             base::stop(msg)
[16:05:34.285]                           }
[16:05:34.285]                         })
[16:05:34.285]                       }
[16:05:34.285]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:34.285]                       base::options(mc.cores = 1L)
[16:05:34.285]                     }
[16:05:34.285]                     base::local({
[16:05:34.285]                       for (pkg in "future") {
[16:05:34.285]                         base::loadNamespace(pkg)
[16:05:34.285]                         base::library(pkg, character.only = TRUE)
[16:05:34.285]                       }
[16:05:34.285]                     })
[16:05:34.285]                   }
[16:05:34.285]                   options(future.plan = NULL)
[16:05:34.285]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:34.285]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:34.285]                     envir = parent.frame()) 
[16:05:34.285]                   {
[16:05:34.285]                     default_workers <- missing(workers)
[16:05:34.285]                     if (is.function(workers)) 
[16:05:34.285]                       workers <- workers()
[16:05:34.285]                     workers <- structure(as.integer(workers), 
[16:05:34.285]                       class = class(workers))
[16:05:34.285]                     stop_if_not(is.finite(workers), workers >= 
[16:05:34.285]                       1L)
[16:05:34.285]                     if ((workers == 1L && !inherits(workers, 
[16:05:34.285]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:34.285]                       if (default_workers) 
[16:05:34.285]                         supportsMulticore(warn = TRUE)
[16:05:34.285]                       return(sequential(..., envir = envir))
[16:05:34.285]                     }
[16:05:34.285]                     oopts <- options(mc.cores = workers)
[16:05:34.285]                     on.exit(options(oopts))
[16:05:34.285]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:34.285]                       envir = envir)
[16:05:34.285]                     if (!future$lazy) 
[16:05:34.285]                       future <- run(future)
[16:05:34.285]                     invisible(future)
[16:05:34.285]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:34.285]                 }
[16:05:34.285]                 ...future.workdir <- getwd()
[16:05:34.285]             }
[16:05:34.285]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:34.285]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:34.285]         }
[16:05:34.285]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:34.285]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:34.285]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:34.285]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:34.285]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:34.285]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:34.285]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:34.285]             base::names(...future.oldOptions))
[16:05:34.285]     }
[16:05:34.285]     if (FALSE) {
[16:05:34.285]     }
[16:05:34.285]     else {
[16:05:34.285]         if (TRUE) {
[16:05:34.285]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:34.285]                 open = "w")
[16:05:34.285]         }
[16:05:34.285]         else {
[16:05:34.285]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:34.285]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:34.285]         }
[16:05:34.285]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:34.285]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:34.285]             base::sink(type = "output", split = FALSE)
[16:05:34.285]             base::close(...future.stdout)
[16:05:34.285]         }, add = TRUE)
[16:05:34.285]     }
[16:05:34.285]     ...future.frame <- base::sys.nframe()
[16:05:34.285]     ...future.conditions <- base::list()
[16:05:34.285]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:34.285]     if (FALSE) {
[16:05:34.285]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:34.285]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:34.285]     }
[16:05:34.285]     ...future.result <- base::tryCatch({
[16:05:34.285]         base::withCallingHandlers({
[16:05:34.285]             ...future.value <- base::withVisible(base::local({
[16:05:34.285]                 ...future.makeSendCondition <- base::local({
[16:05:34.285]                   sendCondition <- NULL
[16:05:34.285]                   function(frame = 1L) {
[16:05:34.285]                     if (is.function(sendCondition)) 
[16:05:34.285]                       return(sendCondition)
[16:05:34.285]                     ns <- getNamespace("parallel")
[16:05:34.285]                     if (exists("sendData", mode = "function", 
[16:05:34.285]                       envir = ns)) {
[16:05:34.285]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:34.285]                         envir = ns)
[16:05:34.285]                       envir <- sys.frame(frame)
[16:05:34.285]                       master <- NULL
[16:05:34.285]                       while (!identical(envir, .GlobalEnv) && 
[16:05:34.285]                         !identical(envir, emptyenv())) {
[16:05:34.285]                         if (exists("master", mode = "list", envir = envir, 
[16:05:34.285]                           inherits = FALSE)) {
[16:05:34.285]                           master <- get("master", mode = "list", 
[16:05:34.285]                             envir = envir, inherits = FALSE)
[16:05:34.285]                           if (inherits(master, c("SOCKnode", 
[16:05:34.285]                             "SOCK0node"))) {
[16:05:34.285]                             sendCondition <<- function(cond) {
[16:05:34.285]                               data <- list(type = "VALUE", value = cond, 
[16:05:34.285]                                 success = TRUE)
[16:05:34.285]                               parallel_sendData(master, data)
[16:05:34.285]                             }
[16:05:34.285]                             return(sendCondition)
[16:05:34.285]                           }
[16:05:34.285]                         }
[16:05:34.285]                         frame <- frame + 1L
[16:05:34.285]                         envir <- sys.frame(frame)
[16:05:34.285]                       }
[16:05:34.285]                     }
[16:05:34.285]                     sendCondition <<- function(cond) NULL
[16:05:34.285]                   }
[16:05:34.285]                 })
[16:05:34.285]                 withCallingHandlers({
[16:05:34.285]                   NA
[16:05:34.285]                 }, immediateCondition = function(cond) {
[16:05:34.285]                   sendCondition <- ...future.makeSendCondition()
[16:05:34.285]                   sendCondition(cond)
[16:05:34.285]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:34.285]                   {
[16:05:34.285]                     inherits <- base::inherits
[16:05:34.285]                     invokeRestart <- base::invokeRestart
[16:05:34.285]                     is.null <- base::is.null
[16:05:34.285]                     muffled <- FALSE
[16:05:34.285]                     if (inherits(cond, "message")) {
[16:05:34.285]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:34.285]                       if (muffled) 
[16:05:34.285]                         invokeRestart("muffleMessage")
[16:05:34.285]                     }
[16:05:34.285]                     else if (inherits(cond, "warning")) {
[16:05:34.285]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:34.285]                       if (muffled) 
[16:05:34.285]                         invokeRestart("muffleWarning")
[16:05:34.285]                     }
[16:05:34.285]                     else if (inherits(cond, "condition")) {
[16:05:34.285]                       if (!is.null(pattern)) {
[16:05:34.285]                         computeRestarts <- base::computeRestarts
[16:05:34.285]                         grepl <- base::grepl
[16:05:34.285]                         restarts <- computeRestarts(cond)
[16:05:34.285]                         for (restart in restarts) {
[16:05:34.285]                           name <- restart$name
[16:05:34.285]                           if (is.null(name)) 
[16:05:34.285]                             next
[16:05:34.285]                           if (!grepl(pattern, name)) 
[16:05:34.285]                             next
[16:05:34.285]                           invokeRestart(restart)
[16:05:34.285]                           muffled <- TRUE
[16:05:34.285]                           break
[16:05:34.285]                         }
[16:05:34.285]                       }
[16:05:34.285]                     }
[16:05:34.285]                     invisible(muffled)
[16:05:34.285]                   }
[16:05:34.285]                   muffleCondition(cond)
[16:05:34.285]                 })
[16:05:34.285]             }))
[16:05:34.285]             future::FutureResult(value = ...future.value$value, 
[16:05:34.285]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:34.285]                   ...future.rng), globalenv = if (FALSE) 
[16:05:34.285]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:34.285]                     ...future.globalenv.names))
[16:05:34.285]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:34.285]         }, condition = base::local({
[16:05:34.285]             c <- base::c
[16:05:34.285]             inherits <- base::inherits
[16:05:34.285]             invokeRestart <- base::invokeRestart
[16:05:34.285]             length <- base::length
[16:05:34.285]             list <- base::list
[16:05:34.285]             seq.int <- base::seq.int
[16:05:34.285]             signalCondition <- base::signalCondition
[16:05:34.285]             sys.calls <- base::sys.calls
[16:05:34.285]             `[[` <- base::`[[`
[16:05:34.285]             `+` <- base::`+`
[16:05:34.285]             `<<-` <- base::`<<-`
[16:05:34.285]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:34.285]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:34.285]                   3L)]
[16:05:34.285]             }
[16:05:34.285]             function(cond) {
[16:05:34.285]                 is_error <- inherits(cond, "error")
[16:05:34.285]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:34.285]                   NULL)
[16:05:34.285]                 if (is_error) {
[16:05:34.285]                   sessionInformation <- function() {
[16:05:34.285]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:34.285]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:34.285]                       search = base::search(), system = base::Sys.info())
[16:05:34.285]                   }
[16:05:34.285]                   ...future.conditions[[length(...future.conditions) + 
[16:05:34.285]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:34.285]                     cond$call), session = sessionInformation(), 
[16:05:34.285]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:34.285]                   signalCondition(cond)
[16:05:34.285]                 }
[16:05:34.285]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:34.285]                 "immediateCondition"))) {
[16:05:34.285]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:34.285]                   ...future.conditions[[length(...future.conditions) + 
[16:05:34.285]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:34.285]                   if (TRUE && !signal) {
[16:05:34.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:34.285]                     {
[16:05:34.285]                       inherits <- base::inherits
[16:05:34.285]                       invokeRestart <- base::invokeRestart
[16:05:34.285]                       is.null <- base::is.null
[16:05:34.285]                       muffled <- FALSE
[16:05:34.285]                       if (inherits(cond, "message")) {
[16:05:34.285]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:34.285]                         if (muffled) 
[16:05:34.285]                           invokeRestart("muffleMessage")
[16:05:34.285]                       }
[16:05:34.285]                       else if (inherits(cond, "warning")) {
[16:05:34.285]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:34.285]                         if (muffled) 
[16:05:34.285]                           invokeRestart("muffleWarning")
[16:05:34.285]                       }
[16:05:34.285]                       else if (inherits(cond, "condition")) {
[16:05:34.285]                         if (!is.null(pattern)) {
[16:05:34.285]                           computeRestarts <- base::computeRestarts
[16:05:34.285]                           grepl <- base::grepl
[16:05:34.285]                           restarts <- computeRestarts(cond)
[16:05:34.285]                           for (restart in restarts) {
[16:05:34.285]                             name <- restart$name
[16:05:34.285]                             if (is.null(name)) 
[16:05:34.285]                               next
[16:05:34.285]                             if (!grepl(pattern, name)) 
[16:05:34.285]                               next
[16:05:34.285]                             invokeRestart(restart)
[16:05:34.285]                             muffled <- TRUE
[16:05:34.285]                             break
[16:05:34.285]                           }
[16:05:34.285]                         }
[16:05:34.285]                       }
[16:05:34.285]                       invisible(muffled)
[16:05:34.285]                     }
[16:05:34.285]                     muffleCondition(cond, pattern = "^muffle")
[16:05:34.285]                   }
[16:05:34.285]                 }
[16:05:34.285]                 else {
[16:05:34.285]                   if (TRUE) {
[16:05:34.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:34.285]                     {
[16:05:34.285]                       inherits <- base::inherits
[16:05:34.285]                       invokeRestart <- base::invokeRestart
[16:05:34.285]                       is.null <- base::is.null
[16:05:34.285]                       muffled <- FALSE
[16:05:34.285]                       if (inherits(cond, "message")) {
[16:05:34.285]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:34.285]                         if (muffled) 
[16:05:34.285]                           invokeRestart("muffleMessage")
[16:05:34.285]                       }
[16:05:34.285]                       else if (inherits(cond, "warning")) {
[16:05:34.285]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:34.285]                         if (muffled) 
[16:05:34.285]                           invokeRestart("muffleWarning")
[16:05:34.285]                       }
[16:05:34.285]                       else if (inherits(cond, "condition")) {
[16:05:34.285]                         if (!is.null(pattern)) {
[16:05:34.285]                           computeRestarts <- base::computeRestarts
[16:05:34.285]                           grepl <- base::grepl
[16:05:34.285]                           restarts <- computeRestarts(cond)
[16:05:34.285]                           for (restart in restarts) {
[16:05:34.285]                             name <- restart$name
[16:05:34.285]                             if (is.null(name)) 
[16:05:34.285]                               next
[16:05:34.285]                             if (!grepl(pattern, name)) 
[16:05:34.285]                               next
[16:05:34.285]                             invokeRestart(restart)
[16:05:34.285]                             muffled <- TRUE
[16:05:34.285]                             break
[16:05:34.285]                           }
[16:05:34.285]                         }
[16:05:34.285]                       }
[16:05:34.285]                       invisible(muffled)
[16:05:34.285]                     }
[16:05:34.285]                     muffleCondition(cond, pattern = "^muffle")
[16:05:34.285]                   }
[16:05:34.285]                 }
[16:05:34.285]             }
[16:05:34.285]         }))
[16:05:34.285]     }, error = function(ex) {
[16:05:34.285]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:34.285]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:34.285]                 ...future.rng), started = ...future.startTime, 
[16:05:34.285]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:34.285]             version = "1.8"), class = "FutureResult")
[16:05:34.285]     }, finally = {
[16:05:34.285]         if (!identical(...future.workdir, getwd())) 
[16:05:34.285]             setwd(...future.workdir)
[16:05:34.285]         {
[16:05:34.285]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:34.285]                 ...future.oldOptions$nwarnings <- NULL
[16:05:34.285]             }
[16:05:34.285]             base::options(...future.oldOptions)
[16:05:34.285]             if (.Platform$OS.type == "windows") {
[16:05:34.285]                 old_names <- names(...future.oldEnvVars)
[16:05:34.285]                 envs <- base::Sys.getenv()
[16:05:34.285]                 names <- names(envs)
[16:05:34.285]                 common <- intersect(names, old_names)
[16:05:34.285]                 added <- setdiff(names, old_names)
[16:05:34.285]                 removed <- setdiff(old_names, names)
[16:05:34.285]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:34.285]                   envs[common]]
[16:05:34.285]                 NAMES <- toupper(changed)
[16:05:34.285]                 args <- list()
[16:05:34.285]                 for (kk in seq_along(NAMES)) {
[16:05:34.285]                   name <- changed[[kk]]
[16:05:34.285]                   NAME <- NAMES[[kk]]
[16:05:34.285]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:34.285]                     next
[16:05:34.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:34.285]                 }
[16:05:34.285]                 NAMES <- toupper(added)
[16:05:34.285]                 for (kk in seq_along(NAMES)) {
[16:05:34.285]                   name <- added[[kk]]
[16:05:34.285]                   NAME <- NAMES[[kk]]
[16:05:34.285]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:34.285]                     next
[16:05:34.285]                   args[[name]] <- ""
[16:05:34.285]                 }
[16:05:34.285]                 NAMES <- toupper(removed)
[16:05:34.285]                 for (kk in seq_along(NAMES)) {
[16:05:34.285]                   name <- removed[[kk]]
[16:05:34.285]                   NAME <- NAMES[[kk]]
[16:05:34.285]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:34.285]                     next
[16:05:34.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:34.285]                 }
[16:05:34.285]                 if (length(args) > 0) 
[16:05:34.285]                   base::do.call(base::Sys.setenv, args = args)
[16:05:34.285]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:34.285]             }
[16:05:34.285]             else {
[16:05:34.285]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:34.285]             }
[16:05:34.285]             {
[16:05:34.285]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:34.285]                   0L) {
[16:05:34.285]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:34.285]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:34.285]                   base::options(opts)
[16:05:34.285]                 }
[16:05:34.285]                 {
[16:05:34.285]                   {
[16:05:34.285]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:34.285]                     NULL
[16:05:34.285]                   }
[16:05:34.285]                   options(future.plan = NULL)
[16:05:34.285]                   if (is.na(NA_character_)) 
[16:05:34.285]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:34.285]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:34.285]                   future::plan(list(a = function (..., workers = availableCores(), 
[16:05:34.285]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:34.285]                     envir = parent.frame()) 
[16:05:34.285]                   {
[16:05:34.285]                     if (is.function(workers)) 
[16:05:34.285]                       workers <- workers()
[16:05:34.285]                     workers <- structure(as.integer(workers), 
[16:05:34.285]                       class = class(workers))
[16:05:34.285]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:34.285]                       workers >= 1)
[16:05:34.285]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:34.285]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:34.285]                     }
[16:05:34.285]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:34.285]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:34.285]                       envir = envir)
[16:05:34.285]                     if (!future$lazy) 
[16:05:34.285]                       future <- run(future)
[16:05:34.285]                     invisible(future)
[16:05:34.285]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:34.285]                     envir = parent.frame()) 
[16:05:34.285]                   {
[16:05:34.285]                     default_workers <- missing(workers)
[16:05:34.285]                     if (is.function(workers)) 
[16:05:34.285]                       workers <- workers()
[16:05:34.285]                     workers <- structure(as.integer(workers), 
[16:05:34.285]                       class = class(workers))
[16:05:34.285]                     stop_if_not(is.finite(workers), workers >= 
[16:05:34.285]                       1L)
[16:05:34.285]                     if ((workers == 1L && !inherits(workers, 
[16:05:34.285]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:34.285]                       if (default_workers) 
[16:05:34.285]                         supportsMulticore(warn = TRUE)
[16:05:34.285]                       return(sequential(..., envir = envir))
[16:05:34.285]                     }
[16:05:34.285]                     oopts <- options(mc.cores = workers)
[16:05:34.285]                     on.exit(options(oopts))
[16:05:34.285]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:34.285]                       envir = envir)
[16:05:34.285]                     if (!future$lazy) 
[16:05:34.285]                       future <- run(future)
[16:05:34.285]                     invisible(future)
[16:05:34.285]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:34.285]                 }
[16:05:34.285]             }
[16:05:34.285]         }
[16:05:34.285]     })
[16:05:34.285]     if (TRUE) {
[16:05:34.285]         base::sink(type = "output", split = FALSE)
[16:05:34.285]         if (TRUE) {
[16:05:34.285]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:34.285]         }
[16:05:34.285]         else {
[16:05:34.285]             ...future.result["stdout"] <- base::list(NULL)
[16:05:34.285]         }
[16:05:34.285]         base::close(...future.stdout)
[16:05:34.285]         ...future.stdout <- NULL
[16:05:34.285]     }
[16:05:34.285]     ...future.result$conditions <- ...future.conditions
[16:05:34.285]     ...future.result$finished <- base::Sys.time()
[16:05:34.285]     ...future.result
[16:05:34.285] }
[16:05:34.338] MultisessionFuture started
[16:05:34.338] result() for ClusterFuture ...
[16:05:34.338] receiveMessageFromWorker() for ClusterFuture ...
[16:05:34.339] - Validating connection of MultisessionFuture
[16:05:34.387] - received message: FutureResult
[16:05:34.387] - Received FutureResult
[16:05:34.388] - Erased future from FutureRegistry
[16:05:34.388] result() for ClusterFuture ...
[16:05:34.388] - result already collected: FutureResult
[16:05:34.388] result() for ClusterFuture ... done
[16:05:34.388] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:34.388] result() for ClusterFuture ... done
[16:05:34.388] result() for ClusterFuture ...
[16:05:34.388] - result already collected: FutureResult
[16:05:34.388] result() for ClusterFuture ... done
[16:05:34.389] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:05:34.392] plan(): nbrOfWorkers() = 2
[16:05:34.392] getGlobalsAndPackages() ...
[16:05:34.392] Searching for globals...
[16:05:34.410] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:05:34.411] Searching for globals ... DONE
[16:05:34.411] Resolving globals: FALSE
[16:05:34.412] The total size of the 2 globals is 90.70 KiB (92872 bytes)
[16:05:34.412] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 90.70 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (90.58 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:05:34.412] - globals: [2] ‘nested’, ‘strategy2’
[16:05:34.412] - packages: [1] ‘future’
[16:05:34.412] getGlobalsAndPackages() ... DONE
[16:05:34.413] run() for ‘Future’ ...
[16:05:34.413] - state: ‘created’
[16:05:34.413] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:34.427] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:34.427] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:34.427]   - Field: ‘node’
[16:05:34.427]   - Field: ‘label’
[16:05:34.427]   - Field: ‘local’
[16:05:34.427]   - Field: ‘owner’
[16:05:34.427]   - Field: ‘envir’
[16:05:34.427]   - Field: ‘workers’
[16:05:34.428]   - Field: ‘packages’
[16:05:34.428]   - Field: ‘gc’
[16:05:34.428]   - Field: ‘conditions’
[16:05:34.428]   - Field: ‘persistent’
[16:05:34.428]   - Field: ‘expr’
[16:05:34.428]   - Field: ‘uuid’
[16:05:34.428]   - Field: ‘seed’
[16:05:34.428]   - Field: ‘version’
[16:05:34.428]   - Field: ‘result’
[16:05:34.428]   - Field: ‘asynchronous’
[16:05:34.428]   - Field: ‘calls’
[16:05:34.429]   - Field: ‘globals’
[16:05:34.429]   - Field: ‘stdout’
[16:05:34.429]   - Field: ‘earlySignal’
[16:05:34.429]   - Field: ‘lazy’
[16:05:34.429]   - Field: ‘state’
[16:05:34.429] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:34.429] - Launch lazy future ...
[16:05:34.429] Packages needed by the future expression (n = 1): ‘future’
[16:05:34.430] Packages needed by future strategies (n = 1): ‘future’
[16:05:34.430] {
[16:05:34.430]     {
[16:05:34.430]         {
[16:05:34.430]             ...future.startTime <- base::Sys.time()
[16:05:34.430]             {
[16:05:34.430]                 {
[16:05:34.430]                   {
[16:05:34.430]                     {
[16:05:34.430]                       {
[16:05:34.430]                         base::local({
[16:05:34.430]                           has_future <- base::requireNamespace("future", 
[16:05:34.430]                             quietly = TRUE)
[16:05:34.430]                           if (has_future) {
[16:05:34.430]                             ns <- base::getNamespace("future")
[16:05:34.430]                             version <- ns[[".package"]][["version"]]
[16:05:34.430]                             if (is.null(version)) 
[16:05:34.430]                               version <- utils::packageVersion("future")
[16:05:34.430]                           }
[16:05:34.430]                           else {
[16:05:34.430]                             version <- NULL
[16:05:34.430]                           }
[16:05:34.430]                           if (!has_future || version < "1.8.0") {
[16:05:34.430]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:34.430]                               "", base::R.version$version.string), 
[16:05:34.430]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:34.430]                                 base::R.version$platform, 8 * 
[16:05:34.430]                                   base::.Machine$sizeof.pointer), 
[16:05:34.430]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:34.430]                                 "release", "version")], collapse = " "), 
[16:05:34.430]                               hostname = base::Sys.info()[["nodename"]])
[16:05:34.430]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:34.430]                               info)
[16:05:34.430]                             info <- base::paste(info, collapse = "; ")
[16:05:34.430]                             if (!has_future) {
[16:05:34.430]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:34.430]                                 info)
[16:05:34.430]                             }
[16:05:34.430]                             else {
[16:05:34.430]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:34.430]                                 info, version)
[16:05:34.430]                             }
[16:05:34.430]                             base::stop(msg)
[16:05:34.430]                           }
[16:05:34.430]                         })
[16:05:34.430]                       }
[16:05:34.430]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:34.430]                       base::options(mc.cores = 1L)
[16:05:34.430]                     }
[16:05:34.430]                     base::local({
[16:05:34.430]                       for (pkg in "future") {
[16:05:34.430]                         base::loadNamespace(pkg)
[16:05:34.430]                         base::library(pkg, character.only = TRUE)
[16:05:34.430]                       }
[16:05:34.430]                     })
[16:05:34.430]                   }
[16:05:34.430]                   options(future.plan = NULL)
[16:05:34.430]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:34.430]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:34.430]                     envir = parent.frame()) 
[16:05:34.430]                   {
[16:05:34.430]                     default_workers <- missing(workers)
[16:05:34.430]                     if (is.function(workers)) 
[16:05:34.430]                       workers <- workers()
[16:05:34.430]                     workers <- structure(as.integer(workers), 
[16:05:34.430]                       class = class(workers))
[16:05:34.430]                     stop_if_not(is.finite(workers), workers >= 
[16:05:34.430]                       1L)
[16:05:34.430]                     if ((workers == 1L && !inherits(workers, 
[16:05:34.430]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:34.430]                       if (default_workers) 
[16:05:34.430]                         supportsMulticore(warn = TRUE)
[16:05:34.430]                       return(sequential(..., envir = envir))
[16:05:34.430]                     }
[16:05:34.430]                     oopts <- options(mc.cores = workers)
[16:05:34.430]                     on.exit(options(oopts))
[16:05:34.430]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:34.430]                       envir = envir)
[16:05:34.430]                     if (!future$lazy) 
[16:05:34.430]                       future <- run(future)
[16:05:34.430]                     invisible(future)
[16:05:34.430]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:34.430]                 }
[16:05:34.430]                 ...future.workdir <- getwd()
[16:05:34.430]             }
[16:05:34.430]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:34.430]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:34.430]         }
[16:05:34.430]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:34.430]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:34.430]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:34.430]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:34.430]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:34.430]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:34.430]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:34.430]             base::names(...future.oldOptions))
[16:05:34.430]     }
[16:05:34.430]     if (FALSE) {
[16:05:34.430]     }
[16:05:34.430]     else {
[16:05:34.430]         if (TRUE) {
[16:05:34.430]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:34.430]                 open = "w")
[16:05:34.430]         }
[16:05:34.430]         else {
[16:05:34.430]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:34.430]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:34.430]         }
[16:05:34.430]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:34.430]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:34.430]             base::sink(type = "output", split = FALSE)
[16:05:34.430]             base::close(...future.stdout)
[16:05:34.430]         }, add = TRUE)
[16:05:34.430]     }
[16:05:34.430]     ...future.frame <- base::sys.nframe()
[16:05:34.430]     ...future.conditions <- base::list()
[16:05:34.430]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:34.430]     if (FALSE) {
[16:05:34.430]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:34.430]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:34.430]     }
[16:05:34.430]     ...future.result <- base::tryCatch({
[16:05:34.430]         base::withCallingHandlers({
[16:05:34.430]             ...future.value <- base::withVisible(base::local({
[16:05:34.430]                 ...future.makeSendCondition <- base::local({
[16:05:34.430]                   sendCondition <- NULL
[16:05:34.430]                   function(frame = 1L) {
[16:05:34.430]                     if (is.function(sendCondition)) 
[16:05:34.430]                       return(sendCondition)
[16:05:34.430]                     ns <- getNamespace("parallel")
[16:05:34.430]                     if (exists("sendData", mode = "function", 
[16:05:34.430]                       envir = ns)) {
[16:05:34.430]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:34.430]                         envir = ns)
[16:05:34.430]                       envir <- sys.frame(frame)
[16:05:34.430]                       master <- NULL
[16:05:34.430]                       while (!identical(envir, .GlobalEnv) && 
[16:05:34.430]                         !identical(envir, emptyenv())) {
[16:05:34.430]                         if (exists("master", mode = "list", envir = envir, 
[16:05:34.430]                           inherits = FALSE)) {
[16:05:34.430]                           master <- get("master", mode = "list", 
[16:05:34.430]                             envir = envir, inherits = FALSE)
[16:05:34.430]                           if (inherits(master, c("SOCKnode", 
[16:05:34.430]                             "SOCK0node"))) {
[16:05:34.430]                             sendCondition <<- function(cond) {
[16:05:34.430]                               data <- list(type = "VALUE", value = cond, 
[16:05:34.430]                                 success = TRUE)
[16:05:34.430]                               parallel_sendData(master, data)
[16:05:34.430]                             }
[16:05:34.430]                             return(sendCondition)
[16:05:34.430]                           }
[16:05:34.430]                         }
[16:05:34.430]                         frame <- frame + 1L
[16:05:34.430]                         envir <- sys.frame(frame)
[16:05:34.430]                       }
[16:05:34.430]                     }
[16:05:34.430]                     sendCondition <<- function(cond) NULL
[16:05:34.430]                   }
[16:05:34.430]                 })
[16:05:34.430]                 withCallingHandlers({
[16:05:34.430]                   {
[16:05:34.430]                     a <- 1L
[16:05:34.430]                     plan_a <- unclass(future::plan("list"))
[16:05:34.430]                     nested_a <- nested[-1]
[16:05:34.430]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:05:34.430]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:05:34.430]                       strategy2))
[16:05:34.430]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:05:34.430]                       "init") <- NULL
[16:05:34.430]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:05:34.430]                       "init") <- NULL
[16:05:34.430]                     stopifnot(all.equal(plan_a, nested_a))
[16:05:34.430]                     y %<-% {
[16:05:34.430]                       b <- 2L
[16:05:34.430]                       plan_b <- future::plan("list")
[16:05:34.430]                       nested_b <- nested_a[-1]
[16:05:34.430]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:05:34.430]                         1L, inherits(plan_b[[1]], "future"), 
[16:05:34.430]                         inherits(future::plan("next"), "sequential"))
[16:05:34.430]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:05:34.430]                         b = b, nested_b = nested_b, plan_b = plan_b)
[16:05:34.430]                     }
[16:05:34.430]                     y
[16:05:34.430]                   }
[16:05:34.430]                 }, immediateCondition = function(cond) {
[16:05:34.430]                   sendCondition <- ...future.makeSendCondition()
[16:05:34.430]                   sendCondition(cond)
[16:05:34.430]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:34.430]                   {
[16:05:34.430]                     inherits <- base::inherits
[16:05:34.430]                     invokeRestart <- base::invokeRestart
[16:05:34.430]                     is.null <- base::is.null
[16:05:34.430]                     muffled <- FALSE
[16:05:34.430]                     if (inherits(cond, "message")) {
[16:05:34.430]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:34.430]                       if (muffled) 
[16:05:34.430]                         invokeRestart("muffleMessage")
[16:05:34.430]                     }
[16:05:34.430]                     else if (inherits(cond, "warning")) {
[16:05:34.430]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:34.430]                       if (muffled) 
[16:05:34.430]                         invokeRestart("muffleWarning")
[16:05:34.430]                     }
[16:05:34.430]                     else if (inherits(cond, "condition")) {
[16:05:34.430]                       if (!is.null(pattern)) {
[16:05:34.430]                         computeRestarts <- base::computeRestarts
[16:05:34.430]                         grepl <- base::grepl
[16:05:34.430]                         restarts <- computeRestarts(cond)
[16:05:34.430]                         for (restart in restarts) {
[16:05:34.430]                           name <- restart$name
[16:05:34.430]                           if (is.null(name)) 
[16:05:34.430]                             next
[16:05:34.430]                           if (!grepl(pattern, name)) 
[16:05:34.430]                             next
[16:05:34.430]                           invokeRestart(restart)
[16:05:34.430]                           muffled <- TRUE
[16:05:34.430]                           break
[16:05:34.430]                         }
[16:05:34.430]                       }
[16:05:34.430]                     }
[16:05:34.430]                     invisible(muffled)
[16:05:34.430]                   }
[16:05:34.430]                   muffleCondition(cond)
[16:05:34.430]                 })
[16:05:34.430]             }))
[16:05:34.430]             future::FutureResult(value = ...future.value$value, 
[16:05:34.430]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:34.430]                   ...future.rng), globalenv = if (FALSE) 
[16:05:34.430]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:34.430]                     ...future.globalenv.names))
[16:05:34.430]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:34.430]         }, condition = base::local({
[16:05:34.430]             c <- base::c
[16:05:34.430]             inherits <- base::inherits
[16:05:34.430]             invokeRestart <- base::invokeRestart
[16:05:34.430]             length <- base::length
[16:05:34.430]             list <- base::list
[16:05:34.430]             seq.int <- base::seq.int
[16:05:34.430]             signalCondition <- base::signalCondition
[16:05:34.430]             sys.calls <- base::sys.calls
[16:05:34.430]             `[[` <- base::`[[`
[16:05:34.430]             `+` <- base::`+`
[16:05:34.430]             `<<-` <- base::`<<-`
[16:05:34.430]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:34.430]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:34.430]                   3L)]
[16:05:34.430]             }
[16:05:34.430]             function(cond) {
[16:05:34.430]                 is_error <- inherits(cond, "error")
[16:05:34.430]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:34.430]                   NULL)
[16:05:34.430]                 if (is_error) {
[16:05:34.430]                   sessionInformation <- function() {
[16:05:34.430]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:34.430]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:34.430]                       search = base::search(), system = base::Sys.info())
[16:05:34.430]                   }
[16:05:34.430]                   ...future.conditions[[length(...future.conditions) + 
[16:05:34.430]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:34.430]                     cond$call), session = sessionInformation(), 
[16:05:34.430]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:34.430]                   signalCondition(cond)
[16:05:34.430]                 }
[16:05:34.430]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:34.430]                 "immediateCondition"))) {
[16:05:34.430]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:34.430]                   ...future.conditions[[length(...future.conditions) + 
[16:05:34.430]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:34.430]                   if (TRUE && !signal) {
[16:05:34.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:34.430]                     {
[16:05:34.430]                       inherits <- base::inherits
[16:05:34.430]                       invokeRestart <- base::invokeRestart
[16:05:34.430]                       is.null <- base::is.null
[16:05:34.430]                       muffled <- FALSE
[16:05:34.430]                       if (inherits(cond, "message")) {
[16:05:34.430]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:34.430]                         if (muffled) 
[16:05:34.430]                           invokeRestart("muffleMessage")
[16:05:34.430]                       }
[16:05:34.430]                       else if (inherits(cond, "warning")) {
[16:05:34.430]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:34.430]                         if (muffled) 
[16:05:34.430]                           invokeRestart("muffleWarning")
[16:05:34.430]                       }
[16:05:34.430]                       else if (inherits(cond, "condition")) {
[16:05:34.430]                         if (!is.null(pattern)) {
[16:05:34.430]                           computeRestarts <- base::computeRestarts
[16:05:34.430]                           grepl <- base::grepl
[16:05:34.430]                           restarts <- computeRestarts(cond)
[16:05:34.430]                           for (restart in restarts) {
[16:05:34.430]                             name <- restart$name
[16:05:34.430]                             if (is.null(name)) 
[16:05:34.430]                               next
[16:05:34.430]                             if (!grepl(pattern, name)) 
[16:05:34.430]                               next
[16:05:34.430]                             invokeRestart(restart)
[16:05:34.430]                             muffled <- TRUE
[16:05:34.430]                             break
[16:05:34.430]                           }
[16:05:34.430]                         }
[16:05:34.430]                       }
[16:05:34.430]                       invisible(muffled)
[16:05:34.430]                     }
[16:05:34.430]                     muffleCondition(cond, pattern = "^muffle")
[16:05:34.430]                   }
[16:05:34.430]                 }
[16:05:34.430]                 else {
[16:05:34.430]                   if (TRUE) {
[16:05:34.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:34.430]                     {
[16:05:34.430]                       inherits <- base::inherits
[16:05:34.430]                       invokeRestart <- base::invokeRestart
[16:05:34.430]                       is.null <- base::is.null
[16:05:34.430]                       muffled <- FALSE
[16:05:34.430]                       if (inherits(cond, "message")) {
[16:05:34.430]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:34.430]                         if (muffled) 
[16:05:34.430]                           invokeRestart("muffleMessage")
[16:05:34.430]                       }
[16:05:34.430]                       else if (inherits(cond, "warning")) {
[16:05:34.430]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:34.430]                         if (muffled) 
[16:05:34.430]                           invokeRestart("muffleWarning")
[16:05:34.430]                       }
[16:05:34.430]                       else if (inherits(cond, "condition")) {
[16:05:34.430]                         if (!is.null(pattern)) {
[16:05:34.430]                           computeRestarts <- base::computeRestarts
[16:05:34.430]                           grepl <- base::grepl
[16:05:34.430]                           restarts <- computeRestarts(cond)
[16:05:34.430]                           for (restart in restarts) {
[16:05:34.430]                             name <- restart$name
[16:05:34.430]                             if (is.null(name)) 
[16:05:34.430]                               next
[16:05:34.430]                             if (!grepl(pattern, name)) 
[16:05:34.430]                               next
[16:05:34.430]                             invokeRestart(restart)
[16:05:34.430]                             muffled <- TRUE
[16:05:34.430]                             break
[16:05:34.430]                           }
[16:05:34.430]                         }
[16:05:34.430]                       }
[16:05:34.430]                       invisible(muffled)
[16:05:34.430]                     }
[16:05:34.430]                     muffleCondition(cond, pattern = "^muffle")
[16:05:34.430]                   }
[16:05:34.430]                 }
[16:05:34.430]             }
[16:05:34.430]         }))
[16:05:34.430]     }, error = function(ex) {
[16:05:34.430]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:34.430]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:34.430]                 ...future.rng), started = ...future.startTime, 
[16:05:34.430]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:34.430]             version = "1.8"), class = "FutureResult")
[16:05:34.430]     }, finally = {
[16:05:34.430]         if (!identical(...future.workdir, getwd())) 
[16:05:34.430]             setwd(...future.workdir)
[16:05:34.430]         {
[16:05:34.430]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:34.430]                 ...future.oldOptions$nwarnings <- NULL
[16:05:34.430]             }
[16:05:34.430]             base::options(...future.oldOptions)
[16:05:34.430]             if (.Platform$OS.type == "windows") {
[16:05:34.430]                 old_names <- names(...future.oldEnvVars)
[16:05:34.430]                 envs <- base::Sys.getenv()
[16:05:34.430]                 names <- names(envs)
[16:05:34.430]                 common <- intersect(names, old_names)
[16:05:34.430]                 added <- setdiff(names, old_names)
[16:05:34.430]                 removed <- setdiff(old_names, names)
[16:05:34.430]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:34.430]                   envs[common]]
[16:05:34.430]                 NAMES <- toupper(changed)
[16:05:34.430]                 args <- list()
[16:05:34.430]                 for (kk in seq_along(NAMES)) {
[16:05:34.430]                   name <- changed[[kk]]
[16:05:34.430]                   NAME <- NAMES[[kk]]
[16:05:34.430]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:34.430]                     next
[16:05:34.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:34.430]                 }
[16:05:34.430]                 NAMES <- toupper(added)
[16:05:34.430]                 for (kk in seq_along(NAMES)) {
[16:05:34.430]                   name <- added[[kk]]
[16:05:34.430]                   NAME <- NAMES[[kk]]
[16:05:34.430]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:34.430]                     next
[16:05:34.430]                   args[[name]] <- ""
[16:05:34.430]                 }
[16:05:34.430]                 NAMES <- toupper(removed)
[16:05:34.430]                 for (kk in seq_along(NAMES)) {
[16:05:34.430]                   name <- removed[[kk]]
[16:05:34.430]                   NAME <- NAMES[[kk]]
[16:05:34.430]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:34.430]                     next
[16:05:34.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:34.430]                 }
[16:05:34.430]                 if (length(args) > 0) 
[16:05:34.430]                   base::do.call(base::Sys.setenv, args = args)
[16:05:34.430]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:34.430]             }
[16:05:34.430]             else {
[16:05:34.430]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:34.430]             }
[16:05:34.430]             {
[16:05:34.430]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:34.430]                   0L) {
[16:05:34.430]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:34.430]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:34.430]                   base::options(opts)
[16:05:34.430]                 }
[16:05:34.430]                 {
[16:05:34.430]                   {
[16:05:34.430]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:34.430]                     NULL
[16:05:34.430]                   }
[16:05:34.430]                   options(future.plan = NULL)
[16:05:34.430]                   if (is.na(NA_character_)) 
[16:05:34.430]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:34.430]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:34.430]                   future::plan(list(a = function (..., workers = availableCores(), 
[16:05:34.430]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:34.430]                     envir = parent.frame()) 
[16:05:34.430]                   {
[16:05:34.430]                     if (is.function(workers)) 
[16:05:34.430]                       workers <- workers()
[16:05:34.430]                     workers <- structure(as.integer(workers), 
[16:05:34.430]                       class = class(workers))
[16:05:34.430]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:34.430]                       workers >= 1)
[16:05:34.430]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:34.430]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:34.430]                     }
[16:05:34.430]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:34.430]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:34.430]                       envir = envir)
[16:05:34.430]                     if (!future$lazy) 
[16:05:34.430]                       future <- run(future)
[16:05:34.430]                     invisible(future)
[16:05:34.430]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:34.430]                     envir = parent.frame()) 
[16:05:34.430]                   {
[16:05:34.430]                     default_workers <- missing(workers)
[16:05:34.430]                     if (is.function(workers)) 
[16:05:34.430]                       workers <- workers()
[16:05:34.430]                     workers <- structure(as.integer(workers), 
[16:05:34.430]                       class = class(workers))
[16:05:34.430]                     stop_if_not(is.finite(workers), workers >= 
[16:05:34.430]                       1L)
[16:05:34.430]                     if ((workers == 1L && !inherits(workers, 
[16:05:34.430]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:34.430]                       if (default_workers) 
[16:05:34.430]                         supportsMulticore(warn = TRUE)
[16:05:34.430]                       return(sequential(..., envir = envir))
[16:05:34.430]                     }
[16:05:34.430]                     oopts <- options(mc.cores = workers)
[16:05:34.430]                     on.exit(options(oopts))
[16:05:34.430]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:34.430]                       envir = envir)
[16:05:34.430]                     if (!future$lazy) 
[16:05:34.430]                       future <- run(future)
[16:05:34.430]                     invisible(future)
[16:05:34.430]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:34.430]                 }
[16:05:34.430]             }
[16:05:34.430]         }
[16:05:34.430]     })
[16:05:34.430]     if (TRUE) {
[16:05:34.430]         base::sink(type = "output", split = FALSE)
[16:05:34.430]         if (TRUE) {
[16:05:34.430]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:34.430]         }
[16:05:34.430]         else {
[16:05:34.430]             ...future.result["stdout"] <- base::list(NULL)
[16:05:34.430]         }
[16:05:34.430]         base::close(...future.stdout)
[16:05:34.430]         ...future.stdout <- NULL
[16:05:34.430]     }
[16:05:34.430]     ...future.result$conditions <- ...future.conditions
[16:05:34.430]     ...future.result$finished <- base::Sys.time()
[16:05:34.430]     ...future.result
[16:05:34.430] }
[16:05:34.433] Exporting 2 global objects (90.70 KiB) to cluster node #1 ...
[16:05:34.433] Exporting ‘nested’ (90.58 KiB) to cluster node #1 ...
[16:05:34.475] Exporting ‘nested’ (90.58 KiB) to cluster node #1 ... DONE
[16:05:34.475] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[16:05:34.476] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[16:05:34.476] Exporting 2 global objects (90.70 KiB) to cluster node #1 ... DONE
[16:05:34.476] MultisessionFuture started
[16:05:34.477] - Launch lazy future ... done
[16:05:34.477] run() for ‘MultisessionFuture’ ... done
[16:05:34.477] result() for ClusterFuture ...
[16:05:34.477] receiveMessageFromWorker() for ClusterFuture ...
[16:05:34.477] - Validating connection of MultisessionFuture
[16:05:34.552] - received message: FutureResult
[16:05:34.553] - Received FutureResult
[16:05:34.553] - Erased future from FutureRegistry
[16:05:34.553] result() for ClusterFuture ...
[16:05:34.553] - result already collected: FutureResult
[16:05:34.553] result() for ClusterFuture ... done
[16:05:34.553] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:34.553] result() for ClusterFuture ... done
[16:05:34.553] result() for ClusterFuture ...
[16:05:34.553] - result already collected: FutureResult
[16:05:34.553] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:05:34.559] getGlobalsAndPackages() ...
[16:05:34.559] Searching for globals...
[16:05:34.560] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:05:34.560] Searching for globals ... DONE
[16:05:34.560] Resolving globals: FALSE
[16:05:34.561] The total size of the 1 globals is 128 bytes (128 bytes)
[16:05:34.561] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:05:34.561] - globals: [1] ‘data’
[16:05:34.561] - packages: [1] ‘future’
[16:05:34.562] getGlobalsAndPackages() ... DONE
[16:05:34.562] run() for ‘Future’ ...
[16:05:34.562] - state: ‘created’
[16:05:34.562] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:34.576] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:34.576] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:34.576]   - Field: ‘node’
[16:05:34.576]   - Field: ‘label’
[16:05:34.576]   - Field: ‘local’
[16:05:34.576]   - Field: ‘owner’
[16:05:34.576]   - Field: ‘envir’
[16:05:34.576]   - Field: ‘workers’
[16:05:34.576]   - Field: ‘packages’
[16:05:34.576]   - Field: ‘gc’
[16:05:34.577]   - Field: ‘conditions’
[16:05:34.577]   - Field: ‘persistent’
[16:05:34.577]   - Field: ‘expr’
[16:05:34.577]   - Field: ‘uuid’
[16:05:34.577]   - Field: ‘seed’
[16:05:34.577]   - Field: ‘version’
[16:05:34.577]   - Field: ‘result’
[16:05:34.577]   - Field: ‘asynchronous’
[16:05:34.577]   - Field: ‘calls’
[16:05:34.577]   - Field: ‘globals’
[16:05:34.577]   - Field: ‘stdout’
[16:05:34.578]   - Field: ‘earlySignal’
[16:05:34.578]   - Field: ‘lazy’
[16:05:34.578]   - Field: ‘state’
[16:05:34.578] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:34.578] - Launch lazy future ...
[16:05:34.578] Packages needed by the future expression (n = 1): ‘future’
[16:05:34.578] Packages needed by future strategies (n = 1): ‘future’
[16:05:34.579] {
[16:05:34.579]     {
[16:05:34.579]         {
[16:05:34.579]             ...future.startTime <- base::Sys.time()
[16:05:34.579]             {
[16:05:34.579]                 {
[16:05:34.579]                   {
[16:05:34.579]                     {
[16:05:34.579]                       {
[16:05:34.579]                         base::local({
[16:05:34.579]                           has_future <- base::requireNamespace("future", 
[16:05:34.579]                             quietly = TRUE)
[16:05:34.579]                           if (has_future) {
[16:05:34.579]                             ns <- base::getNamespace("future")
[16:05:34.579]                             version <- ns[[".package"]][["version"]]
[16:05:34.579]                             if (is.null(version)) 
[16:05:34.579]                               version <- utils::packageVersion("future")
[16:05:34.579]                           }
[16:05:34.579]                           else {
[16:05:34.579]                             version <- NULL
[16:05:34.579]                           }
[16:05:34.579]                           if (!has_future || version < "1.8.0") {
[16:05:34.579]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:34.579]                               "", base::R.version$version.string), 
[16:05:34.579]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:34.579]                                 base::R.version$platform, 8 * 
[16:05:34.579]                                   base::.Machine$sizeof.pointer), 
[16:05:34.579]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:34.579]                                 "release", "version")], collapse = " "), 
[16:05:34.579]                               hostname = base::Sys.info()[["nodename"]])
[16:05:34.579]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:34.579]                               info)
[16:05:34.579]                             info <- base::paste(info, collapse = "; ")
[16:05:34.579]                             if (!has_future) {
[16:05:34.579]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:34.579]                                 info)
[16:05:34.579]                             }
[16:05:34.579]                             else {
[16:05:34.579]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:34.579]                                 info, version)
[16:05:34.579]                             }
[16:05:34.579]                             base::stop(msg)
[16:05:34.579]                           }
[16:05:34.579]                         })
[16:05:34.579]                       }
[16:05:34.579]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:34.579]                       base::options(mc.cores = 1L)
[16:05:34.579]                     }
[16:05:34.579]                     base::local({
[16:05:34.579]                       for (pkg in "future") {
[16:05:34.579]                         base::loadNamespace(pkg)
[16:05:34.579]                         base::library(pkg, character.only = TRUE)
[16:05:34.579]                       }
[16:05:34.579]                     })
[16:05:34.579]                   }
[16:05:34.579]                   options(future.plan = NULL)
[16:05:34.579]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:34.579]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:34.579]                     envir = parent.frame()) 
[16:05:34.579]                   {
[16:05:34.579]                     default_workers <- missing(workers)
[16:05:34.579]                     if (is.function(workers)) 
[16:05:34.579]                       workers <- workers()
[16:05:34.579]                     workers <- structure(as.integer(workers), 
[16:05:34.579]                       class = class(workers))
[16:05:34.579]                     stop_if_not(is.finite(workers), workers >= 
[16:05:34.579]                       1L)
[16:05:34.579]                     if ((workers == 1L && !inherits(workers, 
[16:05:34.579]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:34.579]                       if (default_workers) 
[16:05:34.579]                         supportsMulticore(warn = TRUE)
[16:05:34.579]                       return(sequential(..., envir = envir))
[16:05:34.579]                     }
[16:05:34.579]                     oopts <- options(mc.cores = workers)
[16:05:34.579]                     on.exit(options(oopts))
[16:05:34.579]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:34.579]                       envir = envir)
[16:05:34.579]                     if (!future$lazy) 
[16:05:34.579]                       future <- run(future)
[16:05:34.579]                     invisible(future)
[16:05:34.579]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:34.579]                 }
[16:05:34.579]                 ...future.workdir <- getwd()
[16:05:34.579]             }
[16:05:34.579]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:34.579]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:34.579]         }
[16:05:34.579]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:34.579]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:34.579]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:34.579]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:34.579]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:34.579]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:34.579]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:34.579]             base::names(...future.oldOptions))
[16:05:34.579]     }
[16:05:34.579]     if (FALSE) {
[16:05:34.579]     }
[16:05:34.579]     else {
[16:05:34.579]         if (TRUE) {
[16:05:34.579]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:34.579]                 open = "w")
[16:05:34.579]         }
[16:05:34.579]         else {
[16:05:34.579]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:34.579]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:34.579]         }
[16:05:34.579]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:34.579]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:34.579]             base::sink(type = "output", split = FALSE)
[16:05:34.579]             base::close(...future.stdout)
[16:05:34.579]         }, add = TRUE)
[16:05:34.579]     }
[16:05:34.579]     ...future.frame <- base::sys.nframe()
[16:05:34.579]     ...future.conditions <- base::list()
[16:05:34.579]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:34.579]     if (FALSE) {
[16:05:34.579]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:34.579]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:34.579]     }
[16:05:34.579]     ...future.result <- base::tryCatch({
[16:05:34.579]         base::withCallingHandlers({
[16:05:34.579]             ...future.value <- base::withVisible(base::local({
[16:05:34.579]                 ...future.makeSendCondition <- base::local({
[16:05:34.579]                   sendCondition <- NULL
[16:05:34.579]                   function(frame = 1L) {
[16:05:34.579]                     if (is.function(sendCondition)) 
[16:05:34.579]                       return(sendCondition)
[16:05:34.579]                     ns <- getNamespace("parallel")
[16:05:34.579]                     if (exists("sendData", mode = "function", 
[16:05:34.579]                       envir = ns)) {
[16:05:34.579]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:34.579]                         envir = ns)
[16:05:34.579]                       envir <- sys.frame(frame)
[16:05:34.579]                       master <- NULL
[16:05:34.579]                       while (!identical(envir, .GlobalEnv) && 
[16:05:34.579]                         !identical(envir, emptyenv())) {
[16:05:34.579]                         if (exists("master", mode = "list", envir = envir, 
[16:05:34.579]                           inherits = FALSE)) {
[16:05:34.579]                           master <- get("master", mode = "list", 
[16:05:34.579]                             envir = envir, inherits = FALSE)
[16:05:34.579]                           if (inherits(master, c("SOCKnode", 
[16:05:34.579]                             "SOCK0node"))) {
[16:05:34.579]                             sendCondition <<- function(cond) {
[16:05:34.579]                               data <- list(type = "VALUE", value = cond, 
[16:05:34.579]                                 success = TRUE)
[16:05:34.579]                               parallel_sendData(master, data)
[16:05:34.579]                             }
[16:05:34.579]                             return(sendCondition)
[16:05:34.579]                           }
[16:05:34.579]                         }
[16:05:34.579]                         frame <- frame + 1L
[16:05:34.579]                         envir <- sys.frame(frame)
[16:05:34.579]                       }
[16:05:34.579]                     }
[16:05:34.579]                     sendCondition <<- function(cond) NULL
[16:05:34.579]                   }
[16:05:34.579]                 })
[16:05:34.579]                 withCallingHandlers({
[16:05:34.579]                   {
[16:05:34.579]                     value(future(subset(data, a == 2)))
[16:05:34.579]                   }
[16:05:34.579]                 }, immediateCondition = function(cond) {
[16:05:34.579]                   sendCondition <- ...future.makeSendCondition()
[16:05:34.579]                   sendCondition(cond)
[16:05:34.579]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:34.579]                   {
[16:05:34.579]                     inherits <- base::inherits
[16:05:34.579]                     invokeRestart <- base::invokeRestart
[16:05:34.579]                     is.null <- base::is.null
[16:05:34.579]                     muffled <- FALSE
[16:05:34.579]                     if (inherits(cond, "message")) {
[16:05:34.579]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:34.579]                       if (muffled) 
[16:05:34.579]                         invokeRestart("muffleMessage")
[16:05:34.579]                     }
[16:05:34.579]                     else if (inherits(cond, "warning")) {
[16:05:34.579]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:34.579]                       if (muffled) 
[16:05:34.579]                         invokeRestart("muffleWarning")
[16:05:34.579]                     }
[16:05:34.579]                     else if (inherits(cond, "condition")) {
[16:05:34.579]                       if (!is.null(pattern)) {
[16:05:34.579]                         computeRestarts <- base::computeRestarts
[16:05:34.579]                         grepl <- base::grepl
[16:05:34.579]                         restarts <- computeRestarts(cond)
[16:05:34.579]                         for (restart in restarts) {
[16:05:34.579]                           name <- restart$name
[16:05:34.579]                           if (is.null(name)) 
[16:05:34.579]                             next
[16:05:34.579]                           if (!grepl(pattern, name)) 
[16:05:34.579]                             next
[16:05:34.579]                           invokeRestart(restart)
[16:05:34.579]                           muffled <- TRUE
[16:05:34.579]                           break
[16:05:34.579]                         }
[16:05:34.579]                       }
[16:05:34.579]                     }
[16:05:34.579]                     invisible(muffled)
[16:05:34.579]                   }
[16:05:34.579]                   muffleCondition(cond)
[16:05:34.579]                 })
[16:05:34.579]             }))
[16:05:34.579]             future::FutureResult(value = ...future.value$value, 
[16:05:34.579]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:34.579]                   ...future.rng), globalenv = if (FALSE) 
[16:05:34.579]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:34.579]                     ...future.globalenv.names))
[16:05:34.579]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:34.579]         }, condition = base::local({
[16:05:34.579]             c <- base::c
[16:05:34.579]             inherits <- base::inherits
[16:05:34.579]             invokeRestart <- base::invokeRestart
[16:05:34.579]             length <- base::length
[16:05:34.579]             list <- base::list
[16:05:34.579]             seq.int <- base::seq.int
[16:05:34.579]             signalCondition <- base::signalCondition
[16:05:34.579]             sys.calls <- base::sys.calls
[16:05:34.579]             `[[` <- base::`[[`
[16:05:34.579]             `+` <- base::`+`
[16:05:34.579]             `<<-` <- base::`<<-`
[16:05:34.579]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:34.579]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:34.579]                   3L)]
[16:05:34.579]             }
[16:05:34.579]             function(cond) {
[16:05:34.579]                 is_error <- inherits(cond, "error")
[16:05:34.579]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:34.579]                   NULL)
[16:05:34.579]                 if (is_error) {
[16:05:34.579]                   sessionInformation <- function() {
[16:05:34.579]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:34.579]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:34.579]                       search = base::search(), system = base::Sys.info())
[16:05:34.579]                   }
[16:05:34.579]                   ...future.conditions[[length(...future.conditions) + 
[16:05:34.579]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:34.579]                     cond$call), session = sessionInformation(), 
[16:05:34.579]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:34.579]                   signalCondition(cond)
[16:05:34.579]                 }
[16:05:34.579]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:34.579]                 "immediateCondition"))) {
[16:05:34.579]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:34.579]                   ...future.conditions[[length(...future.conditions) + 
[16:05:34.579]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:34.579]                   if (TRUE && !signal) {
[16:05:34.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:34.579]                     {
[16:05:34.579]                       inherits <- base::inherits
[16:05:34.579]                       invokeRestart <- base::invokeRestart
[16:05:34.579]                       is.null <- base::is.null
[16:05:34.579]                       muffled <- FALSE
[16:05:34.579]                       if (inherits(cond, "message")) {
[16:05:34.579]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:34.579]                         if (muffled) 
[16:05:34.579]                           invokeRestart("muffleMessage")
[16:05:34.579]                       }
[16:05:34.579]                       else if (inherits(cond, "warning")) {
[16:05:34.579]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:34.579]                         if (muffled) 
[16:05:34.579]                           invokeRestart("muffleWarning")
[16:05:34.579]                       }
[16:05:34.579]                       else if (inherits(cond, "condition")) {
[16:05:34.579]                         if (!is.null(pattern)) {
[16:05:34.579]                           computeRestarts <- base::computeRestarts
[16:05:34.579]                           grepl <- base::grepl
[16:05:34.579]                           restarts <- computeRestarts(cond)
[16:05:34.579]                           for (restart in restarts) {
[16:05:34.579]                             name <- restart$name
[16:05:34.579]                             if (is.null(name)) 
[16:05:34.579]                               next
[16:05:34.579]                             if (!grepl(pattern, name)) 
[16:05:34.579]                               next
[16:05:34.579]                             invokeRestart(restart)
[16:05:34.579]                             muffled <- TRUE
[16:05:34.579]                             break
[16:05:34.579]                           }
[16:05:34.579]                         }
[16:05:34.579]                       }
[16:05:34.579]                       invisible(muffled)
[16:05:34.579]                     }
[16:05:34.579]                     muffleCondition(cond, pattern = "^muffle")
[16:05:34.579]                   }
[16:05:34.579]                 }
[16:05:34.579]                 else {
[16:05:34.579]                   if (TRUE) {
[16:05:34.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:34.579]                     {
[16:05:34.579]                       inherits <- base::inherits
[16:05:34.579]                       invokeRestart <- base::invokeRestart
[16:05:34.579]                       is.null <- base::is.null
[16:05:34.579]                       muffled <- FALSE
[16:05:34.579]                       if (inherits(cond, "message")) {
[16:05:34.579]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:34.579]                         if (muffled) 
[16:05:34.579]                           invokeRestart("muffleMessage")
[16:05:34.579]                       }
[16:05:34.579]                       else if (inherits(cond, "warning")) {
[16:05:34.579]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:34.579]                         if (muffled) 
[16:05:34.579]                           invokeRestart("muffleWarning")
[16:05:34.579]                       }
[16:05:34.579]                       else if (inherits(cond, "condition")) {
[16:05:34.579]                         if (!is.null(pattern)) {
[16:05:34.579]                           computeRestarts <- base::computeRestarts
[16:05:34.579]                           grepl <- base::grepl
[16:05:34.579]                           restarts <- computeRestarts(cond)
[16:05:34.579]                           for (restart in restarts) {
[16:05:34.579]                             name <- restart$name
[16:05:34.579]                             if (is.null(name)) 
[16:05:34.579]                               next
[16:05:34.579]                             if (!grepl(pattern, name)) 
[16:05:34.579]                               next
[16:05:34.579]                             invokeRestart(restart)
[16:05:34.579]                             muffled <- TRUE
[16:05:34.579]                             break
[16:05:34.579]                           }
[16:05:34.579]                         }
[16:05:34.579]                       }
[16:05:34.579]                       invisible(muffled)
[16:05:34.579]                     }
[16:05:34.579]                     muffleCondition(cond, pattern = "^muffle")
[16:05:34.579]                   }
[16:05:34.579]                 }
[16:05:34.579]             }
[16:05:34.579]         }))
[16:05:34.579]     }, error = function(ex) {
[16:05:34.579]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:34.579]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:34.579]                 ...future.rng), started = ...future.startTime, 
[16:05:34.579]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:34.579]             version = "1.8"), class = "FutureResult")
[16:05:34.579]     }, finally = {
[16:05:34.579]         if (!identical(...future.workdir, getwd())) 
[16:05:34.579]             setwd(...future.workdir)
[16:05:34.579]         {
[16:05:34.579]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:34.579]                 ...future.oldOptions$nwarnings <- NULL
[16:05:34.579]             }
[16:05:34.579]             base::options(...future.oldOptions)
[16:05:34.579]             if (.Platform$OS.type == "windows") {
[16:05:34.579]                 old_names <- names(...future.oldEnvVars)
[16:05:34.579]                 envs <- base::Sys.getenv()
[16:05:34.579]                 names <- names(envs)
[16:05:34.579]                 common <- intersect(names, old_names)
[16:05:34.579]                 added <- setdiff(names, old_names)
[16:05:34.579]                 removed <- setdiff(old_names, names)
[16:05:34.579]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:34.579]                   envs[common]]
[16:05:34.579]                 NAMES <- toupper(changed)
[16:05:34.579]                 args <- list()
[16:05:34.579]                 for (kk in seq_along(NAMES)) {
[16:05:34.579]                   name <- changed[[kk]]
[16:05:34.579]                   NAME <- NAMES[[kk]]
[16:05:34.579]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:34.579]                     next
[16:05:34.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:34.579]                 }
[16:05:34.579]                 NAMES <- toupper(added)
[16:05:34.579]                 for (kk in seq_along(NAMES)) {
[16:05:34.579]                   name <- added[[kk]]
[16:05:34.579]                   NAME <- NAMES[[kk]]
[16:05:34.579]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:34.579]                     next
[16:05:34.579]                   args[[name]] <- ""
[16:05:34.579]                 }
[16:05:34.579]                 NAMES <- toupper(removed)
[16:05:34.579]                 for (kk in seq_along(NAMES)) {
[16:05:34.579]                   name <- removed[[kk]]
[16:05:34.579]                   NAME <- NAMES[[kk]]
[16:05:34.579]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:34.579]                     next
[16:05:34.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:34.579]                 }
[16:05:34.579]                 if (length(args) > 0) 
[16:05:34.579]                   base::do.call(base::Sys.setenv, args = args)
[16:05:34.579]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:34.579]             }
[16:05:34.579]             else {
[16:05:34.579]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:34.579]             }
[16:05:34.579]             {
[16:05:34.579]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:34.579]                   0L) {
[16:05:34.579]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:34.579]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:34.579]                   base::options(opts)
[16:05:34.579]                 }
[16:05:34.579]                 {
[16:05:34.579]                   {
[16:05:34.579]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:34.579]                     NULL
[16:05:34.579]                   }
[16:05:34.579]                   options(future.plan = NULL)
[16:05:34.579]                   if (is.na(NA_character_)) 
[16:05:34.579]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:34.579]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:34.579]                   future::plan(list(a = function (..., workers = availableCores(), 
[16:05:34.579]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:34.579]                     envir = parent.frame()) 
[16:05:34.579]                   {
[16:05:34.579]                     if (is.function(workers)) 
[16:05:34.579]                       workers <- workers()
[16:05:34.579]                     workers <- structure(as.integer(workers), 
[16:05:34.579]                       class = class(workers))
[16:05:34.579]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:34.579]                       workers >= 1)
[16:05:34.579]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:34.579]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:34.579]                     }
[16:05:34.579]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:34.579]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:34.579]                       envir = envir)
[16:05:34.579]                     if (!future$lazy) 
[16:05:34.579]                       future <- run(future)
[16:05:34.579]                     invisible(future)
[16:05:34.579]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[16:05:34.579]                     envir = parent.frame()) 
[16:05:34.579]                   {
[16:05:34.579]                     default_workers <- missing(workers)
[16:05:34.579]                     if (is.function(workers)) 
[16:05:34.579]                       workers <- workers()
[16:05:34.579]                     workers <- structure(as.integer(workers), 
[16:05:34.579]                       class = class(workers))
[16:05:34.579]                     stop_if_not(is.finite(workers), workers >= 
[16:05:34.579]                       1L)
[16:05:34.579]                     if ((workers == 1L && !inherits(workers, 
[16:05:34.579]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:34.579]                       if (default_workers) 
[16:05:34.579]                         supportsMulticore(warn = TRUE)
[16:05:34.579]                       return(sequential(..., envir = envir))
[16:05:34.579]                     }
[16:05:34.579]                     oopts <- options(mc.cores = workers)
[16:05:34.579]                     on.exit(options(oopts))
[16:05:34.579]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:34.579]                       envir = envir)
[16:05:34.579]                     if (!future$lazy) 
[16:05:34.579]                       future <- run(future)
[16:05:34.579]                     invisible(future)
[16:05:34.579]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:34.579]                 }
[16:05:34.579]             }
[16:05:34.579]         }
[16:05:34.579]     })
[16:05:34.579]     if (TRUE) {
[16:05:34.579]         base::sink(type = "output", split = FALSE)
[16:05:34.579]         if (TRUE) {
[16:05:34.579]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:34.579]         }
[16:05:34.579]         else {
[16:05:34.579]             ...future.result["stdout"] <- base::list(NULL)
[16:05:34.579]         }
[16:05:34.579]         base::close(...future.stdout)
[16:05:34.579]         ...future.stdout <- NULL
[16:05:34.579]     }
[16:05:34.579]     ...future.result$conditions <- ...future.conditions
[16:05:34.579]     ...future.result$finished <- base::Sys.time()
[16:05:34.579]     ...future.result
[16:05:34.579] }
[16:05:34.582] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[16:05:34.582] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[16:05:34.582] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[16:05:34.582] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[16:05:34.583] MultisessionFuture started
[16:05:34.583] - Launch lazy future ... done
[16:05:34.583] run() for ‘MultisessionFuture’ ... done
[16:05:34.583] result() for ClusterFuture ...
[16:05:34.584] receiveMessageFromWorker() for ClusterFuture ...
[16:05:34.584] - Validating connection of MultisessionFuture
[16:05:34.649] - received message: FutureResult
[16:05:34.649] - Received FutureResult
[16:05:34.649] - Erased future from FutureRegistry
[16:05:34.650] result() for ClusterFuture ...
[16:05:34.650] - result already collected: FutureResult
[16:05:34.650] result() for ClusterFuture ... done
[16:05:34.650] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:34.650] result() for ClusterFuture ... done
[16:05:34.650] result() for ClusterFuture ...
[16:05:34.650] - result already collected: FutureResult
[16:05:34.650] result() for ClusterFuture ... done
- plan(list('multisession', 'multicore')) ... DONE
- plan(list('multisession', 'multisession')) ...
[16:05:34.651] plan(): Setting new future strategy stack:
[16:05:34.651] List of future strategies:
[16:05:34.651] 1. multisession:
[16:05:34.651]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:34.651]    - tweaked: FALSE
[16:05:34.651]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:34.651] 2. multisession:
[16:05:34.651]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:34.651]    - tweaked: FALSE
[16:05:34.651]    - call: plan(list(a = strategy1, b = strategy2))
[16:05:34.652] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:05:34.652] multisession:
[16:05:34.652] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:34.652] - tweaked: FALSE
[16:05:34.652] - call: plan(list(a = strategy1, b = strategy2))
[16:05:34.657] getGlobalsAndPackages() ...
[16:05:34.657] Not searching for globals
[16:05:34.657] - globals: [0] <none>
[16:05:34.657] getGlobalsAndPackages() ... DONE
[16:05:34.658] [local output] makeClusterPSOCK() ...
[16:05:34.662] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:05:34.663] [local output] Base port: 11743
[16:05:34.663] [local output] Getting setup options for 2 cluster nodes ...
[16:05:34.663] [local output]  - Node 1 of 2 ...
[16:05:34.664] [local output] localMachine=TRUE => revtunnel=FALSE

[16:05:34.665] [local output] Rscript port: 11743

[16:05:34.665] [local output]  - Node 2 of 2 ...
[16:05:34.666] [local output] localMachine=TRUE => revtunnel=FALSE

[16:05:34.667] [local output] Rscript port: 11743

[16:05:34.667] [local output] Getting setup options for 2 cluster nodes ... done
[16:05:34.667] [local output]  - Parallel setup requested for some PSOCK nodes
[16:05:34.668] [local output] Setting up PSOCK nodes in parallel
[16:05:34.668] List of 36
[16:05:34.668]  $ worker          : chr "localhost"
[16:05:34.668]   ..- attr(*, "localhost")= logi TRUE
[16:05:34.668]  $ master          : chr "localhost"
[16:05:34.668]  $ port            : int 11743
[16:05:34.668]  $ connectTimeout  : num 120
[16:05:34.668]  $ timeout         : num 2592000
[16:05:34.668]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:05:34.668]  $ homogeneous     : logi TRUE
[16:05:34.668]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:05:34.668]  $ rscript_envs    : NULL
[16:05:34.668]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:05:34.668]  $ rscript_startup : NULL
[16:05:34.668]  $ rscript_sh      : chr "sh"
[16:05:34.668]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:05:34.668]  $ methods         : logi TRUE
[16:05:34.668]  $ socketOptions   : chr "no-delay"
[16:05:34.668]  $ useXDR          : logi FALSE
[16:05:34.668]  $ outfile         : chr "/dev/null"
[16:05:34.668]  $ renice          : int NA
[16:05:34.668]  $ rshcmd          : NULL
[16:05:34.668]  $ user            : chr(0) 
[16:05:34.668]  $ revtunnel       : logi FALSE
[16:05:34.668]  $ rshlogfile      : NULL
[16:05:34.668]  $ rshopts         : chr(0) 
[16:05:34.668]  $ rank            : int 1
[16:05:34.668]  $ manual          : logi FALSE
[16:05:34.668]  $ dryrun          : logi FALSE
[16:05:34.668]  $ quiet           : logi FALSE
[16:05:34.668]  $ setup_strategy  : chr "parallel"
[16:05:34.668]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:05:34.668]  $ pidfile         : chr "/tmp/Rtmp0EbAi0/worker.rank=1.parallelly.parent=88964.15b8482cb0ae.pid"
[16:05:34.668]  $ rshcmd_label    : NULL
[16:05:34.668]  $ rsh_call        : NULL
[16:05:34.668]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:05:34.668]  $ localMachine    : logi TRUE
[16:05:34.668]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:05:34.668]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:05:34.668]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:05:34.668]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:05:34.668]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:05:34.668]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:05:34.668]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:05:34.668]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:05:34.668]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:05:34.668]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:05:34.668]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:05:34.668]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:05:34.668]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:05:34.668]  $ arguments       :List of 28
[16:05:34.668]   ..$ worker          : chr "localhost"
[16:05:34.668]   ..$ master          : NULL
[16:05:34.668]   ..$ port            : int 11743
[16:05:34.668]   ..$ connectTimeout  : num 120
[16:05:34.668]   ..$ timeout         : num 2592000
[16:05:34.668]   ..$ rscript         : NULL
[16:05:34.668]   ..$ homogeneous     : NULL
[16:05:34.668]   ..$ rscript_args    : NULL
[16:05:34.668]   ..$ rscript_envs    : NULL
[16:05:34.668]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:05:34.668]   ..$ rscript_startup : NULL
[16:05:34.668]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:05:34.668]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:05:34.668]   ..$ methods         : logi TRUE
[16:05:34.668]   ..$ socketOptions   : chr "no-delay"
[16:05:34.668]   ..$ useXDR          : logi FALSE
[16:05:34.668]   ..$ outfile         : chr "/dev/null"
[16:05:34.668]   ..$ renice          : int NA
[16:05:34.668]   ..$ rshcmd          : NULL
[16:05:34.668]   ..$ user            : NULL
[16:05:34.668]   ..$ revtunnel       : logi NA
[16:05:34.668]   ..$ rshlogfile      : NULL
[16:05:34.668]   ..$ rshopts         : NULL
[16:05:34.668]   ..$ rank            : int 1
[16:05:34.668]   ..$ manual          : logi FALSE
[16:05:34.668]   ..$ dryrun          : logi FALSE
[16:05:34.668]   ..$ quiet           : logi FALSE
[16:05:34.668]   ..$ setup_strategy  : chr "parallel"
[16:05:34.668]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:05:34.687] [local output] System call to launch all workers:
[16:05:34.687] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp0EbAi0/worker.rank=1.parallelly.parent=88964.15b8482cb0ae.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11743 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:05:34.688] [local output] Starting PSOCK main server
[16:05:34.689] [local output] Workers launched
[16:05:34.689] [local output] Waiting for workers to connect back
[16:05:34.689]  - [local output] 0 workers out of 2 ready
[16:05:34.930]  - [local output] 0 workers out of 2 ready
[16:05:34.930]  - [local output] 1 workers out of 2 ready
[16:05:34.939]  - [local output] 1 workers out of 2 ready
[16:05:34.939]  - [local output] 2 workers out of 2 ready
[16:05:34.939] [local output] Launching of workers completed
[16:05:34.939] [local output] Collecting session information from workers
[16:05:34.940] [local output]  - Worker #1 of 2
[16:05:34.941] [local output]  - Worker #2 of 2
[16:05:34.941] [local output] makeClusterPSOCK() ... done
[16:05:34.951] Packages needed by the future expression (n = 0): <none>
[16:05:34.951] Packages needed by future strategies (n = 1): ‘future’
[16:05:34.952] {
[16:05:34.952]     {
[16:05:34.952]         {
[16:05:34.952]             ...future.startTime <- base::Sys.time()
[16:05:34.952]             {
[16:05:34.952]                 {
[16:05:34.952]                   {
[16:05:34.952]                     {
[16:05:34.952]                       {
[16:05:34.952]                         base::local({
[16:05:34.952]                           has_future <- base::requireNamespace("future", 
[16:05:34.952]                             quietly = TRUE)
[16:05:34.952]                           if (has_future) {
[16:05:34.952]                             ns <- base::getNamespace("future")
[16:05:34.952]                             version <- ns[[".package"]][["version"]]
[16:05:34.952]                             if (is.null(version)) 
[16:05:34.952]                               version <- utils::packageVersion("future")
[16:05:34.952]                           }
[16:05:34.952]                           else {
[16:05:34.952]                             version <- NULL
[16:05:34.952]                           }
[16:05:34.952]                           if (!has_future || version < "1.8.0") {
[16:05:34.952]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:34.952]                               "", base::R.version$version.string), 
[16:05:34.952]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:34.952]                                 base::R.version$platform, 8 * 
[16:05:34.952]                                   base::.Machine$sizeof.pointer), 
[16:05:34.952]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:34.952]                                 "release", "version")], collapse = " "), 
[16:05:34.952]                               hostname = base::Sys.info()[["nodename"]])
[16:05:34.952]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:34.952]                               info)
[16:05:34.952]                             info <- base::paste(info, collapse = "; ")
[16:05:34.952]                             if (!has_future) {
[16:05:34.952]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:34.952]                                 info)
[16:05:34.952]                             }
[16:05:34.952]                             else {
[16:05:34.952]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:34.952]                                 info, version)
[16:05:34.952]                             }
[16:05:34.952]                             base::stop(msg)
[16:05:34.952]                           }
[16:05:34.952]                         })
[16:05:34.952]                       }
[16:05:34.952]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:34.952]                       base::options(mc.cores = 1L)
[16:05:34.952]                     }
[16:05:34.952]                     base::local({
[16:05:34.952]                       for (pkg in "future") {
[16:05:34.952]                         base::loadNamespace(pkg)
[16:05:34.952]                         base::library(pkg, character.only = TRUE)
[16:05:34.952]                       }
[16:05:34.952]                     })
[16:05:34.952]                   }
[16:05:34.952]                   options(future.plan = NULL)
[16:05:34.952]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:34.952]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:05:34.952]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:34.952]                     envir = parent.frame()) 
[16:05:34.952]                   {
[16:05:34.952]                     if (is.function(workers)) 
[16:05:34.952]                       workers <- workers()
[16:05:34.952]                     workers <- structure(as.integer(workers), 
[16:05:34.952]                       class = class(workers))
[16:05:34.952]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:34.952]                       workers >= 1)
[16:05:34.952]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:34.952]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:34.952]                     }
[16:05:34.952]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:34.952]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:34.952]                       envir = envir)
[16:05:34.952]                     if (!future$lazy) 
[16:05:34.952]                       future <- run(future)
[16:05:34.952]                     invisible(future)
[16:05:34.952]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:34.952]                 }
[16:05:34.952]                 ...future.workdir <- getwd()
[16:05:34.952]             }
[16:05:34.952]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:34.952]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:34.952]         }
[16:05:34.952]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:34.952]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:34.952]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:34.952]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:34.952]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:34.952]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:34.952]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:34.952]             base::names(...future.oldOptions))
[16:05:34.952]     }
[16:05:34.952]     if (FALSE) {
[16:05:34.952]     }
[16:05:34.952]     else {
[16:05:34.952]         if (TRUE) {
[16:05:34.952]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:34.952]                 open = "w")
[16:05:34.952]         }
[16:05:34.952]         else {
[16:05:34.952]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:34.952]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:34.952]         }
[16:05:34.952]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:34.952]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:34.952]             base::sink(type = "output", split = FALSE)
[16:05:34.952]             base::close(...future.stdout)
[16:05:34.952]         }, add = TRUE)
[16:05:34.952]     }
[16:05:34.952]     ...future.frame <- base::sys.nframe()
[16:05:34.952]     ...future.conditions <- base::list()
[16:05:34.952]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:34.952]     if (FALSE) {
[16:05:34.952]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:34.952]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:34.952]     }
[16:05:34.952]     ...future.result <- base::tryCatch({
[16:05:34.952]         base::withCallingHandlers({
[16:05:34.952]             ...future.value <- base::withVisible(base::local({
[16:05:34.952]                 ...future.makeSendCondition <- base::local({
[16:05:34.952]                   sendCondition <- NULL
[16:05:34.952]                   function(frame = 1L) {
[16:05:34.952]                     if (is.function(sendCondition)) 
[16:05:34.952]                       return(sendCondition)
[16:05:34.952]                     ns <- getNamespace("parallel")
[16:05:34.952]                     if (exists("sendData", mode = "function", 
[16:05:34.952]                       envir = ns)) {
[16:05:34.952]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:34.952]                         envir = ns)
[16:05:34.952]                       envir <- sys.frame(frame)
[16:05:34.952]                       master <- NULL
[16:05:34.952]                       while (!identical(envir, .GlobalEnv) && 
[16:05:34.952]                         !identical(envir, emptyenv())) {
[16:05:34.952]                         if (exists("master", mode = "list", envir = envir, 
[16:05:34.952]                           inherits = FALSE)) {
[16:05:34.952]                           master <- get("master", mode = "list", 
[16:05:34.952]                             envir = envir, inherits = FALSE)
[16:05:34.952]                           if (inherits(master, c("SOCKnode", 
[16:05:34.952]                             "SOCK0node"))) {
[16:05:34.952]                             sendCondition <<- function(cond) {
[16:05:34.952]                               data <- list(type = "VALUE", value = cond, 
[16:05:34.952]                                 success = TRUE)
[16:05:34.952]                               parallel_sendData(master, data)
[16:05:34.952]                             }
[16:05:34.952]                             return(sendCondition)
[16:05:34.952]                           }
[16:05:34.952]                         }
[16:05:34.952]                         frame <- frame + 1L
[16:05:34.952]                         envir <- sys.frame(frame)
[16:05:34.952]                       }
[16:05:34.952]                     }
[16:05:34.952]                     sendCondition <<- function(cond) NULL
[16:05:34.952]                   }
[16:05:34.952]                 })
[16:05:34.952]                 withCallingHandlers({
[16:05:34.952]                   NA
[16:05:34.952]                 }, immediateCondition = function(cond) {
[16:05:34.952]                   sendCondition <- ...future.makeSendCondition()
[16:05:34.952]                   sendCondition(cond)
[16:05:34.952]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:34.952]                   {
[16:05:34.952]                     inherits <- base::inherits
[16:05:34.952]                     invokeRestart <- base::invokeRestart
[16:05:34.952]                     is.null <- base::is.null
[16:05:34.952]                     muffled <- FALSE
[16:05:34.952]                     if (inherits(cond, "message")) {
[16:05:34.952]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:34.952]                       if (muffled) 
[16:05:34.952]                         invokeRestart("muffleMessage")
[16:05:34.952]                     }
[16:05:34.952]                     else if (inherits(cond, "warning")) {
[16:05:34.952]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:34.952]                       if (muffled) 
[16:05:34.952]                         invokeRestart("muffleWarning")
[16:05:34.952]                     }
[16:05:34.952]                     else if (inherits(cond, "condition")) {
[16:05:34.952]                       if (!is.null(pattern)) {
[16:05:34.952]                         computeRestarts <- base::computeRestarts
[16:05:34.952]                         grepl <- base::grepl
[16:05:34.952]                         restarts <- computeRestarts(cond)
[16:05:34.952]                         for (restart in restarts) {
[16:05:34.952]                           name <- restart$name
[16:05:34.952]                           if (is.null(name)) 
[16:05:34.952]                             next
[16:05:34.952]                           if (!grepl(pattern, name)) 
[16:05:34.952]                             next
[16:05:34.952]                           invokeRestart(restart)
[16:05:34.952]                           muffled <- TRUE
[16:05:34.952]                           break
[16:05:34.952]                         }
[16:05:34.952]                       }
[16:05:34.952]                     }
[16:05:34.952]                     invisible(muffled)
[16:05:34.952]                   }
[16:05:34.952]                   muffleCondition(cond)
[16:05:34.952]                 })
[16:05:34.952]             }))
[16:05:34.952]             future::FutureResult(value = ...future.value$value, 
[16:05:34.952]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:34.952]                   ...future.rng), globalenv = if (FALSE) 
[16:05:34.952]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:34.952]                     ...future.globalenv.names))
[16:05:34.952]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:34.952]         }, condition = base::local({
[16:05:34.952]             c <- base::c
[16:05:34.952]             inherits <- base::inherits
[16:05:34.952]             invokeRestart <- base::invokeRestart
[16:05:34.952]             length <- base::length
[16:05:34.952]             list <- base::list
[16:05:34.952]             seq.int <- base::seq.int
[16:05:34.952]             signalCondition <- base::signalCondition
[16:05:34.952]             sys.calls <- base::sys.calls
[16:05:34.952]             `[[` <- base::`[[`
[16:05:34.952]             `+` <- base::`+`
[16:05:34.952]             `<<-` <- base::`<<-`
[16:05:34.952]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:34.952]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:34.952]                   3L)]
[16:05:34.952]             }
[16:05:34.952]             function(cond) {
[16:05:34.952]                 is_error <- inherits(cond, "error")
[16:05:34.952]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:34.952]                   NULL)
[16:05:34.952]                 if (is_error) {
[16:05:34.952]                   sessionInformation <- function() {
[16:05:34.952]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:34.952]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:34.952]                       search = base::search(), system = base::Sys.info())
[16:05:34.952]                   }
[16:05:34.952]                   ...future.conditions[[length(...future.conditions) + 
[16:05:34.952]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:34.952]                     cond$call), session = sessionInformation(), 
[16:05:34.952]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:34.952]                   signalCondition(cond)
[16:05:34.952]                 }
[16:05:34.952]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:34.952]                 "immediateCondition"))) {
[16:05:34.952]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:34.952]                   ...future.conditions[[length(...future.conditions) + 
[16:05:34.952]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:34.952]                   if (TRUE && !signal) {
[16:05:34.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:34.952]                     {
[16:05:34.952]                       inherits <- base::inherits
[16:05:34.952]                       invokeRestart <- base::invokeRestart
[16:05:34.952]                       is.null <- base::is.null
[16:05:34.952]                       muffled <- FALSE
[16:05:34.952]                       if (inherits(cond, "message")) {
[16:05:34.952]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:34.952]                         if (muffled) 
[16:05:34.952]                           invokeRestart("muffleMessage")
[16:05:34.952]                       }
[16:05:34.952]                       else if (inherits(cond, "warning")) {
[16:05:34.952]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:34.952]                         if (muffled) 
[16:05:34.952]                           invokeRestart("muffleWarning")
[16:05:34.952]                       }
[16:05:34.952]                       else if (inherits(cond, "condition")) {
[16:05:34.952]                         if (!is.null(pattern)) {
[16:05:34.952]                           computeRestarts <- base::computeRestarts
[16:05:34.952]                           grepl <- base::grepl
[16:05:34.952]                           restarts <- computeRestarts(cond)
[16:05:34.952]                           for (restart in restarts) {
[16:05:34.952]                             name <- restart$name
[16:05:34.952]                             if (is.null(name)) 
[16:05:34.952]                               next
[16:05:34.952]                             if (!grepl(pattern, name)) 
[16:05:34.952]                               next
[16:05:34.952]                             invokeRestart(restart)
[16:05:34.952]                             muffled <- TRUE
[16:05:34.952]                             break
[16:05:34.952]                           }
[16:05:34.952]                         }
[16:05:34.952]                       }
[16:05:34.952]                       invisible(muffled)
[16:05:34.952]                     }
[16:05:34.952]                     muffleCondition(cond, pattern = "^muffle")
[16:05:34.952]                   }
[16:05:34.952]                 }
[16:05:34.952]                 else {
[16:05:34.952]                   if (TRUE) {
[16:05:34.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:34.952]                     {
[16:05:34.952]                       inherits <- base::inherits
[16:05:34.952]                       invokeRestart <- base::invokeRestart
[16:05:34.952]                       is.null <- base::is.null
[16:05:34.952]                       muffled <- FALSE
[16:05:34.952]                       if (inherits(cond, "message")) {
[16:05:34.952]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:34.952]                         if (muffled) 
[16:05:34.952]                           invokeRestart("muffleMessage")
[16:05:34.952]                       }
[16:05:34.952]                       else if (inherits(cond, "warning")) {
[16:05:34.952]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:34.952]                         if (muffled) 
[16:05:34.952]                           invokeRestart("muffleWarning")
[16:05:34.952]                       }
[16:05:34.952]                       else if (inherits(cond, "condition")) {
[16:05:34.952]                         if (!is.null(pattern)) {
[16:05:34.952]                           computeRestarts <- base::computeRestarts
[16:05:34.952]                           grepl <- base::grepl
[16:05:34.952]                           restarts <- computeRestarts(cond)
[16:05:34.952]                           for (restart in restarts) {
[16:05:34.952]                             name <- restart$name
[16:05:34.952]                             if (is.null(name)) 
[16:05:34.952]                               next
[16:05:34.952]                             if (!grepl(pattern, name)) 
[16:05:34.952]                               next
[16:05:34.952]                             invokeRestart(restart)
[16:05:34.952]                             muffled <- TRUE
[16:05:34.952]                             break
[16:05:34.952]                           }
[16:05:34.952]                         }
[16:05:34.952]                       }
[16:05:34.952]                       invisible(muffled)
[16:05:34.952]                     }
[16:05:34.952]                     muffleCondition(cond, pattern = "^muffle")
[16:05:34.952]                   }
[16:05:34.952]                 }
[16:05:34.952]             }
[16:05:34.952]         }))
[16:05:34.952]     }, error = function(ex) {
[16:05:34.952]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:34.952]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:34.952]                 ...future.rng), started = ...future.startTime, 
[16:05:34.952]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:34.952]             version = "1.8"), class = "FutureResult")
[16:05:34.952]     }, finally = {
[16:05:34.952]         if (!identical(...future.workdir, getwd())) 
[16:05:34.952]             setwd(...future.workdir)
[16:05:34.952]         {
[16:05:34.952]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:34.952]                 ...future.oldOptions$nwarnings <- NULL
[16:05:34.952]             }
[16:05:34.952]             base::options(...future.oldOptions)
[16:05:34.952]             if (.Platform$OS.type == "windows") {
[16:05:34.952]                 old_names <- names(...future.oldEnvVars)
[16:05:34.952]                 envs <- base::Sys.getenv()
[16:05:34.952]                 names <- names(envs)
[16:05:34.952]                 common <- intersect(names, old_names)
[16:05:34.952]                 added <- setdiff(names, old_names)
[16:05:34.952]                 removed <- setdiff(old_names, names)
[16:05:34.952]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:34.952]                   envs[common]]
[16:05:34.952]                 NAMES <- toupper(changed)
[16:05:34.952]                 args <- list()
[16:05:34.952]                 for (kk in seq_along(NAMES)) {
[16:05:34.952]                   name <- changed[[kk]]
[16:05:34.952]                   NAME <- NAMES[[kk]]
[16:05:34.952]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:34.952]                     next
[16:05:34.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:34.952]                 }
[16:05:34.952]                 NAMES <- toupper(added)
[16:05:34.952]                 for (kk in seq_along(NAMES)) {
[16:05:34.952]                   name <- added[[kk]]
[16:05:34.952]                   NAME <- NAMES[[kk]]
[16:05:34.952]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:34.952]                     next
[16:05:34.952]                   args[[name]] <- ""
[16:05:34.952]                 }
[16:05:34.952]                 NAMES <- toupper(removed)
[16:05:34.952]                 for (kk in seq_along(NAMES)) {
[16:05:34.952]                   name <- removed[[kk]]
[16:05:34.952]                   NAME <- NAMES[[kk]]
[16:05:34.952]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:34.952]                     next
[16:05:34.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:34.952]                 }
[16:05:34.952]                 if (length(args) > 0) 
[16:05:34.952]                   base::do.call(base::Sys.setenv, args = args)
[16:05:34.952]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:34.952]             }
[16:05:34.952]             else {
[16:05:34.952]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:34.952]             }
[16:05:34.952]             {
[16:05:34.952]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:34.952]                   0L) {
[16:05:34.952]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:34.952]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:34.952]                   base::options(opts)
[16:05:34.952]                 }
[16:05:34.952]                 {
[16:05:34.952]                   {
[16:05:34.952]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:34.952]                     NULL
[16:05:34.952]                   }
[16:05:34.952]                   options(future.plan = NULL)
[16:05:34.952]                   if (is.na(NA_character_)) 
[16:05:34.952]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:34.952]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:34.952]                   future::plan(list(a = function (..., workers = availableCores(), 
[16:05:34.952]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:34.952]                     envir = parent.frame()) 
[16:05:34.952]                   {
[16:05:34.952]                     if (is.function(workers)) 
[16:05:34.952]                       workers <- workers()
[16:05:34.952]                     workers <- structure(as.integer(workers), 
[16:05:34.952]                       class = class(workers))
[16:05:34.952]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:34.952]                       workers >= 1)
[16:05:34.952]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:34.952]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:34.952]                     }
[16:05:34.952]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:34.952]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:34.952]                       envir = envir)
[16:05:34.952]                     if (!future$lazy) 
[16:05:34.952]                       future <- run(future)
[16:05:34.952]                     invisible(future)
[16:05:34.952]                   }, b = function (..., workers = availableCores(), 
[16:05:34.952]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:34.952]                     envir = parent.frame()) 
[16:05:34.952]                   {
[16:05:34.952]                     if (is.function(workers)) 
[16:05:34.952]                       workers <- workers()
[16:05:34.952]                     workers <- structure(as.integer(workers), 
[16:05:34.952]                       class = class(workers))
[16:05:34.952]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:34.952]                       workers >= 1)
[16:05:34.952]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:34.952]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:34.952]                     }
[16:05:34.952]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:34.952]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:34.952]                       envir = envir)
[16:05:34.952]                     if (!future$lazy) 
[16:05:34.952]                       future <- run(future)
[16:05:34.952]                     invisible(future)
[16:05:34.952]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:34.952]                 }
[16:05:34.952]             }
[16:05:34.952]         }
[16:05:34.952]     })
[16:05:34.952]     if (TRUE) {
[16:05:34.952]         base::sink(type = "output", split = FALSE)
[16:05:34.952]         if (TRUE) {
[16:05:34.952]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:34.952]         }
[16:05:34.952]         else {
[16:05:34.952]             ...future.result["stdout"] <- base::list(NULL)
[16:05:34.952]         }
[16:05:34.952]         base::close(...future.stdout)
[16:05:34.952]         ...future.stdout <- NULL
[16:05:34.952]     }
[16:05:34.952]     ...future.result$conditions <- ...future.conditions
[16:05:34.952]     ...future.result$finished <- base::Sys.time()
[16:05:34.952]     ...future.result
[16:05:34.952] }
[16:05:35.005] MultisessionFuture started
[16:05:35.005] result() for ClusterFuture ...
[16:05:35.005] receiveMessageFromWorker() for ClusterFuture ...
[16:05:35.005] - Validating connection of MultisessionFuture
[16:05:35.053] - received message: FutureResult
[16:05:35.054] - Received FutureResult
[16:05:35.054] - Erased future from FutureRegistry
[16:05:35.054] result() for ClusterFuture ...
[16:05:35.054] - result already collected: FutureResult
[16:05:35.054] result() for ClusterFuture ... done
[16:05:35.054] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:35.054] result() for ClusterFuture ... done
[16:05:35.054] result() for ClusterFuture ...
[16:05:35.055] - result already collected: FutureResult
[16:05:35.055] result() for ClusterFuture ... done
[16:05:35.055] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:05:35.058] plan(): nbrOfWorkers() = 2
[16:05:35.059] getGlobalsAndPackages() ...
[16:05:35.059] Searching for globals...
[16:05:35.075] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:05:35.075] Searching for globals ... DONE
[16:05:35.075] Resolving globals: FALSE
[16:05:35.076] The total size of the 2 globals is 88.27 KiB (90384 bytes)
[16:05:35.076] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 88.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (88.15 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:05:35.077] - globals: [2] ‘nested’, ‘strategy2’
[16:05:35.077] - packages: [1] ‘future’
[16:05:35.077] getGlobalsAndPackages() ... DONE
[16:05:35.077] run() for ‘Future’ ...
[16:05:35.077] - state: ‘created’
[16:05:35.077] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:35.091] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:35.091] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:35.091]   - Field: ‘node’
[16:05:35.092]   - Field: ‘label’
[16:05:35.092]   - Field: ‘local’
[16:05:35.092]   - Field: ‘owner’
[16:05:35.092]   - Field: ‘envir’
[16:05:35.092]   - Field: ‘workers’
[16:05:35.092]   - Field: ‘packages’
[16:05:35.092]   - Field: ‘gc’
[16:05:35.092]   - Field: ‘conditions’
[16:05:35.092]   - Field: ‘persistent’
[16:05:35.092]   - Field: ‘expr’
[16:05:35.093]   - Field: ‘uuid’
[16:05:35.093]   - Field: ‘seed’
[16:05:35.093]   - Field: ‘version’
[16:05:35.093]   - Field: ‘result’
[16:05:35.093]   - Field: ‘asynchronous’
[16:05:35.093]   - Field: ‘calls’
[16:05:35.093]   - Field: ‘globals’
[16:05:35.093]   - Field: ‘stdout’
[16:05:35.093]   - Field: ‘earlySignal’
[16:05:35.093]   - Field: ‘lazy’
[16:05:35.093]   - Field: ‘state’
[16:05:35.094] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:35.094] - Launch lazy future ...
[16:05:35.094] Packages needed by the future expression (n = 1): ‘future’
[16:05:35.094] Packages needed by future strategies (n = 1): ‘future’
[16:05:35.095] {
[16:05:35.095]     {
[16:05:35.095]         {
[16:05:35.095]             ...future.startTime <- base::Sys.time()
[16:05:35.095]             {
[16:05:35.095]                 {
[16:05:35.095]                   {
[16:05:35.095]                     {
[16:05:35.095]                       {
[16:05:35.095]                         base::local({
[16:05:35.095]                           has_future <- base::requireNamespace("future", 
[16:05:35.095]                             quietly = TRUE)
[16:05:35.095]                           if (has_future) {
[16:05:35.095]                             ns <- base::getNamespace("future")
[16:05:35.095]                             version <- ns[[".package"]][["version"]]
[16:05:35.095]                             if (is.null(version)) 
[16:05:35.095]                               version <- utils::packageVersion("future")
[16:05:35.095]                           }
[16:05:35.095]                           else {
[16:05:35.095]                             version <- NULL
[16:05:35.095]                           }
[16:05:35.095]                           if (!has_future || version < "1.8.0") {
[16:05:35.095]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:35.095]                               "", base::R.version$version.string), 
[16:05:35.095]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:35.095]                                 base::R.version$platform, 8 * 
[16:05:35.095]                                   base::.Machine$sizeof.pointer), 
[16:05:35.095]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:35.095]                                 "release", "version")], collapse = " "), 
[16:05:35.095]                               hostname = base::Sys.info()[["nodename"]])
[16:05:35.095]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:35.095]                               info)
[16:05:35.095]                             info <- base::paste(info, collapse = "; ")
[16:05:35.095]                             if (!has_future) {
[16:05:35.095]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:35.095]                                 info)
[16:05:35.095]                             }
[16:05:35.095]                             else {
[16:05:35.095]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:35.095]                                 info, version)
[16:05:35.095]                             }
[16:05:35.095]                             base::stop(msg)
[16:05:35.095]                           }
[16:05:35.095]                         })
[16:05:35.095]                       }
[16:05:35.095]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:35.095]                       base::options(mc.cores = 1L)
[16:05:35.095]                     }
[16:05:35.095]                     base::local({
[16:05:35.095]                       for (pkg in "future") {
[16:05:35.095]                         base::loadNamespace(pkg)
[16:05:35.095]                         base::library(pkg, character.only = TRUE)
[16:05:35.095]                       }
[16:05:35.095]                     })
[16:05:35.095]                   }
[16:05:35.095]                   options(future.plan = NULL)
[16:05:35.095]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:35.095]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:05:35.095]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:35.095]                     envir = parent.frame()) 
[16:05:35.095]                   {
[16:05:35.095]                     if (is.function(workers)) 
[16:05:35.095]                       workers <- workers()
[16:05:35.095]                     workers <- structure(as.integer(workers), 
[16:05:35.095]                       class = class(workers))
[16:05:35.095]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:35.095]                       workers >= 1)
[16:05:35.095]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:35.095]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:35.095]                     }
[16:05:35.095]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:35.095]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:35.095]                       envir = envir)
[16:05:35.095]                     if (!future$lazy) 
[16:05:35.095]                       future <- run(future)
[16:05:35.095]                     invisible(future)
[16:05:35.095]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:35.095]                 }
[16:05:35.095]                 ...future.workdir <- getwd()
[16:05:35.095]             }
[16:05:35.095]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:35.095]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:35.095]         }
[16:05:35.095]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:35.095]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:35.095]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:35.095]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:35.095]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:35.095]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:35.095]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:35.095]             base::names(...future.oldOptions))
[16:05:35.095]     }
[16:05:35.095]     if (FALSE) {
[16:05:35.095]     }
[16:05:35.095]     else {
[16:05:35.095]         if (TRUE) {
[16:05:35.095]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:35.095]                 open = "w")
[16:05:35.095]         }
[16:05:35.095]         else {
[16:05:35.095]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:35.095]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:35.095]         }
[16:05:35.095]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:35.095]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:35.095]             base::sink(type = "output", split = FALSE)
[16:05:35.095]             base::close(...future.stdout)
[16:05:35.095]         }, add = TRUE)
[16:05:35.095]     }
[16:05:35.095]     ...future.frame <- base::sys.nframe()
[16:05:35.095]     ...future.conditions <- base::list()
[16:05:35.095]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:35.095]     if (FALSE) {
[16:05:35.095]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:35.095]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:35.095]     }
[16:05:35.095]     ...future.result <- base::tryCatch({
[16:05:35.095]         base::withCallingHandlers({
[16:05:35.095]             ...future.value <- base::withVisible(base::local({
[16:05:35.095]                 ...future.makeSendCondition <- base::local({
[16:05:35.095]                   sendCondition <- NULL
[16:05:35.095]                   function(frame = 1L) {
[16:05:35.095]                     if (is.function(sendCondition)) 
[16:05:35.095]                       return(sendCondition)
[16:05:35.095]                     ns <- getNamespace("parallel")
[16:05:35.095]                     if (exists("sendData", mode = "function", 
[16:05:35.095]                       envir = ns)) {
[16:05:35.095]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:35.095]                         envir = ns)
[16:05:35.095]                       envir <- sys.frame(frame)
[16:05:35.095]                       master <- NULL
[16:05:35.095]                       while (!identical(envir, .GlobalEnv) && 
[16:05:35.095]                         !identical(envir, emptyenv())) {
[16:05:35.095]                         if (exists("master", mode = "list", envir = envir, 
[16:05:35.095]                           inherits = FALSE)) {
[16:05:35.095]                           master <- get("master", mode = "list", 
[16:05:35.095]                             envir = envir, inherits = FALSE)
[16:05:35.095]                           if (inherits(master, c("SOCKnode", 
[16:05:35.095]                             "SOCK0node"))) {
[16:05:35.095]                             sendCondition <<- function(cond) {
[16:05:35.095]                               data <- list(type = "VALUE", value = cond, 
[16:05:35.095]                                 success = TRUE)
[16:05:35.095]                               parallel_sendData(master, data)
[16:05:35.095]                             }
[16:05:35.095]                             return(sendCondition)
[16:05:35.095]                           }
[16:05:35.095]                         }
[16:05:35.095]                         frame <- frame + 1L
[16:05:35.095]                         envir <- sys.frame(frame)
[16:05:35.095]                       }
[16:05:35.095]                     }
[16:05:35.095]                     sendCondition <<- function(cond) NULL
[16:05:35.095]                   }
[16:05:35.095]                 })
[16:05:35.095]                 withCallingHandlers({
[16:05:35.095]                   {
[16:05:35.095]                     a <- 1L
[16:05:35.095]                     plan_a <- unclass(future::plan("list"))
[16:05:35.095]                     nested_a <- nested[-1]
[16:05:35.095]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:05:35.095]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:05:35.095]                       strategy2))
[16:05:35.095]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:05:35.095]                       "init") <- NULL
[16:05:35.095]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:05:35.095]                       "init") <- NULL
[16:05:35.095]                     stopifnot(all.equal(plan_a, nested_a))
[16:05:35.095]                     y %<-% {
[16:05:35.095]                       b <- 2L
[16:05:35.095]                       plan_b <- future::plan("list")
[16:05:35.095]                       nested_b <- nested_a[-1]
[16:05:35.095]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:05:35.095]                         1L, inherits(plan_b[[1]], "future"), 
[16:05:35.095]                         inherits(future::plan("next"), "sequential"))
[16:05:35.095]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:05:35.095]                         b = b, nested_b = nested_b, plan_b = plan_b)
[16:05:35.095]                     }
[16:05:35.095]                     y
[16:05:35.095]                   }
[16:05:35.095]                 }, immediateCondition = function(cond) {
[16:05:35.095]                   sendCondition <- ...future.makeSendCondition()
[16:05:35.095]                   sendCondition(cond)
[16:05:35.095]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:35.095]                   {
[16:05:35.095]                     inherits <- base::inherits
[16:05:35.095]                     invokeRestart <- base::invokeRestart
[16:05:35.095]                     is.null <- base::is.null
[16:05:35.095]                     muffled <- FALSE
[16:05:35.095]                     if (inherits(cond, "message")) {
[16:05:35.095]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:35.095]                       if (muffled) 
[16:05:35.095]                         invokeRestart("muffleMessage")
[16:05:35.095]                     }
[16:05:35.095]                     else if (inherits(cond, "warning")) {
[16:05:35.095]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:35.095]                       if (muffled) 
[16:05:35.095]                         invokeRestart("muffleWarning")
[16:05:35.095]                     }
[16:05:35.095]                     else if (inherits(cond, "condition")) {
[16:05:35.095]                       if (!is.null(pattern)) {
[16:05:35.095]                         computeRestarts <- base::computeRestarts
[16:05:35.095]                         grepl <- base::grepl
[16:05:35.095]                         restarts <- computeRestarts(cond)
[16:05:35.095]                         for (restart in restarts) {
[16:05:35.095]                           name <- restart$name
[16:05:35.095]                           if (is.null(name)) 
[16:05:35.095]                             next
[16:05:35.095]                           if (!grepl(pattern, name)) 
[16:05:35.095]                             next
[16:05:35.095]                           invokeRestart(restart)
[16:05:35.095]                           muffled <- TRUE
[16:05:35.095]                           break
[16:05:35.095]                         }
[16:05:35.095]                       }
[16:05:35.095]                     }
[16:05:35.095]                     invisible(muffled)
[16:05:35.095]                   }
[16:05:35.095]                   muffleCondition(cond)
[16:05:35.095]                 })
[16:05:35.095]             }))
[16:05:35.095]             future::FutureResult(value = ...future.value$value, 
[16:05:35.095]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:35.095]                   ...future.rng), globalenv = if (FALSE) 
[16:05:35.095]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:35.095]                     ...future.globalenv.names))
[16:05:35.095]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:35.095]         }, condition = base::local({
[16:05:35.095]             c <- base::c
[16:05:35.095]             inherits <- base::inherits
[16:05:35.095]             invokeRestart <- base::invokeRestart
[16:05:35.095]             length <- base::length
[16:05:35.095]             list <- base::list
[16:05:35.095]             seq.int <- base::seq.int
[16:05:35.095]             signalCondition <- base::signalCondition
[16:05:35.095]             sys.calls <- base::sys.calls
[16:05:35.095]             `[[` <- base::`[[`
[16:05:35.095]             `+` <- base::`+`
[16:05:35.095]             `<<-` <- base::`<<-`
[16:05:35.095]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:35.095]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:35.095]                   3L)]
[16:05:35.095]             }
[16:05:35.095]             function(cond) {
[16:05:35.095]                 is_error <- inherits(cond, "error")
[16:05:35.095]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:35.095]                   NULL)
[16:05:35.095]                 if (is_error) {
[16:05:35.095]                   sessionInformation <- function() {
[16:05:35.095]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:35.095]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:35.095]                       search = base::search(), system = base::Sys.info())
[16:05:35.095]                   }
[16:05:35.095]                   ...future.conditions[[length(...future.conditions) + 
[16:05:35.095]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:35.095]                     cond$call), session = sessionInformation(), 
[16:05:35.095]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:35.095]                   signalCondition(cond)
[16:05:35.095]                 }
[16:05:35.095]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:35.095]                 "immediateCondition"))) {
[16:05:35.095]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:35.095]                   ...future.conditions[[length(...future.conditions) + 
[16:05:35.095]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:35.095]                   if (TRUE && !signal) {
[16:05:35.095]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:35.095]                     {
[16:05:35.095]                       inherits <- base::inherits
[16:05:35.095]                       invokeRestart <- base::invokeRestart
[16:05:35.095]                       is.null <- base::is.null
[16:05:35.095]                       muffled <- FALSE
[16:05:35.095]                       if (inherits(cond, "message")) {
[16:05:35.095]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:35.095]                         if (muffled) 
[16:05:35.095]                           invokeRestart("muffleMessage")
[16:05:35.095]                       }
[16:05:35.095]                       else if (inherits(cond, "warning")) {
[16:05:35.095]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:35.095]                         if (muffled) 
[16:05:35.095]                           invokeRestart("muffleWarning")
[16:05:35.095]                       }
[16:05:35.095]                       else if (inherits(cond, "condition")) {
[16:05:35.095]                         if (!is.null(pattern)) {
[16:05:35.095]                           computeRestarts <- base::computeRestarts
[16:05:35.095]                           grepl <- base::grepl
[16:05:35.095]                           restarts <- computeRestarts(cond)
[16:05:35.095]                           for (restart in restarts) {
[16:05:35.095]                             name <- restart$name
[16:05:35.095]                             if (is.null(name)) 
[16:05:35.095]                               next
[16:05:35.095]                             if (!grepl(pattern, name)) 
[16:05:35.095]                               next
[16:05:35.095]                             invokeRestart(restart)
[16:05:35.095]                             muffled <- TRUE
[16:05:35.095]                             break
[16:05:35.095]                           }
[16:05:35.095]                         }
[16:05:35.095]                       }
[16:05:35.095]                       invisible(muffled)
[16:05:35.095]                     }
[16:05:35.095]                     muffleCondition(cond, pattern = "^muffle")
[16:05:35.095]                   }
[16:05:35.095]                 }
[16:05:35.095]                 else {
[16:05:35.095]                   if (TRUE) {
[16:05:35.095]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:35.095]                     {
[16:05:35.095]                       inherits <- base::inherits
[16:05:35.095]                       invokeRestart <- base::invokeRestart
[16:05:35.095]                       is.null <- base::is.null
[16:05:35.095]                       muffled <- FALSE
[16:05:35.095]                       if (inherits(cond, "message")) {
[16:05:35.095]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:35.095]                         if (muffled) 
[16:05:35.095]                           invokeRestart("muffleMessage")
[16:05:35.095]                       }
[16:05:35.095]                       else if (inherits(cond, "warning")) {
[16:05:35.095]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:35.095]                         if (muffled) 
[16:05:35.095]                           invokeRestart("muffleWarning")
[16:05:35.095]                       }
[16:05:35.095]                       else if (inherits(cond, "condition")) {
[16:05:35.095]                         if (!is.null(pattern)) {
[16:05:35.095]                           computeRestarts <- base::computeRestarts
[16:05:35.095]                           grepl <- base::grepl
[16:05:35.095]                           restarts <- computeRestarts(cond)
[16:05:35.095]                           for (restart in restarts) {
[16:05:35.095]                             name <- restart$name
[16:05:35.095]                             if (is.null(name)) 
[16:05:35.095]                               next
[16:05:35.095]                             if (!grepl(pattern, name)) 
[16:05:35.095]                               next
[16:05:35.095]                             invokeRestart(restart)
[16:05:35.095]                             muffled <- TRUE
[16:05:35.095]                             break
[16:05:35.095]                           }
[16:05:35.095]                         }
[16:05:35.095]                       }
[16:05:35.095]                       invisible(muffled)
[16:05:35.095]                     }
[16:05:35.095]                     muffleCondition(cond, pattern = "^muffle")
[16:05:35.095]                   }
[16:05:35.095]                 }
[16:05:35.095]             }
[16:05:35.095]         }))
[16:05:35.095]     }, error = function(ex) {
[16:05:35.095]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:35.095]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:35.095]                 ...future.rng), started = ...future.startTime, 
[16:05:35.095]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:35.095]             version = "1.8"), class = "FutureResult")
[16:05:35.095]     }, finally = {
[16:05:35.095]         if (!identical(...future.workdir, getwd())) 
[16:05:35.095]             setwd(...future.workdir)
[16:05:35.095]         {
[16:05:35.095]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:35.095]                 ...future.oldOptions$nwarnings <- NULL
[16:05:35.095]             }
[16:05:35.095]             base::options(...future.oldOptions)
[16:05:35.095]             if (.Platform$OS.type == "windows") {
[16:05:35.095]                 old_names <- names(...future.oldEnvVars)
[16:05:35.095]                 envs <- base::Sys.getenv()
[16:05:35.095]                 names <- names(envs)
[16:05:35.095]                 common <- intersect(names, old_names)
[16:05:35.095]                 added <- setdiff(names, old_names)
[16:05:35.095]                 removed <- setdiff(old_names, names)
[16:05:35.095]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:35.095]                   envs[common]]
[16:05:35.095]                 NAMES <- toupper(changed)
[16:05:35.095]                 args <- list()
[16:05:35.095]                 for (kk in seq_along(NAMES)) {
[16:05:35.095]                   name <- changed[[kk]]
[16:05:35.095]                   NAME <- NAMES[[kk]]
[16:05:35.095]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:35.095]                     next
[16:05:35.095]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:35.095]                 }
[16:05:35.095]                 NAMES <- toupper(added)
[16:05:35.095]                 for (kk in seq_along(NAMES)) {
[16:05:35.095]                   name <- added[[kk]]
[16:05:35.095]                   NAME <- NAMES[[kk]]
[16:05:35.095]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:35.095]                     next
[16:05:35.095]                   args[[name]] <- ""
[16:05:35.095]                 }
[16:05:35.095]                 NAMES <- toupper(removed)
[16:05:35.095]                 for (kk in seq_along(NAMES)) {
[16:05:35.095]                   name <- removed[[kk]]
[16:05:35.095]                   NAME <- NAMES[[kk]]
[16:05:35.095]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:35.095]                     next
[16:05:35.095]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:35.095]                 }
[16:05:35.095]                 if (length(args) > 0) 
[16:05:35.095]                   base::do.call(base::Sys.setenv, args = args)
[16:05:35.095]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:35.095]             }
[16:05:35.095]             else {
[16:05:35.095]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:35.095]             }
[16:05:35.095]             {
[16:05:35.095]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:35.095]                   0L) {
[16:05:35.095]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:35.095]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:35.095]                   base::options(opts)
[16:05:35.095]                 }
[16:05:35.095]                 {
[16:05:35.095]                   {
[16:05:35.095]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:35.095]                     NULL
[16:05:35.095]                   }
[16:05:35.095]                   options(future.plan = NULL)
[16:05:35.095]                   if (is.na(NA_character_)) 
[16:05:35.095]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:35.095]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:35.095]                   future::plan(list(a = function (..., workers = availableCores(), 
[16:05:35.095]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:35.095]                     envir = parent.frame()) 
[16:05:35.095]                   {
[16:05:35.095]                     if (is.function(workers)) 
[16:05:35.095]                       workers <- workers()
[16:05:35.095]                     workers <- structure(as.integer(workers), 
[16:05:35.095]                       class = class(workers))
[16:05:35.095]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:35.095]                       workers >= 1)
[16:05:35.095]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:35.095]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:35.095]                     }
[16:05:35.095]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:35.095]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:35.095]                       envir = envir)
[16:05:35.095]                     if (!future$lazy) 
[16:05:35.095]                       future <- run(future)
[16:05:35.095]                     invisible(future)
[16:05:35.095]                   }, b = function (..., workers = availableCores(), 
[16:05:35.095]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:35.095]                     envir = parent.frame()) 
[16:05:35.095]                   {
[16:05:35.095]                     if (is.function(workers)) 
[16:05:35.095]                       workers <- workers()
[16:05:35.095]                     workers <- structure(as.integer(workers), 
[16:05:35.095]                       class = class(workers))
[16:05:35.095]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:35.095]                       workers >= 1)
[16:05:35.095]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:35.095]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:35.095]                     }
[16:05:35.095]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:35.095]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:35.095]                       envir = envir)
[16:05:35.095]                     if (!future$lazy) 
[16:05:35.095]                       future <- run(future)
[16:05:35.095]                     invisible(future)
[16:05:35.095]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:35.095]                 }
[16:05:35.095]             }
[16:05:35.095]         }
[16:05:35.095]     })
[16:05:35.095]     if (TRUE) {
[16:05:35.095]         base::sink(type = "output", split = FALSE)
[16:05:35.095]         if (TRUE) {
[16:05:35.095]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:35.095]         }
[16:05:35.095]         else {
[16:05:35.095]             ...future.result["stdout"] <- base::list(NULL)
[16:05:35.095]         }
[16:05:35.095]         base::close(...future.stdout)
[16:05:35.095]         ...future.stdout <- NULL
[16:05:35.095]     }
[16:05:35.095]     ...future.result$conditions <- ...future.conditions
[16:05:35.095]     ...future.result$finished <- base::Sys.time()
[16:05:35.095]     ...future.result
[16:05:35.095] }
[16:05:35.098] Exporting 2 global objects (88.27 KiB) to cluster node #1 ...
[16:05:35.098] Exporting ‘nested’ (88.15 KiB) to cluster node #1 ...
[16:05:35.139] Exporting ‘nested’ (88.15 KiB) to cluster node #1 ... DONE
[16:05:35.139] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[16:05:35.140] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[16:05:35.140] Exporting 2 global objects (88.27 KiB) to cluster node #1 ... DONE
[16:05:35.141] MultisessionFuture started
[16:05:35.141] - Launch lazy future ... done
[16:05:35.141] run() for ‘MultisessionFuture’ ... done
[16:05:35.141] result() for ClusterFuture ...
[16:05:35.141] receiveMessageFromWorker() for ClusterFuture ...
[16:05:35.141] - Validating connection of MultisessionFuture
[16:05:35.216] - received message: FutureResult
[16:05:35.216] - Received FutureResult
[16:05:35.216] - Erased future from FutureRegistry
[16:05:35.216] result() for ClusterFuture ...
[16:05:35.216] - result already collected: FutureResult
[16:05:35.216] result() for ClusterFuture ... done
[16:05:35.217] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:35.217] result() for ClusterFuture ... done
[16:05:35.217] result() for ClusterFuture ...
[16:05:35.217] - result already collected: FutureResult
[16:05:35.217] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:05:35.223] getGlobalsAndPackages() ...
[16:05:35.223] Searching for globals...
[16:05:35.224] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:05:35.224] Searching for globals ... DONE
[16:05:35.224] Resolving globals: FALSE
[16:05:35.225] The total size of the 1 globals is 128 bytes (128 bytes)
[16:05:35.225] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:05:35.225] - globals: [1] ‘data’
[16:05:35.225] - packages: [1] ‘future’
[16:05:35.225] getGlobalsAndPackages() ... DONE
[16:05:35.226] run() for ‘Future’ ...
[16:05:35.226] - state: ‘created’
[16:05:35.226] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:35.239] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:35.240] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:35.240]   - Field: ‘node’
[16:05:35.240]   - Field: ‘label’
[16:05:35.240]   - Field: ‘local’
[16:05:35.240]   - Field: ‘owner’
[16:05:35.240]   - Field: ‘envir’
[16:05:35.240]   - Field: ‘workers’
[16:05:35.240]   - Field: ‘packages’
[16:05:35.240]   - Field: ‘gc’
[16:05:35.240]   - Field: ‘conditions’
[16:05:35.241]   - Field: ‘persistent’
[16:05:35.241]   - Field: ‘expr’
[16:05:35.241]   - Field: ‘uuid’
[16:05:35.241]   - Field: ‘seed’
[16:05:35.241]   - Field: ‘version’
[16:05:35.241]   - Field: ‘result’
[16:05:35.243]   - Field: ‘asynchronous’
[16:05:35.243]   - Field: ‘calls’
[16:05:35.243]   - Field: ‘globals’
[16:05:35.244]   - Field: ‘stdout’
[16:05:35.244]   - Field: ‘earlySignal’
[16:05:35.244]   - Field: ‘lazy’
[16:05:35.244]   - Field: ‘state’
[16:05:35.244] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:35.244] - Launch lazy future ...
[16:05:35.244] Packages needed by the future expression (n = 1): ‘future’
[16:05:35.244] Packages needed by future strategies (n = 1): ‘future’
[16:05:35.245] {
[16:05:35.245]     {
[16:05:35.245]         {
[16:05:35.245]             ...future.startTime <- base::Sys.time()
[16:05:35.245]             {
[16:05:35.245]                 {
[16:05:35.245]                   {
[16:05:35.245]                     {
[16:05:35.245]                       {
[16:05:35.245]                         base::local({
[16:05:35.245]                           has_future <- base::requireNamespace("future", 
[16:05:35.245]                             quietly = TRUE)
[16:05:35.245]                           if (has_future) {
[16:05:35.245]                             ns <- base::getNamespace("future")
[16:05:35.245]                             version <- ns[[".package"]][["version"]]
[16:05:35.245]                             if (is.null(version)) 
[16:05:35.245]                               version <- utils::packageVersion("future")
[16:05:35.245]                           }
[16:05:35.245]                           else {
[16:05:35.245]                             version <- NULL
[16:05:35.245]                           }
[16:05:35.245]                           if (!has_future || version < "1.8.0") {
[16:05:35.245]                             info <- base::c(r_version = base::gsub("R version ", 
[16:05:35.245]                               "", base::R.version$version.string), 
[16:05:35.245]                               platform = base::sprintf("%s (%s-bit)", 
[16:05:35.245]                                 base::R.version$platform, 8 * 
[16:05:35.245]                                   base::.Machine$sizeof.pointer), 
[16:05:35.245]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:35.245]                                 "release", "version")], collapse = " "), 
[16:05:35.245]                               hostname = base::Sys.info()[["nodename"]])
[16:05:35.245]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:05:35.245]                               info)
[16:05:35.245]                             info <- base::paste(info, collapse = "; ")
[16:05:35.245]                             if (!has_future) {
[16:05:35.245]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:35.245]                                 info)
[16:05:35.245]                             }
[16:05:35.245]                             else {
[16:05:35.245]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:35.245]                                 info, version)
[16:05:35.245]                             }
[16:05:35.245]                             base::stop(msg)
[16:05:35.245]                           }
[16:05:35.245]                         })
[16:05:35.245]                       }
[16:05:35.245]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:35.245]                       base::options(mc.cores = 1L)
[16:05:35.245]                     }
[16:05:35.245]                     base::local({
[16:05:35.245]                       for (pkg in "future") {
[16:05:35.245]                         base::loadNamespace(pkg)
[16:05:35.245]                         base::library(pkg, character.only = TRUE)
[16:05:35.245]                       }
[16:05:35.245]                     })
[16:05:35.245]                   }
[16:05:35.245]                   options(future.plan = NULL)
[16:05:35.245]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:35.245]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:05:35.245]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:35.245]                     envir = parent.frame()) 
[16:05:35.245]                   {
[16:05:35.245]                     if (is.function(workers)) 
[16:05:35.245]                       workers <- workers()
[16:05:35.245]                     workers <- structure(as.integer(workers), 
[16:05:35.245]                       class = class(workers))
[16:05:35.245]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:35.245]                       workers >= 1)
[16:05:35.245]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:35.245]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:35.245]                     }
[16:05:35.245]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:35.245]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:35.245]                       envir = envir)
[16:05:35.245]                     if (!future$lazy) 
[16:05:35.245]                       future <- run(future)
[16:05:35.245]                     invisible(future)
[16:05:35.245]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:35.245]                 }
[16:05:35.245]                 ...future.workdir <- getwd()
[16:05:35.245]             }
[16:05:35.245]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:35.245]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:35.245]         }
[16:05:35.245]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:35.245]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:35.245]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:35.245]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:35.245]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:35.245]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:35.245]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:35.245]             base::names(...future.oldOptions))
[16:05:35.245]     }
[16:05:35.245]     if (FALSE) {
[16:05:35.245]     }
[16:05:35.245]     else {
[16:05:35.245]         if (TRUE) {
[16:05:35.245]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:35.245]                 open = "w")
[16:05:35.245]         }
[16:05:35.245]         else {
[16:05:35.245]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:35.245]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:35.245]         }
[16:05:35.245]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:35.245]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:35.245]             base::sink(type = "output", split = FALSE)
[16:05:35.245]             base::close(...future.stdout)
[16:05:35.245]         }, add = TRUE)
[16:05:35.245]     }
[16:05:35.245]     ...future.frame <- base::sys.nframe()
[16:05:35.245]     ...future.conditions <- base::list()
[16:05:35.245]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:35.245]     if (FALSE) {
[16:05:35.245]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:35.245]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:35.245]     }
[16:05:35.245]     ...future.result <- base::tryCatch({
[16:05:35.245]         base::withCallingHandlers({
[16:05:35.245]             ...future.value <- base::withVisible(base::local({
[16:05:35.245]                 ...future.makeSendCondition <- base::local({
[16:05:35.245]                   sendCondition <- NULL
[16:05:35.245]                   function(frame = 1L) {
[16:05:35.245]                     if (is.function(sendCondition)) 
[16:05:35.245]                       return(sendCondition)
[16:05:35.245]                     ns <- getNamespace("parallel")
[16:05:35.245]                     if (exists("sendData", mode = "function", 
[16:05:35.245]                       envir = ns)) {
[16:05:35.245]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:35.245]                         envir = ns)
[16:05:35.245]                       envir <- sys.frame(frame)
[16:05:35.245]                       master <- NULL
[16:05:35.245]                       while (!identical(envir, .GlobalEnv) && 
[16:05:35.245]                         !identical(envir, emptyenv())) {
[16:05:35.245]                         if (exists("master", mode = "list", envir = envir, 
[16:05:35.245]                           inherits = FALSE)) {
[16:05:35.245]                           master <- get("master", mode = "list", 
[16:05:35.245]                             envir = envir, inherits = FALSE)
[16:05:35.245]                           if (inherits(master, c("SOCKnode", 
[16:05:35.245]                             "SOCK0node"))) {
[16:05:35.245]                             sendCondition <<- function(cond) {
[16:05:35.245]                               data <- list(type = "VALUE", value = cond, 
[16:05:35.245]                                 success = TRUE)
[16:05:35.245]                               parallel_sendData(master, data)
[16:05:35.245]                             }
[16:05:35.245]                             return(sendCondition)
[16:05:35.245]                           }
[16:05:35.245]                         }
[16:05:35.245]                         frame <- frame + 1L
[16:05:35.245]                         envir <- sys.frame(frame)
[16:05:35.245]                       }
[16:05:35.245]                     }
[16:05:35.245]                     sendCondition <<- function(cond) NULL
[16:05:35.245]                   }
[16:05:35.245]                 })
[16:05:35.245]                 withCallingHandlers({
[16:05:35.245]                   {
[16:05:35.245]                     value(future(subset(data, a == 2)))
[16:05:35.245]                   }
[16:05:35.245]                 }, immediateCondition = function(cond) {
[16:05:35.245]                   sendCondition <- ...future.makeSendCondition()
[16:05:35.245]                   sendCondition(cond)
[16:05:35.245]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:35.245]                   {
[16:05:35.245]                     inherits <- base::inherits
[16:05:35.245]                     invokeRestart <- base::invokeRestart
[16:05:35.245]                     is.null <- base::is.null
[16:05:35.245]                     muffled <- FALSE
[16:05:35.245]                     if (inherits(cond, "message")) {
[16:05:35.245]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:35.245]                       if (muffled) 
[16:05:35.245]                         invokeRestart("muffleMessage")
[16:05:35.245]                     }
[16:05:35.245]                     else if (inherits(cond, "warning")) {
[16:05:35.245]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:35.245]                       if (muffled) 
[16:05:35.245]                         invokeRestart("muffleWarning")
[16:05:35.245]                     }
[16:05:35.245]                     else if (inherits(cond, "condition")) {
[16:05:35.245]                       if (!is.null(pattern)) {
[16:05:35.245]                         computeRestarts <- base::computeRestarts
[16:05:35.245]                         grepl <- base::grepl
[16:05:35.245]                         restarts <- computeRestarts(cond)
[16:05:35.245]                         for (restart in restarts) {
[16:05:35.245]                           name <- restart$name
[16:05:35.245]                           if (is.null(name)) 
[16:05:35.245]                             next
[16:05:35.245]                           if (!grepl(pattern, name)) 
[16:05:35.245]                             next
[16:05:35.245]                           invokeRestart(restart)
[16:05:35.245]                           muffled <- TRUE
[16:05:35.245]                           break
[16:05:35.245]                         }
[16:05:35.245]                       }
[16:05:35.245]                     }
[16:05:35.245]                     invisible(muffled)
[16:05:35.245]                   }
[16:05:35.245]                   muffleCondition(cond)
[16:05:35.245]                 })
[16:05:35.245]             }))
[16:05:35.245]             future::FutureResult(value = ...future.value$value, 
[16:05:35.245]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:35.245]                   ...future.rng), globalenv = if (FALSE) 
[16:05:35.245]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:35.245]                     ...future.globalenv.names))
[16:05:35.245]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:35.245]         }, condition = base::local({
[16:05:35.245]             c <- base::c
[16:05:35.245]             inherits <- base::inherits
[16:05:35.245]             invokeRestart <- base::invokeRestart
[16:05:35.245]             length <- base::length
[16:05:35.245]             list <- base::list
[16:05:35.245]             seq.int <- base::seq.int
[16:05:35.245]             signalCondition <- base::signalCondition
[16:05:35.245]             sys.calls <- base::sys.calls
[16:05:35.245]             `[[` <- base::`[[`
[16:05:35.245]             `+` <- base::`+`
[16:05:35.245]             `<<-` <- base::`<<-`
[16:05:35.245]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:35.245]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:35.245]                   3L)]
[16:05:35.245]             }
[16:05:35.245]             function(cond) {
[16:05:35.245]                 is_error <- inherits(cond, "error")
[16:05:35.245]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:35.245]                   NULL)
[16:05:35.245]                 if (is_error) {
[16:05:35.245]                   sessionInformation <- function() {
[16:05:35.245]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:35.245]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:35.245]                       search = base::search(), system = base::Sys.info())
[16:05:35.245]                   }
[16:05:35.245]                   ...future.conditions[[length(...future.conditions) + 
[16:05:35.245]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:35.245]                     cond$call), session = sessionInformation(), 
[16:05:35.245]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:35.245]                   signalCondition(cond)
[16:05:35.245]                 }
[16:05:35.245]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:35.245]                 "immediateCondition"))) {
[16:05:35.245]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:35.245]                   ...future.conditions[[length(...future.conditions) + 
[16:05:35.245]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:35.245]                   if (TRUE && !signal) {
[16:05:35.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:35.245]                     {
[16:05:35.245]                       inherits <- base::inherits
[16:05:35.245]                       invokeRestart <- base::invokeRestart
[16:05:35.245]                       is.null <- base::is.null
[16:05:35.245]                       muffled <- FALSE
[16:05:35.245]                       if (inherits(cond, "message")) {
[16:05:35.245]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:35.245]                         if (muffled) 
[16:05:35.245]                           invokeRestart("muffleMessage")
[16:05:35.245]                       }
[16:05:35.245]                       else if (inherits(cond, "warning")) {
[16:05:35.245]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:35.245]                         if (muffled) 
[16:05:35.245]                           invokeRestart("muffleWarning")
[16:05:35.245]                       }
[16:05:35.245]                       else if (inherits(cond, "condition")) {
[16:05:35.245]                         if (!is.null(pattern)) {
[16:05:35.245]                           computeRestarts <- base::computeRestarts
[16:05:35.245]                           grepl <- base::grepl
[16:05:35.245]                           restarts <- computeRestarts(cond)
[16:05:35.245]                           for (restart in restarts) {
[16:05:35.245]                             name <- restart$name
[16:05:35.245]                             if (is.null(name)) 
[16:05:35.245]                               next
[16:05:35.245]                             if (!grepl(pattern, name)) 
[16:05:35.245]                               next
[16:05:35.245]                             invokeRestart(restart)
[16:05:35.245]                             muffled <- TRUE
[16:05:35.245]                             break
[16:05:35.245]                           }
[16:05:35.245]                         }
[16:05:35.245]                       }
[16:05:35.245]                       invisible(muffled)
[16:05:35.245]                     }
[16:05:35.245]                     muffleCondition(cond, pattern = "^muffle")
[16:05:35.245]                   }
[16:05:35.245]                 }
[16:05:35.245]                 else {
[16:05:35.245]                   if (TRUE) {
[16:05:35.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:35.245]                     {
[16:05:35.245]                       inherits <- base::inherits
[16:05:35.245]                       invokeRestart <- base::invokeRestart
[16:05:35.245]                       is.null <- base::is.null
[16:05:35.245]                       muffled <- FALSE
[16:05:35.245]                       if (inherits(cond, "message")) {
[16:05:35.245]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:35.245]                         if (muffled) 
[16:05:35.245]                           invokeRestart("muffleMessage")
[16:05:35.245]                       }
[16:05:35.245]                       else if (inherits(cond, "warning")) {
[16:05:35.245]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:35.245]                         if (muffled) 
[16:05:35.245]                           invokeRestart("muffleWarning")
[16:05:35.245]                       }
[16:05:35.245]                       else if (inherits(cond, "condition")) {
[16:05:35.245]                         if (!is.null(pattern)) {
[16:05:35.245]                           computeRestarts <- base::computeRestarts
[16:05:35.245]                           grepl <- base::grepl
[16:05:35.245]                           restarts <- computeRestarts(cond)
[16:05:35.245]                           for (restart in restarts) {
[16:05:35.245]                             name <- restart$name
[16:05:35.245]                             if (is.null(name)) 
[16:05:35.245]                               next
[16:05:35.245]                             if (!grepl(pattern, name)) 
[16:05:35.245]                               next
[16:05:35.245]                             invokeRestart(restart)
[16:05:35.245]                             muffled <- TRUE
[16:05:35.245]                             break
[16:05:35.245]                           }
[16:05:35.245]                         }
[16:05:35.245]                       }
[16:05:35.245]                       invisible(muffled)
[16:05:35.245]                     }
[16:05:35.245]                     muffleCondition(cond, pattern = "^muffle")
[16:05:35.245]                   }
[16:05:35.245]                 }
[16:05:35.245]             }
[16:05:35.245]         }))
[16:05:35.245]     }, error = function(ex) {
[16:05:35.245]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:35.245]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:35.245]                 ...future.rng), started = ...future.startTime, 
[16:05:35.245]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:35.245]             version = "1.8"), class = "FutureResult")
[16:05:35.245]     }, finally = {
[16:05:35.245]         if (!identical(...future.workdir, getwd())) 
[16:05:35.245]             setwd(...future.workdir)
[16:05:35.245]         {
[16:05:35.245]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:35.245]                 ...future.oldOptions$nwarnings <- NULL
[16:05:35.245]             }
[16:05:35.245]             base::options(...future.oldOptions)
[16:05:35.245]             if (.Platform$OS.type == "windows") {
[16:05:35.245]                 old_names <- names(...future.oldEnvVars)
[16:05:35.245]                 envs <- base::Sys.getenv()
[16:05:35.245]                 names <- names(envs)
[16:05:35.245]                 common <- intersect(names, old_names)
[16:05:35.245]                 added <- setdiff(names, old_names)
[16:05:35.245]                 removed <- setdiff(old_names, names)
[16:05:35.245]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:35.245]                   envs[common]]
[16:05:35.245]                 NAMES <- toupper(changed)
[16:05:35.245]                 args <- list()
[16:05:35.245]                 for (kk in seq_along(NAMES)) {
[16:05:35.245]                   name <- changed[[kk]]
[16:05:35.245]                   NAME <- NAMES[[kk]]
[16:05:35.245]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:35.245]                     next
[16:05:35.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:35.245]                 }
[16:05:35.245]                 NAMES <- toupper(added)
[16:05:35.245]                 for (kk in seq_along(NAMES)) {
[16:05:35.245]                   name <- added[[kk]]
[16:05:35.245]                   NAME <- NAMES[[kk]]
[16:05:35.245]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:35.245]                     next
[16:05:35.245]                   args[[name]] <- ""
[16:05:35.245]                 }
[16:05:35.245]                 NAMES <- toupper(removed)
[16:05:35.245]                 for (kk in seq_along(NAMES)) {
[16:05:35.245]                   name <- removed[[kk]]
[16:05:35.245]                   NAME <- NAMES[[kk]]
[16:05:35.245]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:35.245]                     next
[16:05:35.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:35.245]                 }
[16:05:35.245]                 if (length(args) > 0) 
[16:05:35.245]                   base::do.call(base::Sys.setenv, args = args)
[16:05:35.245]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:35.245]             }
[16:05:35.245]             else {
[16:05:35.245]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:35.245]             }
[16:05:35.245]             {
[16:05:35.245]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:35.245]                   0L) {
[16:05:35.245]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:35.245]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:35.245]                   base::options(opts)
[16:05:35.245]                 }
[16:05:35.245]                 {
[16:05:35.245]                   {
[16:05:35.245]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:35.245]                     NULL
[16:05:35.245]                   }
[16:05:35.245]                   options(future.plan = NULL)
[16:05:35.245]                   if (is.na(NA_character_)) 
[16:05:35.245]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:35.245]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:35.245]                   future::plan(list(a = function (..., workers = availableCores(), 
[16:05:35.245]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:35.245]                     envir = parent.frame()) 
[16:05:35.245]                   {
[16:05:35.245]                     if (is.function(workers)) 
[16:05:35.245]                       workers <- workers()
[16:05:35.245]                     workers <- structure(as.integer(workers), 
[16:05:35.245]                       class = class(workers))
[16:05:35.245]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:35.245]                       workers >= 1)
[16:05:35.245]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:35.245]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:35.245]                     }
[16:05:35.245]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:35.245]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:35.245]                       envir = envir)
[16:05:35.245]                     if (!future$lazy) 
[16:05:35.245]                       future <- run(future)
[16:05:35.245]                     invisible(future)
[16:05:35.245]                   }, b = function (..., workers = availableCores(), 
[16:05:35.245]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:35.245]                     envir = parent.frame()) 
[16:05:35.245]                   {
[16:05:35.245]                     if (is.function(workers)) 
[16:05:35.245]                       workers <- workers()
[16:05:35.245]                     workers <- structure(as.integer(workers), 
[16:05:35.245]                       class = class(workers))
[16:05:35.245]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:35.245]                       workers >= 1)
[16:05:35.245]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:35.245]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:35.245]                     }
[16:05:35.245]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:35.245]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:35.245]                       envir = envir)
[16:05:35.245]                     if (!future$lazy) 
[16:05:35.245]                       future <- run(future)
[16:05:35.245]                     invisible(future)
[16:05:35.245]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:35.245]                 }
[16:05:35.245]             }
[16:05:35.245]         }
[16:05:35.245]     })
[16:05:35.245]     if (TRUE) {
[16:05:35.245]         base::sink(type = "output", split = FALSE)
[16:05:35.245]         if (TRUE) {
[16:05:35.245]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:35.245]         }
[16:05:35.245]         else {
[16:05:35.245]             ...future.result["stdout"] <- base::list(NULL)
[16:05:35.245]         }
[16:05:35.245]         base::close(...future.stdout)
[16:05:35.245]         ...future.stdout <- NULL
[16:05:35.245]     }
[16:05:35.245]     ...future.result$conditions <- ...future.conditions
[16:05:35.245]     ...future.result$finished <- base::Sys.time()
[16:05:35.245]     ...future.result
[16:05:35.245] }
[16:05:35.248] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[16:05:35.248] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[16:05:35.248] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[16:05:35.249] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[16:05:35.249] MultisessionFuture started
[16:05:35.249] - Launch lazy future ... done
[16:05:35.249] run() for ‘MultisessionFuture’ ... done
[16:05:35.250] result() for ClusterFuture ...
[16:05:35.250] receiveMessageFromWorker() for ClusterFuture ...
[16:05:35.250] - Validating connection of MultisessionFuture
[16:05:35.311] - received message: FutureResult
[16:05:35.311] - Received FutureResult
[16:05:35.311] - Erased future from FutureRegistry
[16:05:35.311] result() for ClusterFuture ...
[16:05:35.311] - result already collected: FutureResult
[16:05:35.311] result() for ClusterFuture ... done
[16:05:35.312] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:35.312] result() for ClusterFuture ... done
[16:05:35.312] result() for ClusterFuture ...
[16:05:35.312] - result already collected: FutureResult
[16:05:35.312] result() for ClusterFuture ... done
- plan(list('multisession', 'multisession')) ... DONE
> 
> message("*** Nested futures ... DONE")
*** Nested futures ... DONE
> 
> source("incl/end.R")
[16:05:35.313] plan(): Setting new future strategy stack:
[16:05:35.313] List of future strategies:
[16:05:35.313] 1. FutureStrategy:
[16:05:35.313]    - args: function (..., envir = parent.frame())
[16:05:35.313]    - tweaked: FALSE
[16:05:35.313]    - call: future::plan(oplan)
[16:05:35.313] plan(): nbrOfWorkers() = 1
> 
